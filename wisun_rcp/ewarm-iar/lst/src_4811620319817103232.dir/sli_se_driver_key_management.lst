###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:06
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_management.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_key_management.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_management.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_key_management.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sli_se_driver_key_management.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_key_management.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_management.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Driver Key Management functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t psa_get_key_lifetime(psa_key_attributes_t const *)
   \                     psa_get_key_lifetime: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     36          
     37          #include "sli_se_opaque_types.h"
     38          #include "sli_se_opaque_functions.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void sli_se_key_descriptor_set_plaintext(struct <unnamed>#128 *, uint8_t const *, size_t)
   \                     sli_se_key_descriptor_set_plaintext: (+1)
   \        0x0   0x1CD2             ADDS     R2,R2,#+3
   \        0x2   0x0892             LSRS     R2,R2,#+2
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x0092             LSLS     R2,R2,#+2
   \        0x8   0x60C3             STR      R3,[R0, #+12]
   \        0xA   0x6101             STR      R1,[R0, #+16]
   \        0xC   0x6142             STR      R2,[R0, #+20]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t sli_se_has_format_byte(uint16_t)
   \                     sli_se_has_format_byte: (+1)
   \        0x0   0xF020 0x03FF      BIC      R3,R0,#0xFF
   \        0x4   0xF5B3 0x4F82      CMP      R3,#+16640
   \        0x8   0xD10E             BNE.N    ??sli_se_has_format_byte_0
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable22
   \        0xE   0xEA01 0x0200      AND      R2,R1,R0
   \       0x12   0xF5B2 0x4F82      CMP      R2,#+16640
   \       0x16   0xD105             BNE.N    ??sli_se_has_format_byte_1
   \       0x18   0xB2C1             UXTB     R1,R0
   \       0x1A   0x2941             CMP      R1,#+65
   \       0x1C   0xBF1C             ITT      NE
   \       0x1E   0xB2C0             UXTBNE   R0,R0
   \       0x20   0x2842             CMPNE    R0,#+66
   \       0x22   0xD001             BEQ.N    ??sli_se_has_format_byte_0
   \                     ??sli_se_has_format_byte_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x4770             BX       LR
   \                     ??sli_se_has_format_byte_0: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x4770             BX       LR
     39          #include "sli_se_driver_key_management.h"
     40          #include "sli_psa_driver_common.h"  // sli_psa_zeroize()
     41          #include "sli_se_version_dependencies.h"
     42          
     43          #include "sl_se_manager_key_derivation.h"
     44          #include "sl_se_manager_internal_keys.h"
     45          #include "sl_se_manager_util.h"
     46          #include "sli_se_manager_internal.h"
     47          
     48          #include <string.h>
     49          
     50          // -----------------------------------------------------------------------------
     51          // Static constants
     52          
     53          #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
     54          static const uint8_t ecc_p192_n[] = {
     55            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0xde, 0xf8, 0x36, 0x14, 0x6b, 0xc9, 0xb1, 0xb4, 0xd2, 0x28, 0x31
     56          };
     57          #endif
     58          
     59          #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
     60          static const uint8_t ecc_p224_n[] = {
     61            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0xa2, 0xe0, 0xb8, 0xf0, 0x3e, 0x13, 0xdd, 0x29, 0x45, 0x5c, 0x5c, 0x2a, 0x3d
     62          };
     63          #endif
     64          
     65          #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)

   \                                 In section .text, align 4, keep-with-next
     66          static const uint8_t ecc_p256_n[] = {
   \                     ecc_p256_n:
   \        0x0   0xFF 0xFF          DC8 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF
   \        0xF   0xFF 0xBC          DC8 255, 188, 230, 250, 173, 167, 23, 158, 132, 243, 185, 202, 194, 252
   \              0xE6 0xFA    
   \              0xAD 0xA7    
   \              0x17 0x9E    
   \              0x84 0xF3    
   \              0xB9 0xCA    
   \              0xC2 0xFC
   \       0x1D   0x63 0x25          DC8 99, 37, 81
   \              0x51
     67            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51
     68          };
     69          #endif
     70          
     71          #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
     72          static const uint8_t ecc_p384_n[] = {
     73            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf, 0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73
     74          };
     75          #endif
     76          
     77          #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
     78          static const uint8_t ecc_p521_n[] = {
     79            0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f, 0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09, 0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c, 0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38, 0x64, 0x09
     80          };
     81          #endif
     82          
     83          // -----------------------------------------------------------------------------
     84          // Static functions
     85          
     86          /**
     87           * @brief
     88           *   Clamp if Montgomery or Twisted Edwards private key
     89           *
     90           * @param attributes
     91           *   The PSA attributes struct representing a key
     92           * @param key_data
     93           *   Key data
     94           * @param key_bits
     95           *   Key size in bits
     96           * @returns
     97           *   N/A
     98           */

   \                                 In section .text, align 2, keep-with-next
     99          static void clamp_private_key_if_needed(const psa_key_attributes_t* attributes,
    100                                                  uint8_t *key_data,
    101                                                  size_t key_bits)
    102          {
    103            psa_key_type_t key_type = psa_get_key_type(attributes);
    104          
    105            // Apply clamping
    106            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)
    107                && ((PSA_KEY_TYPE_ECC_GET_FAMILY(key_type) == PSA_ECC_FAMILY_MONTGOMERY))) {
    108              switch (key_bits) {
    109                #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519)
    110                case 255:
    111                  key_data[0] &= 248U;
    112                  key_data[31] &= 127U;
    113                  key_data[31] |= 64U;
    114                  break;
    115                #endif // SLI_PSA_DRIVER_FEATURE_CURVE25519
    116          
    117                #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    118                case 448:
    119                  key_data[0] &= 252U;
    120                  key_data[55] |= 128U;
    121                  break;
    122                #endif // SLI_PSA_DRIVER_FEATURE_CURVE448
    123          
    124                default:
    125                  (void) attributes;
    126                  (void) key_data;
    127                  (void) key_bits;
    128                  break;
    129              }
    130            }
    131          }
   \                     clamp_private_key_if_needed: (+1)
   \        0x0   0x4770             BX       LR
    132          
    133          /**
    134           * @brief
    135           *   Validate that the key descriptor mathces the PSA attributes struct.
    136           *
    137           * @param attributes
    138           *   The PSA attributes struct representing a key
    139           * @param key_size
    140           *   Size of the key
    141           * @param key_desc
    142           *   The SE manager key struct representing the same key
    143           * @returns
    144           *   PSA_SUCCESS if the structures match,
    145           *   PSA_ERROR_INVALID_ARGUMENT otherwise
    146           */
    147          static psa_status_t validate_key_desc(const psa_key_attributes_t* attributes,
    148                                                size_t key_size,
    149                                                const sl_se_key_descriptor_t *key_desc)
    150          {
    151            if (key_desc == NULL || attributes == NULL || key_size == 0) {
    152              return PSA_ERROR_INVALID_ARGUMENT;
    153            }
    154            // Build a new key descriptor from attributes and check that they match

   \                                 In section .rodata, align 4, keep-with-next
    155            sl_se_key_descriptor_t new_key_desc = { 0 };
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    156            psa_status_t status =
    157              sli_se_key_desc_from_psa_attributes(attributes, key_size, &new_key_desc);
    158            if (status != PSA_SUCCESS) {
    159              return PSA_ERROR_INVALID_ARGUMENT;
    160            }
    161            if (new_key_desc.type != key_desc->type
    162                || new_key_desc.size != key_desc->size
    163                || new_key_desc.flags != key_desc->flags
    164                || new_key_desc.password != key_desc->password
    165                || new_key_desc.domain != key_desc->domain) {
    166              return PSA_ERROR_INVALID_ARGUMENT;
    167            }
    168            return PSA_SUCCESS;
    169          }
    170          
    171          /**
    172           * @brief
    173           *   Set the number of bytes of key buffer used for storing the key.
    174           *
    175           * @param attributes[in]
    176           *   The PSA attributes struct representing a key
    177           * @param data_size[in]
    178           *   Size of the data that has been stored (excluding the 0x04 byte for public
    179           *   keys)
    180           * @param key_buffer_length[out]
    181           *   Actually used key buffer space
    182           * @returns
    183           *   PSA_SUCCESS if key_buffer_length can be set properly,
    184           *   PSA_ERROR_NOT_SUPPORTED if unsupported location is encountered.
    185           */

   \                                 In section .text, align 2, keep-with-next
    186          static psa_status_t set_key_buffer_length(
    187            const psa_key_attributes_t *attributes,
    188            size_t data_size,
    189            size_t *key_buffer_length)
    190          {
   \                     set_key_buffer_length: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    191            psa_key_location_t location =
    192              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
   \        0x8   0x.... 0x....      BL       psa_get_key_lifetime
    193            *key_buffer_length = 0;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6031             STR      R1,[R6, #+0]
    194            switch (location) {
   \       0x10   0x0A00             LSRS     R0,R0,#+8
   \       0x12   0xD002             BEQ.N    ??set_key_buffer_length_0
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD008             BEQ.N    ??set_key_buffer_length_1
   \       0x18   0xE009             B.N      ??set_key_buffer_length_2
    195              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    196                if (sli_se_has_format_byte(psa_get_key_type(attributes))) {
   \                     ??set_key_buffer_length_0: (+1)
   \       0x1A   0x8820             LDRH     R0,[R4, #+0]
   \       0x1C   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x20   0xB100             CBZ.N    R0,??set_key_buffer_length_3
    197                  data_size++; // Add the format byte offset
   \       0x22   0x1C6D             ADDS     R5,R5,#+1
    198                }
    199                *key_buffer_length =  data_size;
    200                break;
    201          
    202                #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    203              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
    204                #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    205                data_size = sli_se_word_align(data_size);
    206                #endif
    207                *key_buffer_length = sizeof(sli_se_opaque_wrapped_key_context_t)
    208                                     + data_size;
    209                break;
    210                #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    211          
    212              default:
    213                return PSA_ERROR_NOT_SUPPORTED;
    214                break;
    215            }
    216          
    217            return PSA_SUCCESS;
   \                     ??set_key_buffer_length_3: (+1)
   \       0x24   0x6035             STR      R5,[R6, #+0]
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD70             POP      {R4-R6,PC}
   \                     ??set_key_buffer_length_1: (+1)
   \       0x2A   0x352C             ADDS     R5,R5,#+44
   \       0x2C   0xE7FA             B.N      ??set_key_buffer_length_3
   \                     ??set_key_buffer_length_2: (+1)
   \       0x2E   0xF06F 0x0085      MVN      R0,#+133
   \       0x32   0xBD70             POP      {R4-R6,PC}
    218          }
    219          
    220          #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
    221          

   \                                 In section .text, align 2, keep-with-next
    222          static psa_status_t sli_se_driver_validate_ecc_key(
    223            const psa_key_attributes_t *attributes,
    224            const uint8_t *data,
    225            size_t data_length,
    226            size_t *bits)
    227          {
   \                     sli_se_driver_validate_ecc_key: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB0C3             SUB      SP,SP,#+268
   \        0x6   0x461D             MOV      R5,R3
    228            // Argument check.
    229            if (attributes == NULL
    230                || data == NULL
    231                || data_length == 0
    232                || bits == NULL) {
   \        0x8   0xF06F 0x0886      MVN      R8,#+134
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD004             BEQ.N    ??sli_se_driver_validate_ecc_key_0
   \       0x10   0x000C             MOVS     R4,R1
   \       0x12   0xD002             BEQ.N    ??sli_se_driver_validate_ecc_key_0
   \       0x14   0x0017             MOVS     R7,R2
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2D00             CMPNE    R5,#+0
   \                     ??sli_se_driver_validate_ecc_key_0: (+1)
   \       0x1A   0xF000 0x80A1      BEQ.W    ??sli_se_driver_validate_ecc_key_1
    233              return PSA_ERROR_INVALID_ARGUMENT;
    234            }
    235          
    236            psa_status_t return_status = PSA_ERROR_CORRUPTION_DETECTED;
    237            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x1E   0x8802             LDRH     R2,[R0, #+0]
    238          
    239            psa_ecc_family_t curve_type = PSA_KEY_TYPE_ECC_GET_FAMILY(key_type);
   \       0x20   0x.... 0x....      LDR.W    R3,??DataTable22
   \       0x24   0xF06F 0x0196      MVN      R1,#+150
   \       0x28   0x4013             ANDS     R3,R3,R2
   \       0x2A   0xF5B3 0x4F82      CMP      R3,#+16640
   \       0x2E   0xBF04             ITT      EQ
   \       0x30   0xB2D3             UXTBEQ   R3,R2
   \       0x32   0x2B12             CMPEQ    R3,#+18
    240          
    241            switch (curve_type) {
   \       0x34   0xD113             BNE.N    ??sli_se_driver_validate_ecc_key_2
    242              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    243              case PSA_ECC_FAMILY_SECP_R1: {
    244                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)) {   // Private key.
   \       0x36   0x1E7E             SUBS     R6,R7,#+1
   \       0x38   0xF022 0x03FF      BIC      R3,R2,#0xFF
   \       0x3C   0xF5B3 0x4FE2      CMP      R3,#+28928
   \       0x40   0xD130             BNE.N    ??sli_se_driver_validate_ecc_key_3
    245                  const void *modulus_ptr = NULL;
    246                  *bits = psa_get_key_bits(attributes);
   \       0x42   0x.... 0x....      BL       psa_get_key_bits
   \       0x46   0x6028             STR      R0,[R5, #+0]
    247          
    248                  // Determine key bit-size
    249                  if (*bits == 0) {
   \       0x48   0xB910             CBNZ.N   R0,??sli_se_driver_validate_ecc_key_4
    250                    *bits = data_length * 8;
   \       0x4A   0x00F8             LSLS     R0,R7,#+3
   \       0x4C   0x6028             STR      R0,[R5, #+0]
   \       0x4E   0xE003             B.N      ??sli_se_driver_validate_ecc_key_5
    251                  } else {
    252                    if (PSA_BITS_TO_BYTES(*bits) != data_length) {
   \                     ??sli_se_driver_validate_ecc_key_4: (+1)
   \       0x50   0x1DC0             ADDS     R0,R0,#+7
   \       0x52   0x08C0             LSRS     R0,R0,#+3
   \       0x54   0x42B8             CMP      R0,R7
   \       0x56   0xD12C             BNE.N    ??sli_se_driver_validate_ecc_key_6
    253                      return PSA_ERROR_INVALID_ARGUMENT;
    254                    }
    255                  }
    256          
    257                  switch (*bits) {
   \                     ??sli_se_driver_validate_ecc_key_5: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0xF5B0 0x7F80      CMP      R0,#+256
   \                     ??sli_se_driver_validate_ecc_key_2: (+1)
   \       0x5E   0xF040 0x8081      BNE.W    ??sli_se_driver_validate_ecc_key_7
    258                    #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    259                    case 192:
    260                      modulus_ptr = ecc_p192_n;
    261                      break;
    262                    #endif   // SLI_PSA_DRIVER_FEATURE_P192R1
    263          
    264                    #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    265                    // Series-2-config-1 devices do not support SECP224R1.
    266                    case 224:
    267                      modulus_ptr = ecc_p224_n;
    268                      break;
    269                    #endif   // SLI_PSA_DRIVER_FEATURE_P224R1
    270          
    271                    #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    272                    case 256:
    273                      modulus_ptr = ecc_p256_n;
    274                      break;
    275                    #endif   // SLI_PSA_DRIVER_FEATURE_P256R1
    276          
    277                    #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    278                    case 384:
    279                      modulus_ptr = ecc_p384_n;
    280                      break;
    281                    #endif   // SLI_PSA_DRIVER_FEATURE_P384R1
    282          
    283                    #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    284                    case 521:
    285                      modulus_ptr = ecc_p521_n;
    286                      break;
    287                    case 528:
    288                      // Maybe a 521 bit long key which has been padded to 66 bytes.
    289                      // Make sure the key size is not actually 528
    290                      if (psa_get_key_bits(attributes) == 528) {
    291                        return PSA_ERROR_NOT_SUPPORTED;
    292                      }
    293                      // Actually a 521 bit long key which has been padded to 66 bytes.
    294                      *bits = 521;
    295                      modulus_ptr = ecc_p521_n;
    296                      break;
    297                    #endif   // SLI_PSA_DRIVER_FEATURE_P521R1
    298          
    299                    default:
    300                      return PSA_ERROR_NOT_SUPPORTED;
    301                      break;
    302                  }
    303          
    304                  // Validate the private key.
    305                  return_status = sli_psa_validate_ecc_weierstrass_privkey(data,
    306                                                                           modulus_ptr,
    307                                                                           data_length);
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x2300             MOVS     R3,#+0
   \       0x68   0x.... 0x....      ADR.W    R2,ecc_p256_n
   \       0x6C   0xE010             B.N      ??sli_se_driver_validate_ecc_key_8
   \                     ??sli_se_driver_validate_ecc_key_9: (+1)
   \       0x6E   0x1AF5             SUBS     R5,R6,R3
   \       0x70   0xF814 0xE005      LDRB     LR,[R4, R5]
   \       0x74   0x5D55             LDRB     R5,[R2, R5]
   \       0x76   0xEA4E 0x0000      ORR      R0,LR,R0
   \       0x7A   0xEBAE 0x0E05      SUB      LR,LR,R5
   \       0x7E   0xF1BE 0x0501      SUBS     R5,LR,#+1
   \       0x82   0x41AD             SBCS     R5,R5,R5
   \       0x84   0x0FED             LSRS     R5,R5,#+31
   \       0x86   0x426D             RSBS     R5,R5,#+0
   \       0x88   0x400D             ANDS     R5,R5,R1
   \       0x8A   0xEA4E 0x0105      ORR      R1,LR,R5
   \       0x8E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??sli_se_driver_validate_ecc_key_8: (+1)
   \       0x90   0x42BB             CMP      R3,R7
   \       0x92   0xD3EC             BCC.N    ??sli_se_driver_validate_ecc_key_9
   \       0x94   0xB120             CBZ.N    R0,??sli_se_driver_validate_ecc_key_10
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD502             BPL.N    ??sli_se_driver_validate_ecc_key_10
   \                     ??sli_se_driver_validate_ecc_key_11: (+1)
   \       0x9A   0x2100             MOVS     R1,#+0
    308                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {   // Public key.
    309                  // Check that uncompressed representation is given.
    310                  if (data[0] != 0x04) {
    311                    return PSA_ERROR_INVALID_ARGUMENT;
    312                  }
    313          
    314                  // Create ephemeral SE command context.
    315                  sl_se_command_context_t cmd_ctx = SL_SE_COMMAND_CONTEXT_INIT;
    316                  sl_status_t sl_status = sl_se_init_command_context(&cmd_ctx);
    317                  if (sl_status != SL_STATUS_OK) {
    318                    return PSA_ERROR_HARDWARE_FAILURE;
    319                  }
    320          
    321                  #if defined(SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN)
    322                  // SE version 1.2.2 is first version with public key validation
    323                  // inside of the SE.
    324                  uint32_t se_version = 0;
    325                  sl_status = sl_se_get_se_version(&cmd_ctx, &se_version);
    326                  if (sl_status != SL_STATUS_OK) {
    327                    return PSA_ERROR_HARDWARE_FAILURE;
    328                  }
    329          
    330                  if ((se_version & 0x00FFFFFFU) < SLI_SE_OLDEST_VERSION_WITH_PUBLIC_KEY_VALIDATION) {
    331                    #if defined(MBEDTLS_ECP_C)       \
    332                    && defined(MBEDTLS_PSA_CRYPTO_C) \
    333                    && SL_SE_SUPPORT_FW_PRIOR_TO_1_2_2
    334                    return_status = sli_se_driver_validate_pubkey_with_fallback(
    335                      key_type,
    336                      psa_get_key_bits(attributes),
    337                      data,
    338                      data_length);
    339                    #else
    340                    // No fallback code is compiled in, cannot do public key validation
    341                    return_status = PSA_ERROR_NOT_SUPPORTED;
    342                    #endif
    343                    break;
    344                  }
    345                  #endif   // SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN
    346          
    347                  // Temporary buffer for storing ECDH input private key,
    348                  // possibly padded input public key, and output shared key.
    349                  #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    350          
    351                  // If input public key requires padding, it will be stored
    352                  // starting from the third element. By doing this, and setting
    353                  // the first half-word equal to 1, we are guaranteed to not end up
    354                  // with a private key that is acidentally greater than the order
    355                  // n of the curve group (since the fields size q is greater than n).
    356                  uint8_t tmp_key_buffer[2 + SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    357                  #else   // SLI_SE_KEY_PADDING_REQUIRED
    358                  uint8_t tmp_key_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    359                  #endif   // SLI_SE_KEY_PADDING_REQUIRED
    360          
    361                  // Make sure that ECDH private key is non-zero.
    362                  tmp_key_buffer[0] = 1;
    363          
    364                  // Input public key descriptor.
    365                  sl_se_key_descriptor_t input_public_key_desc = {
    366                    .storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT,
    367                    .storage.location.buffer.pointer = (uint8_t*)data + 1,
    368                    .storage.location.buffer.size = data_length - 1,
    369                  };
    370          
    371                  // Temporary private key descriptor.
    372                  sl_se_key_descriptor_t tmp_private_key_desc = {
    373                    .storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT,
    374                    .storage.location.buffer.pointer = tmp_key_buffer,
    375                    .storage.location.buffer.size = sizeof(tmp_key_buffer),
    376                  };
    377          
    378                  // Temporary shared key descriptor.
    379                  sl_se_key_descriptor_t tmp_shared_key_desc = {
    380                    .type = SL_SE_KEY_TYPE_SYMMETRIC,
    381                    .storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT,
    382                    .storage.location.buffer.pointer = tmp_key_buffer,
    383                    .storage.location.buffer.size = sizeof(tmp_key_buffer),
    384                  };
    385          
    386                  // Determine key bit size (including padding).
    387                  *bits = (data_length - 1) * 8 / 2;
    388          
    389                  uint8_t padding_bytes = 0;
    390                  switch (*bits) {
    391                    #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    392                    case 192:
    393                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P192;
    394                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P192;
    395                      break;
    396                    #endif   // SLI_PSA_DRIVER_FEATURE_P192R1
    397          
    398                    case 224:
    399                      #if defined(SLI_MBEDTLS_DEVICE_HSE_V1)
    400                      // Series-2-config-1 devices do not support SECP224R1.
    401                      return PSA_ERROR_NOT_SUPPORTED;
    402                      break;
    403                      #elif defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    404                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P224;
    405                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P224;
    406                      break;
    407                      #endif
    408          
    409                      #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    410                    case 256:
    411                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P256;
    412                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P256;
    413                      break;
    414                      #endif // SLI_PSA_DRIVER_FEATURE_P256R1
    415          
    416                      #if defined(SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH)
    417          
    418                      #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    419                    case 384:
    420                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P384;
    421                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P384;
    422                      break;
    423                      #endif // SLI_PSA_DRIVER_FEATURE_P384R1
    424          
    425                      #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    426                    case 528:
    427                      // Actually a 521 bit long key which has been padded to 66 bytes.
    428                      *bits = 521;
    429                      padding_bytes = SLI_SE_P521_PADDING_BYTES;
    430                      input_public_key_desc.type = SL_SE_KEY_TYPE_ECC_P521;
    431                      tmp_private_key_desc.type = SL_SE_KEY_TYPE_ECC_P521;
    432                      break;
    433                      #endif // SLI_PSA_DRIVER_FEATURE_P521R1
    434          
    435                      #else // SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH
    436          
    437                    case 384:     // fall through
    438                    case 528:
    439                      return PSA_ERROR_NOT_SUPPORTED;
    440                      break;
    441          
    442                      #endif // SLI_MBEDTLS_DEVICE_HSE_VAULT_HIGH
    443          
    444                    default:
    445                      return PSA_ERROR_INVALID_ARGUMENT;
    446                      break;
    447                  }
    448          
    449                  // Set missing key descriptor attributes.
    450                  input_public_key_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
    451                  tmp_private_key_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
    452                  tmp_shared_key_desc.size = (PSA_BITS_TO_BYTES(*bits) + padding_bytes) * 2;
    453          
    454                  #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    455                  // Should currently only happen for curve P521.
    456                  if (padding_bytes > 0) {
    457                    // Pad public key. Offset +2 in order to avoid problem with invalid private key.
    458                    sli_se_pad_curve_point(tmp_key_buffer + 2,
    459                                           (uint8_t*)data + 1,
    460                                           PSA_BITS_TO_BYTES(*bits));
    461                    sli_se_key_descriptor_set_plaintext(&input_public_key_desc,
    462                                                        tmp_key_buffer + 2,
    463                                                        sizeof(tmp_key_buffer) - 2);
    464                  }
    465                  #endif   // SLI_SE_KEY_PADDING_REQUIRED
    466          
    467                  // Perform key agreement algorithm (ECDH).
    468                  sl_status = sl_se_ecdh_compute_shared_secret(&cmd_ctx,
    469                                                               &tmp_private_key_desc,
    470                                                               &input_public_key_desc,
    471                                                               &tmp_shared_key_desc);
    472          
    473                  // Zero out intermediate results.
    474                  if (padding_bytes == 0) {
    475                    sli_psa_zeroize(tmp_key_buffer, (PSA_BITS_TO_BYTES(*bits)) * 2);
    476                  }
    477                  #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    478                  else {
    479                    sli_psa_zeroize(tmp_key_buffer,
    480                                    2 + (PSA_BITS_TO_BYTES(*bits) + padding_bytes) * 2);
    481                  }
    482                  #endif   // SLI_SE_KEY_PADDING_REQUIRED
    483          
    484                  if (sl_status != SL_STATUS_OK) {
    485                    return PSA_ERROR_INVALID_ARGUMENT;
    486                  } else {
    487                    return_status = PSA_SUCCESS;
    488                  }
    489                }
    490                break;
    491              }
    492              #endif // SLI_PSA_DRIVER_FEATURE_SECPR1
    493          
    494              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
    495              case PSA_ECC_FAMILY_MONTGOMERY: // Explicit fallthrough
    496              case PSA_ECC_FAMILY_TWISTED_EDWARDS:
    497                // Determine key bit-size
    498                if (*bits == 0) {
    499                  *bits = data_length * 8;
    500                } else {
    501                  if (PSA_BITS_TO_BYTES(*bits) != data_length) {
    502                    return PSA_ERROR_INVALID_ARGUMENT;
    503                  }
    504                }
    505                switch (*bits) {
    506                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS25519)
    507                  case 255:
    508                    return_status = PSA_SUCCESS;
    509                    break;
    510                  case 256:
    511                    // Maybe a 255 bit long key which has been padded to 32 bytes.
    512                    // Make sure the key size is not actually 256
    513                    if (psa_get_key_bits(attributes) == 256) {
    514                      return PSA_ERROR_NOT_SUPPORTED;
    515                    }
    516                    *bits = 255;
    517                    return_status = PSA_SUCCESS;
    518                    break;
    519                  #endif // SLI_PSA_DRIVER_FEATURE_CURVE25519 || SLI_PSA_DRIVER_FEATURE_EDWARDS25519
    520          
    521                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    522                  case 448:
    523                    return_status = PSA_SUCCESS;
    524                    break;
    525                  #endif // SLI_PSA_DRIVER_FEATURE_CURVE448
    526          
    527                  default:
    528                    return PSA_ERROR_NOT_SUPPORTED;
    529                    break;
    530                }
    531                break;
    532              #endif  // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
    533          
    534              default:
    535                return PSA_ERROR_NOT_SUPPORTED;
    536                break;
    537            }
    538          
    539            return return_status;
   \                     ??sli_se_driver_validate_ecc_key_12: (+1)
   \       0x9C   0x4608             MOV      R0,R1
   \       0x9E   0xE063             B.N      ??sli_se_driver_validate_ecc_key_13
   \                     ??sli_se_driver_validate_ecc_key_10: (+1)
   \       0xA0   0x4641             MOV      R1,R8
   \       0xA2   0xE7FB             B.N      ??sli_se_driver_validate_ecc_key_12
   \                     ??sli_se_driver_validate_ecc_key_3: (+1)
   \       0xA4   0xF022 0x02FF      BIC      R2,R2,#0xFF
   \       0xA8   0xF5B2 0x4F82      CMP      R2,#+16640
   \       0xAC   0xD1F6             BNE.N    ??sli_se_driver_validate_ecc_key_12
   \       0xAE   0x7820             LDRB     R0,[R4, #+0]
   \       0xB0   0x2804             CMP      R0,#+4
   \                     ??sli_se_driver_validate_ecc_key_6: (+1)
   \       0xB2   0xD155             BNE.N    ??sli_se_driver_validate_ecc_key_1
   \       0xB4   0xA818             ADD      R0,SP,#+96
   \       0xB6   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xBA   0xA818             ADD      R0,SP,#+96
   \       0xBC   0x.... 0x....      BL       sl_se_init_command_context
   \       0xC0   0xB110             CBZ.N    R0,??sli_se_driver_validate_ecc_key_14
   \       0xC2   0xF06F 0x0092      MVN      R0,#+146
   \       0xC6   0xE04F             B.N      ??sli_se_driver_validate_ecc_key_13
   \                     ??sli_se_driver_validate_ecc_key_14: (+1)
   \       0xC8   0x2188             MOVS     R1,#+136
   \       0xCA   0x2200             MOVS     R2,#+0
   \       0xCC   0xA821             ADD      R0,SP,#+132
   \       0xCE   0x.... 0x....      BL       __aeabi_memset
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xF88D 0x0084      STRB     R0,[SP, #+132]
   \       0xD8   0xA808             ADD      R0,SP,#+32
   \       0xDA   0x.... 0x....      BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0xDE   0x1C60             ADDS     R0,R4,#+1
   \       0xE0   0x900C             STR      R0,[SP, #+48]
   \       0xE2   0x960D             STR      R6,[SP, #+52]
   \       0xE4   0x4668             MOV      R0,SP
   \       0xE6   0x.... 0x....      ADR.W    R1,?_7
   \       0xEA   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0xEE   0xA921             ADD      R1,SP,#+132
   \       0xF0   0x9104             STR      R1,[SP, #+16]
   \       0xF2   0xA810             ADD      R0,SP,#+64
   \       0xF4   0x.... 0x....      ADR.W    R1,?_8
   \       0xF8   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0xFC   0xA821             ADD      R0,SP,#+132
   \       0xFE   0x00F6             LSLS     R6,R6,#+3
   \      0x100   0x9014             STR      R0,[SP, #+80]
   \      0x102   0x0876             LSRS     R6,R6,#+1
   \      0x104   0x602E             STR      R6,[R5, #+0]
   \      0x106   0x2EE0             CMP      R6,#+224
   \      0x108   0xBF18             IT       NE
   \      0x10A   0xF5B6 0x7F80      CMPNE    R6,#+256
   \      0x10E   0xD127             BNE.N    ??sli_se_driver_validate_ecc_key_1
   \      0x110   0x.... 0x....      LDR.W    R1,??DataTable22_1
   \      0x114   0x9108             STR      R1,[SP, #+32]
   \      0x116   0x9100             STR      R1,[SP, #+0]
   \      0x118   0x990A             LDR      R1,[SP, #+40]
   \      0x11A   0x9802             LDR      R0,[SP, #+8]
   \      0x11C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \      0x120   0x910A             STR      R1,[SP, #+40]
   \      0x122   0xF440 0x4080      ORR      R0,R0,#0x4000
   \      0x126   0x9002             STR      R0,[SP, #+8]
   \      0x128   0x6828             LDR      R0,[R5, #+0]
   \      0x12A   0xAB10             ADD      R3,SP,#+64
   \      0x12C   0xAA08             ADD      R2,SP,#+32
   \      0x12E   0x1DC0             ADDS     R0,R0,#+7
   \      0x130   0x08C0             LSRS     R0,R0,#+3
   \      0x132   0x0040             LSLS     R0,R0,#+1
   \      0x134   0x9011             STR      R0,[SP, #+68]
   \      0x136   0x4669             MOV      R1,SP
   \      0x138   0xA818             ADD      R0,SP,#+96
   \      0x13A   0x.... 0x....      BL       sl_se_ecdh_compute_shared_secret
   \      0x13E   0x682A             LDR      R2,[R5, #+0]
   \      0x140   0x4601             MOV      R1,R0
   \      0x142   0x1DD2             ADDS     R2,R2,#+7
   \      0x144   0x08D2             LSRS     R2,R2,#+3
   \      0x146   0x0052             LSLS     R2,R2,#+1
   \      0x148   0xD008             BEQ.N    ??sli_se_driver_validate_ecc_key_15
   \      0x14A   0xAB21             ADD      R3,SP,#+132
   \      0x14C   0xE002             B.N      ??sli_se_driver_validate_ecc_key_16
   \                     ??sli_se_driver_validate_ecc_key_17: (+1)
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0xF803 0x0B01      STRB     R0,[R3], #+1
   \                     ??sli_se_driver_validate_ecc_key_16: (+1)
   \      0x154   0x4610             MOV      R0,R2
   \      0x156   0x1E42             SUBS     R2,R0,#+1
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD1F8             BNE.N    ??sli_se_driver_validate_ecc_key_17
   \                     ??sli_se_driver_validate_ecc_key_15: (+1)
   \      0x15C   0x2900             CMP      R1,#+0
   \      0x15E   0xD09C             BEQ.N    ??sli_se_driver_validate_ecc_key_11
   \                     ??sli_se_driver_validate_ecc_key_1: (+1)
   \      0x160   0x4640             MOV      R0,R8
   \      0x162   0xE001             B.N      ??sli_se_driver_validate_ecc_key_13
   \                     ??sli_se_driver_validate_ecc_key_7: (+1)
   \      0x164   0xF06F 0x0085      MVN      R0,#+133
   \                     ??sli_se_driver_validate_ecc_key_13: (+1)
   \      0x168   0xB044             ADD      SP,SP,#+272
   \      0x16A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    540          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x2220             MOVS     R2,#+32
   \        0x2   0x.... 0x....      B.W      __aeabi_memcpy4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2124             MOVS     R1,#+36
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xA801             ADD      R0,SP,#+4
   \                     ??Subroutine3_0: (+1)
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x00               DC8 0
   \       0x21                      DS8 3

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0x0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18                      DS8 8

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0x0, 136
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0088
   \       0x18                      DS8 8

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0x0, 136
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0088
   \       0x18                      DS8 8
    541          
    542          #endif // SLI_PSA_DRIVER_FEATURE_ECC
    543          
    544          // -----------------------------------------------------------------------------
    545          // Global helper functions
    546          
    547          // -------------------------------------
    548          // Generic helper functions
    549          
    550          /**
    551           * @brief
    552           *   Build a key descriptor from a PSA attributes struct
    553           *
    554           * @param attributes
    555           *   The PSA attributes struct representing a key
    556           * @param key_size
    557           *    Size of the key
    558           * @param key_desc
    559           *   The SE manager key struct representing the same key
    560           * @returns
    561           *   PSA_SUCCESS on success
    562           *   PSA_ERROR_INVALID_ARGUMENT on invalid attributes
    563           */

   \                                 In section .text, align 2, keep-with-next
    564          psa_status_t sli_se_key_desc_from_psa_attributes(
    565            const psa_key_attributes_t *attributes,
    566            size_t key_size,
    567            sl_se_key_descriptor_t *key_desc)
    568          {
   \                     sli_se_key_desc_from_psa_attributes: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460C             MOV      R4,R1
    569            size_t attributes_key_size =
    570              PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   \        0x6   0x8841             LDRH     R1,[R0, #+2]
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x1DC9             ADDS     R1,R1,#+7
   \        0xC   0x08C9             LSRS     R1,R1,#+3
    571            if (attributes_key_size != 0) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0x42A1             CMPNE    R1,R4
    572              // If attributes key size is nonzero, it must be equal to key_size
    573              if (attributes_key_size != key_size) {
   \       0x12   0xD164             BNE.N    ??sli_se_key_desc_from_psa_attributes_0
    574                return PSA_ERROR_INVALID_ARGUMENT;
    575              }
    576            }
    577            psa_key_type_t type = psa_get_key_type(attributes);
    578            psa_key_usage_t usage = psa_get_key_usage_flags(attributes);
    579            psa_key_lifetime_t lifetime = psa_get_key_lifetime(attributes);
    580            psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION(lifetime);
   \       0x14   0x6845             LDR      R5,[R0, #+4]
   \       0x16   0xF8B0 0x8000      LDRH     R8,[R0, #+0]
   \       0x1A   0x68C7             LDR      R7,[R0, #+12]
    581          
    582            memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
   \       0x1C   0x2120             MOVS     R1,#+32
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x0A2D             LSRS     R5,R5,#+8
   \       0x22   0x.... 0x....      BL       __aeabi_memclr4
    583          
    584            switch (location) {
   \       0x26   0xB115             CBZ.N    R5,??sli_se_key_desc_from_psa_attributes_1
   \       0x28   0x2D01             CMP      R5,#+1
   \       0x2A   0xD00F             BEQ.N    ??sli_se_key_desc_from_psa_attributes_2
   \       0x2C   0xE011             B.N      ??sli_se_key_desc_from_psa_attributes_3
    585              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    586                key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
   \                     ??sli_se_key_desc_from_psa_attributes_1: (+1)
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x60F2             STR      R2,[R6, #+12]
    587                break;
    588          
    589                #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    590              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
    591                // For the time being, volatile keys directly in SE internal RAM are not
    592                // supported. Once they are, use the persistence info from the key
    593                // lifetime to switch between EXTERNAL_WRAPPED and INTERNAL_VOLATILE.
    594                key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED;
    595                break;
    596                #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    597          
    598              default:
    599                return PSA_ERROR_DOES_NOT_EXIST;
    600            }
    601          
    602            // Dont't accept zero-length keys
    603            if (key_size == 0) {
   \                     ??sli_se_key_desc_from_psa_attributes_4: (+1)
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD053             BEQ.N    ??sli_se_key_desc_from_psa_attributes_0
    604              return PSA_ERROR_INVALID_ARGUMENT;
    605            }
    606          
    607            if (type == PSA_KEY_TYPE_RAW_DATA
    608                || type == PSA_KEY_TYPE_HMAC
    609                || type == PSA_KEY_TYPE_DERIVE) {
   \       0x36   0xF241 0x0001      MOVW     R0,#+4097
   \       0x3A   0x4580             CMP      R8,R0
   \       0x3C   0xBF1C             ITT      NE
   \       0x3E   0xF5B8 0x5F88      CMPNE    R8,#+4352
   \       0x42   0xF5B8 0x5F90      CMPNE    R8,#+4608
   \       0x46   0xD107             BNE.N    ??sli_se_key_desc_from_psa_attributes_5
    610              // Set attributes
    611              key_desc->type = SL_SE_KEY_TYPE_SYMMETRIC;
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0xE012             B.N      ??sli_se_key_desc_from_psa_attributes_6
    612              key_desc->size = key_size;
    613            } else
   \                     ??sli_se_key_desc_from_psa_attributes_2: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0x60F0             STR      R0,[R6, #+12]
   \       0x50   0xE7EF             B.N      ??sli_se_key_desc_from_psa_attributes_4
   \                     ??sli_se_key_desc_from_psa_attributes_3: (+1)
   \       0x52   0xF06F 0x008B      MVN      R0,#+139
   \       0x56   0xE058             B.N      ??sli_se_key_desc_from_psa_attributes_7
    614          
    615            #if defined(SLI_PSA_DRIVER_FEATURE_AES)
    616            if (type == PSA_KEY_TYPE_AES) {
   \                     ??sli_se_key_desc_from_psa_attributes_5: (+1)
   \       0x58   0xF5B8 0x5F10      CMP      R8,#+9216
   \       0x5C   0xD10F             BNE.N    ??sli_se_key_desc_from_psa_attributes_8
    617              switch (key_size) {
   \       0x5E   0x2C10             CMP      R4,#+16
   \       0x60   0xD004             BEQ.N    ??sli_se_key_desc_from_psa_attributes_9
   \       0x62   0x2C18             CMP      R4,#+24
   \       0x64   0xD004             BEQ.N    ??sli_se_key_desc_from_psa_attributes_10
   \       0x66   0x2C20             CMP      R4,#+32
   \       0x68   0xD005             BEQ.N    ??sli_se_key_desc_from_psa_attributes_11
   \       0x6A   0xE038             B.N      ??sli_se_key_desc_from_psa_attributes_0
    618                case 16:
    619                  key_desc->type = SL_SE_KEY_TYPE_AES_128;
   \                     ??sli_se_key_desc_from_psa_attributes_9: (+1)
   \       0x6C   0x2010             MOVS     R0,#+16
   \       0x6E   0xE003             B.N      ??sli_se_key_desc_from_psa_attributes_12
    620                  break;
    621                case 24:
    622                  key_desc->type = SL_SE_KEY_TYPE_AES_192;
   \                     ??sli_se_key_desc_from_psa_attributes_10: (+1)
   \       0x70   0x2118             MOVS     R1,#+24
   \                     ??sli_se_key_desc_from_psa_attributes_6: (+1)
   \       0x72   0x6031             STR      R1,[R6, #+0]
    623                  break;
   \       0x74   0xE001             B.N      ??sli_se_key_desc_from_psa_attributes_13
    624                case 32:
    625                  key_desc->type = SL_SE_KEY_TYPE_AES_256;
   \                     ??sli_se_key_desc_from_psa_attributes_11: (+1)
   \       0x76   0x2020             MOVS     R0,#+32
   \                     ??sli_se_key_desc_from_psa_attributes_12: (+1)
   \       0x78   0x6030             STR      R0,[R6, #+0]
    626                  break;
    627                default:
    628                  // SE doesn't support off-size AES keys
    629                  return PSA_ERROR_INVALID_ARGUMENT;
    630              }
    631              key_desc->size = key_size;
   \                     ??sli_se_key_desc_from_psa_attributes_13: (+1)
   \       0x7A   0x6074             STR      R4,[R6, #+4]
   \       0x7C   0xE038             B.N      ??sli_se_key_desc_from_psa_attributes_14
    632            } else
    633            #endif // SLI_PSA_DRIVER_FEATURE_AES
    634          
    635            #if defined(SLI_PSA_DRIVER_FEATURE_CHACHA20) \
    636            || defined(SLI_PSA_DRIVER_FEATURE_CHACHAPOLY)
    637            if (type == PSA_KEY_TYPE_CHACHA20) {
    638              if (key_size != 0x20) {
    639                return PSA_ERROR_INVALID_ARGUMENT;
    640              }
    641              // Set attributes
    642              key_desc->type = SL_SE_KEY_TYPE_CHACHA20;
    643              key_desc->size = 0x20;
    644            } else
    645            #endif // SLI_PSA_DRIVER_FEATURE_CHACHA20 || SLI_PSA_DRIVER_FEATURE_CHACHAPOLY
    646          
    647            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
    648            if (PSA_KEY_TYPE_IS_ECC(type)) {
   \                     ??sli_se_key_desc_from_psa_attributes_8: (+1)
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x82   0xEA00 0x0008      AND      R0,R0,R8
   \       0x86   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0x8A   0xBF02             ITTT     EQ
   \       0x8C   0xFA5F 0xF088      UXTBEQ   R0,R8
   \       0x90   0x2812             CMPEQ    R0,#+18
   \       0x92   0x2C20             CMPEQ    R4,#+32
    649              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    650              if (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_SECP_R1) {
    651                // Find key size and set key type
    652                switch (key_size) {
   \       0x94   0xD12F             BNE.N    ??sli_se_key_desc_from_psa_attributes_15
    653                  #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    654                  case 24:
    655                    key_desc->type = SL_SE_KEY_TYPE_ECC_P192;
    656                    break;
    657                  #endif     // SLI_PSA_DRIVER_FEATURE_P192R1
    658          
    659                  #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    660                  // Series-2-config-1 devices do not support SECP224R1.
    661                  case 28:
    662                    key_desc->type = SL_SE_KEY_TYPE_ECC_P224;
    663                    break;
    664                  #endif     // SLI_PSA_DRIVER_FEATURE_P224R1
    665          
    666                  #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    667                  case 32:
    668                    key_desc->type = SL_SE_KEY_TYPE_ECC_P256;
   \       0x96   0x.... 0x....      LDR.W    R1,??DataTable22_1
    669                    break;
    670                  #endif     // SLI_PSA_DRIVER_FEATURE_P256R1
    671          
    672                  #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    673                  case 48:
    674                    key_desc->type = SL_SE_KEY_TYPE_ECC_P384;
    675                    break;
    676                  #endif     // SLI_PSA_DRIVER_FEATURE_P384R1
    677          
    678                  #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    679                  case 66:
    680                    key_desc->type = SL_SE_KEY_TYPE_ECC_P521;
    681                    break;
    682                  #endif     // SLI_PSA_DRIVER_FEATURE_P521R1
    683          
    684                  default:
    685                    return PSA_ERROR_NOT_SUPPORTED;
    686                }
    687              } else
    688              #endif   // SLI_PSA_DRIVER_FEATURE_SECPR1
    689          
    690              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY)
    691              if (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_MONTGOMERY) {
    692                // Find key size and set key type
    693                switch (key_size) {
    694                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519)
    695                  case 32:
    696                    key_desc->type = SL_SE_KEY_TYPE_ECC_X25519;
    697                    break;
    698                  #endif     // SLI_PSA_DRIVER_FEATURE_CURVE25519
    699          
    700                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    701                  case 56:
    702                    key_desc->type = SL_SE_KEY_TYPE_ECC_X448;
    703                    break;
    704                  #endif     // SLI_PSA_DRIVER_FEATURE_CURVE448
    705          
    706                  default:
    707                    return PSA_ERROR_NOT_SUPPORTED;
    708                }
    709              } else
    710              #endif   // SLI_PSA_DRIVER_FEATURE_MONTGOMERY
    711          
    712              #if defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
    713              if (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_TWISTED_EDWARDS) {
    714                // Find key size and set key type
    715                switch (key_size) {
    716                  #if defined(SLI_PSA_DRIVER_FEATURE_EDWARDS25519)
    717                  case 32:
    718                    key_desc->type = SL_SE_KEY_TYPE_ECC_ED25519;
    719                    break;
    720                  #endif     // SLI_PSA_DRIVER_FEATURE_EDWARDS25519
    721                  default:
    722                    return PSA_ERROR_NOT_SUPPORTED;
    723                }
    724              } else
    725              #endif   // SLI_PSA_DRIVER_FEATURE_EDWARDS
    726          
    727              {
    728                return PSA_ERROR_NOT_SUPPORTED;
    729              }
    730          
    731              // Set asymmetric args
    732              if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(type)) {
   \       0x9A   0xF028 0x00FF      BIC      R0,R8,#0xFF
   \       0x9E   0x6031             STR      R1,[R6, #+0]
   \       0xA0   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0xA4   0xD114             BNE.N    ??sli_se_key_desc_from_psa_attributes_16
    733                key_desc->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \       0xA6   0x68B0             LDR      R0,[R6, #+8]
   \       0xA8   0xF440 0x4080      ORR      R0,R0,#0x4000
   \                     ??sli_se_key_desc_from_psa_attributes_17: (+1)
   \       0xAC   0x60B0             STR      R0,[R6, #+8]
    734              } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(type)) {
    735                key_desc->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
    736              } else {
    737                return PSA_ERROR_INVALID_ARGUMENT;
    738              }
    739          
    740              // Decide whether the key will be used for signing or derivation
    741              bool is_signing = (usage & (PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH | PSA_KEY_USAGE_SIGN_MESSAGE | PSA_KEY_USAGE_VERIFY_MESSAGE)) != 0;
   \       0xAE   0xF417 0x5270      ANDS     R2,R7,#0x3C00
   \       0xB2   0xBF18             IT       NE
   \       0xB4   0x2201             MOVNE    R2,#+1
    742              bool is_deriving = (usage & (PSA_KEY_USAGE_DERIVE | PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT)) != 0;
   \       0xB6   0xF417 0x4186      ANDS     R1,R7,#0x4300
   \       0xBA   0xBF18             IT       NE
   \       0xBC   0x2101             MOVNE    R1,#+1
    743          
    744              if (is_signing && !is_deriving) {
   \       0xBE   0xF081 0x0301      EOR      R3,R1,#0x1
   \       0xC2   0xB2D0             UXTB     R0,R2
   \       0xC4   0x4218             TST      R0,R3
   \       0xC6   0xD00D             BEQ.N    ??sli_se_key_desc_from_psa_attributes_18
    745                key_desc->flags |= SL_SE_KEY_FLAG_ASYMMMETRIC_SIGNING_ONLY;
   \       0xC8   0x68B1             LDR      R1,[R6, #+8]
   \       0xCA   0xF441 0x6180      ORR      R1,R1,#0x400
   \       0xCE   0xE00E             B.N      ??sli_se_key_desc_from_psa_attributes_19
    746              } else if (!is_signing && is_deriving) {
   \                     ??sli_se_key_desc_from_psa_attributes_16: (+1)
   \       0xD0   0xF5B0 0x4F82      CMP      R0,#+16640
   \       0xD4   0xD103             BNE.N    ??sli_se_key_desc_from_psa_attributes_0
   \       0xD6   0x68B0             LDR      R0,[R6, #+8]
   \       0xD8   0xF440 0x5000      ORR      R0,R0,#0x2000
   \       0xDC   0xE7E6             B.N      ??sli_se_key_desc_from_psa_attributes_17
   \                     ??sli_se_key_desc_from_psa_attributes_0: (+1)
   \       0xDE   0xF06F 0x0086      MVN      R0,#+134
   \       0xE2   0xE012             B.N      ??sli_se_key_desc_from_psa_attributes_7
    747                key_desc->flags = (key_desc->flags & ~SL_SE_KEY_FLAG_ASYMMMETRIC_SIGNING_ONLY);
    748              } else if (is_signing && is_deriving) {
   \                     ??sli_se_key_desc_from_psa_attributes_18: (+1)
   \       0xE4   0x4208             TST      R0,R1
   \       0xE6   0xD106             BNE.N    ??sli_se_key_desc_from_psa_attributes_15
    749                // SE does not support a key to be used for both signing and derivation operations.
    750                return PSA_ERROR_NOT_SUPPORTED;
    751              } else {
    752                // ECC key is not setup for either signing or deriving. Default to not setting
    753                // the 'sign' flag (legacy behaviour)
    754                key_desc->flags = (key_desc->flags & ~SL_SE_KEY_FLAG_ASYMMMETRIC_SIGNING_ONLY);
   \       0xE8   0x68B1             LDR      R1,[R6, #+8]
   \       0xEA   0xF421 0x6180      BIC      R1,R1,#0x400
   \                     ??sli_se_key_desc_from_psa_attributes_19: (+1)
   \       0xEE   0x60B1             STR      R1,[R6, #+8]
    755              }
    756            } else
    757            #endif // SLI_PSA_DRIVER_FEATURE_ECC
    758            {
    759              return PSA_ERROR_NOT_SUPPORTED;
    760            }
    761          
    762            #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    763            // Add key restrictions. Only relevant for opaque drivers. If these properties
    764            // are set for transparent drivers, key generation becomes illegal, as the SE
    765            // does not allow writing a protected key to a plaintext buffer.
    766            if (location != PSA_KEY_LOCATION_LOCAL_STORAGE) {
   \                     ??sli_se_key_desc_from_psa_attributes_14: (+1)
   \       0xF0   0xB155             CBZ.N    R5,??sli_se_key_desc_from_psa_attributes_20
    767              bool can_export = usage & PSA_KEY_USAGE_EXPORT;
    768              bool can_copy = usage & PSA_KEY_USAGE_COPY;
    769          
    770              if (can_copy) {
   \       0xF2   0x07B8             LSLS     R0,R7,#+30
   \       0xF4   0xD502             BPL.N    ??sli_se_key_desc_from_psa_attributes_21
    771                // We do not support copying opaque keys (currently).
    772                return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_key_desc_from_psa_attributes_15: (+1)
   \       0xF6   0xF06F 0x0085      MVN      R0,#+133
   \       0xFA   0xE006             B.N      ??sli_se_key_desc_from_psa_attributes_7
    773              }
    774              if (!can_export) {
   \                     ??sli_se_key_desc_from_psa_attributes_21: (+1)
   \       0xFC   0x07F9             LSLS     R1,R7,#+31
   \       0xFE   0xD403             BMI.N    ??sli_se_key_desc_from_psa_attributes_20
    775                key_desc->flags |= SL_SE_KEY_FLAG_NON_EXPORTABLE;
   \      0x100   0x68B0             LDR      R0,[R6, #+8]
   \      0x102   0xF040 0x7080      ORR      R0,R0,#0x1000000
   \      0x106   0x60B0             STR      R0,[R6, #+8]
    776              }
    777            }
    778            #else // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    779            (void)usage;
    780            #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    781          
    782            return PSA_SUCCESS;
   \                     ??sli_se_key_desc_from_psa_attributes_20: (+1)
   \      0x108   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_desc_from_psa_attributes_7: (+1)
   \      0x10A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    783          }
    784          
    785          /**
    786           * @brief
    787           *   Get the key descriptor from the key buffer and attributes
    788           */

   \                                 In section .text, align 2, keep-with-next
    789          psa_status_t sli_se_key_desc_from_input(const psa_key_attributes_t* attributes,
    790                                                  const uint8_t *key_buffer,
    791                                                  size_t key_buffer_size,
    792                                                  sl_se_key_descriptor_t *key_desc)
    793          {
   \                     sli_se_key_desc_from_input: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460E             MOV      R6,R1
    794            psa_key_lifetime_t lifetime = psa_get_key_lifetime(attributes);
   \        0xA   0x6860             LDR      R0,[R4, #+4]
    795            psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION(lifetime);
    796            uint32_t key_size = 0; // Retrieved in different ways for different locations
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x4617             MOV      R7,R2
   \       0x10   0x461D             MOV      R5,R3
   \       0x12   0x9100             STR      R1,[SP, #+0]
    797            switch (location) {
   \       0x14   0xF06F 0x0A86      MVN      R10,#+134
   \       0x18   0x0A00             LSRS     R0,R0,#+8
   \       0x1A   0xD002             BEQ.N    ??sli_se_key_desc_from_input_0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD050             BEQ.N    ??sli_se_key_desc_from_input_1
   \       0x20   0xE0C8             B.N      ??sli_se_key_desc_from_input_2
    798              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    799              {
    800                uint8_t *actual_key_buffer = (uint8_t *)key_buffer;
    801                size_t actual_key_buffer_size = key_buffer_size;
    802          
    803                #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
    804                psa_key_type_t key_type = psa_get_key_type(attributes);
   \                     ??sli_se_key_desc_from_input_0: (+1)
   \       0x22   0x8820             LDRH     R0,[R4, #+0]
   \       0x24   0x46B1             MOV      R9,R6
   \       0x26   0x46B8             MOV      R8,R7
    805                if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   \       0x28   0xF020 0x01FF      BIC      R1,R0,#0xFF
   \       0x2C   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x30   0xD115             BNE.N    ??sli_se_key_desc_from_input_3
    806                  // For ECC public keys, the attributes key size is always the factor
    807                  // determining the curve size
    808                  key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   \       0x32   0x8861             LDRH     R1,[R4, #+2]
   \       0x34   0x1DC9             ADDS     R1,R1,#+7
   \       0x36   0x08C9             LSRS     R1,R1,#+3
   \       0x38   0x9100             STR      R1,[SP, #+0]
    809                  if (sli_se_has_format_byte(key_type)) {
   \       0x3A   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x3E   0xB158             CBZ.N    R0,??sli_se_key_desc_from_input_4
    810                    // Need to account for the format byte
    811                    if (*key_buffer != 0x04) {
   \       0x40   0x7830             LDRB     R0,[R6, #+0]
   \       0x42   0x2804             CMP      R0,#+4
   \       0x44   0xD107             BNE.N    ??sli_se_key_desc_from_input_5
    812                      return PSA_ERROR_INVALID_ARGUMENT;
    813                    }
    814                    actual_key_buffer += 1;
    815                    actual_key_buffer_size -= 1;
    816                    if (actual_key_buffer_size != 2 * key_size) {
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0xF1A8 0x0801      SUB      R8,R8,#+1
   \       0x4C   0xF109 0x0901      ADD      R9,R9,#+1
   \       0x50   0xEBB8 0x0F40      CMP      R8,R0, LSL #+1
   \       0x54   0xD004             BEQ.N    ??sli_se_key_desc_from_input_6
    817                      return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_key_desc_from_input_5: (+1)
   \       0x56   0xE0B4             B.N      ??sli_se_key_desc_from_input_7
    818                    }
    819                    #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) \
    820                    || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
    821                  } else if ((PSA_KEY_TYPE_ECC_GET_FAMILY(key_type)
    822                              == PSA_ECC_FAMILY_MONTGOMERY)
    823                             || (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type)
    824                                 == PSA_ECC_FAMILY_TWISTED_EDWARDS)) {
    825                    if (actual_key_buffer_size != key_size) {
    826                      return PSA_ERROR_INVALID_ARGUMENT;
    827                    }
    828                    #endif // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
    829                  } else {
    830                    // No other curves supported yet.
    831                    return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_key_desc_from_input_4: (+1)
   \       0x58   0xF06F 0x0085      MVN      R0,#+133
   \                     ??sli_se_key_desc_from_input_8: (+1)
   \       0x5C   0xE0B2             B.N      ??sli_se_key_desc_from_input_9
    832                  }
    833                } else
    834                #endif // SLI_PSA_DRIVER_FEATURE_ECC
    835          
    836                {
    837                  key_size = key_buffer_size;
   \                     ??sli_se_key_desc_from_input_3: (+1)
   \       0x5E   0x9700             STR      R7,[SP, #+0]
    838                }
    839          
    840                // Fill the key desc from attributes
    841                psa_status_t psa_status = sli_se_key_desc_from_psa_attributes(attributes,
    842                                                                              key_size,
    843                                                                              key_desc);
   \                     ??sli_se_key_desc_from_input_6: (+1)
   \       0x60   0x9900             LDR      R1,[SP, #+0]
   \       0x62   0x462A             MOV      R2,R5
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
    844                if (psa_status != PSA_SUCCESS) {
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD1F6             BNE.N    ??sli_se_key_desc_from_input_8
    845                  return psa_status;
    846                }
    847                sli_se_key_descriptor_set_plaintext(key_desc,
    848                                                    actual_key_buffer,
    849                                                    actual_key_buffer_size);
   \       0x6E   0x4642             MOV      R2,R8
   \       0x70   0x4649             MOV      R1,R9
   \       0x72   0x4628             MOV      R0,R5
   \       0x74   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    850                break;
    851              }
    852          
    853                #if defined(SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS)
    854              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
    855              {
    856                if (key_buffer_size < sizeof(sli_se_opaque_key_context_header_t)) {
    857                  return PSA_ERROR_INVALID_ARGUMENT;
    858                }
    859          
    860                sli_se_opaque_key_context_header_t *key_context_header =
    861                  (sli_se_opaque_key_context_header_t *)key_buffer;
    862          
    863                if (key_context_header->struct_version != SLI_SE_OPAQUE_KEY_CONTEXT_VERSION) {
    864                  return PSA_ERROR_STORAGE_FAILURE;
    865                }
    866          
    867                if (key_context_header->builtin_key_id != 0) {
    868                  sl_se_key_descriptor_t builtin_key_desc;
    869                  switch (key_context_header->builtin_key_id) {
    870                    case SL_SE_KEY_SLOT_APPLICATION_SECURE_BOOT_KEY:
    871                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_SECURE_BOOT_KEY;
    872                      break;
    873                    case SL_SE_KEY_SLOT_APPLICATION_SECURE_DEBUG_KEY:
    874                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_SECURE_DEBUG_KEY;
    875                      break;
    876                    case SL_SE_KEY_SLOT_APPLICATION_AES_128_KEY:
    877                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_AES_128_KEY;
    878                      break;
    879                    case SL_SE_KEY_SLOT_TRUSTZONE_ROOT_KEY:
    880                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_TRUSTZONE_ROOT_KEY;
    881                      break;
    882                      #if defined(SLI_PSA_DRIVER_FEATURE_ATTESTATION)
    883                    case SL_SE_KEY_SLOT_APPLICATION_ATTESTATION_KEY:
    884                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_APPLICATION_ATTESTATION_KEY;
    885                      break;
    886                    case SL_SE_KEY_SLOT_SE_ATTESTATION_KEY:
    887                      builtin_key_desc = (sl_se_key_descriptor_t) SL_SE_SYSTEM_ATTESTATION_KEY;
    888                      break;
    889                      #endif // SLI_PSA_DRIVER_FEATURE_ATTESTATION
    890                    default:
    891                      return PSA_ERROR_DOES_NOT_EXIST;
    892                  }
    893                  memcpy(key_desc, &builtin_key_desc, sizeof(*key_desc));
    894                  return PSA_SUCCESS;
    895                } else {
    896                  #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
    897                  if (key_buffer_size < sizeof(sli_se_opaque_wrapped_key_context_t)) {
    898                    return PSA_ERROR_INVALID_ARGUMENT;
    899                  }
    900          
    901                  // Reconstruct key_desc from the key context
    902                  memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
    903          
    904                  // Refer to wrapped key context in input
    905                  sli_se_opaque_wrapped_key_context_t key_context_temp;
    906                  sli_se_opaque_wrapped_key_context_t *key_context =
    907                    (sli_se_opaque_wrapped_key_context_t *)key_buffer;
    908                  key_desc->storage.location.buffer.pointer =
    909                    (uint8_t *)&(key_context->wrapped_buffer);
    910          
    911                  // If the key buffer is unaligned, copy the content into a
    912                  // temporary buffer in order to prevent hardfaults caused by
    913                  // instructions that do not support unaligned words (e.g. LDRD, LDM).
    914                  if ((uintptr_t)key_buffer & 0x3) {
    915                    memcpy(&key_context_temp, key_buffer, sizeof(sli_se_opaque_wrapped_key_context_t));
    916                    key_context = &key_context_temp;
    917                  }
    918          
    919                  key_desc->type = key_context->key_type;
    920                  key_desc->size = key_context->key_size;
    921                  key_desc->flags = key_context->key_flags;
    922          
    923                  key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED;
    924                  key_desc->storage.location.buffer.size =
    925                    key_buffer_size - offsetof(sli_se_opaque_wrapped_key_context_t,
    926                                               wrapped_buffer);
    927          
    928                  // Clear temporary key context
    929                  if ((uintptr_t)key_buffer & 0x3) {
    930                    memset(&key_context_temp, 0, sizeof(sli_se_opaque_wrapped_key_context_t));
    931                  }
    932          
    933                  if (sli_key_get_size(key_desc, &key_size) != SL_STATUS_OK) {
    934                    memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
    935                    return PSA_ERROR_INVALID_ARGUMENT;
    936                  }
    937          
    938                  uint32_t key_full_size = key_size;
    939          
    940                  #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    941                  if (PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes))
    942                      == PSA_ECC_FAMILY_SECP_R1
    943                      && PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(psa_get_key_type(attributes))) {
    944                    key_full_size = 2 * key_full_size;
    945                  }
    946                  #endif     // SLI_PSA_DRIVER_FEATURE_SECPR1
    947          
    948                  if (key_desc->storage.location.buffer.size < key_full_size + SLI_SE_WRAPPED_KEY_OVERHEAD) {
    949                    memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
    950                    return PSA_ERROR_INVALID_ARGUMENT;
    951                  }
    952          
    953                  #else   // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    954                  return PSA_ERROR_NOT_SUPPORTED;
    955                  #endif   // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
    956                }
    957                break;
    958              }
    959                #endif // SLI_PSA_DRIVER_FEATURE_OPAQUE_KEYS
    960          
    961              default:
    962                return PSA_ERROR_DOES_NOT_EXIST;
    963            }
    964          
    965            // Run a general validation routine once the key desc has been populated
    966            psa_status_t status = validate_key_desc(attributes, key_size, key_desc);
   \                     ??sli_se_key_desc_from_input_10: (+1)
   \       0x78   0x2D00             CMP      R5,#+0
   \       0x7A   0xBF1E             ITTT     NE
   \       0x7C   0x2C00             CMPNE    R4,#+0
   \       0x7E   0x9800             LDRNE    R0,[SP, #+0]
   \       0x80   0x2800             CMPNE    R0,#+0
   \       0x82   0xF000 0x809A      BEQ.W    ??sli_se_key_desc_from_input_11
   \       0x86   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x8A   0x9900             LDR      R1,[SP, #+0]
   \       0x8C   0xAA01             ADD      R2,SP,#+4
   \       0x8E   0x4620             MOV      R0,R4
   \       0x90   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xBF02             ITTT     EQ
   \       0x98   0x9801             LDREQ    R0,[SP, #+4]
   \       0x9A   0x6829             LDREQ    R1,[R5, #+0]
   \       0x9C   0x4288             CMPEQ    R0,R1
   \       0x9E   0xD10E             BNE.N    ??sli_se_key_desc_from_input_12
   \       0xA0   0x9902             LDR      R1,[SP, #+8]
   \       0xA2   0x6868             LDR      R0,[R5, #+4]
   \       0xA4   0x4281             CMP      R1,R0
   \       0xA6   0xBF02             ITTT     EQ
   \       0xA8   0x9903             LDREQ    R1,[SP, #+12]
   \       0xAA   0x68A8             LDREQ    R0,[R5, #+8]
   \       0xAC   0x4281             CMPEQ    R1,R0
   \       0xAE   0xD106             BNE.N    ??sli_se_key_desc_from_input_12
   \       0xB0   0x9907             LDR      R1,[SP, #+28]
   \       0xB2   0x69A8             LDR      R0,[R5, #+24]
   \       0xB4   0x4281             CMP      R1,R0
   \       0xB6   0xBF02             ITTT     EQ
   \       0xB8   0x9908             LDREQ    R1,[SP, #+32]
   \       0xBA   0x69E8             LDREQ    R0,[R5, #+28]
   \       0xBC   0x4281             CMPEQ    R1,R0
   \                     ??sli_se_key_desc_from_input_12: (+1)
   \       0xBE   0xD17C             BNE.N    ??sli_se_key_desc_from_input_11
    967            if (status != PSA_SUCCESS) {
    968              memset(key_desc, 0, sizeof(sl_se_key_descriptor_t));
    969              return PSA_ERROR_INVALID_ARGUMENT;
    970            }
    971            return PSA_SUCCESS;
   \       0xC0   0xE035             B.N      ??sli_se_key_desc_from_input_13
   \                     ??sli_se_key_desc_from_input_1: (+1)
   \       0xC2   0x2F04             CMP      R7,#+4
   \       0xC4   0xD37D             BCC.N    ??sli_se_key_desc_from_input_7
   \       0xC6   0x7830             LDRB     R0,[R6, #+0]
   \       0xC8   0x2801             CMP      R0,#+1
   \       0xCA   0xBF18             IT       NE
   \       0xCC   0xF06F 0x0091      MVNNE    R0,#+145
   \       0xD0   0xD178             BNE.N    ??sli_se_key_desc_from_input_9
   \       0xD2   0x7870             LDRB     R0,[R6, #+1]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD02C             BEQ.N    ??sli_se_key_desc_from_input_14
   \       0xD8   0x28F7             CMP      R0,#+247
   \       0xDA   0xD016             BEQ.N    ??sli_se_key_desc_from_input_15
   \       0xDC   0x28F8             CMP      R0,#+248
   \       0xDE   0xD00C             BEQ.N    ??sli_se_key_desc_from_input_16
   \       0xE0   0x28FA             CMP      R0,#+250
   \       0xE2   0xD00E             BEQ.N    ??sli_se_key_desc_from_input_17
   \       0xE4   0x28FC             CMP      R0,#+252
   \       0xE6   0xD004             BEQ.N    ??sli_se_key_desc_from_input_18
   \       0xE8   0x28FE             CMP      R0,#+254
   \       0xEA   0xD012             BEQ.N    ??sli_se_key_desc_from_input_19
   \       0xEC   0x28FF             CMP      R0,#+255
   \       0xEE   0xD014             BEQ.N    ??sli_se_key_desc_from_input_20
   \       0xF0   0xE060             B.N      ??sli_se_key_desc_from_input_2
   \                     ??sli_se_key_desc_from_input_18: (+1)
   \       0xF2   0xA801             ADD      R0,SP,#+4
   \       0xF4   0x.... 0x....      ADR.W    R1,?_9
   \       0xF8   0xE012             B.N      ??sli_se_key_desc_from_input_21
   \                     ??sli_se_key_desc_from_input_16: (+1)
   \       0xFA   0xA801             ADD      R0,SP,#+4
   \       0xFC   0x.... 0x....      ADR.W    R1,?_10
   \      0x100   0xE00E             B.N      ??sli_se_key_desc_from_input_21
   \                     ??sli_se_key_desc_from_input_17: (+1)
   \      0x102   0xA801             ADD      R0,SP,#+4
   \      0x104   0x.... 0x....      ADR.W    R1,?_11
   \      0x108   0xE00A             B.N      ??sli_se_key_desc_from_input_21
   \                     ??sli_se_key_desc_from_input_15: (+1)
   \      0x10A   0xA801             ADD      R0,SP,#+4
   \      0x10C   0x.... 0x....      ADR.W    R1,?_12
   \      0x110   0xE006             B.N      ??sli_se_key_desc_from_input_21
   \                     ??sli_se_key_desc_from_input_19: (+1)
   \      0x112   0xA801             ADD      R0,SP,#+4
   \      0x114   0x.... 0x....      ADR.W    R1,?_13
   \      0x118   0xE002             B.N      ??sli_se_key_desc_from_input_21
   \                     ??sli_se_key_desc_from_input_20: (+1)
   \      0x11A   0xA801             ADD      R0,SP,#+4
   \      0x11C   0x.... 0x....      ADR.W    R1,?_14
   \                     ??sli_se_key_desc_from_input_21: (+1)
   \      0x120   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_13: (+1)
   \      0x124   0x2220             MOVS     R2,#+32
   \      0x126   0xA901             ADD      R1,SP,#+4
   \      0x128   0x4628             MOV      R0,R5
   \      0x12A   0x.... 0x....      BL       __aeabi_memcpy4
   \                     ??sli_se_key_desc_from_input_13: (+1)
   \      0x12E   0x2000             MOVS     R0,#+0
   \      0x130   0xE048             B.N      ??sli_se_key_desc_from_input_9
   \                     ??sli_se_key_desc_from_input_14: (+1)
   \      0x132   0x2F2C             CMP      R7,#+44
   \      0x134   0xD345             BCC.N    ??sli_se_key_desc_from_input_7
   \      0x136   0x2120             MOVS     R1,#+32
   \      0x138   0x4628             MOV      R0,R5
   \      0x13A   0x.... 0x....      BL       __aeabi_memclr4
   \      0x13E   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x142   0x46B0             MOV      R8,R6
   \      0x144   0x6128             STR      R0,[R5, #+16]
   \      0x146   0xF018 0x0F03      TST      R8,#0x3
   \      0x14A   0xD005             BEQ.N    ??sli_se_key_desc_from_input_22
   \      0x14C   0x222C             MOVS     R2,#+44
   \      0x14E   0x4631             MOV      R1,R6
   \      0x150   0xA801             ADD      R0,SP,#+4
   \      0x152   0x.... 0x....      BL       __aeabi_memcpy
   \      0x156   0xAE01             ADD      R6,SP,#+4
   \                     ??sli_se_key_desc_from_input_22: (+1)
   \      0x158   0x6871             LDR      R1,[R6, #+4]
   \      0x15A   0x3F10             SUBS     R7,R7,#+16
   \      0x15C   0x6029             STR      R1,[R5, #+0]
   \      0x15E   0x68B0             LDR      R0,[R6, #+8]
   \      0x160   0x6068             STR      R0,[R5, #+4]
   \      0x162   0x68F1             LDR      R1,[R6, #+12]
   \      0x164   0x2001             MOVS     R0,#+1
   \      0x166   0x60E8             STR      R0,[R5, #+12]
   \      0x168   0x60A9             STR      R1,[R5, #+8]
   \      0x16A   0x616F             STR      R7,[R5, #+20]
   \      0x16C   0xF018 0x0F03      TST      R8,#0x3
   \      0x170   0xD003             BEQ.N    ??sli_se_key_desc_from_input_23
   \      0x172   0x212C             MOVS     R1,#+44
   \      0x174   0xA801             ADD      R0,SP,#+4
   \      0x176   0x.... 0x....      BL       __aeabi_memclr4
   \                     ??sli_se_key_desc_from_input_23: (+1)
   \      0x17A   0x4669             MOV      R1,SP
   \      0x17C   0x4628             MOV      R0,R5
   \      0x17E   0x.... 0x....      BL       sli_key_get_size
   \      0x182   0xB9D0             CBNZ.N   R0,??sli_se_key_desc_from_input_11
   \      0x184   0x8823             LDRH     R3,[R4, #+0]
   \      0x186   0x.... 0x....      LDR.W    R2,??DataTable22
   \      0x18A   0x9800             LDR      R0,[SP, #+0]
   \      0x18C   0x4619             MOV      R1,R3
   \      0x18E   0x400A             ANDS     R2,R2,R1
   \      0x190   0xF5B2 0x4F82      CMP      R2,#+16640
   \      0x194   0xBF04             ITT      EQ
   \      0x196   0xB2DB             UXTBEQ   R3,R3
   \      0x198   0x2B12             CMPEQ    R3,#+18
   \      0x19A   0xD105             BNE.N    ??sli_se_key_desc_from_input_24
   \      0x19C   0xF021 0x01FF      BIC      R1,R1,#0xFF
   \      0x1A0   0xF5B1 0x4F82      CMP      R1,#+16640
   \      0x1A4   0xBF08             IT       EQ
   \      0x1A6   0x0040             LSLEQ    R0,R0,#+1
   \                     ??sli_se_key_desc_from_input_24: (+1)
   \      0x1A8   0x6969             LDR      R1,[R5, #+20]
   \      0x1AA   0x301C             ADDS     R0,R0,#+28
   \      0x1AC   0x4281             CMP      R1,R0
   \      0x1AE   0xF4BF 0xAF63      BCS.W    ??sli_se_key_desc_from_input_10
   \      0x1B2   0xE002             B.N      ??sli_se_key_desc_from_input_11
   \                     ??sli_se_key_desc_from_input_2: (+1)
   \      0x1B4   0xF06F 0x008B      MVN      R0,#+139
   \      0x1B8   0xE004             B.N      ??sli_se_key_desc_from_input_9
   \                     ??sli_se_key_desc_from_input_11: (+1)
   \      0x1BA   0x2120             MOVS     R1,#+32
   \      0x1BC   0x4628             MOV      R0,R5
   \      0x1BE   0x.... 0x....      BL       __aeabi_memclr4
   \                     ??sli_se_key_desc_from_input_7: (+1)
   \      0x1C2   0x4650             MOV      R0,R10
   \                     ??sli_se_key_desc_from_input_9: (+1)
   \      0x1C4   0xB00C             ADD      SP,SP,#+48
   \      0x1C6   0xE8BD 0x87F0      POP      {R4-R10,PC}
    972          }
    973          
    974          /**
    975           * @brief
    976           *   Set the relevant location field of the key descriptor
    977           */

   \                                 In section .text, align 2, keep-with-next
    978          psa_status_t sli_se_set_key_desc_output(const psa_key_attributes_t* attributes,
    979                                                  uint8_t *key_buffer,
    980                                                  size_t key_buffer_size,
    981                                                  size_t key_size,
    982                                                  sl_se_key_descriptor_t *key_desc)
    983          {
   \                     sli_se_set_key_desc_output: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    984            psa_key_location_t location =
    985              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    986            switch (location) {
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x9C02             LDR      R4,[SP, #+8]
   \        0x6   0x0A00             LSRS     R0,R0,#+8
   \        0x8   0xD002             BEQ.N    ??sli_se_set_key_desc_output_0
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD006             BEQ.N    ??sli_se_set_key_desc_output_1
   \        0xE   0xE012             B.N      ??sli_se_set_key_desc_output_2
    987              case PSA_KEY_LOCATION_LOCAL_STORAGE:
    988                if (key_buffer_size < key_size) {
   \                     ??sli_se_set_key_desc_output_0: (+1)
   \       0x10   0x429A             CMP      R2,R3
   \       0x12   0xD307             BCC.N    ??sli_se_set_key_desc_output_3
    989                  return PSA_ERROR_INSUFFICIENT_MEMORY;
    990                }
    991                key_desc->storage.location.buffer.pointer = key_buffer;
   \       0x14   0x6121             STR      R1,[R4, #+16]
    992          
    993                #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    994                key_buffer_size = sli_se_word_align(key_buffer_size);
    995                #endif
    996          
    997                key_desc->storage.location.buffer.size = key_buffer_size;
    998                break;
    999          
   1000                #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1001              case PSA_KEY_LOCATION_SLI_SE_OPAQUE:
   1002                #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1003                key_size = sli_se_word_align(key_size);
   1004                #endif
   1005          
   1006                if (key_buffer_size < sizeof(sli_se_opaque_wrapped_key_context_t)
   1007                    + key_size) {
   1008                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   1009                }
   1010                key_desc->storage.location.buffer.pointer =
   1011                  key_buffer + offsetof(sli_se_opaque_wrapped_key_context_t,
   1012                                        wrapped_buffer);
   1013                key_desc->storage.location.buffer.size =
   1014                  key_size + SLI_SE_WRAPPED_KEY_OVERHEAD;
   1015                break;
   1016                #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1017          
   1018              default:
   1019                return PSA_ERROR_DOES_NOT_EXIST;
   1020            }
   1021            return PSA_SUCCESS;
   \                     ??sli_se_set_key_desc_output_4: (+1)
   \       0x16   0x6162             STR      R2,[R4, #+20]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}
   \                     ??sli_se_set_key_desc_output_1: (+1)
   \       0x1C   0xF103 0x002C      ADD      R0,R3,#+44
   \       0x20   0x4282             CMP      R2,R0
   \       0x22   0xD202             BCS.N    ??sli_se_set_key_desc_output_5
   \                     ??sli_se_set_key_desc_output_3: (+1)
   \       0x24   0xF06F 0x008C      MVN      R0,#+140
   \       0x28   0xBD10             POP      {R4,PC}
   \                     ??sli_se_set_key_desc_output_5: (+1)
   \       0x2A   0xF101 0x0010      ADD      R0,R1,#+16
   \       0x2E   0x6120             STR      R0,[R4, #+16]
   \       0x30   0xF103 0x021C      ADD      R2,R3,#+28
   \       0x34   0xE7EF             B.N      ??sli_se_set_key_desc_output_4
   \                     ??sli_se_set_key_desc_output_2: (+1)
   \       0x36   0xF06F 0x008B      MVN      R0,#+139
   \       0x3A   0xBD10             POP      {R4,PC}
   1022          }
   1023          
   1024          #if defined(SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN) \
   1025            && defined(MBEDTLS_ECP_C)                                  \
   1026            && defined(MBEDTLS_PSA_CRYPTO_C)                           \
   1027            && SL_SE_SUPPORT_FW_PRIOR_TO_1_2_2
   1028          
   1029          #include "mbedtls/ecp.h"
   1030          #include "psa_crypto_core.h"
   1031          
   1032          psa_status_t sli_se_driver_validate_pubkey_with_fallback(psa_key_type_t key_type,
   1033                                                                   size_t key_bits,
   1034                                                                   const uint8_t *data,
   1035                                                                   size_t data_length)
   1036          {
   1037            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1038          
   1039            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1040            mbedtls_ecp_group_id grp_id = MBEDTLS_ECP_DP_NONE;
   1041          
   1042            mbedtls_ecp_group pubkey_grp;
   1043            mbedtls_ecp_point pubkey_point;
   1044          
   1045            mbedtls_ecp_group_init(&pubkey_grp);
   1046            mbedtls_ecp_point_init(&pubkey_point);
   1047          
   1048            // Get software-defined curve structure
   1049            grp_id = mbedtls_ecc_group_of_psa(PSA_KEY_TYPE_ECC_GET_FAMILY(key_type),
   1050                                              key_bits,
   1051                                              1);
   1052            if (grp_id == MBEDTLS_ECP_DP_NONE) {
   1053              goto exit;
   1054            }
   1055          
   1056            psa_status = mbedtls_to_psa_error(mbedtls_ecp_group_load(&pubkey_grp,
   1057                                                                     grp_id));
   1058            if (psa_status != PSA_SUCCESS) {
   1059              goto exit;
   1060            }
   1061          
   1062            // Load public key into mbed TLS structure
   1063            psa_status = mbedtls_to_psa_error(mbedtls_ecp_point_read_binary(
   1064                                                &pubkey_grp,
   1065                                                &pubkey_point,
   1066                                                data,
   1067                                                data_length) );
   1068            if (psa_status != PSA_SUCCESS) {
   1069              goto exit;
   1070            }
   1071          
   1072            // Validate key.
   1073            psa_status = mbedtls_to_psa_error(mbedtls_ecp_check_pubkey(&pubkey_grp,
   1074                                                                       &pubkey_point));
   1075          
   1076            exit:
   1077            mbedtls_ecp_group_free(&pubkey_grp);
   1078            mbedtls_ecp_point_free(&pubkey_point);
   1079            return psa_status;
   1080          
   1081            #else // SLI_PSA_DRIVER_FEATURE_ECC
   1082          
   1083            (void) key_type;
   1084            (void) key_bits;
   1085            (void) data;
   1086            (void) data_length;
   1087          
   1088            return PSA_ERROR_NOT_SUPPORTED;
   1089          
   1090            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1091          }
   1092          
   1093          #endif // SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN ...
   1094          
   1095          // -------------------------------------
   1096          // Opaque helper functions
   1097          
   1098          #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1099          
   1100          /**
   1101           * @brief
   1102           *   Store the required parts of the key descriptor in the context placed the
   1103           *   start of the given key buffer.
   1104           */

   \                                 In section .text, align 2, keep-with-next
   1105          psa_status_t store_key_desc_in_context(sl_se_key_descriptor_t *key_desc,
   1106                                                 uint8_t *key_buffer,
   1107                                                 size_t key_buffer_size)
   1108          {
   \                     store_key_desc_in_context: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1109            if (key_buffer_size < sizeof(sli_se_opaque_wrapped_key_context_t)) {
   \        0x2   0x2A2C             CMP      R2,#+44
   \        0x4   0xD202             BCS.N    ??store_key_desc_in_context_0
   1110              return PSA_ERROR_BUFFER_TOO_SMALL;
   \        0x6   0xF06F 0x0089      MVN      R0,#+137
   \        0xA   0xBD10             POP      {R4,PC}
   1111            }
   1112          
   1113            sli_se_opaque_wrapped_key_context_t *key_context =
   1114              (sli_se_opaque_wrapped_key_context_t *)key_buffer;
   1115            key_context->header.struct_version = SLI_SE_OPAQUE_KEY_CONTEXT_VERSION;
   \                     ??store_key_desc_in_context_0: (+1)
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0x700B             STRB     R3,[R1, #+0]
   1116            key_context->header.builtin_key_id = 0;
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x704A             STRB     R2,[R1, #+1]
   1117            memset(&key_context->header.reserved, 0, sizeof(key_context->header.reserved));
   \       0x14   0x1C8C             ADDS     R4,R1,#+2
   \       0x16   0x7022             STRB     R2,[R4, #+0]
   \       0x18   0x7062             STRB     R2,[R4, #+1]
   1118            key_context->key_type = key_desc->type;
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x604B             STR      R3,[R1, #+4]
   1119            key_context->key_size = key_desc->size;
   \       0x1E   0x6842             LDR      R2,[R0, #+4]
   \       0x20   0x608A             STR      R2,[R1, #+8]
   1120            key_context->key_flags = key_desc->flags;
   \       0x22   0x6880             LDR      R0,[R0, #+8]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1121          
   1122            return PSA_SUCCESS;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD10             POP      {R4,PC}
   1123          }
   1124          
   1125          #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1126          
   1127          // -----------------------------------------------------------------------------
   1128          // Driver entry points
   1129          
   1130          // -------------------------------------
   1131          // Generic driver entry points
   1132          

   \                                 In section .text, align 2, keep-with-next
   1133          psa_status_t sli_se_driver_generate_key(const psa_key_attributes_t *attributes,
   1134                                                  uint8_t *key_buffer,
   1135                                                  size_t key_buffer_size,
   1136                                                  size_t *key_buffer_length)
   1137          {
   \                     sli_se_driver_generate_key: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4699             MOV      R9,R3
   1138            if (attributes == NULL
   1139                || key_buffer == NULL
   1140                || key_buffer_size == 0) {
   \        0xA   0xD018             BEQ.N    ??sli_se_driver_generate_key_0
   \        0xC   0x000D             MOVS     R5,R1
   \        0xE   0xBF18             IT       NE
   \       0x10   0xEA5F 0x0A02      MOVSNE   R10,R2
   \       0x14   0xD013             BEQ.N    ??sli_se_driver_generate_key_0
   1141              return PSA_ERROR_INVALID_ARGUMENT;
   1142            }
   1143          
   1144            size_t key_bits = psa_get_key_bits(attributes);
   \       0x16   0x8867             LDRH     R7,[R4, #+2]
   1145            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   1146            if (key_size == 0) {
   \       0x18   0xF06F 0x0885      MVN      R8,#+133
   \       0x1C   0x1DFE             ADDS     R6,R7,#+7
   \       0x1E   0x08F6             LSRS     R6,R6,#+3
   \       0x20   0xD015             BEQ.N    ??sli_se_driver_generate_key_1
   1147              return PSA_ERROR_NOT_SUPPORTED;
   1148            }
   1149          
   1150            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x22   0x8820             LDRH     R0,[R4, #+0]
   1151            if (PSA_KEY_TYPE_IS_UNSTRUCTURED(key_type)
   1152                && ((key_bits & 0x7) != 0)) {
   \       0x24   0xF400 0x42E0      AND      R2,R0,#0x7000
   \       0x28   0xF5B2 0x5F80      CMP      R2,#+4096
   \       0x2C   0xBF1C             ITT      NE
   \       0x2E   0xF400 0x41E0      ANDNE    R1,R0,#0x7000
   \       0x32   0xF5B1 0x5F00      CMPNE    R1,#+8192
   \       0x36   0xD105             BNE.N    ??sli_se_driver_generate_key_2
   \       0x38   0xF017 0x0F07      TST      R7,#0x7
   \       0x3C   0xD002             BEQ.N    ??sli_se_driver_generate_key_2
   1153              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_generate_key_0: (+1)
   \       0x3E   0xF06F 0x0086      MVN      R0,#+134
   \       0x42   0xE048             B.N      ??sli_se_driver_generate_key_3
   1154            } else if (PSA_KEY_TYPE_IS_PUBLIC_KEY(key_type)) {
   \                     ??sli_se_driver_generate_key_2: (+1)
   \       0x44   0xF400 0x40E0      AND      R0,R0,#0x7000
   \       0x48   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x4C   0xD101             BNE.N    ??sli_se_driver_generate_key_4
   1155              // PSA Crypto defines generate_key to be an invalid call with a key type
   1156              // of public key.
   1157              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_generate_key_1: (+1)
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0xE041             B.N      ??sli_se_driver_generate_key_3
   1158            }
   1159          
   1160            // Generate a key desc
   1161            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??sli_se_driver_generate_key_4: (+1)
   \       0x52   0x.... 0x....      BL       ?Subroutine3
   1162            psa_status_t psa_status =
   1163              sli_se_key_desc_from_psa_attributes(attributes,
   1164                                                  key_size,
   1165                                                  &key_desc);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x56   0xAA01             ADD      R2,SP,#+4
   \       0x58   0x4631             MOV      R1,R6
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   1166            if (psa_status != PSA_SUCCESS) {
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD138             BNE.N    ??sli_se_driver_generate_key_3
   1167              return psa_status;
   1168            }
   1169          
   1170            psa_status = sli_se_set_key_desc_output(attributes,
   1171                                                    key_buffer,
   1172                                                    key_buffer_size,
   1173                                                    key_size,
   1174                                                    &key_desc);
   \       0x64   0xA801             ADD      R0,SP,#+4
   \       0x66   0x9000             STR      R0,[SP, #+0]
   \       0x68   0x4633             MOV      R3,R6
   \       0x6A   0x4652             MOV      R2,R10
   \       0x6C   0x4629             MOV      R1,R5
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0x.... 0x....      BL       sli_se_set_key_desc_output
   1175            if (psa_status != PSA_SUCCESS) {
   \       0x74   0xBB78             CBNZ.N   R0,??sli_se_driver_generate_key_3
   1176              return psa_status;
   1177            }
   1178          
   1179            // Generate the key using SE manager
   1180            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x76   0xA809             ADD      R0,SP,#+36
   \       0x78   0x.... 0x....      BL       ?Subroutine2
   1181            sl_status_t sl_status = sl_se_init_command_context(&cmd_ctx);
   1182            if (sl_status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x7C   0xA809             ADD      R0,SP,#+36
   \       0x7E   0xF06F 0x0B92      MVN      R11,#+146
   \       0x82   0x.... 0x....      BL       sl_se_init_command_context
   \       0x86   0xBB18             CBNZ.N   R0,??sli_se_driver_generate_key_5
   1183              return PSA_ERROR_HARDWARE_FAILURE;
   1184            }
   1185            sl_status = sl_se_generate_key(&cmd_ctx, &key_desc);
   \       0x88   0xA901             ADD      R1,SP,#+4
   \       0x8A   0xA809             ADD      R0,SP,#+36
   \       0x8C   0x.... 0x....      BL       sl_se_generate_key
   1186            if (sl_status != SL_STATUS_OK) {
   \       0x90   0xB120             CBZ.N    R0,??sli_se_driver_generate_key_6
   1187              if (sl_status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0x92   0x2848             CMP      R0,#+72
   \       0x94   0xBF14             ITE      NE
   \       0x96   0x465D             MOVNE    R5,R11
   \       0x98   0x4645             MOVEQ    R5,R8
   1188                // This error will be returned if the key type isn't supported.
   1189                psa_status = PSA_ERROR_NOT_SUPPORTED;
   1190              } else {
   1191                psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0x9A   0xE015             B.N      ??sli_se_driver_generate_key_7
   1192              }
   1193              goto exit;
   1194            } else {
   1195              if (PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes))
   1196                  == PSA_KEY_LOCATION_LOCAL_STORAGE) {
   \                     ??sli_se_driver_generate_key_6: (+1)
   \       0x9C   0x6860             LDR      R0,[R4, #+4]
   \       0x9E   0x0A00             LSRS     R0,R0,#+8
   \       0xA0   0xD105             BNE.N    ??sli_se_driver_generate_key_8
   1197                // Apply clamping if this is a Montgomery key.
   1198                clamp_private_key_if_needed(attributes, key_buffer, key_bits);
   \       0xA2   0x463A             MOV      R2,R7
   \       0xA4   0x4629             MOV      R1,R5
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x.... 0x....      BL       clamp_private_key_if_needed
   \       0xAC   0xE006             B.N      ??sli_se_driver_generate_key_9
   1199              }
   1200          
   1201              #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1202              else {
   1203                // Add the key desc to the output array for opaque keys.
   1204                psa_status = store_key_desc_in_context(&key_desc,
   1205                                                       key_buffer,
   1206                                                       key_buffer_size);
   \                     ??sli_se_driver_generate_key_8: (+1)
   \       0xAE   0x4652             MOV      R2,R10
   \       0xB0   0x4629             MOV      R1,R5
   \       0xB2   0xA801             ADD      R0,SP,#+4
   \       0xB4   0x.... 0x....      BL       store_key_desc_in_context
   \       0xB8   0x0005             MOVS     R5,R0
   1207                if (psa_status != PSA_SUCCESS) {
   \       0xBA   0xD105             BNE.N    ??sli_se_driver_generate_key_7
   \                     ??sli_se_driver_generate_key_9: (+1)
   \       0xBC   0x464A             MOV      R2,R9
   1208                  goto exit;
   1209                }
   1210              }
   1211              #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1212          
   1213              psa_status = set_key_buffer_length(attributes, key_size, key_buffer_length);
   \       0xBE   0x4631             MOV      R1,R6
   \       0xC0   0x4620             MOV      R0,R4
   \       0xC2   0x.... 0x....      BL       set_key_buffer_length
   \       0xC6   0x4605             MOV      R5,R0
   1214            }
   1215            // Cleanup
   1216            exit:
   1217            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   1218            if (sl_status != SL_STATUS_OK) {
   \                     ??sli_se_driver_generate_key_7: (+1)
   \       0xC8   0xA809             ADD      R0,SP,#+36
   \       0xCA   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xCE   0xB108             CBZ.N    R0,??sli_se_driver_generate_key_10
   1219              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_generate_key_5: (+1)
   \       0xD0   0x4658             MOV      R0,R11
   \       0xD2   0xE000             B.N      ??sli_se_driver_generate_key_3
   1220            }
   1221            return psa_status;
   \                     ??sli_se_driver_generate_key_10: (+1)
   \       0xD4   0x4628             MOV      R0,R5
   \                     ??sli_se_driver_generate_key_3: (+1)
   \       0xD6   0xB013             ADD      SP,SP,#+76
   \       0xD8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1222          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1223          

   \                                 In section .text, align 2, keep-with-next
   1224          psa_status_t sli_se_driver_export_public_key(
   1225            const psa_key_attributes_t *attributes,
   1226            const uint8_t *key_buffer,
   1227            size_t key_buffer_size,
   1228            uint8_t *data,
   1229            size_t data_size,
   1230            size_t *data_length)
   1231          {
   \                     sli_se_driver_export_public_key: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB09A             SUB      SP,SP,#+104
   \        0x6   0xEA5F 0x0800      MOVS     R8,R0
   \        0xA   0x4689             MOV      R9,R1
   \        0xC   0x4614             MOV      R4,R2
   1232            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1233          
   1234            if (attributes == NULL
   1235                || key_buffer == NULL
   1236                || key_buffer_size == 0
   1237                || data == NULL
   1238                || data_size == 0
   1239                || data_length == NULL) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x14   0xD007             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x16   0xB134             CBZ.N    R4,??sli_se_driver_export_public_key_0
   \       0x18   0x001D             MOVS     R5,R3
   \       0x1A   0xBF1C             ITT      NE
   \       0x1C   0x9E22             LDRNE    R6,[SP, #+136]
   \       0x1E   0x2E00             CMPNE    R6,#+0
   \       0x20   0xD001             BEQ.N    ??sli_se_driver_export_public_key_0
   \       0x22   0x9F23             LDR      R7,[SP, #+140]
   \       0x24   0xB917             CBNZ.N   R7,??sli_se_driver_export_public_key_1
   1240              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_export_public_key_0: (+1)
   \       0x26   0xF06F 0x0086      MVN      R0,#+134
   \       0x2A   0xE04E             B.N      ??sli_se_driver_export_public_key_2
   1241            }
   1242          
   1243            // Build key descs for the private key
   1244            sl_se_key_descriptor_t priv_key_desc = { 0 };
   \                     ??sli_se_driver_export_public_key_1: (+1)
   \       0x2C   0xA809             ADD      R0,SP,#+36
   \       0x2E   0x.... 0x....      BL       ??Subroutine3_0
   1245            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
   1246                                                                 key_buffer,
   1247                                                                 key_buffer_size,
   1248                                                                 &priv_key_desc);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x32   0xAB09             ADD      R3,SP,#+36
   \       0x34   0x4622             MOV      R2,R4
   \       0x36   0x4649             MOV      R1,R9
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x3E   0x0004             MOVS     R4,R0
   1249            if (psa_status != PSA_SUCCESS) {
   \       0x40   0xD143             BNE.N    ??sli_se_driver_export_public_key_2
   1250              return psa_status;
   1251            }
   1252          
   1253            // ECC public keys are written in uncompressed format with a preceeding 0x04
   1254            // format byte. This byte should however not be present for Montgomery keys
   1255            uint32_t prepend_format_byte = 1;
   1256            #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
   1257            if ((PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes))
   1258                 == PSA_ECC_FAMILY_MONTGOMERY)
   1259                || (PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes))
   1260                    == PSA_ECC_FAMILY_TWISTED_EDWARDS)) {
   1261              prepend_format_byte = 0;
   1262            }
   1263            #endif   // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
   1264          
   1265            sl_se_key_descriptor_t pub_key_desc = priv_key_desc;
   \       0x42   0xA801             ADD      R0,SP,#+4
   \       0x44   0xA909             ADD      R1,SP,#+36
   \       0x46   0x.... 0x....      BL       ?Subroutine4
   1266            size_t padding = 0;
   1267          
   1268            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1269            // Since we were able to successfully build a key desc, we know that the key
   1270            // is supported. However, we must also account for non-word-aligned keys
   1271            uint8_t temp_pub_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
   1272            uint8_t temp_priv_buffer[SLI_SE_MAX_PADDED_KEY_PAIR_SIZE] = { 0 };
   1273            size_t priv_key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   1274            if (PSA_KEY_TYPE_IS_ECC(psa_get_key_type(attributes))) {
   1275              padding = sli_se_get_padding(PSA_BITS_TO_BYTES(psa_get_key_bits(attributes)));
   1276            }
   1277            if (padding > 0) {
   1278              if (priv_key_desc.storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   1279                // We must only fix the padding for plaintext private keys. Opaque padding
   1280                // is already handled in import_key
   1281                if (key_buffer_size < priv_key_size) {
   1282                  return PSA_ERROR_INVALID_ARGUMENT;
   1283                }
   1284                sli_se_pad_big_endian(temp_priv_buffer, key_buffer, priv_key_size);
   1285                sli_se_key_descriptor_set_plaintext(&priv_key_desc,
   1286                                                    temp_priv_buffer,
   1287                                                    sizeof(temp_priv_buffer));
   1288              }
   1289              // Point the key desc to the temp buffer
   1290              sli_se_key_descriptor_set_plaintext(&pub_key_desc,
   1291                                                  temp_pub_buffer,
   1292                                                  sizeof(temp_pub_buffer));
   1293            } else
   1294            #endif   // SLI_SE_KEY_PADDING_REQUIRED
   1295          
   1296            {
   1297              // Account for format byte where applicable
   1298              sli_se_key_descriptor_set_plaintext(&pub_key_desc,
   1299                                                  data + prepend_format_byte,
   1300                                                  data_size - prepend_format_byte);
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x4A   0x1E72             SUBS     R2,R6,#+1
   \       0x4C   0x1C69             ADDS     R1,R5,#+1
   \       0x4E   0xA801             ADD      R0,SP,#+4
   \       0x50   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
   1301            }
   1302          
   1303            // Clear non exportable and private key flags from the public key desc,
   1304            // And set the public flag
   1305            pub_key_desc.flags &= ~(SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY
   1306                                    | SL_SE_KEY_FLAG_NON_EXPORTABLE);
   1307            pub_key_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \       0x54   0x9903             LDR      R1,[SP, #+12]
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable22_2
   1308            uint32_t storage_size = 0;
   1309            sl_status_t sl_status =
   1310              sli_key_get_storage_size(&pub_key_desc, &storage_size);
   1311            if (sl_status != SL_STATUS_OK) {
   \       0x5A   0xF06F 0x0992      MVN      R9,#+146
   \       0x5E   0x4001             ANDS     R1,R0,R1
   \       0x60   0xF441 0x5100      ORR      R1,R1,#0x2000
   \       0x64   0x9103             STR      R1,[SP, #+12]
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x9100             STR      R1,[SP, #+0]
   \       0x6A   0x4669             MOV      R1,SP
   \       0x6C   0xA801             ADD      R0,SP,#+4
   \       0x6E   0x.... 0x....      BL       sli_key_get_storage_size
   \       0x72   0xBB38             CBNZ.N   R0,??sli_se_driver_export_public_key_3
   1312              return PSA_ERROR_HARDWARE_FAILURE;
   1313            }
   1314            // We must fit entire output key + possibly a format byte
   1315            // We don't have to fit the padding bytes into the data buffer.
   1316            storage_size = storage_size + prepend_format_byte - (2 * padding);
   \       0x74   0x9800             LDR      R0,[SP, #+0]
   \       0x76   0x1C40             ADDS     R0,R0,#+1
   \       0x78   0x9000             STR      R0,[SP, #+0]
   1317            if (data_size < storage_size) {
   \       0x7A   0x4286             CMP      R6,R0
   \       0x7C   0xBF38             IT       CC
   \       0x7E   0xF06F 0x0089      MVNCC    R0,#+137
   1318              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x82   0xD322             BCC.N    ??sli_se_driver_export_public_key_2
   1319            }
   1320          
   1321            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x84   0xA811             ADD      R0,SP,#+68
   \       0x86   0x.... 0x....      BL       ?Subroutine2
   1322            sl_status = sl_se_init_command_context(&cmd_ctx);
   1323            if (sl_status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x8A   0xA811             ADD      R0,SP,#+68
   \       0x8C   0x.... 0x....      BL       sl_se_init_command_context
   \       0x90   0xB9C0             CBNZ.N   R0,??sli_se_driver_export_public_key_3
   1324              return PSA_ERROR_HARDWARE_FAILURE;
   1325            }
   1326          
   1327            #if defined(SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED)
   1328            psa_status = sli_se_check_eddsa_errata(attributes, &cmd_ctx);
   1329            if (psa_status != PSA_SUCCESS) {
   1330              return psa_status;
   1331            }
   1332            #endif   // SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED
   1333          
   1334            sl_status = sl_se_export_public_key(&cmd_ctx, &priv_key_desc, &pub_key_desc);
   \       0x92   0xAA01             ADD      R2,SP,#+4
   \       0x94   0xA909             ADD      R1,SP,#+36
   \       0x96   0xA811             ADD      R0,SP,#+68
   \       0x98   0x.... 0x....      BL       sl_se_export_public_key
   1335            if (sl_status == SL_STATUS_FAIL) {
   \       0x9C   0x2801             CMP      R0,#+1
   \       0x9E   0xBF08             IT       EQ
   \       0xA0   0xF06F 0x048B      MVNEQ    R4,#+139
   1336              // This specific code maps to 'does not exist' for builtin keys
   1337              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \       0xA4   0xD00A             BEQ.N    ??sli_se_driver_export_public_key_4
   1338            } else if (sl_status != SL_STATUS_OK) {
   \       0xA6   0xB128             CBZ.N    R0,??sli_se_driver_export_public_key_5
   1339              if (sl_status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0xA8   0x2848             CMP      R0,#+72
   \       0xAA   0xBF14             ITE      NE
   \       0xAC   0x464C             MOVNE    R4,R9
   \       0xAE   0xF06F 0x0485      MVNEQ    R4,#+133
   1340                // This error will be returned if the key type isn't supported.
   1341                psa_status = PSA_ERROR_NOT_SUPPORTED;
   1342              } else {
   1343                psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0xB2   0xE003             B.N      ??sli_se_driver_export_public_key_4
   1344              }
   1345            } else {
   1346              psa_status = PSA_SUCCESS;
   1347          
   1348              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1349              if (padding > 0) {
   1350                // Now it is time to copy the actual ket from the temp buffer to the
   1351                // output buffer. Write to an offset if applicable, to account for the
   1352                // format byte
   1353                sli_se_unpad_curve_point(temp_pub_buffer,
   1354                                         data + prepend_format_byte,
   1355                                         (storage_size - prepend_format_byte) / 2);
   1356                sli_psa_zeroize(temp_priv_buffer, priv_key_size);
   1357              }
   1358              #endif   // SLI_SE_KEY_PADDING_REQUIRED
   1359          
   1360              // Write the uncompressed format byte and actual data length
   1361              if (prepend_format_byte == 1) {
   1362                *data = 0x04;
   \                     ??sli_se_driver_export_public_key_5: (+1)
   \       0xB4   0x2004             MOVS     R0,#+4
   \       0xB6   0x7028             STRB     R0,[R5, #+0]
   1363              }
   1364              *data_length = storage_size;
   \       0xB8   0x9900             LDR      R1,[SP, #+0]
   \       0xBA   0x6039             STR      R1,[R7, #+0]
   1365            }
   1366          
   1367            // Cleanup
   1368            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   1369            if (sl_status != SL_STATUS_OK) {
   \                     ??sli_se_driver_export_public_key_4: (+1)
   \       0xBC   0xA811             ADD      R0,SP,#+68
   \       0xBE   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xC2   0xB108             CBZ.N    R0,??sli_se_driver_export_public_key_6
   1370              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_export_public_key_3: (+1)
   \       0xC4   0x4648             MOV      R0,R9
   \       0xC6   0xE000             B.N      ??sli_se_driver_export_public_key_2
   1371            }
   1372            return psa_status;
   \                     ??sli_se_driver_export_public_key_6: (+1)
   \       0xC8   0x4620             MOV      R0,R4
   \                     ??sli_se_driver_export_public_key_2: (+1)
   \       0xCA   0xB01B             ADD      SP,SP,#+108
   \       0xCC   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1373          
   1374            #else // SLI_PSA_DRIVER_FEATURE_ECC
   1375          
   1376            (void) attributes;
   1377            (void) key_buffer;
   1378            (void) key_buffer_size;
   1379            (void) data;
   1380            (void) data_size;
   1381            (void) data_length;
   1382          
   1383            return PSA_ERROR_NOT_SUPPORTED;
   1384          
   1385            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1386          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1387          
   1388          // -------------------------------------
   1389          // Opaque driver entry points
   1390          

   \                                 In section .text, align 2, keep-with-next
   1391          psa_status_t sli_se_opaque_generate_key(const psa_key_attributes_t *attributes,
   1392                                                  uint8_t *key_buffer,
   1393                                                  size_t key_buffer_size,
   1394                                                  size_t *key_buffer_length)
   1395          {
   1396            return sli_se_driver_generate_key(attributes,
   1397                                              key_buffer,
   1398                                              key_buffer_size,
   1399                                              key_buffer_length);
   \                     sli_se_opaque_generate_key: (+1)
   \        0x0   0x....             B.N      sli_se_driver_generate_key
   1400          }
   1401          

   \                                 In section .text, align 2, keep-with-next
   1402          psa_status_t sli_se_opaque_export_public_key(
   1403            const psa_key_attributes_t *attributes,
   1404            const uint8_t *key_buffer,
   1405            size_t key_buffer_size,
   1406            uint8_t *data,
   1407            size_t data_size,
   1408            size_t *data_length)
   1409          {
   \                     sli_se_opaque_export_public_key: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   1410            return sli_se_driver_export_public_key(attributes,
   1411                                                   key_buffer,
   1412                                                   key_buffer_size,
   1413                                                   data,
   1414                                                   data_size,
   1415                                                   data_length);
   \        0x2   0x....             B.N      ?Subroutine1
   1416          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x9D07             LDR      R5,[SP, #+28]
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
   \        0x4   0x9501             STR      R5,[SP, #+4]
   \        0x6   0x9400             STR      R4,[SP, #+0]
   \        0x8   0x.... 0x....      BL       sli_se_driver_export_public_key
   \        0xC   0xBD3E             POP      {R1-R5,PC}
   1417          
   1418          #if defined(SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS)
   1419          

   \                                 In section .text, align 2, keep-with-next
   1420          psa_status_t sli_se_opaque_copy_key(const psa_key_attributes_t *attributes,
   1421                                              const uint8_t *source_key,
   1422                                              size_t source_key_length,
   1423                                              uint8_t *target_key_buffer,
   1424                                              size_t target_key_buffer_size,
   1425                                              size_t *target_key_buffer_length)
   1426          {
   \                     sli_se_opaque_copy_key: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   1427            size_t bits = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x9403             STR      R4,[SP, #+12]
   1428            return sli_se_opaque_import_key(attributes,
   1429                                            source_key,
   1430                                            source_key_length,
   1431                                            target_key_buffer,
   1432                                            target_key_buffer_size,
   1433                                            target_key_buffer_length,
   1434                                            &bits);
   \        0x6   0x9D09             LDR      R5,[SP, #+36]
   \        0x8   0x9C08             LDR      R4,[SP, #+32]
   \        0xA   0xAE03             ADD      R6,SP,#+12
   \        0xC   0x9602             STR      R6,[SP, #+8]
   \        0xE   0x9501             STR      R5,[SP, #+4]
   \       0x10   0x9400             STR      R4,[SP, #+0]
   \       0x12   0x.... 0x....      BL       sli_se_opaque_import_key
   \       0x16   0xB004             ADD      SP,SP,#+16
   \       0x18   0xBD70             POP      {R4-R6,PC}
   1435          }
   1436          

   \                                 In section .text, align 2, keep-with-next
   1437          psa_status_t sli_se_opaque_import_key(const psa_key_attributes_t *attributes,
   1438                                                const uint8_t *data,
   1439                                                size_t data_length,
   1440                                                uint8_t *key_buffer,
   1441                                                size_t key_buffer_size,
   1442                                                size_t *key_buffer_length,
   1443                                                size_t *bits)
   1444          {
   \                     sli_se_opaque_import_key: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09B             SUB      SP,SP,#+108
   \        0x6   0xEA5F 0x0900      MOVS     R9,R0
   1445            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1446          
   1447            if (attributes == NULL
   1448                || key_buffer == NULL
   1449                || key_buffer_size == 0
   1450                || data == NULL
   1451                || data_length == 0
   1452                || key_buffer_length == NULL
   1453                || bits == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0xEA5F 0x0803      MOVSNE   R8,R3
   \       0x10   0xD00C             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x12   0x9D24             LDR      R5,[SP, #+144]
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0xEA5F 0x0B01      MOVSNE   R11,R1
   \       0x1C   0xD006             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x1E   0x0017             MOVS     R7,R2
   \       0x20   0xBF1C             ITT      NE
   \       0x22   0x9C25             LDRNE    R4,[SP, #+148]
   \       0x24   0x2C00             CMPNE    R4,#+0
   \       0x26   0xD001             BEQ.N    ??sli_se_opaque_import_key_0
   \       0x28   0x9826             LDR      R0,[SP, #+152]
   \       0x2A   0xB910             CBNZ.N   R0,??sli_se_opaque_import_key_1
   1454              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_opaque_import_key_0: (+1)
   \       0x2C   0xF06F 0x0086      MVN      R0,#+134
   \       0x30   0xE07A             B.N      ??sli_se_opaque_import_key_2
   1455            }
   1456            *key_buffer_length = 0;
   \                     ??sli_se_opaque_import_key_1: (+1)
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x6021             STR      R1,[R4, #+0]
   1457          
   1458            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x36   0xF8B9 0x6000      LDRH     R6,[R9, #+0]
   1459          
   1460            // Store bits value for imported key
   1461            *bits = 8 * data_length;
   1462          
   1463            switch (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type)) {
   \       0x3A   0x....             LDR.N    R1,??DataTable22
   \       0x3C   0x00FA             LSLS     R2,R7,#+3
   \       0x3E   0xEA01 0x0306      AND      R3,R1,R6
   \       0x42   0xF5B3 0x4F82      CMP      R3,#+16640
   \       0x46   0xBF04             ITT      EQ
   \       0x48   0xB2F3             UXTBEQ   R3,R6
   \       0x4A   0x2B12             CMPEQ    R3,#+18
   \       0x4C   0xD10B             BNE.N    ??sli_se_opaque_import_key_3
   1464              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
   1465              case PSA_ECC_FAMILY_SECP_R1:
   1466                if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   \       0x4E   0xF026 0x03FF      BIC      R3,R6,#0xFF
   \       0x52   0xF5B3 0x4F82      CMP      R3,#+16640
   \       0x56   0xBF04             ITT      EQ
   \       0x58   0x3A08             SUBEQ    R2,R2,#+8
   \       0x5A   0x0852             LSREQ    R2,R2,#+1
   1467                  *bits -= 8;
   1468                  *bits /= 2;
   1469                }
   1470                if (*bits == PSA_BITS_TO_BYTES(521) * 8) {
   \       0x5C   0xF5B2 0x7F04      CMP      R2,#+528
   \       0x60   0xBF08             IT       EQ
   \       0x62   0xF240 0x2209      MOVWEQ   R2,#+521
   1471                  *bits = 521;
   1472                }
   1473                break;
   1474              #endif // SLI_PSA_DRIVER_FEATURE_SECPR1
   1475          
   1476              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY) || defined(SLI_PSA_DRIVER_FEATURE_EDWARDS)
   1477              case PSA_ECC_FAMILY_MONTGOMERY:
   1478              case PSA_ECC_FAMILY_TWISTED_EDWARDS:
   1479                if (data_length == 32) {
   1480                  *bits = 255;
   1481                }
   1482                break;
   1483              #endif // SLI_PSA_DRIVER_FEATURE_MONTGOMERY || SLI_PSA_DRIVER_FEATURE_EDWARDS
   1484          
   1485              default:
   1486                break;
   1487            }
   1488          
   1489            size_t offset = 0;
   1490            size_t padding = 0;
   1491            size_t key_size = 0;
   \                     ??sli_se_opaque_import_key_3: (+1)
   \       0x66   0x6002             STR      R2,[R0, #+0]
   \       0x68   0x2000             MOVS     R0,#+0
   1492          
   1493            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1494            if (PSA_KEY_TYPE_IS_ECC(key_type)) {
   \       0x6A   0x4031             ANDS     R1,R1,R6
   \       0x6C   0x9001             STR      R0,[SP, #+4]
   \       0x6E   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x72   0xD114             BNE.N    ??sli_se_opaque_import_key_4
   1495              // Validate key and get size.
   1496              psa_status = sli_se_driver_validate_ecc_key(attributes,
   1497                                                          data,
   1498                                                          data_length,
   1499                                                          &key_size);
   \       0x74   0xAB01             ADD      R3,SP,#+4
   \       0x76   0x463A             MOV      R2,R7
   \       0x78   0x4659             MOV      R1,R11
   \       0x7A   0x4648             MOV      R0,R9
   \       0x7C   0x.... 0x....      BL       sli_se_driver_validate_ecc_key
   \       0x80   0xEA5F 0x0A00      MOVS     R10,R0
   1500              if (psa_status != PSA_SUCCESS) {
   \       0x84   0xD14F             BNE.N    ??sli_se_opaque_import_key_5
   1501                return psa_status;
   1502              }
   1503              key_size = PSA_BITS_TO_BYTES(key_size);
   \       0x86   0x9801             LDR      R0,[SP, #+4]
   \       0x88   0x1DC0             ADDS     R0,R0,#+7
   \       0x8A   0x08C0             LSRS     R0,R0,#+3
   \       0x8C   0x9001             STR      R0,[SP, #+4]
   1504              if (sli_se_has_format_byte(key_type)) {
   \       0x8E   0x4630             MOV      R0,R6
   \       0x90   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x94   0xB120             CBZ.N    R0,??sli_se_opaque_import_key_6
   1505                data_length -= 1;
   \       0x96   0x1E7F             SUBS     R7,R7,#+1
   1506                data += 1;
   \       0x98   0xF10B 0x0B01      ADD      R11,R11,#+1
   \       0x9C   0xE000             B.N      ??sli_se_opaque_import_key_6
   1507              }
   1508          
   1509              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1510              if (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type) == PSA_ECC_FAMILY_SECP_R1) {
   1511                // We must add some padding if offset is nonzero
   1512                offset = sli_se_get_padding(key_size);
   1513              }
   1514              #endif   // SLI_SE_KEY_PADDING_REQUIRED
   1515            } else
   1516            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1517          
   1518            {
   1519              key_size = data_length;
   \                     ??sli_se_opaque_import_key_4: (+1)
   \       0x9E   0x9701             STR      R7,[SP, #+4]
   1520            }
   1521          
   1522            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1523            // Size must at least fit max ECC key size plus padding
   1524            uint8_t temp_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
   1525            #endif
   1526          
   1527            // Create a key desc that will represent the wrapped key
   1528            sl_se_key_descriptor_t imported_key_desc = { 0 };
   \                     ??sli_se_opaque_import_key_6: (+1)
   \       0xA0   0xA802             ADD      R0,SP,#+8
   \       0xA2   0x.... 0x....      BL       ??Subroutine3_0
   1529            psa_status =
   1530              sli_se_key_desc_from_psa_attributes(attributes,
   1531                                                  key_size,
   1532                                                  &imported_key_desc);
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0xA6   0x9901             LDR      R1,[SP, #+4]
   \       0xA8   0xAA02             ADD      R2,SP,#+8
   \       0xAA   0x4648             MOV      R0,R9
   \       0xAC   0x.... 0x....      BL       sli_se_key_desc_from_psa_attributes
   \       0xB0   0xEA5F 0x0A00      MOVS     R10,R0
   1533            if (psa_status != PSA_SUCCESS) {
   \       0xB4   0xD137             BNE.N    ??sli_se_opaque_import_key_5
   1534              return psa_status;
   1535            }
   1536            // Create a key desc representing the plaintext input key
   1537            sl_se_key_descriptor_t plaintext_key_desc = imported_key_desc;
   \       0xB6   0xA813             ADD      R0,SP,#+76
   \       0xB8   0xA902             ADD      R1,SP,#+8
   \       0xBA   0x.... 0x....      BL       ?Subroutine4
   1538          
   1539            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1540            if (offset == 0) {
   1541              sli_se_key_descriptor_set_plaintext(&plaintext_key_desc, data, data_length);
   1542            } else {
   1543              // We must account for the offset.
   1544              // Write the key data to offset position in temp buffer
   1545              if (sizeof(temp_buffer) < data_length + 2 * offset) {
   1546                return PSA_ERROR_INVALID_ARGUMENT;
   1547              }
   1548          
   1549              #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1550              if (PSA_KEY_TYPE_ECC_GET_FAMILY(key_type) == PSA_ECC_FAMILY_SECP_R1) {
   1551                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)) {
   1552                  sli_se_pad_big_endian(temp_buffer, data, key_size);
   1553                  padding = offset;
   1554                } else {
   1555                  // Must be public key
   1556                  sli_se_pad_curve_point(temp_buffer, data, key_size);
   1557                  padding = 2 * offset;
   1558                }
   1559                sli_se_key_descriptor_set_plaintext(&plaintext_key_desc,
   1560                                                    temp_buffer,
   1561                                                    data_length + padding);
   1562              } else
   1563              #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1564              {
   1565                return PSA_ERROR_CORRUPTION_DETECTED;
   1566              }
   1567            }
   1568            #else // SLI_SE_KEY_PADDING_REQUIRED
   1569            (void)offset;
   1570            sli_se_key_descriptor_set_plaintext(&plaintext_key_desc, data, data_length);
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xBE   0x463A             MOV      R2,R7
   \       0xC0   0x4659             MOV      R1,R11
   \       0xC2   0xA813             ADD      R0,SP,#+76
   \       0xC4   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
   1571            #endif // SLI_SE_KEY_PADDING_REQUIRED
   1572          
   1573            sl_se_command_context_t cmd_ctx = SL_SE_COMMAND_CONTEXT_INIT;
   \       0xC8   0xA80A             ADD      R0,SP,#+40
   \       0xCA   0x.... 0x....      BL       ?Subroutine2
   1574            sl_status_t sl_status = SL_STATUS_OK;
   1575            // Set location specific properties for the output key buffer
   1576            psa_status = sli_se_set_key_desc_output(attributes,
   1577                                                    key_buffer,
   1578                                                    key_buffer_size,
   1579                                                    data_length + padding,
   1580                                                    &imported_key_desc);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xCE   0xA802             ADD      R0,SP,#+8
   \       0xD0   0x9000             STR      R0,[SP, #+0]
   \       0xD2   0x463B             MOV      R3,R7
   \       0xD4   0x462A             MOV      R2,R5
   \       0xD6   0x4641             MOV      R1,R8
   \       0xD8   0x4648             MOV      R0,R9
   \       0xDA   0x.... 0x....      BL       sli_se_set_key_desc_output
   \       0xDE   0xEA5F 0x0A00      MOVS     R10,R0
   1581            if (psa_status != PSA_SUCCESS) {
   \       0xE2   0xD120             BNE.N    ??sli_se_opaque_import_key_5
   1582              goto exit;
   1583            }
   1584          
   1585            sl_status = sl_se_init_command_context(&cmd_ctx);
   1586            if (sl_status != SL_STATUS_OK) {
   \       0xE4   0xA80A             ADD      R0,SP,#+40
   \       0xE6   0xF06F 0x0692      MVN      R6,#+146
   \       0xEA   0x.... 0x....      BL       sl_se_init_command_context
   \       0xEE   0xB9C8             CBNZ.N   R0,??sli_se_opaque_import_key_7
   1587              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1588              goto exit;
   1589            }
   1590          
   1591            // Call SE manager to import the key
   1592            sl_status = sl_se_import_key(&cmd_ctx,
   1593                                         &plaintext_key_desc,
   1594                                         &imported_key_desc);
   1595            if (sl_status != SL_STATUS_OK) {
   \       0xF0   0xAA02             ADD      R2,SP,#+8
   \       0xF2   0xA913             ADD      R1,SP,#+76
   \       0xF4   0xA80A             ADD      R0,SP,#+40
   \       0xF6   0x.... 0x....      BL       sl_se_import_key
   \       0xFA   0xB108             CBZ.N    R0,??sli_se_opaque_import_key_8
   1596              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0xFC   0x46B2             MOV      R10,R6
   \       0xFE   0xE00D             B.N      ??sli_se_opaque_import_key_9
   1597            } else {
   1598              // Add the key desc parameters to the output array
   1599              psa_status = store_key_desc_in_context(&imported_key_desc,
   1600                                                     key_buffer,
   1601                                                     key_buffer_size);
   \                     ??sli_se_opaque_import_key_8: (+1)
   \      0x100   0x462A             MOV      R2,R5
   \      0x102   0x4641             MOV      R1,R8
   \      0x104   0xA802             ADD      R0,SP,#+8
   \      0x106   0x.... 0x....      BL       store_key_desc_in_context
   \      0x10A   0xEA5F 0x0A00      MOVS     R10,R0
   1602              if (psa_status != PSA_SUCCESS) {
   \      0x10E   0xD10A             BNE.N    ??sli_se_opaque_import_key_5
   1603                goto exit;
   1604              }
   1605          
   1606              psa_status = set_key_buffer_length(attributes,
   1607                                                 data_length + padding,
   1608                                                 key_buffer_length);
   \      0x110   0x4622             MOV      R2,R4
   \      0x112   0x4639             MOV      R1,R7
   \      0x114   0x4648             MOV      R0,R9
   \      0x116   0x.... 0x....      BL       set_key_buffer_length
   \      0x11A   0x4682             MOV      R10,R0
   1609            }
   1610          
   1611            // Cleanup
   1612            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   1613            if (sl_status != SL_STATUS_OK) {
   \                     ??sli_se_opaque_import_key_9: (+1)
   \      0x11C   0xA80A             ADD      R0,SP,#+40
   \      0x11E   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x122   0xB100             CBZ.N    R0,??sli_se_opaque_import_key_5
   1614              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_opaque_import_key_7: (+1)
   \      0x124   0x46B2             MOV      R10,R6
   1615            }
   1616          
   1617            exit:
   1618          
   1619            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1620            sli_psa_zeroize(temp_buffer, sizeof(temp_buffer));
   1621            #endif
   1622          
   1623            return psa_status;
   \                     ??sli_se_opaque_import_key_5: (+1)
   \      0x126   0x4650             MOV      R0,R10
   \                     ??sli_se_opaque_import_key_2: (+1)
   \      0x128   0x....             B.N      ?Subroutine0
   1624          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB01B             ADD      SP,SP,#+108
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x00               DC8 0
   \       0x21                      DS8 3
   1625          

   \                                 In section .text, align 2, keep-with-next
   1626          psa_status_t sli_se_opaque_export_key(const psa_key_attributes_t *attributes,
   1627                                                const uint8_t *key_buffer,
   1628                                                size_t key_buffer_size,
   1629                                                uint8_t *data,
   1630                                                size_t data_size,
   1631                                                size_t *data_length)
   1632          {
   \                     sli_se_opaque_export_key: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09B             SUB      SP,SP,#+108
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4690             MOV      R8,R2
   1633            if (attributes == NULL
   1634                || key_buffer == NULL
   1635                || key_buffer_size == 0
   1636                || data == NULL
   1637                || data_size == 0
   1638                || data_length == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E00             CMPNE    R6,#+0
   \       0x10   0xD00B             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x12   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0xEA5F 0x0A03      MOVSNE   R10,R3
   \       0x1C   0xD005             BEQ.N    ??sli_se_opaque_export_key_0
   \       0x1E   0x9F24             LDR      R7,[SP, #+144]
   \       0x20   0x2F00             CMP      R7,#+0
   \       0x22   0xBF1C             ITT      NE
   \       0x24   0x9D25             LDRNE    R5,[SP, #+148]
   \       0x26   0x2D00             CMPNE    R5,#+0
   \       0x28   0xD102             BNE.N    ??sli_se_opaque_export_key_1
   1639              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_opaque_export_key_0: (+1)
   \       0x2A   0xF06F 0x0086      MVN      R0,#+134
   \       0x2E   0xE058             B.N      ??sli_se_opaque_export_key_2
   1640            }
   1641            // Check that key can be exported
   1642            if (!(psa_get_key_usage_flags(attributes) & PSA_KEY_USAGE_EXPORT)) {
   \                     ??sli_se_opaque_export_key_1: (+1)
   \       0x30   0x7B21             LDRB     R1,[R4, #+12]
   \       0x32   0x07C8             LSLS     R0,R1,#+31
   \       0x34   0xBF58             IT       PL
   \       0x36   0xF06F 0x0084      MVNPL    R0,#+132
   1643              return PSA_ERROR_NOT_PERMITTED;
   \       0x3A   0xD552             BPL.N    ??sli_se_opaque_export_key_2
   1644            }
   1645          
   1646            sl_se_key_descriptor_t imported_key = { 0 };
   \       0x3C   0xA80A             ADD      R0,SP,#+40
   \       0x3E   0x.... 0x....      BL       ??Subroutine3_0
   1647            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
   1648                                                                 key_buffer,
   1649                                                                 key_buffer_size,
   1650                                                                 &imported_key);
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x42   0xAB0A             ADD      R3,SP,#+40
   \       0x44   0x4642             MOV      R2,R8
   \       0x46   0x4631             MOV      R1,R6
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x4E   0xEA5F 0x0800      MOVS     R8,R0
   1651            if (psa_status != PSA_SUCCESS) {
   \       0x52   0xD146             BNE.N    ??sli_se_opaque_export_key_2
   1652              return psa_status;
   1653            }
   1654          
   1655            // Create a plaintext key for the output
   1656            sl_se_key_descriptor_t plaintext_key = imported_key;
   \       0x54   0xA802             ADD      R0,SP,#+8
   \       0x56   0xA90A             ADD      R1,SP,#+40
   \       0x58   0x.... 0x....      BL       ?Subroutine4
   1657            uint32_t storage_size = 0;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x9000             STR      R0,[SP, #+0]
   1658            psa_key_type_t key_type = psa_get_key_type(attributes);
   \       0x60   0x8826             LDRH     R6,[R4, #+0]
   1659            sl_status_t sl_status = sli_key_get_storage_size(&plaintext_key, &storage_size);
   \       0x62   0x4669             MOV      R1,SP
   \       0x64   0xA802             ADD      R0,SP,#+8
   \       0x66   0x.... 0x....      BL       sli_key_get_storage_size
   \       0x6A   0x4683             MOV      R11,R0
   1660            uint32_t prepend_format_byte = sli_se_has_format_byte(key_type);
   \       0x6C   0x4630             MOV      R0,R6
   \       0x6E   0x.... 0x....      BL       sli_se_has_format_byte
   \       0x72   0x4681             MOV      R9,R0
   1661            if (prepend_format_byte == 1) {
   \       0x74   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x78   0xD103             BNE.N    ??sli_se_opaque_export_key_3
   1662              // Make room for the format byte
   1663              *data = 0x04;
   \       0x7A   0x2004             MOVS     R0,#+4
   \       0x7C   0xF80A 0x0B01      STRB     R0,[R10], #+1
   1664              data += 1;
   1665              data_size -= 1;
   \       0x80   0x1E7F             SUBS     R7,R7,#+1
   1666            }
   1667          
   1668            size_t key_bits = psa_get_key_bits(attributes);
   \                     ??sli_se_opaque_export_key_3: (+1)
   \       0x82   0x8860             LDRH     R0,[R4, #+2]
   1669          
   1670            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1671            // We must handle non-word-aligned keys with a temporary buffer
   1672            uint8_t temp_key_buffer[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
   1673            size_t padding = 0;
   1674          
   1675            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1676            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   1677            if (PSA_KEY_TYPE_IS_ECC(key_type)) {
   1678              padding = sli_se_get_padding(key_size);
   1679            }
   1680            #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1681          
   1682            if (padding > 0) {
   1683              if (storage_size > sizeof(temp_key_buffer)) {
   1684                return PSA_ERROR_BUFFER_TOO_SMALL;
   1685              }
   1686              sli_se_key_descriptor_set_plaintext(&plaintext_key,
   1687                                                  temp_key_buffer,
   1688                                                  sizeof(temp_key_buffer));
   1689              storage_size -= padding;
   1690              #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1691              if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   1692                // Padding must be applied twice for public keys
   1693                storage_size -= padding;
   1694              }
   1695              #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1696            } else {
   1697              if ((storage_size - imported_key.size) < 4) {
   1698                // SE manager has rounded the storage size up for word-alignment
   1699                storage_size = imported_key.size;
   1700              }
   1701              sli_se_key_descriptor_set_plaintext(&plaintext_key, data, data_size);
   1702            }
   1703            #else // SLI_SE_KEY_PADDING_REQUIRED
   1704            sli_se_key_descriptor_set_plaintext(&plaintext_key, data, data_size);
   \       0x84   0x463A             MOV      R2,R7
   \       0x86   0x4651             MOV      R1,R10
   \       0x88   0x9001             STR      R0,[SP, #+4]
   \       0x8A   0xA802             ADD      R0,SP,#+8
   \       0x8C   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
   1705            #endif // SLI_SE_KEY_PADDING_REQUIRED
   1706          
   1707            if (sl_status != SL_STATUS_OK) {
   \       0x90   0xF06F 0x0692      MVN      R6,#+146
   \       0x94   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x98   0xD120             BNE.N    ??sli_se_opaque_export_key_4
   1708              return PSA_ERROR_HARDWARE_FAILURE;
   1709            }
   1710            if (storage_size > data_size) {
   \       0x9A   0x9800             LDR      R0,[SP, #+0]
   \       0x9C   0x4287             CMP      R7,R0
   \       0x9E   0xBF38             IT       CC
   \       0xA0   0xF06F 0x0089      MVNCC    R0,#+137
   1711              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xA4   0xD31D             BCC.N    ??sli_se_opaque_export_key_2
   1712            }
   1713          
   1714            // Export key
   1715            sl_se_command_context_t cmd_ctx = { 0 };
   \       0xA6   0xA812             ADD      R0,SP,#+72
   \       0xA8   0x.... 0x....      BL       ?Subroutine2
   1716            sl_status = sl_se_init_command_context(&cmd_ctx);
   1717            if (sl_status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xAC   0xA812             ADD      R0,SP,#+72
   \       0xAE   0x.... 0x....      BL       sl_se_init_command_context
   \       0xB2   0xB998             CBNZ.N   R0,??sli_se_opaque_export_key_4
   1718              return PSA_ERROR_HARDWARE_FAILURE;
   1719            }
   1720            sl_status = sl_se_export_key(&cmd_ctx, &imported_key, &plaintext_key);
   1721            if (sl_status != SL_STATUS_OK) {
   \       0xB4   0xAA02             ADD      R2,SP,#+8
   \       0xB6   0xA90A             ADD      R1,SP,#+40
   \       0xB8   0xA812             ADD      R0,SP,#+72
   \       0xBA   0x.... 0x....      BL       sl_se_export_key
   \       0xBE   0xB108             CBZ.N    R0,??sli_se_opaque_export_key_5
   1722              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0xC0   0x46B0             MOV      R8,R6
   \       0xC2   0xE007             B.N      ??sli_se_opaque_export_key_6
   1723            } else {
   1724              psa_status = PSA_SUCCESS;
   1725          
   1726              #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1727              // Handle padding.
   1728              if (padding > 0) {
   1729                #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1730                // Copy out the padded key
   1731                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(key_type)) {
   1732                  sli_se_unpad_big_endian(temp_key_buffer, data, key_size);
   1733                  sli_psa_zeroize(temp_key_buffer, key_size);
   1734                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(key_type)) {
   1735                  sli_se_unpad_curve_point(temp_key_buffer, data, key_size);
   1736                } else
   1737                #endif   // SLI_PSA_DRIVER_FEATURE_ECC
   1738                {
   1739                  // This should never happen
   1740                  return PSA_ERROR_BAD_STATE;
   1741                }
   1742              }
   1743              #endif // SLI_SE_KEY_PADDING_REQUIRED
   1744          
   1745              // Apply clamping if this is a Montgomery key.
   1746              clamp_private_key_if_needed(attributes, data, key_bits);
   \                     ??sli_se_opaque_export_key_5: (+1)
   \       0xC4   0x9A01             LDR      R2,[SP, #+4]
   \       0xC6   0x4651             MOV      R1,R10
   \       0xC8   0x4620             MOV      R0,R4
   \       0xCA   0x.... 0x....      BL       clamp_private_key_if_needed
   1747          
   1748              // Successful operation. Set ouput length
   1749              *data_length = storage_size + prepend_format_byte;
   \       0xCE   0x9800             LDR      R0,[SP, #+0]
   \       0xD0   0x4448             ADD      R0,R9,R0
   \       0xD2   0x6028             STR      R0,[R5, #+0]
   1750            }
   1751          
   1752            // Cleanup
   1753            sl_status = sl_se_deinit_command_context(&cmd_ctx);
   1754            if (sl_status != SL_STATUS_OK) {
   \                     ??sli_se_opaque_export_key_6: (+1)
   \       0xD4   0xA812             ADD      R0,SP,#+72
   \       0xD6   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xDA   0xB108             CBZ.N    R0,??sli_se_opaque_export_key_7
   1755              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_opaque_export_key_4: (+1)
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0xE000             B.N      ??sli_se_opaque_export_key_2
   1756            }
   1757            return psa_status;
   \                     ??sli_se_opaque_export_key_7: (+1)
   \       0xE0   0x4640             MOV      R0,R8
   \                     ??sli_se_opaque_export_key_2: (+1)
   \       0xE2                      REQUIRE ?Subroutine0
   \       0xE2                      ;; // Fall through to label ?Subroutine0
   1758          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1759          
   1760          #endif // SLI_PSA_DRIVER_FEATURE_WRAPPED_KEYS
   1761          
   1762          // -------------------------------------
   1763          // Transparent driver entry points
   1764          

   \                                 In section .text, align 2, keep-with-next
   1765          psa_status_t sli_se_transparent_generate_key(
   1766            const psa_key_attributes_t *attributes,
   1767            uint8_t *key_buffer,
   1768            size_t key_buffer_size,
   1769            size_t *key_buffer_length)
   1770          {
   \                     sli_se_transparent_generate_key: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1771            psa_key_type_t type = psa_get_key_type(attributes);
   \        0x2   0x8805             LDRH     R5,[R0, #+0]
   1772          
   1773            // We don't support generating symmetric keys with transparent drivers;
   1774            // it should be done by the core instead.
   1775            if (PSA_KEY_TYPE_IS_UNSTRUCTURED(type)) {
   \        0x4   0xF405 0x44E0      AND      R4,R5,#0x7000
   \        0x8   0xF5B4 0x5F80      CMP      R4,#+4096
   \        0xC   0xBF1C             ITT      NE
   \        0xE   0xF405 0x45E0      ANDNE    R5,R5,#0x7000
   \       0x12   0xF5B5 0x5F00      CMPNE    R5,#+8192
   \       0x16   0xD102             BNE.N    ??sli_se_transparent_generate_key_0
   1776              return PSA_ERROR_NOT_SUPPORTED;
   \       0x18   0xF06F 0x0085      MVN      R0,#+133
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
   1777            }
   1778          
   1779            return sli_se_driver_generate_key(attributes,
   1780                                              key_buffer,
   1781                                              key_buffer_size,
   1782                                              key_buffer_length);
   \                     ??sli_se_transparent_generate_key_0: (+1)
   \       0x1E   0xB001             ADD      SP,SP,#+4
   \       0x20   0xE8BD 0x4030      POP      {R4,R5,LR}
   \       0x24   0x....             B.N      sli_se_driver_generate_key
   1783          }
   1784          

   \                                 In section .text, align 2, keep-with-next
   1785          psa_status_t sli_se_transparent_export_public_key(
   1786            const psa_key_attributes_t *attributes,
   1787            const uint8_t *key_buffer,
   1788            size_t key_buffer_size,
   1789            uint8_t *data,
   1790            size_t data_size,
   1791            size_t *data_length)
   1792          {
   \                     sli_se_transparent_export_public_key: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   1793            // If the key is stored transparently and is already a public key,
   1794            // let the core handle it.
   1795            if (PSA_KEY_TYPE_IS_PUBLIC_KEY(psa_get_key_type(attributes))) {
   \        0x2   0x8804             LDRH     R4,[R0, #+0]
   \        0x4   0xF404 0x44E0      AND      R4,R4,#0x7000
   \        0x8   0xF5B4 0x4F80      CMP      R4,#+16384
   \        0xC   0xD102             BNE.N    ??sli_se_transparent_export_public_key_0
   1796              return PSA_ERROR_NOT_SUPPORTED;
   \        0xE   0xF06F 0x0085      MVN      R0,#+133
   \       0x12   0xBD3E             POP      {R1-R5,PC}
   1797            }
   1798          
   1799            return sli_se_driver_export_public_key(attributes,
   1800                                                   key_buffer,
   1801                                                   key_buffer_size,
   1802                                                   data,
   1803                                                   data_size,
   1804                                                   data_length);
   \                     ??sli_se_transparent_export_public_key_0: (+1)
   \       0x14                      REQUIRE ?Subroutine1
   \       0x14                      ;; // Fall through to label ?Subroutine1
   1805          }
   1806          

   \                                 In section .text, align 2, keep-with-next
   1807          psa_status_t sli_se_transparent_import_key(const psa_key_attributes_t *attributes,
   1808                                                     const uint8_t *data,
   1809                                                     size_t data_length,
   1810                                                     uint8_t *key_buffer,
   1811                                                     size_t key_buffer_size,
   1812                                                     size_t *key_buffer_length,
   1813                                                     size_t *bits)
   1814          {
   \                     sli_se_transparent_import_key: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   1815            #if defined(SLI_PSA_DRIVER_FEATURE_ECC)
   1816          
   1817            // Our driver only handles ECC keys (since they are better done accelerated).
   1818            if (PSA_KEY_TYPE_IS_ECC(psa_get_key_type(attributes))) {
   \        0x8   0x8821             LDRH     R1,[R4, #+0]
   \        0xA   0x....             LDR.N    R0,??DataTable22
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x4001             ANDS     R1,R0,R1
   \       0x10   0x4699             MOV      R9,R3
   \       0x12   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x16   0xD11A             BNE.N    ??sli_se_transparent_import_key_0
   \       0x18   0x9D0A             LDR      R5,[SP, #+40]
   1819              psa_status_t status = sli_se_driver_validate_ecc_key(attributes,
   1820                                                                   data,
   1821                                                                   data_length,
   1822                                                                   bits);
   \       0x1A   0x4641             MOV      R1,R8
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x462B             MOV      R3,R5
   \       0x20   0x.... 0x....      BL       sli_se_driver_validate_ecc_key
   1823              if (status != PSA_SUCCESS) {
   \       0x24   0xB9A8             CBNZ.N   R0,??sli_se_transparent_import_key_1
   1824                return status;
   \       0x26   0x9808             LDR      R0,[SP, #+32]
   1825              }
   1826          
   1827              if ( key_buffer_size < data_length ) {
   \       0x28   0x42B0             CMP      R0,R6
   \       0x2A   0xBF38             IT       CC
   \       0x2C   0xF06F 0x0089      MVNCC    R0,#+137
   1828                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x30   0xD30F             BCC.N    ??sli_se_transparent_import_key_1
   \       0x32   0x9F09             LDR      R7,[SP, #+36]
   1829              }
   1830          
   1831              memcpy(key_buffer, data, data_length);
   \       0x34   0x4632             MOV      R2,R6
   \       0x36   0x4641             MOV      R1,R8
   \       0x38   0x4648             MOV      R0,R9
   \       0x3A   0x.... 0x....      BL       __aeabi_memcpy
   1832              clamp_private_key_if_needed(attributes, key_buffer, *bits);
   \       0x3E   0x682A             LDR      R2,[R5, #+0]
   \       0x40   0x4649             MOV      R1,R9
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x.... 0x....      BL       clamp_private_key_if_needed
   1833              *key_buffer_length = data_length;
   \       0x48   0x603E             STR      R6,[R7, #+0]
   1834          
   1835              return PSA_SUCCESS;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xE001             B.N      ??sli_se_transparent_import_key_1
   1836            }
   1837          
   1838            #else // SLI_PSA_DRIVER_FEATURE_ECC
   1839          
   1840            (void)attributes;
   1841            (void)data;
   1842            (void)data_length;
   1843            (void)key_buffer;
   1844            (void)key_buffer_size;
   1845            (void)key_buffer_length;
   1846            (void)bits;
   1847          
   1848            #endif // SLI_PSA_DRIVER_FEATURE_ECC
   1849          
   1850            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_import_key_0: (+1)
   \       0x4E   0xF06F 0x0085      MVN      R0,#+133
   \                     ??sli_se_transparent_import_key_1: (+1)
   \       0x52   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1851          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x8000'0020        DC32     0x80000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0xFEFF'BFFF        DC32     0xfeffbfff
   1852          
   1853          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   clamp_private_key_if_needed
       0   psa_get_key_bits
       0   psa_get_key_lifetime
      16   set_key_buffer_length
        16   -> psa_get_key_lifetime
        16   -> sli_se_has_format_byte
     136   sli_se_driver_export_public_key
       136   -> __aeabi_memclr4
       136   -> __aeabi_memcpy4
       136   -> sl_se_deinit_command_context
       136   -> sl_se_export_public_key
       136   -> sl_se_init_command_context
       136   -> sli_key_get_storage_size
       136   -> sli_se_key_desc_from_input
       136   -> sli_se_key_descriptor_set_plaintext
     112   sli_se_driver_generate_key
       112   -> __aeabi_memclr4
       112   -> clamp_private_key_if_needed
       112   -> set_key_buffer_length
       112   -> sl_se_deinit_command_context
       112   -> sl_se_generate_key
       112   -> sl_se_init_command_context
       112   -> sli_se_key_desc_from_psa_attributes
       112   -> sli_se_set_key_desc_output
       112   -> store_key_desc_in_context
     296   sli_se_driver_validate_ecc_key
       296   -> __aeabi_memclr4
       296   -> __aeabi_memcpy4
       296   -> __aeabi_memset
       296   -> psa_get_key_bits
       296   -> sl_se_ecdh_compute_shared_secret
       296   -> sl_se_init_command_context
       0   sli_se_has_format_byte
      80   sli_se_key_desc_from_input
        80   -> __aeabi_memclr4
        80   -> __aeabi_memcpy
        80   -> __aeabi_memcpy4
        80   -> sli_key_get_size
        80   -> sli_se_has_format_byte
        80   -> sli_se_key_desc_from_psa_attributes
        80   -> sli_se_key_descriptor_set_plaintext
      24   sli_se_key_desc_from_psa_attributes
        24   -> __aeabi_memclr4
       0   sli_se_key_descriptor_set_plaintext
      32   sli_se_opaque_copy_key
        32   -> sli_se_opaque_import_key
     144   sli_se_opaque_export_key
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy4
       144   -> clamp_private_key_if_needed
       144   -> sl_se_deinit_command_context
       144   -> sl_se_export_key
       144   -> sl_se_init_command_context
       144   -> sli_key_get_storage_size
       144   -> sli_se_has_format_byte
       144   -> sli_se_key_desc_from_input
       144   -> sli_se_key_descriptor_set_plaintext
      24   sli_se_opaque_export_public_key
        24   -> sli_se_driver_export_public_key
       0   sli_se_opaque_generate_key
         0   -> sli_se_driver_generate_key
     144   sli_se_opaque_import_key
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy4
       144   -> set_key_buffer_length
       144   -> sl_se_deinit_command_context
       144   -> sl_se_import_key
       144   -> sl_se_init_command_context
       144   -> sli_se_driver_validate_ecc_key
       144   -> sli_se_has_format_byte
       144   -> sli_se_key_desc_from_psa_attributes
       144   -> sli_se_key_descriptor_set_plaintext
       144   -> sli_se_set_key_desc_output
       144   -> store_key_desc_in_context
       8   sli_se_set_key_desc_output
      24   sli_se_transparent_export_public_key
        24   -> sli_se_driver_export_public_key
      16   sli_se_transparent_generate_key
         0   -> sli_se_driver_generate_key
      32   sli_se_transparent_import_key
        32   -> __aeabi_memcpy
        32   -> clamp_private_key_if_needed
        32   -> sli_se_driver_validate_ecc_key
       8   store_key_desc_in_context


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       6  ?Subroutine0
      14  ?Subroutine1
       6  ?Subroutine2
       8  ?Subroutine3
       6  ?Subroutine4
      36  ?_0
      36  ?_1
      32  ?_15
      32  ?_16
      32  ?_17
      32  ?_18
      36  ?_2
      36  ?_3
      36  ?_4
      32  ?_5
      32  ?_6
      32  ?_7
      32  ?_8
       2  clamp_private_key_if_needed
      32  ecc_p256_n
       4  psa_get_key_bits
       4  psa_get_key_lifetime
      52  set_key_buffer_length
     208  sli_se_driver_export_public_key
     220  sli_se_driver_generate_key
     366  sli_se_driver_validate_ecc_key
      44  sli_se_has_format_byte
     458  sli_se_key_desc_from_input
     270  sli_se_key_desc_from_psa_attributes
      16  sli_se_key_descriptor_set_plaintext
      26  sli_se_opaque_copy_key
     226  sli_se_opaque_export_key
       4  sli_se_opaque_export_public_key
       2  sli_se_opaque_generate_key
     298  sli_se_opaque_import_key
      60  sli_se_set_key_desc_output
      20  sli_se_transparent_export_public_key
      38  sli_se_transparent_generate_key
      86  sli_se_transparent_import_key
      42  store_key_desc_in_context
     192  -- Other

 
   372 bytes in section .rodata
 2'786 bytes in section .text
 
 2'786 bytes of CODE  memory
   372 bytes of CONST memory

Errors: none
Warnings: none
