###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:01
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sl_psa_its_nvm3.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sl_psa_its_nvm3.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sl_psa_its_nvm3.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sl_psa_its_nvm3.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sl_psa_its_nvm3.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sl_psa_its_nvm3.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sl_psa_its_nvm3.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief PSA ITS implementation based on Silicon Labs NVM3
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          // The psa_driver_wrappers.h file that we're including here assumes that it has
     32          // access to private struct members. Define this here in order to avoid
     33          // compilation errors.
     34          #define MBEDTLS_ALLOW_PRIVATE_ACCESS
     35          
     36          // -------------------------------------
     37          // Includes
     38          
     39          #include <mbedtls/build_info.h>
     40          
     41          #if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) && !defined(MBEDTLS_PSA_ITS_FILE_C)
     42          
     43          #include "psa/internal_trusted_storage.h"
     44          #include "psa/sli_internal_trusted_storage.h"
     45          #include "nvm3_default.h"
     46          #include "mbedtls/platform.h"
     47          #include <stdbool.h>
     48          #include <string.h>
     49          
     50          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
     51            #include <arm_cmse.h>
     52            #include "psa/storage_common.h"
     53          #endif // TFM_CONFIG_SL_SECURE_LIBRARY
     54          
     55          #if defined(SLI_PSA_ITS_ENCRYPTED)
     56            #include "psa_crypto_core.h"
     57            #include "psa_crypto_driver_wrappers.h"
     58            #if defined(SEMAILBOX_PRESENT)
     59              #include "psa/crypto_extra.h"
     60              #include "sl_psa_values.h"
     61              #include "sli_se_opaque_functions.h"
     62            #endif // defined(SEMAILBOX_PRESENT)
     63          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
     64          
     65          // -------------------------------------
     66          // Threading support
     67          
     68          #if defined(MBEDTLS_THREADING_C)
     69          #include "cmsis_os2.h"
     70          #include "mbedtls/threading.h"
     71          
     72          // Mutex for protecting access to the ITS instance

   \                                 In section .bss, align 4
     73          static mbedtls_threading_mutex_t its_mutex;
     74          static volatile bool its_mutex_inited = false;
   \                     its_mutex_inited:
   \        0x0                      DS8 1
   \        0x1                      DS8 3
   \        0x4                      DS8 100
     75          
     76          /**
     77           * \brief          Lock all task switches
     78           *
     79           * \return         Previous lock state
     80           *
     81           */
     82          static inline int32_t lock_task_switches(void)
     83          {
     84            int32_t kernel_lock_state = 0;
     85            osKernelState_t kernel_state = osKernelGetState();
     86            if (kernel_state != osKernelInactive && kernel_state != osKernelReady) {
     87              kernel_lock_state = osKernelLock();
     88            }
     89            return kernel_lock_state;
     90          }
     91          
     92          /**
     93           * \brief          Restores the previous lock state
     94           */
     95          static inline void restore_lock_state(int32_t kernel_lock_state)
     96          {
     97            osKernelState_t kernel_state = osKernelGetState();
     98            if (kernel_state != osKernelInactive && kernel_state != osKernelReady) {
     99              if (osKernelRestoreLock(kernel_lock_state) < 0) {
    100                EFM_ASSERT(false);
    101              }
    102            }
    103          }
    104          
    105          #endif // defined(MBEDTLS_THREADING_C)
    106          
    107          /**
    108           * \brief Pend on the ITS mutex
    109           */

   \                                 In section .text, align 2, keep-with-next
    110          void sli_its_acquire_mutex(void)
    111          {
   \                     sli_its_acquire_mutex: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    112          #if defined(MBEDTLS_THREADING_C)
    113            if (!its_mutex_inited) {
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable9
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x.... 0x....      LDR.W    R4,??DataTable9_1
   \        0xC   0xBB08             CBNZ.N   R0,??sli_its_acquire_mutex_0
    114              int32_t kernel_lock_state = lock_task_switches();
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0x.... 0x....      BL       osKernelGetState
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2801             CMPNE    R0,#+1
   \       0x1A   0xD002             BEQ.N    ??sli_its_acquire_mutex_1
   \       0x1C   0x.... 0x....      BL       osKernelLock
   \       0x20   0x4606             MOV      R6,R0
    115              if (!its_mutex_inited) {
   \                     ??sli_its_acquire_mutex_1: (+1)
   \       0x22   0x7828             LDRB     R0,[R5, #+0]
   \       0x24   0xB930             CBNZ.N   R0,??sli_its_acquire_mutex_2
    116                mbedtls_mutex_init(&its_mutex);
   \       0x26   0x.... 0x....      LDR.W    R2,??DataTable9_2
   \       0x2A   0x6811             LDR      R1,[R2, #+0]
   \       0x2C   0x1D28             ADDS     R0,R5,#+4
   \       0x2E   0x4788             BLX      R1
    117                its_mutex_inited = true;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x7028             STRB     R0,[R5, #+0]
    118              }
    119              restore_lock_state(kernel_lock_state);
   \                     ??sli_its_acquire_mutex_2: (+1)
   \       0x34   0x.... 0x....      BL       osKernelGetState
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xBF18             IT       NE
   \       0x3C   0x2801             CMPNE    R0,#+1
   \       0x3E   0xD008             BEQ.N    ??sli_its_acquire_mutex_0
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0x.... 0x....      BL       osKernelRestoreLock
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD503             BPL.N    ??sli_its_acquire_mutex_0
   \       0x4A   0x2164             MOVS     R1,#+100
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       assertEFM
    120            }
    121            if (mbedtls_mutex_lock(&its_mutex) != 0) {
   \                     ??sli_its_acquire_mutex_0: (+1)
   \       0x52   0x.... 0x....      LDR.W    R2,??DataTable9_3
   \       0x56   0x6811             LDR      R1,[R2, #+0]
   \       0x58   0x1D28             ADDS     R0,R5,#+4
   \       0x5A   0x4788             BLX      R1
   \       0x5C   0xB128             CBZ.N    R0,??sli_its_acquire_mutex_3
    122              EFM_ASSERT(false);
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x217A             MOVS     R1,#+122
   \       0x62   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x66   0x.... 0x....      B.W      assertEFM
    123            }
    124          #endif
    125          }
   \                     ??sli_its_acquire_mutex_3: (+1)
   \       0x6A   0xBD70             POP      {R4-R6,PC}
    126          
    127          /**
    128           * \brief Free the ITS mutex.
    129           */

   \                                 In section .text, align 2, keep-with-next
    130          void sli_its_release_mutex(void)
    131          {
    132          #if defined(MBEDTLS_THREADING_C)
    133            if (its_mutex_inited) {
   \                     sli_its_release_mutex: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable9
   \        0x4   0x7808             LDRB     R0,[R1, #+0]
   \        0x6   0xB120             CBZ.N    R0,??sli_its_release_mutex_0
    134              mbedtls_mutex_unlock(&its_mutex);
   \        0x8   0x1D08             ADDS     R0,R1,#+4
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable9_4
   \        0xE   0x6811             LDR      R1,[R2, #+0]
   \       0x10   0x4708             BX       R1
    135            }
    136          #endif
    137          }
   \                     ??sli_its_release_mutex_0: (+1)
   \       0x12   0x4770             BX       LR
    138          
    139          // -------------------------------------
    140          // Defines
    141          
    142          #if (!SL_PSA_ITS_SUPPORT_V3_DRIVER)
    143          #define SLI_PSA_ITS_NVM3_RANGE_START SLI_PSA_ITS_NVM3_RANGE_BASE
    144          #define SLI_PSA_ITS_NVM3_RANGE_END   SLI_PSA_ITS_NVM3_RANGE_START + SL_PSA_ITS_MAX_FILES
    145          
    146          #define SLI_PSA_ITS_NVM3_INVALID_KEY (0)
    147          #define SLI_PSA_ITS_NVM3_UNKNOWN_KEY (1)
    148          
    149          #if SL_PSA_ITS_MAX_FILES > SLI_PSA_ITS_NVM3_RANGE_SIZE
    150          #error "Trying to store more ITS files then our NVM3 range allows for"
    151          #endif
    152          
    153          #define SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE 16
    154          
    155          // Enable backwards-compatibility with keys stored with a v1 header unless disabled.
    156          #if !defined(SL_PSA_ITS_REMOVE_V1_HEADER_SUPPORT)
    157          #define SLI_PSA_ITS_SUPPORT_V1_FORMAT
    158          #endif
    159          
    160          // Internal error codes local to this compile unit
    161          #define SLI_PSA_ITS_ECODE_NO_VALID_HEADER (ECODE_EMDRV_NVM3_BASE - 1)
    162          #define SLI_PSA_ITS_ECODE_NEEDS_UPGRADE   (ECODE_EMDRV_NVM3_BASE - 2)
    163          
    164          // SLI_STATIC_TESTABLE is used to expose otherwise-static variables during internal testing.
    165          #if !defined(SLI_STATIC_TESTABLE)
    166          #define SLI_STATIC_TESTABLE static
    167          #endif
    168          
    169          #if defined(SLI_PSA_ITS_ENCRYPTED)
    170          // Define some cryptographic constants if not already set. This depends on the underlying
    171          // crypto accelerator in use (CRYPTOACC has these defines, but not SEMAILBOX).
    172          #if !defined(AES_MAC_SIZE)
    173          #define AES_MAC_SIZE 16
    174          #endif
    175          
    176          #if !defined(AES_IV_GCM_SIZE)
    177          #define AES_IV_GCM_SIZE 12
    178          #endif
    179          
    180          #define SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD  (AES_IV_GCM_SIZE + AES_MAC_SIZE)
    181          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    182          
    183          // -------------------------------------
    184          // Local global static variables
    185          
    186          SLI_STATIC_TESTABLE bool nvm3_uid_set_cache_initialized = false;
    187          SLI_STATIC_TESTABLE uint32_t nvm3_uid_set_cache[(SL_PSA_ITS_MAX_FILES + 31) / 32] = { 0 };
    188          
    189          typedef struct {
    190            psa_storage_uid_t uid;
    191            nvm3_ObjectKey_t object_id;
    192            bool set;
    193          } previous_lookup_t;
    194          
    195          static previous_lookup_t previous_lookup = {
    196            0, 0, false
    197          };
    198          
    199          #if defined(SLI_PSA_ITS_ENCRYPTED)
    200          // The root key is an AES-256 key, and is therefore 32 bytes.
    201          #define ROOT_KEY_SIZE     (32)
    202          // The session key is derived from CMAC, which means it is equal to the AES block size, i.e. 16 bytes
    203          #define SESSION_KEY_SIZE  (16)
    204          
    205          #if !defined(SEMAILBOX_PRESENT)
    206          typedef struct {
    207            bool initialized;
    208            uint8_t data[ROOT_KEY_SIZE];
    209          } root_key_t;
    210          
    211          static root_key_t g_root_key = {
    212            .initialized = false,
    213            .data = { 0 },
    214          };
    215          #endif // !defined(SEMAILBOX_PRESENT)
    216          
    217          typedef struct {
    218            bool active;
    219            psa_storage_uid_t uid;
    220            uint8_t data[SESSION_KEY_SIZE];
    221          } session_key_t;
    222          
    223          static session_key_t g_cached_session_key = {
    224            .active = false,
    225            .uid = 0,
    226            .data = { 0 },
    227          };
    228          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    229          
    230          // -------------------------------------
    231          // Structs
    232          
    233          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
    234          typedef struct {
    235            uint32_t magic;
    236            psa_storage_uid_t uid;
    237            psa_storage_create_flags_t flags;
    238          } sl_its_file_meta_v1_t;
    239          #endif // defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
    240          
    241          // Due to alignment constraints on the 64-bit UID, the v2 header struct is
    242          // serialized to 16 bytes instead of the 24 bytes the v1 header compiles to.
    243          typedef struct {
    244            uint32_t magic;
    245            psa_storage_create_flags_t flags;
    246            psa_storage_uid_t uid;
    247          } sli_its_file_meta_v2_t;
    248          
    249          #if defined(SLI_PSA_ITS_ENCRYPTED)
    250          typedef struct {
    251            uint8_t iv[AES_IV_GCM_SIZE];
    252            // When encrypted & authenticated, MAC is stored at the end of the data array
    253            uint8_t data[];
    254          } sli_its_encrypted_blob_t;
    255          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    256          
    257          // -------------------------------------
    258          // Local function prototypes
    259          
    260          static nvm3_ObjectKey_t get_nvm3_id(psa_storage_uid_t uid, bool find_empty_slot);
    261          static nvm3_ObjectKey_t prepare_its_get_nvm3_id(psa_storage_uid_t uid);
    262          
    263          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    264          static inline bool object_lives_in_s(const void *object, size_t object_size);
    265          #endif // defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    266          
    267          #if defined(SLI_PSA_ITS_ENCRYPTED)
    268          static psa_status_t derive_session_key(uint8_t *iv,
    269                                                 size_t iv_size,
    270                                                 uint8_t *session_key,
    271                                                 size_t session_key_size);
    272          
    273          static psa_status_t encrypt_its_file(sli_its_file_meta_v2_t *metadata,
    274                                               uint8_t *plaintext,
    275                                               size_t plaintext_size,
    276                                               sli_its_encrypted_blob_t *blob,
    277                                               size_t blob_size,
    278                                               size_t *blob_length);
    279          
    280          static psa_status_t decrypt_its_file(sli_its_file_meta_v2_t *metadata,
    281                                               sli_its_encrypted_blob_t *blob,
    282                                               size_t blob_size,
    283                                               uint8_t *plaintext,
    284                                               size_t plaintext_size,
    285                                               size_t *plaintext_length);
    286          
    287          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
    288                                                    psa_storage_uid_t *authenticated_uid);
    289          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    290          
    291          // -------------------------------------
    292          // Local function definitions
    293          
    294          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    295          // If an object of given size is fully encapsulated in a region of
    296          // secure domain the function returns true.
    297          static inline bool object_lives_in_s(const void *object, size_t object_size)
    298          {
    299            cmse_address_info_t cmse_flags;
    300          
    301            for (size_t i = 0u; i < object_size; i++) {
    302              cmse_flags = cmse_TTA((uint32_t *)object + i);
    303              if (!cmse_flags.flags.secure) {
    304                return false;
    305              }
    306            }
    307          
    308            return true;
    309          }
    310          #endif // defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    311          
    312          static inline void cache_set(nvm3_ObjectKey_t key)
    313          {
    314            uint32_t i = key - SLI_PSA_ITS_NVM3_RANGE_START;
    315            uint32_t bin = i / 32;
    316            uint32_t offset = i - 32 * bin;
    317            nvm3_uid_set_cache[bin] |= (1 << offset);
    318          }
    319          
    320          static inline void cache_clear(nvm3_ObjectKey_t key)
    321          {
    322            uint32_t i = key - SLI_PSA_ITS_NVM3_RANGE_START;
    323            uint32_t bin = i / 32;
    324            uint32_t offset = i - 32 * bin;
    325            nvm3_uid_set_cache[bin] ^= (1 << offset);
    326          }
    327          
    328          static inline bool cache_lookup(nvm3_ObjectKey_t key)
    329          {
    330            uint32_t i = key - SLI_PSA_ITS_NVM3_RANGE_START;
    331            uint32_t bin = i / 32;
    332            uint32_t offset = i - 32 * bin;
    333            return (bool)((nvm3_uid_set_cache[bin] >> offset) & 0x1);
    334          }
    335          
    336          static void init_cache(void)
    337          {
    338            size_t num_keys_referenced_by_nvm3;
    339            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = { 0 };
    340          
    341            for (nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START;
    342                 range_start < SLI_PSA_ITS_NVM3_RANGE_END;
    343                 range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE) {
    344              nvm3_ObjectKey_t range_end = range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
    345              if (range_end > SLI_PSA_ITS_NVM3_RANGE_END) {
    346                range_end = SLI_PSA_ITS_NVM3_RANGE_END;
    347              }
    348          
    349              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
    350                                                             keys_referenced_by_nvm3,
    351                                                             sizeof(keys_referenced_by_nvm3) / sizeof(nvm3_ObjectKey_t),
    352                                                             range_start,
    353                                                             range_end - 1);
    354          
    355              for (size_t i = 0; i < num_keys_referenced_by_nvm3; i++) {
    356                cache_set(keys_referenced_by_nvm3[i]);
    357              }
    358            }
    359          
    360            nvm3_uid_set_cache_initialized = true;
    361          }
    362          
    363          // Read the file metadata for a specific NVM3 ID
    364          static Ecode_t get_file_metadata(nvm3_ObjectKey_t key,
    365                                           sli_its_file_meta_v2_t* metadata,
    366                                           size_t* its_file_offset,
    367                                           size_t* its_file_size)
    368          {
    369            // Initialize output variables to safe default
    370            if (its_file_offset != NULL) {
    371              *its_file_offset = 0;
    372            }
    373            if (its_file_size != NULL) {
    374              *its_file_size = 0;
    375            }
    376          
    377            Ecode_t status = nvm3_readPartialData(nvm3_defaultHandle,
    378                                                  key,
    379                                                  metadata,
    380                                                  0,
    381                                                  sizeof(sli_its_file_meta_v2_t));
    382            if (status != ECODE_NVM3_OK) {
    383              return status;
    384            }
    385          
    386          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
    387            // Re-read in v1 header format and translate to the latest structure version
    388            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V1) {
    389              sl_its_file_meta_v1_t key_meta_v1 = { 0 };
    390              status = nvm3_readPartialData(nvm3_defaultHandle,
    391                                            key,
    392                                            &key_meta_v1,
    393                                            0,
    394                                            sizeof(sl_its_file_meta_v1_t));
    395          
    396              if (status != ECODE_NVM3_OK) {
    397                return status;
    398              }
    399          
    400              metadata->flags = key_meta_v1.flags;
    401              metadata->uid = key_meta_v1.uid;
    402              metadata->magic = SLI_PSA_ITS_META_MAGIC_V2;
    403          
    404              if (its_file_offset != NULL) {
    405                *its_file_offset = sizeof(sl_its_file_meta_v1_t);
    406              }
    407          
    408              status = SLI_PSA_ITS_ECODE_NEEDS_UPGRADE;
    409            } else
    410          #endif
    411            {
    412              if (its_file_offset != NULL) {
    413                *its_file_offset = sizeof(sli_its_file_meta_v2_t);
    414              }
    415            }
    416          
    417            if (metadata->magic != SLI_PSA_ITS_META_MAGIC_V2) {
    418              // No valid header found in this object
    419              return SLI_PSA_ITS_ECODE_NO_VALID_HEADER;
    420            }
    421          
    422            if (its_file_offset != NULL && its_file_size != NULL) {
    423              // Calculate the ITS file size if requested
    424              uint32_t obj_type;
    425              Ecode_t info_status = nvm3_getObjectInfo(nvm3_defaultHandle,
    426                                                       key,
    427                                                       &obj_type,
    428                                                       its_file_size);
    429              if (info_status != ECODE_NVM3_OK) {
    430                return info_status;
    431              }
    432          
    433              *its_file_size = *its_file_size - *its_file_offset;
    434            }
    435          
    436            return status;
    437          }
    438          
    439          // Search through NVM3 for uid
    440          static nvm3_ObjectKey_t get_nvm3_id(psa_storage_uid_t uid, bool find_empty_slot)
    441          {
    442            Ecode_t status;
    443            sli_its_file_meta_v2_t key_meta;
    444          
    445            if (find_empty_slot) {
    446              for (size_t i = 0; i < SL_PSA_ITS_MAX_FILES; i++) {
    447                if (!cache_lookup(i + SLI_PSA_ITS_NVM3_RANGE_START)) {
    448                  return i + SLI_PSA_ITS_NVM3_RANGE_START;
    449                }
    450              }
    451            } else {
    452              if (previous_lookup.set) {
    453                if (previous_lookup.uid == uid) {
    454                  return previous_lookup.object_id;
    455                }
    456              }
    457          
    458              for (size_t i = 0; i < SL_PSA_ITS_MAX_FILES; i++) {
    459                if (!cache_lookup(i + SLI_PSA_ITS_NVM3_RANGE_START)) {
    460                  continue;
    461                }
    462                nvm3_ObjectKey_t object_id = i + SLI_PSA_ITS_NVM3_RANGE_START;
    463          
    464                status = get_file_metadata(object_id, &key_meta, NULL, NULL);
    465          
    466                if (status == ECODE_NVM3_OK
    467                    || status == SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
    468                  if (key_meta.uid == uid) {
    469                    previous_lookup.set = true;
    470                    previous_lookup.object_id = object_id;
    471                    previous_lookup.uid = uid;
    472          
    473                    return object_id;
    474                  } else {
    475                    continue;
    476                  }
    477                }
    478          
    479                if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER
    480                    || status == ECODE_NVM3_ERR_READ_DATA_SIZE) {
    481                  // we don't expect any other data in our range then PSA ITS files.
    482                  // delete the file if the magic doesn't match or the object on disk
    483                  // is too small to even have full metadata.
    484                  status = nvm3_deleteObject(nvm3_defaultHandle, object_id);
    485                  if (status != ECODE_NVM3_OK) {
    486                    return SLI_PSA_ITS_NVM3_RANGE_END + 1U;
    487                  }
    488                }
    489              }
    490            }
    491          
    492            return SLI_PSA_ITS_NVM3_RANGE_END + 1U;
    493          }
    494          
    495          // Perform NVM3 open and fill the look-up table.
    496          // Try to find the mapping NVM3 object ID with PSA ITS UID.
    497          static nvm3_ObjectKey_t prepare_its_get_nvm3_id(psa_storage_uid_t uid)
    498          {
    499          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    500            // With SKL the NVM3 instance must be initialized by the NS app. We therefore check that
    501            // it has been opened (which is done on init) rather than actually doing the init.
    502            if (!nvm3_defaultHandle->hasBeenOpened) {
    503          #else
    504            if (nvm3_initDefault() != ECODE_NVM3_OK) {
    505          #endif
    506              return SLI_PSA_ITS_NVM3_RANGE_END + 1U;
    507            }
    508          
    509            if (nvm3_uid_set_cache_initialized == false) {
    510              init_cache();
    511            }
    512          
    513            return get_nvm3_id(uid, false);
    514          }
    515          
    516          #if defined(SLI_PSA_ITS_ENCRYPTED)
    517          static inline void cache_session_key(uint8_t *session_key, psa_storage_uid_t uid)
    518          {
    519            // Cache the session key
    520            memcpy(g_cached_session_key.data, session_key, sizeof(g_cached_session_key.data));
    521            g_cached_session_key.uid = uid;
    522            g_cached_session_key.active = true;
    523          }
    524          
    525          /**
    526           * \brief Derive a session key for ITS file encryption from the initialized root key and provided IV.
    527           *
    528           * \param[in] iv                Pointer to array containing the initialization vector to be used in the key derivation.
    529           * \param[in] iv_size           Size of the IV buffer in bytes. Must be 12 bytes (AES-GCM IV size).
    530           * \param[out] session_key      Pointer to array where derived session key shall be stored.
    531           * \param[out] session_key_size Size of the derived session key output array. Must be at least 32 bytes (AES-256 key size).
    532           *
    533           * \return      A status indicating the success/failure of the operation
    534           *
    535           * \retval      PSA_SUCCESS                      The operation completed successfully
    536           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    537           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because iv or session_key is NULL, or their sizes are incorrect.
    538           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    539           */
    540          static psa_status_t derive_session_key(uint8_t *iv, size_t iv_size, uint8_t *session_key, size_t session_key_size)
    541          {
    542            if (iv == NULL
    543                || iv_size != AES_IV_GCM_SIZE
    544                || session_key == NULL
    545                || session_key_size < SESSION_KEY_SIZE) {
    546              return PSA_ERROR_INVALID_ARGUMENT;
    547            }
    548          
    549            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    550            psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    551          
    552          #if defined(SEMAILBOX_PRESENT)
    553            // For HSE devices, use the builtin TrustZone Root Key
    554            psa_set_key_id(&attributes, SL_SE_BUILTIN_KEY_TRUSTZONE_ID);
    555          
    556            psa_key_lifetime_t reported_lifetime;
    557            psa_drv_slot_number_t reported_slot;
    558            status = mbedtls_psa_platform_get_builtin_key(psa_get_key_id(&attributes),
    559                                                          &reported_lifetime,
    560                                                          &reported_slot);
    561          
    562            if (status != PSA_SUCCESS) {
    563              return status;
    564            }
    565          
    566            psa_set_key_lifetime(&attributes, reported_lifetime);
    567          
    568            uint8_t key_buffer[sizeof(sli_se_opaque_key_context_header_t)];
    569            size_t key_buffer_size;
    570            status = sli_se_opaque_get_builtin_key(reported_slot,
    571                                                   &attributes,
    572                                                   key_buffer,
    573                                                   sizeof(key_buffer),
    574                                                   &key_buffer_size);
    575            if (status != PSA_SUCCESS) {
    576              return status;
    577            }
    578          #else // defined(SEMAILBOX_PRESENT)
    579            // For VSE devices, use the previously initialized root key
    580            if (!g_root_key.initialized) {
    581              return PSA_ERROR_BAD_STATE;
    582            }
    583          
    584            // Prepare root key attributes
    585            psa_set_key_algorithm(&attributes, PSA_ALG_CMAC);
    586            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    587            psa_set_key_bits(&attributes, ROOT_KEY_SIZE * 8);
    588          
    589            // Point the key buffer to the global root key
    590            uint8_t *key_buffer = (uint8_t*)g_root_key.data;
    591            size_t key_buffer_size = sizeof(g_root_key.data);
    592          #endif // defined(SEMAILBOX_PRESENT)
    593          
    594            // Use CMAC as a key derivation function
    595            size_t session_key_length;
    596            status = psa_driver_wrapper_mac_compute(
    597              &attributes,
    598              key_buffer,
    599              key_buffer_size,
    600              PSA_ALG_CMAC,
    601              iv,
    602              iv_size,
    603              session_key,
    604              session_key_size,
    605              &session_key_length);
    606          
    607            // Verify that the key derivation was successful before transferring the key to the caller
    608            if (status != PSA_SUCCESS || session_key_length != SESSION_KEY_SIZE) {
    609              memset(session_key, 0, session_key_size);
    610              return PSA_ERROR_HARDWARE_FAILURE;
    611            }
    612          
    613            return status;
    614          }
    615          
    616          /**
    617           * \brief Encrypt and authenticate ITS data with AES-128-GCM, storing the result in an encrypted blob.
    618           *
    619           * \param[in] metadata        ITS metadata to be used as authenticated additional data.
    620           * \param[in] plaintext       Pointer to array containing data to be encrypted.
    621           * \param[in] plaintext_size  Size of provided plaintext data array.
    622           * \param[out] blob           Pointer to array where the resulting encrypted blob shall be placed.
    623           * \param[in] blob_size       Size of the output array. Must be at least as big as plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
    624           * \param[out] blob_length    Resulting size of the output blob.
    625           *
    626           * \return      A status indicating the success/failure of the operation
    627           *
    628           * \retval      PSA_SUCCESS                      The operation completed successfully
    629           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    630           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
    631           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    632           */
    633          static psa_status_t encrypt_its_file(sli_its_file_meta_v2_t *metadata,
    634                                               uint8_t *plaintext,
    635                                               size_t plaintext_size,
    636                                               sli_its_encrypted_blob_t *blob,
    637                                               size_t blob_size,
    638                                               size_t *blob_length)
    639          {
    640            if (metadata == NULL
    641                || (plaintext == NULL && plaintext_size > 0)
    642                || blob == NULL
    643                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
    644                || blob_length == NULL) {
    645              return PSA_ERROR_INVALID_ARGUMENT;
    646            }
    647          
    648            // Generate IV
    649            size_t iv_length = 0;
    650            psa_status_t psa_status = mbedtls_psa_external_get_random(NULL, blob->iv, AES_IV_GCM_SIZE, &iv_length);
    651          
    652            if (psa_status != PSA_SUCCESS || iv_length != AES_IV_GCM_SIZE) {
    653              return PSA_ERROR_HARDWARE_FAILURE;
    654            }
    655          
    656            // Prepare encryption key
    657            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    658            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    659            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
    660            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    661            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
    662          
    663            uint8_t session_key[SESSION_KEY_SIZE];
    664            psa_status = derive_session_key(blob->iv, AES_IV_GCM_SIZE, session_key, sizeof(session_key));
    665            if (psa_status != PSA_SUCCESS) {
    666              return psa_status;
    667            }
    668          
    669            cache_session_key(session_key, metadata->uid);
    670          
    671            // Retrieve data to be encrypted
    672            if (plaintext_size != 0U) {
    673              memcpy(blob->data, ((uint8_t*)plaintext), plaintext_size);
    674            }
    675          
    676            // Encrypt and authenticate blob
    677            size_t output_length = 0;
    678            psa_status = psa_driver_wrapper_aead_encrypt(
    679              &attributes,
    680              session_key, sizeof(session_key),
    681              PSA_ALG_GCM,
    682              blob->iv, sizeof(blob->iv),
    683              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
    684              blob->data, plaintext_size,
    685              blob->data, plaintext_size + AES_MAC_SIZE,    // output == input for in-place encryption
    686              &output_length);
    687          
    688            // Clear the local session key immediately after we're done using it
    689            memset(session_key, 0, sizeof(session_key));
    690          
    691            if (psa_status != PSA_SUCCESS) {
    692              return PSA_ERROR_HARDWARE_FAILURE;
    693            }
    694          
    695            if (output_length != plaintext_size + AES_MAC_SIZE) {
    696              return PSA_ERROR_HARDWARE_FAILURE;
    697            }
    698          
    699            *blob_length = output_length + AES_IV_GCM_SIZE;
    700          
    701            return PSA_SUCCESS;
    702          }
    703          
    704          /**
    705           * \brief Decrypt and authenticate encrypted ITS data.
    706           *
    707           * \param[in] metadata          ITS metadata to be used as authenticated additional data. Must be identical to the metadata used during encryption.
    708           * \param[in] blob              Encrypted blob containing data to be decrypted.
    709           * \param[in] blob_size         Size of the encrypted blob in bytes.
    710           * \param[out] plaintext        Pointer to array where the decrypted plaintext shall be placed.
    711           * \param[in] plaintext_size    Size of the plaintext array. Must be equal to sizeof(blob->data) - AES_MAC_SIZE.
    712           * \param[out] plaintext_length Resulting length of the decrypted plaintext.
    713           *
    714           * \return      A status indicating the success/failure of the operation
    715           *
    716           * \retval      PSA_SUCCESS                      The operation completed successfully
    717           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
    718           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    719           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
    720           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    721           */
    722          static psa_status_t decrypt_its_file(sli_its_file_meta_v2_t *metadata,
    723                                               sli_its_encrypted_blob_t *blob,
    724                                               size_t blob_size,
    725                                               uint8_t *plaintext,
    726                                               size_t plaintext_size,
    727                                               size_t *plaintext_length)
    728          {
    729            if (metadata == NULL
    730                || blob == NULL
    731                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
    732                || (plaintext == NULL && plaintext_size > 0)
    733                || plaintext_length == NULL) {
    734              return PSA_ERROR_INVALID_ARGUMENT;
    735            }
    736          
    737            // Prepare decryption key
    738            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    739            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    740            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
    741            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
    742            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
    743          
    744            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
    745            uint8_t session_key[SESSION_KEY_SIZE];
    746          
    747            if (g_cached_session_key.active && g_cached_session_key.uid == metadata->uid) {
    748              // Use cached session key if it's already set and UID matches
    749              memcpy(session_key, g_cached_session_key.data, sizeof(session_key));
    750            } else {
    751              psa_status = derive_session_key(blob->iv, AES_IV_GCM_SIZE, session_key, sizeof(session_key));
    752              if (psa_status != PSA_SUCCESS) {
    753                return psa_status;
    754              }
    755              cache_session_key(session_key, metadata->uid);
    756            }
    757          
    758            // Decrypt and authenticate blob
    759            size_t output_length = 0;
    760            psa_status = psa_driver_wrapper_aead_decrypt(
    761              &attributes,
    762              session_key, sizeof(session_key),
    763              PSA_ALG_GCM,
    764              blob->iv, sizeof(blob->iv),
    765              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
    766              blob->data, plaintext_size + AES_MAC_SIZE,
    767              plaintext, plaintext_size,
    768              &output_length);
    769          
    770            // Clear the session key immediately after we're done using it
    771            memset(session_key, 0, sizeof(session_key));
    772          
    773            // Invalid signature likely means that NVM data was tampered with
    774            if (psa_status == PSA_ERROR_INVALID_SIGNATURE) {
    775              return PSA_ERROR_INVALID_SIGNATURE;
    776            }
    777          
    778            if (psa_status != PSA_SUCCESS
    779                || output_length != plaintext_size) {
    780              return PSA_ERROR_HARDWARE_FAILURE;
    781            }
    782          
    783            *plaintext_length = output_length;
    784          
    785            return PSA_SUCCESS;
    786          }
    787          
    788          /**
    789           * \brief Authenticate encrypted ITS data and return the UID of the ITS file that was authenticated.
    790           *
    791           * \details NOTE: This function will run decrypt_its_file() internally. The difference from the decrypt_its_file()
    792           *          function is that authenticate_its_file() reads the NVM3 data, decrypts it in order to authenticate the
    793           *          stored data, and then discards the plaintext. This is needed since PSA Crypto doesn't support the
    794           *          GMAC primitive directly, which means we have to run a full GCM decrypt for authentication.
    795           *
    796           * \param[in] nvm3_object_id      The NVM3 id corresponding to the stored ITS file.
    797           * \param[out] authenticated_uid  UID for the authenticated ITS file.
    798           *
    799           * \return      A status indicating the success/failure of the operation
    800           *
    801           * \retval      PSA_SUCCESS                      The operation completed successfully
    802           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
    803           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
    804           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
    805           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    806           */
    807          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
    808                                                    psa_storage_uid_t *authenticated_uid)
    809          {
    810            psa_status_t ret = PSA_ERROR_CORRUPTION_DETECTED;
    811            sli_its_file_meta_v2_t *its_file_meta = NULL;
    812            sli_its_encrypted_blob_t *blob = NULL;
    813          
    814            uint32_t obj_type;
    815            size_t its_file_size = 0;
    816            Ecode_t status = nvm3_getObjectInfo(nvm3_defaultHandle,
    817                                                nvm3_object_id,
    818                                                &obj_type,
    819                                                &its_file_size);
    820            if (status != ECODE_NVM3_OK) {
    821              return PSA_ERROR_STORAGE_FAILURE;
    822            }
    823          
    824            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size);
    825            if (its_file_buffer == NULL) {
    826              return PSA_ERROR_INSUFFICIENT_MEMORY;
    827            }
    828            memset(its_file_buffer, 0, its_file_size);
    829          
    830            status = nvm3_readData(nvm3_defaultHandle,
    831                                   nvm3_object_id,
    832                                   its_file_buffer,
    833                                   its_file_size);
    834            if (status != ECODE_NVM3_OK) {
    835              ret = PSA_ERROR_STORAGE_FAILURE;
    836              goto cleanup;
    837            }
    838          
    839            its_file_meta = (sli_its_file_meta_v2_t*)its_file_buffer;
    840            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
    841          
    842            // Decrypt and authenticate blob
    843            size_t plaintext_length;
    844            ret = decrypt_its_file(its_file_meta,
    845                                   blob,
    846                                   its_file_size - sizeof(sli_its_file_meta_v2_t),
    847                                   blob->data,
    848                                   its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
    849                                   &plaintext_length);
    850          
    851            if (ret != PSA_SUCCESS) {
    852              goto cleanup;
    853            }
    854          
    855            if (plaintext_length != (its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
    856              ret = PSA_ERROR_INVALID_SIGNATURE;
    857              goto cleanup;
    858            }
    859          
    860            if (authenticated_uid != NULL) {
    861              *authenticated_uid = its_file_meta->uid;
    862            }
    863          
    864            ret = PSA_SUCCESS;
    865          
    866            cleanup:
    867          
    868            // Discard output, as we're only interested in whether the authentication check passed or not.
    869            memset(its_file_buffer, 0, its_file_size);
    870            mbedtls_free(its_file_buffer);
    871          
    872            return ret;
    873          }
    874          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
    875          
    876          // -------------------------------------
    877          // Global function definitions
    878          
    879          /**
    880           * \brief create a new or modify an existing uid/value pair
    881           *
    882           * \param[in] uid           the identifier for the data
    883           * \param[in] data_length   The size in bytes of the data in `p_data`
    884           * \param[in] p_data        A buffer containing the data
    885           * \param[in] create_flags  The flags that the data will be stored with
    886           *
    887           * \return      A status indicating the success/failure of the operation
    888           *
    889           * \retval      PSA_SUCCESS                      The operation completed successfully
    890           * \retval      PSA_ERROR_NOT_PERMITTED          The operation failed because the provided `uid` value was already created with PSA_STORAGE_FLAG_WRITE_ONCE
    891           * \retval      PSA_ERROR_NOT_SUPPORTED          The operation failed because one or more of the flags provided in `create_flags` is not supported or is not valid
    892           * \retval      PSA_ERROR_INSUFFICIENT_STORAGE   The operation failed because there was insufficient space on the storage medium
    893           * \retval      PSA_ERROR_STORAGE_FAILURE        The operation failed because the physical storage has failed (Fatal error)
    894           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one of the provided pointers(`p_data`)
    895           *                                               is invalid, for example is `NULL` or references memory the caller cannot access
    896           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
    897           */
    898          psa_status_t psa_its_set(psa_storage_uid_t uid,
    899                                   uint32_t data_length,
    900                                   const void *p_data,
    901                                   psa_storage_create_flags_t create_flags)
    902          {
    903            if (data_length > NVM3_MAX_OBJECT_SIZE) {
    904              return PSA_ERROR_STORAGE_FAILURE;
    905            }
    906            if ((data_length != 0U) && (p_data == NULL)) {
    907              return PSA_ERROR_INVALID_ARGUMENT;
    908            }
    909          
    910            if (create_flags != PSA_STORAGE_FLAG_WRITE_ONCE
    911                && create_flags != PSA_STORAGE_FLAG_NONE
    912          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    913                && create_flags != PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
    914          #endif
    915                ) {
    916              return PSA_ERROR_NOT_SUPPORTED;
    917            }
    918          
    919          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    920            if ((create_flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
    921                && (!object_lives_in_s(p_data, data_length))) {
    922              // The flag indicates that this data should not be set by the non-secure domain
    923              return PSA_ERROR_INVALID_ARGUMENT;
    924            }
    925          #endif
    926            sli_its_acquire_mutex();
    927            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
    928            Ecode_t status;
    929            psa_status_t ret = PSA_SUCCESS;
    930            sli_its_file_meta_v2_t* its_file_meta;
    931          
    932          #if defined(SLI_PSA_ITS_ENCRYPTED)
    933            psa_storage_uid_t authenticated_uid;
    934            sli_its_encrypted_blob_t *blob = NULL;
    935            size_t blob_length = 0u;
    936            psa_status_t psa_status;
    937          
    938            size_t its_file_size = data_length + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
    939          #else
    940            size_t its_file_size = data_length;
    941          #endif
    942          
    943            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sli_its_file_meta_v2_t));
    944            if (its_file_buffer == NULL) {
    945              ret = PSA_ERROR_INSUFFICIENT_MEMORY;
    946              goto exit;
    947            }
    948            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
    949          
    950            its_file_meta = (sli_its_file_meta_v2_t *)its_file_buffer;
    951            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
    952              // ITS UID was not found. Request a new.
    953              nvm3_object_id = get_nvm3_id(0ULL, true);
    954              if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
    955                // The storage is full, or an error was returned during cleanup.
    956                ret = PSA_ERROR_INSUFFICIENT_STORAGE;
    957              } else {
    958                its_file_meta->uid = uid;
    959                its_file_meta->magic = SLI_PSA_ITS_META_MAGIC_V2;
    960              }
    961            } else {
    962              // ITS UID was found. Read ITS meta data.
    963              status = get_file_metadata(nvm3_object_id, its_file_meta, NULL, NULL);
    964          
    965              if (status != ECODE_NVM3_OK
    966                  && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
    967                ret = PSA_ERROR_STORAGE_FAILURE;
    968                goto exit;
    969              }
    970          
    971              if (its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE
    972          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
    973                  || its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
    974          #endif
    975                  ) {
    976                ret = PSA_ERROR_NOT_PERMITTED;
    977                goto exit;
    978              }
    979          
    980          #if defined(SLI_PSA_ITS_ENCRYPTED)
    981              // If the UID already exists, authenticate the existing value and make sure the stored UID is the same.
    982              ret = authenticate_its_file(nvm3_object_id, &authenticated_uid);
    983              if (ret != PSA_SUCCESS) {
    984                goto exit;
    985              }
    986          
    987              if (authenticated_uid != uid) {
    988                ret = PSA_ERROR_NOT_PERMITTED;
    989                goto exit;
    990              }
    991          #endif
    992            }
    993          
    994            its_file_meta->flags = create_flags;
    995          
    996          #if defined(SLI_PSA_ITS_ENCRYPTED)
    997            // Everything after the file metadata will make up the encrypted & authenticated blob
    998            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
    999          
   1000            // Encrypt and authenticate the provided data
   1001            psa_status = encrypt_its_file(its_file_meta,
   1002                                          (uint8_t*)p_data,
   1003                                          data_length,
   1004                                          blob,
   1005                                          its_file_size,
   1006                                          &blob_length);
   1007          
   1008            if (psa_status != PSA_SUCCESS) {
   1009              ret = psa_status;
   1010              goto exit;
   1011            }
   1012          
   1013            if (blob_length != its_file_size) {
   1014              ret = PSA_ERROR_HARDWARE_FAILURE;
   1015              goto exit;
   1016            }
   1017          
   1018          #else
   1019            if (data_length != 0U) {
   1020              memcpy(its_file_buffer + sizeof(sli_its_file_meta_v2_t), ((uint8_t*)p_data), data_length);
   1021            }
   1022          #endif
   1023          
   1024            status = nvm3_writeData(nvm3_defaultHandle,
   1025                                    nvm3_object_id,
   1026                                    its_file_buffer, its_file_size + sizeof(sli_its_file_meta_v2_t));
   1027          
   1028            if (status == ECODE_NVM3_OK) {
   1029              // Power-loss might occur, however upon boot, the look-up table will be
   1030              // re-filled as long as the data has been successfully written to NVM3.
   1031              cache_set(nvm3_object_id);
   1032            } else {
   1033              ret = PSA_ERROR_STORAGE_FAILURE;
   1034            }
   1035          
   1036            exit:
   1037            if (its_file_buffer != NULL) {
   1038              // Clear and free key buffer before return.
   1039              memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   1040              mbedtls_free(its_file_buffer);
   1041            }
   1042            sli_its_release_mutex();
   1043            return ret;
   1044          }
   1045          
   1046          /**
   1047           * \brief Retrieve the value associated with a provided uid
   1048           *
   1049           * \param[in] uid               The uid value
   1050           * \param[in] data_offset       The starting offset of the data requested
   1051           * \param[in] data_length       the amount of data requested (and the minimum allocated size of the `p_data` buffer)
   1052           * \param[out] p_data           The buffer where the data will be placed upon successful completion
   1053           * \param[out] p_data_length    The amount of data returned in the p_data buffer
   1054           *
   1055           *
   1056           * \return      A status indicating the success/failure of the operation
   1057           *
   1058           * \retval      PSA_SUCCESS                  The operation completed successfully
   1059           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided `uid` value was not found in the storage
   1060           * \retval      PSA_ERROR_BUFFER_TOO_SMALL   The operation failed because the data associated with provided uid is larger than `data_size`
   1061           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   1062           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_data`, `p_data_length`)
   1063           *                                           is invalid. For example is `NULL` or references memory the caller cannot access.
   1064           *                                           In addition, this can also happen if an invalid offset was provided.
   1065           */
   1066          psa_status_t psa_its_get(psa_storage_uid_t uid,
   1067                                   uint32_t data_offset,
   1068                                   uint32_t data_length,
   1069                                   void *p_data,
   1070                                   size_t *p_data_length)
   1071          {
   1072            psa_status_t ret = PSA_ERROR_CORRUPTION_DETECTED;
   1073          
   1074            if ((data_length != 0U) && (p_data_length == NULL)) {
   1075              return PSA_ERROR_INVALID_ARGUMENT;
   1076            }
   1077          
   1078            if (data_length != 0U) {
   1079              // If the request amount of data is 0, allow invalid pointer of the output buffer.
   1080              if ((p_data == NULL)
   1081                  || ((uint32_t)p_data < SRAM_BASE)
   1082                  || ((uint32_t)p_data > (SRAM_BASE + SRAM_SIZE - data_length))) {
   1083                return PSA_ERROR_INVALID_ARGUMENT;
   1084              }
   1085            }
   1086          
   1087          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1088            sli_its_encrypted_blob_t *blob = NULL;
   1089            size_t plaintext_length;
   1090            psa_status_t psa_status;
   1091          #endif
   1092            size_t its_file_data_size = 0u;
   1093            Ecode_t status;
   1094            sli_its_file_meta_v2_t its_file_meta = { 0 };
   1095            size_t its_file_size = 0;
   1096            size_t its_file_offset = 0;
   1097          
   1098            sli_its_acquire_mutex();
   1099            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
   1100            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1101              ret = PSA_ERROR_DOES_NOT_EXIST;
   1102              goto exit;
   1103            }
   1104          
   1105            status = get_file_metadata(nvm3_object_id, &its_file_meta, &its_file_offset, &its_file_size);
   1106            if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   1107              ret = PSA_ERROR_DOES_NOT_EXIST;
   1108              goto exit;
   1109            }
   1110            if (status != ECODE_NVM3_OK
   1111                && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   1112              ret = PSA_ERROR_STORAGE_FAILURE;
   1113              goto exit;
   1114            }
   1115          
   1116          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1117            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   1118                && !object_lives_in_s(p_data, data_length)) {
   1119              // The flag indicates that this data should not be read back to the non-secure domain
   1120              ret = PSA_ERROR_INVALID_ARGUMENT;
   1121              goto exit;
   1122            }
   1123          #endif
   1124          
   1125          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1126            // Subtract IV and MAC from ITS file as the below checks concern the actual data size
   1127            its_file_data_size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   1128          #else
   1129            its_file_data_size = its_file_size;
   1130          #endif
   1131          
   1132            if (data_length != 0U) {
   1133              if ((data_offset >= its_file_data_size) && (its_file_data_size != 0U)) {
   1134                ret = PSA_ERROR_INVALID_ARGUMENT;
   1135                goto exit;
   1136              }
   1137          
   1138              if ((its_file_data_size == 0U) && (data_offset != 0U)) {
   1139                ret = PSA_ERROR_INVALID_ARGUMENT;
   1140                goto exit;
   1141              }
   1142            } else {
   1143              // Allow the offset at the data size boundary if the requested amount of data is zero.
   1144              if (data_offset > its_file_data_size) {
   1145                ret = PSA_ERROR_INVALID_ARGUMENT;
   1146                goto exit;
   1147              }
   1148            }
   1149          
   1150            if (data_length > (its_file_data_size - data_offset)) {
   1151              *p_data_length = its_file_data_size - data_offset;
   1152            } else {
   1153              *p_data_length = data_length;
   1154            }
   1155          
   1156          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1157            // its_file_size includes size of sli_its_encrypted_blob_t struct
   1158            blob = (sli_its_encrypted_blob_t*)mbedtls_calloc(1, its_file_size);
   1159            if (blob == NULL) {
   1160              ret = PSA_ERROR_INSUFFICIENT_MEMORY;
   1161              goto exit;
   1162            }
   1163            memset(blob, 0, its_file_size);
   1164          
   1165            status = nvm3_readPartialData(nvm3_defaultHandle,
   1166                                          nvm3_object_id,
   1167                                          blob,
   1168                                          its_file_offset,
   1169                                          its_file_size);
   1170            if (status != ECODE_NVM3_OK) {
   1171              ret = PSA_ERROR_STORAGE_FAILURE;
   1172              goto exit;
   1173            }
   1174          
   1175            // Decrypt and authenticate blob
   1176            psa_status = decrypt_its_file(&its_file_meta,
   1177                                          blob,
   1178                                          its_file_size,
   1179                                          blob->data,
   1180                                          its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   1181                                          &plaintext_length);
   1182          
   1183            if (psa_status != PSA_SUCCESS) {
   1184              ret = psa_status;
   1185              goto exit;
   1186            }
   1187          
   1188            if (plaintext_length != (its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   1189              ret = PSA_ERROR_INVALID_SIGNATURE;
   1190              goto exit;
   1191            }
   1192          
   1193            // Verify that the requested UID is equal to the retrieved and authenticated UID
   1194            if (uid != its_file_meta.uid) {
   1195              ret = PSA_ERROR_INVALID_ARGUMENT;
   1196              goto exit;
   1197            }
   1198          
   1199            if (*p_data_length > 0) {
   1200              memcpy(p_data, blob->data + data_offset, *p_data_length);
   1201            }
   1202            ret = PSA_SUCCESS;
   1203          
   1204            exit:
   1205            if (blob != NULL) {
   1206              memset(blob, 0, its_file_size);
   1207              mbedtls_free(blob);
   1208            }
   1209            sli_its_release_mutex();
   1210          #else
   1211            // If no encryption is used, just read out the data and write it directly to the output buffer
   1212            status = nvm3_readPartialData(nvm3_defaultHandle, nvm3_object_id, p_data, its_file_offset + data_offset, *p_data_length);
   1213          
   1214            if (status != ECODE_NVM3_OK) {
   1215              ret = PSA_ERROR_STORAGE_FAILURE;
   1216            } else {
   1217              ret = PSA_SUCCESS;
   1218            }
   1219          
   1220            exit:
   1221            sli_its_release_mutex();
   1222          #endif
   1223          
   1224            return ret;
   1225          }
   1226          
   1227          /**
   1228           * \brief Retrieve the metadata about the provided uid
   1229           *
   1230           * \param[in] uid           The uid value
   1231           * \param[out] p_info       A pointer to the `psa_storage_info_t` struct that will be populated with the metadata
   1232           *
   1233           * \return      A status indicating the success/failure of the operation
   1234           *
   1235           * \retval      PSA_SUCCESS                  The operation completed successfully
   1236           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided uid value was not found in the storage
   1237           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   1238           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_info`)
   1239           *                                           is invalid, for example is `NULL` or references memory the caller cannot access
   1240           * \retval      PSA_ERROR_INVALID_SIGANTURE  The operation failed because authentication of the stored metadata failed.
   1241           */
   1242          psa_status_t psa_its_get_info(psa_storage_uid_t uid,
   1243                                        struct psa_storage_info_t *p_info)
   1244          {
   1245            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1246          
   1247            if (p_info == NULL) {
   1248              return PSA_ERROR_INVALID_ARGUMENT;
   1249            }
   1250            Ecode_t status;
   1251            sli_its_file_meta_v2_t its_file_meta = { 0 };
   1252            size_t its_file_size = 0;
   1253            size_t its_file_offset = 0;
   1254          
   1255            sli_its_acquire_mutex();
   1256            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
   1257            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1258              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1259              goto exit;
   1260            }
   1261          
   1262            status = get_file_metadata(nvm3_object_id, &its_file_meta, &its_file_offset, &its_file_size);
   1263            if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   1264              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1265              goto exit;
   1266            }
   1267            if (status != ECODE_NVM3_OK
   1268                && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   1269              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1270              goto exit;
   1271            }
   1272          
   1273          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1274            // Authenticate the ITS file (both metadata and ciphertext) before returning the metadata.
   1275            // Note that this can potentially induce a significant performance hit.
   1276            psa_storage_uid_t authenticated_uid;
   1277            psa_status = authenticate_its_file(nvm3_object_id, &authenticated_uid);
   1278            if (psa_status != PSA_SUCCESS) {
   1279              goto exit;
   1280            }
   1281          
   1282            if (authenticated_uid != uid) {
   1283              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1284              goto exit;
   1285            }
   1286          #endif
   1287          
   1288            p_info->flags = its_file_meta.flags;
   1289            p_info->size = its_file_size;
   1290          
   1291            psa_status = PSA_SUCCESS;
   1292          
   1293          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1294            // Remove IV and MAC size from file size
   1295            p_info->size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   1296          #endif
   1297            exit:
   1298            sli_its_release_mutex();
   1299            return psa_status;
   1300          }
   1301          
   1302          /**
   1303           * \brief Remove the provided key and its associated data from the storage
   1304           *
   1305           * \param[in] uid   The uid value
   1306           *
   1307           * \return  A status indicating the success/failure of the operation
   1308           *
   1309           * \retval      PSA_SUCCESS                  The operation completed successfully
   1310           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided key value was not found in the storage
   1311           * \retval      PSA_ERROR_NOT_PERMITTED      The operation failed because the provided key value was created with PSA_STORAGE_FLAG_WRITE_ONCE
   1312           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   1313           */
   1314          psa_status_t psa_its_remove(psa_storage_uid_t uid)
   1315          {
   1316            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1317            Ecode_t status;
   1318            sli_its_file_meta_v2_t its_file_meta = { 0 };
   1319            size_t its_file_size = 0;
   1320            size_t its_file_offset = 0;
   1321          
   1322            sli_its_acquire_mutex();
   1323            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(uid);
   1324            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1325              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1326              goto exit;
   1327            }
   1328          
   1329            status = get_file_metadata(nvm3_object_id, &its_file_meta, &its_file_offset, &its_file_size);
   1330            if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   1331              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1332              goto exit;
   1333            }
   1334            if (status != ECODE_NVM3_OK
   1335                && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   1336              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1337              goto exit;
   1338            }
   1339          
   1340            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE
   1341          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1342                || its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   1343          #endif
   1344                ) {
   1345              psa_status = PSA_ERROR_NOT_PERMITTED;
   1346              goto exit;
   1347            }
   1348          
   1349          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1350            // If the UID already exists, authenticate the existing value and make sure the stored UID is the same.
   1351            psa_storage_uid_t authenticated_uid;
   1352            psa_status = authenticate_its_file(nvm3_object_id, &authenticated_uid);
   1353            if (psa_status != PSA_SUCCESS) {
   1354              goto exit;
   1355            }
   1356          
   1357            if (authenticated_uid != uid) {
   1358              psa_status = PSA_ERROR_NOT_PERMITTED;
   1359              goto exit;
   1360            }
   1361          #endif
   1362          
   1363            status = nvm3_deleteObject(nvm3_defaultHandle, nvm3_object_id);
   1364          
   1365            if (status == ECODE_NVM3_OK) {
   1366              // Power-loss might occur, however upon boot, the look-up table will be
   1367              // re-filled as long as the data has been successfully written to NVM3.
   1368              if (previous_lookup.set && previous_lookup.uid == uid) {
   1369                previous_lookup.set = false;
   1370              }
   1371              cache_clear(nvm3_object_id);
   1372          
   1373              psa_status = PSA_SUCCESS;
   1374            } else {
   1375              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1376            }
   1377          
   1378            exit:
   1379            sli_its_release_mutex();
   1380            return psa_status;
   1381          }
   1382          
   1383          // -------------------------------------
   1384          // Silicon Labs extensions
   1385          static psa_storage_uid_t psa_its_identifier_of_slot(mbedtls_svc_key_id_t key)
   1386          {
   1387          #if defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
   1388            // Encode the owner in the upper 32 bits. This means that if
   1389            // owner values are nonzero (as they are on a PSA platform),
   1390            // no key file will ever have a value less than 0x100000000, so
   1391            // the whole range 0..0xffffffff is available for non-key files.
   1392            uint32_t unsigned_owner_id = MBEDTLS_SVC_KEY_ID_GET_OWNER_ID(key);
   1393            return ((uint64_t)unsigned_owner_id << 32) | MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
   1394          #else
   1395            // Use the key id directly as a file name.
   1396            // psa_is_key_id_valid() in psa_crypto_slot_management.c
   1397            // is responsible for ensuring that key identifiers do not have a
   1398            // value that is reserved for non-key files.
   1399            return key;
   1400          #endif
   1401          }
   1402          
   1403          psa_status_t sli_psa_its_change_key_id(mbedtls_svc_key_id_t old_id,
   1404                                                 mbedtls_svc_key_id_t new_id)
   1405          {
   1406            psa_storage_uid_t old_uid = psa_its_identifier_of_slot(old_id);
   1407            psa_storage_uid_t new_uid = psa_its_identifier_of_slot(new_id);
   1408            Ecode_t status;
   1409            uint32_t obj_type;
   1410            size_t its_file_size = 0;
   1411            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1412            int8_t *its_file_buffer = NULL;
   1413            sli_its_file_meta_v2_t* metadata = NULL;
   1414          
   1415          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1416            sli_its_encrypted_blob_t *blob = NULL;
   1417            size_t plaintext_length;
   1418            size_t blob_length;
   1419            psa_status_t encrypt_status;
   1420            psa_status_t decrypt_status;
   1421          #endif
   1422            sli_its_acquire_mutex();
   1423          
   1424            // Check whether the key to migrate exists on disk
   1425            nvm3_ObjectKey_t nvm3_object_id = prepare_its_get_nvm3_id(old_uid);
   1426            if (nvm3_object_id > SLI_PSA_ITS_NVM3_RANGE_END) {
   1427              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   1428              goto exit;
   1429            }
   1430          
   1431            // Get total length to allocate
   1432            status = nvm3_getObjectInfo(nvm3_defaultHandle,
   1433                                        nvm3_object_id,
   1434                                        &obj_type,
   1435                                        &its_file_size);
   1436            if (status != ECODE_NVM3_OK) {
   1437              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1438              goto exit;
   1439            }
   1440          
   1441            // Allocate temporary buffer and cast it to the metadata format
   1442            its_file_buffer = mbedtls_calloc(1, its_file_size);
   1443            if (its_file_buffer == NULL) {
   1444              psa_status = PSA_ERROR_INSUFFICIENT_MEMORY;
   1445              goto exit;
   1446            }
   1447            metadata = (sli_its_file_meta_v2_t*) its_file_buffer;
   1448          
   1449            // Read contents of pre-existing key into the temporary buffer
   1450            status = nvm3_readData(nvm3_defaultHandle,
   1451                                   nvm3_object_id,
   1452                                   its_file_buffer,
   1453                                   its_file_size);
   1454            if (status != ECODE_NVM3_OK) {
   1455              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1456              goto exit;
   1457            }
   1458          
   1459          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1460            // Decrypt and authenticate blob
   1461            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   1462            decrypt_status = decrypt_its_file(metadata,
   1463                                              blob,
   1464                                              its_file_size - sizeof(sli_its_file_meta_v2_t),
   1465                                              blob->data,
   1466                                              its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   1467                                              &plaintext_length);
   1468          
   1469            if (decrypt_status != PSA_SUCCESS) {
   1470              psa_status = decrypt_status;
   1471              goto exit;
   1472            }
   1473          
   1474            if (plaintext_length != (its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   1475              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1476              goto exit;
   1477            }
   1478          #endif
   1479          
   1480            // Swap out the old UID for the new one
   1481          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT)
   1482            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V1) {
   1483              // Recast as v1 metadata
   1484              sl_its_file_meta_v1_t* metadata_v1 = (sl_its_file_meta_v1_t*) its_file_buffer;
   1485              if (metadata_v1->uid != old_uid) {
   1486                psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1487                goto exit;
   1488              }
   1489              metadata_v1->uid = new_uid;
   1490            } else
   1491          #endif
   1492            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V2) {
   1493              if (metadata->uid != old_uid) {
   1494                psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1495                goto exit;
   1496              }
   1497              metadata->uid = new_uid;
   1498            } else {
   1499              psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1500              goto exit;
   1501            }
   1502          
   1503          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1504            // Encrypt and authenticate the modified data data
   1505            encrypt_status = encrypt_its_file(metadata,
   1506                                              blob->data,
   1507                                              plaintext_length,
   1508                                              blob,
   1509                                              its_file_size - sizeof(sli_its_file_meta_v2_t),
   1510                                              &blob_length);
   1511          
   1512            if (encrypt_status != PSA_SUCCESS) {
   1513              psa_status = encrypt_status;
   1514              goto exit;
   1515            }
   1516          
   1517            if (blob_length != (its_file_size - sizeof(sli_its_file_meta_v2_t))) {
   1518              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1519              goto exit;
   1520            }
   1521          #endif
   1522          
   1523            // Overwrite the NVM3 token with the changed buffer
   1524            status = nvm3_writeData(nvm3_defaultHandle,
   1525                                    nvm3_object_id,
   1526                                    its_file_buffer,
   1527                                    its_file_size);
   1528            if (status == ECODE_NVM3_OK) {
   1529              // Update last lookup and report success
   1530              if (previous_lookup.set) {
   1531                if (previous_lookup.uid == old_uid) {
   1532                  previous_lookup.uid = new_uid;
   1533                }
   1534              }
   1535              psa_status = PSA_SUCCESS;
   1536            } else {
   1537              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1538            }
   1539          
   1540            exit:
   1541            if (its_file_buffer != NULL) {
   1542              // Clear and free key buffer before return.
   1543              memset(its_file_buffer, 0, its_file_size);
   1544              mbedtls_free(its_file_buffer);
   1545            }
   1546            sli_its_release_mutex();
   1547            return psa_status;
   1548          }
   1549          
   1550          /**
   1551           * \brief Check if the ITS encryption is enabled
   1552           */
   1553          psa_status_t sli_psa_its_encrypted(void)
   1554          {
   1555            #if defined(SLI_PSA_ITS_ENCRYPTED)
   1556            return PSA_SUCCESS;
   1557            #else
   1558            return PSA_ERROR_NOT_SUPPORTED;
   1559            #endif
   1560          }
   1561          
   1562          #if defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   1563          /**
   1564           * \brief Set the root key to be used when deriving session keys for ITS encryption.
   1565           *
   1566           * \param[in] root_key        Buffer containing the root key.
   1567           * \param[in] root_key_size   Size of the root key in bytes. Must be 32 (256 bits).
   1568           *
   1569           * \return  A status indicating the success/failure of the operation
   1570           *
   1571           * \retval      PSA_SUCCESS                  The key was successfully set.
   1572           * \retval      PSA_ERROR_INVALID_ARGUMENT   The root key was NULL or had an invalid size.
   1573           * \retval      PSA_ERROR_ALREADY_EXISTS     The root key has already been initialized.
   1574           */
   1575          psa_status_t sli_psa_its_set_root_key(uint8_t *root_key, size_t root_key_size)
   1576          {
   1577            // Check that arguments are valid
   1578            if (root_key == NULL || root_key_size != sizeof(g_root_key.data)) {
   1579              return PSA_ERROR_INVALID_ARGUMENT;
   1580            }
   1581          
   1582            // Check that the root key has not already been set
   1583            // (This is possibly too restrictive. For TrustZone usage this can be enforced by
   1584            // not exposing the function to NS instead.)
   1585            if (g_root_key.initialized) {
   1586              return PSA_ERROR_ALREADY_EXISTS;
   1587            }
   1588          
   1589            // Store the provided root key and mark it as initialized
   1590            memcpy(g_root_key.data, root_key, sizeof(g_root_key.data));
   1591            g_root_key.initialized = true;
   1592          
   1593            return PSA_SUCCESS;
   1594          }
   1595          #endif // defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   1596          
   1597          #else // (!SL_PSA_ITS_SUPPORT_V3_DRIVER)
   1598          
   1599          // -------------------------------------
   1600          // Defines
   1601          #define SLI_PSA_ITS_V3_DRIVER               (0x3A)
   1602          #define SLI_PSA_ITS_V2_DRIVER               (0x74)
   1603          #define SLI_PSA_ITS_NOT_CHECKED             (0xE8)
   1604          #define SLI_PSA_ITS_V2_DRIVER_FLAG_NVM3_ID  (SLI_PSA_ITS_NVM3_RANGE_START - 1)
   1605          #define SLI_PSA_ITS_NVM3_INVALID_KEY        (0)
   1606          #define SLI_PSA_ITS_NVM3_UNKNOWN_KEY        (1)
   1607          
   1608          #if SL_PSA_ITS_MAX_FILES > SLI_PSA_ITS_NVM3_RANGE_SIZE
   1609          #error "Trying to store more ITS files then our NVM3 range allows for"
   1610          #endif
   1611          
   1612          #define SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE 16
   1613          
   1614          // Internal error codes local to this compile unit
   1615          #define SLI_PSA_ITS_ECODE_NO_VALID_HEADER (ECODE_EMDRV_NVM3_BASE - 1)
   1616          #define SLI_PSA_ITS_ECODE_NEEDS_UPGRADE   (ECODE_EMDRV_NVM3_BASE - 2)
   1617          
   1618          // SLI_STATIC_TESTABLE is used to expose otherwise-static variables during internal testing.
   1619          #if !defined(SLI_STATIC_TESTABLE)
   1620          #define SLI_STATIC_TESTABLE static
   1621          #endif
   1622          
   1623          // -------------------------------------
   1624          // Local global static variables
   1625          

   \                                 In section .bss, align 4
   1626          SLI_STATIC_TESTABLE bool nvm3_uid_set_cache_initialized = false;
   \                     nvm3_uid_set_cache_initialized:
   \        0x0                      DS8 1
   \        0x1                      DS8 3
   \        0x4                      DS8 20
   \       0x18                      DS8 20
   1627          SLI_STATIC_TESTABLE uint32_t nvm3_uid_set_cache[(SL_PSA_ITS_MAX_FILES + 31) / 32] = { 0 };
   1628          SLI_STATIC_TESTABLE uint32_t nvm3_uid_tomb_cache[(SL_PSA_ITS_MAX_FILES + 31) / 32] = { 0 };
   1629          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1630          SLI_STATIC_TESTABLE uint32_t its_driver_version = SLI_PSA_ITS_NOT_CHECKED;
   1631          #endif // SL_PSA_ITS_SUPPORT_V2_DRIVER
   1632          
   1633          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1634          // The root key is an AES-256 key, and is therefore 32 bytes.
   1635          #define ROOT_KEY_SIZE     (32)
   1636          // The session key is derived from CMAC, which means it is equal to the AES block size, i.e. 16 bytes
   1637          #define SESSION_KEY_SIZE  (16)
   1638          
   1639          #if !defined(SEMAILBOX_PRESENT)
   1640          typedef struct {
   1641            bool initialized;
   1642            uint8_t data[ROOT_KEY_SIZE];
   1643          } root_key_t;
   1644          
   1645          static root_key_t g_root_key = {
   1646            .initialized = false,
   1647            .data = { 0 },
   1648          };
   1649          #endif // !defined(SEMAILBOX_PRESENT)
   1650          
   1651          typedef struct {
   1652            bool active;
   1653            psa_storage_uid_t uid;
   1654            uint8_t data[SESSION_KEY_SIZE];
   1655          } session_key_t;
   1656          
   1657          static session_key_t g_cached_session_key = {
   1658            .active = false,
   1659            .uid = 0,
   1660            .data = { 0 },
   1661          };
   1662          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
   1663          
   1664          // -------------------------------------
   1665          // Structs
   1666          
   1667          #if defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1668          typedef struct {
   1669            uint32_t magic;
   1670            psa_storage_uid_t uid;
   1671            psa_storage_create_flags_t flags;
   1672          } sl_its_file_meta_v1_t;
   1673          #endif // defined(SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1674          
   1675          // -------------------------------------
   1676          // Local function prototypes
   1677          
   1678          static psa_status_t find_nvm3_id(psa_storage_uid_t uid,
   1679                                           bool find_empty_slot,
   1680                                           sli_its_file_meta_v2_t* its_file_meta,
   1681                                           size_t* its_file_offset,
   1682                                           size_t* its_file_size,
   1683                                           nvm3_ObjectKey_t * output_nvm3_id);
   1684          static nvm3_ObjectKey_t derive_nvm3_id(psa_storage_uid_t uid);
   1685          
   1686          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1687          static inline bool object_lives_in_s(const void *object, size_t object_size);
   1688          #endif
   1689          
   1690          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1691          static psa_status_t derive_session_key(uint8_t *iv,
   1692                                                 size_t iv_size,
   1693                                                 uint8_t *session_key,
   1694                                                 size_t session_key_size);
   1695          
   1696          static psa_status_t sli_decrypt_its_file(sli_its_file_meta_v2_t *metadata,
   1697                                                   sli_its_encrypted_blob_t *blob,
   1698                                                   size_t blob_size,
   1699                                                   uint8_t *plaintext,
   1700                                                   size_t plaintext_size,
   1701                                                   size_t *plaintext_length);
   1702          
   1703          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
   1704                                                    psa_storage_uid_t *authenticated_uid);
   1705          #endif
   1706          
   1707          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1708          static psa_status_t psa_its_get_legacy(nvm3_ObjectKey_t nvm3_object_id,
   1709                                                 sli_its_file_meta_v2_t* its_file_meta,
   1710                                                 size_t its_file_size,
   1711                                                 size_t its_file_offset, void *p_data);
   1712          static psa_status_t detect_legacy_versions();
   1713          static psa_status_t upgrade_all_keys();
   1714          
   1715          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1716          psa_status_t psa_its_set_v1(psa_storage_uid_t uid,
   1717                                      uint32_t data_length,
   1718                                      const void *p_data,
   1719                                      psa_storage_create_flags_t create_flags);
   1720          #endif // SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL
   1721          #endif // SL_PSA_ITS_SUPPORT_V2_DRIVER
   1722          
   1723          // -------------------------------------
   1724          // Local function definitions

   \                                 In section .text, align 2, keep-with-next
   1725          static inline uint32_t get_index(nvm3_ObjectKey_t key)
   1726          {
   1727            return (key - (SLI_PSA_ITS_NVM3_RANGE_START)) / 32;
   \                     get_index: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \        0x4   0x1808             ADDS     R0,R1,R0
   \        0x6   0x0940             LSRS     R0,R0,#+5
   \        0x8   0x4770             BX       LR
   1728          }
   1729          

   \                                 In section .text, align 2, keep-with-next
   1730          static inline uint32_t get_offset(nvm3_ObjectKey_t key)
   1731          {
   1732            return (key - (SLI_PSA_ITS_NVM3_RANGE_START)) % 32;
   \                     get_offset: (+1)
   \        0x0   0xF000 0x001F      AND      R0,R0,#0x1F
   \        0x4   0x4770             BX       LR
   1733          }
   1734          

   \                                 In section .text, align 2, keep-with-next
   1735          static inline void set_cache(nvm3_ObjectKey_t key)
   1736          {
   \                     set_cache: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   1737            nvm3_uid_set_cache[get_index(key)] |= (1 << get_offset(key));
   \        0x6   0x.... 0x....      BL       get_index
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable9_6
   \        0xE   0xEB05 0x0480      ADD      R4,R5,R0, LSL #+2
   \       0x12   0x6867             LDR      R7,[R4, #+4]
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0x2601             MOVS     R6,#+1
   \       0x18   0x.... 0x....      BL       get_offset
   \       0x1C   0xFA06 0xF000      LSL      R0,R6,R0
   \       0x20   0x4307             ORRS     R7,R0,R7
   \       0x22   0x6067             STR      R7,[R4, #+4]
   1738            nvm3_uid_tomb_cache[get_index(key)] &= ~(1 << get_offset(key));
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x.... 0x....      BL       get_index
   \       0x2A   0xEB05 0x0780      ADD      R7,R5,R0, LSL #+2
   \       0x2E   0x69BD             LDR      R5,[R7, #+24]
   \       0x30   0x4640             MOV      R0,R8
   \       0x32   0x.... 0x....      BL       get_offset
   \       0x36   0x4086             LSLS     R6,R6,R0
   \       0x38   0xEA25 0x0606      BIC      R6,R5,R6
   \       0x3C   0x61BE             STR      R6,[R7, #+24]
   1739          }
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1740          

   \                                 In section .text, align 2, keep-with-next
   1741          static inline void set_tomb(nvm3_ObjectKey_t key)
   1742          {
   1743            nvm3_uid_tomb_cache[get_index(key)] |= (1 << get_offset(key));
   \                     set_tomb: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \        0x4   0x1809             ADDS     R1,R1,R0
   \        0x6   0xB510             PUSH     {R4,LR}
   \        0x8   0x0949             LSRS     R1,R1,#+5
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable9_6
   \        0xE   0xEB02 0x0481      ADD      R4,R2,R1, LSL #+2
   \       0x12   0x69A1             LDR      R1,[R4, #+24]
   \       0x14   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x18   0x4308             ORRS     R0,R0,R1
   \       0x1A   0x61A0             STR      R0,[R4, #+24]
   1744          
   1745            uint32_t cache_not_empty = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   1746            for ( size_t i = 0; i < (((SL_PSA_ITS_MAX_FILES) +31) / 32); i++ ) {
   \       0x1E   0x2100             MOVS     R1,#+0
   1747              cache_not_empty += nvm3_uid_set_cache[i];
   \                     ??set_tomb_0: (+1)
   \       0x20   0xEB02 0x0481      ADD      R4,R2,R1, LSL #+2
   \       0x24   0x6863             LDR      R3,[R4, #+4]
   1748            }
   \       0x26   0x1C49             ADDS     R1,R1,#+1
   \       0x28   0x1818             ADDS     R0,R3,R0
   \       0x2A   0x2905             CMP      R1,#+5
   \       0x2C   0xD3F8             BCC.N    ??set_tomb_0
   1749            if (cache_not_empty == 0) {
   \       0x2E   0xB930             CBNZ.N   R0,??set_tomb_1
   1750              for ( size_t i = 0; i < (((SL_PSA_ITS_MAX_FILES) +31) / 32); i++ ) {
   1751                nvm3_uid_tomb_cache[i] = 0;
   \       0x30   0x2114             MOVS     R1,#+20
   \       0x32   0xF102 0x0018      ADD      R0,R2,#+24
   \       0x36   0xE8BD 0x4010      POP      {R4,LR}
   \       0x3A   0x.... 0x....      B.W      __aeabi_memclr
   1752              }
   1753            }
   1754          }
   \                     ??set_tomb_1: (+1)
   \       0x3E   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0xF000 0x001F      AND      R0,R0,#0x1F
   \        0x6   0xFA03 0xF000      LSL      R0,R3,R0
   \        0xA   0x4770             BX       LR
   1755          
   1756          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1757          static inline psa_status_t write_driver_v3()
   1758          {
   1759            uint8_t driver_verison = SLI_PSA_ITS_V3_DRIVER;
   1760            Ecode_t status;
   1761            status = nvm3_writeData(nvm3_defaultHandle,
   1762                                    SLI_PSA_ITS_V2_DRIVER_FLAG_NVM3_ID,
   1763                                    &driver_verison, sizeof(uint8_t));
   1764            if ( status != ECODE_NVM3_OK ) {
   1765              return PSA_ERROR_STORAGE_FAILURE;
   1766            }
   1767            return PSA_SUCCESS;
   1768          }
   1769          #endif
   1770          
   1771          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   1772          // If an object of given size is fully encapsulated in a region of
   1773          // secure domain the function returns true.
   1774          static inline bool object_lives_in_s(const void *object, size_t object_size)
   1775          {
   1776            cmse_address_info_t cmse_flags;
   1777          
   1778            for (size_t i = 0u; i < object_size; i++) {
   1779              cmse_flags = cmse_TTA((uint32_t *)object + i);
   1780              if (!cmse_flags.flags.secure) {
   1781                return false;
   1782              }
   1783            }
   1784          
   1785            return true;
   1786          }
   1787          #endif
   1788          
   1789          static inline void clear_cache(nvm3_ObjectKey_t key)
   1790          {
   1791            nvm3_uid_set_cache[get_index(key)] ^= (1 << get_offset(key));
   1792          }
   1793          
   1794          static inline bool lookup_cache(nvm3_ObjectKey_t key)
   1795          {
   1796            return (bool)((nvm3_uid_set_cache[get_index(key)] >> get_offset(key)) & 0x1);
   1797          }
   1798          
   1799          static inline bool lookup_tomb(nvm3_ObjectKey_t key)
   1800          {
   1801            return (bool)((nvm3_uid_tomb_cache[get_index(key)] >> get_offset(key)) & 0x1);
   1802          }
   1803          

   \                                 In section .text, align 2, keep-with-next
   1804          static inline nvm3_ObjectKey_t increment_obj_id(nvm3_ObjectKey_t id)
   1805          {
   1806            return SLI_PSA_ITS_NVM3_RANGE_START + ((id - SLI_PSA_ITS_NVM3_RANGE_START + 1)
   1807                                                   % SL_PSA_ITS_MAX_FILES);
   \                     increment_obj_id: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable9_7
   \        0x4   0x1810             ADDS     R0,R2,R0
   \        0x6   0x238A             MOVS     R3,#+138
   \        0x8   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \        0xC   0x218A             MOVS     R1,#+138
   \        0xE   0xFB01 0x0013      MLS      R0,R1,R3,R0
   \       0x12   0xF500 0x2000      ADD      R0,R0,#+524288
   \       0x16   0xF500 0x40DA      ADD      R0,R0,#+27904
   \       0x1A   0x4770             BX       LR
   1808          }
   1809          static inline nvm3_ObjectKey_t prng(psa_storage_uid_t uid)
   1810          {
   1811          // Squash uid down to a 32 bit word
   1812            nvm3_ObjectKey_t uid_32 = uid & 0xFFFFFFFF;
   1813            nvm3_ObjectKey_t xored_32 = (uid >> 32) ^ uid_32;
   1814            nvm3_ObjectKey_t temp;
   1815          // Accumulate all "entropy" towards the LSB, since that is where we need it
   1816            for ( size_t i = 1; i < 4; i++ ) {
   1817              temp = xored_32 ^ (xored_32 >> (8 * i));
   1818              if ((temp & 0x3) != 0 ) {
   1819                temp = temp << 2;
   1820              }
   1821              uid_32 = (uid_32 + temp);
   1822            }
   1823            return uid_32;
   1824          }
   1825          
   1826          static inline nvm3_ObjectKey_t derive_nvm3_id(psa_storage_uid_t uid)
   1827          {
   1828            return SLI_PSA_ITS_NVM3_RANGE_START + (prng(uid) % (SL_PSA_ITS_MAX_FILES));
   1829          }
   1830          
   1831          static void init_cache(void)
   1832          {
   1833            size_t num_keys_referenced_by_nvm3;
   1834            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = { 0 };
   1835            size_t num_del_keys_from_nvm3;
   1836            nvm3_ObjectKey_t deleted_keys_from_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = { 0 };
   1837            for (nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START;
   1838                 range_start < SLI_PSA_ITS_NVM3_RANGE_END;
   1839                 range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE) {
   1840              nvm3_ObjectKey_t range_end = range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
   1841              if (range_end > SLI_PSA_ITS_NVM3_RANGE_END) {
   1842                range_end = SLI_PSA_ITS_NVM3_RANGE_END;
   1843              }
   1844          
   1845              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
   1846                                                             keys_referenced_by_nvm3,
   1847                                                             sizeof(keys_referenced_by_nvm3) / sizeof(nvm3_ObjectKey_t),
   1848                                                             range_start,
   1849                                                             range_end - 1);
   1850          
   1851              for (size_t i = 0; i < num_keys_referenced_by_nvm3; i++) {
   1852                set_cache(keys_referenced_by_nvm3[i]);
   1853              }
   1854              num_del_keys_from_nvm3 = nvm3_enumDeletedObjects(nvm3_defaultHandle,
   1855                                                               deleted_keys_from_nvm3,
   1856                                                               sizeof(deleted_keys_from_nvm3) / sizeof(nvm3_ObjectKey_t),
   1857                                                               range_start,
   1858                                                               range_end - 1);
   1859              for (size_t i = 0; i < num_del_keys_from_nvm3; i++) {
   1860                set_tomb(deleted_keys_from_nvm3[i]);
   1861              }
   1862            }
   1863            nvm3_uid_set_cache_initialized = true;
   1864          }
   1865          
   1866          // Read the file metadata for a specific NVM3 ID
   1867          static Ecode_t get_file_metadata(nvm3_ObjectKey_t key,
   1868                                           sli_its_file_meta_v2_t* metadata,
   1869                                           size_t* its_file_offset,
   1870                                           size_t* its_file_size)
   1871          {
   1872            // Initialize output variables to safe default
   1873            if (its_file_offset != NULL) {
   1874              *its_file_offset = 0;
   1875            }
   1876            if (its_file_size != NULL) {
   1877              *its_file_size = 0;
   1878            }
   1879          
   1880            Ecode_t status = nvm3_readPartialData(nvm3_defaultHandle,
   1881                                                  key,
   1882                                                  metadata,
   1883                                                  0,
   1884                                                  sizeof(sli_its_file_meta_v2_t));
   1885            if (status != ECODE_NVM3_OK) {
   1886              return status;
   1887            }
   1888          
   1889          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   1890            // Re-read in v1 header format and translate to the latest structure version
   1891            if (metadata->magic == SLI_PSA_ITS_META_MAGIC_V1) {
   1892              sl_its_file_meta_v1_t key_meta_v1 = { 0 };
   1893              status = nvm3_readPartialData(nvm3_defaultHandle,
   1894                                            key,
   1895                                            &key_meta_v1,
   1896                                            0,
   1897                                            sizeof(sl_its_file_meta_v1_t));
   1898          
   1899              if (status != ECODE_NVM3_OK) {
   1900                return status;
   1901              }
   1902          
   1903              metadata->flags = key_meta_v1.flags;
   1904              metadata->uid = key_meta_v1.uid;
   1905              metadata->magic = SLI_PSA_ITS_META_MAGIC_V2;
   1906          
   1907              if (its_file_offset != NULL) {
   1908                *its_file_offset = sizeof(sl_its_file_meta_v1_t);
   1909              }
   1910          
   1911              status = SLI_PSA_ITS_ECODE_NEEDS_UPGRADE;
   1912            } else
   1913          #endif
   1914            {
   1915              if (its_file_offset != NULL) {
   1916                *its_file_offset = sizeof(sli_its_file_meta_v2_t);
   1917              }
   1918            }
   1919          
   1920            if (metadata->magic != SLI_PSA_ITS_META_MAGIC_V2) {
   1921              // No valid header found in this object
   1922              return SLI_PSA_ITS_ECODE_NO_VALID_HEADER;
   1923            }
   1924          
   1925            if (its_file_offset != NULL && its_file_size != NULL) {
   1926              // Calculate the ITS file size if requested
   1927              uint32_t obj_type;
   1928              Ecode_t info_status = nvm3_getObjectInfo(nvm3_defaultHandle,
   1929                                                       key,
   1930                                                       &obj_type,
   1931                                                       its_file_size);
   1932              if (info_status != ECODE_NVM3_OK) {
   1933                return info_status;
   1934              }
   1935          
   1936              *its_file_size = *its_file_size - *its_file_offset;
   1937            }
   1938          
   1939            return status;
   1940          }
   1941          
   1942          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   1943          static psa_status_t psa_its_get_legacy(nvm3_ObjectKey_t nvm3_object_id,
   1944                                                 sli_its_file_meta_v2_t* its_file_meta,
   1945                                                 size_t its_file_size,
   1946                                                 size_t its_file_offset,
   1947                                                 void *p_data)
   1948          {
   1949            Ecode_t status;
   1950            if (its_file_size == 0) {
   1951              if (its_file_meta != NULL) {
   1952                return PSA_ERROR_DATA_INVALID;
   1953              }
   1954            }
   1955          
   1956          #if defined(SLI_PSA_ITS_ENCRYPTED)
   1957            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   1958            sli_its_encrypted_blob_t *blob = NULL;
   1959            size_t plaintext_length;
   1960          
   1961            // its_file_size includes size of sli_its_encrypted_blob_t struct
   1962            blob = (sli_its_encrypted_blob_t*)mbedtls_calloc(1, its_file_size);
   1963            if (blob == NULL) {
   1964              return PSA_ERROR_INSUFFICIENT_MEMORY;
   1965            }
   1966            memset(blob, 0, its_file_size);
   1967          
   1968            status = nvm3_readPartialData(nvm3_defaultHandle,
   1969                                          nvm3_object_id,
   1970                                          blob,
   1971                                          its_file_offset,
   1972                                          its_file_size);
   1973            if (status != ECODE_NVM3_OK) {
   1974              psa_status = PSA_ERROR_STORAGE_FAILURE;
   1975              goto cleanup;
   1976            }
   1977          
   1978            // Decrypt and authenticate blob
   1979            psa_status = sli_decrypt_its_file(its_file_meta,
   1980                                              blob,
   1981                                              its_file_size,
   1982                                              blob->data,
   1983                                              its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   1984                                              &plaintext_length);
   1985          
   1986            if (psa_status != PSA_SUCCESS) {
   1987              goto cleanup;
   1988            }
   1989          
   1990            if (plaintext_length != (its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   1991              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1992              goto cleanup;
   1993            }
   1994          
   1995            if (its_file_size + its_file_offset > 0) {
   1996              memcpy(p_data, blob->data, its_file_size + its_file_offset);
   1997            }
   1998            psa_status = PSA_SUCCESS;
   1999          
   2000            cleanup:
   2001            if (blob != NULL) {
   2002              memset(blob, 0, its_file_size);
   2003              mbedtls_free(blob);
   2004            }
   2005            return psa_status;
   2006          #else
   2007            // If no encryption is used, just read out the data and write it directly to the output buffer
   2008            status = nvm3_readPartialData(nvm3_defaultHandle, nvm3_object_id, p_data,
   2009                                          its_file_offset, its_file_size);
   2010          
   2011            if (status != ECODE_NVM3_OK) {
   2012              return PSA_ERROR_STORAGE_FAILURE;
   2013            } else {
   2014              return PSA_SUCCESS;
   2015            }
   2016          #endif
   2017          }
   2018          
   2019          // Function sets detect the presence of v1 and v2 its driver. If there is something
   2020          // stored in v1/v2 driver range, it sets its_driver_version to SLI_PSA_ITS_V2_DRIVER.
   2021          static psa_status_t detect_legacy_versions()
   2022          {
   2023            uint8_t driver_verison = 0;
   2024            Ecode_t status;
   2025            status = nvm3_readData(nvm3_defaultHandle, SLI_PSA_ITS_V2_DRIVER_FLAG_NVM3_ID,
   2026                                   &driver_verison, sizeof(uint8_t));
   2027            if ((status != ECODE_NVM3_OK) && (status != ECODE_NVM3_ERR_KEY_NOT_FOUND)) {
   2028              return PSA_ERROR_STORAGE_FAILURE;
   2029            }
   2030            if (driver_verison == SLI_PSA_ITS_V3_DRIVER) {
   2031              its_driver_version = SLI_PSA_ITS_V3_DRIVER;
   2032              return PSA_SUCCESS;
   2033            }
   2034          
   2035            size_t num_keys_referenced_by_nvm3;
   2036          
   2037            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = {
   2038              0
   2039            };
   2040          
   2041            for ( nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START_V2_DRIVER;
   2042                  range_start < SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2043                  range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE ) {
   2044              nvm3_ObjectKey_t range_end =
   2045                range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
   2046              if (range_end > SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER ) {
   2047                range_end = SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2048              }
   2049          
   2050              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
   2051                                                             keys_referenced_by_nvm3,
   2052                                                             sizeof(keys_referenced_by_nvm3)
   2053                                                             / sizeof(nvm3_ObjectKey_t),
   2054                                                             range_start,
   2055                                                             range_end - 1);
   2056          
   2057              if (num_keys_referenced_by_nvm3 > 0) {
   2058                sli_its_file_meta_v2_t its_file_meta = { 0 };
   2059                size_t its_file_size = 0;
   2060                size_t its_file_offset = 0;
   2061                status = get_file_metadata(keys_referenced_by_nvm3[0],
   2062                                           &its_file_meta, &its_file_offset,
   2063                                           &its_file_size);
   2064                if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   2065                  return PSA_ERROR_DOES_NOT_EXIST;
   2066                }
   2067                if (status != ECODE_NVM3_OK
   2068                    && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   2069                  return PSA_ERROR_STORAGE_FAILURE;
   2070                }
   2071          
   2072                if ((its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V1)
   2073                    || (its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V2)) {
   2074                  its_driver_version = SLI_PSA_ITS_V2_DRIVER;
   2075                  return PSA_SUCCESS;
   2076                } else {
   2077                  return PSA_ERROR_STORAGE_FAILURE;
   2078                }
   2079              }
   2080            }
   2081            its_driver_version = SLI_PSA_ITS_V3_DRIVER;
   2082            return PSA_SUCCESS;
   2083          }
   2084          
   2085          static psa_status_t upgrade_all_keys()
   2086          {
   2087            size_t num_keys_referenced_by_nvm3;
   2088            nvm3_ObjectKey_t keys_referenced_by_nvm3[SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE] = {
   2089              0
   2090            };
   2091            Ecode_t status;
   2092            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2093          
   2094            sli_its_file_meta_v2_t its_file_meta = { 0 };
   2095            size_t its_file_data_size;
   2096            uint8_t * its_file_buffer = NULL;
   2097          
   2098            size_t its_file_size = 0;
   2099            size_t its_file_offset;
   2100          
   2101            for ( nvm3_ObjectKey_t range_start = SLI_PSA_ITS_NVM3_RANGE_START_V2_DRIVER;
   2102                  range_start < SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2103                  range_start += SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE ) {
   2104              nvm3_ObjectKey_t range_end =
   2105                range_start + SLI_PSA_ITS_CACHE_INIT_CHUNK_SIZE;
   2106              if (range_end >= SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER ) {
   2107                range_end = SLI_PSA_ITS_NVM3_RANGE_END_V2_DRIVER;
   2108              }
   2109          
   2110              num_keys_referenced_by_nvm3 = nvm3_enumObjects(nvm3_defaultHandle,
   2111                                                             keys_referenced_by_nvm3,
   2112                                                             sizeof(keys_referenced_by_nvm3)
   2113                                                             /
   2114                                                             sizeof(nvm3_ObjectKey_t),
   2115                                                             range_start,
   2116                                                             range_end - 1);
   2117              for ( size_t i = 0; i < num_keys_referenced_by_nvm3; i++ ) {
   2118                its_file_size = 0;
   2119                its_file_offset = 0;
   2120                status = get_file_metadata(keys_referenced_by_nvm3[i],
   2121                                           &(its_file_meta), &its_file_offset,
   2122                                           &its_file_size);
   2123                if ( status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER) {
   2124                  return PSA_ERROR_DOES_NOT_EXIST;
   2125                }
   2126                if ( status != ECODE_NVM3_OK
   2127                     && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   2128                  return PSA_ERROR_STORAGE_FAILURE;
   2129                }
   2130          
   2131          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2132                // Subtract IV and MAC from ITS file as the below checks concern the actual data size
   2133                its_file_data_size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   2134          #else
   2135                its_file_data_size = its_file_size;
   2136          #endif
   2137          
   2138                if ((its_file_meta.magic != SLI_PSA_ITS_META_MAGIC_V2)
   2139                    && (its_file_meta.magic != SLI_PSA_ITS_META_MAGIC_V1)) {
   2140                  return PSA_ERROR_STORAGE_FAILURE;
   2141                }
   2142                its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2143                if (its_file_buffer == NULL) {
   2144                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   2145                }
   2146          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2147                psa_status = psa_its_get_legacy(keys_referenced_by_nvm3[i],
   2148                                                &(its_file_meta),
   2149                                                its_file_size,
   2150                                                its_file_offset,
   2151                                                its_file_buffer);
   2152          #else
   2153                psa_status = psa_its_get_legacy(keys_referenced_by_nvm3[i],
   2154                                                NULL,
   2155                                                its_file_size,
   2156                                                its_file_offset,
   2157                                                its_file_buffer);
   2158          #endif
   2159                if (psa_status != PSA_SUCCESS) {
   2160                  psa_status = PSA_ERROR_STORAGE_FAILURE;
   2161                  goto exit;
   2162                }
   2163          
   2164          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   2165                if (its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V1) {
   2166                  psa_status = psa_its_set_v1(its_file_meta.uid, its_file_data_size,
   2167                                              its_file_buffer, its_file_meta.flags);
   2168                } else if (its_file_meta.magic == SLI_PSA_ITS_META_MAGIC_V2)
   2169          #endif
   2170                {
   2171                  psa_status = psa_its_set(its_file_meta.uid, its_file_data_size,
   2172                                           its_file_buffer, its_file_meta.flags);
   2173                }
   2174          
   2175                if ((psa_status != PSA_SUCCESS) && (psa_status
   2176                                                    != PSA_ERROR_NOT_PERMITTED)) {
   2177                  goto exit;
   2178                }
   2179                status = nvm3_deleteObject(nvm3_defaultHandle,
   2180                                           keys_referenced_by_nvm3[i]);
   2181          
   2182                if ( status != ECODE_NVM3_OK ) {
   2183                  psa_status = PSA_ERROR_STORAGE_FAILURE;
   2184                  goto exit;
   2185                }
   2186                memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2187                mbedtls_free(its_file_buffer);
   2188              }
   2189            }
   2190            return PSA_SUCCESS;
   2191          
   2192            exit:
   2193            // Clear and free key buffer before return.
   2194            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2195            mbedtls_free(its_file_buffer);
   2196            return psa_status;
   2197          }
   2198          
   2199          #if defined (SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL)
   2200          psa_status_t psa_its_set_v1(psa_storage_uid_t uid,
   2201                                      uint32_t data_length,
   2202                                      const void *p_data,
   2203                                      psa_storage_create_flags_t create_flags)
   2204          {
   2205            if ((data_length != 0U) && (p_data == NULL)) {
   2206              return PSA_ERROR_INVALID_ARGUMENT;
   2207            }
   2208          
   2209            if (create_flags != PSA_STORAGE_FLAG_WRITE_ONCE
   2210                && create_flags != PSA_STORAGE_FLAG_NONE
   2211          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2212                && create_flags != PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2213          #endif
   2214                ) {
   2215              return PSA_ERROR_NOT_SUPPORTED;
   2216            }
   2217          
   2218          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2219            if ((create_flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
   2220                && (!object_lives_in_s(p_data, data_length))) {
   2221              // The flag indicates that this data should not be set by the non-secure domain
   2222              return PSA_ERROR_INVALID_ARGUMENT;
   2223            }
   2224          #endif
   2225          
   2226            Ecode_t status;
   2227            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2228            sl_its_file_meta_v1_t* its_file_meta;
   2229            nvm3_ObjectKey_t nvm3_object_id = 0;
   2230            size_t its_file_size = data_length;
   2231          
   2232            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sl_its_file_meta_v1_t));
   2233            if (its_file_buffer == NULL) {
   2234              return PSA_ERROR_INSUFFICIENT_MEMORY;
   2235            }
   2236            memset(its_file_buffer, 0, its_file_size + sizeof(sl_its_file_meta_v1_t));
   2237          
   2238            its_file_meta = (sl_its_file_meta_v1_t *)its_file_buffer;
   2239            sli_its_file_meta_v2_t its_file_meta_v2;
   2240          
   2241            sli_its_acquire_mutex();
   2242            psa_status = find_nvm3_id(uid, true, &its_file_meta_v2, NULL, NULL,
   2243                                      &nvm3_object_id);
   2244            if (psa_status != PSA_SUCCESS) {
   2245              if (psa_status == PSA_ERROR_DOES_NOT_EXIST) {
   2246                psa_status = PSA_ERROR_INSUFFICIENT_STORAGE;
   2247              }
   2248              goto exit;
   2249            }
   2250          
   2251            its_file_meta->magic = SLI_PSA_ITS_META_MAGIC_V1;
   2252            its_file_meta->uid = uid;
   2253            its_file_meta->flags = create_flags;
   2254          
   2255            if (data_length != 0U) {
   2256              memcpy(its_file_buffer + sizeof(sl_its_file_meta_v1_t), ((uint8_t*)
   2257                                                                       p_data), data_length);
   2258            }
   2259          
   2260            status = nvm3_writeData(nvm3_defaultHandle,
   2261                                    nvm3_object_id,
   2262                                    its_file_buffer, its_file_size + sizeof
   2263                                    (sl_its_file_meta_v1_t));
   2264          
   2265            if (status == ECODE_NVM3_OK) {
   2266              // Power-loss might occur, however upon boot, the look-up table will be
   2267              // re-filled as long as the data has been successfully written to NVM3.
   2268              set_cache(nvm3_object_id);
   2269            } else {
   2270              psa_status = PSA_ERROR_STORAGE_FAILURE;
   2271            }
   2272          
   2273            exit:
   2274            // Clear and free key buffer before return.
   2275            memset(its_file_buffer, 0, its_file_size + sizeof(sl_its_file_meta_v1_t));
   2276            mbedtls_free(its_file_buffer);
   2277            sli_its_release_mutex();
   2278            return psa_status;
   2279          }
   2280          #endif //SLI_PSA_ITS_SUPPORT_V1_FORMAT_INTERNAL
   2281          #endif //SL_PSA_ITS_SUPPORT_V1_DRIVER
   2282          
   2283          /**
   2284           * \brief Search through NVM3 for correct uid
   2285           *
   2286           * \param[in] uid               UID under what we want to store the data
   2287           * \param[in] find_empty_slot   Indicates whether we want to find existing data or empty space for storing new.
   2288           * \param[out] its_file_meta    Meta information of ITS file
   2289           * \param[out] its_file_offset  Offset of ITS file
   2290           * \param[out] its_file_size    Size of ITS file
   2291           * \param[out] output_nvm3_id   NVM3 ID corresponding to UID.
   2292           *
   2293           * \return      A status indicating the success/failure of the operation
   2294           *
   2295           * \retval      PSA_SUCCESS                      The operation completed successfully
   2296           * \retval      PSA_ERROR_DOES_NOT_EXIST         The data with this UID are not stored in NVM3
   2297           * \retval      PSA_ERROR_NOT_PERMITTED          The requested operation is not permitted
   2298           */

   \                                 In section .text, align 2, keep-with-next
   2299          static psa_status_t find_nvm3_id(psa_storage_uid_t uid,
   2300                                           bool find_empty_slot,
   2301                                           sli_its_file_meta_v2_t* its_file_meta,
   2302                                           size_t* its_file_offset,
   2303                                           size_t* its_file_size,
   2304                                           nvm3_ObjectKey_t * output_nvm3_id)
   2305          {
   \                     find_nvm3_id: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0xB0A3             SUB      SP,SP,#+140
   2306            Ecode_t status;
   2307            nvm3_ObjectKey_t tmp_id = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9002             STR      R0,[SP, #+8]
   \        0xC   0x4688             MOV      R8,R1
   \        0xE   0x4699             MOV      R9,R3
   2308            nvm3_ObjectKey_t nvm3_object_id = 0;
   2309            nvm3_object_id = derive_nvm3_id(uid);
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x4692             MOV      R10,R2
   \       0x14   0x4041             EORS     R1,R0,R1
   \       0x16   0x2301             MOVS     R3,#+1
   \                     ??find_nvm3_id_0: (+1)
   \       0x18   0x00DE             LSLS     R6,R3,#+3
   \       0x1A   0xFA21 0xF206      LSR      R2,R1,R6
   \       0x1E   0x404A             EORS     R2,R2,R1
   \       0x20   0xF012 0x0F03      TST      R2,#0x3
   \       0x24   0xBF18             IT       NE
   \       0x26   0x0092             LSLNE    R2,R2,#+2
   \       0x28   0x1810             ADDS     R0,R2,R0
   \       0x2A   0x1C5B             ADDS     R3,R3,#+1
   \       0x2C   0x2B04             CMP      R3,#+4
   \       0x2E   0xD3F3             BCC.N    ??find_nvm3_id_0
   \       0x30   0x228A             MOVS     R2,#+138
   \       0x32   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \       0x36   0x218A             MOVS     R1,#+138
   \       0x38   0x.... 0x....      LDR.W    R6,??DataTable9_8
   \       0x3C   0xFB01 0x0012      MLS      R0,R1,R2,R0
   2310          
   2311            if (nvm3_uid_set_cache_initialized == false) {
   \       0x40   0x.... 0x....      LDR.W    R3,??DataTable9_6
   \       0x44   0x1830             ADDS     R0,R6,R0
   \       0x46   0x9001             STR      R0,[SP, #+4]
   \       0x48   0x7818             LDRB     R0,[R3, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD143             BNE.N    ??find_nvm3_id_1
   2312          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY) \
   2313              // With SKL the NVM3 instance must be initialized by the NS app. We therefore check that
   2314              // it has been opened (which is done on init) rather than actually doing the init.
   2315              if (!nvm3_defaultHandle->hasBeenOpened) {
   2316          #else
   2317              if (nvm3_initDefault() != ECODE_NVM3_OK) {
   \       0x4E   0x.... 0x....      BL       nvm3_initDefault
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xF040 0x80C9      BNE.W    ??find_nvm3_id_2
   2318          #endif
   2319                return PSA_ERROR_STORAGE_FAILURE;
   2320              }
   2321          
   2322          #if SL_PSA_ITS_SUPPORT_V2_DRIVER
   2323              if ( its_driver_version == SLI_PSA_ITS_NOT_CHECKED ) {
   2324                if ( detect_legacy_versions() != PSA_SUCCESS ) {
   2325                  return PSA_ERROR_STORAGE_FAILURE;
   2326                }
   2327                if ( its_driver_version == SLI_PSA_ITS_V2_DRIVER ) {
   2328                  psa_status_t psa_status = upgrade_all_keys();
   2329                  if ( psa_status != PSA_SUCCESS ) {
   2330                    return psa_status;
   2331                  }
   2332                  psa_status = write_driver_v3();
   2333                  if ( psa_status != PSA_SUCCESS ) {
   2334                    return psa_status;
   2335                  }
   2336                } else {
   2337                  init_cache();
   2338                }
   2339              } else {
   2340                init_cache();
   2341              }
   2342          #else
   2343              init_cache();
   \       0x58   0x2140             MOVS     R1,#+64
   \       0x5A   0xA813             ADD      R0,SP,#+76
   \       0x5C   0x.... 0x....      BL       __aeabi_memclr4
   \       0x60   0x2140             MOVS     R1,#+64
   \       0x62   0xA803             ADD      R0,SP,#+12
   \       0x64   0x.... 0x....      BL       __aeabi_memclr4
   \                     ??find_nvm3_id_3: (+1)
   \       0x68   0xF106 0x0B10      ADD      R11,R6,#+16
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \       0x70   0xF1AB 0x0101      SUB      R1,R11,#+1
   \       0x74   0x6800             LDR      R0,[R0, #+0]
   \       0x76   0x9100             STR      R1,[SP, #+0]
   \       0x78   0x4633             MOV      R3,R6
   \       0x7A   0x2210             MOVS     R2,#+16
   \       0x7C   0xA913             ADD      R1,SP,#+76
   \       0x7E   0x.... 0x....      BL       nvm3_enumObjects
   \       0x82   0x4605             MOV      R5,R0
   \       0x84   0x2700             MOVS     R7,#+0
   \       0x86   0xE005             B.N      ??find_nvm3_id_4
   \                     ??find_nvm3_id_5: (+1)
   \       0x88   0xA813             ADD      R0,SP,#+76
   \       0x8A   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \       0x8E   0x1C7F             ADDS     R7,R7,#+1
   \       0x90   0x.... 0x....      BL       set_cache
   \                     ??find_nvm3_id_4: (+1)
   \       0x94   0x42AF             CMP      R7,R5
   \       0x96   0xD3F7             BCC.N    ??find_nvm3_id_5
   \       0x98   0xF1AB 0x0001      SUB      R0,R11,#+1
   \       0x9C   0x9000             STR      R0,[SP, #+0]
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0x4633             MOV      R3,R6
   \       0xA6   0x2210             MOVS     R2,#+16
   \       0xA8   0xA903             ADD      R1,SP,#+12
   \       0xAA   0x.... 0x....      BL       nvm3_enumDeletedObjects
   \       0xAE   0x4605             MOV      R5,R0
   \       0xB0   0x2700             MOVS     R7,#+0
   \       0xB2   0xE005             B.N      ??find_nvm3_id_6
   \                     ??find_nvm3_id_7: (+1)
   \       0xB4   0xA803             ADD      R0,SP,#+12
   \       0xB6   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \       0xBA   0x1C7F             ADDS     R7,R7,#+1
   \       0xBC   0x.... 0x....      BL       set_tomb
   \                     ??find_nvm3_id_6: (+1)
   \       0xC0   0x42AF             CMP      R7,R5
   \       0xC2   0xD3F7             BCC.N    ??find_nvm3_id_7
   \       0xC4   0x3610             ADDS     R6,R6,#+16
   \       0xC6   0x.... 0x....      LDR.W    R2,??DataTable9_10
   \       0xCA   0x4296             CMP      R6,R2
   \       0xCC   0xD3CC             BCC.N    ??find_nvm3_id_3
   \       0xCE   0x2101             MOVS     R1,#+1
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \       0xD4   0x7001             STRB     R1,[R0, #+0]
   2344          #endif
   2345            }
   2346          
   2347            for (size_t i = 0; i < SL_PSA_ITS_MAX_FILES; ++i ) {
   \                     ??find_nvm3_id_1: (+1)
   \       0xD6   0x9F2C             LDR      R7,[SP, #+176]
   \       0xD8   0x9D2D             LDR      R5,[SP, #+180]
   \       0xDA   0xE9CD 0x4804      STRD     R4,R8,[SP, #+16]
   \       0xDE   0x9C02             LDR      R4,[SP, #+8]
   \       0xE0   0x9E01             LDR      R6,[SP, #+4]
   \       0xE2   0xF04F 0x088A      MOV      R8,#+138
   2348              if (!lookup_cache(nvm3_object_id)) {
   \                     ??find_nvm3_id_8: (+1)
   \       0xE6   0x4630             MOV      R0,R6
   \       0xE8   0x.... 0x....      BL       get_index
   \       0xEC   0x4683             MOV      R11,R0
   \       0xEE   0x4630             MOV      R0,R6
   \       0xF0   0x.... 0x....      BL       get_offset
   \       0xF4   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \       0xF8   0xEB01 0x028B      ADD      R2,R1,R11, LSL #+2
   \       0xFC   0x6853             LDR      R3,[R2, #+4]
   \       0xFE   0x40C3             LSRS     R3,R3,R0
   \      0x100   0x07D8             LSLS     R0,R3,#+31
   \      0x102   0xD41A             BMI.N    ??find_nvm3_id_9
   2349                // dont exist
   2350                if (lookup_tomb(nvm3_object_id)) {
   \      0x104   0x4630             MOV      R0,R6
   \      0x106   0x.... 0x....      BL       get_index
   \      0x10A   0x4683             MOV      R11,R0
   \      0x10C   0x4630             MOV      R0,R6
   \      0x10E   0x.... 0x....      BL       get_offset
   \      0x112   0x.... 0x....      LDR.W    R1,??DataTable9_6
   \      0x116   0xEB01 0x028B      ADD      R2,R1,R11, LSL #+2
   \      0x11A   0x6993             LDR      R3,[R2, #+24]
   \      0x11C   0x40C3             LSRS     R3,R3,R0
   \      0x11E   0x07D8             LSLS     R0,R3,#+31
   \      0x120   0xD503             BPL.N    ??find_nvm3_id_10
   2351                  // tombstone
   2352                  if (tmp_id == 0 ) {
   \      0x122   0x2C00             CMP      R4,#+0
   \      0x124   0xD158             BNE.N    ??find_nvm3_id_11
   2353                    // mark first empty space
   2354                    tmp_id = nvm3_object_id;
   \      0x126   0x4634             MOV      R4,R6
   \      0x128   0xE056             B.N      ??find_nvm3_id_11
   2355                  }
   2356                  nvm3_object_id = increment_obj_id(nvm3_object_id);
   2357                  continue;
   2358                } else {
   2359                  // empty space
   2360                  if (find_empty_slot) {
   \                     ??find_nvm3_id_10: (+1)
   \      0x12A   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x12E   0xD069             BEQ.N    ??find_nvm3_id_12
   2361                    if (tmp_id != 0) {
   \      0x130   0x2C00             CMP      R4,#+0
   \      0x132   0xD140             BNE.N    ??find_nvm3_id_13
   2362                      *output_nvm3_id = tmp_id;
   2363                      return PSA_SUCCESS;
   2364                    }
   2365                    *output_nvm3_id = nvm3_object_id;
   2366                    return PSA_SUCCESS;
   2367                  } else {
   2368                    return PSA_ERROR_DOES_NOT_EXIST;
   2369                  }
   2370                }
   2371              }
   2372              status = get_file_metadata(nvm3_object_id, its_file_meta, its_file_offset,
   2373                                         its_file_size);
   2374          
   2375              if (status == SLI_PSA_ITS_ECODE_NO_VALID_HEADER
   2376                  || status == ECODE_NVM3_ERR_READ_DATA_SIZE) {
   2377                // we don't expect any other data in our range then PSA ITS files.
   2378                // delete the file if the magic doesn't match or the object on disk
   2379                // is too small to even have full metadata.
   2380                status = nvm3_deleteObject(nvm3_defaultHandle, nvm3_object_id);
   2381                if (status != ECODE_NVM3_OK) {
   2382                  return PSA_ERROR_DOES_NOT_EXIST;
   2383                }
   2384              }
   2385          
   2386              if (status != ECODE_NVM3_OK
   2387                  && status != SLI_PSA_ITS_ECODE_NEEDS_UPGRADE) {
   2388                return PSA_ERROR_STORAGE_FAILURE;
   2389              }
   2390          
   2391              if (its_file_meta->uid != uid) {
   2392                nvm3_object_id = increment_obj_id(nvm3_object_id);
   2393              } else {
   2394                if (find_empty_slot) {
   2395                  if (its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE
   2396          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2397                      || its_file_meta->flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2398          #endif
   2399                      ) {
   2400                    return PSA_ERROR_NOT_PERMITTED;
   2401                  }
   2402                }
   2403          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2404                // If the UID already exists, authenticate the existing value and make sure the stored UID is the same.
   2405                // Note that this can potentially induce a significant performance hit.
   2406                psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2407                psa_storage_uid_t authenticated_uid = 0;
   2408                psa_status = authenticate_its_file(nvm3_object_id, &authenticated_uid);
   2409                if (psa_status != PSA_SUCCESS) {
   2410                  return psa_status;
   2411                }
   2412          
   2413                if (authenticated_uid != uid) {
   2414                  return PSA_ERROR_INVALID_SIGNATURE;
   2415                }
   2416          #endif
   2417                *output_nvm3_id = nvm3_object_id;
   \                     ??find_nvm3_id_14: (+1)
   \      0x134   0x982E             LDR      R0,[SP, #+184]
   \      0x136   0x6006             STR      R6,[R0, #+0]
   2418                return PSA_SUCCESS;
   \      0x138   0xE03F             B.N      ??find_nvm3_id_15
   \                     ??find_nvm3_id_9: (+1)
   \      0x13A   0xB10F             CBZ.N    R7,??find_nvm3_id_16
   \      0x13C   0x2000             MOVS     R0,#+0
   \      0x13E   0x6038             STR      R0,[R7, #+0]
   \                     ??find_nvm3_id_16: (+1)
   \      0x140   0xB10D             CBZ.N    R5,??find_nvm3_id_17
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0x6028             STR      R0,[R5, #+0]
   \                     ??find_nvm3_id_17: (+1)
   \      0x146   0x.... 0x....      LDR.W    R0,??DataTable9_9
   \      0x14A   0x2110             MOVS     R1,#+16
   \      0x14C   0x6800             LDR      R0,[R0, #+0]
   \      0x14E   0x9100             STR      R1,[SP, #+0]
   \      0x150   0x2300             MOVS     R3,#+0
   \      0x152   0x464A             MOV      R2,R9
   \      0x154   0x4631             MOV      R1,R6
   \      0x156   0x.... 0x....      BL       nvm3_readPartialData
   \      0x15A   0xEA5F 0x0B00      MOVS     R11,R0
   \      0x15E   0xD117             BNE.N    ??find_nvm3_id_18
   \      0x160   0xB10F             CBZ.N    R7,??find_nvm3_id_19
   \      0x162   0x2210             MOVS     R2,#+16
   \      0x164   0x603A             STR      R2,[R7, #+0]
   \                     ??find_nvm3_id_19: (+1)
   \      0x166   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x16A   0x....             LDR.N    R0,??DataTable9_11
   \      0x16C   0x4281             CMP      R1,R0
   \      0x16E   0xD116             BNE.N    ??find_nvm3_id_20
   \      0x170   0x2F00             CMP      R7,#+0
   \      0x172   0xBF18             IT       NE
   \      0x174   0x2D00             CMPNE    R5,#+0
   \      0x176   0xD00B             BEQ.N    ??find_nvm3_id_18
   \      0x178   0x....             LDR.N    R0,??DataTable9_9
   \      0x17A   0x6800             LDR      R0,[R0, #+0]
   \      0x17C   0x462B             MOV      R3,R5
   \      0x17E   0x466A             MOV      R2,SP
   \      0x180   0x4631             MOV      R1,R6
   \      0x182   0x.... 0x....      BL       nvm3_getObjectInfo
   \      0x186   0xB920             CBNZ.N   R0,??find_nvm3_id_21
   \      0x188   0x6829             LDR      R1,[R5, #+0]
   \      0x18A   0x6838             LDR      R0,[R7, #+0]
   \      0x18C   0x1A09             SUBS     R1,R1,R0
   \      0x18E   0x6029             STR      R1,[R5, #+0]
   \                     ??find_nvm3_id_18: (+1)
   \      0x190   0x4658             MOV      R0,R11
   \                     ??find_nvm3_id_21: (+1)
   \      0x192   0x....             LDR.N    R2,??DataTable9_12
   \      0x194   0x4290             CMP      R0,R2
   \      0x196   0xBF1C             ITT      NE
   \      0x198   0x....             LDRNE.N  R1,??DataTable9_13
   \      0x19A   0x4288             CMPNE    R0,R1
   \      0x19C   0xD10F             BNE.N    ??find_nvm3_id_22
   \                     ??find_nvm3_id_20: (+1)
   \      0x19E   0x....             LDR.N    R0,??DataTable9_9
   \      0x1A0   0x6800             LDR      R0,[R0, #+0]
   \      0x1A2   0x4631             MOV      R1,R6
   \      0x1A4   0x.... 0x....      BL       nvm3_deleteObject
   \      0x1A8   0xB170             CBZ.N    R0,??find_nvm3_id_23
   \      0x1AA   0xE02B             B.N      ??find_nvm3_id_12
   2419              }
   2420            }
   2421            if (find_empty_slot) {
   \                     ??find_nvm3_id_24: (+1)
   \      0x1AC   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1B0   0xBF18             IT       NE
   \      0x1B2   0x2C00             CMPNE    R4,#+0
   2422              if (tmp_id != 0) {
   \      0x1B4   0xD026             BEQ.N    ??find_nvm3_id_12
   2423                *output_nvm3_id = tmp_id;
   \                     ??find_nvm3_id_13: (+1)
   \      0x1B6   0x982E             LDR      R0,[SP, #+184]
   \      0x1B8   0x6004             STR      R4,[R0, #+0]
   2424                return PSA_SUCCESS;
   \                     ??find_nvm3_id_15: (+1)
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0xE024             B.N      ??find_nvm3_id_25
   2425              }
   2426            }
   \                     ??find_nvm3_id_22: (+1)
   \      0x1BE   0x2800             CMP      R0,#+0
   \      0x1C0   0xBF1C             ITT      NE
   \      0x1C2   0x....             LDRNE.N  R1,??DataTable9_14
   \      0x1C4   0x4288             CMPNE    R0,R1
   \      0x1C6   0xD110             BNE.N    ??find_nvm3_id_2
   \                     ??find_nvm3_id_23: (+1)
   \      0x1C8   0xE9D9 0x2302      LDRD     R2,R3,[R9, #+8]
   \      0x1CC   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \      0x1D0   0x428B             CMP      R3,R1
   \      0x1D2   0xBF08             IT       EQ
   \      0x1D4   0x4282             CMPEQ    R2,R0
   \      0x1D6   0xD00B             BEQ.N    ??find_nvm3_id_26
   \                     ??find_nvm3_id_11: (+1)
   \      0x1D8   0x4630             MOV      R0,R6
   \      0x1DA   0x.... 0x....      BL       increment_obj_id
   \      0x1DE   0x4606             MOV      R6,R0
   \      0x1E0   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \      0x1E4   0xF47F 0xAF7F      BNE.W    ??find_nvm3_id_8
   \      0x1E8   0xE7E0             B.N      ??find_nvm3_id_24
   \                     ??find_nvm3_id_2: (+1)
   \      0x1EA   0xF06F 0x0091      MVN      R0,#+145
   \      0x1EE   0xE00B             B.N      ??find_nvm3_id_25
   \                     ??find_nvm3_id_26: (+1)
   \      0x1F0   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1F4   0xD09E             BEQ.N    ??find_nvm3_id_14
   \      0x1F6   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x1FA   0x2801             CMP      R0,#+1
   \      0x1FC   0xD19A             BNE.N    ??find_nvm3_id_14
   \      0x1FE   0xF06F 0x0084      MVN      R0,#+132
   \      0x202   0xE001             B.N      ??find_nvm3_id_25
   2427            return PSA_ERROR_DOES_NOT_EXIST;
   \                     ??find_nvm3_id_12: (+1)
   \      0x204   0xF06F 0x008B      MVN      R0,#+139
   \                     ??find_nvm3_id_25: (+1)
   \      0x208   0xB023             ADD      SP,SP,#+140
   \      0x20A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2428          }
   2429          
   2430          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2431          static inline void cache_session_key(uint8_t *session_key, psa_storage_uid_t uid)
   2432          {
   2433            // Cache the session key
   2434            memcpy(g_cached_session_key.data, session_key, sizeof(g_cached_session_key.data));
   2435            g_cached_session_key.uid = uid;
   2436            g_cached_session_key.active = true;
   2437          }
   2438          
   2439          /**
   2440           * \brief Derive a session key for ITS file encryption from the initialized root key and provided IV.
   2441           *
   2442           * \param[in] iv                Pointer to array containing the initialization vector to be used in the key derivation.
   2443           * \param[in] iv_size           Size of the IV buffer in bytes. Must be 12 bytes (AES-GCM IV size).
   2444           * \param[out] session_key      Pointer to array where derived session key shall be stored.
   2445           * \param[out] session_key_size Size of the derived session key output array. Must be at least 32 bytes (AES-256 key size).
   2446           *
   2447           * \return      A status indicating the success/failure of the operation
   2448           *
   2449           * \retval      PSA_SUCCESS                      The operation completed successfully
   2450           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2451           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because iv or session_key is NULL, or their sizes are incorrect.
   2452           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2453           */
   2454          static psa_status_t derive_session_key(uint8_t *iv, size_t iv_size, uint8_t *session_key, size_t session_key_size)
   2455          {
   2456            if (iv == NULL
   2457                || iv_size != AES_GCM_IV_SIZE
   2458                || session_key == NULL
   2459                || session_key_size < SESSION_KEY_SIZE) {
   2460              return PSA_ERROR_INVALID_ARGUMENT;
   2461            }
   2462          
   2463            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2464            psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2465          
   2466          #if defined(SEMAILBOX_PRESENT)
   2467            // For HSE devices, use the builtin TrustZone Root Key
   2468            psa_set_key_id(&attributes, SL_SE_BUILTIN_KEY_TRUSTZONE_ID);
   2469          
   2470            psa_key_lifetime_t reported_lifetime;
   2471            psa_drv_slot_number_t reported_slot;
   2472            status = mbedtls_psa_platform_get_builtin_key(psa_get_key_id(&attributes),
   2473                                                          &reported_lifetime,
   2474                                                          &reported_slot);
   2475          
   2476            if (status != PSA_SUCCESS) {
   2477              return status;
   2478            }
   2479          
   2480            psa_set_key_lifetime(&attributes, reported_lifetime);
   2481          
   2482            uint8_t key_buffer[sizeof(sli_se_opaque_key_context_header_t)];
   2483            size_t key_buffer_size;
   2484            status = sli_se_opaque_get_builtin_key(reported_slot,
   2485                                                   &attributes,
   2486                                                   key_buffer,
   2487                                                   sizeof(key_buffer),
   2488                                                   &key_buffer_size);
   2489            if (status != PSA_SUCCESS) {
   2490              return status;
   2491            }
   2492          #else // defined(SEMAILBOX_PRESENT)
   2493            // For VSE devices, use the previously initialized root key
   2494            if (!g_root_key.initialized) {
   2495              return PSA_ERROR_BAD_STATE;
   2496            }
   2497          
   2498            // Prepare root key attributes
   2499            psa_set_key_algorithm(&attributes, PSA_ALG_CMAC);
   2500            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   2501            psa_set_key_bits(&attributes, ROOT_KEY_SIZE * 8);
   2502          
   2503            // Point the key buffer to the global root key
   2504            uint8_t *key_buffer = (uint8_t*)g_root_key.data;
   2505            size_t key_buffer_size = sizeof(g_root_key.data);
   2506          #endif // defined(SEMAILBOX_PRESENT)
   2507          
   2508            // Use CMAC as a key derivation function
   2509            size_t session_key_length;
   2510            status = psa_driver_wrapper_mac_compute(
   2511              &attributes,
   2512              key_buffer,
   2513              key_buffer_size,
   2514              PSA_ALG_CMAC,
   2515              iv,
   2516              iv_size,
   2517              session_key,
   2518              session_key_size,
   2519              &session_key_length);
   2520          
   2521            // Verify that the key derivation was successful before transferring the key to the caller
   2522            if (status != PSA_SUCCESS || session_key_length != SESSION_KEY_SIZE) {
   2523              memset(session_key, 0, session_key_size);
   2524              return PSA_ERROR_HARDWARE_FAILURE;
   2525            }
   2526          
   2527            return status;
   2528          }
   2529          
   2530          /**
   2531           * \brief Encrypt and authenticate ITS data with AES-128-GCM, storing the result in an encrypted blob.
   2532           *
   2533           * \param[in] metadata        ITS metadata to be used as authenticated additional data.
   2534           * \param[in] plaintext       Pointer to array containing data to be encrypted.
   2535           * \param[in] plaintext_size  Size of provided plaintext data array.
   2536           * \param[out] blob           Pointer to array where the resulting encrypted blob shall be placed.
   2537           * \param[in] blob_size       Size of the output array. Must be at least as big as plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
   2538           * \param[out] blob_length    Resulting size of the output blob.
   2539           *
   2540           * \return      A status indicating the success/failure of the operation
   2541           *
   2542           * \retval      PSA_SUCCESS                      The operation completed successfully
   2543           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2544           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
   2545           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2546           */
   2547          psa_status_t sli_encrypt_its_file(sli_its_file_meta_v2_t *metadata,
   2548                                            uint8_t *plaintext,
   2549                                            size_t plaintext_size,
   2550                                            sli_its_encrypted_blob_t *blob,
   2551                                            size_t blob_size,
   2552                                            size_t *blob_length)
   2553          {
   2554            if (metadata == NULL
   2555                || (plaintext == NULL && plaintext_size > 0)
   2556                || blob == NULL
   2557                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
   2558                || blob_length == NULL) {
   2559              return PSA_ERROR_INVALID_ARGUMENT;
   2560            }
   2561          
   2562            // Generate IV
   2563            size_t iv_length = 0;
   2564            psa_status_t psa_status = mbedtls_psa_external_get_random(NULL, blob->iv, AES_GCM_IV_SIZE, &iv_length);
   2565          
   2566            if (psa_status != PSA_SUCCESS || iv_length != AES_GCM_IV_SIZE) {
   2567              return PSA_ERROR_HARDWARE_FAILURE;
   2568            }
   2569          
   2570            // Prepare encryption key
   2571            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2572            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
   2573            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
   2574            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   2575            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
   2576          
   2577            uint8_t session_key[SESSION_KEY_SIZE];
   2578            psa_status = derive_session_key(blob->iv, AES_GCM_IV_SIZE, session_key, sizeof(session_key));
   2579            if (psa_status != PSA_SUCCESS) {
   2580              return psa_status;
   2581            }
   2582          
   2583            cache_session_key(session_key, metadata->uid);
   2584          
   2585            // Retrieve data to be encrypted
   2586            if (plaintext_size != 0U) {
   2587              memcpy(blob->data, ((uint8_t*)plaintext), plaintext_size);
   2588            }
   2589          
   2590            // Encrypt and authenticate blob
   2591            size_t output_length = 0;
   2592            psa_status = psa_driver_wrapper_aead_encrypt(
   2593              &attributes,
   2594              session_key, sizeof(session_key),
   2595              PSA_ALG_GCM,
   2596              blob->iv, sizeof(blob->iv),
   2597              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
   2598              blob->data, plaintext_size,
   2599              blob->data, plaintext_size + AES_GCM_MAC_SIZE,    // output == input for in-place encryption
   2600              &output_length);
   2601          
   2602            // Clear the local session key immediately after we're done using it
   2603            memset(session_key, 0, sizeof(session_key));
   2604          
   2605            if (psa_status != PSA_SUCCESS) {
   2606              return PSA_ERROR_HARDWARE_FAILURE;
   2607            }
   2608          
   2609            if (output_length != plaintext_size + AES_GCM_MAC_SIZE) {
   2610              return PSA_ERROR_HARDWARE_FAILURE;
   2611            }
   2612          
   2613            *blob_length = output_length + AES_GCM_IV_SIZE;
   2614          
   2615            return PSA_SUCCESS;
   2616          }
   2617          
   2618          /**
   2619           * \brief Decrypt and authenticate encrypted ITS data.
   2620           *
   2621           * \param[in] metadata          ITS metadata to be used as authenticated additional data. Must be identical to the metadata used during encryption.
   2622           * \param[in] blob              Encrypted blob containing data to be decrypted.
   2623           * \param[in] blob_size         Size of the encrypted blob in bytes.
   2624           * \param[out] plaintext        Pointer to array where the decrypted plaintext shall be placed.
   2625           * \param[in] plaintext_size    Size of the plaintext array. Must be equal to sizeof(blob->data) - AES_GCM_MAC_SIZE.
   2626           * \param[out] plaintext_length Resulting length of the decrypted plaintext.
   2627           *
   2628           * \return      A status indicating the success/failure of the operation
   2629           *
   2630           * \retval      PSA_SUCCESS                      The operation completed successfully
   2631           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
   2632           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2633           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
   2634           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2635           */
   2636          static psa_status_t sli_decrypt_its_file(sli_its_file_meta_v2_t *metadata,
   2637                                                   sli_its_encrypted_blob_t *blob,
   2638                                                   size_t blob_size,
   2639                                                   uint8_t *plaintext,
   2640                                                   size_t plaintext_size,
   2641                                                   size_t *plaintext_length)
   2642          {
   2643            if (metadata == NULL
   2644                || blob == NULL
   2645                || blob_size < plaintext_size + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD
   2646                || (plaintext == NULL && plaintext_size > 0)
   2647                || plaintext_length == NULL) {
   2648              return PSA_ERROR_INVALID_ARGUMENT;
   2649            }
   2650          
   2651            // Prepare decryption key
   2652            psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2653            psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
   2654            psa_set_key_algorithm(&attributes, PSA_ALG_GCM);
   2655            psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);
   2656            psa_set_key_bits(&attributes, SESSION_KEY_SIZE * 8);
   2657          
   2658            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2659            uint8_t session_key[SESSION_KEY_SIZE];
   2660          
   2661            if (g_cached_session_key.active && g_cached_session_key.uid == metadata->uid) {
   2662              // Use cached session key if it's already set and UID matches
   2663              memcpy(session_key, g_cached_session_key.data, sizeof(session_key));
   2664            } else {
   2665              psa_status = derive_session_key(blob->iv, AES_GCM_IV_SIZE, session_key, sizeof(session_key));
   2666              if (psa_status != PSA_SUCCESS) {
   2667                return psa_status;
   2668              }
   2669              cache_session_key(session_key, metadata->uid);
   2670            }
   2671          
   2672            // Decrypt and authenticate blob
   2673            size_t output_length = 0;
   2674            psa_status = psa_driver_wrapper_aead_decrypt(
   2675              &attributes,
   2676              session_key, sizeof(session_key),
   2677              PSA_ALG_GCM,
   2678              blob->iv, sizeof(blob->iv),
   2679              (uint8_t*)metadata, sizeof(sli_its_file_meta_v2_t),    // metadata is AAD
   2680              blob->data, plaintext_size + AES_GCM_MAC_SIZE,
   2681              plaintext, plaintext_size,
   2682              &output_length);
   2683          
   2684            // Clear the session key immediately after we're done using it
   2685            memset(session_key, 0, sizeof(session_key));
   2686          
   2687            // Invalid signature likely means that NVM data was tampered with
   2688            if (psa_status == PSA_ERROR_INVALID_SIGNATURE) {
   2689              return PSA_ERROR_INVALID_SIGNATURE;
   2690            }
   2691          
   2692            if (psa_status != PSA_SUCCESS
   2693                || output_length != plaintext_size) {
   2694              return PSA_ERROR_HARDWARE_FAILURE;
   2695            }
   2696          
   2697            *plaintext_length = output_length;
   2698          
   2699            return PSA_SUCCESS;
   2700          }
   2701          
   2702          /**
   2703           * \brief Authenticate encrypted ITS data and return the UID of the ITS file that was authenticated.
   2704           *
   2705           * \details NOTE: This function will run sli_decrypt_its_file() internally. The difference from the sli_decrypt_its_file()
   2706           *          function is that authenticate_its_file() reads the NVM3 data, decrypts it in order to authenticate the
   2707           *          stored data, and then discards the plaintext. This is needed since PSA Crypto doesn't support the
   2708           *          GMAC primitive directly, which means we have to run a full GCM decrypt for authentication.
   2709           *
   2710           * \param[in] nvm3_object_id      The NVM3 id corresponding to the stored ITS file.
   2711           * \param[out] authenticated_uid  UID for the authenticated ITS file.
   2712           *
   2713           * \return      A status indicating the success/failure of the operation
   2714           *
   2715           * \retval      PSA_SUCCESS                      The operation completed successfully
   2716           * \retval      PSA_ERROR_INVALID_SIGANTURE      The operation failed because authentication of the decrypted data failed.
   2717           * \retval      PSA_ERROR_BAD_STATE              The root key has not been initialized.
   2718           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one or more arguments are NULL or of invalid size.
   2719           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2720           */
   2721          static psa_status_t authenticate_its_file(nvm3_ObjectKey_t nvm3_object_id,
   2722                                                    psa_storage_uid_t *authenticated_uid)
   2723          {
   2724            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2725            sli_its_file_meta_v2_t *its_file_meta = NULL;
   2726            sli_its_encrypted_blob_t *blob = NULL;
   2727          
   2728            uint32_t obj_type;
   2729            size_t its_file_size = 0;
   2730            Ecode_t status = nvm3_getObjectInfo(nvm3_defaultHandle,
   2731                                                nvm3_object_id,
   2732                                                &obj_type,
   2733                                                &its_file_size);
   2734            if (status != ECODE_NVM3_OK) {
   2735              return PSA_ERROR_STORAGE_FAILURE;
   2736            }
   2737          
   2738            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size);
   2739            if (its_file_buffer == NULL) {
   2740              return PSA_ERROR_INSUFFICIENT_MEMORY;
   2741            }
   2742            memset(its_file_buffer, 0, its_file_size);
   2743          
   2744            status = nvm3_readData(nvm3_defaultHandle,
   2745                                   nvm3_object_id,
   2746                                   its_file_buffer,
   2747                                   its_file_size);
   2748            if (status != ECODE_NVM3_OK) {
   2749              psa_status = PSA_ERROR_STORAGE_FAILURE;
   2750              goto cleanup;
   2751            }
   2752          
   2753            its_file_meta = (sli_its_file_meta_v2_t*)its_file_buffer;
   2754            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   2755          
   2756            // Decrypt and authenticate blob
   2757            size_t plaintext_length;
   2758            psa_status = sli_decrypt_its_file(its_file_meta,
   2759                                              blob,
   2760                                              its_file_size - sizeof(sli_its_file_meta_v2_t),
   2761                                              blob->data,
   2762                                              its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   2763                                              &plaintext_length);
   2764          
   2765            if (psa_status != PSA_SUCCESS) {
   2766              goto cleanup;
   2767            }
   2768          
   2769            if (plaintext_length != (its_file_size - sizeof(sli_its_file_meta_v2_t) - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   2770              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   2771              goto cleanup;
   2772            }
   2773          
   2774            if (authenticated_uid != NULL) {
   2775              *authenticated_uid = its_file_meta->uid;
   2776            }
   2777          
   2778            psa_status = PSA_SUCCESS;
   2779          
   2780            cleanup:
   2781          
   2782            // Discard output, as we're only interested in whether the authentication check passed or not.
   2783            memset(its_file_buffer, 0, its_file_size);
   2784            mbedtls_free(its_file_buffer);
   2785          
   2786            return psa_status;
   2787          }
   2788          #endif // defined(SLI_PSA_ITS_ENCRYPTED)
   2789          
   2790          // -------------------------------------
   2791          // Global function definitions
   2792          
   2793          /**
   2794           * \brief create a new or modify an existing uid/value pair
   2795           *
   2796           * \param[in] uid           the identifier for the data
   2797           * \param[in] data_length   The size in bytes of the data in `p_data`
   2798           * \param[in] p_data        A buffer containing the data
   2799           * \param[in] create_flags  The flags that the data will be stored with
   2800           *
   2801           * \return      A status indicating the success/failure of the operation
   2802           *
   2803           * \retval      PSA_SUCCESS                      The operation completed successfully
   2804           * \retval      PSA_ERROR_NOT_PERMITTED          The operation failed because the provided `uid` value was already created with PSA_STORAGE_FLAG_WRITE_ONCE
   2805           * \retval      PSA_ERROR_NOT_SUPPORTED          The operation failed because one or more of the flags provided in `create_flags` is not supported or is not valid
   2806           * \retval      PSA_ERROR_INSUFFICIENT_STORAGE   The operation failed because there was insufficient space on the storage medium
   2807           * \retval      PSA_ERROR_STORAGE_FAILURE        The operation failed because the physical storage has failed (Fatal error)
   2808           * \retval      PSA_ERROR_INVALID_ARGUMENT       The operation failed because one of the provided pointers(`p_data`)
   2809           *                                               is invalid, for example is `NULL` or references memory the caller cannot access
   2810           * \retval      PSA_ERROR_HARDWARE_FAILURE       The operation failed because an internal cryptographic operation failed.
   2811           * \retval      PSA_ERROR_INVALID_SIGNATURE      The operation failed because the provided `uid` doesnt match the autenticated uid from the storage
   2812           */

   \                                 In section .text, align 2, keep-with-next
   2813          psa_status_t psa_its_set(psa_storage_uid_t uid,
   2814                                   uint32_t data_length,
   2815                                   const void *p_data,
   2816                                   psa_storage_create_flags_t create_flags)
   2817          {
   \                     psa_its_set: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x468A             MOV      R10,R1
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0x461F             MOV      R7,R3
   2818            if ((data_length != 0U) && (p_data == NULL)) {
   \        0xE   0xF06F 0x0991      MVN      R9,#+145
   \       0x12   0xD009             BEQ.N    ??psa_its_set_0
   \       0x14   0xB917             CBNZ.N   R7,??psa_its_set_1
   2819              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x16   0xF06F 0x0086      MVN      R0,#+134
   \       0x1A   0xE057             B.N      ??psa_its_set_2
   2820            }
   2821            if ((data_length > NVM3_MAX_OBJECT_SIZE)) {
   \                     ??psa_its_set_1: (+1)
   \       0x1C   0xF240 0x706D      MOVW     R0,#+1901
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xBF28             IT       CS
   \       0x24   0x4648             MOVCS    R0,R9
   2822              return PSA_ERROR_STORAGE_FAILURE;
   \       0x26   0xD251             BCS.N    ??psa_its_set_2
   \                     ??psa_its_set_0: (+1)
   \       0x28   0x9D0E             LDR      R5,[SP, #+56]
   2823            }
   2824          
   2825            if (create_flags != PSA_STORAGE_FLAG_WRITE_ONCE
   2826                && create_flags != PSA_STORAGE_FLAG_NONE
   2827          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2828                && create_flags != PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2829          #endif
   2830                ) {
   \       0x2A   0x2D01             CMP      R5,#+1
   \       0x2C   0xBF1C             ITT      NE
   \       0x2E   0x2D00             CMPNE    R5,#+0
   \       0x30   0xF06F 0x0085      MVNNE    R0,#+133
   2831              return PSA_ERROR_NOT_SUPPORTED;
   \       0x34   0xD14A             BNE.N    ??psa_its_set_2
   2832            }
   2833          
   2834          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2835            if ((create_flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
   2836                && (!object_lives_in_s(p_data, data_length))) {
   2837              // The flag indicates that this data should not be set by the non-secure domain
   2838              return PSA_ERROR_INVALID_ARGUMENT;
   2839            }
   2840          #endif
   2841          
   2842            Ecode_t status;
   2843            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   2844            sli_its_file_meta_v2_t* its_file_meta;
   2845            nvm3_ObjectKey_t nvm3_object_id = 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x9003             STR      R0,[SP, #+12]
   2846          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2847            sli_its_encrypted_blob_t *blob = NULL;
   2848            size_t its_file_size = data_length + SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   2849            size_t blob_length = 0u;
   2850          #else
   2851            size_t its_file_size = data_length;
   2852          #endif
   2853          
   2854            uint8_t *its_file_buffer = mbedtls_calloc(1, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \       0x3A   0xF104 0x0110      ADD      R1,R4,#+16
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x.... 0x....      BL       sl_calloc
   \       0x44   0x0006             MOVS     R6,R0
   2855            if (its_file_buffer == NULL) {
   \       0x46   0xBF08             IT       EQ
   \       0x48   0xF06F 0x008C      MVNEQ    R0,#+140
   2856              return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x4C   0xD03E             BEQ.N    ??psa_its_set_2
   2857            }
   2858            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \       0x4E   0xF104 0x0110      ADD      R1,R4,#+16
   \       0x52   0x.... 0x....      BL       __aeabi_memclr
   2859          
   2860            its_file_meta = (sli_its_file_meta_v2_t *)its_file_buffer;
   2861          
   2862            sli_its_acquire_mutex();
   \       0x56   0x.... 0x....      BL       sli_its_acquire_mutex
   2863            psa_status = find_nvm3_id(uid, true, its_file_meta, NULL, NULL, &nvm3_object_id);
   \       0x5A   0xA803             ADD      R0,SP,#+12
   \       0x5C   0x9002             STR      R0,[SP, #+8]
   \       0x5E   0x2300             MOVS     R3,#+0
   \       0x60   0x9301             STR      R3,[SP, #+4]
   \       0x62   0x9300             STR      R3,[SP, #+0]
   \       0x64   0x4633             MOV      R3,R6
   \       0x66   0x2201             MOVS     R2,#+1
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0x4651             MOV      R1,R10
   \       0x6C   0x.... 0x....      BL       find_nvm3_id
   \       0x70   0xEA5F 0x0B00      MOVS     R11,R0
   2864            if (psa_status != PSA_SUCCESS) {
   \       0x74   0xD005             BEQ.N    ??psa_its_set_3
   2865              if (psa_status == PSA_ERROR_DOES_NOT_EXIST) {
   \       0x76   0xF11B 0x0F8C      CMN      R11,#+140
   \       0x7A   0xD11C             BNE.N    ??psa_its_set_4
   2866                psa_status = PSA_ERROR_INSUFFICIENT_STORAGE;
   \       0x7C   0xF06F 0x0B8D      MVN      R11,#+141
   \       0x80   0xE019             B.N      ??psa_its_set_4
   2867              }
   2868              goto exit;
   2869            }
   2870          
   2871            its_file_meta->magic = SLI_PSA_ITS_META_MAGIC_V2;
   \                     ??psa_its_set_3: (+1)
   \       0x82   0x....             LDR.N    R0,??DataTable9_11
   \       0x84   0x6030             STR      R0,[R6, #+0]
   2872            its_file_meta->uid = uid;
   \       0x86   0xE9C6 0x8A02      STRD     R8,R10,[R6, #+8]
   2873            its_file_meta->flags = create_flags;
   \       0x8A   0x6075             STR      R5,[R6, #+4]
   2874          
   2875          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2876            // Everything after the the file metadata will make up the encrypted & authenticated blob
   2877            blob = (sli_its_encrypted_blob_t*)(its_file_buffer + sizeof(sli_its_file_meta_v2_t));
   2878          
   2879            // Encrypt and authenticate the provided data
   2880            psa_status = sli_encrypt_its_file(its_file_meta,
   2881                                              (uint8_t*)p_data,
   2882                                              data_length,
   2883                                              blob,
   2884                                              its_file_size,
   2885                                              &blob_length);
   2886          
   2887            if (psa_status != PSA_SUCCESS) {
   2888              goto exit;
   2889            }
   2890          
   2891            if (blob_length != its_file_size) {
   2892              psa_status = PSA_ERROR_HARDWARE_FAILURE;
   2893              goto exit;
   2894            }
   2895          
   2896          #else
   2897            if (data_length != 0U) {
   \       0x8C   0xB12C             CBZ.N    R4,??psa_its_set_5
   2898              memcpy(its_file_buffer + sizeof(sli_its_file_meta_v2_t), ((uint8_t*)p_data), data_length);
   \       0x8E   0x4622             MOV      R2,R4
   \       0x90   0x4639             MOV      R1,R7
   \       0x92   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x96   0x.... 0x....      BL       __aeabi_memcpy
   2899            }
   2900          #endif
   2901          
   2902            status = nvm3_writeData(nvm3_defaultHandle,
   2903                                    nvm3_object_id,
   2904                                    its_file_buffer, its_file_size + sizeof(sli_its_file_meta_v2_t));
   2905          
   2906            if (status == ECODE_NVM3_OK) {
   \                     ??psa_its_set_5: (+1)
   \       0x9A   0x....             LDR.N    R0,??DataTable9_9
   \       0x9C   0x9903             LDR      R1,[SP, #+12]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0xF104 0x0310      ADD      R3,R4,#+16
   \       0xA4   0x4632             MOV      R2,R6
   \       0xA6   0x.... 0x....      BL       nvm3_writeData
   \       0xAA   0xB918             CBNZ.N   R0,??psa_its_set_6
   2907              // Power-loss might occur, however upon boot, the look-up table will be
   2908              // re-filled as long as the data has been successfully written to NVM3.
   2909              set_cache(nvm3_object_id);
   \       0xAC   0x9803             LDR      R0,[SP, #+12]
   \       0xAE   0x.... 0x....      BL       set_cache
   \       0xB2   0xE000             B.N      ??psa_its_set_4
   2910            } else {
   2911              psa_status = PSA_ERROR_STORAGE_FAILURE;
   \                     ??psa_its_set_6: (+1)
   \       0xB4   0x46CB             MOV      R11,R9
   2912            }
   2913          
   2914            exit:
   2915            // Clear and free key buffer before return.
   2916            memset(its_file_buffer, 0, its_file_size + sizeof(sli_its_file_meta_v2_t));
   \                     ??psa_its_set_4: (+1)
   \       0xB6   0xF104 0x0110      ADD      R1,R4,#+16
   \       0xBA   0x4630             MOV      R0,R6
   \       0xBC   0x.... 0x....      BL       __aeabi_memclr
   2917            mbedtls_free(its_file_buffer);
   \       0xC0   0x4630             MOV      R0,R6
   \       0xC2   0x.... 0x....      BL       sl_free
   2918            sli_its_release_mutex();
   \       0xC6   0x.... 0x....      BL       sli_its_release_mutex
   2919            return psa_status;
   \       0xCA   0x4658             MOV      R0,R11
   \                     ??psa_its_set_2: (+1)
   \       0xCC   0xB005             ADD      SP,SP,#+20
   \       0xCE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2920          }
   2921          
   2922          /**
   2923           * \brief Retrieve the value associated with a provided uid
   2924           *
   2925           * \param[in] uid               The uid value
   2926           * \param[in] data_offset       The starting offset of the data requested
   2927           * \param[in] data_length       the amount of data requested (and the minimum allocated size of the `p_data` buffer)
   2928           * \param[out] p_data           The buffer where the data will be placed upon successful completion
   2929           * \param[out] p_data_length    The amount of data returned in the p_data buffer
   2930           *
   2931           *
   2932           * \return      A status indicating the success/failure of the operation
   2933           *
   2934           * \retval      PSA_SUCCESS                  The operation completed successfully
   2935           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided `uid` value was not found in the storage
   2936           * \retval      PSA_ERROR_BUFFER_TOO_SMALL   The operation failed because the data associated with provided uid is larger than `data_size`
   2937           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   2938           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_data`, `p_data_length`)
   2939           *                                           is invalid. For example is `NULL` or references memory the caller cannot access.
   2940           *                                           In addition, this can also happen if an invalid offset was provided.
   2941           */

   \                                 In section .text, align 2, keep-with-next
   2942          psa_status_t psa_its_get(psa_storage_uid_t uid,
   2943                                   uint32_t data_offset,
   2944                                   uint32_t data_length,
   2945                                   void *p_data,
   2946                                   size_t *p_data_length)
   2947          {
   \                     psa_its_get: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0x001C             MOVS     R4,R3
   \        0xA   0x9D14             LDR      R5,[SP, #+80]
   \        0xC   0x9E15             LDR      R6,[SP, #+84]
   2948            if ((data_length != 0U) && (p_data_length == NULL)) {
   \        0xE   0xF06F 0x0886      MVN      R8,#+134
   \       0x12   0xD00C             BEQ.N    ??psa_its_get_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2D00             CMPNE    R5,#+0
   2949              return PSA_ERROR_INVALID_ARGUMENT;
   2950            }
   2951          
   2952            if (data_length != 0U) {
   2953              // If the request amount of data is 0, allow invalid pointer of the output buffer.
   2954              if ((p_data == NULL)
   2955                  || ((uint32_t)p_data < SRAM_BASE)
   2956                  || ((uint32_t)p_data > (SRAM_BASE + SRAM_SIZE - data_length))) {
   \       0x1A   0xD006             BEQ.N    ??psa_its_get_1
   \       0x1C   0xF1B5 0x5F00      CMP      R5,#+536870912
   \       0x20   0xBF22             ITTT     CS
   \       0x22   0x....             LDRCS.N  R2,??DataTable9_15
   \       0x24   0x1B12             SUBCS    R2,R2,R4
   \       0x26   0x42AA             CMPCS    R2,R5
   \       0x28   0xD201             BCS.N    ??psa_its_get_0
   2957                return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_its_get_1: (+1)
   \       0x2A   0x4640             MOV      R0,R8
   \       0x2C   0xE036             B.N      ??psa_its_get_2
   2958              }
   2959            }
   \                     ??psa_its_get_0: (+1)
   \       0x2E   0x4682             MOV      R10,R0
   \       0x30   0x468B             MOV      R11,R1
   2960          
   2961          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2962            size_t plaintext_length;
   2963            sli_its_encrypted_blob_t *blob = NULL;
   2964          #endif
   2965            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x32   0xF10D 0x0C18      ADD      R12,SP,#+24
   \       0x36   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x3A   0xE88C 0x000F      STM      R12,{R0-R3}
   2966            Ecode_t status;
   2967            sli_its_file_meta_v2_t its_file_meta = { 0 };
   2968            size_t its_file_size = 0u;
   \       0x3E   0x9205             STR      R2,[SP, #+20]
   2969            size_t its_file_data_size = 0u;
   2970            size_t its_file_offset = 0u;
   \       0x40   0x9104             STR      R1,[SP, #+16]
   2971            nvm3_ObjectKey_t nvm3_object_id;
   2972          
   2973            sli_its_acquire_mutex();
   \       0x42   0x.... 0x....      BL       sli_its_acquire_mutex
   2974            psa_status = find_nvm3_id(uid, false, &its_file_meta, &its_file_offset, &its_file_size, &nvm3_object_id);
   \       0x46   0xA803             ADD      R0,SP,#+12
   \       0x48   0x9002             STR      R0,[SP, #+8]
   \       0x4A   0xA805             ADD      R0,SP,#+20
   \       0x4C   0x9001             STR      R0,[SP, #+4]
   \       0x4E   0xA804             ADD      R0,SP,#+16
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xAB06             ADD      R3,SP,#+24
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x4650             MOV      R0,R10
   \       0x58   0x4659             MOV      R1,R11
   \       0x5A   0x.... 0x....      BL       find_nvm3_id
   \       0x5E   0xEA5F 0x0900      MOVS     R9,R0
   2975            if (psa_status != PSA_SUCCESS) {
   \       0x62   0xD118             BNE.N    ??psa_its_get_3
   2976              goto exit;
   2977            }
   2978          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   2979            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE
   2980                && !object_lives_in_s(p_data, data_length)) {
   2981              // The flag indicates that this data should not be read back to the non-secure domain
   2982              psa_status = PSA_ERROR_INVALID_ARGUMENT;
   2983              goto exit;
   2984            }
   2985          #endif
   2986          
   2987          #if defined(SLI_PSA_ITS_ENCRYPTED)
   2988            // Subtract IV and MAC from ITS file as the below checks concern the actual data size
   2989            its_file_data_size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   2990          #else
   2991            its_file_data_size = its_file_size;
   \       0x64   0x9805             LDR      R0,[SP, #+20]
   2992          #endif
   2993          
   2994            if (data_length != 0U) {
   \       0x66   0xB1E4             CBZ.N    R4,??psa_its_get_4
   2995              if ((data_offset >= its_file_data_size) && (its_file_data_size != 0U)) {
   \       0x68   0x4287             CMP      R7,R0
   \       0x6A   0xD301             BCC.N    ??psa_its_get_5
   \       0x6C   0xB9D8             CBNZ.N   R0,??psa_its_get_6
   \       0x6E   0xE000             B.N      ??psa_its_get_7
   2996                psa_status = PSA_ERROR_INVALID_ARGUMENT;
   2997                goto exit;
   2998              }
   2999          
   3000              if ((its_file_data_size == 0U) && (data_offset != 0U)) {
   \                     ??psa_its_get_5: (+1)
   \       0x70   0xB900             CBNZ.N   R0,??psa_its_get_8
   \                     ??psa_its_get_7: (+1)
   \       0x72   0xB9C7             CBNZ.N   R7,??psa_its_get_6
   3001                psa_status = PSA_ERROR_INVALID_ARGUMENT;
   3002                goto exit;
   3003              }
   3004            } else {
   3005              // Allow the offset at the data size boundary if the requested amount of data is zero.
   3006              if (data_offset > its_file_data_size) {
   3007                psa_status = PSA_ERROR_INVALID_ARGUMENT;
   3008                goto exit;
   3009              }
   3010            }
   3011          
   3012            if (data_length > (its_file_data_size - data_offset)) {
   \                     ??psa_its_get_8: (+1)
   \       0x74   0x1BC0             SUBS     R0,R0,R7
   \       0x76   0x42A0             CMP      R0,R4
   \       0x78   0xBF88             IT       HI
   \       0x7A   0x4620             MOVHI    R0,R4
   3013              *p_data_length = its_file_data_size - data_offset;
   3014            } else {
   3015              *p_data_length = data_length;
   3016            }
   3017          
   3018          #if defined(SLI_PSA_ITS_ENCRYPTED)
   3019            // its_file_size includes size of sli_its_encrypted_blob_t struct
   3020            blob = (sli_its_encrypted_blob_t*)mbedtls_calloc(1, its_file_size);
   3021            if (blob == NULL) {
   3022              psa_status = PSA_ERROR_INSUFFICIENT_MEMORY;
   3023              goto exit;
   3024            }
   3025            memset(blob, 0, its_file_size);
   3026          
   3027            status = nvm3_readPartialData(nvm3_defaultHandle,
   3028                                          nvm3_object_id,
   3029                                          blob,
   3030                                          its_file_offset,
   3031                                          its_file_size);
   3032            if (status != ECODE_NVM3_OK) {
   3033              psa_status = PSA_ERROR_STORAGE_FAILURE;
   3034              goto exit;
   3035            }
   3036          
   3037            // Decrypt and authenticate blob
   3038            psa_status = sli_decrypt_its_file(&its_file_meta,
   3039                                              blob,
   3040                                              its_file_size,
   3041                                              blob->data,
   3042                                              its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD,
   3043                                              &plaintext_length);
   3044          
   3045            if (psa_status != PSA_SUCCESS) {
   3046              goto exit;
   3047            }
   3048          
   3049            if (plaintext_length != (its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD)) {
   3050              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   3051              goto exit;
   3052            }
   3053          
   3054            // Verify that the requested UID is equal to the retrieved and authenticated UID
   3055            if (uid != its_file_meta.uid) {
   3056              psa_status = PSA_ERROR_INVALID_ARGUMENT;
   3057              goto exit;
   3058            }
   3059          
   3060            if (*p_data_length > 0) {
   3061              memcpy(p_data, blob->data + data_offset, *p_data_length);
   3062            }
   3063            psa_status = PSA_SUCCESS;
   3064          
   3065            exit:
   3066            if (blob != NULL) {
   3067              memset(blob, 0, its_file_size);
   3068              mbedtls_free(blob);
   3069            }
   3070            sli_its_release_mutex();
   3071          #else
   3072            // If no encryption is used, just read out the data and write it directly to the output buffer
   3073            status = nvm3_readPartialData(nvm3_defaultHandle, nvm3_object_id, p_data, its_file_offset + data_offset, *p_data_length);
   3074          
   3075            if (status != ECODE_NVM3_OK) {
   \       0x7C   0x6030             STR      R0,[R6, #+0]
   \       0x7E   0x9904             LDR      R1,[SP, #+16]
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0x....             LDR.N    R0,??DataTable9_9
   \       0x84   0x187B             ADDS     R3,R7,R1
   \       0x86   0x9903             LDR      R1,[SP, #+12]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x462A             MOV      R2,R5
   \       0x8C   0x.... 0x....      BL       nvm3_readPartialData
   \       0x90   0xB108             CBZ.N    R0,??psa_its_get_3
   3076              psa_status = PSA_ERROR_STORAGE_FAILURE;
   \       0x92   0xF06F 0x0991      MVN      R9,#+145
   3077            } else {
   3078              psa_status = PSA_SUCCESS;
   3079            }
   3080          
   3081            exit:
   3082            sli_its_release_mutex();
   \                     ??psa_its_get_3: (+1)
   \       0x96   0x.... 0x....      BL       sli_its_release_mutex
   3083          #endif
   3084          
   3085            return psa_status;
   \       0x9A   0x4648             MOV      R0,R9
   \                     ??psa_its_get_2: (+1)
   \       0x9C   0xB00B             ADD      SP,SP,#+44
   \       0x9E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??psa_its_get_4: (+1)
   \       0xA2   0x42B8             CMP      R0,R7
   \       0xA4   0xD2E6             BCS.N    ??psa_its_get_8
   \                     ??psa_its_get_6: (+1)
   \       0xA6   0x46C1             MOV      R9,R8
   \       0xA8   0xE7F5             B.N      ??psa_its_get_3
   3086          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x4770             BX       LR
   3087          
   3088          /**
   3089           * \brief Retrieve the metadata about the provided uid
   3090           *
   3091           * \param[in] uid           The uid value
   3092           * \param[out] p_info       A pointer to the `psa_storage_info_t` struct that will be populated with the metadata
   3093           *
   3094           * \return      A status indicating the success/failure of the operation
   3095           *
   3096           * \retval      PSA_SUCCESS                  The operation completed successfully
   3097           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided uid value was not found in the storage
   3098           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   3099           * \retval      PSA_ERROR_INVALID_ARGUMENT   The operation failed because one of the provided pointers(`p_info`)
   3100           *                                           is invalid, for example is `NULL` or references memory the caller cannot access
   3101           * \retval      PSA_ERROR_INVALID_SIGANTURE  The operation failed because authentication of the stored metadata failed.
   3102           */

   \                                 In section .text, align 2, keep-with-next
   3103          psa_status_t psa_its_get_info(psa_storage_uid_t uid,
   3104                                        struct psa_storage_info_t *p_info)
   3105          {
   \                     psa_its_get_info: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x0016             MOVS     R6,R2
   3106            if (p_info == NULL) {
   \        0x6   0xBF08             IT       EQ
   \        0x8   0xF06F 0x0086      MVNEQ    R0,#+134
   3107              return PSA_ERROR_INVALID_ARGUMENT;
   \        0xC   0xD01C             BEQ.N    ??psa_its_get_info_0
   \        0xE   0x4604             MOV      R4,R0
   \       0x10   0x460D             MOV      R5,R1
   3108            }
   3109          
   3110            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x12   0xAF06             ADD      R7,SP,#+24
   \       0x14   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x18   0xE887 0x000F      STM      R7,{R0-R3}
   3111            sli_its_file_meta_v2_t its_file_meta = { 0 };
   3112            size_t its_file_size = 0;
   \       0x1C   0x9203             STR      R2,[SP, #+12]
   3113            size_t its_file_offset = 0;
   \       0x1E   0x9105             STR      R1,[SP, #+20]
   3114            nvm3_ObjectKey_t nvm3_object_id;
   3115          
   3116            sli_its_acquire_mutex();
   \       0x20   0x.... 0x....      BL       sli_its_acquire_mutex
   3117            psa_status = find_nvm3_id(uid, false, &its_file_meta, &its_file_offset, &its_file_size, &nvm3_object_id);
   \       0x24   0xA804             ADD      R0,SP,#+16
   \       0x26   0xAB03             ADD      R3,SP,#+12
   \       0x28   0xAA05             ADD      R2,SP,#+20
   \       0x2A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x2E   0x0004             MOVS     R4,R0
   3118            if (psa_status != PSA_SUCCESS) {
   \       0x30   0xD003             BEQ.N    ??psa_its_get_info_1
   3119              sli_its_release_mutex();
   \       0x32   0x.... 0x....      BL       sli_its_release_mutex
   3120              return psa_status;
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xE006             B.N      ??psa_its_get_info_0
   3121            }
   3122          
   3123            p_info->flags = its_file_meta.flags;
   \                     ??psa_its_get_info_1: (+1)
   \       0x3A   0x9907             LDR      R1,[SP, #+28]
   \       0x3C   0x6071             STR      R1,[R6, #+4]
   3124            p_info->size = its_file_size;
   \       0x3E   0x9803             LDR      R0,[SP, #+12]
   \       0x40   0x6030             STR      R0,[R6, #+0]
   3125          
   3126          #if defined(SLI_PSA_ITS_ENCRYPTED)
   3127            // Remove IV and MAC size from file size
   3128            p_info->size = its_file_size - SLI_ITS_ENCRYPTED_BLOB_SIZE_OVERHEAD;
   3129          #endif
   3130            sli_its_release_mutex();
   \       0x42   0x.... 0x....      BL       sli_its_release_mutex
   3131            return PSA_SUCCESS;
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??psa_its_get_info_0: (+1)
   \       0x48   0xB00B             ADD      SP,SP,#+44
   \       0x4A   0xBDF0             POP      {R4-R7,PC}
   3132          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x9002             STR      R0,[SP, #+8]
   \        0x2   0x9301             STR      R3,[SP, #+4]
   \        0x4   0x9200             STR      R2,[SP, #+0]
   \        0x6   0xAB06             ADD      R3,SP,#+24
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x4629             MOV      R1,R5
   \        0xE   0x....             B.N      find_nvm3_id
   3133          
   3134          /**
   3135           * \brief Remove the provided key and its associated data from the storage
   3136           *
   3137           * \param[in] uid   The uid value
   3138           *
   3139           * \return  A status indicating the success/failure of the operation
   3140           *
   3141           * \retval      PSA_SUCCESS                  The operation completed successfully
   3142           * \retval      PSA_ERROR_DOES_NOT_EXIST     The operation failed because the provided key value was not found in the storage
   3143           * \retval      PSA_ERROR_NOT_PERMITTED      The operation failed because the provided key value was created with PSA_STORAGE_FLAG_WRITE_ONCE
   3144           * \retval      PSA_ERROR_STORAGE_FAILURE    The operation failed because the physical storage has failed (Fatal error)
   3145           */

   \                                 In section .text, align 2, keep-with-next
   3146          psa_status_t psa_its_remove(psa_storage_uid_t uid)
   3147          {
   \                     psa_its_remove: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   3148            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \        0x8   0xAE06             ADD      R6,SP,#+24
   \        0xA   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0xE   0xE886 0x000F      STM      R6,{R0-R3}
   3149            Ecode_t status;
   3150            sli_its_file_meta_v2_t its_file_meta = { 0 };
   3151            size_t its_file_size = 0;
   \       0x12   0x9205             STR      R2,[SP, #+20]
   3152            size_t its_file_offset = 0;
   \       0x14   0x9104             STR      R1,[SP, #+16]
   3153            nvm3_ObjectKey_t nvm3_object_id;
   3154          
   3155            sli_its_acquire_mutex();
   \       0x16   0x.... 0x....      BL       sli_its_acquire_mutex
   3156            psa_status = find_nvm3_id(uid, false, &its_file_meta, &its_file_offset, &its_file_size, &nvm3_object_id);
   \       0x1A   0xA803             ADD      R0,SP,#+12
   \       0x1C   0xAB05             ADD      R3,SP,#+20
   \       0x1E   0xAA04             ADD      R2,SP,#+16
   \       0x20   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x24   0x0004             MOVS     R4,R0
   3157            if (psa_status != PSA_SUCCESS) {
   \       0x26   0xD11F             BNE.N    ??psa_its_remove_0
   3158              goto exit;
   3159            }
   3160            if (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE
   3161          #if defined(TFM_CONFIG_SL_SECURE_LIBRARY)
   3162                || (its_file_meta.flags == PSA_STORAGE_FLAG_WRITE_ONCE_SECURE_ACCESSIBLE)
   3163          #endif
   3164                ) {
   \       0x28   0x9807             LDR      R0,[SP, #+28]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xBF08             IT       EQ
   \       0x2E   0xF06F 0x0484      MVNEQ    R4,#+132
   3165              psa_status = PSA_ERROR_NOT_PERMITTED;
   3166              goto exit;
   \       0x32   0xD019             BEQ.N    ??psa_its_remove_0
   3167            }
   3168            status = nvm3_deleteObject(nvm3_defaultHandle, nvm3_object_id);
   3169            if (status == ECODE_NVM3_OK) {
   \       0x34   0x....             LDR.N    R0,??DataTable9_9
   \       0x36   0x9903             LDR      R1,[SP, #+12]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x.... 0x....      BL       nvm3_deleteObject
   \       0x3E   0xB988             CBNZ.N   R0,??psa_its_remove_1
   3170              // Power-loss might occur, however upon boot, the look-up table will be
   3171              // re-filled as long as the data has been successfully written to NVM3.
   3172              clear_cache(nvm3_object_id);
   \       0x40   0x9803             LDR      R0,[SP, #+12]
   \       0x42   0x....             LDR.N    R1,??DataTable9_5
   \       0x44   0x....             LDR.N    R2,??DataTable9_6
   \       0x46   0x1809             ADDS     R1,R1,R0
   \       0x48   0x0949             LSRS     R1,R1,#+5
   \       0x4A   0x1D16             ADDS     R6,R2,#+4
   \       0x4C   0xF856 0x5021      LDR      R5,[R6, R1, LSL #+2]
   \       0x50   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x54   0x4068             EORS     R0,R0,R5
   \       0x56   0x1D12             ADDS     R2,R2,#+4
   \       0x58   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   3173              set_tomb(nvm3_object_id);
   \       0x5C   0x9803             LDR      R0,[SP, #+12]
   \       0x5E   0x.... 0x....      BL       set_tomb
   3174              psa_status = PSA_SUCCESS;
   \       0x62   0xE001             B.N      ??psa_its_remove_0
   3175            } else {
   3176              psa_status = PSA_ERROR_STORAGE_FAILURE;
   \                     ??psa_its_remove_1: (+1)
   \       0x64   0xF06F 0x0491      MVN      R4,#+145
   3177            }
   3178          
   3179            exit:
   3180            sli_its_release_mutex();
   \                     ??psa_its_remove_0: (+1)
   \       0x68   0x.... 0x....      BL       sli_its_release_mutex
   3181            return psa_status;
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0xB00A             ADD      SP,SP,#+40
   \       0x70   0xBD70             POP      {R4-R6,PC}
   3182          }
   3183          
   3184          // -------------------------------------
   3185          // Silicon Labs extensions
   3186          
   3187          static psa_storage_uid_t psa_its_identifier_of_slot(mbedtls_svc_key_id_t key)
   3188          {
   3189          #if defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
   3190            /* Encode the owner in the upper 32 bits. This means that if
   3191             * owner values are nonzero (as they are on a PSA platform),
   3192             * no key file will ever have a value less than 0x100000000, so
   3193             * the whole range 0..0xffffffff is available for non-key files. */
   3194            uint32_t unsigned_owner_id = MBEDTLS_SVC_KEY_ID_GET_OWNER_ID(key);
   3195            return ((uint64_t) unsigned_owner_id << 32) | MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
   3196          #else
   3197            /* Use the key id directly as a file name.
   3198             * psa_is_key_id_valid() in psa_crypto_slot_management.c
   3199             * is responsible for ensuring that key identifiers do not have a
   3200             * value that is reserved for non-key files. */
   3201            return key;
   3202          #endif
   3203          }
   3204          

   \                                 In section .text, align 2, keep-with-next
   3205          psa_status_t sli_psa_its_change_key_id(mbedtls_svc_key_id_t old_id,
   3206                                                 mbedtls_svc_key_id_t new_id)
   3207          {
   \                     sli_psa_its_change_key_id: (+1)
   \        0x0   0xE92D 0x41D0      PUSH     {R4,R6-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   3208            psa_storage_uid_t old_uid = psa_its_identifier_of_slot(old_id);
   3209            psa_storage_uid_t new_uid = psa_its_identifier_of_slot(new_id);
   3210            size_t its_file_size = 0;
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x9202             STR      R2,[SP, #+8]
   3211            psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   3212            if (old_id == new_id) {
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBF08             IT       EQ
   \       0x12   0x2000             MOVEQ    R0,#+0
   3213              return PSA_SUCCESS;
   \       0x14   0xD031             BEQ.N    ??sli_psa_its_change_key_id_0
   3214            }
   3215            // Check whether the key to migrate exists on disk
   3216            struct psa_storage_info_t p_info;
   3217            status = psa_its_get_info(old_uid, &p_info);
   \       0x16   0xAA03             ADD      R2,SP,#+12
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x.... 0x....      BL       psa_its_get_info
   3218            if (status != PSA_SUCCESS) {
   \       0x1E   0xBB60             CBNZ.N   R0,??sli_psa_its_change_key_id_0
   3219              return status;
   3220            }
   3221          
   3222            // Allocate temporary buffer and cast it to the metadata format
   3223            uint8_t *its_file_buffer = mbedtls_calloc(1, p_info.size);
   \       0x20   0x9903             LDR      R1,[SP, #+12]
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x.... 0x....      BL       sl_calloc
   \       0x28   0x0007             MOVS     R7,R0
   3224            if (its_file_buffer == NULL) {
   \       0x2A   0xBF08             IT       EQ
   \       0x2C   0xF06F 0x008C      MVNEQ    R0,#+140
   3225              return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x30   0xD023             BEQ.N    ??sli_psa_its_change_key_id_0
   3226            }
   3227            // Read contents of pre-existing key into the temporary buffer
   3228            status = psa_its_get(old_uid, 0, p_info.size, its_file_buffer,
   3229                                 &its_file_size);
   \       0x32   0xA802             ADD      R0,SP,#+8
   \       0x34   0x9001             STR      R0,[SP, #+4]
   \       0x36   0x9700             STR      R7,[SP, #+0]
   \       0x38   0x9B03             LDR      R3,[SP, #+12]
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x.... 0x....      BL       psa_its_get
   \       0x44   0xEA5F 0x0800      MOVS     R8,R0
   3230          
   3231            if (status != PSA_SUCCESS) {
   \       0x48   0xD10F             BNE.N    ??sli_psa_its_change_key_id_1
   3232              goto exit;
   3233            }
   3234          
   3235            status = psa_its_set(new_uid, its_file_size, its_file_buffer,
   3236                                 p_info.flags);
   \       0x4A   0x9804             LDR      R0,[SP, #+16]
   \       0x4C   0x9A02             LDR      R2,[SP, #+8]
   \       0x4E   0x463B             MOV      R3,R7
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x4630             MOV      R0,R6
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x.... 0x....      BL       psa_its_set
   \       0x5A   0xEA5F 0x0800      MOVS     R8,R0
   3237          
   3238            if (status != PSA_SUCCESS) {
   \       0x5E   0xD104             BNE.N    ??sli_psa_its_change_key_id_1
   3239              goto exit;
   3240            }
   3241          
   3242            status = psa_its_remove(old_uid);
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x.... 0x....      BL       psa_its_remove
   \       0x68   0x4680             MOV      R8,R0
   3243          
   3244            if (status != PSA_SUCCESS) {
   3245              goto exit;
   3246            }
   3247          
   3248            exit:
   3249            // Clear and free key buffer before return.
   3250            memset(its_file_buffer, 0, its_file_size);
   \                     ??sli_psa_its_change_key_id_1: (+1)
   \       0x6A   0x9902             LDR      R1,[SP, #+8]
   \       0x6C   0x4638             MOV      R0,R7
   \       0x6E   0x.... 0x....      BL       __aeabi_memclr
   3251            mbedtls_free(its_file_buffer);
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0x.... 0x....      BL       sl_free
   3252            return status;
   \       0x78   0x4640             MOV      R0,R8
   \                     ??sli_psa_its_change_key_id_0: (+1)
   \       0x7A   0xB005             ADD      SP,SP,#+20
   \       0x7C   0xE8BD 0x81D0      POP      {R4,R6-R8,PC}
   3253          }
   3254          
   3255          /**
   3256           * \brief Check if the ITS encryption is enabled
   3257           */

   \                                 In section .text, align 2, keep-with-next
   3258          psa_status_t sli_psa_its_encrypted(void)
   3259          {
   3260          #if defined(SLI_PSA_ITS_ENCRYPTED)
   3261            return PSA_SUCCESS;
   3262          #else
   3263            return PSA_ERROR_NOT_SUPPORTED;
   \                     sli_psa_its_encrypted: (+1)
   \        0x0   0xF06F 0x0085      MVN      R0,#+133
   \        0x4   0x4770             BX       LR
   3264          #endif
   3265          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     its_mutex_inited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     mbedtls_mutex_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     mbedtls_mutex_lock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x....'....        DC32     mbedtls_mutex_unlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0xFFF7'9300        DC32     0xfff79300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x....'....        DC32     nvm3_uid_set_cache_initialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \        0x0   0xFFF7'9301        DC32     0xfff79301

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \        0x0   0x0008'6D00        DC32     0x86d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \        0x0   0x....'....        DC32     nvm3_defaultHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \        0x0   0x0008'7100        DC32     0x87100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \        0x0   0x5E17'5D10        DC32     0x5e175d10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \        0x0   0xF000'DFFF        DC32     0xf000dfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \        0x0   0xF000'E011        DC32     0xf000e011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \        0x0   0xF000'DFFE        DC32     0xf000dffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \        0x0   0x2004'0000        DC32     0x20040000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x73          DC8 0x5C, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74
   \              0x65 0x63    
   \              0x75 0x72    
   \              0x69 0x74
   \       0x58   0x79 0x5C          DC8 0x79, 0x5C, 0x73, 0x6C, 0x5F, 0x63, 0x6F, 0x6D
   \              0x73 0x6C    
   \              0x5F 0x63    
   \              0x6F 0x6D
   \       0x60   0x70 0x6F          DC8 0x70, 0x6F, 0x6E, 0x65, 0x6E, 0x74, 0x5C, 0x73
   \              0x6E 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73
   \       0x68   0x6C 0x5F          DC8 0x6C, 0x5F, 0x70, 0x73, 0x61, 0x5F, 0x64, 0x72
   \              0x70 0x73    
   \              0x61 0x5F    
   \              0x64 0x72
   \       0x70   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x5C, 0x73, 0x72, 0x63
   \              0x65 0x72    
   \              0x5C 0x73    
   \              0x72 0x63
   \       0x78   0x5C 0x73          DC8 0x5C, 0x73, 0x6C, 0x5F, 0x70, 0x73, 0x61, 0x5F
   \              0x6C 0x5F    
   \              0x70 0x73    
   \              0x61 0x5F
   \       0x80   0x69 0x74          DC8 0x69, 0x74, 0x73, 0x5F, 0x6E, 0x76, 0x6D, 0x33
   \              0x73 0x5F    
   \              0x6E 0x76    
   \              0x6D 0x33
   \       0x88   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x8B                      DS8 1
   3266          
   3267          #if defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   3268          /**
   3269           * \brief Set the root key to be used when deriving session keys for ITS encryption.
   3270           *
   3271           * \param[in] root_key        Buffer containing the root key.
   3272           * \param[in] root_key_size   Size of the root key in bytes. Must be 32 (256 bits).
   3273           *
   3274           * \return  A status indicating the success/failure of the operation
   3275           *
   3276           * \retval      PSA_SUCCESS                  The key was successfully set.
   3277           * \retval      PSA_ERROR_INVALID_ARGUMENT   The root key was NULL or had an invalid size.
   3278           * \retval      PSA_ERROR_ALREADY_EXISTS     The root key has already been initialized.
   3279           */
   3280          psa_status_t sli_psa_its_set_root_key(uint8_t *root_key, size_t root_key_size)
   3281          {
   3282            // Check that arguments are valid
   3283            if (root_key == NULL || root_key_size != sizeof(g_root_key.data)) {
   3284              return PSA_ERROR_INVALID_ARGUMENT;
   3285            }
   3286          
   3287            // Check that the root key has not already been set
   3288            // (This is possibly too restrictive. For TrustZone usage this can be enforced by
   3289            // not exposing the function to NS instead.)
   3290            if (g_root_key.initialized) {
   3291              return PSA_ERROR_ALREADY_EXISTS;
   3292            }
   3293          
   3294            // Store the provided root key and mark it as initialized
   3295            memcpy(g_root_key.data, root_key, sizeof(g_root_key.data));
   3296            g_root_key.initialized = true;
   3297          
   3298            return PSA_SUCCESS;
   3299          }
   3300          #endif // defined(SLI_PSA_ITS_ENCRYPTED) && !defined(SEMAILBOX_PRESENT)
   3301          #endif // (!SL_PSA_ITS_SUPPORT_V3_DRIVER)
   3302          #endif // MBEDTLS_PSA_CRYPTO_STORAGE_C && !MBEDTLS_PSA_ITS_FILE_C

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     176   find_nvm3_id
       176   -> __aeabi_memclr4
       176   -> get_index
       176   -> get_offset
       176   -> increment_obj_id
       176   -> nvm3_deleteObject
       176   -> nvm3_enumDeletedObjects
       176   -> nvm3_enumObjects
       176   -> nvm3_getObjectInfo
       176   -> nvm3_initDefault
       176   -> nvm3_readPartialData
       176   -> set_cache
       176   -> set_tomb
       0   get_index
       0   get_offset
       0   increment_obj_id
      80   psa_its_get
        80   -> find_nvm3_id
        80   -> nvm3_readPartialData
        80   -> sli_its_acquire_mutex
        80   -> sli_its_release_mutex
      64   psa_its_get_info
        64   -> find_nvm3_id
        64   -> sli_its_acquire_mutex
        64   -> sli_its_release_mutex
      56   psa_its_remove
        56   -> find_nvm3_id
        56   -> nvm3_deleteObject
        56   -> set_tomb
        56   -> sli_its_acquire_mutex
        56   -> sli_its_release_mutex
      56   psa_its_set
        56   -> __aeabi_memclr
        56   -> __aeabi_memcpy
        56   -> find_nvm3_id
        56   -> nvm3_writeData
        56   -> set_cache
        56   -> sl_calloc
        56   -> sl_free
        56   -> sli_its_acquire_mutex
        56   -> sli_its_release_mutex
      24   set_cache
        24   -> get_index
        24   -> get_offset
       8   set_tomb
         0   -> __aeabi_memclr
      16   sli_its_acquire_mutex
        16   -- Indirect call
         0   -> assertEFM
        16   -> assertEFM
        16   -> osKernelGetState
        16   -> osKernelLock
        16   -> osKernelRestoreLock
       0   sli_its_release_mutex
         0   -- Indirect call
      40   sli_psa_its_change_key_id
        40   -> __aeabi_memclr
        40   -> psa_its_get
        40   -> psa_its_get_info
        40   -> psa_its_remove
        40   -> psa_its_set
        40   -> sl_calloc
        40   -> sl_free
       0   sli_psa_its_encrypted


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?Subroutine0
      16  ?Subroutine1
      10  ?Subroutine2
     140  ?_0
     526  find_nvm3_id
      10  get_index
       6  get_offset
      28  increment_obj_id
     104  its_mutex_inited
          its_mutex
      44  nvm3_uid_set_cache_initialized
          nvm3_uid_set_cache
          nvm3_uid_tomb_cache
     170  psa_its_get
      76  psa_its_get_info
     114  psa_its_remove
     210  psa_its_set
      66  set_cache
      64  set_tomb
     108  sli_its_acquire_mutex
      20  sli_its_release_mutex
     128  sli_psa_its_change_key_id
       6  sli_psa_its_encrypted

 
   148 bytes in section .bss
   140 bytes in section .rodata
 1'634 bytes in section .text
 
 1'634 bytes of CODE  memory
   140 bytes of CONST memory
   148 bytes of DATA  memory

Errors: none
Warnings: none
