###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:09
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_transparent_driver_mac.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_transparent_driver_mac.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_transparent_driver_mac.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_transparent_driver_mac.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sli_se_transparent_driver_mac.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_transparent_driver_mac.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_transparent_driver_mac.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Transparent Driver Mac functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"
     36          
     37          #include "sli_se_transparent_types.h"
     38          #include "sli_se_transparent_functions.h"
     39          #include "sli_psa_driver_common.h"
     40          
     41          #include <string.h>
     42          
     43          //------------------------------------------------------------------------------
     44          // Static asserts
     45          
     46          // Make sure that the two locations of 'alg' are in the same place, since we
     47          // access them interchangeably.
     48          #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
     49          _Static_assert(offsetof(sli_se_transparent_mac_operation_t, hmac.alg)
     50                         == offsetof(sli_se_transparent_mac_operation_t,
     51                                     cipher_mac.operation.alg),
     52                         "hmac.alg and cipher_mac.oepration.alg are not aliases");
     53          #endif // SLI_PSA_DRIVER_FEATURE_MAC
     54          
     55          //------------------------------------------------------------------------------
     56          // Static functions
     57          
     58          #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
     59          
     60          static psa_status_t sli_se_transparent_driver_symmetric_key_from_context(
     61            sl_se_key_descriptor_t* key_desc,
     62            sli_se_transparent_mac_operation_t* operation)
     63          {
     64            // Point to transparent key buffer as storage location
     65            key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
     66            key_desc->storage.location.buffer.pointer = operation->cipher_mac.key;
     67            key_desc->storage.location.buffer.size = sizeof(operation->cipher_mac.key);
     68            key_desc->size = operation->cipher_mac.key_len;
     69          
     70            switch (PSA_ALG_FULL_LENGTH_MAC(operation->cipher_mac.operation.alg)) {
     71              case PSA_ALG_CBC_MAC:
     72              case PSA_ALG_CMAC:
     73                if (key_desc->size == 16) {
     74                  key_desc->type = SL_SE_KEY_TYPE_AES_128;
     75                } else if (key_desc->size == 24) {
     76                  key_desc->type = SL_SE_KEY_TYPE_AES_192;
     77                } else if (key_desc->size == 32) {
     78                  key_desc->type = SL_SE_KEY_TYPE_AES_256;
     79                } else {
     80                  return PSA_ERROR_BAD_STATE;
     81                }
     82                break;
     83              default:
     84                return PSA_ERROR_BAD_STATE;
     85            }
     86          
     87            return PSA_SUCCESS;
     88          }
     89          
     90          #endif // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
     91          
     92          #if defined(SLI_PSA_DRIVER_FEATURE_MAC)
     93          
     94          static psa_status_t sli_se_transparent_driver_symmetric_key_from_psa(
     95            sl_se_key_descriptor_t* key_desc,
     96            const psa_key_attributes_t *attributes,
     97            const uint8_t *key_buffer,
     98            size_t key_buffer_size)
     99          {
    100            // Point to transparent key buffer as storage location
    101            key_desc->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
    102            key_desc->storage.location.buffer.pointer = (uint8_t *)key_buffer;
    103            key_desc->storage.location.buffer.size = key_buffer_size;
    104          
    105            // Verify and set key attributes
    106            psa_key_type_t keytype = psa_get_key_type(attributes);
    107          
    108            switch (keytype) {
    109              #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    110              case PSA_KEY_TYPE_AES: {
    111                switch (psa_get_key_bits(attributes)) {
    112                  case 128:
    113                    key_desc->size = 16;
    114                    key_desc->type = SL_SE_KEY_TYPE_AES_128;
    115                    break;
    116                  case 192:
    117                    key_desc->size = 24;
    118                    key_desc->type = SL_SE_KEY_TYPE_AES_192;
    119                    break;
    120                  case 256:
    121                    key_desc->size = 32;
    122                    key_desc->type = SL_SE_KEY_TYPE_AES_256;
    123                    break;
    124                  default:
    125                    return PSA_ERROR_NOT_SUPPORTED;
    126                }
    127                break;
    128              }
    129              #endif // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    130          
    131              #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    132              case PSA_KEY_TYPE_HMAC: {
    133                key_desc->size = psa_get_key_bits(attributes) / 8;
    134                key_desc->type = SL_SE_KEY_TYPE_SYMMETRIC;
    135                break;
    136              }
    137              #endif // SLI_PSA_DRIVER_FEATURE_HMAC
    138          
    139              default:
    140                return PSA_ERROR_INVALID_ARGUMENT;
    141                break;
    142            }
    143          
    144            if (key_buffer_size < key_desc->size) {
    145              return PSA_ERROR_INVALID_ARGUMENT;
    146            }
    147          
    148            return PSA_SUCCESS;
    149          }
    150          
    151          #endif // SLI_PSA_DRIVER_FEATURE_MAC
    152          
    153          //------------------------------------------------------------------------------
    154          // Single-shot driver entry points
    155          

   \                                 In section .text, align 2, keep-with-next
    156          psa_status_t sli_se_transparent_mac_compute(
    157            const psa_key_attributes_t *attributes,
    158            const uint8_t *key_buffer,
    159            size_t key_buffer_size,
    160            psa_algorithm_t alg,
    161            const uint8_t *input,
    162            size_t input_length,
    163            uint8_t *mac,
    164            size_t mac_size,
    165            size_t *mac_length)
    166          {
   \                     sli_se_transparent_mac_compute: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x4699             MOV      R9,R3
    167            #if defined(SLI_PSA_DRIVER_FEATURE_MAC)
    168          
    169            if (key_buffer == NULL
    170                || attributes == NULL) {
   \        0xE   0xF06F 0x0886      MVN      R8,#+134
   \       0x12   0xBF18             IT       NE
   \       0x14   0x2C00             CMPNE    R4,#+0
   \       0x16   0xD01F             BEQ.N    ??sli_se_transparent_mac_compute_0
    171              return PSA_ERROR_INVALID_ARGUMENT;
    172            }
    173          
    174            // Ephemeral contexts
    175            sl_se_key_descriptor_t key_desc = { 0 };
   \       0x18   0xA803             ADD      R0,SP,#+12
   \       0x1A   0x2120             MOVS     R1,#+32
   \       0x1C   0x.... 0x....      BL       __aeabi_memclr4
    176            psa_status_t psa_status
    177              = sli_se_transparent_driver_symmetric_key_from_psa(&key_desc,
    178                                                                 attributes,
    179                                                                 key_buffer,
    180                                                                 key_buffer_size);
   \       0x20   0x2700             MOVS     R7,#+0
   \       0x22   0x9706             STR      R7,[SP, #+24]
   \       0x24   0x9507             STR      R5,[SP, #+28]
   \       0x26   0x9608             STR      R6,[SP, #+32]
   \       0x28   0x8821             LDRH     R1,[R4, #+0]
   \       0x2A   0xF5B1 0x5F88      CMP      R1,#+4352
   \       0x2E   0xD113             BNE.N    ??sli_se_transparent_mac_compute_0
   \       0x30   0x8861             LDRH     R1,[R4, #+2]
   \       0x32   0x08C9             LSRS     R1,R1,#+3
   \       0x34   0x9104             STR      R1,[SP, #+16]
   \       0x36   0x9703             STR      R7,[SP, #+12]
   \       0x38   0x9804             LDR      R0,[SP, #+16]
   \       0x3A   0x4286             CMP      R6,R0
   \       0x3C   0xD30C             BCC.N    ??sli_se_transparent_mac_compute_0
    181            if (psa_status != PSA_SUCCESS) {
    182              return psa_status;
    183            }
    184          
    185            return sli_se_driver_mac_compute(&key_desc,
    186                                             alg,
    187                                             input,
    188                                             input_length,
    189                                             mac,
    190                                             mac_size,
    191                                             mac_length);
   \       0x3E   0x9816             LDR      R0,[SP, #+88]
   \       0x40   0x9915             LDR      R1,[SP, #+84]
   \       0x42   0x9B13             LDR      R3,[SP, #+76]
   \       0x44   0x9002             STR      R0,[SP, #+8]
   \       0x46   0x9814             LDR      R0,[SP, #+80]
   \       0x48   0x9A12             LDR      R2,[SP, #+72]
   \       0x4A   0x9101             STR      R1,[SP, #+4]
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x4649             MOV      R1,R9
   \       0x50   0xA803             ADD      R0,SP,#+12
   \       0x52   0x.... 0x....      BL       sli_se_driver_mac_compute
   \       0x56   0xE000             B.N      ??sli_se_transparent_mac_compute_1
   \                     ??sli_se_transparent_mac_compute_0: (+1)
   \       0x58   0x4640             MOV      R0,R8
   \                     ??sli_se_transparent_mac_compute_1: (+1)
   \       0x5A   0xB00B             ADD      SP,SP,#+44
   \       0x5C   0xE8BD 0x83F0      POP      {R4-R9,PC}
    192          
    193            #else // SLI_PSA_DRIVER_FEATURE_MAC
    194          
    195            (void)attributes;
    196            (void)key_buffer;
    197            (void)key_buffer_size;
    198            (void)alg;
    199            (void)input;
    200            (void)input_length;
    201            (void)mac;
    202            (void)mac_size;
    203            (void)mac_length;
    204          
    205            return PSA_ERROR_NOT_SUPPORTED;
    206          
    207            #endif // SLI_PSA_DRIVER_FEATURE_MAC
    208          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    209          
    210          //------------------------------------------------------------------------------
    211          // Multi-part driver entry points
    212          

   \                                 In section .text, align 2, keep-with-next
    213          psa_status_t sli_se_transparent_mac_sign_setup(
    214            sli_se_transparent_mac_operation_t *operation,
    215            const psa_key_attributes_t *attributes,
    216            const uint8_t *key_buffer,
    217            size_t key_buffer_size,
    218            psa_algorithm_t alg)
    219          {
   \                     sli_se_transparent_mac_sign_setup: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460F             MOV      R7,R1
    220            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    221          
    222            if (operation == NULL
    223                || attributes == NULL
    224                || (key_buffer == NULL && key_buffer_size > 0)) {
   \        0x8   0xBF18             IT       NE
   \        0xA   0x2F00             CMPNE    R7,#+0
   \        0xC   0xD061             BEQ.N    ??sli_se_transparent_mac_sign_setup_0
   \        0xE   0xEA5F 0x0B02      MOVS     R11,R2
   \       0x12   0x461D             MOV      R5,R3
   \       0x14   0xD101             BNE.N    ??sli_se_transparent_mac_sign_setup_1
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD15B             BNE.N    ??sli_se_transparent_mac_sign_setup_0
   \                     ??sli_se_transparent_mac_sign_setup_1: (+1)
   \       0x1A   0x9E0C             LDR      R6,[SP, #+48]
    225              return PSA_ERROR_INVALID_ARGUMENT;
    226            }
    227          
    228            psa_status_t status;
    229          
    230            // start by resetting context
    231            memset(operation, 0, sizeof(*operation));
   \       0x1C   0xF44F 0x71AE      MOV      R1,#+348
   \       0x20   0x.... 0x....      BL       __aeabi_memclr4
    232          
    233            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    234            if (PSA_ALG_IS_HMAC(alg)) {
   \       0x24   0x....             LDR.N    R2,??DataTable4
   \       0x26   0x4032             ANDS     R2,R2,R6
   \       0x28   0xF1B2 0x7F60      CMP      R2,#+58720256
   \       0x2C   0xF040 0x808B      BNE.W    ??sli_se_transparent_mac_sign_setup_2
    235              // SE does not support multipart HMAC. Construct it from hashing instead.
    236              // Check key type and output size
    237              if (psa_get_key_type(attributes) != PSA_KEY_TYPE_HMAC) {
   \       0x30   0x8838             LDRH     R0,[R7, #+0]
   \       0x32   0xF5B0 0x5F88      CMP      R0,#+4352
   \       0x36   0xD14C             BNE.N    ??sli_se_transparent_mac_sign_setup_0
    238                // For HMAC, key type is strictly enforced
    239                return PSA_ERROR_INVALID_ARGUMENT;
    240              }
    241          
    242              psa_algorithm_t hash_alg = PSA_ALG_HMAC_GET_HASH(alg);
   \       0x38   0xF006 0x00FF      AND      R0,R6,#0xFF
   \       0x3C   0xF040 0x7800      ORR      R8,R0,#0x2000000
    243              size_t digest_len = PSA_HASH_LENGTH(hash_alg);
   \       0x40   0x....             LDR.N    R0,??DataTable4_1
   \       0x42   0x.... 0x....      LDR.W    R9,??DataTable4_2
   \       0x46   0x.... 0x....      LDR.W    R10,??DataTable4_3
   \       0x4A   0x4580             CMP      R8,R0
   \       0x4C   0xBF08             IT       EQ
   \       0x4E   0x2010             MOVEQ    R0,#+16
   \       0x50   0xD02B             BEQ.N    ??sli_se_transparent_mac_sign_setup_3
   \       0x52   0x....             LDR.N    R1,??DataTable4_4
   \       0x54   0x4588             CMP      R8,R1
   \       0x56   0xBF1A             ITTE     NE
   \       0x58   0x....             LDRNE.N  R0,??DataTable4_5
   \       0x5A   0x4580             CMPNE    R8,R0
   \       0x5C   0x2014             MOVEQ    R0,#+20
   \       0x5E   0xD024             BEQ.N    ??sli_se_transparent_mac_sign_setup_3
   \       0x60   0x....             LDR.N    R1,??DataTable4_6
   \       0x62   0x4588             CMP      R8,R1
   \       0x64   0xD00F             BEQ.N    ??sli_se_transparent_mac_sign_setup_4
   \       0x66   0x....             LDR.N    R0,??DataTable4_7
   \       0x68   0x4580             CMP      R8,R0
   \       0x6A   0xD011             BEQ.N    ??sli_se_transparent_mac_sign_setup_5
   \       0x6C   0x45D0             CMP      R8,R10
   \       0x6E   0xD014             BEQ.N    ??sli_se_transparent_mac_sign_setup_6
   \       0x70   0x45C8             CMP      R8,R9
   \       0x72   0xD017             BEQ.N    ??sli_se_transparent_mac_sign_setup_7
   \       0x74   0x....             LDR.N    R0,??DataTable4_8
   \       0x76   0x4580             CMP      R8,R0
   \       0x78   0xD005             BEQ.N    ??sli_se_transparent_mac_sign_setup_4
   \       0x7A   0x....             LDR.N    R1,??DataTable4_9
   \       0x7C   0x4588             CMP      R8,R1
   \       0x7E   0xD007             BEQ.N    ??sli_se_transparent_mac_sign_setup_5
   \       0x80   0x....             LDR.N    R0,??DataTable4_10
   \       0x82   0x4580             CMP      R8,R0
   \       0x84   0xD101             BNE.N    ??sli_se_transparent_mac_sign_setup_8
   \                     ??sli_se_transparent_mac_sign_setup_4: (+1)
   \       0x86   0x201C             MOVS     R0,#+28
   \       0x88   0xE00F             B.N      ??sli_se_transparent_mac_sign_setup_3
   \                     ??sli_se_transparent_mac_sign_setup_8: (+1)
   \       0x8A   0x....             LDR.N    R0,??DataTable4_11
   \       0x8C   0x4580             CMP      R8,R0
   \       0x8E   0xD101             BNE.N    ??sli_se_transparent_mac_sign_setup_9
   \                     ??sli_se_transparent_mac_sign_setup_5: (+1)
   \       0x90   0x2020             MOVS     R0,#+32
   \       0x92   0xE00A             B.N      ??sli_se_transparent_mac_sign_setup_3
   \                     ??sli_se_transparent_mac_sign_setup_9: (+1)
   \       0x94   0x....             LDR.N    R0,??DataTable4_12
   \       0x96   0x4580             CMP      R8,R0
   \       0x98   0xD101             BNE.N    ??sli_se_transparent_mac_sign_setup_10
   \                     ??sli_se_transparent_mac_sign_setup_6: (+1)
   \       0x9A   0x2030             MOVS     R0,#+48
   \       0x9C   0xE005             B.N      ??sli_se_transparent_mac_sign_setup_3
   \                     ??sli_se_transparent_mac_sign_setup_10: (+1)
   \       0x9E   0x....             LDR.N    R0,??DataTable4_13
   \       0xA0   0x4580             CMP      R8,R0
   \       0xA2   0xD101             BNE.N    ??sli_se_transparent_mac_sign_setup_11
   \                     ??sli_se_transparent_mac_sign_setup_7: (+1)
   \       0xA4   0x2040             MOVS     R0,#+64
   \       0xA6   0xE000             B.N      ??sli_se_transparent_mac_sign_setup_3
   \                     ??sli_se_transparent_mac_sign_setup_11: (+1)
   \       0xA8   0x2000             MOVS     R0,#+0
    244          
    245              if (PSA_MAC_TRUNCATED_LENGTH(alg) > digest_len) {
   \                     ??sli_se_transparent_mac_sign_setup_3: (+1)
   \       0xAA   0xF3C6 0x4105      UBFX     R1,R6,#+16,#+6
   \       0xAE   0x4288             CMP      R0,R1
   \       0xB0   0xD30F             BCC.N    ??sli_se_transparent_mac_sign_setup_0
    246                return PSA_ERROR_INVALID_ARGUMENT;
    247              }
    248          
    249              // Setup the hash accumulator first, such that we can return early for non-
    250              // supported hash functions and avoid potentially overflowing buffer lengths.
    251              status = sli_se_transparent_hash_setup(&operation->hmac.hash_ctx,
    252                                                     hash_alg);
   \       0xB2   0x4641             MOV      R1,R8
   \       0xB4   0x1D20             ADDS     R0,R4,#+4
   \       0xB6   0x.... 0x....      BL       sli_se_transparent_hash_setup
    253              if (status != PSA_SUCCESS) {
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD145             BNE.N    ??sli_se_transparent_mac_sign_setup_12
    254                return status;
    255              }
    256          
    257              size_t keylen = psa_get_key_bits(attributes) / 8;
   \       0xBE   0x8878             LDRH     R0,[R7, #+2]
   \       0xC0   0x08C0             LSRS     R0,R0,#+3
   \       0xC2   0x9002             STR      R0,[SP, #+8]
    258              size_t blocklen
    259                = (hash_alg == PSA_ALG_SHA_384 || hash_alg == PSA_ALG_SHA_512) ? 128 : 64;
   \       0xC4   0x45D0             CMP      R8,R10
   \       0xC6   0xBF16             ITET     NE
   \       0xC8   0x45C8             CMPNE    R8,R9
   \       0xCA   0x2780             MOVEQ    R7,#+128
   \       0xCC   0x2740             MOVNE    R7,#+64
    260          
    261              if (key_buffer_size < keylen) {
   \       0xCE   0x4285             CMP      R5,R0
   \       0xD0   0xD202             BCS.N    ??sli_se_transparent_mac_sign_setup_13
    262                return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_sign_setup_0: (+1)
   \       0xD2   0xF06F 0x0086      MVN      R0,#+134
   \       0xD6   0xE038             B.N      ??sli_se_transparent_mac_sign_setup_12
    263              }
    264          
    265              // Reduce the key if larger than a block
    266              if (keylen > blocklen) {
   \                     ??sli_se_transparent_mac_sign_setup_13: (+1)
   \       0xD8   0xF104 0x05DC      ADD      R5,R4,#+220
   \       0xDC   0x4287             CMP      R7,R0
   \       0xDE   0xD20B             BCS.N    ??sli_se_transparent_mac_sign_setup_14
    267                status = sli_se_transparent_hash_compute(
    268                  hash_alg,
    269                  key_buffer,
    270                  keylen,
    271                  operation->hmac.opad,
    272                  sizeof(operation->hmac.opad),
    273                  &keylen);
   \       0xE0   0x2280             MOVS     R2,#+128
   \       0xE2   0x9200             STR      R2,[SP, #+0]
   \       0xE4   0xA902             ADD      R1,SP,#+8
   \       0xE6   0x9A02             LDR      R2,[SP, #+8]
   \       0xE8   0x9101             STR      R1,[SP, #+4]
   \       0xEA   0x462B             MOV      R3,R5
   \       0xEC   0x4659             MOV      R1,R11
   \       0xEE   0x4640             MOV      R0,R8
   \       0xF0   0x.... 0x....      BL       sli_se_transparent_hash_compute
    274                if (status != PSA_SUCCESS) {
   \       0xF4   0xBB48             CBNZ.N   R0,??sli_se_transparent_mac_sign_setup_12
   \       0xF6   0xE005             B.N      ??sli_se_transparent_mac_sign_setup_15
    275                  return status;
    276                }
    277              } else if (keylen > 0) {
   \                     ??sli_se_transparent_mac_sign_setup_14: (+1)
   \       0xF8   0xB120             CBZ.N    R0,??sli_se_transparent_mac_sign_setup_15
    278                memcpy(operation->hmac.opad, key_buffer, keylen);
   \       0xFA   0x4602             MOV      R2,R0
   \       0xFC   0x4659             MOV      R1,R11
   \       0xFE   0x4628             MOV      R0,R5
   \      0x100   0x.... 0x....      BL       __aeabi_memcpy
    279              }
    280          
    281              // Calculate inner padding in opad buffer and start a multipart hash with it
    282              for (size_t i = 0; i < keylen; i++) {
   \                     ??sli_se_transparent_mac_sign_setup_15: (+1)
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0xE004             B.N      ??sli_se_transparent_mac_sign_setup_16
    283                operation->hmac.opad[i] ^= 0x36;
   \                     ??sli_se_transparent_mac_sign_setup_17: (+1)
   \      0x108   0x5C29             LDRB     R1,[R5, R0]
   \      0x10A   0xF081 0x0136      EOR      R1,R1,#0x36
   \      0x10E   0x5429             STRB     R1,[R5, R0]
    284              }
   \      0x110   0x1C40             ADDS     R0,R0,#+1
   \                     ??sli_se_transparent_mac_sign_setup_16: (+1)
   \      0x112   0x9902             LDR      R1,[SP, #+8]
   \      0x114   0x4288             CMP      R0,R1
   \      0x116   0xD3F7             BCC.N    ??sli_se_transparent_mac_sign_setup_17
    285              memset(&operation->hmac.opad[keylen], 0x36, blocklen - keylen);
   \      0x118   0x9802             LDR      R0,[SP, #+8]
   \      0x11A   0x2236             MOVS     R2,#+54
   \      0x11C   0x1A79             SUBS     R1,R7,R1
   \      0x11E   0x4428             ADD      R0,R5,R0
   \      0x120   0x.... 0x....      BL       __aeabi_memset
    286          
    287              status = sli_se_transparent_hash_update(
    288                &operation->hmac.hash_ctx,
    289                operation->hmac.opad, blocklen);
   \      0x124   0x463A             MOV      R2,R7
   \      0x126   0x4629             MOV      R1,R5
   \      0x128   0x1D20             ADDS     R0,R4,#+4
   \      0x12A   0x.... 0x....      BL       sli_se_transparent_hash_update
    290              if (status != PSA_SUCCESS) {
   \      0x12E   0xB960             CBNZ.N   R0,??sli_se_transparent_mac_sign_setup_12
    291                return status;
    292              }
    293          
    294              // Calculate outer padding and store it for finalisation
    295              for (size_t i = 0; i < blocklen; i++) {
   \      0x130   0xE004             B.N      ??sli_se_transparent_mac_sign_setup_18
    296                operation->hmac.opad[i] ^= 0x36 ^ 0x5C;
   \                     ??sli_se_transparent_mac_sign_setup_19: (+1)
   \      0x132   0x5C29             LDRB     R1,[R5, R0]
   \      0x134   0xF081 0x016A      EOR      R1,R1,#0x6A
   \      0x138   0x5429             STRB     R1,[R5, R0]
    297              }
   \      0x13A   0x1C40             ADDS     R0,R0,#+1
   \                     ??sli_se_transparent_mac_sign_setup_18: (+1)
   \      0x13C   0x42B8             CMP      R0,R7
   \      0x13E   0xD3F8             BCC.N    ??sli_se_transparent_mac_sign_setup_19
    298          
    299              operation->hmac.alg = alg;
   \      0x140   0x6026             STR      R6,[R4, #+0]
    300              return PSA_SUCCESS;
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0xE001             B.N      ??sli_se_transparent_mac_sign_setup_12
    301            }
    302            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    303          
    304            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    305            status = sli_se_driver_mac_sign_setup(&(operation->cipher_mac.operation),
    306                                                  attributes,
    307                                                  alg);
    308            if (status != PSA_SUCCESS) {
    309              return status;
    310            }
    311          
    312            operation->cipher_mac.key_len = psa_get_key_bits(attributes) / 8;
    313            switch (operation->cipher_mac.key_len) {
    314              case 16:
    315                if (key_buffer_size < 16) {
    316                  return PSA_ERROR_INVALID_ARGUMENT;
    317                }
    318                memcpy(operation->cipher_mac.key, key_buffer, 16);
    319                break;
    320              case 24:
    321                if (key_buffer_size < 24) {
    322                  return PSA_ERROR_INVALID_ARGUMENT;
    323                }
    324                memcpy(operation->cipher_mac.key, key_buffer, 24);
    325                break;
    326              case 32:
    327                if (key_buffer_size < 32) {
    328                  return PSA_ERROR_INVALID_ARGUMENT;
    329                }
    330                memcpy(operation->cipher_mac.key, key_buffer, 32);
    331                break;
    332              default:
    333                return PSA_ERROR_INVALID_ARGUMENT;
    334            }
    335          
    336            return PSA_SUCCESS;
    337            #else   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    338            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_mac_sign_setup_2: (+1)
   \      0x146   0xF06F 0x0085      MVN      R0,#+133
   \                     ??sli_se_transparent_mac_sign_setup_12: (+1)
   \      0x14A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    339            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    340          
    341            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    342          
    343            (void)operation;
    344            (void)attributes;
    345            (void)key_buffer;
    346            (void)key_buffer_size;
    347            (void)alg;
    348          
    349            return PSA_ERROR_NOT_SUPPORTED;
    350          
    351            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    352          }
    353          

   \                                 In section .text, align 2, keep-with-next
    354          psa_status_t sli_se_transparent_mac_verify_setup(
    355            sli_se_transparent_mac_operation_t *operation,
    356            const psa_key_attributes_t *attributes,
    357            const uint8_t *key_buffer,
    358            size_t key_buffer_size,
    359            psa_algorithm_t alg)
    360          {
   \                     sli_se_transparent_mac_verify_setup: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    361            // Since the PSA Crypto core exposes the verify functionality of the drivers
    362            // without actually implementing the fallback to 'sign' when the driver
    363            // doesn't support verify, we need to do this ourselves for the time being.
    364            return sli_se_transparent_mac_sign_setup(operation,
    365                                                     attributes,
    366                                                     key_buffer,
    367                                                     key_buffer_size,
    368                                                     alg);
   \        0x2   0x9C04             LDR      R4,[SP, #+16]
   \        0x4   0x9400             STR      R4,[SP, #+0]
   \        0x6   0x.... 0x....      BL       sli_se_transparent_mac_sign_setup
   \        0xA   0xBD16             POP      {R1,R2,R4,PC}
    369          }
    370          

   \                                 In section .text, align 2, keep-with-next
    371          psa_status_t sli_se_transparent_mac_update(
    372            sli_se_transparent_mac_operation_t *operation,
    373            const uint8_t *input,
    374            size_t input_length)
    375          {
   \                     sli_se_transparent_mac_update: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    376            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    377          
    378            if (operation == NULL
    379                || (input == NULL && input_length > 0)) {
   \        0x2   0xB108             CBZ.N    R0,??sli_se_transparent_mac_update_0
   \        0x4   0xB919             CBNZ.N   R1,??sli_se_transparent_mac_update_1
   \        0x6   0xB112             CBZ.N    R2,??sli_se_transparent_mac_update_1
    380              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_update_0: (+1)
   \        0x8   0xF06F 0x0086      MVN      R0,#+134
   \        0xC   0xBD10             POP      {R4,PC}
    381            }
    382          
    383            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    384            if (PSA_ALG_IS_HMAC(operation->hmac.alg)) {
   \                     ??sli_se_transparent_mac_update_1: (+1)
   \        0xE   0x6804             LDR      R4,[R0, #+0]
   \       0x10   0x....             LDR.N    R3,??DataTable4
   \       0x12   0x401C             ANDS     R4,R3,R4
   \       0x14   0xF1B4 0x7F60      CMP      R4,#+58720256
   \       0x18   0xD104             BNE.N    ??sli_se_transparent_mac_update_2
    385              return sli_se_transparent_hash_update(
    386                &operation->hmac.hash_ctx,
    387                input,
    388                input_length);
   \       0x1A   0x1D00             ADDS     R0,R0,#+4
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x.... 0x....      B.W      sli_se_transparent_hash_update
    389            }
    390            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    391          
    392            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    393            // Ephemeral contexts
    394            sl_se_key_descriptor_t key_desc = { 0 };
    395          
    396            psa_status_t psa_status
    397              = sli_se_transparent_driver_symmetric_key_from_context(&key_desc,
    398                                                                     operation);
    399            if (psa_status != PSA_SUCCESS) {
    400              return psa_status;
    401            }
    402          
    403            return sli_se_driver_mac_update(&(operation->cipher_mac.operation),
    404                                            &key_desc,
    405                                            input,
    406                                            input_length);
    407            #else   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    408            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_mac_update_2: (+1)
   \       0x24   0xF06F 0x0085      MVN      R0,#+133
   \       0x28   0xBD10             POP      {R4,PC}
    409            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    410          
    411            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    412          
    413            (void)operation;
    414            (void)input;
    415            (void)input_length;
    416          
    417            return PSA_ERROR_NOT_SUPPORTED;
    418          
    419            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    420          }
    421          

   \                                 In section .text, align 2, keep-with-next
    422          psa_status_t sli_se_transparent_mac_sign_finish(
    423            sli_se_transparent_mac_operation_t *operation,
    424            uint8_t *mac,
    425            size_t mac_size,
    426            size_t *mac_length)
    427          {
   \                     sli_se_transparent_mac_sign_finish: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB0B3             SUB      SP,SP,#+204
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461E             MOV      R6,R3
    428            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    429          
    430            if (operation == NULL
    431                || mac == NULL
    432                || mac_size == 0
    433                || mac_length == NULL) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2C00             CMPNE    R4,#+0
   \       0x12   0xD003             BEQ.N    ??sli_se_transparent_mac_sign_finish_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2E00             CMPNE    R6,#+0
   \       0x1A   0xD102             BNE.N    ??sli_se_transparent_mac_sign_finish_1
    434              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_transparent_mac_sign_finish_0: (+1)
   \       0x1C   0xF06F 0x0086      MVN      R0,#+134
   \       0x20   0xE044             B.N      ??sli_se_transparent_mac_sign_finish_2
    435            }
    436          
    437            #if defined(SLI_PSA_DRIVER_FEATURE_HMAC)
    438            if (PSA_ALG_IS_HMAC(operation->hmac.alg)) {
   \                     ??sli_se_transparent_mac_sign_finish_1: (+1)
   \       0x22   0x6839             LDR      R1,[R7, #+0]
   \       0x24   0x....             LDR.N    R0,??DataTable4
   \       0x26   0x4001             ANDS     R1,R0,R1
   \       0x28   0xF1B1 0x7F60      CMP      R1,#+58720256
   \       0x2C   0xD13C             BNE.N    ??sli_se_transparent_mac_sign_finish_3
    439              uint8_t buffer[sizeof(operation->hmac.opad)
    440                             + (sizeof(operation->hmac.opad) / 2)];
    441              size_t olen = 0;
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x9102             STR      R1,[SP, #+8]
    442              psa_algorithm_t hash_alg = PSA_ALG_HMAC_GET_HASH(operation->hmac.alg);
   \       0x32   0x7838             LDRB     R0,[R7, #+0]
    443          
    444              #if !defined(SLI_PSA_DRIVER_FEATURE_HASH_STATE_64)
    445              if (hash_alg == PSA_ALG_SHA_384 || hash_alg == PSA_ALG_SHA_512) {
   \       0x34   0x....             LDR.N    R1,??DataTable4_3
   \       0x36   0xF040 0x7800      ORR      R8,R0,#0x2000000
   \       0x3A   0x4588             CMP      R8,R1
   \       0x3C   0xBF1A             ITTE     NE
   \       0x3E   0x....             LDRNE.N  R0,??DataTable4_2
   \       0x40   0x4580             CMPNE    R8,R0
   \       0x42   0xF06F 0x0088      MVNEQ    R0,#+136
    446                // Could only reach here if the programmer has made some errors. Take the
    447                // safe approach of checking just in case, in order to avoid certain
    448                // buffer overflows.
    449                return PSA_ERROR_BAD_STATE;
   \       0x46   0xD031             BEQ.N    ??sli_se_transparent_mac_sign_finish_2
    450              }
    451              size_t blocklen = 64;
    452              #else
    453              size_t blocklen
    454                = (hash_alg == PSA_ALG_SHA_384 || hash_alg == PSA_ALG_SHA_512) ? 128 : 64;
    455              #endif
    456          
    457              // Construct outer hash input from opad and hash result
    458              memcpy(buffer, operation->hmac.opad, blocklen);
   \       0x48   0xF107 0x09DC      ADD      R9,R7,#+220
   \       0x4C   0x2240             MOVS     R2,#+64
   \       0x4E   0x4649             MOV      R1,R9
   \       0x50   0xA803             ADD      R0,SP,#+12
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy4
    459              memset(operation->hmac.opad, 0, sizeof(operation->hmac.opad));
   \       0x56   0x2180             MOVS     R1,#+128
   \       0x58   0x4648             MOV      R0,R9
   \       0x5A   0x.... 0x....      BL       __aeabi_memclr4
    460          
    461              psa_status_t status = sli_se_transparent_hash_finish(
    462                &operation->hmac.hash_ctx,
    463                &buffer[blocklen],
    464                sizeof(buffer) - blocklen,
    465                &olen);
   \       0x5E   0xAB02             ADD      R3,SP,#+8
   \       0x60   0x2280             MOVS     R2,#+128
   \       0x62   0xA913             ADD      R1,SP,#+76
   \       0x64   0x1D38             ADDS     R0,R7,#+4
   \       0x66   0x.... 0x....      BL       sli_se_transparent_hash_finish
    466              if (status != PSA_SUCCESS) {
   \       0x6A   0xB9F8             CBNZ.N   R0,??sli_se_transparent_mac_sign_finish_2
    467                return status;
    468              }
    469          
    470              // Calculate HMAC
    471              status = sli_se_transparent_hash_compute(
    472                hash_alg,
    473                buffer,
    474                blocklen + olen,
    475                buffer,
    476                sizeof(buffer),
    477                &olen);
   \       0x6C   0x9A02             LDR      R2,[SP, #+8]
   \       0x6E   0xA902             ADD      R1,SP,#+8
   \       0x70   0x20C0             MOVS     R0,#+192
   \       0x72   0x9101             STR      R1,[SP, #+4]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0xAB03             ADD      R3,SP,#+12
   \       0x78   0x3240             ADDS     R2,R2,#+64
   \       0x7A   0xA903             ADD      R1,SP,#+12
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0x.... 0x....      BL       sli_se_transparent_hash_compute
    478              if (status != PSA_SUCCESS) {
   \       0x82   0xB998             CBNZ.N   R0,??sli_se_transparent_mac_sign_finish_2
    479                return status;
    480              }
    481          
    482              // Copy out a potentially truncated HMAC
    483              size_t requested_length = PSA_MAC_TRUNCATED_LENGTH(operation->hmac.alg);
   \       0x84   0x6838             LDR      R0,[R7, #+0]
   \       0x86   0xF3C0 0x4705      UBFX     R7,R0,#+16,#+6
    484              if (requested_length == 0) {
   \       0x8A   0xB907             CBNZ.N   R7,??sli_se_transparent_mac_sign_finish_4
    485                requested_length = olen;
   \       0x8C   0x9F02             LDR      R7,[SP, #+8]
    486              }
    487          
    488              if (requested_length > mac_size) {
   \                     ??sli_se_transparent_mac_sign_finish_4: (+1)
   \       0x8E   0x42BD             CMP      R5,R7
   \       0x90   0xBF38             IT       CC
   \       0x92   0xF06F 0x0089      MVNCC    R0,#+137
    489                memset(buffer, 0, sizeof(buffer));
    490                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x96   0xD309             BCC.N    ??sli_se_transparent_mac_sign_finish_2
    491              }
    492          
    493              memcpy(mac, buffer, requested_length);
   \       0x98   0x463A             MOV      R2,R7
   \       0x9A   0xA903             ADD      R1,SP,#+12
   \       0x9C   0x4620             MOV      R0,R4
   \       0x9E   0x.... 0x....      BL       __aeabi_memcpy
    494              *mac_length = requested_length;
   \       0xA2   0x6037             STR      R7,[R6, #+0]
    495              memset(buffer, 0, sizeof(buffer));
    496              return PSA_SUCCESS;
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xE001             B.N      ??sli_se_transparent_mac_sign_finish_2
    497            }
    498            #endif   // SLI_PSA_DRIVER_FEATURE_HMAC
    499          
    500            #if defined(SLI_PSA_DRIVER_FEATURE_CMAC) || defined(SLI_PSA_DRIVER_FEATURE_CBC_MAC)
    501            // Ephemeral contexts
    502            sl_se_key_descriptor_t key_desc = { 0 };
    503          
    504            psa_status_t status = sli_se_transparent_driver_symmetric_key_from_context(
    505              &key_desc,
    506              operation);
    507            if (status != PSA_SUCCESS) {
    508              return status;
    509            }
    510          
    511            return sli_se_driver_mac_sign_finish(&(operation->cipher_mac.operation),
    512                                                 &key_desc,
    513                                                 mac,
    514                                                 mac_size,
    515                                                 mac_length);
    516            #else   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    517            return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_transparent_mac_sign_finish_3: (+1)
   \       0xA8   0xF06F 0x0085      MVN      R0,#+133
   \                     ??sli_se_transparent_mac_sign_finish_2: (+1)
   \       0xAC   0xB033             ADD      SP,SP,#+204
   \       0xAE   0xE8BD 0x83F0      POP      {R4-R9,PC}
    518            #endif   // SLI_PSA_DRIVER_FEATURE_CMAC || SLI_PSA_DRIVER_FEATURE_CBC_MAC
    519          
    520            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    521          
    522            (void)operation;
    523            (void)mac;
    524            (void)mac_size;
    525            (void)mac_length;
    526          
    527            return PSA_ERROR_NOT_SUPPORTED;
    528          
    529            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    530          }
    531          

   \                                 In section .text, align 2, keep-with-next
    532          psa_status_t sli_se_transparent_mac_verify_finish(
    533            sli_se_transparent_mac_operation_t *operation,
    534            const uint8_t *mac,
    535            size_t mac_length)
    536          {
   \                     sli_se_transparent_mac_verify_finish: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x2120             MOVS     R1,#+32
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0xA801             ADD      R0,SP,#+4
   \       0x10   0x.... 0x....      BL       __aeabi_memset
    537            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    538          
    539            // Since the PSA Crypto core exposes the verify functionality of the drivers
    540            // without actually implementing the fallback to 'sign' when the driver
    541            // doesn't support verify, we need to do this ourselves for the time being.
    542            uint8_t calculated_mac[PSA_MAC_MAX_SIZE] = { 0 };
    543            size_t calculated_length = PSA_MAC_MAX_SIZE;
   \       0x14   0x2120             MOVS     R1,#+32
   \       0x16   0x9100             STR      R1,[SP, #+0]
    544          
    545            psa_status_t status = sli_se_transparent_mac_sign_finish(
    546              operation,
    547              calculated_mac, sizeof(calculated_mac), &calculated_length);
   \       0x18   0x466B             MOV      R3,SP
   \       0x1A   0x2220             MOVS     R2,#+32
   \       0x1C   0xA901             ADD      R1,SP,#+4
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       sli_se_transparent_mac_sign_finish
    548            if (status != PSA_SUCCESS) {
   \       0x24   0xB990             CBNZ.N   R0,??sli_se_transparent_mac_verify_finish_0
    549              return status;
    550            }
    551          
    552            if (mac_length > sizeof(calculated_mac)) {
   \       0x26   0x2D20             CMP      R5,#+32
   \       0x28   0xBF88             IT       HI
   \       0x2A   0xF06F 0x0086      MVNHI    R0,#+134
    553              return PSA_ERROR_INVALID_ARGUMENT;
   \       0x2E   0xD80D             BHI.N    ??sli_se_transparent_mac_verify_finish_0
    554            }
    555          
    556            if (sli_psa_safer_memcmp(mac, calculated_mac, mac_length) != 0) {
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0xAE01             ADD      R6,SP,#+4
   \       0x36   0xE004             B.N      ??sli_se_transparent_mac_verify_finish_1
   \                     ??sli_se_transparent_mac_verify_finish_2: (+1)
   \       0x38   0x5CA7             LDRB     R7,[R4, R2]
   \       0x3A   0x5CB3             LDRB     R3,[R6, R2]
   \       0x3C   0x1C52             ADDS     R2,R2,#+1
   \       0x3E   0x405F             EORS     R7,R3,R7
   \       0x40   0x4339             ORRS     R1,R7,R1
   \                     ??sli_se_transparent_mac_verify_finish_1: (+1)
   \       0x42   0x42AA             CMP      R2,R5
   \       0x44   0xD3F8             BCC.N    ??sli_se_transparent_mac_verify_finish_2
   \       0x46   0xB109             CBZ.N    R1,??sli_se_transparent_mac_verify_finish_0
    557              status = PSA_ERROR_INVALID_SIGNATURE;
   \       0x48   0xF06F 0x0094      MVN      R0,#+148
    558            } else {
    559              status = PSA_SUCCESS;
    560            }
    561          
    562            memset(calculated_mac, 0, sizeof(calculated_mac));
    563            return status;
   \                     ??sli_se_transparent_mac_verify_finish_0: (+1)
   \       0x4C   0xB009             ADD      SP,SP,#+36
   \       0x4E   0xBDF0             POP      {R4-R7,PC}
    564          
    565            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    566          
    567            (void)operation;
    568            (void)mac;
    569            (void)mac_length;
    570          
    571            return PSA_ERROR_NOT_SUPPORTED;
    572            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    573          }
    574          

   \                                 In section .text, align 2, keep-with-next
    575          psa_status_t sli_se_transparent_mac_abort(
    576            sli_se_transparent_mac_operation_t *operation)
    577          {
   \                     sli_se_transparent_mac_abort: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    578            #if defined(SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART)
    579          
    580            // There's no state in hardware that we need to preserve, so zeroing out the
    581            // context suffices.
    582            if (operation == NULL) {
   \        0x2   0xB910             CBNZ.N   R0,??sli_se_transparent_mac_abort_0
    583              return PSA_ERROR_INVALID_ARGUMENT;
   \        0x4   0xF06F 0x0086      MVN      R0,#+134
   \        0x8   0xBD02             POP      {R1,PC}
    584            }
    585          
    586            memset(operation, 0, sizeof(*operation));
   \                     ??sli_se_transparent_mac_abort_0: (+1)
   \        0xA   0xF44F 0x71AE      MOV      R1,#+348
   \        0xE   0x.... 0x....      BL       __aeabi_memclr4
    587          
    588            return PSA_SUCCESS;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD02             POP      {R1,PC}
    589          
    590            #else // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    591          
    592            (void)operation;
    593          
    594            return PSA_ERROR_NOT_SUPPORTED;
    595            #endif // SLI_PSA_DRIVER_FEATURE_MAC_MULTIPART
    596          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x7FC0'0000        DC32     0x7fc00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \        0x0   0x0200'0013        DC32     0x2000013
    597          
    598          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   sli_se_transparent_mac_abort
         8   -> __aeabi_memclr4
      72   sli_se_transparent_mac_compute
        72   -> __aeabi_memclr4
        72   -> sli_se_driver_mac_compute
     232   sli_se_transparent_mac_sign_finish
       232   -> __aeabi_memclr4
       232   -> __aeabi_memcpy
       232   -> __aeabi_memcpy4
       232   -> sli_se_transparent_hash_compute
       232   -> sli_se_transparent_hash_finish
      48   sli_se_transparent_mac_sign_setup
        48   -> __aeabi_memclr4
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> sli_se_transparent_hash_compute
        48   -> sli_se_transparent_hash_setup
        48   -> sli_se_transparent_hash_update
       8   sli_se_transparent_mac_update
         0   -> sli_se_transparent_hash_update
      56   sli_se_transparent_mac_verify_finish
        56   -> __aeabi_memset
        56   -> sli_se_transparent_mac_sign_finish
      16   sli_se_transparent_mac_verify_setup
        16   -> sli_se_transparent_mac_sign_setup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      32  ?_0
      22  sli_se_transparent_mac_abort
      96  sli_se_transparent_mac_compute
     178  sli_se_transparent_mac_sign_finish
     334  sli_se_transparent_mac_sign_setup
      42  sli_se_transparent_mac_update
      80  sli_se_transparent_mac_verify_finish
      12  sli_se_transparent_mac_verify_setup

 
  32 bytes in section .rodata
 820 bytes in section .text
 
 820 bytes of CODE  memory
  32 bytes of CONST memory

Errors: none
Warnings: none
