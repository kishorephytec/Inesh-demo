###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:02
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_aead.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_aead.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_aead.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_aead.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sli_se_driver_aead.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_aead.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_aead.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Driver AEAD functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     36          
     37          #include "sli_psa_driver_common.h"
     38          #include "sli_se_driver_key_management.h"
     39          #include "sli_se_driver_aead.h"
     40          
     41          #include "sl_se_manager.h"
     42          #include "sl_se_manager_cipher.h"
     43          #include "sli_se_manager_internal.h"
     44          
     45          #include <string.h>
     46          
     47          // -----------------------------------------------------------------------------
     48          // Static functions
     49          
     50          #if defined(SLI_PSA_DRIVER_FEATURE_AEAD)
     51          

   \                                 In section .text, align 2, keep-with-next
     52          static psa_status_t check_aead_parameters(const psa_key_attributes_t *attributes,
     53                                                    psa_algorithm_t alg,
     54                                                    size_t nonce_length,
     55                                                    size_t additional_data_length)
     56          {
   \                     check_aead_parameters: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
     57            size_t tag_length = PSA_AEAD_TAG_LENGTH(psa_get_key_type(attributes),
     58                                                    psa_get_key_bits(attributes),
     59                                                    alg);
   \        0x4   0x8820             LDRH     R0,[R4, #+0]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xE   0xD12E             BNE.N    ??check_aead_parameters_0
   \       0x10   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x14   0xD12B             BNE.N    ??check_aead_parameters_0
   \       0x16   0xF085 0x60AA      EOR      R0,R5,#0x5500000
   \       0x1A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x1E   0xBF1E             ITTT     NE
   \       0x20   0xF085 0x60AA      EORNE    R0,R5,#0x5500000
   \       0x24   0xF480 0x7000      EORNE    R0,R0,#0x200
   \       0x28   0xF430 0x107E      BICSNE   R0,R0,#0x3F8000
   \       0x2C   0xD12A             BNE.N    ??check_aead_parameters_1
   \                     ??check_aead_parameters_2: (+1)
   \       0x2E   0xF3C5 0x4705      UBFX     R7,R5,#+16,#+6
     60          
     61            #if !defined(SLI_PSA_DRIVER_FEATURE_GCM)
     62            (void)additional_data_length;
     63            #endif // SLI_PSA_DRIVER_FEATURE_GCM
     64          
     65            switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0)) {
   \                     ??check_aead_parameters_3: (+1)
   \       0x32   0xF425 0x157E      BIC      R5,R5,#0x3F8000
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x3A   0x4285             CMP      R5,R0
   \       0x3C   0xBF04             ITT      EQ
   \       0x3E   0x8821             LDRHEQ   R1,[R4, #+0]
   \       0x40   0xF5B1 0x5F10      CMPEQ    R1,#+9216
     66              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
     67              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
     68                // verify key type
     69                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
   \       0x44   0xD125             BNE.N    ??check_aead_parameters_4
     70                  return PSA_ERROR_NOT_SUPPORTED;
     71                }
     72                switch (psa_get_key_bits(attributes)) {
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x.... 0x....      BL       psa_get_key_bits
   \       0x4C   0x2880             CMP      R0,#+128
   \       0x4E   0xBF1C             ITT      NE
   \       0x50   0x28C0             CMPNE    R0,#+192
   \       0x52   0xF5B0 0x7F80      CMPNE    R0,#+256
   \       0x56   0xD107             BNE.N    ??check_aead_parameters_5
     73                  case 128:   // Fallthrough
     74                  case 192:   // Fallthrough
     75                  case 256:
     76                    break;
     77                  default:
     78                    return PSA_ERROR_INVALID_ARGUMENT;
     79                }
     80                // verify nonce and tag lengths
     81                if (tag_length < 4 || tag_length > 16 || tag_length % 2 != 0
     82                    || nonce_length < 7 || nonce_length > 13) {
   \       0x58   0x1F38             SUBS     R0,R7,#+4
   \       0x5A   0x280D             CMP      R0,#+13
   \       0x5C   0xD204             BCS.N    ??check_aead_parameters_5
   \       0x5E   0x07F8             LSLS     R0,R7,#+31
   \       0x60   0xD402             BMI.N    ??check_aead_parameters_5
   \       0x62   0x1FF6             SUBS     R6,R6,#+7
   \       0x64   0x2E07             CMP      R6,#+7
   \       0x66   0xD312             BCC.N    ??check_aead_parameters_6
     83                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??check_aead_parameters_5: (+1)
   \       0x68   0xF06F 0x0086      MVN      R0,#+134
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}
     84                }
   \                     ??check_aead_parameters_0: (+1)
   \       0x6E   0xF242 0x0104      MOVW     R1,#+8196
   \       0x72   0x4288             CMP      R0,R1
   \       0x74   0xBF02             ITTT     EQ
   \       0x76   0xF085 0x60A2      EOREQ    R0,R5,#0x5100000
   \       0x7A   0xF480 0x60A0      EOREQ    R0,R0,#0x500
   \       0x7E   0xF430 0x107E      BICSEQ   R0,R0,#0x3F8000
   \       0x82   0xD0D4             BEQ.N    ??check_aead_parameters_2
   \                     ??check_aead_parameters_1: (+1)
   \       0x84   0x4620             MOV      R0,R4
   \       0x86   0x.... 0x....      BL       psa_get_key_bits
   \       0x8A   0x2700             MOVS     R7,#+0
   \       0x8C   0xE7D1             B.N      ??check_aead_parameters_3
     85                break;
     86              #endif // SLI_PSA_DRIVER_FEATURE_CCM
     87          
     88              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
     89              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
     90                // AD are limited to 2^64 bits, so 2^61 bytes.
     91                // We need not check if SIZE_MAX (max of size_t) is less than 2^61.
     92                #if SIZE_MAX > 0x2000000000000000ull
     93                if (additional_data_length >> 61 != 0) {
     94                  return PSA_ERROR_INVALID_ARGUMENT;
     95                }
     96                #else
     97                (void) additional_data_length;
     98                #endif
     99                // verify key type
    100                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
    101                  return PSA_ERROR_NOT_SUPPORTED;
    102                }
    103                switch (psa_get_key_bits(attributes)) {
    104                  case 128:   // Fallthrough
    105                  case 192:   // Fallthrough
    106                  case 256:
    107                    break;
    108                  default:
    109                    return PSA_ERROR_INVALID_ARGUMENT;
    110                }
    111                // verify nonce and tag lengths
    112                if ((tag_length < 4) || (tag_length > 16)) {
    113                  return PSA_ERROR_INVALID_ARGUMENT;
    114                }
    115                if (nonce_length == 0) {
    116                  return PSA_ERROR_INVALID_ARGUMENT;
    117                }
    118                #if !defined(SLI_PSA_SUPPORT_GCM_IV_CALCULATION)
    119                if (nonce_length != 12) {
    120                  return PSA_ERROR_NOT_SUPPORTED;
    121                }
    122                #endif
    123                break;
    124              #endif // SLI_PSA_DRIVER_FEATURE_GCM
    125          
    126              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHAPOLY)
    127              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CHACHA20_POLY1305, 0):
    128                // verify key type
    129                if (psa_get_key_type(attributes) != PSA_KEY_TYPE_CHACHA20
    130                    || psa_get_key_bits(attributes) != 256) {
    131                  return PSA_ERROR_INVALID_ARGUMENT;
    132                }
    133          
    134                // verify nonce and tag lengths
    135                if (nonce_length != 12 || tag_length != 16) {
    136                  return PSA_ERROR_NOT_SUPPORTED;
    137                }
    138                break;
    139              #endif // SLI_PSA_DRIVER_FEATURE_CHACHAPOLY
    140          
    141              default:
    142                return PSA_ERROR_NOT_SUPPORTED;
    143            }
    144          
    145            return PSA_SUCCESS;
   \                     ??check_aead_parameters_6: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??check_aead_parameters_4: (+1)
   \       0x92   0xF06F 0x0085      MVN      R0,#+133
   \       0x96   0xBDF2             POP      {R1,R4-R7,PC}
    146          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF400 0x41E0      AND      R1,R0,#0x7000
   \        0x4   0xF5B1 0x5F00      CMP      R1,#+8192
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x0A01             LSRS     R1,R0,#+8
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0xF001 0x0107      AND      R1,R1,#0x7
   \        0x8   0x408A             LSLS     R2,R2,R1
   \        0xA   0x2A10             CMP      R2,#+16
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF480 0x7080      EOR      R0,R0,#0x100
   \        0x4   0xF430 0x107E      BICS     R0,R0,#0x3F8000
   \        0x8   0x4770             BX       LR
    147          
    148          #endif // SLI_PSA_DRIVER_FEATURE_AEAD
    149          
    150          #if defined(SLI_PSA_DRIVER_FEATURE_GCM_IV_CALCULATION)
    151          
    152          // Do GCM in software in case the IV isn't 12 bytes, since that's the only
    153          // thing the accelerator supports.
    154          static psa_status_t sli_se_driver_software_gcm(sl_se_command_context_t *cmd_ctx,
    155                                                         sl_se_key_descriptor_t *key_desc,
    156                                                         const uint8_t* nonce,
    157                                                         size_t nonce_length,
    158                                                         const uint8_t* additional_data,
    159                                                         size_t additional_data_length,
    160                                                         const uint8_t* input,
    161                                                         uint8_t* output,
    162                                                         size_t plaintext_length,
    163                                                         size_t tag_length,
    164                                                         uint8_t* tag,
    165                                                         bool encrypt_ndecrypt)
    166          {
    167            // Step 1: calculate H = Ek(0)
    168            uint8_t Ek[16] = { 0 };
    169            psa_status_t status = sl_se_aes_crypt_ecb(cmd_ctx,
    170                                                      key_desc,
    171                                                      SL_SE_ENCRYPT,
    172                                                      sizeof(Ek),
    173                                                      (const unsigned char *)Ek,
    174                                                      Ek);
    175          
    176            if (status != SL_STATUS_OK) {
    177              return PSA_ERROR_HARDWARE_FAILURE;
    178            }
    179          
    180            // Step 2: calculate IV = GHASH(H, {}, IV)
    181            uint8_t iv[16] = { 0 };
    182            uint64_t HL[16], HH[16];
    183          
    184            sli_psa_software_ghash_setup(Ek, HL, HH);
    185          
    186            for (size_t i = 0; i < nonce_length; i += 16) {
    187              // Mix in IV
    188              for (size_t j = 0; j < (nonce_length - i > 16 ? 16 : nonce_length - i); j++) {
    189                iv[j] ^= nonce[i + j];
    190              }
    191              // Update result
    192              sli_psa_software_ghash_multiply(HL, HH, iv, iv);
    193            }
    194          
    195            iv[12] ^= (nonce_length * 8) >> 24;
    196            iv[13] ^= (nonce_length * 8) >> 16;
    197            iv[14] ^= (nonce_length * 8) >>  8;
    198            iv[15] ^= (nonce_length * 8) >>  0;
    199          
    200            sli_psa_software_ghash_multiply(HL, HH, iv, iv);
    201          
    202            // Step 3: Calculate first counter block for tag generation
    203            uint8_t tagbuf[16] = { 0 };
    204            status = sl_se_aes_crypt_ecb(cmd_ctx,
    205                                         key_desc,
    206                                         SL_SE_ENCRYPT,
    207                                         sizeof(iv),
    208                                         (const unsigned char *)iv,
    209                                         tagbuf);
    210          
    211            if (status != SL_STATUS_OK) {
    212              return PSA_ERROR_HARDWARE_FAILURE;
    213            }
    214          
    215            // If we're decrypting, mix in the to-be-checked tag value before transforming
    216            if (!encrypt_ndecrypt) {
    217              for (size_t i = 0; i < tag_length; i++) {
    218                tagbuf[i] ^= tag[i];
    219              }
    220            }
    221          
    222            // Step 4: increment IV (ripple increment)
    223            for (size_t i = 0; i < 16; i++) {
    224              iv[15 - i]++;
    225          
    226              if (iv[15 - i] != 0) {
    227                break;
    228              }
    229            }
    230          
    231            // Step 5: Accumulate additional data
    232            memset(Ek, 0, sizeof(Ek));
    233            for (size_t i = 0; i < additional_data_length; i += 16) {
    234              // Mix in additional data as much as we have
    235              for (size_t j = 0;
    236                   j < (additional_data_length - i > 16 ? 16 : additional_data_length - i);
    237                   j++) {
    238                Ek[j] ^= additional_data[i + j];
    239              }
    240          
    241              sli_psa_software_ghash_multiply(HL, HH, Ek, Ek);
    242            }
    243          
    244            // Step 6: If we're decrypting, accumulate the ciphertext before it gets transformed
    245            if (!encrypt_ndecrypt) {
    246              for (size_t i = 0; i < plaintext_length; i += 16) {
    247                // Mix in ciphertext
    248                for (size_t j = 0;
    249                     j < (plaintext_length - i > 16 ? 16 : plaintext_length - i);
    250                     j++) {
    251                  Ek[j] ^= input[i + j];
    252                }
    253          
    254                sli_psa_software_ghash_multiply(HL, HH, Ek, Ek);
    255              }
    256            }
    257          
    258            // Step 7: transform data using AES-CTR
    259            uint32_t nc = 0;
    260            uint8_t nc_buff[16];
    261            status = sl_se_aes_crypt_ctr(cmd_ctx,
    262                                         key_desc,
    263                                         plaintext_length,
    264                                         &nc,
    265                                         iv,
    266                                         nc_buff,
    267                                         input,
    268                                         output);
    269            if (status != SL_STATUS_OK) {
    270              return PSA_ERROR_HARDWARE_FAILURE;
    271            }
    272          
    273            // Step 8: If we're encrypting, accumulate the ciphertext now
    274            if (encrypt_ndecrypt) {
    275              for (size_t i = 0; i < plaintext_length; i += 16) {
    276                // Mix in ciphertext
    277                for (size_t j = 0;
    278                     j < (plaintext_length - i > 16 ? 16 : plaintext_length - i);
    279                     j++) {
    280                  Ek[j] ^= output[i + j];
    281                }
    282          
    283                sli_psa_software_ghash_multiply(HL, HH, Ek, Ek);
    284              }
    285            }
    286          
    287            // Step 9: add len(A) || len(C) block to tag calculation
    288            uint64_t bitlen = additional_data_length * 8;
    289            Ek[0]  ^= bitlen >> 56;
    290            Ek[1]  ^= bitlen >> 48;
    291            Ek[2]  ^= bitlen >> 40;
    292            Ek[3]  ^= bitlen >> 32;
    293            Ek[4]  ^= bitlen >> 24;
    294            Ek[5]  ^= bitlen >> 16;
    295            Ek[6]  ^= bitlen >>  8;
    296            Ek[7]  ^= bitlen >>  0;
    297          
    298            bitlen = plaintext_length * 8;
    299            Ek[8]  ^= bitlen >> 56;
    300            Ek[9]  ^= bitlen >> 48;
    301            Ek[10] ^= bitlen >> 40;
    302            Ek[11] ^= bitlen >> 32;
    303            Ek[12] ^= bitlen >> 24;
    304            Ek[13] ^= bitlen >> 16;
    305            Ek[14] ^= bitlen >>  8;
    306            Ek[15] ^= bitlen >>  0;
    307          
    308            sli_psa_software_ghash_multiply(HL, HH, Ek, Ek);
    309          
    310            // Step 10: calculate tag value
    311            for (size_t i = 0; i < tag_length; i++) {
    312              tagbuf[i] ^= Ek[i];
    313            }
    314          
    315            // Step 11: output tag for encrypt operation, check tag for decrypt
    316            if (encrypt_ndecrypt) {
    317              memcpy(tag, tagbuf, tag_length);
    318            } else {
    319              uint8_t accumulator = 0;
    320              for (size_t i = 0; i < tag_length; i++) {
    321                accumulator |= tagbuf[i];
    322              }
    323              if (accumulator != 0) {
    324                return PSA_ERROR_INVALID_SIGNATURE;
    325              }
    326            }
    327          
    328            return PSA_SUCCESS;
    329          }
    330          
    331          #endif // SLI_PSA_DRIVER_FEATURE_GCM_IV_CALCULATION
    332          
    333          #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
    334          

   \                                 In section .text, align 2, keep-with-next
    335          static psa_status_t aead_start(sli_se_driver_aead_operation_t *operation,
    336                                         const uint8_t *input,
    337                                         size_t input_length)
    338          {
   \                     aead_start: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB097             SUB      SP,SP,#+92
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    339            // Ephemeral contexts
    340            sli_se_driver_aead_preinit_t preinit = operation->ctx.preinit;
   \        0xA   0xA806             ADD      R0,SP,#+24
   \        0xC   0xF104 0x0130      ADD      R1,R4,#+48
   \       0x10   0x2220             MOVS     R2,#+32
   \       0x12   0x.... 0x....      BL       __aeabi_memcpy4
    341          
    342            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x16   0xA80E             ADD      R0,SP,#+56
   \       0x18   0x.... 0x....      BL       ??Subroutine4_0
    343          
    344            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
    345            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x1C   0xA80E             ADD      R0,SP,#+56
   \       0x1E   0xF06F 0x0792      MVN      R7,#+146
   \       0x22   0x.... 0x....      BL       sl_se_init_command_context
   \       0x26   0xB9D8             CBNZ.N   R0,??aead_start_0
    346              return PSA_ERROR_HARDWARE_FAILURE;
    347            }
    348          
    349            #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
    350            uint8_t tag_length = PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg);
    351            #endif // SLI_PSA_DRIVER_FEATURE_CCM
    352          
    353            psa_algorithm_t alg = PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(operation->alg);
   \       0x28   0x6822             LDR      R2,[R4, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable11
   \       0x2E   0xF422 0x107E      BIC      R0,R2,#0x3F8000
   \       0x32   0x4288             CMP      R0,R1
   \       0x34   0xD11B             BNE.N    ??aead_start_1
    354          
    355            switch (alg) {
    356              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
    357              case PSA_ALG_GCM:
    358                status = sl_se_gcm_multipart_starts(&operation->ctx.gcm,
    359                                                    &cmd_ctx,
    360                                                    &operation->key_desc,
    361                                                    preinit.direction,
    362                                                    preinit.nonce,
    363                                                    preinit.nonce_length,
    364                                                    input,
    365                                                    input_length);
    366                if (status != SL_STATUS_OK) {
    367                  return PSA_ERROR_HARDWARE_FAILURE;
    368                }
    369          
    370                operation->ad_len += input_length;
    371                return PSA_SUCCESS;
    372                break;
    373              #endif // SLI_PSA_DRIVER_FEATURE_GCM
    374          
    375              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
    376              case PSA_ALG_CCM:
    377                status = sl_se_ccm_multipart_starts(&operation->ctx.ccm,
    378                                                    &cmd_ctx,
    379                                                    &operation->key_desc,
    380                                                    preinit.direction,
    381                                                    preinit.pt_length,
    382                                                    preinit.nonce,
    383                                                    preinit.nonce_length,
    384                                                    input,
    385                                                    input_length,
    386                                                    tag_length);
    387          
    388                if (status != SL_STATUS_OK) {
   \       0x36   0x980D             LDR      R0,[SP, #+52]
   \       0x38   0x0C12             LSRS     R2,R2,#+16
   \       0x3A   0xF002 0x023F      AND      R2,R2,#0x3F
   \       0x3E   0x9002             STR      R0,[SP, #+8]
   \       0x40   0x9808             LDR      R0,[SP, #+32]
   \       0x42   0xA909             ADD      R1,SP,#+36
   \       0x44   0xF89D 0x3018      LDRB     R3,[SP, #+24]
   \       0x48   0x9205             STR      R2,[SP, #+20]
   \       0x4A   0x9101             STR      R1,[SP, #+4]
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x9604             STR      R6,[SP, #+16]
   \       0x50   0x9503             STR      R5,[SP, #+12]
   \       0x52   0x1D22             ADDS     R2,R4,#+4
   \       0x54   0xA90E             ADD      R1,SP,#+56
   \       0x56   0xF104 0x0030      ADD      R0,R4,#+48
   \       0x5A   0x.... 0x....      BL       sl_se_ccm_multipart_starts
   \       0x5E   0xB108             CBZ.N    R0,??aead_start_2
    389                  return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??aead_start_0: (+1)
   \       0x60   0x4638             MOV      R0,R7
   \       0x62   0xE006             B.N      ??aead_start_3
    390                }
    391                operation->ad_len += input_length;
   \                     ??aead_start_2: (+1)
   \       0x64   0x6A60             LDR      R0,[R4, #+36]
   \       0x66   0x1836             ADDS     R6,R6,R0
   \       0x68   0x6266             STR      R6,[R4, #+36]
    392                return PSA_SUCCESS;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xE001             B.N      ??aead_start_3
    393                break;
    394              #endif // SLI_PSA_DRIVER_FEATURE_CCM
    395          
    396              default:
    397                return PSA_ERROR_NOT_SUPPORTED;
   \                     ??aead_start_1: (+1)
   \       0x6E   0xF06F 0x0085      MVN      R0,#+133
   \                     ??aead_start_3: (+1)
   \       0x72   0xB017             ADD      SP,SP,#+92
   \       0x74   0xBDF0             POP      {R4-R7,PC}
    398                break;
    399            }
    400          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xA80F             ADD      R0,SP,#+60
   \                     ??Subroutine4_0: (+1)
   \        0x2   0x2124             MOVS     R1,#+36
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
    401          
    402          #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
    403          
    404          // -----------------------------------------------------------------------------
    405          // Single-shot driver entry points
    406          

   \                                 In section .text, align 2, keep-with-next
    407          psa_status_t sli_se_driver_aead_encrypt_tag(
    408            const psa_key_attributes_t *attributes,
    409            const uint8_t *key_buffer,
    410            size_t key_buffer_size,
    411            psa_algorithm_t alg,
    412            const uint8_t *nonce,
    413            size_t nonce_length,
    414            const uint8_t *additional_data,
    415            size_t additional_data_length,
    416            const uint8_t *plaintext,
    417            size_t plaintext_length,
    418            uint8_t *ciphertext,
    419            size_t ciphertext_size,
    420            size_t *ciphertext_length,
    421            uint8_t *tag,
    422            size_t tag_size,
    423            size_t *tag_length)
    424          {
   \                     sli_se_driver_aead_encrypt_tag: (+1)
   \        0x0   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0x4691             MOV      R9,R2
    425            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD)
    426          
    427            if (key_buffer == NULL
    428                || attributes == NULL
    429                || nonce == NULL
    430                || (additional_data == NULL && additional_data_length > 0)
    431                || (plaintext == NULL && plaintext_length > 0)
    432                || (plaintext_length > 0 && (ciphertext == NULL || ciphertext_size == 0))
    433                || ciphertext_length == NULL || tag_length == NULL
    434                || tag_size == 0 || tag == NULL) {
   \        0x8   0xF06F 0x0B86      MVN      R11,#+134
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9000             STRNE    R0,[SP, #+0]
   \       0x12   0x2800             CMPNE    R0,#+0
   \       0x14   0xD01F             BEQ.N    ??sli_se_driver_aead_encrypt_tag_0
   \       0x16   0x9822             LDR      R0,[SP, #+136]
   \       0x18   0xB1E8             CBZ.N    R0,??sli_se_driver_aead_encrypt_tag_0
   \       0x1A   0x9824             LDR      R0,[SP, #+144]
   \       0x1C   0xB908             CBNZ.N   R0,??sli_se_driver_aead_encrypt_tag_1
   \       0x1E   0x9825             LDR      R0,[SP, #+148]
   \       0x20   0xB9C8             CBNZ.N   R0,??sli_se_driver_aead_encrypt_tag_0
   \                     ??sli_se_driver_aead_encrypt_tag_1: (+1)
   \       0x22   0x9D26             LDR      R5,[SP, #+152]
   \       0x24   0x9C27             LDR      R4,[SP, #+156]
   \       0x26   0xF8DD 0xA0A4      LDR      R10,[SP, #+164]
   \       0x2A   0xB90D             CBNZ.N   R5,??sli_se_driver_aead_encrypt_tag_2
   \       0x2C   0xB99C             CBNZ.N   R4,??sli_se_driver_aead_encrypt_tag_0
   \       0x2E   0xE006             B.N      ??sli_se_driver_aead_encrypt_tag_3
   \                     ??sli_se_driver_aead_encrypt_tag_2: (+1)
   \       0x30   0xB12C             CBZ.N    R4,??sli_se_driver_aead_encrypt_tag_3
   \       0x32   0x9828             LDR      R0,[SP, #+160]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xBF18             IT       NE
   \       0x38   0xF1BA 0x0F00      CMPNE    R10,#+0
   \       0x3C   0xD00B             BEQ.N    ??sli_se_driver_aead_encrypt_tag_0
   \                     ??sli_se_driver_aead_encrypt_tag_3: (+1)
   \       0x3E   0x9F2A             LDR      R7,[SP, #+168]
   \       0x40   0x2F00             CMP      R7,#+0
   \       0x42   0xBF1C             ITT      NE
   \       0x44   0x9E2D             LDRNE    R6,[SP, #+180]
   \       0x46   0x2E00             CMPNE    R6,#+0
   \       0x48   0xD005             BEQ.N    ??sli_se_driver_aead_encrypt_tag_0
   \       0x4A   0x982C             LDR      R0,[SP, #+176]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xBF1C             ITT      NE
   \       0x50   0x982B             LDRNE    R0,[SP, #+172]
   \       0x52   0x2800             CMPNE    R0,#+0
   \       0x54   0xD101             BNE.N    ??sli_se_driver_aead_encrypt_tag_4
    435              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_encrypt_tag_0: (+1)
   \       0x56   0x4658             MOV      R0,R11
   \       0x58   0xE077             B.N      ??sli_se_driver_aead_encrypt_tag_5
    436            }
    437          
    438            sl_status_t status;
    439            psa_status_t psa_status;
    440            *tag_length = PSA_AEAD_TAG_LENGTH(psa_get_key_type(attributes),
    441                                              psa_get_key_bits(attributes),
    442                                              alg);
   \                     ??sli_se_driver_aead_encrypt_tag_4: (+1)
   \       0x5A   0x9800             LDR      R0,[SP, #+0]
   \       0x5C   0x4698             MOV      R8,R3
   \       0x5E   0x8800             LDRH     R0,[R0, #+0]
   \       0x60   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x64   0xD126             BNE.N    ??sli_se_driver_aead_encrypt_tag_6
   \       0x66   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x6A   0xD123             BNE.N    ??sli_se_driver_aead_encrypt_tag_6
   \       0x6C   0xF088 0x60AA      EOR      R0,R8,#0x5500000
   \       0x70   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x74   0xBF1E             ITTT     NE
   \       0x76   0xF088 0x60AA      EORNE    R0,R8,#0x5500000
   \       0x7A   0xF480 0x7000      EORNE    R0,R0,#0x200
   \       0x7E   0xF430 0x107E      BICSNE   R0,R0,#0x3F8000
   \       0x82   0xD122             BNE.N    ??sli_se_driver_aead_encrypt_tag_7
   \                     ??sli_se_driver_aead_encrypt_tag_8: (+1)
   \       0x84   0xF3C8 0x4005      UBFX     R0,R8,#+16,#+6
   \                     ??sli_se_driver_aead_encrypt_tag_9: (+1)
   \       0x88   0x6030             STR      R0,[R6, #+0]
    443          
    444            // Verify that the driver supports the given parameters
    445            psa_status = check_aead_parameters(attributes,
    446                                               alg,
    447                                               nonce_length,
    448                                               additional_data_length);
   \       0x8A   0x9B25             LDR      R3,[SP, #+148]
   \       0x8C   0x9A23             LDR      R2,[SP, #+140]
   \       0x8E   0x9800             LDR      R0,[SP, #+0]
   \       0x90   0x4641             MOV      R1,R8
   \       0x92   0x.... 0x....      BL       check_aead_parameters
    449            if (psa_status != PSA_SUCCESS) {
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD157             BNE.N    ??sli_se_driver_aead_encrypt_tag_5
    450              return psa_status;
    451            }
    452          
    453            // Ephemeral contexts
    454            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x9A   0x.... 0x....      BL       ?Subroutine4
    455            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x9E   0xA807             ADD      R0,SP,#+28
   \       0xA0   0x2120             MOVS     R1,#+32
   \       0xA2   0x.... 0x....      BL       __aeabi_memclr4
    456          
    457            status = sl_se_init_command_context(&cmd_ctx);
    458            if (status != SL_STATUS_OK) {
   \       0xA6   0xA80F             ADD      R0,SP,#+60
   \       0xA8   0x.... 0x....      BL       sl_se_init_command_context
   \       0xAC   0xB178             CBZ.N    R0,??sli_se_driver_aead_encrypt_tag_10
    459              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xAE   0xF06F 0x0092      MVN      R0,#+146
   \       0xB2   0xE04A             B.N      ??sli_se_driver_aead_encrypt_tag_5
    460            }
   \                     ??sli_se_driver_aead_encrypt_tag_6: (+1)
   \       0xB4   0xF242 0x0104      MOVW     R1,#+8196
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xBF02             ITTT     EQ
   \       0xBC   0xF088 0x60A2      EOREQ    R0,R8,#0x5100000
   \       0xC0   0xF480 0x60A0      EOREQ    R0,R0,#0x500
   \       0xC4   0xF430 0x107E      BICSEQ   R0,R0,#0x3F8000
   \       0xC8   0xD0DC             BEQ.N    ??sli_se_driver_aead_encrypt_tag_8
   \                     ??sli_se_driver_aead_encrypt_tag_7: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xE7DC             B.N      ??sli_se_driver_aead_encrypt_tag_9
    461          
    462            psa_status = sli_se_key_desc_from_input(attributes,
    463                                                    key_buffer,
    464                                                    key_buffer_size,
    465                                                    &key_desc);
   \                     ??sli_se_driver_aead_encrypt_tag_10: (+1)
   \       0xCE   0x9918             LDR      R1,[SP, #+96]
   \       0xD0   0x9800             LDR      R0,[SP, #+0]
   \       0xD2   0x464A             MOV      R2,R9
   \       0xD4   0xAB07             ADD      R3,SP,#+28
   \       0xD6   0x.... 0x....      BL       sli_se_key_desc_from_input
    466            if (psa_status != PSA_SUCCESS) {
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD135             BNE.N    ??sli_se_driver_aead_encrypt_tag_5
    467              return psa_status;
    468            }
    469          
    470            // Check sufficient output buffer size.
    471            if ((ciphertext_size < plaintext_length)
    472                || (tag_size < *tag_length)) {
   \       0xDE   0x45A2             CMP      R10,R4
   \       0xE0   0xBF23             ITTTE    CS
   \       0xE2   0x992C             LDRCS    R1,[SP, #+176]
   \       0xE4   0x6830             LDRCS    R0,[R6, #+0]
   \       0xE6   0x4281             CMPCS    R1,R0
   \       0xE8   0xF06F 0x0089      MVNCC    R0,#+137
    473              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0xEC   0xD32D             BCC.N    ??sli_se_driver_aead_encrypt_tag_5
    474            }
    475          
    476            // Our drivers only support full or no overlap between input and output
    477            // buffers. So in the case of partial overlap, copy the input buffer into
    478            // the output buffer and process it in place as if the buffers fully
    479            // overlapped.
    480            if ((ciphertext > plaintext) && (ciphertext < (plaintext + plaintext_length))) {
   \       0xEE   0x9928             LDR      R1,[SP, #+160]
   \       0xF0   0x428D             CMP      R5,R1
   \       0xF2   0xBF3C             ITT      CC
   \       0xF4   0x1928             ADDCC    R0,R5,R4
   \       0xF6   0x4281             CMPCC    R1,R0
   \       0xF8   0xD205             BCS.N    ??sli_se_driver_aead_encrypt_tag_11
    481              memmove(ciphertext, plaintext, plaintext_length);
   \       0xFA   0x9828             LDR      R0,[SP, #+160]
   \       0xFC   0x4622             MOV      R2,R4
   \       0xFE   0x4629             MOV      R1,R5
   \      0x100   0x.... 0x....      BL       __aeabi_memmove
    482              plaintext = ciphertext;
   \      0x104   0x9D28             LDR      R5,[SP, #+160]
    483            }
    484          
    485            psa_status = PSA_ERROR_BAD_STATE;
    486            switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0)) {
   \                     ??sli_se_driver_aead_encrypt_tag_11: (+1)
   \      0x106   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_16: (+1)
   \      0x10A   0xD11B             BNE.N    ??sli_se_driver_aead_encrypt_tag_12
    487              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
    488              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
    489                status = sl_se_ccm_encrypt_and_tag(&cmd_ctx,
    490                                                   &key_desc,
    491                                                   plaintext_length,
    492                                                   nonce,
    493                                                   nonce_length,
    494                                                   additional_data,
    495                                                   additional_data_length,
    496                                                   plaintext,
    497                                                   ciphertext,
    498                                                   tag,
    499                                                   *tag_length);
   \      0x10C   0x6830             LDR      R0,[R6, #+0]
   \      0x10E   0x992B             LDR      R1,[SP, #+172]
   \      0x110   0x9A25             LDR      R2,[SP, #+148]
   \      0x112   0x9006             STR      R0,[SP, #+24]
   \      0x114   0x9828             LDR      R0,[SP, #+160]
   \      0x116   0x9105             STR      R1,[SP, #+20]
   \      0x118   0x9924             LDR      R1,[SP, #+144]
   \      0x11A   0x9004             STR      R0,[SP, #+16]
   \      0x11C   0x9823             LDR      R0,[SP, #+140]
   \      0x11E   0x9B22             LDR      R3,[SP, #+136]
   \      0x120   0x9202             STR      R2,[SP, #+8]
   \      0x122   0x9101             STR      R1,[SP, #+4]
   \      0x124   0x9000             STR      R0,[SP, #+0]
   \      0x126   0x9503             STR      R5,[SP, #+12]
   \      0x128   0x4622             MOV      R2,R4
   \      0x12A   0xA907             ADD      R1,SP,#+28
   \      0x12C   0xA80F             ADD      R0,SP,#+60
   \      0x12E   0x.... 0x....      BL       sl_se_ccm_encrypt_and_tag
    500                if (status == SL_STATUS_INVALID_PARAMETER) {
   \      0x132   0x2821             CMP      R0,#+33
   \      0x134   0xBF08             IT       EQ
   \      0x136   0x4658             MOVEQ    R0,R11
    501                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
   \      0x138   0xD004             BEQ.N    ??sli_se_driver_aead_encrypt_tag_12
    502                } else if (status == SL_STATUS_OK) {
   \      0x13A   0xB908             CBNZ.N   R0,??sli_se_driver_aead_encrypt_tag_13
    503                  psa_status = PSA_SUCCESS;
    504                } else {
    505                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
    506                }
    507                break;
    508              #endif // SLI_PSA_DRIVER_FEATURE_CCM
    509          
    510              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
    511              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
    512                if (nonce_length == 12) {
    513                  status = sl_se_gcm_crypt_and_tag(&cmd_ctx,
    514                                                   &key_desc,
    515                                                   SL_SE_ENCRYPT,
    516                                                   plaintext_length,
    517                                                   nonce,
    518                                                   nonce_length,
    519                                                   additional_data,
    520                                                   additional_data_length,
    521                                                   plaintext,
    522                                                   ciphertext,
    523                                                   *tag_length,
    524                                                   tag);
    525          
    526                  if (status == SL_STATUS_INVALID_PARAMETER) {
    527                    psa_status = PSA_ERROR_INVALID_ARGUMENT;
    528                  } else if (status == SL_STATUS_OK) {
    529                    psa_status = PSA_SUCCESS;
    530                  } else {
    531                    psa_status = PSA_ERROR_HARDWARE_FAILURE;
    532                  }
    533                }
    534                #if defined(SLI_PSA_SUPPORT_GCM_IV_CALCULATION)
    535                else {
    536                  psa_status = sli_se_driver_software_gcm(&cmd_ctx,
    537                                                          &key_desc,
    538                                                          nonce,
    539                                                          nonce_length,
    540                                                          additional_data,
    541                                                          additional_data_length,
    542                                                          plaintext,
    543                                                          ciphertext,
    544                                                          plaintext_length,
    545                                                          *tag_length,
    546                                                          tag,
    547                                                          true);
    548                }
    549                #else   // SLI_PSA_SUPPORT_GCM_IV_CALCULATION
    550                else {
    551                  psa_status = PSA_ERROR_NOT_SUPPORTED;
    552                }
    553                #endif   // SLI_PSA_SUPPORT_GCM_IV_CALCULATION
    554                break;
    555              #endif // SLI_PSA_DRIVER_FEATURE_GCM
    556          
    557              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHAPOLY)
    558              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CHACHA20_POLY1305, 0):
    559              {
    560                #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    561                // EFR32xG21 doesn't support the special case where both the message
    562                // and additional data length are zero.
    563                if (plaintext_length == 0 && additional_data_length == 0) {
    564                  return PSA_ERROR_NOT_SUPPORTED;
    565                }
    566                #endif
    567          
    568                uint8_t tagbuf[16];
    569          
    570                status = sl_se_chacha20_poly1305_encrypt_and_tag(&cmd_ctx,
    571                                                                 &key_desc,
    572                                                                 plaintext_length,
    573                                                                 nonce,
    574                                                                 additional_data,
    575                                                                 additional_data_length,
    576                                                                 plaintext,
    577                                                                 ciphertext,
    578                                                                 tagbuf);
    579          
    580                if (status == SL_STATUS_INVALID_PARAMETER) {
    581                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
    582                } else if (status == SL_STATUS_OK) {
    583                  memcpy(tag, tagbuf, *tag_length);
    584                  psa_status = PSA_SUCCESS;
    585                } else {
    586                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
    587                }
    588                break;
    589              }
    590              #endif // SLI_PSA_DRIVER_FEATURE_CHACHAPOLY
    591            }
    592          
    593            if (psa_status == PSA_SUCCESS) {
    594              *ciphertext_length = plaintext_length;
   \      0x13C   0x603C             STR      R4,[R7, #+0]
   \      0x13E   0xE004             B.N      ??sli_se_driver_aead_encrypt_tag_5
    595            } else {
   \                     ??sli_se_driver_aead_encrypt_tag_13: (+1)
   \      0x140   0xF06F 0x0092      MVN      R0,#+146
    596              *ciphertext_length = 0;
   \                     ??sli_se_driver_aead_encrypt_tag_12: (+1)
   \      0x144   0x2100             MOVS     R1,#+0
   \      0x146   0x6039             STR      R1,[R7, #+0]
    597              *tag_length = 0;
   \      0x148   0x6031             STR      R1,[R6, #+0]
    598            }
    599          
    600            return psa_status;
   \                     ??sli_se_driver_aead_encrypt_tag_5: (+1)
   \      0x14A                      REQUIRE ?Subroutine0
   \      0x14A                      ;; // Fall through to label ?Subroutine0
    601          
    602            #else // SLI_PSA_DRIVER_FEATURE_AEAD
    603          
    604            (void)attributes;
    605            (void)key_buffer;
    606            (void)key_buffer_size;
    607            (void)alg;
    608            (void)nonce;
    609            (void)nonce_length;
    610            (void)additional_data;
    611            (void)additional_data_length;
    612            (void)plaintext;
    613            (void)plaintext_length;
    614            (void)ciphertext;
    615            (void)ciphertext_size;
    616            (void)ciphertext_length;
    617            (void)tag;
    618            (void)tag_size;
    619            (void)tag_length;
    620          
    621            return PSA_ERROR_NOT_SUPPORTED;
    622          
    623            #endif // SLI_PSA_DRIVER_FEATURE_AEAD
    624          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB019             ADD      SP,SP,#+100
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF428 0x127E      BIC      R2,R8,#0x3F8000
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable11
   \        0x8   0xF06F 0x0088      MVN      R0,#+136
   \        0xC   0x428A             CMP      R2,R1
   \        0xE   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    625          

   \                                 In section .text, align 2, keep-with-next
    626          psa_status_t sli_se_driver_aead_decrypt_tag(
    627            const psa_key_attributes_t *attributes,
    628            const uint8_t *key_buffer,
    629            size_t key_buffer_size,
    630            psa_algorithm_t alg,
    631            const uint8_t *nonce,
    632            size_t nonce_length,
    633            const uint8_t *additional_data,
    634            size_t additional_data_length,
    635            const uint8_t *ciphertext,
    636            size_t ciphertext_length,
    637            const uint8_t* tag,
    638            size_t tag_length,
    639            uint8_t *plaintext,
    640            size_t plaintext_size,
    641            size_t *plaintext_length)
    642          {
   \                     sli_se_driver_aead_decrypt_tag: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB098             SUB      SP,SP,#+96
   \        0x6   0xEA5F 0x0B00      MOVS     R11,R0
   \        0xA   0x4691             MOV      R9,R2
    643            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD)
    644          
    645            if (attributes == NULL
    646                || key_buffer == NULL
    647                || nonce == NULL
    648                || (additional_data == NULL && additional_data_length > 0)
    649                || (ciphertext == NULL && ciphertext_length > 0)
    650                || (plaintext == NULL && plaintext_size > 0)
    651                || plaintext_length == NULL
    652                || tag == NULL) {
   \        0xC   0xD05D             BEQ.N    ??sli_se_driver_aead_decrypt_tag_0
   \        0xE   0x9100             STR      R1,[SP, #+0]
   \       0x10   0x0008             MOVS     R0,R1
   \       0x12   0xBF1C             ITT      NE
   \       0x14   0x9822             LDRNE    R0,[SP, #+136]
   \       0x16   0x2800             CMPNE    R0,#+0
   \       0x18   0xD057             BEQ.N    ??sli_se_driver_aead_decrypt_tag_0
   \       0x1A   0x9824             LDR      R0,[SP, #+144]
   \       0x1C   0x9F25             LDR      R7,[SP, #+148]
   \       0x1E   0xB908             CBNZ.N   R0,??sli_se_driver_aead_decrypt_tag_1
   \       0x20   0x2F00             CMP      R7,#+0
   \       0x22   0xD152             BNE.N    ??sli_se_driver_aead_decrypt_tag_0
   \                     ??sli_se_driver_aead_decrypt_tag_1: (+1)
   \       0x24   0x9C26             LDR      R4,[SP, #+152]
   \       0x26   0x9D27             LDR      R5,[SP, #+156]
   \       0x28   0xB90C             CBNZ.N   R4,??sli_se_driver_aead_decrypt_tag_2
   \       0x2A   0x2D00             CMP      R5,#+0
   \       0x2C   0xD14D             BNE.N    ??sli_se_driver_aead_decrypt_tag_0
   \                     ??sli_se_driver_aead_decrypt_tag_2: (+1)
   \       0x2E   0x9E2A             LDR      R6,[SP, #+168]
   \       0x30   0xF8DD 0xA0AC      LDR      R10,[SP, #+172]
   \       0x34   0xB916             CBNZ.N   R6,??sli_se_driver_aead_decrypt_tag_3
   \       0x36   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x3A   0xD146             BNE.N    ??sli_se_driver_aead_decrypt_tag_0
   \                     ??sli_se_driver_aead_decrypt_tag_3: (+1)
   \       0x3C   0x982C             LDR      R0,[SP, #+176]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xBF1C             ITT      NE
   \       0x42   0x9828             LDRNE    R0,[SP, #+160]
   \       0x44   0x2800             CMPNE    R0,#+0
   \       0x46   0xD040             BEQ.N    ??sli_se_driver_aead_decrypt_tag_0
    653              return PSA_ERROR_INVALID_ARGUMENT;
    654            }
    655          
    656            sl_status_t status;
    657            psa_status_t psa_status;
    658          
    659            // Verify that the driver supports the given parameters
    660            psa_status = check_aead_parameters(attributes,
    661                                               alg,
    662                                               nonce_length,
    663                                               additional_data_length);
   \       0x48   0x9A23             LDR      R2,[SP, #+140]
   \       0x4A   0x4698             MOV      R8,R3
   \       0x4C   0x463B             MOV      R3,R7
   \       0x4E   0x4641             MOV      R1,R8
   \       0x50   0x4658             MOV      R0,R11
   \       0x52   0x.... 0x....      BL       check_aead_parameters
    664            if (psa_status != PSA_SUCCESS) {
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD143             BNE.N    ??sli_se_driver_aead_decrypt_tag_4
    665              return psa_status;
    666            }
    667          
    668            // Ephemeral contexts
    669            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x5A   0x.... 0x....      BL       ?Subroutine4
    670            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x5E   0xA807             ADD      R0,SP,#+28
   \       0x60   0x2120             MOVS     R1,#+32
   \       0x62   0x.... 0x....      BL       __aeabi_memclr4
    671          
    672            status = sl_se_init_command_context(&cmd_ctx);
    673            if (status != SL_STATUS_OK) {
   \       0x66   0xA80F             ADD      R0,SP,#+60
   \       0x68   0x.... 0x....      BL       sl_se_init_command_context
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD139             BNE.N    ??sli_se_driver_aead_decrypt_tag_5
    674              return PSA_ERROR_HARDWARE_FAILURE;
    675            }
    676          
    677            psa_status = sli_se_key_desc_from_input(attributes,
    678                                                    key_buffer,
    679                                                    key_buffer_size,
    680                                                    &key_desc);
   \       0x70   0x9900             LDR      R1,[SP, #+0]
   \       0x72   0x464A             MOV      R2,R9
   \       0x74   0xAB07             ADD      R3,SP,#+28
   \       0x76   0x4658             MOV      R0,R11
   \       0x78   0x.... 0x....      BL       sli_se_key_desc_from_input
    681            if (psa_status != PSA_SUCCESS) {
   \       0x7C   0xBB88             CBNZ.N   R0,??sli_se_driver_aead_decrypt_tag_4
    682              return psa_status;
    683            }
    684          
    685            // Check sufficient output buffer size.
    686            if (plaintext_size < ciphertext_length) {
   \       0x7E   0x45AA             CMP      R10,R5
   \       0x80   0xBF38             IT       CC
   \       0x82   0xF06F 0x0089      MVNCC    R0,#+137
    687              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x86   0xD32C             BCC.N    ??sli_se_driver_aead_decrypt_tag_4
    688            }
    689          
    690            // Our drivers only support full or no overlap between input and output
    691            // buffers. So in the case of partial overlap, copy the input buffer into
    692            // the output buffer and process it in place as if the buffers fully
    693            // overlapped.
    694            if ((plaintext > ciphertext) && (plaintext < (ciphertext + ciphertext_length))) {
   \       0x88   0x42B4             CMP      R4,R6
   \       0x8A   0xBF3C             ITT      CC
   \       0x8C   0x1960             ADDCC    R0,R4,R5
   \       0x8E   0x4286             CMPCC    R6,R0
   \       0x90   0xD205             BCS.N    ??sli_se_driver_aead_decrypt_tag_6
    695              memmove(plaintext, ciphertext, ciphertext_length);
   \       0x92   0x462A             MOV      R2,R5
   \       0x94   0x4621             MOV      R1,R4
   \       0x96   0x4630             MOV      R0,R6
   \       0x98   0x.... 0x....      BL       __aeabi_memmove
    696              ciphertext = plaintext;
   \       0x9C   0x4634             MOV      R4,R6
    697            }
    698          
    699            psa_status = PSA_ERROR_BAD_STATE;
    700            switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0)) {
   \                     ??sli_se_driver_aead_decrypt_tag_6: (+1)
   \       0x9E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0xA2   0xD11E             BNE.N    ??sli_se_driver_aead_decrypt_tag_4
    701              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
    702              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
    703                status = sl_se_ccm_auth_decrypt(&cmd_ctx,
    704                                                &key_desc,
    705                                                ciphertext_length,
    706                                                nonce,
    707                                                nonce_length,
    708                                                additional_data,
    709                                                additional_data_length,
    710                                                ciphertext,
    711                                                plaintext,
    712                                                tag,
    713                                                tag_length);
   \       0xA4   0x9A29             LDR      R2,[SP, #+164]
   \       0xA6   0x9828             LDR      R0,[SP, #+160]
   \       0xA8   0x9604             STR      R6,[SP, #+16]
   \       0xAA   0x9206             STR      R2,[SP, #+24]
   \       0xAC   0x9005             STR      R0,[SP, #+20]
   \       0xAE   0x9403             STR      R4,[SP, #+12]
   \       0xB0   0x9702             STR      R7,[SP, #+8]
   \       0xB2   0x9924             LDR      R1,[SP, #+144]
   \       0xB4   0x9823             LDR      R0,[SP, #+140]
   \       0xB6   0x9B22             LDR      R3,[SP, #+136]
   \       0xB8   0x9101             STR      R1,[SP, #+4]
   \       0xBA   0x9000             STR      R0,[SP, #+0]
   \       0xBC   0x462A             MOV      R2,R5
   \       0xBE   0xA907             ADD      R1,SP,#+28
   \       0xC0   0xA80F             ADD      R0,SP,#+60
   \       0xC2   0x.... 0x....      BL       sl_se_ccm_auth_decrypt
    714                if (status == SL_STATUS_INVALID_PARAMETER) {
   \       0xC6   0x2821             CMP      R0,#+33
   \       0xC8   0xD102             BNE.N    ??sli_se_driver_aead_decrypt_tag_7
    715                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_decrypt_tag_0: (+1)
   \       0xCA   0xF06F 0x0086      MVN      R0,#+134
   \       0xCE   0xE008             B.N      ??sli_se_driver_aead_decrypt_tag_4
    716                } else if (status == SL_STATUS_INVALID_SIGNATURE) {
   \                     ??sli_se_driver_aead_decrypt_tag_7: (+1)
   \       0xD0   0x282C             CMP      R0,#+44
   \       0xD2   0xBF08             IT       EQ
   \       0xD4   0xF06F 0x0094      MVNEQ    R0,#+148
    717                  return PSA_ERROR_INVALID_SIGNATURE;
   \       0xD8   0xD003             BEQ.N    ??sli_se_driver_aead_decrypt_tag_4
    718                } else if (status == SL_STATUS_OK) {
   \       0xDA   0xB918             CBNZ.N   R0,??sli_se_driver_aead_decrypt_tag_5
    719                  *plaintext_length = ciphertext_length;
   \       0xDC   0x982C             LDR      R0,[SP, #+176]
   \       0xDE   0x6005             STR      R5,[R0, #+0]
    720                  psa_status = PSA_SUCCESS;
   \       0xE0   0x2000             MOVS     R0,#+0
    721                } else {
    722                  return PSA_ERROR_HARDWARE_FAILURE;
    723                }
    724                break;
    725              #endif // SLI_PSA_DRIVER_FEATURE_CCM
    726          
    727              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
    728              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
    729                if (nonce_length == 12) {
    730                  status = sl_se_gcm_auth_decrypt(&cmd_ctx,
    731                                                  &key_desc,
    732                                                  ciphertext_length,
    733                                                  nonce,
    734                                                  nonce_length,
    735                                                  additional_data,
    736                                                  additional_data_length,
    737                                                  ciphertext,
    738                                                  plaintext,
    739                                                  tag_length,
    740                                                  tag);
    741          
    742                  if (status == SL_STATUS_INVALID_PARAMETER) {
    743                    return PSA_ERROR_INVALID_ARGUMENT;
    744                  } else if (status == SL_STATUS_INVALID_SIGNATURE) {
    745                    return PSA_ERROR_INVALID_SIGNATURE;
    746                  } else if (status == SL_STATUS_OK) {
    747                    *plaintext_length = ciphertext_length;
    748                    psa_status = PSA_SUCCESS;
    749                  } else {
    750                    return PSA_ERROR_HARDWARE_FAILURE;
    751                  }
    752                }
    753                #if defined(SLI_PSA_SUPPORT_GCM_IV_CALCULATION)
    754                else {
    755                  psa_status = sli_se_driver_software_gcm(&cmd_ctx,
    756                                                          &key_desc,
    757                                                          nonce,
    758                                                          nonce_length,
    759                                                          additional_data,
    760                                                          additional_data_length,
    761                                                          ciphertext,
    762                                                          plaintext,
    763                                                          ciphertext_length,
    764                                                          tag_length,
    765                                                          (uint8_t*) tag,
    766                                                          false);
    767                  if (psa_status == PSA_SUCCESS) {
    768                    *plaintext_length = ciphertext_length;
    769                  }
    770                }
    771                #else   // SLI_PSA_SUPPORT_GCM_IV_CALCULATION
    772                else {
    773                  psa_status = PSA_ERROR_NOT_SUPPORTED;
    774                }
    775                #endif   // SLI_PSA_SUPPORT_GCM_IV_CALCULATION
    776                break;
    777              #endif // SLI_PSA_DRIVER_FEATURE_CCM
    778          
    779              #if defined(SLI_PSA_DRIVER_FEATURE_CHACHAPOLY)
    780              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CHACHA20_POLY1305, 0):
    781          
    782                #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    783                // EFR32xG21 doesn't support the special case where both the message
    784                // and additional data length are zero.
    785                if (ciphertext_length == 0 && additional_data_length == 0) {
    786                  return PSA_ERROR_NOT_SUPPORTED;
    787                }
    788                #endif
    789          
    790                // Vault devices currently do not support ChaCha20-Poly1305 with truncated
    791                // tag lengths. RFC8439 also disallows truncating the tag.
    792                if (tag_length != 16) {
    793                  return PSA_ERROR_NOT_SUPPORTED;
    794                }
    795          
    796                status = sl_se_chacha20_poly1305_auth_decrypt(&cmd_ctx,
    797                                                              &key_desc,
    798                                                              ciphertext_length,
    799                                                              nonce,
    800                                                              additional_data,
    801                                                              additional_data_length,
    802                                                              ciphertext,
    803                                                              plaintext,
    804                                                              tag);
    805          
    806                if (status == SL_STATUS_INVALID_PARAMETER) {
    807                  return PSA_ERROR_INVALID_ARGUMENT;
    808                } else if (status == SL_STATUS_INVALID_SIGNATURE) {
    809                  return PSA_ERROR_INVALID_SIGNATURE;
    810                } else if (status == SL_STATUS_OK) {
    811                  *plaintext_length = ciphertext_length;
    812                  psa_status = PSA_SUCCESS;
    813                } else {
    814                  return PSA_ERROR_HARDWARE_FAILURE;
    815                }
    816                break;
    817              #endif // SLI_PSA_DRIVER_FEATURE_CHACHAPOLY
    818            }
    819          
    820            return psa_status;
   \                     ??sli_se_driver_aead_decrypt_tag_4: (+1)
   \       0xE2   0x....             B.N      ?Subroutine0
   \                     ??sli_se_driver_aead_decrypt_tag_5: (+1)
   \       0xE4   0xF06F 0x0092      MVN      R0,#+146
   \       0xE8   0xE7FB             B.N      ??sli_se_driver_aead_decrypt_tag_4
    821          
    822            #else // SLI_PSA_DRIVER_FEATURE_AEAD
    823          
    824            (void)attributes;
    825            (void)key_buffer;
    826            (void)key_buffer_size;
    827            (void)alg;
    828            (void)nonce;
    829            (void)nonce_length;
    830            (void)additional_data;
    831            (void)additional_data_length;
    832            (void)ciphertext;
    833            (void)ciphertext_length;
    834            (void)tag;
    835            (void)tag_length;
    836            (void)plaintext;
    837            (void)plaintext_size;
    838            (void)plaintext_length;
    839          
    840            return PSA_ERROR_NOT_SUPPORTED;
    841          
    842            #endif // SLI_PSA_DRIVER_FEATURE_AEAD
    843          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    844          

   \                                 In section .text, align 2, keep-with-next
    845          psa_status_t sli_se_driver_aead_encrypt(const psa_key_attributes_t *attributes,
    846                                                  const uint8_t *key_buffer,
    847                                                  size_t key_buffer_size,
    848                                                  psa_algorithm_t alg,
    849                                                  const uint8_t *nonce,
    850                                                  size_t nonce_length,
    851                                                  const uint8_t *additional_data,
    852                                                  size_t additional_data_length,
    853                                                  const uint8_t *plaintext,
    854                                                  size_t plaintext_length,
    855                                                  uint8_t *ciphertext,
    856                                                  size_t ciphertext_size,
    857                                                  size_t *ciphertext_length)
    858          {
   \                     sli_se_driver_aead_encrypt: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x9D19             LDR      R5,[SP, #+100]
   \        0x8   0x9E1B             LDR      R6,[SP, #+108]
    859            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD)
    860          
    861            if (ciphertext_size <= plaintext_length) {
   \        0xA   0x42B5             CMP      R5,R6
   \        0xC   0xBF28             IT       CS
   \        0xE   0xF06F 0x0089      MVNCS    R0,#+137
    862              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x12   0xD222             BCS.N    ??sli_se_driver_aead_encrypt_0
   \       0x14   0x9F1A             LDR      R7,[SP, #+104]
    863            }
    864          
    865            size_t tag_length = 0;
    866            psa_status_t psa_status = sli_se_driver_aead_encrypt_tag(
    867              attributes,
    868              key_buffer,
    869              key_buffer_size,
    870              alg,
    871              nonce,
    872              nonce_length,
    873              additional_data,
    874              additional_data_length,
    875              plaintext,
    876              plaintext_length,
    877              ciphertext,
    878              plaintext_length,
    879              ciphertext_length,
    880              &ciphertext[plaintext_length],
    881              ciphertext_size - plaintext_length,
    882              &tag_length);
   \       0x16   0x9507             STR      R5,[SP, #+28]
   \       0x18   0x9505             STR      R5,[SP, #+20]
   \       0x1A   0x1B76             SUBS     R6,R6,R5
   \       0x1C   0x960A             STR      R6,[SP, #+40]
   \       0x1E   0x197E             ADDS     R6,R7,R5
   \       0x20   0x9D18             LDR      R5,[SP, #+96]
   \       0x22   0x9609             STR      R6,[SP, #+36]
   \       0x24   0x9E17             LDR      R6,[SP, #+92]
   \       0x26   0x9504             STR      R5,[SP, #+16]
   \       0x28   0x9D16             LDR      R5,[SP, #+88]
   \       0x2A   0x9603             STR      R6,[SP, #+12]
   \       0x2C   0x9C1C             LDR      R4,[SP, #+112]
   \       0x2E   0x9502             STR      R5,[SP, #+8]
   \       0x30   0x9E15             LDR      R6,[SP, #+84]
   \       0x32   0x9D14             LDR      R5,[SP, #+80]
   \       0x34   0xF04F 0x0E00      MOV      LR,#+0
   \       0x38   0xF10D 0x0830      ADD      R8,SP,#+48
   \       0x3C   0xF8CD 0xE030      STR      LR,[SP, #+48]
   \       0x40   0xF8CD 0x802C      STR      R8,[SP, #+44]
   \       0x44   0x9408             STR      R4,[SP, #+32]
   \       0x46   0x9706             STR      R7,[SP, #+24]
   \       0x48   0x9601             STR      R6,[SP, #+4]
   \       0x4A   0x9500             STR      R5,[SP, #+0]
   \       0x4C   0x.... 0x....      BL       sli_se_driver_aead_encrypt_tag
    883          
    884            if (psa_status == PSA_SUCCESS) {
   \       0x50   0xB918             CBNZ.N   R0,??sli_se_driver_aead_encrypt_0
    885              *ciphertext_length += tag_length;
   \       0x52   0x6822             LDR      R2,[R4, #+0]
   \       0x54   0x990C             LDR      R1,[SP, #+48]
   \       0x56   0x188A             ADDS     R2,R1,R2
   \       0x58   0x6022             STR      R2,[R4, #+0]
    886            }
    887          
    888            return psa_status;
   \                     ??sli_se_driver_aead_encrypt_0: (+1)
   \       0x5A   0xB00E             ADD      SP,SP,#+56
   \       0x5C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    889          
    890            #else // SLI_PSA_DRIVER_FEATURE_AEAD
    891          
    892            (void)attributes;
    893            (void)key_buffer;
    894            (void)key_buffer_size;
    895            (void)alg;
    896            (void)nonce;
    897            (void)nonce_length;
    898            (void)additional_data;
    899            (void)additional_data_length;
    900            (void)plaintext;
    901            (void)plaintext_length;
    902            (void)ciphertext;
    903            (void)ciphertext_size;
    904            (void)ciphertext_length;
    905          
    906            return PSA_ERROR_NOT_SUPPORTED;
    907          
    908            #endif // SLI_PSA_DRIVER_FEATURE_AEAD
    909          }
    910          

   \                                 In section .text, align 2, keep-with-next
    911          psa_status_t sli_se_driver_aead_decrypt(const psa_key_attributes_t *attributes,
    912                                                  const uint8_t *key_buffer,
    913                                                  size_t key_buffer_size,
    914                                                  psa_algorithm_t alg,
    915                                                  const uint8_t *nonce,
    916                                                  size_t nonce_length,
    917                                                  const uint8_t *additional_data,
    918                                                  size_t additional_data_length,
    919                                                  const uint8_t *ciphertext,
    920                                                  size_t ciphertext_length,
    921                                                  uint8_t *plaintext,
    922                                                  size_t plaintext_size,
    923                                                  size_t *plaintext_length)
    924          {
   \                     sli_se_driver_aead_decrypt: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x469A             MOV      R10,R3
    925            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD)
    926          
    927            if (attributes == NULL) {
   \        0xE   0xD01B             BEQ.N    ??sli_se_driver_aead_decrypt_0
    928              return PSA_ERROR_INVALID_ARGUMENT;
    929            }
    930          
    931            size_t tag_length = PSA_AEAD_TAG_LENGTH(psa_get_key_type(attributes),
    932                                                    psa_get_key_bits(attributes),
    933                                                    alg);
   \       0x10   0x8820             LDRH     R0,[R4, #+0]
   \       0x12   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x16   0xD11A             BNE.N    ??sli_se_driver_aead_decrypt_1
   \       0x18   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x1C   0xD117             BNE.N    ??sli_se_driver_aead_decrypt_1
   \       0x1E   0xF08A 0x60AA      EOR      R0,R10,#0x5500000
   \       0x22   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x26   0xBF1E             ITTT     NE
   \       0x28   0xF08A 0x60AA      EORNE    R0,R10,#0x5500000
   \       0x2C   0xF480 0x7000      EORNE    R0,R0,#0x200
   \       0x30   0xF430 0x107E      BICSNE   R0,R0,#0x3F8000
   \       0x34   0xD116             BNE.N    ??sli_se_driver_aead_decrypt_2
   \                     ??sli_se_driver_aead_decrypt_3: (+1)
   \       0x36   0xF3CA 0x4605      UBFX     R6,R10,#+16,#+6
   \                     ??sli_se_driver_aead_decrypt_4: (+1)
   \       0x3A   0x9F1D             LDR      R7,[SP, #+116]
    934          
    935            if (ciphertext_length < tag_length
    936                || ciphertext == NULL
    937                || (tag_length > 16)) {
   \       0x3C   0x42B7             CMP      R7,R6
   \       0x3E   0xD303             BCC.N    ??sli_se_driver_aead_decrypt_0
   \       0x40   0x9D1C             LDR      R5,[SP, #+112]
   \       0x42   0xB10D             CBZ.N    R5,??sli_se_driver_aead_decrypt_0
   \       0x44   0x2E10             CMP      R6,#+16
   \       0x46   0xD90F             BLS.N    ??sli_se_driver_aead_decrypt_5
    938              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_decrypt_0: (+1)
   \       0x48   0xF06F 0x0086      MVN      R0,#+134
   \       0x4C   0xE02B             B.N      ??sli_se_driver_aead_decrypt_6
    939            }
   \                     ??sli_se_driver_aead_decrypt_1: (+1)
   \       0x4E   0xF242 0x0104      MOVW     R1,#+8196
   \       0x52   0x4288             CMP      R0,R1
   \       0x54   0xBF02             ITTT     EQ
   \       0x56   0xF08A 0x60A2      EOREQ    R0,R10,#0x5100000
   \       0x5A   0xF480 0x60A0      EOREQ    R0,R0,#0x500
   \       0x5E   0xF430 0x107E      BICSEQ   R0,R0,#0x3F8000
   \       0x62   0xD0E8             BEQ.N    ??sli_se_driver_aead_decrypt_3
   \                     ??sli_se_driver_aead_decrypt_2: (+1)
   \       0x64   0x2600             MOVS     R6,#+0
   \       0x66   0xE7E8             B.N      ??sli_se_driver_aead_decrypt_4
    940          
    941            // Split the tag in its own buffer to avoid potential issues when the
    942            // plaintext buffer extends into the tag area
    943            uint8_t check_tag[16];
    944            memcpy(check_tag, &ciphertext[ciphertext_length - tag_length], tag_length);
   \                     ??sli_se_driver_aead_decrypt_5: (+1)
   \       0x68   0x1BBF             SUBS     R7,R7,R6
   \       0x6A   0x4632             MOV      R2,R6
   \       0x6C   0x19E9             ADDS     R1,R5,R7
   \       0x6E   0xA80B             ADD      R0,SP,#+44
   \       0x70   0x.... 0x....      BL       __aeabi_memcpy
    945          
    946            return sli_se_driver_aead_decrypt_tag(
    947              attributes,
    948              key_buffer,
    949              key_buffer_size,
    950              alg,
    951              nonce,
    952              nonce_length,
    953              additional_data,
    954              additional_data_length,
    955              ciphertext,
    956              ciphertext_length - tag_length,
    957              check_tag,
    958              tag_length,
    959              plaintext,
    960              plaintext_size,
    961              plaintext_length);
   \       0x74   0x9820             LDR      R0,[SP, #+128]
   \       0x76   0x991F             LDR      R1,[SP, #+124]
   \       0x78   0xAA0B             ADD      R2,SP,#+44
   \       0x7A   0x900A             STR      R0,[SP, #+40]
   \       0x7C   0x981E             LDR      R0,[SP, #+120]
   \       0x7E   0x9109             STR      R1,[SP, #+36]
   \       0x80   0x4653             MOV      R3,R10
   \       0x82   0x9008             STR      R0,[SP, #+32]
   \       0x84   0x9607             STR      R6,[SP, #+28]
   \       0x86   0x9206             STR      R2,[SP, #+24]
   \       0x88   0x9705             STR      R7,[SP, #+20]
   \       0x8A   0x991B             LDR      R1,[SP, #+108]
   \       0x8C   0x981A             LDR      R0,[SP, #+104]
   \       0x8E   0x9103             STR      R1,[SP, #+12]
   \       0x90   0x9919             LDR      R1,[SP, #+100]
   \       0x92   0x9002             STR      R0,[SP, #+8]
   \       0x94   0x9818             LDR      R0,[SP, #+96]
   \       0x96   0x9101             STR      R1,[SP, #+4]
   \       0x98   0x9504             STR      R5,[SP, #+16]
   \       0x9A   0x9000             STR      R0,[SP, #+0]
   \       0x9C   0x464A             MOV      R2,R9
   \       0x9E   0x4641             MOV      R1,R8
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x.... 0x....      BL       sli_se_driver_aead_decrypt_tag
   \                     ??sli_se_driver_aead_decrypt_6: (+1)
   \       0xA6   0xB010             ADD      SP,SP,#+64
   \       0xA8   0xE8BD 0x87F0      POP      {R4-R10,PC}
    962          
    963            #else // SLI_PSA_DRIVER_FEATURE_AEAD
    964          
    965            (void)attributes;
    966            (void)key_buffer;
    967            (void)key_buffer_size;
    968            (void)alg;
    969            (void)nonce;
    970            (void)nonce_length;
    971            (void)additional_data;
    972            (void)additional_data_length;
    973            (void)plaintext;
    974            (void)plaintext_size;
    975            (void)plaintext_length;
    976            (void)ciphertext;
    977            (void)ciphertext_length;
    978          
    979            return PSA_ERROR_NOT_SUPPORTED;
    980          
    981            #endif // SLI_PSA_DRIVER_FEATURE_AEAD
    982          }
    983          

   \                                 In section .text, align 2, keep-with-next
    984          psa_status_t sli_se_driver_aead_encrypt_decrypt_setup(
    985            sli_se_driver_aead_operation_t *operation,
    986            const psa_key_attributes_t *attributes,
    987            const uint8_t *key_buffer,
    988            size_t key_buffer_size,
    989            psa_algorithm_t alg,
    990            sl_se_cipher_operation_t operation_direction,
    991            uint8_t *key_storage_buffer,
    992            size_t key_storage_buffer_size,
    993            size_t key_storage_overhead)
    994          {
   \                     sli_se_driver_aead_encrypt_decrypt_setup: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4698             MOV      R8,R3
    995            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
    996          
    997            if (operation == NULL
    998                || attributes == NULL
    999                || key_buffer == NULL) {
   \        0xC   0xF06F 0x0986      MVN      R9,#+134
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2D00             CMPNE    R5,#+0
   \       0x14   0x2E00             CMPNE    R6,#+0
   \       0x16   0xD042             BEQ.N    ??sli_se_driver_aead_encrypt_decrypt_setup_0
   1000              return PSA_ERROR_INVALID_ARGUMENT;
   1001            }
   1002          
   1003            size_t key_bits = psa_get_key_bits(attributes);
   1004            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   1005          
   1006            if (key_buffer_size < key_size) {
   \       0x18   0x8868             LDRH     R0,[R5, #+2]
   \       0x1A   0x1DC0             ADDS     R0,R0,#+7
   \       0x1C   0xEBB8 0x0FD0      CMP      R8,R0, LSR #+3
   \       0x20   0xD33D             BCC.N    ??sli_se_driver_aead_encrypt_decrypt_setup_0
   1007              return PSA_ERROR_INVALID_ARGUMENT;
   1008            }
   1009          
   1010            // Validate key type
   1011            if (psa_get_key_type(attributes) != PSA_KEY_TYPE_AES) {
   \       0x22   0x8828             LDRH     R0,[R5, #+0]
   \       0x24   0xF5B0 0x5F10      CMP      R0,#+9216
   \       0x28   0xD12B             BNE.N    ??sli_se_driver_aead_encrypt_decrypt_setup_1
   \       0x2A   0x9F08             LDR      R7,[SP, #+32]
   1012              return PSA_ERROR_NOT_SUPPORTED;
   1013            }
   1014          
   1015            // Validate tag length.
   1016            if ( PSA_AEAD_TAG_LENGTH(psa_get_key_type(attributes), key_bits, alg) > 16 ) {
   \       0x2C   0xF087 0x60AA      EOR      R0,R7,#0x5500000
   \       0x30   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x34   0xBF1E             ITTT     NE
   \       0x36   0xF087 0x60AA      EORNE    R0,R7,#0x5500000
   \       0x3A   0xF480 0x7000      EORNE    R0,R0,#0x200
   \       0x3E   0xF430 0x107E      BICSNE   R0,R0,#0x3F8000
   \       0x42   0xD103             BNE.N    ??sli_se_driver_aead_encrypt_decrypt_setup_2
   \       0x44   0xF3C7 0x4005      UBFX     R0,R7,#+16,#+6
   \       0x48   0x2811             CMP      R0,#+17
   \       0x4A   0xD228             BCS.N    ??sli_se_driver_aead_encrypt_decrypt_setup_0
   1017              return PSA_ERROR_INVALID_ARGUMENT;
   1018            }
   1019          
   1020            // Reset context
   1021            memset(operation, 0, sizeof(*operation));
   \                     ??sli_se_driver_aead_encrypt_decrypt_setup_2: (+1)
   \       0x4C   0x2180             MOVS     R1,#+128
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x.... 0x....      BL       __aeabi_memclr4
   1022          
   1023            // Validate operation
   1024            switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0)) {
   \       0x54   0xF427 0x127E      BIC      R2,R7,#0x3F8000
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x5C   0x4282             CMP      R2,R0
   \       0x5E   0xD110             BNE.N    ??sli_se_driver_aead_encrypt_decrypt_setup_1
   1025              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
   1026              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
   1027                operation->alg = alg;
   1028                break;
   1029              #endif
   1030          
   1031              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
   1032              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
   1033                operation->alg = alg;
   \       0x60   0x6027             STR      R7,[R4, #+0]
   1034                break;
   1035              #endif
   1036          
   1037              default:
   1038                return PSA_ERROR_NOT_SUPPORTED;
   1039            }
   1040          
   1041            // Prepare key descriptor
   1042            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
   1043                                                                 key_buffer,
   1044                                                                 key_buffer_size,
   1045                                                                 &(operation->key_desc));
   \       0x62   0x1D23             ADDS     R3,R4,#+4
   \       0x64   0x4642             MOV      R2,R8
   \       0x66   0x4631             MOV      R1,R6
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x.... 0x....      BL       sli_se_key_desc_from_input
   1046            if (psa_status != PSA_SUCCESS) {
   \       0x6E   0xBB10             CBNZ.N   R0,??sli_se_driver_aead_encrypt_decrypt_setup_3
   1047              return psa_status;
   1048            }
   1049          
   1050            // Verify length and copy key material to context
   1051            uint32_t key_len = 0;
   \       0x70   0x9000             STR      R0,[SP, #+0]
   1052            sl_status_t status = sli_key_get_size(&(operation->key_desc), &key_len);
   1053            if (status != SL_STATUS_OK) {
   \       0x72   0x4669             MOV      R1,SP
   \       0x74   0x1D20             ADDS     R0,R4,#+4
   \       0x76   0x.... 0x....      BL       sli_key_get_size
   \       0x7A   0xB128             CBZ.N    R0,??sli_se_driver_aead_encrypt_decrypt_setup_4
   1054              return PSA_ERROR_HARDWARE_FAILURE;
   \       0x7C   0xF06F 0x0092      MVN      R0,#+146
   \       0x80   0xE019             B.N      ??sli_se_driver_aead_encrypt_decrypt_setup_3
   1055            }
   \                     ??sli_se_driver_aead_encrypt_decrypt_setup_1: (+1)
   \       0x82   0xF06F 0x0085      MVN      R0,#+133
   \       0x86   0xE016             B.N      ??sli_se_driver_aead_encrypt_decrypt_setup_3
   1056          
   1057            switch (key_len) {
   \                     ??sli_se_driver_aead_encrypt_decrypt_setup_4: (+1)
   \       0x88   0x9800             LDR      R0,[SP, #+0]
   \       0x8A   0x2810             CMP      R0,#+16
   \       0x8C   0xBF1C             ITT      NE
   \       0x8E   0x2818             CMPNE    R0,#+24
   \       0x90   0x2820             CMPNE    R0,#+32
   \       0x92   0xD104             BNE.N    ??sli_se_driver_aead_encrypt_decrypt_setup_0
   \       0x94   0x9A0C             LDR      R2,[SP, #+48]
   \       0x96   0x990B             LDR      R1,[SP, #+44]
   1058              case 16:   // Fallthrough
   1059              case 24:   // Fallthrough
   1060              case 32:
   1061                break;
   1062              default:
   1063                return PSA_ERROR_INVALID_ARGUMENT;
   1064            }
   1065          
   1066            if (key_storage_buffer_size < key_storage_overhead + key_len) {
   \       0x98   0x1882             ADDS     R2,R0,R2
   \       0x9A   0x4291             CMP      R1,R2
   \       0x9C   0xD201             BCS.N    ??sli_se_driver_aead_encrypt_decrypt_setup_5
   \                     ??sli_se_driver_aead_encrypt_decrypt_setup_0: (+1)
   \       0x9E   0x4648             MOV      R0,R9
   \       0xA0   0xE009             B.N      ??sli_se_driver_aead_encrypt_decrypt_setup_3
   \                     ??sli_se_driver_aead_encrypt_decrypt_setup_5: (+1)
   \       0xA2   0x9E0A             LDR      R6,[SP, #+40]
   1067              return PSA_ERROR_INVALID_ARGUMENT;
   1068            }
   1069            memcpy(key_storage_buffer,
   1070                   operation->key_desc.storage.location.buffer.pointer,
   1071                   key_storage_overhead + key_len);
   \       0xA4   0x6961             LDR      R1,[R4, #+20]
   \       0xA6   0x9D09             LDR      R5,[SP, #+36]
   \       0xA8   0x4630             MOV      R0,R6
   \       0xAA   0x.... 0x....      BL       __aeabi_memcpy
   1072          
   1073            // Point key_descriptor at internal copy of key
   1074            operation->key_desc.storage.location.buffer.pointer = key_storage_buffer;
   \       0xAE   0x6166             STR      R6,[R4, #+20]
   1075          
   1076            // Set direction of operation
   1077            operation->ctx.preinit.direction = operation_direction;
   \       0xB0   0xF884 0x5030      STRB     R5,[R4, #+48]
   1078            return PSA_SUCCESS;
   \       0xB4   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_aead_encrypt_decrypt_setup_3: (+1)
   \       0xB6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1079          
   1080            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1081          
   1082            (void)operation;
   1083            (void)attributes;
   1084            (void)key_buffer;
   1085            (void)key_buffer_size;
   1086            (void)alg;
   1087            (void)operation_direction;
   1088            (void)key_storage_buffer;
   1089            (void)key_storage_buffer_size;
   1090            (void)key_storage_overhead;
   1091          
   1092            return PSA_ERROR_NOT_SUPPORTED;
   1093          
   1094            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1095          }
   1096          

   \                                 In section .text, align 2, keep-with-next
   1097          psa_status_t sli_se_driver_aead_set_nonce(
   1098            sli_se_driver_aead_operation_t *operation,
   1099            const uint8_t *nonce,
   1100            size_t nonce_size)
   1101          {
   \                     sli_se_driver_aead_set_nonce: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x4615             MOV      R5,R2
   1102            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
   1103          
   1104            if (operation == NULL
   1105                || nonce == NULL) {
   \        0x6   0xF06F 0x0086      MVN      R0,#+134
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2900             CMPNE    R1,#+0
   \        0xE   0xD00D             BEQ.N    ??sli_se_driver_aead_set_nonce_0
   1106              return PSA_ERROR_INVALID_ARGUMENT;
   1107            }
   1108          
   1109            // Setting nonce twice isn't supported
   1110            if (operation->ctx.preinit.nonce_length != 0) {
   \       0x10   0x6CE2             LDR      R2,[R4, #+76]
   \       0x12   0xB112             CBZ.N    R2,??sli_se_driver_aead_set_nonce_1
   1111              return PSA_ERROR_BAD_STATE;
   \       0x14   0xF06F 0x0088      MVN      R0,#+136
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
   1112            }
   1113          
   1114            #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
   1115            // Non-12-byte IV is not supported for multipart GCM
   1116            if (PSA_ALG_AEAD_WITH_SHORTENED_TAG(operation->alg, 0)
   1117                == PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0)) {
   1118              if (nonce_size != 12) {
   1119                return PSA_ERROR_NOT_SUPPORTED;
   1120              }
   1121            }
   1122            #endif
   1123          
   1124            if (nonce_size <= sizeof(operation->ctx.preinit.nonce)) {
   \                     ??sli_se_driver_aead_set_nonce_1: (+1)
   \       0x1A   0x2D11             CMP      R5,#+17
   \       0x1C   0xD206             BCS.N    ??sli_se_driver_aead_set_nonce_0
   1125              memcpy(operation->ctx.preinit.nonce, nonce, nonce_size);
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0xF104 0x003C      ADD      R0,R4,#+60
   \       0x24   0x.... 0x....      BL       __aeabi_memcpy
   1126              operation->ctx.preinit.nonce_length = nonce_size;
   \       0x28   0x64E5             STR      R5,[R4, #+76]
   1127              return PSA_SUCCESS;
   \       0x2A   0x2000             MOVS     R0,#+0
   1128            } else {
   1129              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_set_nonce_0: (+1)
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
   1130            }
   1131          
   1132            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1133          
   1134            (void)operation;
   1135            (void)nonce;
   1136            (void)nonce_size;
   1137          
   1138            return PSA_ERROR_NOT_SUPPORTED;
   1139          
   1140            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1141          }
   1142          

   \                                 In section .text, align 2, keep-with-next
   1143          psa_status_t sli_se_driver_aead_set_lengths(
   1144            sli_se_driver_aead_operation_t *operation,
   1145            size_t ad_length,
   1146            size_t plaintext_length)
   1147          {
   \                     sli_se_driver_aead_set_lengths: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1148            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
   1149          
   1150            if (operation == NULL) {
   \        0x2   0xB170             CBZ.N    R0,??sli_se_driver_aead_set_lengths_0
   1151              return PSA_ERROR_INVALID_ARGUMENT;
   1152            }
   1153          
   1154            // To pass current PSA Crypto test suite, tag length encoded in the
   1155            // algorithm needs to be checked at this point.
   1156            switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(operation->alg, 0)) {
   \        0x4   0x6804             LDR      R4,[R0, #+0]
   \        0x6   0x.... 0x....      LDR.W    R3,??DataTable11
   \        0xA   0xF424 0x157E      BIC      R5,R4,#0x3F8000
   \        0xE   0x429D             CMP      R5,R3
   \       0x10   0xD110             BNE.N    ??sli_se_driver_aead_set_lengths_1
   1157              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
   1158                if ((PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg) % 2 != 0)
   1159                    || PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg) < 4
   1160                    || PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg) > 16) {
   \       0x12   0xF3C4 0x4300      UBFX     R3,R4,#+16,#+1
   \       0x16   0xB923             CBNZ.N   R3,??sli_se_driver_aead_set_lengths_0
   \       0x18   0xF3C4 0x4305      UBFX     R3,R4,#+16,#+6
   \       0x1C   0x1F1B             SUBS     R3,R3,#+4
   \       0x1E   0x2B0D             CMP      R3,#+13
   \       0x20   0xD302             BCC.N    ??sli_se_driver_aead_set_lengths_2
   1161                  return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_set_lengths_0: (+1)
   \       0x22   0xF06F 0x0086      MVN      R0,#+134
   \       0x26   0xBD30             POP      {R4,R5,PC}
   1162                }
   1163                break;
   1164          
   1165                #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
   1166              case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
   1167                if (PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg) < 4
   1168                    || PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg) > 16) {
   1169                  return PSA_ERROR_INVALID_ARGUMENT;
   1170                }
   1171                break;
   1172                #endif
   1173          
   1174              default:
   1175                return PSA_ERROR_BAD_STATE;
   1176            }
   1177          
   1178            if (operation->ad_len != 0 || operation->pt_len != 0) {
   \                     ??sli_se_driver_aead_set_lengths_2: (+1)
   \       0x28   0x6A43             LDR      R3,[R0, #+36]
   \       0x2A   0x2B00             CMP      R3,#+0
   \       0x2C   0xBF04             ITT      EQ
   \       0x2E   0x6A83             LDREQ    R3,[R0, #+40]
   \       0x30   0x2B00             CMPEQ    R3,#+0
   \       0x32   0xD002             BEQ.N    ??sli_se_driver_aead_set_lengths_3
   1179              return PSA_ERROR_BAD_STATE;
   \                     ??sli_se_driver_aead_set_lengths_1: (+1)
   \       0x34   0xF06F 0x0088      MVN      R0,#+136
   \       0x38   0xBD30             POP      {R4,R5,PC}
   1180            }
   1181          
   1182            operation->ctx.preinit.ad_length = ad_length;
   \                     ??sli_se_driver_aead_set_lengths_3: (+1)
   \       0x3A   0x6341             STR      R1,[R0, #+52]
   1183            operation->ctx.preinit.pt_length = plaintext_length;
   \       0x3C   0x6382             STR      R2,[R0, #+56]
   1184          
   1185            return PSA_SUCCESS;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD30             POP      {R4,R5,PC}
   1186          
   1187            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1188          
   1189            (void)operation;
   1190            (void)ad_length;
   1191            (void)plaintext_length;
   1192          
   1193            return PSA_ERROR_NOT_SUPPORTED;
   1194          
   1195            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1196          }
   1197          

   \                                 In section .text, align 2, keep-with-next
   1198          psa_status_t sli_se_driver_aead_update_ad(
   1199            sli_se_driver_aead_operation_t *operation,
   1200            uint8_t *key_buffer,
   1201            const uint8_t *input,
   1202            size_t input_length)
   1203          {
   \                     sli_se_driver_aead_update_ad: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4614             MOV      R4,R2
   \        0x4   0x461A             MOV      R2,R3
   1204            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
   1205          
   1206            if (operation == NULL
   1207                || key_buffer == NULL
   1208                || (input == NULL && input_length > 0)) {
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xBF18             IT       NE
   \        0xA   0x2900             CMPNE    R1,#+0
   \        0xC   0xD001             BEQ.N    ??sli_se_driver_aead_update_ad_0
   \        0xE   0xB91C             CBNZ.N   R4,??sli_se_driver_aead_update_ad_1
   \       0x10   0xB112             CBZ.N    R2,??sli_se_driver_aead_update_ad_1
   1209              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_update_ad_0: (+1)
   \       0x12   0xF06F 0x0086      MVN      R0,#+134
   \       0x16   0xBD10             POP      {R4,PC}
   1210            }
   1211          
   1212            if (operation->alg == 0) {
   \                     ??sli_se_driver_aead_update_ad_1: (+1)
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xB129             CBZ.N    R1,??sli_se_driver_aead_update_ad_2
   1213              return PSA_ERROR_BAD_STATE;
   1214            }
   1215          
   1216            if (operation->ad_len > 0 || operation->pt_len > 0) {
   \       0x1C   0x6A41             LDR      R1,[R0, #+36]
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xBF04             ITT      EQ
   \       0x22   0x6A81             LDREQ    R1,[R0, #+40]
   \       0x24   0x2900             CMPEQ    R1,#+0
   \       0x26   0xD002             BEQ.N    ??sli_se_driver_aead_update_ad_3
   1217              return PSA_ERROR_BAD_STATE;
   \                     ??sli_se_driver_aead_update_ad_2: (+1)
   \       0x28   0xF06F 0x0088      MVN      R0,#+136
   \       0x2C   0xBD10             POP      {R4,PC}
   1218            }
   1219          
   1220            // Start operation
   1221            if (input_length == 0) {
   \                     ??sli_se_driver_aead_update_ad_3: (+1)
   \       0x2E   0xB90A             CBNZ.N   R2,??sli_se_driver_aead_update_ad_4
   1222              return PSA_SUCCESS;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD10             POP      {R4,PC}
   1223            }
   1224          
   1225            return aead_start(operation, input, input_length);
   \                     ??sli_se_driver_aead_update_ad_4: (+1)
   \       0x34   0x4621             MOV      R1,R4
   \       0x36   0xE8BD 0x4010      POP      {R4,LR}
   \       0x3A   0x....             B.N      aead_start
   1226          
   1227            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1228          
   1229            (void)operation;
   1230            (void)key_buffer;
   1231            (void)input;
   1232            (void)input_length;
   1233          
   1234            return PSA_ERROR_NOT_SUPPORTED;
   1235          
   1236            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1237          }
   1238          

   \                                 In section .text, align 2, keep-with-next
   1239          psa_status_t sli_se_driver_aead_update(sli_se_driver_aead_operation_t *operation,
   1240                                                 uint8_t *key_buffer,
   1241                                                 const uint8_t *input,
   1242                                                 size_t input_length,
   1243                                                 uint8_t *output,
   1244                                                 size_t output_size,
   1245                                                 size_t *output_length)
   1246          {
   \                     sli_se_driver_aead_update: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461C             MOV      R4,R3
   1247            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
   1248          
   1249            (void)key_buffer;
   1250            sl_status_t status;
   1251          
   1252            sl_se_command_context_t cmd_ctx = { 0 };
   \        0xC   0xA803             ADD      R0,SP,#+12
   \        0xE   0x.... 0x....      BL       ??Subroutine4_0
   1253          
   1254            status = sl_se_init_command_context(&cmd_ctx);
   1255            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x12   0xA803             ADD      R0,SP,#+12
   \       0x14   0x.... 0x....      BL       sl_se_init_command_context
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD14C             BNE.N    ??sli_se_driver_aead_update_0
   \       0x1C   0x9815             LDR      R0,[SP, #+84]
   1256              return PSA_ERROR_HARDWARE_FAILURE;
   1257            }
   1258          
   1259            if (output_size < input_length) {
   \       0x1E   0x42A0             CMP      R0,R4
   \       0x20   0xBF38             IT       CC
   \       0x22   0xF06F 0x0089      MVNCC    R0,#+137
   1260              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x26   0xD34F             BCC.N    ??sli_se_driver_aead_update_1
   1261            }
   1262          
   1263            if (operation == NULL
   1264                || ((input == NULL || output == NULL) && input_length > 0)
   1265                || output_length == NULL) {
   \       0x28   0xB145             CBZ.N    R5,??sli_se_driver_aead_update_2
   \       0x2A   0x9F14             LDR      R7,[SP, #+80]
   \       0x2C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x30   0xBF18             IT       NE
   \       0x32   0x2F00             CMPNE    R7,#+0
   \       0x34   0xD100             BNE.N    ??sli_se_driver_aead_update_3
   \       0x36   0xB90C             CBNZ.N   R4,??sli_se_driver_aead_update_2
   \                     ??sli_se_driver_aead_update_3: (+1)
   \       0x38   0x9E16             LDR      R6,[SP, #+88]
   \       0x3A   0xB916             CBNZ.N   R6,??sli_se_driver_aead_update_4
   1266              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_aead_update_2: (+1)
   \       0x3C   0xF06F 0x0086      MVN      R0,#+134
   \       0x40   0xE042             B.N      ??sli_se_driver_aead_update_1
   1267            }
   1268          
   1269            if (operation->alg == 0) {
   \                     ??sli_se_driver_aead_update_4: (+1)
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0xB910             CBNZ.N   R0,??sli_se_driver_aead_update_5
   1270              return PSA_ERROR_BAD_STATE;
   \       0x46   0xF06F 0x0088      MVN      R0,#+136
   \       0x4A   0xE03D             B.N      ??sli_se_driver_aead_update_1
   1271            }
   1272          
   1273            // Start operation
   1274            if (input_length == 0) {
   \                     ??sli_se_driver_aead_update_5: (+1)
   \       0x4C   0xB90C             CBNZ.N   R4,??sli_se_driver_aead_update_6
   1275              return PSA_SUCCESS;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE03A             B.N      ??sli_se_driver_aead_update_1
   1276            }
   1277          
   1278            psa_algorithm_t alg = PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(operation->alg);
   \                     ??sli_se_driver_aead_update_6: (+1)
   \       0x52   0xF420 0x117E      BIC      R1,R0,#0x3F8000
   \       0x56   0x....             LDR.N    R3,??DataTable11
   \       0x58   0x.... 0x....      LDR.W    R10,??DataTable11_1
   \       0x5C   0x4299             CMP      R1,R3
   \       0x5E   0xBF08             IT       EQ
   \       0x60   0x46D1             MOVEQ    R9,R10
   \       0x62   0xD00E             BEQ.N    ??sli_se_driver_aead_update_7
   \       0x64   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x68   0xBF08             IT       EQ
   \       0x6A   0x.... 0x....      LDREQ.W  R9,??DataTable11_2
   \       0x6E   0xD008             BEQ.N    ??sli_se_driver_aead_update_7
   \       0x70   0xF420 0x107E      BIC      R0,R0,#0x3F8000
   \       0x74   0xF1B0 0x2F05      CMP      R0,#+83887360
   \       0x78   0xBF0C             ITE      EQ
   \       0x7A   0x.... 0x....      LDREQ.W  R9,??DataTable11_3
   \       0x7E   0xF04F 0x0900      MOVNE    R9,#+0
   1279          
   1280            psa_status_t psa_status;
   1281          
   1282            // Operation isn't initialised unless we have either AD or PT, so if we are
   1283            // still at 0, we need to run the start step.
   1284            if (operation->ad_len == 0 && operation->pt_len == 0) {
   \                     ??sli_se_driver_aead_update_7: (+1)
   \       0x82   0x6A68             LDR      R0,[R5, #+36]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xBF04             ITT      EQ
   \       0x88   0x6AA8             LDREQ    R0,[R5, #+40]
   \       0x8A   0x2800             CMPEQ    R0,#+0
   \       0x8C   0xD105             BNE.N    ??sli_se_driver_aead_update_8
   1285              psa_status = aead_start(operation, NULL, 0);
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0x4628             MOV      R0,R5
   \       0x94   0x.... 0x....      BL       aead_start
   1286              if (psa_status != PSA_SUCCESS) {
   \       0x98   0xB9B0             CBNZ.N   R0,??sli_se_driver_aead_update_1
   1287                return psa_status;
   1288              }
   1289            }
   1290          
   1291            switch (alg) {
   \                     ??sli_se_driver_aead_update_8: (+1)
   \       0x9A   0x45D1             CMP      R9,R10
   \       0x9C   0xD112             BNE.N    ??sli_se_driver_aead_update_9
   1292              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
   1293              case PSA_ALG_GCM:
   1294              {
   1295                status = sl_se_gcm_multipart_update(&operation->ctx.gcm,
   1296                                                    &cmd_ctx,
   1297                                                    &operation->key_desc,
   1298                                                    input_length,
   1299                                                    input,
   1300                                                    output,
   1301                                                    output_length);
   1302                if (status != SL_STATUS_OK) {
   1303                  return PSA_ERROR_HARDWARE_FAILURE;
   1304                }
   1305                psa_status = PSA_SUCCESS;
   1306                operation->pt_len += input_length;
   1307                break;
   1308              }
   1309              #endif   // SLI_PSA_DRIVER_FEATURE_GCM
   1310          
   1311              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
   1312              case PSA_ALG_CCM:
   1313              {
   1314                status = sl_se_ccm_multipart_update(&operation->ctx.ccm,
   1315                                                    &cmd_ctx,
   1316                                                    &operation->key_desc,
   1317                                                    input_length,
   1318                                                    input,
   1319                                                    output,
   1320                                                    output_length);
   1321                if (status != SL_STATUS_OK) {
   \       0x9E   0x9602             STR      R6,[SP, #+8]
   \       0xA0   0x9701             STR      R7,[SP, #+4]
   \       0xA2   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xA6   0x4623             MOV      R3,R4
   \       0xA8   0x1D2A             ADDS     R2,R5,#+4
   \       0xAA   0xA903             ADD      R1,SP,#+12
   \       0xAC   0xF105 0x0030      ADD      R0,R5,#+48
   \       0xB0   0x.... 0x....      BL       sl_se_ccm_multipart_update
   \       0xB4   0xB110             CBZ.N    R0,??sli_se_driver_aead_update_10
   1322                  return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_aead_update_0: (+1)
   \       0xB6   0xF06F 0x0092      MVN      R0,#+146
   \       0xBA   0xE005             B.N      ??sli_se_driver_aead_update_1
   1323                }
   1324                psa_status = PSA_SUCCESS;
   1325                operation->pt_len += input_length;
   \                     ??sli_se_driver_aead_update_10: (+1)
   \       0xBC   0x6AA9             LDR      R1,[R5, #+40]
   \       0xBE   0x1864             ADDS     R4,R4,R1
   \       0xC0   0x62AC             STR      R4,[R5, #+40]
   1326                break;
   \       0xC2   0xE001             B.N      ??sli_se_driver_aead_update_1
   1327              }
   1328              #endif   // SLI_PSA_DRIVER_FEATURE_CCM
   1329          
   1330              default:
   1331                psa_status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_aead_update_9: (+1)
   \       0xC4   0xF06F 0x0085      MVN      R0,#+133
   1332                break;
   1333            }
   1334          
   1335            return psa_status;
   \                     ??sli_se_driver_aead_update_1: (+1)
   \       0xC8   0xB00C             ADD      SP,SP,#+48
   \       0xCA   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1336          
   1337            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1338          
   1339            (void)operation;
   1340            (void)key_buffer;
   1341            (void)input;
   1342            (void)input_length;
   1343            (void)output;
   1344            (void)output_size;
   1345            (void)output_length;
   1346          
   1347            return PSA_ERROR_NOT_SUPPORTED;
   1348          
   1349            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1350          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xF420 0x127E      BIC      R2,R0,#0x3F8000
   \        0x4   0x....             LDR.N    R1,??DataTable11_4
   \        0x6   0x428A             CMP      R2,R1
   \        0x8   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1351          

   \                                 In section .text, align 2, keep-with-next
   1352          psa_status_t sli_se_driver_aead_finish(sli_se_driver_aead_operation_t *operation,
   1353                                                 uint8_t *key_buffer,
   1354                                                 uint8_t *ciphertext,
   1355                                                 size_t ciphertext_size,
   1356                                                 size_t *ciphertext_length,
   1357                                                 uint8_t *tag,
   1358                                                 size_t tag_size,
   1359                                                 size_t *tag_length)
   1360          {
   \                     sli_se_driver_aead_finish: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08E             SUB      SP,SP,#+56
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461E             MOV      R6,R3
   1361            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
   1362          
   1363            (void)key_buffer;
   1364          
   1365            sl_status_t status;
   1366            psa_status_t psa_status;
   1367          
   1368            sl_se_command_context_t cmd_ctx = { 0 };
   \        0xC   0xA805             ADD      R0,SP,#+20
   \        0xE   0x.... 0x....      BL       ??Subroutine4_0
   1369          
   1370            if (operation == NULL) {
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x12   0xF06F 0x0886      MVN      R8,#+134
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD067             BEQ.N    ??sli_se_driver_aead_finish_0
   1371              return PSA_ERROR_INVALID_ARGUMENT;
   1372            }
   1373          
   1374            uint32_t tag_len = PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg);
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x981A             LDR      R0,[SP, #+104]
   \       0x1E   0xF3C1 0x4105      UBFX     R1,R1,#+16,#+6
   \       0x22   0x9104             STR      R1,[SP, #+16]
   1375          
   1376            if (tag_size < tag_len) {
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xBF38             IT       CC
   \       0x28   0xF06F 0x0089      MVNCC    R0,#+137
   1377              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x2C   0xD35E             BCC.N    ??sli_se_driver_aead_finish_1
   \       0x2E   0x9D18             LDR      R5,[SP, #+96]
   1378            }
   1379          
   1380            if (ciphertext_length == NULL
   1381                || tag == NULL
   1382                || tag_length == NULL) {
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xBF1F             ITTTT    NE
   \       0x34   0x9819             LDRNE    R0,[SP, #+100]
   \       0x36   0x2800             CMPNE    R0,#+0
   \       0x38   0x981B             LDRNE    R0,[SP, #+108]
   \       0x3A   0x2800             CMPNE    R0,#+0
   \       0x3C   0xD055             BEQ.N    ??sli_se_driver_aead_finish_0
   1383              return PSA_ERROR_INVALID_ARGUMENT;
   1384            }
   1385          
   1386            *ciphertext_length = 0;
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x6029             STR      R1,[R5, #+0]
   1387          
   1388            if (operation->alg == 0) {
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0xB910             CBNZ.N   R0,??sli_se_driver_aead_finish_2
   1389              return PSA_ERROR_BAD_STATE;
   \       0x46   0xF06F 0x0088      MVN      R0,#+136
   \       0x4A   0xE04F             B.N      ??sli_se_driver_aead_finish_1
   1390            }
   1391          
   1392            // Operation isn't initialised unless we have either AD or PT, so  if we are
   1393            // still at 0, we need to run the start step.
   1394            if (operation->ad_len == 0 && operation->pt_len == 0) {
   \                     ??sli_se_driver_aead_finish_2: (+1)
   \       0x4C   0x6A60             LDR      R0,[R4, #+36]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xBF04             ITT      EQ
   \       0x52   0x6AA0             LDREQ    R0,[R4, #+40]
   \       0x54   0x2800             CMPEQ    R0,#+0
   \       0x56   0xD105             BNE.N    ??sli_se_driver_aead_finish_3
   1395              psa_status = aead_start(operation, NULL, 0);
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x.... 0x....      BL       aead_start
   1396              if (psa_status != PSA_SUCCESS) {
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD143             BNE.N    ??sli_se_driver_aead_finish_1
   1397                return psa_status;
   1398              }
   1399            }
   1400          
   1401            psa_algorithm_t alg = PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(operation->alg);
   \                     ??sli_se_driver_aead_finish_3: (+1)
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x....             LDR.N    R3,??DataTable11
   \       0x68   0x.... 0x....      LDR.W    R11,??DataTable11_1
   \       0x6C   0xF420 0x117E      BIC      R1,R0,#0x3F8000
   \       0x70   0x4299             CMP      R1,R3
   \       0x72   0xBF08             IT       EQ
   \       0x74   0x46DA             MOVEQ    R10,R11
   \       0x76   0xD00E             BEQ.N    ??sli_se_driver_aead_finish_4
   \       0x78   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x7C   0xBF08             IT       EQ
   \       0x7E   0x.... 0x....      LDREQ.W  R10,??DataTable11_2
   \       0x82   0xD008             BEQ.N    ??sli_se_driver_aead_finish_4
   \       0x84   0xF420 0x107E      BIC      R0,R0,#0x3F8000
   \       0x88   0xF1B0 0x2F05      CMP      R0,#+83887360
   \       0x8C   0xBF0C             ITE      EQ
   \       0x8E   0x.... 0x....      LDREQ.W  R10,??DataTable11_3
   \       0x92   0xF04F 0x0A00      MOVNE    R10,#+0
   1402          
   1403            status = sl_se_init_command_context(&cmd_ctx);
   1404            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_aead_finish_4: (+1)
   \       0x96   0xA805             ADD      R0,SP,#+20
   \       0x98   0xF06F 0x0992      MVN      R9,#+146
   \       0x9C   0x.... 0x....      BL       sl_se_init_command_context
   \       0xA0   0xBB08             CBNZ.N   R0,??sli_se_driver_aead_finish_5
   1405              return PSA_ERROR_HARDWARE_FAILURE;
   1406            }
   1407          
   1408            switch (alg) {
   \       0xA2   0x45DA             CMP      R10,R11
   \       0xA4   0xD119             BNE.N    ??sli_se_driver_aead_finish_6
   1409              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
   1410              case PSA_ALG_GCM:
   1411                if (operation->ctx.gcm.mode != SL_SE_ENCRYPT) {
   1412                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
   1413                  goto exit;
   1414                }
   1415                status = sl_se_gcm_multipart_finish(&operation->ctx.gcm,
   1416                                                    &cmd_ctx,
   1417                                                    &operation->key_desc,
   1418                                                    tag,
   1419                                                    tag_len,
   1420                                                    ciphertext,
   1421                                                    ciphertext_size,
   1422                                                    (uint8_t *)ciphertext_length);
   1423                if (status != SL_STATUS_OK) {
   1424                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1425                  goto exit;
   1426                }
   1427                *tag_length = tag_len;
   1428                psa_status = PSA_SUCCESS;
   1429                break;
   1430              #endif   // SLI_PSA_DRIVER_FEATURE_GCM
   1431          
   1432              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
   1433              case PSA_ALG_CCM:
   1434                if (operation->ctx.ccm.mode != SL_SE_ENCRYPT) {
   \       0xA6   0xF894 0x004C      LDRB     R0,[R4, #+76]
   \       0xAA   0xB9C0             CBNZ.N   R0,??sli_se_driver_aead_finish_7
   1435                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
   1436                  goto exit;
   1437                }
   1438                status = sl_se_ccm_multipart_finish(&operation->ctx.ccm,
   1439                                                    &cmd_ctx,
   1440                                                    &operation->key_desc,
   1441                                                    tag,
   1442                                                    tag_len,
   1443                                                    ciphertext,
   1444                                                    ciphertext_size,
   1445                                                    (uint8_t *)ciphertext_length);
   1446          
   1447                if (status != SL_STATUS_OK) {
   \       0xAC   0x9804             LDR      R0,[SP, #+16]
   \       0xAE   0x9B19             LDR      R3,[SP, #+100]
   \       0xB0   0xB2F6             UXTB     R6,R6
   \       0xB2   0xB2C0             UXTB     R0,R0
   \       0xB4   0x9000             STR      R0,[SP, #+0]
   \       0xB6   0x9503             STR      R5,[SP, #+12]
   \       0xB8   0x9602             STR      R6,[SP, #+8]
   \       0xBA   0x9701             STR      R7,[SP, #+4]
   \       0xBC   0x1D22             ADDS     R2,R4,#+4
   \       0xBE   0xA905             ADD      R1,SP,#+20
   \       0xC0   0xF104 0x0030      ADD      R0,R4,#+48
   \       0xC4   0x.... 0x....      BL       sl_se_ccm_multipart_finish
   \       0xC8   0xB108             CBZ.N    R0,??sli_se_driver_aead_finish_8
   1448                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
   \       0xCA   0x46C8             MOV      R8,R9
   1449                  goto exit;
   \       0xCC   0xE007             B.N      ??sli_se_driver_aead_finish_7
   1450                }
   1451                *tag_length = operation->ctx.ccm.tag_len;
   \                     ??sli_se_driver_aead_finish_8: (+1)
   \       0xCE   0x6CA1             LDR      R1,[R4, #+72]
   \       0xD0   0x981B             LDR      R0,[SP, #+108]
   1452                psa_status = PSA_SUCCESS;
   \       0xD2   0xF04F 0x0800      MOV      R8,#+0
   \       0xD6   0x6001             STR      R1,[R0, #+0]
   1453                break;
   \       0xD8   0xE001             B.N      ??sli_se_driver_aead_finish_7
   1454              #endif   // SLI_PSA_DRIVER_FEATURE_CCM
   1455          
   1456              default:
   1457                (void)tag_size;
   1458                psa_status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_aead_finish_6: (+1)
   \       0xDA   0xF06F 0x0885      MVN      R8,#+133
   1459                goto exit;
   1460            }
   1461          
   1462            exit:
   1463          
   1464            status = sl_se_deinit_command_context(&cmd_ctx);
   1465            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_aead_finish_7: (+1)
   \       0xDE   0xA805             ADD      R0,SP,#+20
   \       0xE0   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xE4   0xB108             CBZ.N    R0,??sli_se_driver_aead_finish_0
   1466              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_aead_finish_5: (+1)
   \       0xE6   0x4648             MOV      R0,R9
   \       0xE8   0xE000             B.N      ??sli_se_driver_aead_finish_1
   1467            }
   1468          
   1469            return psa_status;
   \                     ??sli_se_driver_aead_finish_0: (+1)
   \       0xEA   0x4640             MOV      R0,R8
   \                     ??sli_se_driver_aead_finish_1: (+1)
   \       0xEC   0xB00F             ADD      SP,SP,#+60
   \       0xEE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1470          
   1471            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1472          
   1473            (void)operation;
   1474            (void)key_buffer;
   1475            (void)ciphertext;
   1476            (void)ciphertext_size;
   1477            (void)ciphertext_length;
   1478            (void)tag;
   1479            (void)tag_size;
   1480            (void)tag_length;
   1481          
   1482            return PSA_ERROR_NOT_SUPPORTED;
   1483          
   1484            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1485          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4
   1486          

   \                                 In section .text, align 2, keep-with-next
   1487          psa_status_t sli_se_driver_aead_verify(sli_se_driver_aead_operation_t *operation,
   1488                                                 uint8_t *key_buffer,
   1489                                                 uint8_t *plaintext,
   1490                                                 size_t plaintext_size,
   1491                                                 size_t *plaintext_length,
   1492                                                 const uint8_t *tag,
   1493                                                 size_t tag_length)
   1494          {
   \                     sli_se_driver_aead_verify: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   1495            #if defined(SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART)
   1496          
   1497            (void)key_buffer;
   1498          
   1499            sl_status_t status;
   1500            psa_status_t psa_status;
   1501          
   1502            sl_se_command_context_t cmd_ctx = { 0 };
   \        0xC   0xA804             ADD      R0,SP,#+16
   \        0xE   0x.... 0x....      BL       ??Subroutine4_0
   1503          
   1504            if (operation == NULL || plaintext_length == NULL) {
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x12   0xF06F 0x0A86      MVN      R10,#+134
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xBF1C             ITT      NE
   \       0x1A   0x9816             LDRNE    R0,[SP, #+88]
   \       0x1C   0x2800             CMPNE    R0,#+0
   \       0x1E   0xD064             BEQ.N    ??sli_se_driver_aead_verify_0
   1505              return PSA_ERROR_INVALID_ARGUMENT;
   1506            }
   1507          
   1508            *plaintext_length = 0;
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x6002             STR      R2,[R0, #+0]
   1509          
   1510            if (tag == NULL || tag_length == 0 ) {
   \       0x24   0x9817             LDR      R0,[SP, #+92]
   \       0x26   0xF06F 0x0894      MVN      R8,#+148
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xBF1A             ITTE     NE
   \       0x2E   0x9D18             LDRNE    R5,[SP, #+96]
   \       0x30   0x2D00             CMPNE    R5,#+0
   \       0x32   0x4640             MOVEQ    R0,R8
   1511              return PSA_ERROR_INVALID_SIGNATURE;
   \       0x34   0xD05A             BEQ.N    ??sli_se_driver_aead_verify_1
   1512            }
   1513          
   1514            psa_algorithm_t alg = PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(operation->alg);
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x....             LDR.N    R1,??DataTable11
   \       0x3A   0xF420 0x127E      BIC      R2,R0,#0x3F8000
   \       0x3E   0x428A             CMP      R2,R1
   \       0x40   0xBF08             IT       EQ
   \       0x42   0x.... 0x....      LDREQ.W  R9,??DataTable11_1
   \       0x46   0xD00E             BEQ.N    ??sli_se_driver_aead_verify_2
   \       0x48   0x....             LDR.N    R1,??DataTable11_4
   \       0x4A   0x428A             CMP      R2,R1
   \       0x4C   0xBF08             IT       EQ
   \       0x4E   0x.... 0x....      LDREQ.W  R9,??DataTable11_2
   \       0x52   0xD008             BEQ.N    ??sli_se_driver_aead_verify_2
   \       0x54   0xF420 0x117E      BIC      R1,R0,#0x3F8000
   \       0x58   0xF1B1 0x2F05      CMP      R1,#+83887360
   \       0x5C   0xBF0C             ITE      EQ
   \       0x5E   0x.... 0x....      LDREQ.W  R9,??DataTable11_3
   \       0x62   0xF04F 0x0900      MOVNE    R9,#+0
   1515          
   1516            if (operation->alg == 0) {
   \                     ??sli_se_driver_aead_verify_2: (+1)
   \       0x66   0xB910             CBNZ.N   R0,??sli_se_driver_aead_verify_3
   1517              return PSA_ERROR_BAD_STATE;
   \       0x68   0xF06F 0x0088      MVN      R0,#+136
   \       0x6C   0xE03E             B.N      ??sli_se_driver_aead_verify_1
   1518            }
   1519          
   1520            // Operation isn't initialised unless we have either AD or PT, so  if we are
   1521            // still at 0, we need to run the start step.
   1522            if (operation->ad_len == 0 && operation->pt_len == 0) {
   \                     ??sli_se_driver_aead_verify_3: (+1)
   \       0x6E   0x6A60             LDR      R0,[R4, #+36]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xBF04             ITT      EQ
   \       0x74   0x6AA0             LDREQ    R0,[R4, #+40]
   \       0x76   0x2800             CMPEQ    R0,#+0
   \       0x78   0xD105             BNE.N    ??sli_se_driver_aead_verify_4
   1523              psa_status = aead_start(operation, NULL, 0);
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x.... 0x....      BL       aead_start
   1524              if (psa_status != PSA_SUCCESS) {
   \       0x84   0xBB90             CBNZ.N   R0,??sli_se_driver_aead_verify_1
   1525                return psa_status;
   1526              }
   1527            }
   1528          
   1529            status = sl_se_init_command_context(&cmd_ctx);
   1530            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_aead_verify_4: (+1)
   \       0x86   0xA804             ADD      R0,SP,#+16
   \       0x88   0xF06F 0x0B92      MVN      R11,#+146
   \       0x8C   0x.... 0x....      BL       sl_se_init_command_context
   \       0x90   0xBB48             CBNZ.N   R0,??sli_se_driver_aead_verify_5
   1531              return PSA_ERROR_HARDWARE_FAILURE;
   1532            }
   1533          
   1534            switch (alg) {
   \       0x92   0x....             LDR.N    R0,??DataTable11_1
   \       0x94   0x4581             CMP      R9,R0
   \       0x96   0xD120             BNE.N    ??sli_se_driver_aead_verify_6
   1535              #if defined(SLI_PSA_DRIVER_FEATURE_GCM)
   1536              case PSA_ALG_GCM:
   1537                if (operation->ctx.gcm.mode != SL_SE_DECRYPT) {
   1538                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
   1539                  goto exit;
   1540                }
   1541                status = sl_se_gcm_multipart_finish(&operation->ctx.gcm,
   1542                                                    &cmd_ctx,
   1543                                                    &operation->key_desc,
   1544                                                    (uint8_t *)tag,
   1545                                                    tag_length,
   1546                                                    plaintext,
   1547                                                    plaintext_size,
   1548                                                    (uint8_t *)plaintext_length);
   1549                if (status == SL_STATUS_INVALID_SIGNATURE) {
   1550                  psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1551                  goto exit;
   1552                } else if (status != SL_STATUS_OK) {
   1553                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1554                  goto exit;
   1555                }
   1556                psa_status = PSA_SUCCESS;
   1557                break;
   1558              #endif   // SLI_PSA_DRIVER_FEATURE_GCM
   1559          
   1560              #if defined(SLI_PSA_DRIVER_FEATURE_CCM)
   1561              case PSA_ALG_CCM:
   1562              {
   1563                uint32_t tag_len = PSA_ALG_AEAD_GET_TAG_LENGTH(operation->alg);
   1564                if (tag_length != tag_len) {
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0xF3C1 0x4005      UBFX     R0,R1,#+16,#+6
   \       0x9E   0x4285             CMP      R5,R0
   \       0xA0   0xD113             BNE.N    ??sli_se_driver_aead_verify_7
   1565                  psa_status = PSA_ERROR_INVALID_SIGNATURE;
   1566                  goto exit;
   1567                }
   1568                if (operation->ctx.ccm.mode != SL_SE_DECRYPT) {
   \       0xA2   0xF894 0x004C      LDRB     R0,[R4, #+76]
   \       0xA6   0x2801             CMP      R0,#+1
   \       0xA8   0xD119             BNE.N    ??sli_se_driver_aead_verify_8
   1569                  psa_status = PSA_ERROR_INVALID_ARGUMENT;
   1570                  goto exit;
   1571                }
   1572                status = sl_se_ccm_multipart_finish(&operation->ctx.ccm,
   1573                                                    &cmd_ctx,
   1574                                                    &operation->key_desc,
   1575                                                    (uint8_t *)tag,
   1576                                                    tag_length,
   1577                                                    plaintext,
   1578                                                    plaintext_size,
   1579                                                    (uint8_t *)plaintext_length);
   \       0xAA   0x9816             LDR      R0,[SP, #+88]
   \       0xAC   0xB2FF             UXTB     R7,R7
   \       0xAE   0x9702             STR      R7,[SP, #+8]
   \       0xB0   0x9003             STR      R0,[SP, #+12]
   \       0xB2   0x9601             STR      R6,[SP, #+4]
   \       0xB4   0x9B17             LDR      R3,[SP, #+92]
   \       0xB6   0xB2ED             UXTB     R5,R5
   \       0xB8   0x9500             STR      R5,[SP, #+0]
   \       0xBA   0x1D22             ADDS     R2,R4,#+4
   \       0xBC   0xA904             ADD      R1,SP,#+16
   \       0xBE   0xF104 0x0030      ADD      R0,R4,#+48
   \       0xC2   0x.... 0x....      BL       sl_se_ccm_multipart_finish
   1580          
   1581                if (status == SL_STATUS_INVALID_SIGNATURE) {
   \       0xC6   0x282C             CMP      R0,#+44
   \       0xC8   0xD101             BNE.N    ??sli_se_driver_aead_verify_9
   1582                  psa_status = PSA_ERROR_INVALID_SIGNATURE;
   \                     ??sli_se_driver_aead_verify_7: (+1)
   \       0xCA   0x46C2             MOV      R10,R8
   1583                  goto exit;
   \       0xCC   0xE007             B.N      ??sli_se_driver_aead_verify_8
   1584                } else if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_aead_verify_9: (+1)
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xBF0C             ITE      EQ
   \       0xD2   0xF04F 0x0A00      MOVEQ    R10,#+0
   \       0xD6   0x46DA             MOVNE    R10,R11
   1585                  psa_status = PSA_ERROR_HARDWARE_FAILURE;
   1586                  goto exit;
   1587                }
   1588                psa_status = PSA_SUCCESS;
   \       0xD8   0xE001             B.N      ??sli_se_driver_aead_verify_8
   1589                break;
   1590              }
   1591              #endif   // SLI_PSA_DRIVER_FEATURE_CCM
   1592          
   1593              default:
   1594                psa_status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_aead_verify_6: (+1)
   \       0xDA   0xF06F 0x0A85      MVN      R10,#+133
   1595                goto exit;
   1596            }
   1597          
   1598            exit:
   1599          
   1600            status = sl_se_deinit_command_context(&cmd_ctx);
   1601            if (status != SL_STATUS_OK) {
   \                     ??sli_se_driver_aead_verify_8: (+1)
   \       0xDE   0xA804             ADD      R0,SP,#+16
   \       0xE0   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xE4   0xB108             CBZ.N    R0,??sli_se_driver_aead_verify_0
   1602              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_driver_aead_verify_5: (+1)
   \       0xE6   0x4658             MOV      R0,R11
   \       0xE8   0xE000             B.N      ??sli_se_driver_aead_verify_1
   1603            }
   1604          
   1605            return psa_status;
   \                     ??sli_se_driver_aead_verify_0: (+1)
   \       0xEA   0x4650             MOV      R0,R10
   \                     ??sli_se_driver_aead_verify_1: (+1)
   \       0xEC   0xB00D             ADD      SP,SP,#+52
   \       0xEE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1606          
   1607            #else // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1608          
   1609            (void)operation;
   1610            (void)key_buffer;
   1611            (void)plaintext;
   1612            (void)plaintext_size;
   1613            (void)plaintext_length;
   1614            (void)tag;
   1615            (void)tag_length;
   1616          
   1617            return PSA_ERROR_NOT_SUPPORTED;
   1618          
   1619            #endif // SLI_PSA_DRIVER_FEATURE_AEAD_MULTIPART
   1620          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x0540'0100        DC32     0x5400100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x0550'0100        DC32     0x5500100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x0550'0200        DC32     0x5500200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x0510'0500        DC32     0x5100500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x0540'0200        DC32     0x5400200
   1621          
   1622          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     112   aead_start
       112   -> __aeabi_memclr4
       112   -> __aeabi_memcpy4
       112   -> sl_se_ccm_multipart_starts
       112   -> sl_se_init_command_context
      24   check_aead_parameters
        24   -> psa_get_key_bits
       0   psa_get_key_bits
      96   sli_se_driver_aead_decrypt
        96   -> __aeabi_memcpy
        96   -> sli_se_driver_aead_decrypt_tag
     136   sli_se_driver_aead_decrypt_tag
       136   -> __aeabi_memclr4
       136   -> __aeabi_memmove
       136   -> check_aead_parameters
       136   -> sl_se_ccm_auth_decrypt
       136   -> sl_se_init_command_context
       136   -> sli_se_key_desc_from_input
      80   sli_se_driver_aead_encrypt
        80   -> sli_se_driver_aead_encrypt_tag
      32   sli_se_driver_aead_encrypt_decrypt_setup
        32   -> __aeabi_memclr4
        32   -> __aeabi_memcpy
        32   -> sli_key_get_size
        32   -> sli_se_key_desc_from_input
     136   sli_se_driver_aead_encrypt_tag
       136   -> __aeabi_memclr4
       136   -> __aeabi_memmove
       136   -> check_aead_parameters
       136   -> sl_se_ccm_encrypt_and_tag
       136   -> sl_se_init_command_context
       136   -> sli_se_key_desc_from_input
      96   sli_se_driver_aead_finish
        96   -> __aeabi_memclr4
        96   -> aead_start
        96   -> sl_se_ccm_multipart_finish
        96   -> sl_se_deinit_command_context
        96   -> sl_se_init_command_context
      12   sli_se_driver_aead_set_lengths
      16   sli_se_driver_aead_set_nonce
        16   -> __aeabi_memcpy
      80   sli_se_driver_aead_update
        80   -> __aeabi_memclr4
        80   -> aead_start
        80   -> sl_se_ccm_multipart_update
        80   -> sl_se_init_command_context
       8   sli_se_driver_aead_update_ad
         0   -> aead_start
      88   sli_se_driver_aead_verify
        88   -> __aeabi_memclr4
        88   -> aead_start
        88   -> sl_se_ccm_multipart_finish
        88   -> sl_se_deinit_command_context
        88   -> sl_se_init_command_context


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       6  ?Subroutine0
      14  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
       8  ?Subroutine4
      16  ?Subroutine5
      10  ?Subroutine6
      36  ?_0
      36  ?_1
      36  ?_2
      36  ?_3
      36  ?_4
      36  ?_5
      32  ?_6
      32  ?_7
     118  aead_start
     152  check_aead_parameters
       4  psa_get_key_bits
     172  sli_se_driver_aead_decrypt
     234  sli_se_driver_aead_decrypt_tag
      96  sli_se_driver_aead_encrypt
     186  sli_se_driver_aead_encrypt_decrypt_setup
     330  sli_se_driver_aead_encrypt_tag
     242  sli_se_driver_aead_finish
      66  sli_se_driver_aead_set_lengths
      46  sli_se_driver_aead_set_nonce
     206  sli_se_driver_aead_update
      60  sli_se_driver_aead_update_ad
     242  sli_se_driver_aead_verify

 
   280 bytes in section .rodata
 2'248 bytes in section .text
 
 2'248 bytes of CODE  memory
   280 bytes of CONST memory

Errors: none
Warnings: none
