###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:05
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_signature.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_signature.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_signature.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_signature.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sli_se_driver_signature.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_signature.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_signature.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Secure Engine Signature Driver functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "psa/crypto.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t psa_get_key_bits(psa_key_attributes_t const *)
   \                     psa_get_key_bits: (+1)
   \        0x0   0x8840             LDRH     R0,[R0, #+2]
   \        0x2   0x4770             BX       LR
     36          
     37          #include "sli_psa_driver_common.h"  // sli_psa_zeroize()
     38          #include "sli_se_transparent_types.h"
     39          #include "sli_se_transparent_functions.h"
     40          #include "sli_se_driver_key_management.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void sli_se_key_descriptor_set_plaintext(struct <unnamed>#128 *, uint8_t const *, size_t)
   \                     sli_se_key_descriptor_set_plaintext: (+1)
   \        0x0   0x1CD2             ADDS     R2,R2,#+3
   \        0x2   0x0892             LSRS     R2,R2,#+2
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x0092             LSLS     R2,R2,#+2
   \        0x8   0x60C3             STR      R3,[R0, #+12]
   \        0xA   0x6101             STR      R1,[R0, #+16]
   \        0xC   0x6142             STR      R2,[R0, #+20]
   \        0xE   0x4770             BX       LR
     41          #include "sli_se_version_dependencies.h"
     42          
     43          #include "sl_se_manager.h"
     44          #include "sli_se_manager_internal.h"
     45          #include "sl_se_manager_signature.h"
     46          
     47          #include <string.h>
     48          
     49          // -----------------------------------------------------------------------------
     50          // Static functions
     51          
     52          // -------------------------------------
     53          // Helpers
     54          
     55          #if defined(SLI_PSA_DRIVER_FEATURE_SIGNATURE)
     56          
     57          /**
     58           * @brief
     59           *   Validate that the curve and algorithm combination is supported by hardware
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          static psa_status_t check_curve_availability(
     62            const psa_key_attributes_t *attributes,
     63            psa_algorithm_t alg)
     64          {
   \                     check_curve_availability: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
     65            psa_key_type_t key_type = psa_get_key_type(attributes);
   \        0x4   0x8801             LDRH     R1,[R0, #+0]
     66            psa_ecc_family_t curvetype = PSA_KEY_TYPE_ECC_GET_FAMILY(key_type);
   \        0x6   0x.... 0x....      LDR.W    R2,??DataTable7
   \        0xA   0x400A             ANDS     R2,R2,R1
   \        0xC   0xF5B2 0x4F82      CMP      R2,#+16640
   \       0x10   0xBF0C             ITE      EQ
   \       0x12   0xB2C9             UXTBEQ   R1,R1
   \       0x14   0x2100             MOVNE    R1,#+0
     67          
     68            if (PSA_ALG_IS_RSA_PSS(alg) || PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg)) {
   \       0x16   0x0A25             LSRS     R5,R4,#+8
   \       0x18   0x022D             LSLS     R5,R5,#+8
   \       0x1A   0x.... 0x....      LDR.W    R3,??DataTable7_1
   \       0x1E   0x429D             CMP      R5,R3
   \       0x20   0xBF1F             ITTTT    NE
   \       0x22   0x0A22             LSRNE    R2,R4,#+8
   \       0x24   0x0212             LSLNE    R2,R2,#+8
   \       0x26   0x.... 0x....      LDRNE.W  R5,??DataTable7_2
   \       0x2A   0x42AA             CMPNE    R2,R5
   \       0x2C   0xD005             BEQ.N    ??check_curve_availability_0
   \       0x2E   0x0A23             LSRS     R3,R4,#+8
   \       0x30   0x021B             LSLS     R3,R3,#+8
   \       0x32   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x36   0x4293             CMP      R3,R2
   \       0x38   0xD102             BNE.N    ??check_curve_availability_1
     69              // We shouldn't have a RSA-type alg for a ECC key.
     70              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??check_curve_availability_0: (+1)
   \       0x3A   0xF06F 0x0086      MVN      R0,#+134
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}
     71            }
     72          
     73            #if defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
     74            if (curvetype == PSA_ECC_FAMILY_SECP_R1) {
   \                     ??check_curve_availability_1: (+1)
   \       0x40   0xF06F 0x0585      MVN      R5,#+133
   \       0x44   0x2912             CMP      R1,#+18
   \       0x46   0xD10A             BNE.N    ??check_curve_availability_2
     75              switch (psa_get_key_bits(attributes)) {
   \       0x48   0x.... 0x....      BL       psa_get_key_bits
   \       0x4C   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x50   0xD106             BNE.N    ??check_curve_availability_3
     76                #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
     77                case 192:     // Intentional
     78                #endif
     79                #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
     80                case 224:     // Intentional
     81                #endif
     82                #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
     83                case 256:     // Intentional
     84                #endif
     85                #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
     86                case 384:     // Intentional
     87                #endif
     88                #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
     89                case 521:
     90                #endif
     91                // Only randomized ECDSA is supported on secp-r1 curves
     92                if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
   \       0x52   0x0A24             LSRS     R4,R4,#+8
   \       0x54   0x0224             LSLS     R4,R4,#+8
   \       0x56   0xF1B4 0x2F06      CMP      R4,#+100664832
   \       0x5A   0xD003             BEQ.N    ??check_curve_availability_4
     93                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x5C   0xE000             B.N      ??check_curve_availability_3
     94                }
     95                break;     // This break catches all the supported curves
     96                default:
     97                  return PSA_ERROR_NOT_SUPPORTED;
     98              }
     99            } else if (curvetype == PSA_ECC_FAMILY_SECP_K1) {
   \                     ??check_curve_availability_2: (+1)
   \       0x5E   0x2917             CMP      R1,#+23
    100              // Only randomized ECDSA is supported on secp-k1 curves
    101              if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
    102                return PSA_ERROR_NOT_SUPPORTED;
    103              }
    104              // TODO: introduce custom domains to enable secpxxxk1
    105              return PSA_ERROR_NOT_SUPPORTED;
    106            } else
    107            #endif // SLI_PSA_DRIVER_FEATURE_ECDSA
    108          
    109            #if defined(SLI_PSA_DRIVER_FEATURE_EDDSA)
    110            if (curvetype == PSA_ECC_FAMILY_TWISTED_EDWARDS) {
    111              switch (psa_get_key_bits(attributes)) {
    112                #if defined(SLI_PSA_DRIVER_FEATURE_EDWARDS25519)
    113                case 255:
    114                  // Only Ed25519 is supported (and only in context of EdDSA)
    115                  if (alg != PSA_ALG_PURE_EDDSA) {
    116                    return PSA_ERROR_NOT_SUPPORTED;
    117                  }
    118                  break;
    119                #endif   // SLI_PSA_DRIVER_FEATURE_EDWARDS25519
    120                default:
    121                  return PSA_ERROR_NOT_SUPPORTED;
    122              }
    123            } else
    124            #endif // SLI_PSA_DRIVER_FEATURE_EDDSA
    125          
    126            {
    127              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??check_curve_availability_3: (+1)
   \       0x60   0x4628             MOV      R0,R5
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    128            }
    129          
    130            return PSA_SUCCESS;
   \                     ??check_curve_availability_4: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xBD32             POP      {R1,R4,R5,PC}
    131          }
    132          

   \                                 In section .text, align 2, keep-with-next
    133          static sl_se_hash_type_t get_hash_for_algorithm(psa_algorithm_t alg)
    134          {
    135            #if defined(SLI_PSA_DRIVER_FEATURE_EDDSA)
    136            if (alg == PSA_ALG_PURE_EDDSA) {
    137              // The hash alg parameter is ignored for EdDSA, as it is decided uniqely by
    138              // the alorithm. Return magic value which isn't SL_SE_HASH_NONE.
    139              return (sl_se_hash_type_t)255;
    140            }
    141            #endif // SLI_PSA_DRIVER_FEATURE_EDDSA
    142          
    143            switch (PSA_ALG_SIGN_GET_HASH(alg)) {
   \                     get_hash_for_algorithm: (+1)
   \        0x0   0x0A03             LSRS     R3,R0,#+8
   \        0x2   0x021B             LSLS     R3,R3,#+8
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable7_1
   \        0x8   0x4293             CMP      R3,R2
   \        0xA   0xBF1F             ITTTT    NE
   \        0xC   0x0A01             LSRNE    R1,R0,#+8
   \        0xE   0x0209             LSLNE    R1,R1,#+8
   \       0x10   0x.... 0x....      LDRNE.W  R3,??DataTable7_2
   \       0x14   0x4299             CMPNE    R1,R3
   \       0x16   0xD016             BEQ.N    ??get_hash_for_algorithm_0
   \       0x18   0x0A02             LSRS     R2,R0,#+8
   \       0x1A   0x0212             LSLS     R2,R2,#+8
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \       0x20   0x428A             CMP      R2,R1
   \       0x22   0xBF1E             ITTT     NE
   \       0x24   0x0A43             LSRNE    R3,R0,#+9
   \       0x26   0x025B             LSLNE    R3,R3,#+9
   \       0x28   0xF1B3 0x2F06      CMPNE    R3,#+100664832
   \       0x2C   0xD00B             BEQ.N    ??get_hash_for_algorithm_0
   \       0x2E   0x0A01             LSRS     R1,R0,#+8
   \       0x30   0x0209             LSLS     R1,R1,#+8
   \       0x32   0x.... 0x....      LDR.W    R3,??DataTable7_4
   \       0x36   0x4299             CMP      R1,R3
   \       0x38   0xBF1F             ITTTT    NE
   \       0x3A   0x0A42             LSRNE    R2,R0,#+9
   \       0x3C   0x0252             LSLNE    R2,R2,#+9
   \       0x3E   0x.... 0x....      LDRNE.W  R1,??DataTable7_5
   \       0x42   0x428A             CMPNE    R2,R1
   \       0x44   0xD114             BNE.N    ??get_hash_for_algorithm_1
   \                     ??get_hash_for_algorithm_0: (+1)
   \       0x46   0x0602             LSLS     R2,R0,#+24
   \       0x48   0xD012             BEQ.N    ??get_hash_for_algorithm_1
   \       0x4A   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x4E   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \       0x52   0x.... 0x....      LDR.W    R1,??DataTable7_6
   \       0x56   0x1A40             SUBS     R0,R0,R1
   \       0x58   0xD004             BEQ.N    ??get_hash_for_algorithm_2
   \       0x5A   0x1EC0             SUBS     R0,R0,#+3
   \       0x5C   0xD004             BEQ.N    ??get_hash_for_algorithm_3
   \       0x5E   0x1E40             SUBS     R0,R0,#+1
   \       0x60   0xD004             BEQ.N    ??get_hash_for_algorithm_4
   \       0x62   0xE005             B.N      ??get_hash_for_algorithm_1
    144              #if defined(SLI_PSA_DRIVER_FEATURE_SHA1)
    145              case PSA_ALG_SHA_1:
    146                return SL_SE_HASH_SHA1;
   \                     ??get_hash_for_algorithm_2: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0x4770             BX       LR
    147              #endif // SLI_PSA_DRIVER_FEATURE_SHA1
    148          
    149              #if defined(SLI_PSA_DRIVER_FEATURE_SHA224)
    150              case PSA_ALG_SHA_224:
    151                return SL_SE_HASH_SHA224;
   \                     ??get_hash_for_algorithm_3: (+1)
   \       0x68   0x2002             MOVS     R0,#+2
   \       0x6A   0x4770             BX       LR
    152              #endif // SLI_PSA_DRIVER_FEATURE_SHA224
    153          
    154              #if defined(SLI_PSA_DRIVER_FEATURE_SHA256)
    155              case PSA_ALG_SHA_256:
    156                return SL_SE_HASH_SHA256;
   \                     ??get_hash_for_algorithm_4: (+1)
   \       0x6C   0x2003             MOVS     R0,#+3
   \       0x6E   0x4770             BX       LR
    157              #endif // SLI_PSA_DRIVER_FEATURE_SHA256
    158          
    159              #if defined(SLI_PSA_DRIVER_FEATURE_SHA384)
    160              case PSA_ALG_SHA_384:
    161                return SL_SE_HASH_SHA384;
    162              #endif // SLI_PSA_DRIVER_FEATURE_SHA384
    163          
    164              #if defined(SLI_PSA_DRIVER_FEATURE_SHA512)
    165              case PSA_ALG_SHA_512:
    166                return SL_SE_HASH_SHA512;
    167              #endif // SLI_PSA_DRIVER_FEATURE_SHA512
    168          
    169              default:
    170                return SL_SE_HASH_NONE;
   \                     ??get_hash_for_algorithm_1: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x4770             BX       LR
    171            }
    172          }
    173          
    174          #endif // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    175          
    176          // -------------------------------------
    177          // Generic (indirect) driver entry points
    178          

   \                                 In section .text, align 2, keep-with-next
    179          static psa_status_t sli_se_sign_message(
    180            const psa_key_attributes_t *attributes,
    181            const uint8_t *key_buffer,
    182            size_t key_buffer_size,
    183            psa_algorithm_t alg,
    184            const uint8_t *input,
    185            size_t input_length,
    186            uint8_t *signature,
    187            size_t signature_size,
    188            size_t *signature_length)
    189          {
   \                     sli_se_sign_message: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0xEA5F 0x0800      MOVS     R8,R0
    190            #if defined(SLI_PSA_DRIVER_FEATURE_SIGNATURE)
    191          
    192            uint8_t* tmp_signature_p = signature;
    193            size_t tmp_signature_size = signature_size;
    194            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
    195          
    196            // Argument check
    197            if (attributes == NULL
    198                || key_buffer == NULL
    199                || key_buffer_size == 0
    200                || (input == NULL && input_length > 0)
    201                || signature == NULL
    202                || signature_size == 0
    203                || signature_length == NULL) {
   \        0xA   0xD045             BEQ.N    ??sli_se_sign_message_0
   \        0xC   0x9101             STR      R1,[SP, #+4]
   \        0xE   0x0008             MOVS     R0,R1
   \       0x10   0xD042             BEQ.N    ??sli_se_sign_message_0
   \       0x12   0x0017             MOVS     R7,R2
   \       0x14   0xD040             BEQ.N    ??sli_se_sign_message_0
   \       0x16   0x981E             LDR      R0,[SP, #+120]
   \       0x18   0x9D1F             LDR      R5,[SP, #+124]
   \       0x1A   0xB908             CBNZ.N   R0,??sli_se_sign_message_1
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD13B             BNE.N    ??sli_se_sign_message_0
   \                     ??sli_se_sign_message_1: (+1)
   \       0x20   0x9E20             LDR      R6,[SP, #+128]
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xBF1F             ITTTT    NE
   \       0x26   0xF8DD 0xB084      LDRNE    R11,[SP, #+132]
   \       0x2A   0xF1BB 0x0F00      CMPNE    R11,#+0
   \       0x2E   0x9C22             LDRNE    R4,[SP, #+136]
   \       0x30   0x2C00             CMPNE    R4,#+0
   \       0x32   0xD031             BEQ.N    ??sli_se_sign_message_0
    204              return PSA_ERROR_INVALID_ARGUMENT;
    205            }
    206          
    207            // Check the requested algorithm is supported
    208            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(psa_get_key_type(attributes))) {
   \       0x34   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \       0x38   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x3C   0xD12C             BNE.N    ??sli_se_sign_message_0
   \       0x3E   0x9300             STR      R3,[SP, #+0]
    209              psa_status = check_curve_availability(attributes, alg);
   \       0x40   0x4619             MOV      R1,R3
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0x.... 0x....      BL       check_curve_availability
    210              if (psa_status != PSA_SUCCESS) {
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD155             BNE.N    ??sli_se_sign_message_2
    211                return psa_status;
    212              }
    213            } else {
    214              // Not able to sign using non-ECC keys, or using public keys
    215              return PSA_ERROR_INVALID_ARGUMENT;
    216            }
    217          
    218            // Check the requested hashing algorithm is supported
    219            if (get_hash_for_algorithm(alg) == SL_SE_HASH_NONE) {
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0xF06F 0x0985      MVN      R9,#+133
   \       0x52   0x.... 0x....      BL       get_hash_for_algorithm
   \       0x56   0xB908             CBNZ.N   R0,??sli_se_sign_message_3
    220              return PSA_ERROR_NOT_SUPPORTED;
   \       0x58   0x4648             MOV      R0,R9
   \       0x5A   0xE04D             B.N      ??sli_se_sign_message_2
    221            }
    222          
    223            // Ephemeral contexts
    224            sl_se_command_context_t cmd_ctx = { 0 };
   \                     ??sli_se_sign_message_3: (+1)
   \       0x5C   0x.... 0x....      BL       ?Subroutine7
    225            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x60   0x.... 0x....      BL       ?Subroutine8
    226          
    227            // Initialize key descriptor and verify key buffer size
    228            psa_status = sli_se_key_desc_from_input(attributes,
    229                                                    key_buffer,
    230                                                    key_buffer_size,
    231                                                    &key_desc);
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x64   0x9901             LDR      R1,[SP, #+4]
   \       0x66   0xAB04             ADD      R3,SP,#+16
   \       0x68   0x463A             MOV      R2,R7
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x70   0xEA5F 0x0A00      MOVS     R10,R0
    232            if (psa_status != PSA_SUCCESS) {
   \       0x74   0xD140             BNE.N    ??sli_se_sign_message_2
    233              return psa_status;
    234            }
    235          
    236            // Validate that the output buffer can contain the full signature.
    237            // Both ECDSA and EdDSA share the same signature size.
    238            if (signature_size
    239                < PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \       0x76   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x7A   0x1DC0             ADDS     R0,R0,#+7
   \       0x7C   0x08C0             LSRS     R0,R0,#+3
   \       0x7E   0xEBBB 0x0F40      CMP      R11,R0, LSL #+1
   \       0x82   0xBF38             IT       CC
   \       0x84   0xF06F 0x0089      MVNCC    R0,#+137
    240              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x88   0xD336             BCC.N    ??sli_se_sign_message_2
    241            }
    242          
    243            size_t key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
   \       0x8A   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x8E   0x1DC7             ADDS     R7,R0,#+7
   \       0x90   0x08FF             LSRS     R7,R7,#+3
    244          
    245            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    246            size_t offset = sli_se_get_padding(key_size);
    247            #else
    248            size_t offset = 0;
    249            #endif
    250          
    251            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    252            // P-521 (or any curve size that's not word-multiple) requires alignment on
    253            // word boundaries, instead of byte boundaries such as PSA Crypto defines as
    254            // input here.
    255            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_KEY_PAIR_SIZE] = { 0 };
    256            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    257            psa_key_location_t location =
    258              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    259          
    260            if (offset > 0) {
    261              // We can only manipulate the input key for transparent keys.
    262              // For opaque keys, we will just have to rely on the key import operation
    263              // handling this
    264              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    265                if ((offset + key_buffer_size) > sizeof(temp_key_buf)) {
    266                  return PSA_ERROR_INVALID_ARGUMENT;
    267                }
    268                sli_se_pad_big_endian(temp_key_buf, key_buffer, key_buffer_size);
    269                // Since we know that this must be a plaintext key, we can freely
    270                // modify the key descriptor
    271                key_desc.storage.location.buffer.pointer = temp_key_buf;
    272                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    273              }
    274          
    275              tmp_signature_p = temp_signature_buffer;
    276              tmp_signature_size = sizeof(temp_signature_buffer);
    277            }
    278            #endif   // SLI_SE_KEY_PADDING_REQUIRED || SLI_PSA_DRIVER_FEATURE_ECDSA
    279          
    280            if (tmp_signature_size < 2 * (offset + key_size)) {
   \       0x92   0xEBBB 0x0F47      CMP      R11,R7, LSL #+1
   \       0x96   0xD202             BCS.N    ??sli_se_sign_message_4
    281              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_sign_message_0: (+1)
   \       0x98   0xF06F 0x0086      MVN      R0,#+134
   \       0x9C   0xE02C             B.N      ??sli_se_sign_message_2
    282            }
    283            tmp_signature_size = 2 * (offset + key_size);
    284          
    285            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
    286            if (status != SL_STATUS_OK) {
   \                     ??sli_se_sign_message_4: (+1)
   \       0x9E   0xA80C             ADD      R0,SP,#+48
   \       0xA0   0xF06F 0x0B92      MVN      R11,#+146
   \       0xA4   0x.... 0x....      BL       sl_se_init_command_context
   \       0xA8   0xBB18             CBNZ.N   R0,??sli_se_sign_message_5
    287              return PSA_ERROR_HARDWARE_FAILURE;
    288            }
    289          
    290            #if defined(SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED)
    291            psa_status = sli_se_check_eddsa_errata(attributes, &cmd_ctx);
    292            if (psa_status != PSA_SUCCESS) {
    293              return psa_status;
    294            }
    295            #endif   // SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED
    296          
    297            // Run signature generation
    298            status = sl_se_ecc_sign(&cmd_ctx,
    299                                    &key_desc,
    300                                    get_hash_for_algorithm(alg),
    301                                    false,
    302                                    input,
    303                                    input_length,
    304                                    tmp_signature_p,
    305                                    tmp_signature_size
    306                                    );
   \       0xAA   0x9800             LDR      R0,[SP, #+0]
   \       0xAC   0x007F             LSLS     R7,R7,#+1
   \       0xAE   0x.... 0x....      BL       get_hash_for_algorithm
   \       0xB2   0x9703             STR      R7,[SP, #+12]
   \       0xB4   0x991E             LDR      R1,[SP, #+120]
   \       0xB6   0x4602             MOV      R2,R0
   \       0xB8   0x9602             STR      R6,[SP, #+8]
   \       0xBA   0x9100             STR      R1,[SP, #+0]
   \       0xBC   0x9501             STR      R5,[SP, #+4]
   \       0xBE   0x2300             MOVS     R3,#+0
   \       0xC0   0xA904             ADD      R1,SP,#+16
   \       0xC2   0xA80C             ADD      R0,SP,#+48
   \       0xC4   0x.... 0x....      BL       sl_se_ecc_sign
    307          
    308            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    309            if (offset > 0) {
    310              sli_psa_zeroize(temp_key_buf, sizeof(temp_key_buf));
    311              // Copy over from temp signature
    312              sli_se_unpad_curve_point(temp_signature_buffer, signature, key_size);
    313            }
    314            #endif // SLI_SE_KEY_PADDING_REQUIRED && SLI_PSA_DRIVER_FEATURE_ECDSA
    315          
    316            if (status == SL_STATUS_OK) {
   \       0xC8   0xB930             CBNZ.N   R0,??sli_se_sign_message_6
    317              *signature_length = PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes));
   \       0xCA   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0xCE   0x1DC0             ADDS     R0,R0,#+7
   \       0xD0   0x08C0             LSRS     R0,R0,#+3
   \       0xD2   0x0040             LSLS     R0,R0,#+1
   \       0xD4   0x6020             STR      R0,[R4, #+0]
    318              psa_status = PSA_SUCCESS;
   \       0xD6   0xE008             B.N      ??sli_se_sign_message_7
    319            } else {
    320              if (status == SL_STATUS_FAIL) {
   \                     ??sli_se_sign_message_6: (+1)
   \       0xD8   0x2801             CMP      R0,#+1
   \       0xDA   0xBF08             IT       EQ
   \       0xDC   0xF06F 0x0A8B      MVNEQ    R10,#+139
    321                // Will be returned for missing built-in keys.
    322                psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \       0xE0   0xD003             BEQ.N    ??sli_se_sign_message_7
    323              } else if (status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0xE2   0x2848             CMP      R0,#+72
   \       0xE4   0xBF0C             ITE      EQ
   \       0xE6   0x46CA             MOVEQ    R10,R9
   \       0xE8   0x46DA             MOVNE    R10,R11
    324                // Will be returned if a key type is not supported (for example).
    325                psa_status = PSA_ERROR_NOT_SUPPORTED;
    326              } else {
    327                psa_status = PSA_ERROR_HARDWARE_FAILURE;
    328              }
    329            }
    330          
    331            // Cleanup
    332            status = sl_se_deinit_command_context(&cmd_ctx);
    333            if (status != SL_STATUS_OK) {
   \                     ??sli_se_sign_message_7: (+1)
   \       0xEA   0xA80C             ADD      R0,SP,#+48
   \       0xEC   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xF0   0xB108             CBZ.N    R0,??sli_se_sign_message_8
    334              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_sign_message_5: (+1)
   \       0xF2   0x4658             MOV      R0,R11
   \       0xF4   0xE000             B.N      ??sli_se_sign_message_2
    335            }
    336            return psa_status;
   \                     ??sli_se_sign_message_8: (+1)
   \       0xF6   0x4650             MOV      R0,R10
   \                     ??sli_se_sign_message_2: (+1)
   \       0xF8   0x....             B.N      ?Subroutine0
    337          
    338            #else // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    339          
    340            (void) attributes;
    341            (void) key_buffer;
    342            (void) key_buffer_size;
    343            (void) alg;
    344            (void) input;
    345            (void) input_length;
    346            (void) signature;
    347            (void) signature_size;
    348            (void) signature_length;
    349          
    350            return PSA_ERROR_NOT_SUPPORTED;
    351          
    352            #endif // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    353          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0xA804             ADD      R0,SP,#+16
   \                     ??Subroutine8_0: (+1)
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xA80C             ADD      R0,SP,#+48
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x2124             MOVS     R1,#+36
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB015             ADD      SP,SP,#+84
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF06F 0x0B92      MVN      R11,#+146
   \                     ??Subroutine5_0: (+1)
   \        0x4   0xF020 0x00FF      BIC      R0,R0,#0xFF
   \        0x8   0xF5B0 0x4FE2      CMP      R0,#+28928
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x....             B.N      psa_get_key_bits

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    354          

   \                                 In section .text, align 2, keep-with-next
    355          static psa_status_t sli_se_sign_hash(
    356            const psa_key_attributes_t *attributes,
    357            const uint8_t *key_buffer,
    358            size_t key_buffer_size,
    359            psa_algorithm_t alg,
    360            const uint8_t *hash,
    361            size_t hash_length,
    362            uint8_t *signature,
    363            size_t signature_size,
    364            size_t *signature_length)
    365          {
   \                     sli_se_sign_hash: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x0007             MOVS     R7,R0
    366            #if defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    367            uint8_t* tmp_signature_p = signature;
    368            size_t tmp_signature_size = signature_size;
    369          
    370            // Argument check
    371            if (attributes == NULL
    372                || key_buffer == NULL
    373                || key_buffer_size == 0
    374                || hash == NULL
    375                || hash_length == 0
    376                || signature == NULL
    377                || signature_size == 0
    378                || signature_length == NULL) {
   \        0x8   0xBF18             IT       NE
   \        0xA   0xEA5F 0x0B01      MOVSNE   R11,R1
   \        0xE   0xD045             BEQ.N    ??sli_se_sign_hash_0
   \       0x10   0x9200             STR      R2,[SP, #+0]
   \       0x12   0x0010             MOVS     R0,R2
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x9C1E             LDRNE    R4,[SP, #+120]
   \       0x18   0x2C00             CMPNE    R4,#+0
   \       0x1A   0xD03F             BEQ.N    ??sli_se_sign_hash_0
   \       0x1C   0x9D1F             LDR      R5,[SP, #+124]
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xBF1C             ITT      NE
   \       0x22   0x9E20             LDRNE    R6,[SP, #+128]
   \       0x24   0x2E00             CMPNE    R6,#+0
   \       0x26   0xD039             BEQ.N    ??sli_se_sign_hash_0
   \       0x28   0xF8DD 0x9084      LDR      R9,[SP, #+132]
   \       0x2C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x30   0xBF1C             ITT      NE
   \       0x32   0xF8DD 0x8088      LDRNE    R8,[SP, #+136]
   \       0x36   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x3A   0xD02F             BEQ.N    ??sli_se_sign_hash_0
   \       0x3C   0x.... 0x....      BL       ?Subroutine9
    379              return PSA_ERROR_INVALID_ARGUMENT;
    380            }
    381          
    382            // Check the requested algorithm is ECDSA with randomized k
    383            if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x40   0xBF18             IT       NE
   \       0x42   0xF06F 0x0085      MVNNE    R0,#+133
    384              return PSA_ERROR_NOT_SUPPORTED;
   \       0x46   0xD14C             BNE.N    ??sli_se_sign_hash_1
    385            }
    386          
    387            // Ephemeral contexts
    388            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x48   0x.... 0x....      BL       ?Subroutine7
    389            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x4C   0x.... 0x....      BL       ?Subroutine8
    390          
    391            // Initialize key descriptor and verify key buffer size
    392            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
    393                                                                 key_buffer,
    394                                                                 key_buffer_size,
    395                                                                 &key_desc);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x50   0x9A00             LDR      R2,[SP, #+0]
   \       0x52   0xAB04             ADD      R3,SP,#+16
   \       0x54   0x4659             MOV      R1,R11
   \       0x56   0x4638             MOV      R0,R7
   \       0x58   0x.... 0x....      BL       sli_se_key_desc_from_input
    396            if (psa_status != PSA_SUCCESS) {
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD140             BNE.N    ??sli_se_sign_hash_1
    397              return psa_status;
    398            }
    399          
    400            // Verify and set key attributes
    401            psa_key_type_t keytype = psa_get_key_type(attributes);
    402          
    403            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
   \       0x60   0x8838             LDRH     R0,[R7, #+0]
   \       0x62   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x66   0xD119             BNE.N    ??sli_se_sign_hash_0
    404              // Validate that the input
    405              psa_status = check_curve_availability(attributes, alg);
   \       0x68   0x4651             MOV      R1,R10
   \       0x6A   0x4638             MOV      R0,R7
   \       0x6C   0x.... 0x....      BL       check_curve_availability
   \       0x70   0xEA5F 0x0A00      MOVS     R10,R0
    406              if (psa_status != PSA_SUCCESS) {
   \       0x74   0xD135             BNE.N    ??sli_se_sign_hash_1
    407                return psa_status;
    408              }
    409              if (signature_size
    410                  < PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \       0x76   0x4638             MOV      R0,R7
   \       0x78   0x.... 0x....      BL       psa_get_key_bits
   \       0x7C   0x1DC0             ADDS     R0,R0,#+7
   \       0x7E   0x08C0             LSRS     R0,R0,#+3
   \       0x80   0xEBB9 0x0F40      CMP      R9,R0, LSL #+1
   \       0x84   0xBF38             IT       CC
   \       0x86   0xF06F 0x0089      MVNCC    R0,#+137
    411                return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x8A   0xD32A             BCC.N    ??sli_se_sign_hash_1
    412              }
    413            } else {
    414              // Not able to sign using non-ECC keys, or using public keys
    415              return PSA_ERROR_INVALID_ARGUMENT;
    416            }
    417          
    418            size_t key_bits = psa_get_key_bits(attributes);
   \       0x8C   0x4638             MOV      R0,R7
   \       0x8E   0x.... 0x....      BL       psa_get_key_bits
    419            size_t key_size = PSA_BITS_TO_BYTES(key_bits);
   \       0x92   0x1DC7             ADDS     R7,R0,#+7
   \       0x94   0x08FF             LSRS     R7,R7,#+3
    420          
    421            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    422            size_t offset = sli_se_get_padding(key_size);
    423            #else
    424            size_t offset = 0;
    425            #endif
    426          
    427            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    428            // P-521 (or any curve size that's not word-multiple) requires alignment on
    429            // word boundaries, instead of byte boundaries such as PSA Crypto defines as
    430            // input here.
    431            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_KEY_PAIR_SIZE] = { 0 };
    432            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    433            psa_key_location_t location =
    434              PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    435          
    436            if (offset > 0) {
    437              // We can only manipulate the input key for transparent keys.
    438              // For opaque keys, we will just have to rely on the key import operation
    439              // handling this
    440              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    441                if ((offset + key_buffer_size) > sizeof(temp_key_buf)) {
    442                  return PSA_ERROR_INVALID_ARGUMENT;
    443                }
    444                sli_se_pad_big_endian(temp_key_buf, key_buffer, key_buffer_size);
    445                // Since we know that this must be a plaintext key, we can freely
    446                // modify the key descriptor
    447                key_desc.storage.location.buffer.pointer = temp_key_buf;
    448                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    449              }
    450          
    451              tmp_signature_p = temp_signature_buffer;
    452              tmp_signature_size = sizeof(temp_signature_buffer);
    453            }
    454            #endif   // SLI_SE_KEY_PADDING_REQUIRED
    455          
    456            if (tmp_signature_size < 2 * (offset + key_size)) {
   \       0x96   0x007F             LSLS     R7,R7,#+1
   \       0x98   0x45B9             CMP      R9,R7
   \       0x9A   0xD202             BCS.N    ??sli_se_sign_hash_2
    457              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_sign_hash_0: (+1)
   \       0x9C   0xF06F 0x0086      MVN      R0,#+134
   \       0xA0   0xE01F             B.N      ??sli_se_sign_hash_1
    458            }
    459            tmp_signature_size = 2 * (offset + key_size);
    460          
    461            sl_status_t status = sl_se_init_command_context(&cmd_ctx);
    462            if (status != SL_STATUS_OK) {
   \                     ??sli_se_sign_hash_2: (+1)
   \       0xA2   0xA80C             ADD      R0,SP,#+48
   \       0xA4   0xF06F 0x0992      MVN      R9,#+146
   \       0xA8   0x.... 0x....      BL       sl_se_init_command_context
   \       0xAC   0xB9B0             CBNZ.N   R0,??sli_se_sign_hash_3
    463              return PSA_ERROR_HARDWARE_FAILURE;
    464            }
    465          
    466            // Run signature generation
    467            status = sl_se_ecc_sign(&cmd_ctx,
    468                                    &key_desc,
    469                                    SL_SE_HASH_NONE,
    470                                    true,
    471                                    hash,
    472                                    hash_length,
    473                                    tmp_signature_p,
    474                                    tmp_signature_size);
   \       0xAE   0x9703             STR      R7,[SP, #+12]
   \       0xB0   0x9602             STR      R6,[SP, #+8]
   \       0xB2   0x9501             STR      R5,[SP, #+4]
   \       0xB4   0x9400             STR      R4,[SP, #+0]
   \       0xB6   0x2301             MOVS     R3,#+1
   \       0xB8   0x2200             MOVS     R2,#+0
   \       0xBA   0xA904             ADD      R1,SP,#+16
   \       0xBC   0xA80C             ADD      R0,SP,#+48
   \       0xBE   0x.... 0x....      BL       sl_se_ecc_sign
    475          
    476            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    477            if (offset > 0) {
    478              sli_psa_zeroize(temp_key_buf, sizeof(temp_key_buf));
    479              // Copy over from temp signature
    480              sli_se_unpad_curve_point(temp_signature_buffer, signature, key_size);
    481            }
    482            #endif   // SLI_SE_KEY_PADDING_REQUIRED
    483          
    484            if (status == SL_STATUS_OK) {
   \       0xC2   0xB910             CBNZ.N   R0,??sli_se_sign_hash_4
    485              *signature_length = PSA_ECDSA_SIGNATURE_SIZE(key_bits);
   \       0xC4   0xF8C8 0x7000      STR      R7,[R8, #+0]
    486              psa_status = PSA_SUCCESS;
   \       0xC8   0xE004             B.N      ??sli_se_sign_hash_5
    487            } else {
    488              if (status == SL_STATUS_FAIL) {
   \                     ??sli_se_sign_hash_4: (+1)
   \       0xCA   0x2801             CMP      R0,#+1
   \       0xCC   0xBF0C             ITE      EQ
   \       0xCE   0xF06F 0x0A8B      MVNEQ    R10,#+139
   \       0xD2   0x46CA             MOVNE    R10,R9
    489                psa_status = PSA_ERROR_DOES_NOT_EXIST;
    490              } else {
    491                psa_status = PSA_ERROR_HARDWARE_FAILURE;
    492              }
    493            }
    494          
    495            // Cleanup
    496            status = sl_se_deinit_command_context(&cmd_ctx);
    497            if (status != SL_STATUS_OK) {
   \                     ??sli_se_sign_hash_5: (+1)
   \       0xD4   0xA80C             ADD      R0,SP,#+48
   \       0xD6   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xDA   0xB108             CBZ.N    R0,??sli_se_sign_hash_6
    498              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_sign_hash_3: (+1)
   \       0xDC   0x4648             MOV      R0,R9
   \       0xDE   0xE000             B.N      ??sli_se_sign_hash_1
    499            }
    500            return psa_status;
   \                     ??sli_se_sign_hash_6: (+1)
   \       0xE0   0x4650             MOV      R0,R10
   \                     ??sli_se_sign_hash_1: (+1)
   \       0xE2                      REQUIRE ?Subroutine0
   \       0xE2                      ;; // Fall through to label ?Subroutine0
    501          
    502            #else // SLI_PSA_DRIVER_FEATURE_ECDSA
    503          
    504            (void) attributes;
    505            (void) key_buffer;
    506            (void) key_buffer_size;
    507            (void) alg;
    508            (void) hash;
    509            (void) hash_length;
    510            (void) signature;
    511            (void) signature_size;
    512            (void) signature_length;
    513          
    514            return PSA_ERROR_NOT_SUPPORTED;
    515          
    516            #endif  // SLI_PSA_DRIVER_FEATURE_ECDSA
    517          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x469A             MOV      R10,R3
   \        0x2   0xEA4F 0x201A      LSR      R0,R10,#+8
   \        0x6   0x0200             LSLS     R0,R0,#+8
   \        0x8   0xF1B0 0x2F06      CMP      R0,#+100664832
   \        0xC   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    518          

   \                                 In section .text, align 2, keep-with-next
    519          static psa_status_t sli_se_verify_message(
    520            const psa_key_attributes_t *attributes,
    521            const uint8_t *key_buffer,
    522            size_t key_buffer_size,
    523            psa_algorithm_t alg,
    524            const uint8_t *input,
    525            size_t input_length,
    526            const uint8_t *signature,
    527            size_t signature_length)
    528          {
   \                     sli_se_verify_message: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0BC             SUB      SP,SP,#+240
   \        0x6   0x0004             MOVS     R4,R0
    529            #if defined(SLI_PSA_DRIVER_FEATURE_SIGNATURE)
    530          
    531            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
    532          
    533            // Argument check.
    534            if (attributes == NULL
    535                || key_buffer == NULL
    536                || key_buffer_size == 0
    537                || (input == NULL && input_length > 0)
    538                || signature == NULL) {
   \        0x8   0xBF1C             ITT      NE
   \        0xA   0xEA5F 0x0B01      MOVSNE   R11,R1
   \        0xE   0xEA5F 0x0A02      MOVSNE   R10,R2
   \       0x12   0xD005             BEQ.N    ??sli_se_verify_message_0
   \       0x14   0x9846             LDR      R0,[SP, #+280]
   \       0x16   0x9D47             LDR      R5,[SP, #+284]
   \       0x18   0xB900             CBNZ.N   R0,??sli_se_verify_message_1
   \       0x1A   0xB90D             CBNZ.N   R5,??sli_se_verify_message_0
   \                     ??sli_se_verify_message_1: (+1)
   \       0x1C   0x9E48             LDR      R6,[SP, #+288]
   \       0x1E   0xB916             CBNZ.N   R6,??sli_se_verify_message_2
    539              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_verify_message_0: (+1)
   \       0x20   0xF06F 0x0086      MVN      R0,#+134
   \       0x24   0xE084             B.N      ??sli_se_verify_message_3
    540            }
    541          
    542            // Verify can happen with a public or private key
    543            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(psa_get_key_type(attributes))
    544                || PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(psa_get_key_type(attributes))) {
   \                     ??sli_se_verify_message_2: (+1)
   \       0x26   0x8821             LDRH     R1,[R4, #+0]
   \       0x28   0xF06F 0x0985      MVN      R9,#+133
   \       0x2C   0xF021 0x00FF      BIC      R0,R1,#0xFF
   \       0x30   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x34   0xBF1C             ITT      NE
   \       0x36   0xF021 0x01FF      BICNE    R1,R1,#0xFF
   \       0x3A   0xF5B1 0x4F82      CMPNE    R1,#+16640
   \       0x3E   0xD14A             BNE.N    ??sli_se_verify_message_4
   \       0x40   0x9300             STR      R3,[SP, #+0]
    545              // Check the requested algorithm is supported and matches the key type
    546              psa_status = check_curve_availability(attributes, alg);
   \       0x42   0x4619             MOV      R1,R3
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       check_curve_availability
    547              if (psa_status != PSA_SUCCESS) {
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD170             BNE.N    ??sli_se_verify_message_3
    548                return psa_status;
    549              }
    550            } else {
    551              return PSA_ERROR_NOT_SUPPORTED;
    552            }
    553          
    554            // Check the requested hashing algorithm is supported
    555            if (get_hash_for_algorithm(alg) == SL_SE_HASH_NONE) {
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x.... 0x....      BL       get_hash_for_algorithm
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD03E             BEQ.N    ??sli_se_verify_message_4
   \       0x58   0x9F49             LDR      R7,[SP, #+292]
    556              return PSA_ERROR_NOT_SUPPORTED;
    557            }
    558          
    559            if (signature_length == 0) {
   \       0x5A   0xF06F 0x0894      MVN      R8,#+148
   \       0x5E   0xB1B7             CBZ.N    R7,??sli_se_verify_message_5
    560              return PSA_ERROR_INVALID_SIGNATURE;
    561            }
    562          
    563            // Ephemeral contexts
    564            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x60   0xA811             ADD      R0,SP,#+68
   \       0x62   0x.... 0x....      BL       ??Subroutine7_0
    565            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x66   0xA809             ADD      R0,SP,#+36
   \       0x68   0x.... 0x....      BL       ??Subroutine8_0
    566          
    567            psa_status = sli_se_key_desc_from_input(attributes,
    568                                                    key_buffer,
    569                                                    key_buffer_size,
    570                                                    &key_desc);
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x6C   0xAB09             ADD      R3,SP,#+36
   \       0x6E   0x4652             MOV      R2,R10
   \       0x70   0x4659             MOV      R1,R11
   \       0x72   0x4620             MOV      R0,R4
   \       0x74   0x.... 0x....      BL       sli_se_key_desc_from_input
   \       0x78   0xEA5F 0x0A00      MOVS     R10,R0
    571            if (psa_status != PSA_SUCCESS) {
   \       0x7C   0xD158             BNE.N    ??sli_se_verify_message_3
    572              return psa_status;
    573            }
    574          
    575            // Validate that the signature input is of the expected length.
    576            // Both ECDSA and EdDSA share the same signature size.
    577            if (signature_length
    578                != PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x.... 0x....      BL       psa_get_key_bits
   \       0x84   0x1DC0             ADDS     R0,R0,#+7
   \       0x86   0x08C0             LSRS     R0,R0,#+3
   \       0x88   0xEBB7 0x0F40      CMP      R7,R0, LSL #+1
   \       0x8C   0xD001             BEQ.N    ??sli_se_verify_message_6
    579              return PSA_ERROR_INVALID_SIGNATURE;
   \                     ??sli_se_verify_message_5: (+1)
   \       0x8E   0x4640             MOV      R0,R8
   \       0x90   0xE04E             B.N      ??sli_se_verify_message_3
    580            }
   \                     ??sli_se_verify_message_6: (+1)
   \       0x92   0x2188             MOVS     R1,#+136
   \       0x94   0x2200             MOVS     R2,#+0
   \       0x96   0xA81A             ADD      R0,SP,#+104
   \       0x98   0x.... 0x....      BL       __aeabi_memset
    581          
    582            // Verify and set key attributes
    583            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    584            psa_key_type_t keytype = psa_get_key_type(attributes);
    585          
    586            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    587            // P-521 (or any curve size that's not word-multiple) requires alignment on word
    588            // boundaries, instead of byte boundaries such as PSA Crypto defines as input here.
    589            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    590            size_t key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
    591            size_t offset = sli_se_get_padding(key_size);
    592            if (offset > 0) {
    593              psa_key_location_t location =
    594                PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    595          
    596              // Only pad transparent keys.
    597              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    598                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
    599                  if (offset + key_size > sizeof(temp_key_buf)) {
    600                    return PSA_ERROR_INVALID_ARGUMENT;
    601                  }
    602                  sli_se_pad_big_endian(temp_key_buf,
    603                                        key_desc.storage.location.buffer.pointer,
    604                                        key_size);
    605                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(keytype)) {
    606                  if ((2 * (offset + key_size)) > sizeof(temp_key_buf)) {
    607                    return PSA_ERROR_INVALID_ARGUMENT;
    608                  }
    609                  sli_se_pad_curve_point(temp_key_buf,
    610                                         key_desc.storage.location.buffer.pointer,
    611                                         key_size);
    612                } else {
    613                  return PSA_ERROR_CORRUPTION_DETECTED;
    614                }
    615                key_desc.storage.location.buffer.pointer = temp_key_buf;
    616                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    617              }
    618          
    619              // Always pad signature
    620              if ((2 * (offset + key_size)) > sizeof(temp_signature_buffer)) {
    621                return PSA_ERROR_INVALID_ARGUMENT;
    622              }
    623              sli_se_pad_curve_point(temp_signature_buffer, signature, key_size);
    624          
    625              signature = temp_signature_buffer;
    626              signature_length = signature_length + 2 * offset;
    627            }
    628            #endif   // SLI_SE_KEY_PADDING_REQUIRED && SLI_PSA_DRIVER_FEATURE_ECDSA
    629          
    630            // SE manager only accepts public keys for signature verification,
    631            // so we must generate a public key if we are passed a private one
    632            sl_status_t status = SL_STATUS_INVALID_PARAMETER;
    633            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
   \       0x9C   0x8820             LDRH     R0,[R4, #+0]
   \       0x9E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0xA2   0xD11E             BNE.N    ??CrossCallReturnLabel_25
    634              #if defined(SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED)
    635              psa_status = sli_se_check_eddsa_errata(attributes, &cmd_ctx);
    636              if (psa_status != PSA_SUCCESS) {
    637                return psa_status;
    638              }
    639              #endif   // SLI_SE_VERSION_ED25519_ERRATA_CHECK_REQUIRED
    640          
    641              // Create similar key descriptor for temporary public key.
    642              sl_se_key_descriptor_t pubkey_desc = key_desc;
   \       0xA4   0xA801             ADD      R0,SP,#+4
   \       0xA6   0xA909             ADD      R1,SP,#+36
   \       0xA8   0x.... 0x....      BL       ?Subroutine12
    643              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
    644              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_IS_RESTRICTED;
    645              pubkey_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0xAC   0x9903             LDR      R1,[SP, #+12]
   \       0xAE   0x.... 0x....      BL       ?Subroutine11
    646              sli_se_key_descriptor_set_plaintext(&pubkey_desc, temp_key_buf, sizeof(temp_key_buf));
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0xB2   0x9103             STR      R1,[SP, #+12]
   \       0xB4   0xA91A             ADD      R1,SP,#+104
   \       0xB6   0xA801             ADD      R0,SP,#+4
   \       0xB8   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    647          
    648              status = sl_se_init_command_context(&cmd_ctx);
    649              if (status != SL_STATUS_OK) {
   \       0xBC   0xA811             ADD      R0,SP,#+68
   \       0xBE   0x.... 0x....      BL       sl_se_init_command_context
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD131             BNE.N    ??sli_se_verify_message_7
    650                return PSA_ERROR_HARDWARE_FAILURE;
    651              }
    652          
    653              status = sl_se_export_public_key(&cmd_ctx, &key_desc, &pubkey_desc);
   \       0xC6   0xAA01             ADD      R2,SP,#+4
   \       0xC8   0xA909             ADD      R1,SP,#+36
   \       0xCA   0xA811             ADD      R0,SP,#+68
   \       0xCC   0x.... 0x....      BL       sl_se_export_public_key
    654              if (status != SL_STATUS_OK) {
   \       0xD0   0xB118             CBZ.N    R0,??sli_se_verify_message_8
    655                if (status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0xD2   0x2848             CMP      R0,#+72
   \       0xD4   0xD129             BNE.N    ??sli_se_verify_message_7
    656                  // This error will be returned if the key type isn't supported.
    657                  return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_verify_message_4: (+1)
   \       0xD6   0x4648             MOV      R0,R9
   \       0xD8   0xE02A             B.N      ??sli_se_verify_message_3
    658                } else {
    659                  return PSA_ERROR_HARDWARE_FAILURE;
    660                }
    661              }
    662          
    663              // Set the key desc to the public key, and move on.
    664              key_desc = pubkey_desc;
   \                     ??sli_se_verify_message_8: (+1)
   \       0xDA   0xA809             ADD      R0,SP,#+36
   \       0xDC   0xA901             ADD      R1,SP,#+4
   \       0xDE   0x.... 0x....      BL       ?Subroutine12
    665            }
    666          
    667            status = sl_se_init_command_context(&cmd_ctx);
    668            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0xE2   0xA811             ADD      R0,SP,#+68
   \       0xE4   0x.... 0x....      BL       sl_se_init_command_context
   \       0xE8   0xB9F8             CBNZ.N   R0,??sli_se_verify_message_7
    669              return PSA_ERROR_HARDWARE_FAILURE;
    670            }
    671          
    672            // Run signature verification
    673            status = sl_se_ecc_verify(&cmd_ctx,
    674                                      &key_desc,
    675                                      get_hash_for_algorithm(alg),
    676                                      false,
    677                                      input,
    678                                      input_length,
    679                                      signature,
    680                                      signature_length);
   \       0xEA   0x9800             LDR      R0,[SP, #+0]
   \       0xEC   0x.... 0x....      BL       get_hash_for_algorithm
   \       0xF0   0x9946             LDR      R1,[SP, #+280]
   \       0xF2   0x4602             MOV      R2,R0
   \       0xF4   0x9703             STR      R7,[SP, #+12]
   \       0xF6   0x9100             STR      R1,[SP, #+0]
   \       0xF8   0x9602             STR      R6,[SP, #+8]
   \       0xFA   0x9501             STR      R5,[SP, #+4]
   \       0xFC   0x2300             MOVS     R3,#+0
   \       0xFE   0xA909             ADD      R1,SP,#+36
   \      0x100   0xA811             ADD      R0,SP,#+68
   \      0x102   0x.... 0x....      BL       sl_se_ecc_verify
    681          
    682            if (status == SL_STATUS_OK) {
   \      0x106   0xB160             CBZ.N    R0,??sli_se_verify_message_9
    683              psa_status = PSA_SUCCESS;
    684            } else if (status == SL_STATUS_INVALID_SIGNATURE) {
   \      0x108   0x282C             CMP      R0,#+44
   \      0x10A   0xBF08             IT       EQ
   \      0x10C   0x46C2             MOVEQ    R10,R8
    685              // Signature was invalid.
    686              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   \      0x10E   0xD008             BEQ.N    ??sli_se_verify_message_9
    687            } else if (status == SL_STATUS_FAIL) {
   \      0x110   0x2801             CMP      R0,#+1
   \      0x112   0xBF08             IT       EQ
   \      0x114   0xF06F 0x0A8B      MVNEQ    R10,#+139
    688              // Built-in key does not exist.
    689              psa_status = PSA_ERROR_DOES_NOT_EXIST;
   \      0x118   0xD003             BEQ.N    ??sli_se_verify_message_9
    690            } else if (status == SL_STATUS_COMMAND_IS_INVALID) {
   \      0x11A   0x2848             CMP      R0,#+72
   \      0x11C   0xBF0C             ITE      EQ
   \      0x11E   0x46CA             MOVEQ    R10,R9
   \      0x120   0x46DA             MOVNE    R10,R11
    691              // Key type is not supported.
    692              psa_status = PSA_ERROR_NOT_SUPPORTED;
    693            } else {
    694              psa_status = PSA_ERROR_HARDWARE_FAILURE;
    695            }
    696          
    697            // Cleanup
    698            status = sl_se_deinit_command_context(&cmd_ctx);
    699            if (status != SL_STATUS_OK) {
   \                     ??sli_se_verify_message_9: (+1)
   \      0x122   0xA811             ADD      R0,SP,#+68
   \      0x124   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x128   0xB108             CBZ.N    R0,??sli_se_verify_message_10
    700              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_verify_message_7: (+1)
   \      0x12A   0x4658             MOV      R0,R11
   \      0x12C   0xE000             B.N      ??sli_se_verify_message_3
    701            }
    702          
    703            return psa_status;
   \                     ??sli_se_verify_message_10: (+1)
   \      0x12E   0x4650             MOV      R0,R10
   \                     ??sli_se_verify_message_3: (+1)
   \      0x130   0xB03D             ADD      SP,SP,#+244
   \      0x132   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    704          
    705            #else // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    706          
    707            (void) attributes;
    708            (void) key_buffer;
    709            (void) key_buffer_size;
    710            (void) alg;
    711            (void) input;
    712            (void) input_length;
    713            (void) signature;
    714            (void) signature_length;
    715          
    716            return PSA_ERROR_NOT_SUPPORTED;
    717          
    718            #endif  // SLI_PSA_DRIVER_FEATURE_SIGNATURE
    719          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x2220             MOVS     R2,#+32
   \        0x2   0x.... 0x....      B.W      __aeabi_memcpy4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable7_7
   \        0x2   0x2288             MOVS     R2,#+136
   \        0x4   0x4001             ANDS     R1,R0,R1
   \        0x6   0xF441 0x5100      ORR      R1,R1,#0x2000
   \        0xA   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    720          

   \                                 In section .text, align 2, keep-with-next
    721          static psa_status_t sli_se_verify_hash(
    722            const psa_key_attributes_t *attributes,
    723            const uint8_t *key_buffer,
    724            size_t key_buffer_size,
    725            psa_algorithm_t alg,
    726            const uint8_t *hash,
    727            size_t hash_length,
    728            const uint8_t *signature,
    729            size_t signature_length)
    730          {
   \                     sli_se_verify_hash: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB0BB             SUB      SP,SP,#+236
   \        0x6   0xEA5F 0x0800      MOVS     R8,R0
    731            #if defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    732          
    733            // Argument check.
    734            if (attributes == NULL
    735                || key_buffer == NULL
    736                || key_buffer_size == 0
    737                || hash == NULL
    738                || hash_length == 0
    739                || signature == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0xEA5F 0x0B01      MOVSNE   R11,R1
   \       0x10   0xD00B             BEQ.N    ??sli_se_verify_hash_0
   \       0x12   0x9200             STR      R2,[SP, #+0]
   \       0x14   0x0010             MOVS     R0,R2
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x9D44             LDRNE    R5,[SP, #+272]
   \       0x1A   0x2D00             CMPNE    R5,#+0
   \       0x1C   0xD005             BEQ.N    ??sli_se_verify_hash_0
   \       0x1E   0x9E45             LDR      R6,[SP, #+276]
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xBF1C             ITT      NE
   \       0x24   0x9F46             LDRNE    R7,[SP, #+280]
   \       0x26   0x2F00             CMPNE    R7,#+0
   \       0x28   0xD102             BNE.N    ??sli_se_verify_hash_1
    740              return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_verify_hash_0: (+1)
   \       0x2A   0xF06F 0x0086      MVN      R0,#+134
   \       0x2E   0xE073             B.N      ??sli_se_verify_hash_2
    741            }
   \                     ??sli_se_verify_hash_1: (+1)
   \       0x30   0x9C47             LDR      R4,[SP, #+284]
    742          
    743            if (signature_length == 0) {
   \       0x32   0xF06F 0x0994      MVN      R9,#+148
   \       0x36   0xB1D4             CBZ.N    R4,??sli_se_verify_hash_3
   \       0x38   0x.... 0x....      BL       ?Subroutine9
    744              return PSA_ERROR_INVALID_SIGNATURE;
    745            }
    746          
    747            // Check the requested algorithm is ECDSA with randomized k
    748            if (!PSA_ALG_IS_RANDOMIZED_ECDSA(alg)) {
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x3C   0xBF18             IT       NE
   \       0x3E   0xF06F 0x0085      MVNNE    R0,#+133
    749              return PSA_ERROR_NOT_SUPPORTED;
   \       0x42   0xD169             BNE.N    ??sli_se_verify_hash_2
    750            }
    751          
    752            // Ephemeral contexts
    753            sl_se_command_context_t cmd_ctx = { 0 };
   \       0x44   0xA810             ADD      R0,SP,#+64
   \       0x46   0x.... 0x....      BL       ??Subroutine7_0
    754            sl_se_key_descriptor_t key_desc = { 0 };
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x4A   0xA808             ADD      R0,SP,#+32
   \       0x4C   0x.... 0x....      BL       ??Subroutine8_0
    755          
    756            psa_status_t psa_status = sli_se_key_desc_from_input(attributes,
    757                                                                 key_buffer,
    758                                                                 key_buffer_size,
    759                                                                 &key_desc);
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x50   0x9A00             LDR      R2,[SP, #+0]
   \       0x52   0xAB08             ADD      R3,SP,#+32
   \       0x54   0x4659             MOV      R1,R11
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x.... 0x....      BL       sli_se_key_desc_from_input
    760            if (psa_status != PSA_SUCCESS) {
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD15B             BNE.N    ??sli_se_verify_hash_2
    761              return psa_status;
    762            }
    763          
    764            // Verify and set key attributes
    765            if (signature_length
    766                != PSA_ECDSA_SIGNATURE_SIZE(psa_get_key_bits(attributes))) {
   \       0x60   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x64   0x1DC0             ADDS     R0,R0,#+7
   \       0x66   0x08C0             LSRS     R0,R0,#+3
   \       0x68   0xEBB4 0x0F40      CMP      R4,R0, LSL #+1
   \       0x6C   0xD001             BEQ.N    ??sli_se_verify_hash_4
    767              return PSA_ERROR_INVALID_SIGNATURE;
   \                     ??sli_se_verify_hash_3: (+1)
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0xE052             B.N      ??sli_se_verify_hash_2
    768            }
    769            psa_status = check_curve_availability(attributes, alg);
   \                     ??sli_se_verify_hash_4: (+1)
   \       0x72   0x4651             MOV      R1,R10
   \       0x74   0x4640             MOV      R0,R8
   \       0x76   0x.... 0x....      BL       check_curve_availability
   \       0x7A   0xEA5F 0x0A00      MOVS     R10,R0
    770            if (psa_status != PSA_SUCCESS) {
   \       0x7E   0xD14B             BNE.N    ??sli_se_verify_hash_2
   \       0x80   0x2188             MOVS     R1,#+136
   \       0x82   0x2200             MOVS     R2,#+0
   \       0x84   0xA819             ADD      R0,SP,#+100
   \       0x86   0x.... 0x....      BL       __aeabi_memset
    771              return psa_status;
    772            }
    773          
    774            uint8_t temp_key_buf[SLI_SE_MAX_PADDED_PUBLIC_KEY_SIZE] = { 0 };
    775            psa_key_type_t keytype = psa_get_key_type(attributes);
    776          
    777            #if defined(SLI_SE_KEY_PADDING_REQUIRED) && defined(SLI_PSA_DRIVER_FEATURE_ECDSA)
    778            // P-521 (or any curve size that's not word-multiple) requires alignment on word
    779            // boundaries, instead of byte boundaries such as PSA Crypto defines as input here.
    780            uint8_t temp_signature_buffer[SLI_SE_MAX_PADDED_SIGNATURE_SIZE] = { 0 };
    781            size_t key_size = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
    782            size_t offset = sli_se_get_padding(key_size);
    783            if (offset > 0) {
    784              psa_key_location_t location =
    785                PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes));
    786          
    787              // Only pad transparent keys.
    788              if (location == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    789                if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
    790                  if (offset + key_size > sizeof(temp_key_buf)) {
    791                    return PSA_ERROR_INVALID_ARGUMENT;
    792                  }
    793                  sli_se_pad_big_endian(temp_key_buf,
    794                                        key_desc.storage.location.buffer.pointer,
    795                                        key_size);
    796                } else if (PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY(keytype)) {
    797                  if ((2 * (offset + key_size)) > sizeof(temp_key_buf)) {
    798                    return PSA_ERROR_INVALID_ARGUMENT;
    799                  }
    800                  sli_se_pad_curve_point(temp_key_buf,
    801                                         key_desc.storage.location.buffer.pointer,
    802                                         key_size);
    803                } else {
    804                  return PSA_ERROR_CORRUPTION_DETECTED;
    805                }
    806                key_desc.storage.location.buffer.pointer = temp_key_buf;
    807                key_desc.storage.location.buffer.size = sizeof(temp_key_buf);
    808              }
    809          
    810              // Always pad signature
    811              if ((2 * (offset + key_size)) > sizeof(temp_signature_buffer)) {
    812                return PSA_ERROR_INVALID_ARGUMENT;
    813              }
    814              sli_se_pad_curve_point(temp_signature_buffer, signature, key_size);
    815          
    816              signature = temp_signature_buffer;
    817              signature_length = signature_length + 2 * offset;
    818            }
    819            #endif   // SLI_SE_KEY_PADDING_REQUIRED && SLI_PSA_DRIVER_FEATURE_ECDSA
    820          
    821            // SE manager only accepts public keys for signature verification,
    822            // so we must generate a public key if we are passed a private one
    823            sl_status_t status = SL_STATUS_INVALID_PARAMETER;
    824            if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(keytype)) {
   \       0x8A   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \       0x8E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x92   0xD122             BNE.N    ??CrossCallReturnLabel_27
    825              sl_se_key_descriptor_t pubkey_desc = key_desc;
   \       0x94   0x4668             MOV      R0,SP
   \       0x96   0xA908             ADD      R1,SP,#+32
   \       0x98   0x.... 0x....      BL       ?Subroutine12
    826              // Unset private key flag and set public
    827              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
    828              pubkey_desc.flags &= ~SL_SE_KEY_FLAG_IS_RESTRICTED;
    829              pubkey_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x9C   0x9902             LDR      R1,[SP, #+8]
   \       0x9E   0x.... 0x....      BL       ?Subroutine11
    830              sli_se_key_descriptor_set_plaintext(&pubkey_desc, temp_key_buf, sizeof(temp_key_buf));
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xA2   0x9102             STR      R1,[SP, #+8]
   \       0xA4   0xA919             ADD      R1,SP,#+100
   \       0xA6   0x4668             MOV      R0,SP
   \       0xA8   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    831              // Same input output region
    832              status = sl_se_init_command_context(&cmd_ctx);
    833              if (status != SL_STATUS_OK) {
   \       0xAC   0xA810             ADD      R0,SP,#+64
   \       0xAE   0x.... 0x....      BL       sl_se_init_command_context
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD12D             BNE.N    ??sli_se_verify_hash_5
    834                return PSA_ERROR_HARDWARE_FAILURE;
    835              }
    836              status = sl_se_export_public_key(&cmd_ctx, &key_desc, &pubkey_desc);
   \       0xB6   0x466A             MOV      R2,SP
   \       0xB8   0xA908             ADD      R1,SP,#+32
   \       0xBA   0xA810             ADD      R0,SP,#+64
   \       0xBC   0x.... 0x....      BL       sl_se_export_public_key
   \       0xC0   0x4680             MOV      R8,R0
    837              if (sl_se_deinit_command_context(&cmd_ctx) != SL_STATUS_OK) {
   \       0xC2   0xA810             ADD      R0,SP,#+64
   \       0xC4   0x.... 0x....      BL       sl_se_deinit_command_context
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xBF08             IT       EQ
   \       0xCC   0xF1B8 0x0F00      CMPEQ    R8,#+0
    838                return PSA_ERROR_HARDWARE_FAILURE;
    839              }
    840              if (status) {
   \       0xD0   0xD11F             BNE.N    ??sli_se_verify_hash_5
    841                return PSA_ERROR_HARDWARE_FAILURE;
    842              }
    843              // Set the key desc to the public key, and go on
    844              key_desc = pubkey_desc;
   \       0xD2   0xA808             ADD      R0,SP,#+32
   \       0xD4   0x4669             MOV      R1,SP
   \       0xD6   0x.... 0x....      BL       ?Subroutine12
    845            }
    846          
    847            status = sl_se_init_command_context(&cmd_ctx);
    848            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0xDA   0xA810             ADD      R0,SP,#+64
   \       0xDC   0x.... 0x....      BL       sl_se_init_command_context
   \       0xE0   0xB9B8             CBNZ.N   R0,??sli_se_verify_hash_5
    849              return PSA_ERROR_HARDWARE_FAILURE;
    850            }
    851          
    852            // Run signature verification
    853            status = sl_se_ecc_verify(&cmd_ctx,
    854                                      &key_desc,
    855                                      SL_SE_HASH_NONE,
    856                                      true,
    857                                      hash,
    858                                      hash_length,
    859                                      signature,
    860                                      signature_length);
   \       0xE2   0x9403             STR      R4,[SP, #+12]
   \       0xE4   0x9702             STR      R7,[SP, #+8]
   \       0xE6   0x9601             STR      R6,[SP, #+4]
   \       0xE8   0x9500             STR      R5,[SP, #+0]
   \       0xEA   0x2301             MOVS     R3,#+1
   \       0xEC   0x2200             MOVS     R2,#+0
   \       0xEE   0xA908             ADD      R1,SP,#+32
   \       0xF0   0xA810             ADD      R0,SP,#+64
   \       0xF2   0x.... 0x....      BL       sl_se_ecc_verify
    861          
    862            if (status == SL_STATUS_OK) {
   \       0xF6   0xB140             CBZ.N    R0,??sli_se_verify_hash_6
    863              psa_status = PSA_SUCCESS;
    864            } else if (status == SL_STATUS_INVALID_SIGNATURE) {
   \       0xF8   0x282C             CMP      R0,#+44
   \       0xFA   0xBF08             IT       EQ
   \       0xFC   0x46CA             MOVEQ    R10,R9
    865              psa_status = PSA_ERROR_INVALID_SIGNATURE;
   \       0xFE   0xD004             BEQ.N    ??sli_se_verify_hash_6
    866            } else if (status == SL_STATUS_FAIL) {
   \      0x100   0x2801             CMP      R0,#+1
   \      0x102   0xBF0C             ITE      EQ
   \      0x104   0xF06F 0x0A8B      MVNEQ    R10,#+139
   \      0x108   0x46DA             MOVNE    R10,R11
    867              psa_status = PSA_ERROR_DOES_NOT_EXIST;
    868            } else {
    869              psa_status = PSA_ERROR_HARDWARE_FAILURE;
    870            }
    871          
    872            // Cleanup
    873            status = sl_se_deinit_command_context(&cmd_ctx);
    874            if (status != SL_STATUS_OK) {
   \                     ??sli_se_verify_hash_6: (+1)
   \      0x10A   0xA810             ADD      R0,SP,#+64
   \      0x10C   0x.... 0x....      BL       sl_se_deinit_command_context
   \      0x110   0xB108             CBZ.N    R0,??sli_se_verify_hash_7
    875              return PSA_ERROR_HARDWARE_FAILURE;
   \                     ??sli_se_verify_hash_5: (+1)
   \      0x112   0x4658             MOV      R0,R11
   \      0x114   0xE000             B.N      ??sli_se_verify_hash_2
    876            }
    877          
    878            return psa_status;
   \                     ??sli_se_verify_hash_7: (+1)
   \      0x116   0x4650             MOV      R0,R10
   \                     ??sli_se_verify_hash_2: (+1)
   \      0x118   0xB03B             ADD      SP,SP,#+236
   \      0x11A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    879          
    880            #else // SLI_PSA_DRIVER_FEATURE_ECDSA
    881          
    882            (void) attributes;
    883            (void) key_buffer;
    884            (void) key_buffer_size;
    885            (void) alg;
    886            (void) hash;
    887            (void) hash_length;
    888            (void) signature;
    889            (void) signature_length;
    890          
    891            return PSA_ERROR_NOT_SUPPORTED;
    892          
    893            #endif // SLI_PSA_DRIVER_FEATURE_ECDSA
    894          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
   \       0x20                      DS8 4

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28
    895          
    896          // -----------------------------------------------------------------------------
    897          // Opaque driver entry points
    898          

   \                                 In section .text, align 2, keep-with-next
    899          psa_status_t sli_se_opaque_sign_message(const psa_key_attributes_t *attributes,
    900                                                  const uint8_t *key_buffer,
    901                                                  size_t key_buffer_size,
    902                                                  psa_algorithm_t alg,
    903                                                  const uint8_t *input,
    904                                                  size_t input_length,
    905                                                  uint8_t *signature,
    906                                                  size_t signature_size,
    907                                                  size_t *signature_length)
    908          {
   \                     sli_se_opaque_sign_message: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB085             SUB      SP,SP,#+20
    909            return sli_se_sign_message(attributes,
    910                                       key_buffer,
    911                                       key_buffer_size,
    912                                       alg,
    913                                       input,
    914                                       input_length,
    915                                       signature,
    916                                       signature_size,
    917                                       signature_length);
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_18: (+1)
   \        0x6   0x.... 0x....      BL       sli_se_sign_message
   \        0xA   0xB005             ADD      SP,SP,#+20
   \        0xC   0xBD30             POP      {R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x9C0C             LDR      R4,[SP, #+48]
   \        0x2   0x9D0B             LDR      R5,[SP, #+44]
   \        0x4   0x9404             STR      R4,[SP, #+16]
   \                     ??Subroutine10_0: (+1)
   \        0x6   0x9C0A             LDR      R4,[SP, #+40]
   \        0x8   0x9503             STR      R5,[SP, #+12]
   \        0xA   0x9D09             LDR      R5,[SP, #+36]
   \        0xC   0x9402             STR      R4,[SP, #+8]
   \        0xE   0x9C08             LDR      R4,[SP, #+32]
   \       0x10   0x9501             STR      R5,[SP, #+4]
   \       0x12   0x9400             STR      R4,[SP, #+0]
   \       0x14   0x4770             BX       LR
    918          }
    919          

   \                                 In section .text, align 2, keep-with-next
    920          psa_status_t sli_se_opaque_sign_hash(const psa_key_attributes_t *attributes,
    921                                               const uint8_t *key_buffer,
    922                                               size_t key_buffer_size,
    923                                               psa_algorithm_t alg,
    924                                               const uint8_t *hash,
    925                                               size_t hash_length,
    926                                               uint8_t *signature,
    927                                               size_t signature_size,
    928                                               size_t *signature_length)
    929          {
   \                     sli_se_opaque_sign_hash: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x....             B.N      ?Subroutine2

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xB085             SUB      SP,SP,#+20
    930            return sli_se_sign_hash(attributes,
    931                                    key_buffer,
    932                                    key_buffer_size,
    933                                    alg,
    934                                    hash,
    935                                    hash_length,
    936                                    signature,
    937                                    signature_size,
    938                                    signature_length);
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_19: (+1)
   \        0x6   0x.... 0x....      BL       sli_se_sign_hash
   \        0xA   0xB005             ADD      SP,SP,#+20
   \        0xC   0xBD30             POP      {R4,R5,PC}
    939          }
    940          

   \                                 In section .text, align 2, keep-with-next
    941          psa_status_t sli_se_opaque_verify_message(const psa_key_attributes_t *attributes,
    942                                                    const uint8_t *key_buffer,
    943                                                    size_t key_buffer_size,
    944                                                    psa_algorithm_t alg,
    945                                                    const uint8_t * input,
    946                                                    size_t input_length,
    947                                                    const uint8_t * signature,
    948                                                    size_t signature_length)
    949          {
   \                     sli_se_opaque_verify_message: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             B.N      ?Subroutine3

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xB084             SUB      SP,SP,#+16
    950            return sli_se_verify_message(attributes,
    951                                         key_buffer,
    952                                         key_buffer_size,
    953                                         alg,
    954                                         input,
    955                                         input_length,
    956                                         signature,
    957                                         signature_length);
   \        0x2   0x9D0B             LDR      R5,[SP, #+44]
   \        0x4   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_20: (+1)
   \        0x8   0x.... 0x....      BL       sli_se_verify_message
   \        0xC   0xB005             ADD      SP,SP,#+20
   \        0xE   0xBD30             POP      {R4,R5,PC}
    958          }
    959          

   \                                 In section .text, align 2, keep-with-next
    960          psa_status_t sli_se_opaque_verify_hash(const psa_key_attributes_t *attributes,
    961                                                 const uint8_t *key_buffer,
    962                                                 size_t key_buffer_size,
    963                                                 psa_algorithm_t alg,
    964                                                 const uint8_t *hash,
    965                                                 size_t hash_length,
    966                                                 const uint8_t *signature,
    967                                                 size_t signature_length)
    968          {
   \                     sli_se_opaque_verify_hash: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             B.N      ?Subroutine4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xB084             SUB      SP,SP,#+16
    969            return sli_se_verify_hash(attributes,
    970                                      key_buffer,
    971                                      key_buffer_size,
    972                                      alg,
    973                                      hash,
    974                                      hash_length,
    975                                      signature,
    976                                      signature_length);
   \        0x2   0x9D0B             LDR      R5,[SP, #+44]
   \        0x4   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_21: (+1)
   \        0x8   0x.... 0x....      BL       sli_se_verify_hash
   \        0xC   0xB005             ADD      SP,SP,#+20
   \        0xE   0xBD30             POP      {R4,R5,PC}
    977          }
    978          
    979          // -----------------------------------------------------------------------------
    980          // Transparent driver entry points
    981          

   \                                 In section .text, align 2, keep-with-next
    982          psa_status_t sli_se_transparent_sign_message(
    983            const psa_key_attributes_t *attributes,
    984            const uint8_t *key_buffer,
    985            size_t key_buffer_size,
    986            psa_algorithm_t alg,
    987            const uint8_t *input,
    988            size_t input_length,
    989            uint8_t *signature,
    990            size_t signature_size,
    991            size_t *signature_length)
    992          {
   \                     sli_se_transparent_sign_message: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2                      REQUIRE ?Subroutine1
   \        0x2                      ;; // Fall through to label ?Subroutine1
    993            return sli_se_sign_message(attributes,
    994                                       key_buffer,
    995                                       key_buffer_size,
    996                                       alg,
    997                                       input,
    998                                       input_length,
    999                                       signature,
   1000                                       signature_size,
   1001                                       signature_length);
   1002          }
   1003          

   \                                 In section .text, align 2, keep-with-next
   1004          psa_status_t sli_se_transparent_sign_hash(const psa_key_attributes_t *attributes,
   1005                                                    const uint8_t *key_buffer,
   1006                                                    size_t key_buffer_size,
   1007                                                    psa_algorithm_t alg,
   1008                                                    const uint8_t *hash,
   1009                                                    size_t hash_length,
   1010                                                    uint8_t *signature,
   1011                                                    size_t signature_size,
   1012                                                    size_t *signature_length)
   1013          {
   \                     sli_se_transparent_sign_hash: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2                      REQUIRE ?Subroutine2
   \        0x2                      ;; // Fall through to label ?Subroutine2
   1014            return sli_se_sign_hash(attributes,
   1015                                    key_buffer,
   1016                                    key_buffer_size,
   1017                                    alg,
   1018                                    hash,
   1019                                    hash_length,
   1020                                    signature,
   1021                                    signature_size,
   1022                                    signature_length);
   1023          }
   1024          

   \                                 In section .text, align 2, keep-with-next
   1025          psa_status_t sli_se_transparent_verify_message(
   1026            const psa_key_attributes_t *attributes,
   1027            const uint8_t *key_buffer,
   1028            size_t key_buffer_size,
   1029            psa_algorithm_t alg,
   1030            const uint8_t *input,
   1031            size_t input_length,
   1032            const uint8_t *signature,
   1033            size_t signature_length)
   1034          {
   \                     sli_se_transparent_verify_message: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2                      REQUIRE ?Subroutine3
   \        0x2                      ;; // Fall through to label ?Subroutine3
   1035            return sli_se_verify_message(attributes,
   1036                                         key_buffer,
   1037                                         key_buffer_size,
   1038                                         alg,
   1039                                         input,
   1040                                         input_length,
   1041                                         signature,
   1042                                         signature_length);
   1043          }
   1044          

   \                                 In section .text, align 2, keep-with-next
   1045          psa_status_t sli_se_transparent_verify_hash(
   1046            const psa_key_attributes_t *attributes,
   1047            const uint8_t *key_buffer,
   1048            size_t key_buffer_size,
   1049            psa_algorithm_t alg,
   1050            const uint8_t *hash,
   1051            size_t hash_length,
   1052            const uint8_t *signature,
   1053            size_t signature_length)
   1054          {
   \                     sli_se_transparent_verify_hash: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2                      REQUIRE ?Subroutine4
   \        0x2                      ;; // Fall through to label ?Subroutine4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x0600'0300        DC32     0x6000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x0600'1300        DC32     0x6001300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x0600'0200        DC32     0x6000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x0600'0900        DC32     0x6000900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x0600'0400        DC32     0x6000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0xFCFF'BFFF        DC32     0xfcffbfff
   1055            return sli_se_verify_hash(attributes,
   1056                                      key_buffer,
   1057                                      key_buffer_size,
   1058                                      alg,
   1059                                      hash,
   1060                                      hash_length,
   1061                                      signature,
   1062                                      signature_length);
   1063          }
   1064          
   1065          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   check_curve_availability
        16   -> psa_get_key_bits
       0   get_hash_for_algorithm
       0   psa_get_key_bits
       0   sli_se_key_descriptor_set_plaintext
      12   sli_se_opaque_sign_hash
        32   -> sli_se_sign_hash
      12   sli_se_opaque_sign_message
        32   -> sli_se_sign_message
      16   sli_se_opaque_verify_hash
        32   -> sli_se_verify_hash
      16   sli_se_opaque_verify_message
        32   -> sli_se_verify_message
     120   sli_se_sign_hash
       120   -> __aeabi_memclr4
       120   -> check_curve_availability
       120   -> psa_get_key_bits
       120   -> sl_se_deinit_command_context
       120   -> sl_se_ecc_sign
       120   -> sl_se_init_command_context
       120   -> sli_se_key_desc_from_input
     120   sli_se_sign_message
       120   -> __aeabi_memclr4
       120   -> check_curve_availability
       120   -> get_hash_for_algorithm
       120   -> psa_get_key_bits
       120   -> sl_se_deinit_command_context
       120   -> sl_se_ecc_sign
       120   -> sl_se_init_command_context
       120   -> sli_se_key_desc_from_input
       0   sli_se_transparent_sign_hash
        32   -> sli_se_sign_hash
       0   sli_se_transparent_sign_message
        32   -> sli_se_sign_message
       0   sli_se_transparent_verify_hash
        32   -> sli_se_verify_hash
       0   sli_se_transparent_verify_message
        32   -> sli_se_verify_message
     272   sli_se_verify_hash
       272   -> __aeabi_memclr4
       272   -> __aeabi_memcpy4
       272   -> __aeabi_memset
       272   -> check_curve_availability
       272   -> psa_get_key_bits
       272   -> sl_se_deinit_command_context
       272   -> sl_se_ecc_verify
       272   -> sl_se_export_public_key
       272   -> sl_se_init_command_context
       272   -> sli_se_key_desc_from_input
       272   -> sli_se_key_descriptor_set_plaintext
     280   sli_se_verify_message
       280   -> __aeabi_memclr4
       280   -> __aeabi_memcpy4
       280   -> __aeabi_memset
       280   -> check_curve_availability
       280   -> get_hash_for_algorithm
       280   -> psa_get_key_bits
       280   -> sl_se_deinit_command_context
       280   -> sl_se_ecc_verify
       280   -> sl_se_export_public_key
       280   -> sl_se_init_command_context
       280   -> sli_se_key_desc_from_input
       280   -> sli_se_key_descriptor_set_plaintext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       6  ?Subroutine0
      14  ?Subroutine1
      22  ?Subroutine10
      12  ?Subroutine11
       6  ?Subroutine12
      14  ?Subroutine2
      16  ?Subroutine3
      16  ?Subroutine4
      14  ?Subroutine5
       4  ?Subroutine6
       8  ?Subroutine7
       8  ?Subroutine8
      14  ?Subroutine9
      36  ?_0
      36  ?_1
      36  ?_2
      36  ?_3
      32  ?_4
      32  ?_5
      32  ?_6
      32  ?_7
     104  check_curve_availability
     116  get_hash_for_algorithm
       4  psa_get_key_bits
      16  sli_se_key_descriptor_set_plaintext
       4  sli_se_opaque_sign_hash
       4  sli_se_opaque_sign_message
       4  sli_se_opaque_verify_hash
       4  sli_se_opaque_verify_message
     226  sli_se_sign_hash
     250  sli_se_sign_message
       2  sli_se_transparent_sign_hash
       2  sli_se_transparent_sign_message
       2  sli_se_transparent_verify_hash
       2  sli_se_transparent_verify_message
     286  sli_se_verify_hash
     310  sli_se_verify_message

 
   272 bytes in section .rodata
 1'522 bytes in section .text
 
 1'522 bytes of CODE  memory
   272 bytes of CONST memory

Errors: none
Warnings: none
