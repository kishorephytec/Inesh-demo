###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:07
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_derivation.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_key_derivation.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_derivation.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_key_derivation.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_4811620319817103232.dir\sli_se_driver_key_derivation.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_4811620319817103232.dir\sli_se_driver_key_derivation.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\src\sli_se_driver_key_derivation.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs PSA Crypto Driver Key Derivation functions.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sli_psa_driver_features.h"
     32          
     33          #if defined(SLI_MBEDTLS_DEVICE_HSE)
     34          
     35          #include "sli_psa_driver_common.h"  // sli_psa_zeroize()
     36          #include "sli_se_opaque_functions.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void sli_se_key_descriptor_set_plaintext(struct <unnamed>#128 *, uint8_t const *, size_t)
   \                     sli_se_key_descriptor_set_plaintext: (+1)
   \        0x0   0x1CD2             ADDS     R2,R2,#+3
   \        0x2   0x0892             LSRS     R2,R2,#+2
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x0092             LSLS     R2,R2,#+2
   \        0x8   0x60C3             STR      R3,[R0, #+12]
   \        0xA   0x6101             STR      R1,[R0, #+16]
   \        0xC   0x6142             STR      R2,[R0, #+20]
   \        0xE   0x4770             BX       LR
     37          #include "sli_se_driver_key_management.h"
     38          #include "sli_se_driver_key_derivation.h"
     39          #include "sli_se_version_dependencies.h"
     40          #include "psa/crypto.h"
     41          
     42          #include "sl_se_manager.h"
     43          #include "sl_se_manager_key_derivation.h"
     44          #include "sl_se_manager_util.h"
     45          #include "sli_se_manager_internal.h"
     46          
     47          #include <string.h>
     48          
     49          // -----------------------------------------------------------------------------
     50          // Custom SL PSA driver entry points
     51          
     52          #if defined(SLI_PSA_DRIVER_FEATURE_HKDF)
     53          
     54          psa_status_t sli_se_driver_single_shot_hkdf(
     55            psa_algorithm_t alg,
     56            const psa_key_attributes_t *key_in_attributes,
     57            const uint8_t *key_in_buffer,
     58            size_t key_in_buffer_size,
     59            const uint8_t* info,
     60            size_t info_length,
     61            const uint8_t* salt,
     62            size_t salt_length,
     63            const psa_key_attributes_t *key_out_attributes,
     64            uint8_t *key_out_buffer,
     65            size_t key_out_buffer_size)
     66          {
     67            // This driver function will not be called unless alg is of HKDF type.
     68            sl_se_hash_type_t sl_hash_alg = SL_SE_HASH_NONE;
     69            psa_algorithm_t psa_hash_alg = PSA_ALG_HKDF_GET_HASH(alg);
     70            switch (psa_hash_alg) {
     71              case PSA_ALG_SHA_1:
     72                sl_hash_alg = SL_SE_HASH_SHA1;
     73                break;
     74              case PSA_ALG_SHA_224:
     75                sl_hash_alg = SL_SE_HASH_SHA224;
     76                break;
     77              case PSA_ALG_SHA_256:
     78                sl_hash_alg = SL_SE_HASH_SHA256;
     79                break;
     80              case PSA_ALG_SHA_384:
     81                sl_hash_alg = SL_SE_HASH_SHA384;
     82                break;
     83              case PSA_ALG_SHA_512:
     84                sl_hash_alg = SL_SE_HASH_SHA512;
     85                break;
     86              default:
     87                return PSA_ERROR_NOT_SUPPORTED;
     88            }
     89          
     90            // Create input key descriptor.
     91            sl_se_key_descriptor_t key_in_desc = { 0 };
     92            psa_status_t psa_status = sli_se_key_desc_from_input(key_in_attributes,
     93                                                                 key_in_buffer,
     94                                                                 key_in_buffer_size,
     95                                                                 &key_in_desc);
     96            if (psa_status != PSA_SUCCESS) {
     97              return psa_status;
     98            }
     99          
    100            size_t key_out_size = PSA_BITS_TO_BYTES(psa_get_key_bits(key_out_attributes));
    101          
    102            // Check that we don't request more than 255 times the hash digest size.
    103            // This limitation comes from RFC-5869.
    104            if (key_out_size > 255 * PSA_HASH_LENGTH(psa_hash_alg)) {
    105              return PSA_ERROR_INVALID_ARGUMENT;
    106            }
    107          
    108            // Create output key descriptor.
    109            sl_se_key_descriptor_t key_out_desc = { 0 };
    110            psa_status = sli_se_key_desc_from_psa_attributes(
    111              key_out_attributes,
    112              key_out_size,
    113              &key_out_desc);
    114            if (psa_status != PSA_SUCCESS) {
    115              return psa_status;
    116            }
    117          
    118            psa_status = sli_se_set_key_desc_output(key_out_attributes,
    119                                                    key_out_buffer,
    120                                                    key_out_buffer_size,
    121                                                    key_out_size,
    122                                                    &key_out_desc);
    123            if (psa_status != PSA_SUCCESS) {
    124              return psa_status;
    125            }
    126          
    127            // Prepare SE command context.
    128            sl_se_command_context_t cmd_ctx = { 0 };
    129            sl_status_t sl_status = sl_se_init_command_context(&cmd_ctx);
    130            if (sl_status != SL_STATUS_OK) {
    131              return PSA_ERROR_INVALID_ARGUMENT;
    132            }
    133          
    134            // Execute the SE command.
    135            sl_status = sl_se_derive_key_hkdf(&cmd_ctx,
    136                                              &key_in_desc,
    137                                              sl_hash_alg,
    138                                              salt,
    139                                              salt_length,
    140                                              info,
    141                                              info_length,
    142                                              &key_out_desc);
    143            if (sl_status != SL_STATUS_OK) {
    144              return PSA_ERROR_HARDWARE_FAILURE;
    145            } else {
    146              psa_status = PSA_SUCCESS;
    147            }
    148          
    149            if (PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(key_out_attributes))
    150                == PSA_KEY_LOCATION_SLI_SE_OPAQUE) {
    151              // Add the key desc to the output array for opaque keys.
    152              psa_status = store_key_desc_in_context(&key_out_desc,
    153                                                     key_out_buffer,
    154                                                     key_out_buffer_size);
    155            }
    156          
    157            return psa_status;
    158          }
    159          
    160          #endif // SLI_PSA_DRIVER_FEATURE_HKDF
    161          
    162          #if defined(SLI_PSA_DRIVER_FEATURE_PBKDF2)
    163          
    164          psa_status_t sli_se_driver_single_shot_pbkdf2(
    165            psa_algorithm_t alg,
    166            const psa_key_attributes_t *key_in_attributes,
    167            const uint8_t *key_in_buffer,
    168            size_t key_in_buffer_size,
    169            const uint8_t* salt,
    170            size_t salt_length,
    171            const psa_key_attributes_t *key_out_attributes,
    172            uint32_t iterations,
    173            uint8_t *key_out_buffer,
    174            size_t key_out_buffer_size)
    175          {
    176            sl_se_hash_type_t sl_prf = SL_SE_HASH_NONE;
    177            psa_algorithm_t psa_hash_alg = PSA_ALG_GET_HASH(alg);
    178          
    179            switch (psa_hash_alg) {
    180              case PSA_ALG_SHA_1:
    181                sl_prf = SL_SE_PRF_HMAC_SHA1;
    182                break;
    183              case PSA_ALG_SHA_224:
    184                sl_prf = SL_SE_PRF_HMAC_SHA224;
    185                break;
    186              case PSA_ALG_SHA_256:
    187                sl_prf = SL_SE_PRF_HMAC_SHA256;
    188                break;
    189              case PSA_ALG_SHA_384:
    190                sl_prf = SL_SE_PRF_HMAC_SHA384;
    191                break;
    192              case PSA_ALG_SHA_512:
    193                sl_prf = SL_SE_PRF_HMAC_SHA512;
    194                break;
    195              default:
    196                if (alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128) {
    197                  sl_prf = SL_SE_PRF_AES_CMAC_128;
    198                  break;
    199                }
    200                return PSA_ERROR_NOT_SUPPORTED;
    201            }
    202          
    203            // Create input key descriptor.
    204            sl_se_key_descriptor_t key_in_desc = { 0 };
    205            psa_status_t psa_status = sli_se_key_desc_from_input(key_in_attributes,
    206                                                                 key_in_buffer,
    207                                                                 key_in_buffer_size,
    208                                                                 &key_in_desc);
    209            if (psa_status != PSA_SUCCESS) {
    210              return psa_status;
    211            }
    212          
    213            size_t key_out_size = PSA_BITS_TO_BYTES(psa_get_key_bits(key_out_attributes));
    214          
    215            if ( alg == PSA_ALG_PBKDF2_AES_CMAC_PRF_128 ) {
    216              #define AES_CMAC_PRF_128_BLOCK_SIZE 128
    217              // The out key length can atmost be 128 bits long.
    218              if ( !key_out_size || (key_out_size > PSA_BITS_TO_BYTES(AES_CMAC_PRF_128_BLOCK_SIZE)) ) {
    219                return PSA_ERROR_INVALID_ARGUMENT;
    220              }
    221            } else { // HMAC based
    222              // In conformance with rfc 8018 (sec 5.2), max output length should not exceed
    223              // 2 ^ 32 -1 * hlen.
    224              // Our max key size is limited by type of key bits in attributes, so no further
    225              // validation is necessary.Our key out size is narrower than the rfc specification.
    226              if ( !key_out_size ) {
    227                return PSA_ERROR_INVALID_ARGUMENT;
    228              }
    229            }
    230          
    231            if ( !iterations ) {
    232              return PSA_ERROR_INVALID_ARGUMENT;
    233            }
    234          
    235            // Create output key descriptor.
    236            sl_se_key_descriptor_t key_out_desc = { 0 };
    237            psa_status = sli_se_key_desc_from_psa_attributes(
    238              key_out_attributes,
    239              key_out_size,
    240              &key_out_desc);
    241            if (psa_status != PSA_SUCCESS) {
    242              return psa_status;
    243            }
    244          
    245            psa_status = sli_se_set_key_desc_output(key_out_attributes,
    246                                                    key_out_buffer,
    247                                                    key_out_buffer_size,
    248                                                    key_out_size,
    249                                                    &key_out_desc);
    250            if (psa_status != PSA_SUCCESS) {
    251              return psa_status;
    252            }
    253          
    254            // Prepare SE command context.
    255            sl_se_command_context_t cmd_ctx = { 0 };
    256            sl_status_t sl_status = sl_se_init_command_context(&cmd_ctx);
    257            if (sl_status != SL_STATUS_OK) {
    258              return PSA_ERROR_INVALID_ARGUMENT;
    259            }
    260          
    261            // Execute the SE command.
    262            sl_status = sl_se_derive_key_pbkdf2(&cmd_ctx,
    263                                                &key_in_desc,
    264                                                sl_prf,
    265                                                salt,
    266                                                salt_length,
    267                                                iterations,
    268                                                &key_out_desc);
    269            if (sl_status != SL_STATUS_OK) {
    270              return PSA_ERROR_HARDWARE_FAILURE;
    271            } else {
    272              psa_status = PSA_SUCCESS;
    273            }
    274          
    275            if (PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(key_out_attributes))
    276                == PSA_KEY_LOCATION_SLI_SE_OPAQUE) {
    277              // Add the key desc to the output array for opaque keys.
    278              psa_status = store_key_desc_in_context(&key_out_desc,
    279                                                     key_out_buffer,
    280                                                     key_out_buffer_size);
    281            }
    282          
    283            return psa_status;
    284          }
    285          
    286          #endif // SLI_PSA_DRIVER_FEATURE_PBKDF2
    287          
    288          // -----------------------------------------------------------------------------
    289          // Driver entry points
    290          

   \                                 In section .text, align 2, keep-with-next
    291          psa_status_t sli_se_driver_key_agreement(psa_algorithm_t alg,
    292                                                   const psa_key_attributes_t *attributes,
    293                                                   const uint8_t *key_buffer,
    294                                                   size_t key_buffer_size,
    295                                                   const uint8_t *peer_key,
    296                                                   size_t peer_key_length,
    297                                                   uint8_t *output,
    298                                                   size_t output_size,
    299                                                   size_t *output_length)
    300          {
   \                     sli_se_driver_key_agreement: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB0C3             SUB      SP,SP,#+268
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x469B             MOV      R11,R3
    301            #if defined(SLI_PSA_DRIVER_FEATURE_ECDH)
    302          
    303            sl_se_key_descriptor_t priv_desc = { 0 };
   \        0xE   0xA81A             ADD      R0,SP,#+104
   \       0x10   0x2120             MOVS     R1,#+32
   \       0x12   0x.... 0x....      BL       __aeabi_memclr4
    304            sl_se_key_descriptor_t pub_desc = { 0 };
   \       0x16   0xA809             ADD      R0,SP,#+36
   \       0x18   0x2120             MOVS     R1,#+32
   \       0x1A   0x.... 0x....      BL       __aeabi_memclr4
    305            sl_se_key_descriptor_t shared_desc = { 0 };
   \       0x1E   0xA801             ADD      R0,SP,#+4
   \       0x20   0x2120             MOVS     R1,#+32
   \       0x22   0x.... 0x....      BL       __aeabi_memclr4
    306            sl_se_command_context_t cmd_ctx = SL_SE_COMMAND_CONTEXT_INIT;
   \       0x26   0xA811             ADD      R0,SP,#+68
   \       0x28   0x2124             MOVS     R1,#+36
   \       0x2A   0x.... 0x....      BL       __aeabi_memclr4
    307            sl_status_t sl_status = SL_STATUS_FAIL;
    308            psa_status_t psa_status = PSA_ERROR_CORRUPTION_DETECTED;
   \       0x2E   0x2184             MOVS     R1,#+132
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0xA822             ADD      R0,SP,#+136
   \       0x34   0x.... 0x....      BL       __aeabi_memset
    309          
    310            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    311            size_t padding_bytes = 0;
    312            uint8_t tmp_output_buf[SLI_SE_MAX_PADDED_ECP_PUBLIC_KEY_SIZE] = { 0 };
    313            #else
    314            uint8_t tmp_output_buf[SLI_SE_MAX_ECP_PUBLIC_KEY_SIZE] = { 0 };
    315            #endif // SLI_SE_KEY_PADDING_REQUIRED
    316          
    317            // Argument check.
    318            if (attributes == NULL
    319                || key_buffer == NULL
    320                || peer_key == NULL
    321                || output == NULL
    322                || output_length == NULL) {
   \       0x38   0xF06F 0x0A86      MVN      R10,#+134
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD05C             BEQ.N    ??sli_se_driver_key_agreement_0
   \       0x40   0x9500             STR      R5,[SP, #+0]
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0xBF1C             ITT      NE
   \       0x46   0x984C             LDRNE    R0,[SP, #+304]
   \       0x48   0x2800             CMPNE    R0,#+0
   \       0x4A   0xD056             BEQ.N    ??sli_se_driver_key_agreement_0
   \       0x4C   0x9E4E             LDR      R6,[SP, #+312]
   \       0x4E   0x2E00             CMP      R6,#+0
   \       0x50   0xBF1C             ITT      NE
   \       0x52   0x9D50             LDRNE    R5,[SP, #+320]
   \       0x54   0x2D00             CMPNE    R5,#+0
   \       0x56   0xBF1F             ITTTT    NE
   \       0x58   0x8827             LDRHNE   R7,[R4, #+0]
   \       0x5A   0x8862             LDRHNE   R2,[R4, #+2]
   \       0x5C   0xF407 0x41E0      ANDNE    R1,R7,#0x7000
   \       0x60   0xF5B1 0x4F80      CMPNE    R1,#+16384
    323              return PSA_ERROR_INVALID_ARGUMENT;
    324            }
    325          
    326            psa_key_type_t key_type = psa_get_key_type(attributes);
    327            size_t key_bits = psa_get_key_bits(attributes);
    328          
    329            // Check that key_buffer contains private key.
    330            if (PSA_KEY_TYPE_IS_PUBLIC_KEY(key_type)) {
   \       0x64   0xD049             BEQ.N    ??sli_se_driver_key_agreement_0
   \       0x66   0x4649             MOV      R1,R9
    331              return PSA_ERROR_INVALID_ARGUMENT;
    332            }
    333          
    334            // Only accelerate ECDH.
    335            if (!PSA_ALG_IS_ECDH(alg)) {
   \       0x68   0x0C09             LSRS     R1,R1,#+16
   \       0x6A   0x0409             LSLS     R1,R1,#+16
   \       0x6C   0xF041 0x6110      ORR      R1,R1,#0x9000000
   \       0x70   0x....             LDR.N    R3,??DataTable4
   \       0x72   0xF06F 0x0985      MVN      R9,#+133
   \       0x76   0x4299             CMP      R1,R3
   \       0x78   0xD13D             BNE.N    ??sli_se_driver_key_agreement_1
    336              return PSA_ERROR_NOT_SUPPORTED;
    337            }
    338          
    339            // Check private key buffer.
    340            if (key_buffer_size < PSA_BITS_TO_BYTES(key_bits)) {
   \       0x7A   0x1DD1             ADDS     R1,R2,#+7
   \       0x7C   0xEBBB 0x0FD1      CMP      R11,R1, LSR #+3
   \       0x80   0xD33B             BCC.N    ??sli_se_driver_key_agreement_0
   \       0x82   0x9B4F             LDR      R3,[SP, #+316]
    341              return PSA_ERROR_INVALID_ARGUMENT;
    342            }
    343          
    344            // Check sufficient output buffer size.
    345            if (output_size < PSA_BITS_TO_BYTES(key_bits)) {
   \       0x84   0xEBB3 0x0FD1      CMP      R3,R1, LSR #+3
   \       0x88   0xBF38             IT       CC
   \       0x8A   0xF06F 0x0089      MVNCC    R0,#+137
    346              return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x8E   0xD34A             BCC.N    ??sli_se_driver_key_agreement_2
    347            }
    348          
    349            #if defined(SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN)
    350            sl_status = sl_se_init_command_context(&cmd_ctx);
    351            if (sl_status != SL_STATUS_OK) {
    352              return PSA_ERROR_HARDWARE_FAILURE;
    353            }
    354            uint32_t se_version = 0;
    355            sl_status = sl_se_get_se_version(&cmd_ctx, &se_version);
    356            if (sl_status != SL_STATUS_OK) {
    357              return PSA_ERROR_HARDWARE_FAILURE;
    358            }
    359            se_version = SLI_VERSION_REMOVE_DIE_ID(se_version);
    360          
    361            // External public key validation is required for older versions of SE FW.
    362            if (SLI_SE_VERSION_PUBKEY_VALIDATION_REQUIRED(se_version)) {
    363              #if defined(MBEDTLS_ECP_C)       \
    364              && defined(MBEDTLS_PSA_CRYPTO_C) \
    365              && SL_SE_SUPPORT_FW_PRIOR_TO_1_2_2
    366              psa_status = sli_se_driver_validate_pubkey_with_fallback(key_type,
    367                                                                       key_bits,
    368                                                                       peer_key,
    369                                                                       peer_key_length);
    370              if (psa_status != PSA_SUCCESS) {
    371                return psa_status;
    372              }
    373              #else
    374              // No fallback code is compiled in, cannot do public key validation.
    375              return PSA_ERROR_NOT_SUPPORTED;
    376              #endif
    377            }
    378            #endif   // SLI_SE_VERSION_ECDH_PUBKEY_VALIDATION_UNCERTAIN
    379          
    380            switch (key_type) {
   \       0x90   0xF247 0x1812      MOVW     R8,#+28946
   \       0x94   0x4547             CMP      R7,R8
   \       0x96   0xBF08             IT       EQ
   \       0x98   0xF5B2 0x7F80      CMPEQ    R2,#+256
    381              #if defined(SLI_PSA_DRIVER_FEATURE_SECPR1)
    382              case PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1):
    383                switch (key_bits) {
   \       0x9C   0xD12B             BNE.N    ??sli_se_driver_key_agreement_1
   \       0x9E   0x9A4D             LDR      R2,[SP, #+308]
    384                  #if defined(SLI_PSA_DRIVER_FEATURE_P192R1)
    385                  case 192:
    386                    pub_desc.type = SL_SE_KEY_TYPE_ECC_P192;
    387                    break;
    388                  #endif     // SLI_PSA_DRIVER_FEATURE_P192R1
    389          
    390                  #if defined(SLI_PSA_DRIVER_FEATURE_P224R1)
    391                  case 224:
    392                    pub_desc.type = SL_SE_KEY_TYPE_ECC_P224;
    393                    break;
    394                  #endif     // SLI_PSA_DRIVER_FEATURE_P224R1
    395          
    396                  #if defined(SLI_PSA_DRIVER_FEATURE_P256R1)
    397                  case 256:
    398                    pub_desc.type = SL_SE_KEY_TYPE_ECC_P256;
   \       0xA0   0x....             LDR.N    R1,??DataTable4_1
   \       0xA2   0x9109             STR      R1,[SP, #+36]
    399                    break;
    400                  #endif     // SLI_PSA_DRIVER_FEATURE_P256R1
    401          
    402                  #if defined(SLI_PSA_DRIVER_FEATURE_P384R1)
    403                  case 384:
    404                    pub_desc.type = SL_SE_KEY_TYPE_ECC_P384;
    405                    break;
    406                  #endif     // SLI_PSA_DRIVER_FEATURE_P384R1
    407          
    408                  #if defined(SLI_PSA_DRIVER_FEATURE_P521R1)
    409                  case 521:
    410                    pub_desc.type = SL_SE_KEY_TYPE_ECC_P521;
    411                    #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    412                    padding_bytes = SLI_SE_P521_PADDING_BYTES;
    413                    #endif
    414                    break;
    415                  #endif     // SLI_PSA_DRIVER_FEATURE_P521R1
    416          
    417                  default:
    418                    return PSA_ERROR_NOT_SUPPORTED;
    419                }
    420          
    421                // Set key descriptor attributes.
    422                // If padding is required, the descriptor will be set later as part of
    423                // the padding. If padding is not required, set the descriptor here.
    424                if (pub_desc.type != 0
    425                    #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    426                    && padding_bytes == 0
    427                    #endif
    428                    ) {
    429                  sli_se_key_descriptor_set_plaintext(&pub_desc,
    430                                                      peer_key + 1,
    431                                                      peer_key_length - 1);
   \       0xA4   0x1C41             ADDS     R1,R0,#+1
   \       0xA6   0x1E52             SUBS     R2,R2,#+1
   \       0xA8   0xA809             ADD      R0,SP,#+36
   \       0xAA   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    432                  sli_se_key_descriptor_set_plaintext(&shared_desc,
    433                                                      tmp_output_buf,
    434                                                      sizeof(tmp_output_buf));
   \       0xAE   0x2284             MOVS     R2,#+132
   \       0xB0   0xA922             ADD      R1,SP,#+136
   \       0xB2   0xA801             ADD      R0,SP,#+4
   \       0xB4   0x.... 0x....      BL       sli_se_key_descriptor_set_plaintext
    435                  shared_desc.size = PSA_BITS_TO_BYTES(key_bits) * 2;
   \       0xB8   0x2040             MOVS     R0,#+64
    436                }
    437                break;
    438              #endif   // SLI_PSA_DRIVER_FEATURE_SECPR1
    439          
    440              #if defined(SLI_PSA_DRIVER_FEATURE_MONTGOMERY)
    441              case PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_MONTGOMERY):
    442          
    443                // Check peer_key is of sufficient size.
    444                if (peer_key_length < PSA_BITS_TO_BYTES(key_bits)) {
    445                  return PSA_ERROR_INVALID_ARGUMENT;
    446                }
    447          
    448                switch (key_bits) {
    449                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE25519)
    450                  case 255:
    451                    pub_desc.type = SL_SE_KEY_TYPE_ECC_X25519;
    452                    break;
    453                  #endif     // SLI_PSA_DRIVER_FEATURE_CURVE25519
    454          
    455                  #if defined(SLI_PSA_DRIVER_FEATURE_CURVE448)
    456                  case 448:
    457                    pub_desc.type = SL_SE_KEY_TYPE_ECC_X448;
    458                    break;
    459                  #endif     // SLI_PSA_DRIVER_FEATURE_CURVE448
    460          
    461                  default:
    462                    return PSA_ERROR_NOT_SUPPORTED;
    463                }
    464          
    465                // Set key descriptor attributes.
    466                sli_se_key_descriptor_set_plaintext(&pub_desc,
    467                                                    peer_key,
    468                                                    peer_key_length);
    469                sli_se_key_descriptor_set_plaintext(&shared_desc,
    470                                                    output,
    471                                                    output_size);
    472                shared_desc.size = PSA_BITS_TO_BYTES(key_bits);
    473                break;
    474              #endif   // SLI_PSA_DRIVER_FEATURE_MONTGOMERY
    475          
    476              default:
    477                return PSA_ERROR_NOT_SUPPORTED;
    478            }
    479          
    480            // Generate a key descriptor for private key.
    481            psa_status = sli_se_key_desc_from_input(attributes,
    482                                                    key_buffer,
    483                                                    key_buffer_size,
    484                                                    &priv_desc);
   \       0xBA   0x9900             LDR      R1,[SP, #+0]
   \       0xBC   0x9002             STR      R0,[SP, #+8]
   \       0xBE   0xAB1A             ADD      R3,SP,#+104
   \       0xC0   0x465A             MOV      R2,R11
   \       0xC2   0x4620             MOV      R0,R4
   \       0xC4   0x.... 0x....      BL       sli_se_key_desc_from_input
    485            if (psa_status != PSA_SUCCESS) {
   \       0xC8   0xBB68             CBNZ.N   R0,??sli_se_driver_key_agreement_2
    486              return psa_status;
    487            }
    488          
    489            // Panther crypto engine requires alignment on word boundries instead of byte
    490            // boundaries which is used in the PSA crypto API.
    491            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    492            uint8_t tmp_priv_padded_buf[SLI_SE_MAX_PADDED_ECP_PRIVATE_KEY_SIZE] = { 0 };
    493            uint8_t tmp_pub_padded_buf[SLI_SE_MAX_PADDED_ECP_PUBLIC_KEY_SIZE] = { 0 };
    494          
    495            // Should currently only happen for curve P521.
    496            if (padding_bytes > 0) {
    497              // Can only do padding on non-wrapped keys.
    498              if (PSA_KEY_LIFETIME_GET_LOCATION(psa_get_key_lifetime(attributes))
    499                  == PSA_KEY_LOCATION_LOCAL_STORAGE) {
    500                // Pad private key.
    501                sli_se_pad_big_endian(tmp_priv_padded_buf, key_buffer,
    502                                      PSA_BITS_TO_BYTES(key_bits));
    503          
    504                // Re-set key descriptor attributes.
    505                sli_se_key_descriptor_set_plaintext(&priv_desc,
    506                                                    tmp_priv_padded_buf,
    507                                                    sizeof(tmp_priv_padded_buf));
    508              }
    509          
    510              // Pad public key.
    511              sli_se_pad_curve_point(tmp_pub_padded_buf, peer_key + 1,
    512                                     PSA_BITS_TO_BYTES(key_bits));
    513          
    514              // Set key descriptor attributes.
    515              sli_se_key_descriptor_set_plaintext(&pub_desc,
    516                                                  tmp_pub_padded_buf,
    517                                                  sizeof(tmp_pub_padded_buf));
    518              sli_se_key_descriptor_set_plaintext(&shared_desc,
    519                                                  tmp_output_buf,
    520                                                  sizeof(tmp_output_buf));
    521              shared_desc.size = (PSA_BITS_TO_BYTES(key_bits) + padding_bytes) * 2;
    522            }
    523            #endif   // SLI_SE_KEY_PADDING_REQUIRED
    524          
    525            // Set key descriptor attributes that are common to all supported curves.
    526            pub_desc.flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \       0xCA   0x990B             LDR      R1,[SP, #+44]
    527            shared_desc.type = SL_SE_KEY_TYPE_SYMMETRIC;
    528          
    529            // Re-init SE command context.
    530            sl_status = sl_se_init_command_context(&cmd_ctx);
    531            if (sl_status != SL_STATUS_OK) {
   \       0xCC   0xA811             ADD      R0,SP,#+68
   \       0xCE   0xF441 0x5100      ORR      R1,R1,#0x2000
   \       0xD2   0x910B             STR      R1,[SP, #+44]
   \       0xD4   0x2100             MOVS     R1,#+0
   \       0xD6   0x9101             STR      R1,[SP, #+4]
   \       0xD8   0x.... 0x....      BL       sl_se_init_command_context
   \       0xDC   0xB110             CBZ.N    R0,??sli_se_driver_key_agreement_3
    532              return PSA_ERROR_HARDWARE_FAILURE;
   \       0xDE   0xF06F 0x0092      MVN      R0,#+146
   \       0xE2   0xE020             B.N      ??sli_se_driver_key_agreement_2
    533            }
    534          
    535            // Perform key agreement algorithm (ECDH).
    536            sl_status = sl_se_ecdh_compute_shared_secret(&cmd_ctx,
    537                                                         &priv_desc,
    538                                                         &pub_desc,
    539                                                         &shared_desc);
   \                     ??sli_se_driver_key_agreement_3: (+1)
   \       0xE4   0xAB01             ADD      R3,SP,#+4
   \       0xE6   0xAA09             ADD      R2,SP,#+36
   \       0xE8   0xA91A             ADD      R1,SP,#+104
   \       0xEA   0xA811             ADD      R0,SP,#+68
   \       0xEC   0x.... 0x....      BL       sl_se_ecdh_compute_shared_secret
    540            if (sl_status != SL_STATUS_OK) {
   \       0xF0   0xB128             CBZ.N    R0,??sli_se_driver_key_agreement_4
    541              if (sl_status == SL_STATUS_COMMAND_IS_INVALID) {
   \       0xF2   0x2848             CMP      R0,#+72
   \       0xF4   0xD101             BNE.N    ??sli_se_driver_key_agreement_0
    542                // This error will be returned if the key type isn't supported.
    543                return PSA_ERROR_NOT_SUPPORTED;
   \                     ??sli_se_driver_key_agreement_1: (+1)
   \       0xF6   0x4648             MOV      R0,R9
   \       0xF8   0xE015             B.N      ??sli_se_driver_key_agreement_2
    544              } else {
    545                // If the ECDH operation failed, this is most likely due to the peer key
    546                // being an invalid elliptic curve point. Other sources for failure should
    547                // hopefully have been caught during parameter validation.
    548                return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??sli_se_driver_key_agreement_0: (+1)
   \       0xFA   0x4650             MOV      R0,R10
   \       0xFC   0xE013             B.N      ??sli_se_driver_key_agreement_2
    549              }
    550            }
    551          
    552            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    553            // Remove padding bytes and clean up temporary key storage.
    554            if (padding_bytes > 0) {
    555              sli_se_unpad_curve_point(tmp_output_buf,
    556                                       tmp_output_buf,
    557                                       PSA_BITS_TO_BYTES(key_bits));
    558              sli_psa_zeroize(tmp_priv_padded_buf, sizeof(tmp_priv_padded_buf));
    559            }
    560            #endif // SLI_SE_KEY_PADDING_REQUIRED
    561          
    562            // Montgomery curve computations do not require the temporary buffer to store the y-coord.
    563            if (key_type == PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1)) {
   \                     ??sli_se_driver_key_agreement_4: (+1)
   \       0xFE   0x4547             CMP      R7,R8
   \      0x100   0xD10E             BNE.N    ??sli_se_driver_key_agreement_5
    564              memcpy(output, tmp_output_buf, PSA_BITS_TO_BYTES(key_bits));
   \      0x102   0x2220             MOVS     R2,#+32
   \      0x104   0xA922             ADD      R1,SP,#+136
   \      0x106   0x4630             MOV      R0,R6
   \      0x108   0x.... 0x....      BL       __aeabi_memcpy
    565              sli_psa_zeroize(tmp_output_buf, sizeof(tmp_output_buf));
   \      0x10C   0x2184             MOVS     R1,#+132
   \      0x10E   0xAA22             ADD      R2,SP,#+136
   \      0x110   0xE002             B.N      ??sli_se_driver_key_agreement_6
   \                     ??sli_se_driver_key_agreement_7: (+1)
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0xF802 0x0B01      STRB     R0,[R2], #+1
   \                     ??sli_se_driver_key_agreement_6: (+1)
   \      0x118   0x4608             MOV      R0,R1
   \      0x11A   0x1E41             SUBS     R1,R0,#+1
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD1F8             BNE.N    ??sli_se_driver_key_agreement_7
    566            }
    567          
    568            *output_length = PSA_BITS_TO_BYTES(key_bits);
   \                     ??sli_se_driver_key_agreement_5: (+1)
   \      0x120   0x2020             MOVS     R0,#+32
   \      0x122   0x6028             STR      R0,[R5, #+0]
    569          
    570            return PSA_SUCCESS;
   \      0x124   0x2000             MOVS     R0,#+0
   \                     ??sli_se_driver_key_agreement_2: (+1)
   \      0x126   0xB043             ADD      SP,SP,#+268
   \      0x128   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    571          
    572            #else // SLI_PSA_DRIVER_FEATURE_ECDH
    573          
    574            (void) attributes;
    575            (void) key_buffer;
    576            (void) peer_key;
    577            (void) output;
    578            (void) output_length;
    579            (void) alg;
    580            (void) key_buffer_size;
    581            (void) peer_key_length;
    582            (void) output_size;
    583          
    584            return PSA_ERROR_NOT_SUPPORTED;
    585          
    586            #endif // SLI_PSA_DRIVER_FEATURE_ECDH
    587          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0
   \        0x4                      DS8 28

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x00               DC8 0
   \       0x21                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0902'0000        DC32     0x9020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x8000'0020        DC32     0x80000020
    588          
    589          #endif // SLI_MBEDTLS_DEVICE_HSE

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     304   sli_se_driver_key_agreement
       304   -> __aeabi_memclr4
       304   -> __aeabi_memcpy
       304   -> __aeabi_memset
       304   -> sl_se_ecdh_compute_shared_secret
       304   -> sl_se_init_command_context
       304   -> sli_se_key_desc_from_input
       304   -> sli_se_key_descriptor_set_plaintext
       0   sli_se_key_descriptor_set_plaintext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
      36  ?_0
      32  ?_1
      32  ?_2
      32  ?_3
     300  sli_se_driver_key_agreement
      16  sli_se_key_descriptor_set_plaintext

 
 132 bytes in section .rodata
 324 bytes in section .text
 
 324 bytes of CODE  memory
 132 bytes of CONST memory

Errors: none
Warnings: none
