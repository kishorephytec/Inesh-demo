###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:55
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_ldma.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_ldma.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_ldma.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_ldma.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir\em_ldma.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_ldma.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_ldma.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Direct memory access (LDMA) module peripheral API
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "em_ldma.h"
     32          
     33          #if defined(LDMA_PRESENT) && (LDMA_COUNT == 1)
     34          
     35          #include <stddef.h>
     36          #include "sl_assert.h"
     37          #include "em_bus.h"
     38          #include "em_cmu.h"
     39          #include "em_core.h"
     40          
     41          /***************************************************************************//**
     42           * @addtogroup ldma
     43           * @{
     44           ******************************************************************************/
     45          
     46          #if defined(LDMA_IRQ_HANDLER_TEMPLATE)
     47          /***************************************************************************//**
     48           * @brief
     49           *   A template for an LDMA IRQ handler.
     50           ******************************************************************************/
     51          void LDMA_IRQHandler(void)
     52          {
     53            uint32_t ch;
     54            /* Get all pending and enabled interrupts. */
     55            uint32_t pending = LDMA_IntGetEnabled();
     56          
     57            /* Loop on an LDMA error to enable debugging. */
     58            while (pending & LDMA_IF_ERROR) {
     59            }
     60          
     61            /* Iterate over all LDMA channels. */
     62            for (ch = 0; ch < DMA_CHAN_COUNT; ch++) {
     63              uint32_t mask = 0x1 << ch;
     64              if (pending & mask) {
     65                /* Clear the interrupt flag. */
     66                LDMA->IFC = mask;
     67          
     68                /* Perform more actions here, execute callbacks, and so on. */
     69              }
     70            }
     71          }
     72          #endif
     73          
     74          /***************************************************************************//**
     75           * @brief
     76           *   De-initialize the LDMA controller.
     77           *
     78           *   LDMA interrupts are disabled and the LDMA clock is stopped.
     79           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     80          void LDMA_DeInit(void)
     81          {
   \                     LDMA_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     82            NVIC_DisableIRQ(LDMA_IRQn);
   \        0x2   0xF44F 0x0180      MOV      R1,#+4194304
   \        0x6   0x....             LDR.N    R0,??DataTable7
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
     83            LDMA->IEN  = 0;
   \       0x12   0x....             LDR.N    R0,??DataTable7_1
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6501             STR      R1,[R0, #+80]
     84          #if defined(_LDMA_CHDIS_MASK)
     85            LDMA->CHDIS = _LDMA_CHEN_MASK;
   \       0x18   0x23FF             MOVS     R3,#+255
   \       0x1A   0x6243             STR      R3,[R0, #+36]
     86          #else
     87            LDMA->CHEN = 0;
     88          #endif
     89          #if defined(LDMA_EN_EN)
     90            LDMA->EN = 0;
   \       0x1C   0x2200             MOVS     R2,#+0
   \       0x1E   0x6002             STR      R2,[R0, #+0]
     91          #if defined(LDMA_EN_DISABLING)
     92            while (LDMA->EN & _LDMA_EN_DISABLING_MASK) {
     93            }
     94          #endif
     95          #endif
     96          
     97            CMU_ClockEnable(cmuClock_LDMA, false);
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0x.... 0x....      BL       CMU_ClockEnable
     98          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG) && (_SILICON_LABS_32B_SERIES_2_CONFIG > 1)
     99            CMU_ClockEnable(cmuClock_LDMAXBAR, false);
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x2021             MOVS     R0,#+33
   \       0x2A   0xE8BD 0x4004      POP      {R2,LR}
   \       0x2E   0x.... 0x....      B.W      CMU_ClockEnable
    100          #endif
    101          }
    102          
    103          /***************************************************************************//**
    104           * @brief
    105           *   Enable or disable an LDMA channel request.
    106           *
    107           * @details
    108           *   Use this function to enable or disable an LDMA channel request. This will
    109           *   prevent the LDMA from proceeding after its current transaction if disabled.
    110           *
    111           * @param[in] ch
    112           *   LDMA channel to enable or disable requests.
    113           *
    114           * @param[in] enable
    115           *   If 'true', the request will be enabled. If 'false', the request will be disabled.
    116           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    117          void LDMA_EnableChannelRequest(int ch, bool enable)
    118          {
   \                     LDMA_EnableChannelRequest: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460F             MOV      R7,R1
    119            EFM_ASSERT(ch < (int)DMA_CHAN_COUNT);
   \        0x6   0x....             LDR.N    R6,??DataTable7_2
   \        0x8   0x2D08             CMP      R5,#+8
   \        0xA   0xDB02             BLT.N    ??CrossCallReturnLabel_6
   \        0xC   0x2177             MOVS     R1,#+119
   \        0xE   0x.... 0x....      BL       ?Subroutine0
    120          
    121            BUS_RegBitWrite(&LDMA->REQDIS, ch, !enable);
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x12   0x1E7C             SUBS     R4,R7,#+1
   \       0x14   0x41A4             SBCS     R4,R4,R4
   \       0x16   0x0FE4             LSRS     R4,R4,#+31
   \       0x18   0x2D20             CMP      R5,#+32
   \       0x1A   0xD303             BCC.N    ??LDMA_EnableChannelRequest_0
   \       0x1C   0x2191             MOVS     R1,#+145
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       assertEFM
   \                     ??LDMA_EnableChannelRequest_0: (+1)
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xBF14             ITE      NE
   \       0x28   0x....             LDRNE.N  R1,??DataTable7_3
   \       0x2A   0x....             LDREQ.N  R1,??DataTable7_4
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xFA00 0xF505      LSL      R5,R0,R5
   \       0x32   0x600D             STR      R5,[R1, #+0]
    122          }
   \       0x34   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF106 0x0064      ADD      R0,R6,#+100
   \        0x4   0x.... 0x....      B.W      assertEFM
    123          
    124          /***************************************************************************//**
    125           * @brief
    126           *   Initialize the LDMA controller.
    127           *
    128           * @details
    129           *   This function will disable all the LDMA channels and enable the LDMA bus
    130           *   clock in the CMU. This function will also enable the LDMA IRQ in the NVIC
    131           *   and set the LDMA IRQ priority to a user-configurable priority. The LDMA
    132           *   interrupt priority is configured using the @ref LDMA_Init_t structure.
    133           *
    134           * @note
    135           *   Since this function enables the LDMA IRQ, always add a custom
    136           *   LDMA_IRQHandler to the application to handle any interrupts
    137           *   from LDMA.
    138           *
    139           * @param[in] init
    140           *   A pointer to the initialization structure used to configure the LDMA.
    141           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    142          void LDMA_Init(const LDMA_Init_t *init)
    143          {
   \                     LDMA_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    144            uint32_t ldmaCtrlVal;
    145            EFM_ASSERT(init != NULL);
   \        0x4   0x....             LDR.N    R5,??DataTable7_2
   \        0x6   0xD102             BNE.N    ??CrossCallReturnLabel_9
   \        0x8   0x2191             MOVS     R1,#+145
   \        0xA   0x.... 0x....      BL       ?Subroutine1
    146            EFM_ASSERT(!(((uint32_t)init->ldmaInitCtrlNumFixed << _LDMA_CTRL_NUMFIXED_SHIFT)
    147                         & ~_LDMA_CTRL_NUMFIXED_MASK));
   \                     ??CrossCallReturnLabel_9: (+1)
   \        0xE   0x7821             LDRB     R1,[R4, #+0]
   \       0x10   0xF06F 0x50F8      MVN      R0,#+520093696
   \       0x14   0xEA10 0x6F01      TST      R0,R1, LSL #+24
   \       0x18   0xD002             BEQ.N    ??CrossCallReturnLabel_8
   \       0x1A   0x2193             MOVS     R1,#+147
   \       0x1C   0x.... 0x....      BL       ?Subroutine1
    148          
    149          #if defined(_LDMA_CTRL_SYNCPRSCLREN_SHIFT) && defined (_LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    150            EFM_ASSERT(!(((uint32_t)init->ldmaInitCtrlSyncPrsClrEn << _LDMA_CTRL_SYNCPRSCLREN_SHIFT)
    151                         & ~_LDMA_CTRL_SYNCPRSCLREN_MASK));
    152            EFM_ASSERT(!(((uint32_t)init->ldmaInitCtrlSyncPrsSetEn << _LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    153                         & ~_LDMA_CTRL_SYNCPRSSETEN_MASK));
    154          #endif
    155          
    156          #if defined(_LDMA_SYNCHWEN_SYNCCLREN_SHIFT) && defined (_LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    157            EFM_ASSERT(!(((uint32_t)init->ldmaInitCtrlSyncPrsClrEn << _LDMA_SYNCHWEN_SYNCCLREN_SHIFT)
    158                         & ~_LDMA_SYNCHWEN_SYNCCLREN_MASK));
    159            EFM_ASSERT(!(((uint32_t)init->ldmaInitCtrlSyncPrsSetEn << _LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    160                         & ~_LDMA_SYNCHWEN_SYNCSETEN_MASK));
    161          #endif
    162          
    163            EFM_ASSERT(init->ldmaInitIrqPriority < (1 << __NVIC_PRIO_BITS));
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x20   0x78E0             LDRB     R0,[R4, #+3]
   \       0x22   0x2810             CMP      R0,#+16
   \       0x24   0xDB02             BLT.N    ??CrossCallReturnLabel_7
   \       0x26   0x21A3             MOVS     R1,#+163
   \       0x28   0x.... 0x....      BL       ?Subroutine1
    164          
    165            CMU_ClockEnable(cmuClock_LDMA, true);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0x.... 0x....      BL       CMU_ClockEnable
    166          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG) && (_SILICON_LABS_32B_SERIES_2_CONFIG > 1)
    167            CMU_ClockEnable(cmuClock_LDMAXBAR, true);
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0x2021             MOVS     R0,#+33
   \       0x38   0x.... 0x....      BL       CMU_ClockEnable
    168          #endif
    169          
    170          #if defined(LDMA_EN_EN)
    171            LDMA->EN = LDMA_EN_EN;
   \       0x3C   0x....             LDR.N    R0,??DataTable7_1
   \       0x3E   0x2201             MOVS     R2,#+1
   \       0x40   0x6002             STR      R2,[R0, #+0]
    172          #endif
    173          
    174            ldmaCtrlVal = (uint32_t)init->ldmaInitCtrlNumFixed << _LDMA_CTRL_NUMFIXED_SHIFT;
    175          
    176          #if defined(_LDMA_CTRL_SYNCPRSCLREN_SHIFT) && defined (_LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    177            ldmaCtrlVal |=  (init->ldmaInitCtrlSyncPrsClrEn << _LDMA_CTRL_SYNCPRSCLREN_SHIFT)
    178                           | (init->ldmaInitCtrlSyncPrsSetEn << _LDMA_CTRL_SYNCPRSSETEN_SHIFT);
    179          #endif
    180          
    181            LDMA->CTRL = ldmaCtrlVal;
   \       0x42   0x7821             LDRB     R1,[R4, #+0]
   \       0x44   0x0609             LSLS     R1,R1,#+24
   \       0x46   0x6041             STR      R1,[R0, #+4]
    182          
    183          #if defined(_LDMA_SYNCHWEN_SYNCCLREN_SHIFT) && defined (_LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    184            LDMA->SYNCHWEN = ((uint32_t)init->ldmaInitCtrlSyncPrsClrEn << _LDMA_SYNCHWEN_SYNCCLREN_SHIFT)
    185                             | ((uint32_t)init->ldmaInitCtrlSyncPrsSetEn << _LDMA_SYNCHWEN_SYNCSETEN_SHIFT);
   \       0x48   0x7862             LDRB     R2,[R4, #+1]
   \       0x4A   0x78A1             LDRB     R1,[R4, #+2]
   \       0x4C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
    186          #endif
    187          
    188          #if defined(_LDMA_CHDIS_MASK)
    189            LDMA->CHDIS = _LDMA_CHEN_MASK;
   \       0x50   0x22FF             MOVS     R2,#+255
   \       0x52   0x6141             STR      R1,[R0, #+20]
   \       0x54   0x6242             STR      R2,[R0, #+36]
    190          #else
    191            LDMA->CHEN    = 0;
    192          #endif
    193            LDMA->DBGHALT = 0;
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x6341             STR      R1,[R0, #+52]
    194            LDMA->REQDIS  = 0;
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0x63C2             STR      R2,[R0, #+60]
    195          
    196            /* Enable the LDMA error interrupt. */
    197            LDMA->IEN = LDMA_IEN_ERROR;
   \       0x5E   0xF04F 0x4100      MOV      R1,#+2147483648
   \       0x62   0x6501             STR      R1,[R0, #+80]
    198          #if defined (LDMA_HAS_SET_CLEAR)
    199            LDMA->IF_CLR = 0xFFFFFFFFU;
   \       0x64   0xF04F 0x32FF      MOV      R2,#+4294967295
   \       0x68   0x....             LDR.N    R0,??DataTable7_5
   \       0x6A   0x6002             STR      R2,[R0, #+0]
    200          #else
    201            LDMA->IFC = 0xFFFFFFFFU;
    202          #endif
    203            NVIC_ClearPendingIRQ(LDMA_IRQn);
   \       0x6C   0xF44F 0x0080      MOV      R0,#+4194304
   \       0x70   0x....             LDR.N    R1,??DataTable7_6
   \       0x72   0x6008             STR      R0,[R1, #+0]
    204          
    205            /* Range is 0-7, where 0 is the highest priority. */
    206            NVIC_SetPriority(LDMA_IRQn, init->ldmaInitIrqPriority);
   \       0x74   0x78E2             LDRB     R2,[R4, #+3]
   \       0x76   0x....             LDR.N    R1,??DataTable7_7
   \       0x78   0x0112             LSLS     R2,R2,#+4
   \       0x7A   0x700A             STRB     R2,[R1, #+0]
    207          
    208            NVIC_EnableIRQ(LDMA_IRQn);
   \       0x7C   0x....             LDR.N    R3,??DataTable7_8
   \       0x7E   0x6018             STR      R0,[R3, #+0]
    209          }
   \       0x80   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF105 0x0064      ADD      R0,R5,#+100
   \        0x4   0x.... 0x....      B.W      assertEFM
    210          
    211          /***************************************************************************//**
    212           * @brief
    213           *   Start a DMA transfer.
    214           *
    215           * @param[in] ch
    216           *   A DMA channel.
    217           *
    218           * @param[in] transfer
    219           *   The initialization structure used to configure the transfer.
    220           *
    221           * @param[in] descriptor
    222           *   The transfer descriptor, which can be an array of descriptors linked together.
    223           *   Each descriptor's fields stored in RAM will be loaded into the certain
    224           *   hardware registers at the proper time to perform the DMA transfer.
    225           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          void LDMA_StartTransfer(int ch,
    227                                  const LDMA_TransferCfg_t *transfer,
    228                                  const LDMA_Descriptor_t  *descriptor)
    229          {
   \                     LDMA_StartTransfer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
    230          #if !(defined (_LDMA_SYNCHWEN_SYNCCLREN_SHIFT) && defined (_LDMA_SYNCHWEN_SYNCSETEN_SHIFT))
    231            uint32_t tmp;
    232          #endif
    233            CORE_DECLARE_IRQ_STATE;
    234            uint32_t chMask = 1UL << (uint8_t)ch;
   \        0x6   0x2501             MOVS     R5,#+1
   \        0x8   0x40BD             LSLS     R5,R5,R7
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x4690             MOV      R8,R2
    235          
    236            EFM_ASSERT(ch < (int)DMA_CHAN_COUNT);
   \        0xE   0x....             LDR.N    R6,??DataTable7_2
   \       0x10   0x2F08             CMP      R7,#+8
   \       0x12   0xDB02             BLT.N    ??CrossCallReturnLabel_5
   \       0x14   0x21EC             MOVS     R1,#+236
   \       0x16   0x.... 0x....      BL       ?Subroutine0
    237            EFM_ASSERT(transfer != NULL);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x1A   0xB914             CBNZ.N   R4,??CrossCallReturnLabel_4
   \       0x1C   0x21ED             MOVS     R1,#+237
   \       0x1E   0x.... 0x....      BL       ?Subroutine0
    238          
    239          #if defined (_LDMAXBAR_CH_REQSEL_MASK)
    240            EFM_ASSERT(!(transfer->ldmaReqSel & ~_LDMAXBAR_CH_REQSEL_MASK));
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x....             LDR.N    R0,??DataTable7_9
   \       0x26   0x4201             TST      R1,R0
   \       0x28   0xD002             BEQ.N    ??CrossCallReturnLabel_3
   \       0x2A   0x21F0             MOVS     R1,#+240
   \       0x2C   0x.... 0x....      BL       ?Subroutine0
    241          #elif defined (_LDMA_CH_REQSEL_MASK)
    242            EFM_ASSERT(!(transfer->ldmaReqSel & ~_LDMA_CH_REQSEL_MASK));
    243          #endif
    244          
    245          #if defined (_LDMA_SYNCHWEN_SYNCCLREN_SHIFT) && defined (_LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    246            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsClrOff << _LDMA_SYNCHWEN_SYNCCLREN_SHIFT)
    247                         & ~_LDMA_SYNCHWEN_SYNCCLREN_MASK));
    248            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsClrOn << _LDMA_SYNCHWEN_SYNCCLREN_SHIFT)
    249                         & ~_LDMA_SYNCHWEN_SYNCCLREN_MASK));
    250            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsSetOff << _LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    251                         & ~_LDMA_SYNCHWEN_SYNCSETEN_MASK));
    252            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsSetOn << _LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    253                         & ~_LDMA_SYNCHWEN_SYNCSETEN_MASK));
    254          #elif defined (_LDMA_CTRL_SYNCPRSCLREN_SHIFT) && defined (_LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    255            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsClrOff << _LDMA_CTRL_SYNCPRSCLREN_SHIFT)
    256                         & ~_LDMA_CTRL_SYNCPRSCLREN_MASK));
    257            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsClrOn << _LDMA_CTRL_SYNCPRSCLREN_SHIFT)
    258                         & ~_LDMA_CTRL_SYNCPRSCLREN_MASK));
    259            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsSetOff << _LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    260                         & ~_LDMA_CTRL_SYNCPRSSETEN_MASK));
    261            EFM_ASSERT(!(((uint32_t)transfer->ldmaCtrlSyncPrsSetOn << _LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    262                         & ~_LDMA_CTRL_SYNCPRSSETEN_MASK));
    263          #endif
    264          
    265            EFM_ASSERT(!(((uint32_t)transfer->ldmaCfgArbSlots << _LDMA_CH_CFG_ARBSLOTS_SHIFT)
    266                         & ~_LDMA_CH_CFG_ARBSLOTS_MASK));
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x30   0x7AA1             LDRB     R1,[R4, #+10]
   \       0x32   0xF46F 0x3040      MVN      R0,#+196608
   \       0x36   0xEA10 0x4F01      TST      R0,R1, LSL #+16
   \       0x3A   0xD003             BEQ.N    ??CrossCallReturnLabel_2
   \       0x3C   0xF44F 0x7185      MOV      R1,#+266
   \       0x40   0x.... 0x....      BL       ?Subroutine0
    267            EFM_ASSERT(!(((uint32_t)transfer->ldmaCfgSrcIncSign << _LDMA_CH_CFG_SRCINCSIGN_SHIFT)
    268                         & ~_LDMA_CH_CFG_SRCINCSIGN_MASK));
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x44   0x7AE1             LDRB     R1,[R4, #+11]
   \       0x46   0xF46F 0x1080      MVN      R0,#+1048576
   \       0x4A   0xEA10 0x5F01      TST      R0,R1, LSL #+20
   \       0x4E   0xD003             BEQ.N    ??CrossCallReturnLabel_1
   \       0x50   0xF44F 0x7186      MOV      R1,#+268
   \       0x54   0x.... 0x....      BL       ?Subroutine0
    269            EFM_ASSERT(!(((uint32_t)transfer->ldmaCfgDstIncSign << _LDMA_CH_CFG_DSTINCSIGN_SHIFT)
    270                         & ~_LDMA_CH_CFG_DSTINCSIGN_MASK));
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x58   0x7B21             LDRB     R1,[R4, #+12]
   \       0x5A   0xF46F 0x1000      MVN      R0,#+2097152
   \       0x5E   0xEA10 0x5F41      TST      R0,R1, LSL #+21
   \       0x62   0xD003             BEQ.N    ??CrossCallReturnLabel_0
   \       0x64   0xF44F 0x7187      MOV      R1,#+270
   \       0x68   0x.... 0x....      BL       ?Subroutine0
    271            EFM_ASSERT(!(((uint32_t)transfer->ldmaLoopCnt << _LDMA_CH_LOOP_LOOPCNT_SHIFT)
    272                         & ~_LDMA_CH_LOOP_LOOPCNT_MASK));
    273          
    274            /* Clear the pending channel interrupt. */
    275          #if defined (LDMA_HAS_SET_CLEAR)
    276            LDMA->IF_CLR = chMask;
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x6C   0x....             LDR.N    R6,??DataTable7_10
   \       0x6E   0x63B5             STR      R5,[R6, #+56]
    277          #else
    278            LDMA->IFC = chMask;
    279          #endif
    280          
    281          #if defined(LDMAXBAR)
    282            LDMAXBAR->CH[ch].REQSEL = transfer->ldmaReqSel;
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x....             LDR.N    R2,??DataTable7_11
    283          #else
    284            LDMA->CH[ch].REQSEL = transfer->ldmaReqSel;
    285          #endif
    286            LDMA->CH[ch].LOOP = transfer->ldmaLoopCnt << _LDMA_CH_LOOP_LOOPCNT_SHIFT;
   \       0x74   0x....             LDR.N    R1,??DataTable7_12
   \       0x76   0xF842 0x0027      STR      R0,[R2, R7, LSL #+2]
   \       0x7A   0x2030             MOVS     R0,#+48
   \       0x7C   0x4347             MULS     R7,R0,R7
   \       0x7E   0x7B63             LDRB     R3,[R4, #+13]
   \       0x80   0x19C8             ADDS     R0,R1,R7
   \       0x82   0x6083             STR      R3,[R0, #+8]
    287            LDMA->CH[ch].CFG = (transfer->ldmaCfgArbSlots << _LDMA_CH_CFG_ARBSLOTS_SHIFT)
    288                               | (transfer->ldmaCfgSrcIncSign << _LDMA_CH_CFG_SRCINCSIGN_SHIFT)
    289                               | (transfer->ldmaCfgDstIncSign << _LDMA_CH_CFG_DSTINCSIGN_SHIFT)
    290          #if defined(_LDMA_CH_CFG_SRCBUSPORT_MASK)
    291                               | (transfer->ldmaCfgStructBusPort << _LDMA_CH_CFG_STRUCTBUSPORT_SHIFT)
    292                               | (transfer->ldmaCfgSrcBusPort << _LDMA_CH_CFG_SRCBUSPORT_SHIFT)
    293                               | (transfer->ldmaCfgDstBusPort << _LDMA_CH_CFG_DSTBUSPORT_SHIFT)
    294          #endif
    295            ;
   \       0x84   0x7AE1             LDRB     R1,[R4, #+11]
   \       0x86   0x7AA2             LDRB     R2,[R4, #+10]
   \       0x88   0x0509             LSLS     R1,R1,#+20
   \       0x8A   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \       0x8E   0x7B22             LDRB     R2,[R4, #+12]
   \       0x90   0xEA41 0x5142      ORR      R1,R1,R2, LSL #+21
   \       0x94   0x6041             STR      R1,[R0, #+4]
    296          
    297            /* Set the descriptor address. */
    298            LDMA->CH[ch].LINK = (uint32_t)descriptor & _LDMA_CH_LINK_LINKADDR_MASK;
   \       0x96   0xEA4F 0x0198      LSR      R1,R8,#+2
   \       0x9A   0xEA4F 0x0881      LSL      R8,R1,#+2
   \       0x9E   0xF8C0 0x8018      STR      R8,[R0, #+24]
    299          
    300            /* A critical region. */
    301            CORE_ENTER_ATOMIC();
   \       0xA2   0x.... 0x....      BL       CORE_EnterAtomic
    302          
    303            /* Enable the channel interrupt. */
    304            LDMA->IEN |= chMask;
   \       0xA6   0x....             LDR.N    R2,??DataTable7_13
   \       0xA8   0x69D3             LDR      R3,[R2, #+28]
   \       0xAA   0x432B             ORRS     R3,R5,R3
   \       0xAC   0x61D3             STR      R3,[R2, #+28]
    305          
    306            if (transfer->ldmaReqDis) {
   \       0xAE   0x7A21             LDRB     R1,[R4, #+8]
   \       0xB0   0xB111             CBZ.N    R1,??LDMA_StartTransfer_0
    307              LDMA->REQDIS |= chMask;
   \       0xB2   0x6891             LDR      R1,[R2, #+8]
   \       0xB4   0x4329             ORRS     R1,R5,R1
   \       0xB6   0x6091             STR      R1,[R2, #+8]
    308            }
    309          
    310            if (transfer->ldmaDbgHalt) {
   \                     ??LDMA_StartTransfer_0: (+1)
   \       0xB8   0x7A61             LDRB     R1,[R4, #+9]
   \       0xBA   0xB111             CBZ.N    R1,??LDMA_StartTransfer_1
    311              LDMA->DBGHALT |= chMask;
   \       0xBC   0x6817             LDR      R7,[R2, #+0]
   \       0xBE   0x432F             ORRS     R7,R5,R7
   \       0xC0   0x6017             STR      R7,[R2, #+0]
    312            }
    313          
    314          #if defined (_LDMA_SYNCHWEN_SYNCCLREN_SHIFT) && defined (_LDMA_SYNCHWEN_SYNCSETEN_SHIFT)
    315          
    316            LDMA->SYNCHWEN_CLR =
    317              (((uint32_t)transfer->ldmaCtrlSyncPrsClrOff << _LDMA_SYNCHWEN_SYNCCLREN_SHIFT)
    318               | ((uint32_t)transfer->ldmaCtrlSyncPrsSetOff << _LDMA_SYNCHWEN_SYNCSETEN_SHIFT))
    319              & _LDMA_SYNCHWEN_MASK;
   \                     ??LDMA_StartTransfer_1: (+1)
   \       0xC2   0x7923             LDRB     R3,[R4, #+4]
   \       0xC4   0x79A1             LDRB     R1,[R4, #+6]
   \       0xC6   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \       0xCA   0x6031             STR      R1,[R6, #+0]
    320          
    321            LDMA->SYNCHWEN_SET =
    322              (((uint32_t)transfer->ldmaCtrlSyncPrsClrOn << _LDMA_SYNCHWEN_SYNCCLREN_SHIFT)
    323               | ((uint32_t)transfer->ldmaCtrlSyncPrsSetOn << _LDMA_SYNCHWEN_SYNCSETEN_SHIFT))
    324              & _LDMA_SYNCHWEN_MASK;
   \       0xCC   0x7963             LDRB     R3,[R4, #+5]
   \       0xCE   0x79E1             LDRB     R1,[R4, #+7]
   \       0xD0   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \       0xD4   0x....             LDR.N    R3,??DataTable7_14
   \       0xD6   0x6019             STR      R1,[R3, #+0]
    325          
    326          #elif defined (_LDMA_CTRL_SYNCPRSCLREN_SHIFT) && defined (_LDMA_CTRL_SYNCPRSSETEN_SHIFT)
    327          
    328            tmp = LDMA->CTRL;
    329          
    330            if (transfer->ldmaCtrlSyncPrsClrOff) {
    331              tmp &= ~_LDMA_CTRL_SYNCPRSCLREN_MASK
    332                     | (~transfer->ldmaCtrlSyncPrsClrOff << _LDMA_CTRL_SYNCPRSCLREN_SHIFT);
    333            }
    334          
    335            if (transfer->ldmaCtrlSyncPrsClrOn) {
    336              tmp |= transfer->ldmaCtrlSyncPrsClrOn << _LDMA_CTRL_SYNCPRSCLREN_SHIFT;
    337            }
    338          
    339            if (transfer->ldmaCtrlSyncPrsSetOff) {
    340              tmp &= ~_LDMA_CTRL_SYNCPRSSETEN_MASK
    341                     | (~transfer->ldmaCtrlSyncPrsSetOff << _LDMA_CTRL_SYNCPRSSETEN_SHIFT);
    342            }
    343          
    344            if (transfer->ldmaCtrlSyncPrsSetOn) {
    345              tmp |= transfer->ldmaCtrlSyncPrsSetOn << _LDMA_CTRL_SYNCPRSSETEN_SHIFT;
    346            }
    347          
    348            LDMA->CTRL = tmp;
    349          
    350          #else
    351          
    352            #error  "SYNC Set and SYNC Clear not defined"
    353          
    354          #endif
    355          
    356            BUS_RegMaskedClear(&LDMA->CHDONE, chMask);  /* Clear the done flag.     */
   \       0xD8   0x61F5             STR      R5,[R6, #+28]
    357            LDMA->LINKLOAD = chMask;      /* Start a transfer by loading the descriptor.  */
   \       0xDA   0x6115             STR      R5,[R2, #+16]
    358          
    359            /* A critical region end. */
    360            CORE_EXIT_ATOMIC();
   \       0xDC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xE0   0x.... 0x....      B.W      CORE_ExitAtomic
    361          }
    362          
    363          #if defined(_LDMA_CH_CTRL_EXTEND_MASK)
    364          /***************************************************************************//**
    365           * @brief
    366           *   Start an extended DMA transfer.
    367           *
    368           * @param[in] ch
    369           *   A DMA channel.
    370           *
    371           * @param[in] transfer
    372           *   The initialization structure used to configure the transfer.
    373           *
    374           * @param[in] descriptor_ext
    375           *   The extended transfer descriptor, which can be an array of descriptors
    376           *   linked together. Each descriptor's fields stored in RAM will be loaded
    377           *   into the certain hardware registers at the proper time to perform the DMA
    378           *   transfer.
    379           ******************************************************************************/
    380          void LDMA_StartTransferExtend(int ch,
    381                                        const LDMA_TransferCfg_t *transfer,
    382                                        const LDMA_DescriptorExtend_t *descriptor_ext)
    383          {
    384            // Ensure destination interleaving supported for given channel.
    385            EFM_ASSERT(((1 << ch) & LDMA_ILCHNL));
    386          
    387            LDMA_StartTransfer(ch,
    388                               transfer,
    389                               (const LDMA_Descriptor_t *)descriptor_ext);
    390          }
    391          #endif
    392          
    393          /***************************************************************************//**
    394           * @brief
    395           *   Stop a DMA transfer.
    396           *
    397           * @note
    398           *   The DMA will complete the current AHB burst transfer before stopping.
    399           *
    400           * @param[in] ch
    401           *   A DMA channel to stop.
    402           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    403          void LDMA_StopTransfer(int ch)
    404          {
   \                     LDMA_StopTransfer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    405            uint32_t chMask = 1UL << (uint8_t)ch;
   \        0x2   0x2401             MOVS     R4,#+1
   \        0x4   0x4084             LSLS     R4,R4,R0
    406          
    407            EFM_ASSERT(ch < (int)DMA_CHAN_COUNT);
   \        0x6   0x2808             CMP      R0,#+8
   \        0x8   0xDB03             BLT.N    ??CrossCallReturnLabel_12
   \        0xA   0xF240 0x1197      MOVW     R1,#+407
   \        0xE   0x.... 0x....      BL       ?Subroutine2
    408          
    409          #if defined(_LDMA_CHDIS_MASK)
    410            CORE_ATOMIC_SECTION(
    411              LDMA->IEN &= ~chMask;
    412              LDMA->CHDIS = chMask;
    413              )
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x12   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x16   0x....             LDR.N    R2,??DataTable7_15
   \       0x18   0x6AD1             LDR      R1,[R2, #+44]
   \       0x1A   0x43A1             BICS     R1,R1,R4
   \       0x1C   0x62D1             STR      R1,[R2, #+44]
   \       0x1E   0x6014             STR      R4,[R2, #+0]
   \       0x20   0xE8BD 0x4010      POP      {R4,LR}
   \       0x24   0x.... 0x....      B.W      CORE_ExitAtomic
    414          #else
    415            CORE_ATOMIC_SECTION(
    416              LDMA->IEN &= ~chMask;
    417              BUS_RegMaskedClear(&LDMA->CHEN, chMask);
    418              )
    419          #endif
    420          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable7_17
   \        0x2   0x.... 0x....      B.W      assertEFM
    421          
    422          /***************************************************************************//**
    423           * @brief
    424           *   Check if a DMA transfer has completed.
    425           *
    426           * @param[in] ch
    427           *   A DMA channel to check.
    428           *
    429           * @return
    430           *   True if transfer has completed, false if not.
    431           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    432          bool LDMA_TransferDone(int ch)
    433          {
   \                     LDMA_TransferDone: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    434            bool     retVal = false;
    435            uint32_t chMask = 1UL << (uint8_t)ch;
   \        0x2   0x2501             MOVS     R5,#+1
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x4085             LSLS     R5,R5,R0
    436          
    437            EFM_ASSERT(ch < (int)DMA_CHAN_COUNT);
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB03             BLT.N    ??CrossCallReturnLabel_11
   \        0xC   0xF240 0x11B5      MOVW     R1,#+437
   \       0x10   0x.... 0x....      BL       ?Subroutine2
    438          
    439          #if defined(_LDMA_CHSTATUS_MASK)
    440            CORE_ATOMIC_SECTION(
    441              if (((LDMA->CHSTATUS & chMask) == 0) && ((LDMA->CHDONE & chMask) == chMask)) {
    442              retVal = true;
    443            }
    444              )
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x14   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x18   0x....             LDR.N    R2,??DataTable7_16
   \       0x1A   0x6811             LDR      R1,[R2, #+0]
   \       0x1C   0x4229             TST      R1,R5
   \       0x1E   0xBF01             ITTTT    EQ
   \       0x20   0x6891             LDREQ    R1,[R2, #+8]
   \       0x22   0x4029             ANDEQ    R1,R5,R1
   \       0x24   0x42A9             CMPEQ    R1,R5
   \       0x26   0x2401             MOVEQ    R4,#+1
   \       0x28   0x.... 0x....      BL       CORE_ExitAtomic
    445          #else
    446            CORE_ATOMIC_SECTION(
    447              if (((LDMA->CHEN & chMask) == 0) && ((LDMA->CHDONE & chMask) == chMask)) {
    448              retVal = true;
    449            }
    450              )
    451          #endif
    452          
    453            return retVal;
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    454          }
    455          
    456          /***************************************************************************//**
    457           * @brief
    458           *  Get the number of items remaining in a transfer.
    459           *
    460           * @note
    461           *  This function does not take into account that a DMA transfer with
    462           *  a chain of linked transfers might be ongoing. It will only check the
    463           *  count for the current transfer.
    464           *
    465           * @param[in] ch
    466           *  The channel number of the transfer to check.
    467           *
    468           * @return
    469           *  A number of items remaining in the transfer.
    470           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    471          uint32_t LDMA_TransferRemainingCount(int ch)
    472          {
   \                     LDMA_TransferRemainingCount: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
    473            uint32_t remaining, done, iflag;
    474            uint32_t chMask = 1UL << (uint8_t)ch;
   \        0x4   0x2501             MOVS     R5,#+1
   \        0x6   0x40BD             LSLS     R5,R5,R7
    475          
    476            EFM_ASSERT(ch < (int)DMA_CHAN_COUNT);
   \        0x8   0x2F08             CMP      R7,#+8
   \        0xA   0xDB03             BLT.N    ??CrossCallReturnLabel_10
   \        0xC   0xF44F 0x71EE      MOV      R1,#+476
   \       0x10   0x.... 0x....      BL       ?Subroutine2
    477          
    478            CORE_ATOMIC_SECTION(
    479              iflag  = LDMA->IF;
    480              done   = LDMA->CHDONE;
    481              remaining = LDMA->CH[ch].CTRL;
    482              )
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x14   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x18   0x....             LDR.N    R1,??DataTable7_18
   \       0x1A   0x69CC             LDR      R4,[R1, #+28]
   \       0x1C   0x680E             LDR      R6,[R1, #+0]
   \       0x1E   0x2130             MOVS     R1,#+48
   \       0x20   0x434F             MULS     R7,R1,R7
   \       0x22   0x....             LDR.N    R2,??DataTable7_12
   \       0x24   0x402C             ANDS     R4,R5,R4
   \       0x26   0x19D1             ADDS     R1,R2,R7
   \       0x28   0x68CF             LDR      R7,[R1, #+12]
   \       0x2A   0x.... 0x....      BL       CORE_ExitAtomic
    483          
    484            iflag    &= chMask;
    485            done     &= chMask;
    486            remaining = (remaining & _LDMA_CH_CTRL_XFERCNT_MASK)
    487                        >> _LDMA_CH_CTRL_XFERCNT_SHIFT;
    488          
    489            if (done || ((remaining == 0) && iflag)) {
   \       0x2E   0x422E             TST      R6,R5
   \       0x30   0xF3C7 0x100A      UBFX     R0,R7,#+4,#+11
   \       0x34   0xD101             BNE.N    ??LDMA_TransferRemainingCount_0
   \       0x36   0xB910             CBNZ.N   R0,??LDMA_TransferRemainingCount_1
   \       0x38   0xB10C             CBZ.N    R4,??LDMA_TransferRemainingCount_1
    490              return 0;
   \                     ??LDMA_TransferRemainingCount_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBDF2             POP      {R1,R4-R7,PC}
    491            }
    492          
    493            /* +1 because XFERCNT is 0-based. */
    494            return remaining + 1;
   \                     ??LDMA_TransferRemainingCount_1: (+1)
   \       0x3E   0x1C40             ADDS     R0,R0,#+1
   \       0x40   0xBDF2             POP      {R1,R4-R7,PC}
    495          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x5004'0004        DC32     0x50040004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x5004'1040        DC32     0x50041040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x5004'2040        DC32     0x50042040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x5004'2050        DC32     0x50042050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0xE000'E416        DC32     0xe000e416

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \        0x0   0xFFC0'FFF0        DC32     0xffc0fff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \        0x0   0x5004'2018        DC32     0x50042018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \        0x0   0x5004'4004        DC32     0x50044004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \        0x0   0x5004'0058        DC32     0x50040058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \        0x0   0x5004'0038        DC32     0x50040038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \        0x0   0x5004'1018        DC32     0x50041018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \        0x0   0x5004'0028        DC32     0x50040028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \        0x0   0x5004'002C        DC32     0x5004002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \        0x0   0x....'....        DC32     ?_0+100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \        0x0   0x5004'0034        DC32     0x50040034

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x65          DC8 0x5C, 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x69
   \              0x6D 0x6C    
   \              0x69 0x62    
   \              0x5C 0x69
   \       0x58   0x6E 0x63          DC8 0x6E, 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x62, 0x75
   \              0x5C 0x65    
   \              0x6D 0x5F    
   \              0x62 0x75
   \       0x60   0x73 0x2E          DC8 0x73, 0x2E, 0x68, 0
   \              0x68 0x00
   \       0x64   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \       0x6C   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x74   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x7C   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x84   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x8C   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x94   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x9C   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0xA4   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0xAC   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0xB4   0x5C 0x65          DC8 0x5C, 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x73
   \              0x6D 0x6C    
   \              0x69 0x62    
   \              0x5C 0x73
   \       0xBC   0x72 0x63          DC8 0x72, 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x6C, 0x64
   \              0x5C 0x65    
   \              0x6D 0x5F    
   \              0x6C 0x64
   \       0xC4   0x6D 0x61          DC8 0x6D, 0x61, 0x2E, 0x63, 0
   \              0x2E 0x63    
   \              0x00
   \       0xC9                      DS8 3
    496          
    497          /** @} (end addtogroup ldma) */
    498          #endif /* defined( LDMA_PRESENT ) && ( LDMA_COUNT == 1 ) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   LDMA_DeInit
         0   -> CMU_ClockEnable
         8   -> CMU_ClockEnable
      24   LDMA_EnableChannelRequest
        24   -> assertEFM
      16   LDMA_Init
        16   -> CMU_ClockEnable
        16   -> assertEFM
      24   LDMA_StartTransfer
        24   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic
        24   -> assertEFM
       8   LDMA_StopTransfer
         8   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic
         8   -> assertEFM
      16   LDMA_TransferDone
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> assertEFM
      24   LDMA_TransferRemainingCount
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> assertEFM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  ?Subroutine0
       8  ?Subroutine1
       6  ?Subroutine2
     204  ?_0
      50  LDMA_DeInit
      54  LDMA_EnableChannelRequest
     130  LDMA_Init
     228  LDMA_StartTransfer
      40  LDMA_StopTransfer
      48  LDMA_TransferDone
      66  LDMA_TransferRemainingCount

 
 204 bytes in section .rodata
 714 bytes in section .text
 
 714 bytes of CODE  memory
 204 bytes of CONST memory

Errors: none
Warnings: none
