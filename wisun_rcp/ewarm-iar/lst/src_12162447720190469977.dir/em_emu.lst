###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:54
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_emu.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_emu.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_emu.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_emu.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir\em_emu.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_emu.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_emu.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Energy Management Unit (EMU) Peripheral API
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include <limits.h>
     32          
     33          #include "em_emu.h"
     34          #if defined(EMU_PRESENT) && (EMU_COUNT > 0)
     35          
     36          #include "sl_assert.h"
     37          #include "em_cmu.h"
     38          #include "em_gpio.h"
     39          #include "sl_common.h"
     40          #include "em_core.h"
     41          #include "em_system.h"
     42          #include "em_ramfunc.h"
     43          
     44          #if defined(SL_CATALOG_METRIC_EM23_WAKE_PRESENT)
     45          #include "sli_metric_em23_wake.h"
     46          #include "sli_metric_em23_wake_config.h"
     47          #endif
     48          
     49          #if defined(SL_CATALOG_METRIC_EM4_WAKE_PRESENT)
     50          #include "sli_metric_em4_wake.h"
     51          #endif
     52          
     53          #if defined(SYSCFG_PRESENT)
     54          #include "em_syscfg.h"
     55          #endif
     56          /* Consistency check, since restoring assumes similar bit positions in */
     57          /* CMU OSCENCMD and STATUS regs. */
     58          #if defined(CMU_STATUS_AUXHFRCOENS) && (CMU_STATUS_AUXHFRCOENS != CMU_OSCENCMD_AUXHFRCOEN)
     59          #error Conflict in AUXHFRCOENS and AUXHFRCOEN bitpositions
     60          #endif
     61          #if defined(CMU_STATUS_HFXOENS) && (CMU_STATUS_HFXOENS != CMU_OSCENCMD_HFXOEN)
     62          #error Conflict in HFXOENS and HFXOEN bitpositions
     63          #endif
     64          #if defined(CMU_STATUS_LFRCOENS) && (CMU_STATUS_LFRCOENS != CMU_OSCENCMD_LFRCOEN)
     65          #error Conflict in LFRCOENS and LFRCOEN bitpositions
     66          #endif
     67          #if defined(CMU_STATUS_LFXOENS) && (CMU_STATUS_LFXOENS != CMU_OSCENCMD_LFXOEN)
     68          #error Conflict in LFXOENS and LFXOEN bitpositions
     69          #endif
     70          
     71          /*******************************************************************************
     72           ******************************   DEFINES   ************************************
     73           ******************************************************************************/
     74          #if defined(_SILICON_LABS_32B_SERIES_0)
     75          /* Fix for errata EMU_E107 - non-WIC interrupt masks. */
     76          #if defined(_EFM32_GECKO_FAMILY)
     77          #define ERRATA_FIX_EMU_E107_ENABLE
     78          #define NON_WIC_INT_MASK_0    (~(0x0dfc0323U))
     79          #define NON_WIC_INT_MASK_1    (~(0x0U))
     80          
     81          #elif defined(_EFM32_TINY_FAMILY)
     82          #define ERRATA_FIX_EMU_E107_ENABLE
     83          #define NON_WIC_INT_MASK_0    (~(0x001be323U))
     84          #define NON_WIC_INT_MASK_1    (~(0x0U))
     85          
     86          #elif defined(_EFM32_GIANT_FAMILY)
     87          #define ERRATA_FIX_EMU_E107_ENABLE
     88          #define NON_WIC_INT_MASK_0    (~(0xff020e63U))
     89          #define NON_WIC_INT_MASK_1    (~(0x00000046U))
     90          
     91          #elif defined(_EFM32_WONDER_FAMILY)
     92          #define ERRATA_FIX_EMU_E107_ENABLE
     93          #define NON_WIC_INT_MASK_0    (~(0xff020e63U))
     94          #define NON_WIC_INT_MASK_1    (~(0x00000046U))
     95          
     96          #elif defined(_EFM32_ZERO_FAMILY)
     97          #define ERRATA_FIX_EMU_E107_ENABLE
     98          #define NON_WIC_INT_MASK_0    (~(0x00005c6bU))
     99          #define NON_WIC_INT_MASK_1    (~(0x00000000U))
    100          
    101          #elif defined(_EFM32_HAPPY_FAMILY)
    102          #define ERRATA_FIX_EMU_E107_ENABLE
    103          #define NON_WIC_INT_MASK_0    (~(0x00085c6bU))
    104          #define NON_WIC_INT_MASK_1    (~(0x00000000U))
    105          
    106          #endif
    107          #endif
    108          
    109          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_74) \
    110            || (defined(_SILICON_LABS_32B_SERIES_0)         \
    111            && (defined(_EFM32_HAPPY_FAMILY) || defined(_EFM32_ZERO_FAMILY)))
    112          // Fix for errata EMU_E110 - Potential Hard Fault when Exiting EM2.
    113          #define ERRATA_FIX_EMU_E110_ENABLE
    114          #endif
    115          
    116          /* Fix for errata EMU_E108 - High Current Consumption on EM4 Entry. */
    117          #if defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_HAPPY_FAMILY)
    118          #define ERRATA_FIX_EMU_E108_ENABLE
    119          #endif
    120          
    121          /* Fix for errata EMU_E208 - Occasional Full Reset After Exiting EM4H. */
    122          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    123          #define ERRATA_FIX_EMU_E208_ENABLE
    124          #endif
    125          
    126          /* Enable FETCNT tuning errata fix. */
    127          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    128          #define ERRATA_FIX_DCDC_FETCNT_SET_ENABLE
    129          #endif
    130          
    131          /* Enable LN handshake errata fix. */
    132          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    133          #define ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE
    134          typedef enum {
    135            errataFixDcdcHsInit,
    136            errataFixDcdcHsTrimSet,
    137            errataFixDcdcHsBypassLn,
    138            errataFixDcdcHsLnWaitDone
    139          } errataFixDcdcHs_TypeDef;
    140          static errataFixDcdcHs_TypeDef errataFixDcdcHsState = errataFixDcdcHsInit;
    141          #endif
    142          
    143          /* Fix for errata for EFM32GG11 and EFM32TG11. If a device is entering EM4S
    144           * while powering the analog peripherals from DVDD, firmware must switch
    145           * over to powering the analog peripherals from AVDD and delay the EM4S entry
    146           * with 30 us. */
    147          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_100) \
    148            || defined(_SILICON_LABS_GECKO_INTERNAL_SDID_103)
    149          #define ERRATA_FIX_EM4S_DELAY_ENTRY
    150          #endif
    151          
    152          #if defined(_SILICON_LABS_32B_SERIES_1)             \
    153            && !defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80) \
    154            && !defined(ERRATA_FIX_EMU_E220_DECBOD_IGNORE)
    155          /* EMU_E220 DECBOD Errata fix. DECBOD Reset can occur
    156           * during voltage scaling after EM2/3 wakeup. */
    157          #define ERRATA_FIX_EMU_E220_DECBOD_ENABLE
    158          #define EMU_PORBOD                   (*(volatile uint32_t *) (EMU_BASE + 0x14C))
    159          #define EMU_PORBOD_GMC_CALIB_DISABLE (0x1UL << 31)
    160          #endif
    161          
    162          /* Used to figure out if a memory address is inside or outside of a RAM block.
    163           * A memory address is inside a RAM block if the address is greater than the
    164           * RAM block address. */
    165          #define ADDRESS_NOT_IN_BLOCK(addr, block)  ((addr) <= (block) ? 1UL : 0UL)
    166          
    167          /* RAM Block layout for various device families. Note that some devices
    168           * have special layout in RAM0 and some devices have a special RAM block
    169           * at the end of their block layout. */
    170          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_84)
    171          #define RAM1_BLOCKS            2U
    172          #define RAM1_BLOCK_SIZE  0x10000U // 64 kB blocks
    173          #define RAM2_BLOCKS            1U
    174          #define RAM2_BLOCK_SIZE    0x800U // 2 kB block
    175          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_89)
    176          #define RAM0_BLOCKS            2U
    177          #define RAM0_BLOCK_SIZE   0x4000U
    178          #define RAM1_BLOCKS            2U
    179          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB blocks
    180          #define RAM2_BLOCKS            1U
    181          #define RAM2_BLOCK_SIZE    0x800U // 2 kB block
    182          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_95)
    183          #define RAM0_BLOCKS            1U
    184          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB block
    185          #define RAM1_BLOCKS            1U
    186          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB block
    187          #define RAM2_BLOCKS            1U
    188          #define RAM2_BLOCK_SIZE    0x800U // 2 kB block
    189          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_103)
    190          #define RAM0_BLOCKS            4U
    191          #define RAM0_BLOCK_SIZE   0x2000U //  8 kB blocks
    192          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_GIANT_FAMILY)
    193          #define RAM0_BLOCKS            4U
    194          #define RAM0_BLOCK_SIZE   0x8000U // 32 kB blocks
    195          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_GECKO_FAMILY)
    196          #define RAM0_BLOCKS            4U
    197          #define RAM0_BLOCK_SIZE   0x1000U //  4 kB blocks
    198          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_100)
    199          #define RAM0_BLOCKS            8U
    200          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    201          #define RAM1_BLOCKS            8U
    202          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB blocks
    203          #define RAM2_BLOCKS            4U
    204          #define RAM2_BLOCK_SIZE  0x10000U // 64 kB blocks
    205          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_106)
    206          #define RAM0_BLOCKS            4U
    207          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    208          #define RAM1_BLOCKS            4U
    209          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB blocks
    210          #define RAM2_BLOCKS            4U
    211          #define RAM2_BLOCK_SIZE   0x4000U // 16 kB blocks
    212          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    213          #define RAM0_BLOCKS            6U
    214          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    215          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_3)
    216          #define RAM0_BLOCKS            4U
    217          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    218          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_4)
    219          #define RAM0_BLOCKS           16U
    220          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    221          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_5)
    222          #define RAM0_BLOCKS           16U
    223          #define RAM0_BLOCK_SIZE   0x8000U // 32 kB blocks
    224          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_8)
    225          #define RAM0_BLOCKS           16U
    226          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    227          #endif
    228          
    229          #if defined(_SILICON_LABS_32B_SERIES_0)
    230          /* RAM_MEM_END on Gecko devices have a value larger than the SRAM_SIZE. */
    231          #define RAM0_END    (SRAM_BASE + SRAM_SIZE - 1)
    232          #else
    233          #define RAM0_END    RAM_MEM_END
    234          #endif
    235          
    236          #if defined(CMU_STATUS_HFXOSHUNTOPTRDY)
    237          #define HFXO_STATUS_READY_FLAGS  (CMU_STATUS_HFXOPEAKDETRDY | CMU_STATUS_HFXOSHUNTOPTRDY)
    238          #elif defined(CMU_STATUS_HFXOPEAKDETRDY)
    239          #define HFXO_STATUS_READY_FLAGS  (CMU_STATUS_HFXOPEAKDETRDY)
    240          #endif
    241          
    242          #if defined(EMU_SERIES1_DCDC_BUCK_PRESENT)
    243          #if !defined(PWRCFG_DCDCTODVDD_VMIN)
    244          /** DCDCTODVDD output range maximum. */
    245          #define PWRCFG_DCDCTODVDD_VMIN          1800U
    246          #endif
    247          #if !defined(PWRCFG_DCDCTODVDD_VMAX)
    248          /** DCDCTODVDD output range minimum. */
    249          #define PWRCFG_DCDCTODVDD_VMAX          3000U
    250          #endif
    251          #endif
    252          
    253          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE) || defined(EMU_SERIES1_DCDC_BUCK_PRESENT)
    254          #define DCDC_LP_PFET_CNT        7
    255          #define DCDC_LP_NFET_CNT        7
    256          #endif
    257          
    258          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
    259          #define EMU_DCDCSTATUS  (*(volatile uint32_t *)(EMU_BASE + 0x7C))
    260          #endif
    261          
    262          #if defined(EMU_SERIES1_DCDC_BUCK_PRESENT)
    263          /* Translate fields with different names across platform generations to common names. */
    264          #if defined(_EMU_DCDCMISCCTRL_LPCMPBIAS_MASK)
    265          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK      _EMU_DCDCMISCCTRL_LPCMPBIAS_MASK
    266          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT     _EMU_DCDCMISCCTRL_LPCMPBIAS_SHIFT
    267          #elif defined(_EMU_DCDCMISCCTRL_LPCMPBIASEM234H_MASK)
    268          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK      _EMU_DCDCMISCCTRL_LPCMPBIASEM234H_MASK
    269          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT     _EMU_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT
    270          #endif
    271          #if defined(_EMU_DCDCLPCTRL_LPCMPHYSSEL_MASK)
    272          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK      _EMU_DCDCLPCTRL_LPCMPHYSSEL_MASK
    273          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT     _EMU_DCDCLPCTRL_LPCMPHYSSEL_SHIFT
    274          #elif defined(_EMU_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK)
    275          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK      _EMU_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK
    276          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT     _EMU_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT
    277          #endif
    278          
    279          /* Disable LP mode hysteresis in the state machine control. */
    280          #define EMU_DCDCMISCCTRL_LPCMPHYSDIS (0x1UL << 1)
    281          /* Comparator threshold on the high side. */
    282          #define EMU_DCDCMISCCTRL_LPCMPHYSHI  (0x1UL << 2)
    283          #define EMU_DCDCSMCTRL  (*(volatile uint32_t *)(EMU_BASE + 0x44))
    284          
    285          #define DCDC_TRIM_MODES ((uint8_t)dcdcTrimMode_LN + 1)
    286          #endif
    287          
    288          #if defined(EMU_SERIES2_DCDC_BUCK_PRESENT) \
    289            || defined(EMU_SERIES2_DCDC_BOOST_PRESENT)
    290          /* EMU DCDC MODE set timeout. */
    291          #define EMU_DCDC_MODE_SET_TIMEOUT           1000000
    292          #endif
    293          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    294          #define EMU_TESTLOCK         (*(volatile uint32_t *) (EMU_BASE + 0x190))
    295          #define EMU_BIASCONF         (*(volatile uint32_t *) (EMU_BASE + 0x164))
    296          #define EMU_BIASTESTCTRL     (*(volatile uint32_t *) (EMU_BASE + 0x19C))
    297          #define CMU_ULFRCOCTRL       (*(volatile uint32_t *) (CMU_BASE + 0x03C))
    298          #endif
    299          
    300          #if defined(_EMU_TEMP_TEMP_MASK)
    301          /* As the energy mode at which a temperature measurement was taken at is
    302           * not known, the chosen constant for the TEMPCO calculation is midway between
    303           * the EM0/EM1 constant and the EM2/EM3/EM4 constant.
    304           */
    305          #define EMU_TEMPCO_CONST (0.273f)
    306          #endif
    307          
    308          #define EMU_EM4_ENTRY_WAIT_LOOPS 200
    309          
    310          /*******************************************************************************
    311           ***************************  LOCAL VARIABLES   ********************************
    312           ******************************************************************************/
    313          
    314          /* Static user configuration. */
    315          #if defined(EMU_SERIES1_DCDC_BUCK_PRESENT)
    316          static uint16_t dcdcMaxCurrent_mA;
    317          static uint16_t dcdcEm01LoadCurrent_mA;
    318          static EMU_DcdcLnReverseCurrentControl_TypeDef dcdcReverseCurrentControl;
    319          #endif
    320          #if defined(EMU_VSCALE_EM01_PRESENT)

   \                                 In section .bss, align 1
    321          static EMU_EM01Init_TypeDef vScaleEM01Config = { false };
   \                     vScaleEM01Config:
   \        0x0                      DS8 1
    322          #endif
    323          
    324          /*******************************************************************************
    325           **************************   LOCAL FUNCTIONS   ********************************
    326           ******************************************************************************/
    327          
    328          #if defined(EMU_VSCALE_EM01_PRESENT)
    329          /* Convert from level to EM0/1 command bit */
    330          __STATIC_INLINE uint32_t vScaleEM01Cmd(EMU_VScaleEM01_TypeDef level)
    331          {
    332          #if defined(_SILICON_LABS_32B_SERIES_2)
    333            return EMU_CMD_EM01VSCALE1 << ((uint32_t)level - _EMU_STATUS_VSCALE_VSCALE1);
    334          #else
    335            return EMU_CMD_EM01VSCALE0 << (_EMU_STATUS_VSCALE_VSCALE0 - (uint32_t)level);
    336          #endif
    337          }
    338          #endif
    339          
    340          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_205) \
    341            || defined(ERRATA_FIX_EMU_E110_ENABLE)
    342          SL_RAMFUNC_DECLARATOR static void __attribute__ ((noinline)) ramWFI(void);
    343          SL_RAMFUNC_DEFINITION_BEGIN
    344          static void __attribute__ ((noinline)) ramWFI(void)
    345          {
    346          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_205)
    347            __WFI();                      // Enter EM2 or EM3
    348            if (CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk) {
    349              for (volatile int i = 0; i < 6; i++) {
    350              }                           // Dummy wait loop ...
    351            }
    352          
    353          #else
    354            __WFI();                      // Enter EM2 or EM3
    355          #if defined(__GNUC__)
    356          #pragma GCC diagnostic push
    357          #pragma GCC diagnostic ignored "-Warray-bounds"
    358          #endif
    359            *(volatile uint32_t*)4;       // Clear faulty read data after wakeup
    360          #if defined(__GNUC__)
    361          #pragma GCC diagnostic pop
    362          #endif
    363          #endif
    364          }
    365          SL_RAMFUNC_DEFINITION_END
    366          #endif
    367          
    368          #if defined(ERRATA_FIX_EMU_E220_DECBOD_ENABLE)
    369          SL_RAMFUNC_DECLARATOR static void __attribute__ ((noinline)) ramWFI(void);
    370          SL_RAMFUNC_DEFINITION_BEGIN
    371          static void __attribute__ ((noinline)) ramWFI(void)
    372          {
    373            /* Second part of EMU_E220 DECBOD Errata fix. Calibration needs to be disabled
    374             * quickly when coming out of EM2/EM3. Ram execution is needed to meet timing.
    375             * Calibration is re-enabled after voltage scaling completes. */
    376            uint32_t temp = EMU_PORBOD | EMU_PORBOD_GMC_CALIB_DISABLE;
    377            __WFI();
    378            EMU_PORBOD = temp;
    379          }
    380          SL_RAMFUNC_DEFINITION_END
    381          #endif
    382          
    383          #if (_SILICON_LABS_32B_SERIES < 2)
    384          /***************************************************************************//**
    385           * @brief
    386           *   Save/restore/update oscillator, core clock and voltage scaling configuration on
    387           *   EM2 or EM3 entry/exit.
    388           *
    389           * @details
    390           *   Hardware may automatically change the oscillator and the voltage scaling configuration
    391           *   when going into or out of an energy mode. Static data in this function keeps track of
    392           *   such configuration bits and is used to restore state if needed.
    393           *
    394           ******************************************************************************/
    395          typedef enum {
    396            emState_Save,         /* Save EMU and CMU state. */
    397            emState_Restore,      /* Restore and unlock.     */
    398          } emState_TypeDef;
    399          
    400          static void emState(emState_TypeDef action)
    401          {
    402            uint32_t oscEnCmd;
    403            uint32_t cmuLocked;
    404            static uint32_t cmuStatus;
    405            static CMU_Select_TypeDef hfClock;
    406          #if defined(EMU_VSCALE_PRESENT)
    407            static uint8_t vScaleStatus;
    408            static uint32_t hfrcoCtrl;
    409          #endif
    410          
    411            /* Save or update state. */
    412            if (action == emState_Save) {
    413              /* Save configuration. */
    414              cmuStatus = CMU->STATUS;
    415              hfClock = CMU_ClockSelectGet(cmuClock_HF);
    416          #if defined(EMU_VSCALE_PRESENT)
    417              /* Save vscale. */
    418              EMU_VScaleWait();
    419              vScaleStatus = (uint8_t)((EMU->STATUS & _EMU_STATUS_VSCALE_MASK)
    420                                       >> _EMU_STATUS_VSCALE_SHIFT);
    421              hfrcoCtrl = CMU->HFRCOCTRL;
    422          #endif
    423            } else { /* Restore state. */
    424              /* Apply saved configuration. */
    425          #if defined(EMU_VSCALE_PRESENT)
    426          #if defined(_SILICON_LABS_32B_SERIES_1)
    427              if (EMU_LDOStatusGet() == true)
    428              /* Restore voltage scaling level if LDO regulator is on. */
    429          #endif
    430              {
    431                /* Restore EM0 and 1 voltage scaling level.
    432                   @ref EMU_VScaleWait() is called later,
    433                   just before HF clock select is set. */
    434                EMU->CMD = vScaleEM01Cmd((EMU_VScaleEM01_TypeDef)vScaleStatus);
    435              }
    436          #endif
    437              /* CMU registers may be locked. */
    438              cmuLocked = CMU->LOCK & CMU_LOCK_LOCKKEY_LOCKED;
    439              CMU_Unlock();
    440          
    441          #if defined(_CMU_OSCENCMD_MASK)
    442              /* AUXHFRCO are automatically disabled (except if using debugger). */
    443              /* HFRCO, USHFRCO and HFXO are automatically disabled. */
    444              /* LFRCO/LFXO may be disabled by SW in EM3. */
    445              /* Restore according to status prior to entering energy mode. */
    446              oscEnCmd = 0;
    447              oscEnCmd |= (cmuStatus & CMU_STATUS_HFRCOENS) != 0U
    448                          ? CMU_OSCENCMD_HFRCOEN : 0U;
    449              oscEnCmd |= (cmuStatus & CMU_STATUS_AUXHFRCOENS) != 0U
    450                          ? CMU_OSCENCMD_AUXHFRCOEN : 0U;
    451              oscEnCmd |= (cmuStatus & CMU_STATUS_LFRCOENS) != 0U
    452                          ? CMU_OSCENCMD_LFRCOEN : 0U;
    453              oscEnCmd |= (cmuStatus & CMU_STATUS_HFXOENS) != 0U
    454                          ? CMU_OSCENCMD_HFXOEN : 0U;
    455              oscEnCmd |= (cmuStatus & CMU_STATUS_LFXOENS) != 0U
    456                          ? CMU_OSCENCMD_LFXOEN : 0U;
    457          #if defined(_CMU_STATUS_USHFRCOENS_MASK)
    458              oscEnCmd |= (cmuStatus & CMU_STATUS_USHFRCOENS) != 0U
    459                          ? CMU_OSCENCMD_USHFRCOEN : 0U;
    460          #endif
    461              CMU->OSCENCMD = oscEnCmd;
    462          #endif
    463          
    464          #if defined(_EMU_STATUS_VSCALE_MASK)
    465              /* Wait for upscale to complete and then restore selected clock. */
    466              EMU_VScaleWait();
    467              if ((EMU->CTRL & _EMU_CTRL_EM23VSCALEAUTOWSEN_MASK) != 0U) {
    468                /* Restore HFRCO frequency which was automatically adjusted by hardware. */
    469                while ((CMU->SYNCBUSY & CMU_SYNCBUSY_HFRCOBSY) != 0U) {
    470                }
    471                CMU->HFRCOCTRL = hfrcoCtrl;
    472                if (hfClock == cmuSelect_HFRCO) {
    473                  /* Optimize wait state after EM2/EM3 wakeup because hardware has
    474                   * modified them. */
    475                  CMU_UpdateWaitStates(SystemHfrcoFreq, (int)EMU_VScaleGet());
    476                }
    477              }
    478          #endif
    479          
    480              switch (hfClock) {
    481                case cmuSelect_LFXO:
    482                  CMU_CLOCK_SELECT_SET(HF, LFXO);
    483                  break;
    484                case cmuSelect_LFRCO:
    485                  CMU_CLOCK_SELECT_SET(HF, LFRCO);
    486                  break;
    487                case cmuSelect_HFXO:
    488                  CMU_CLOCK_SELECT_SET(HF, HFXO);
    489                  break;
    490          #if defined(CMU_CMD_HFCLKSEL_USHFRCODIV2)
    491                case cmuSelect_USHFRCODIV2:
    492                  CMU_CLOCK_SELECT_SET(HF, USHFRCODIV2);
    493                  break;
    494          #endif
    495          #if defined(CMU_HFCLKSTATUS_SELECTED_HFRCODIV2)
    496                case cmuSelect_HFRCODIV2:
    497                  CMU_CLOCK_SELECT_SET(HF, HFRCODIV2);
    498                  break;
    499          #endif
    500          #if defined(CMU_HFCLKSTATUS_SELECTED_CLKIN0)
    501                case cmuSelect_CLKIN0:
    502                  CMU_CLOCK_SELECT_SET(HF, CLKIN0);
    503                  break;
    504          #endif
    505          #if defined(CMU_HFCLKSTATUS_SELECTED_USHFRCO)
    506                case cmuSelect_USHFRCO:
    507                  CMU_CLOCK_SELECT_SET(HF, USHFRCO);
    508                  break;
    509          #endif
    510              }
    511          
    512          #if defined(_CMU_OSCENCMD_MASK)
    513              /* If HFRCO was disabled before entering Energy Mode, turn it off again */
    514              /* as it is automatically enabled by wake up */
    515              if ((cmuStatus & CMU_STATUS_HFRCOENS) == 0U) {
    516                CMU->OSCENCMD = CMU_OSCENCMD_HFRCODIS;
    517              }
    518          #endif
    519          
    520              /* Restore CMU register locking */
    521              if (cmuLocked != 0U) {
    522                CMU_Lock();
    523              }
    524            }
    525          }
    526          #endif
    527          
    528          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    529          /* Get enable conditions for errata EMU_E107 fix. */
    530          __STATIC_INLINE bool getErrataFixEmuE107En(void)
    531          {
    532          #if defined(_EFM32_HAPPY_FAMILY)   \
    533            || defined(_EFM32_TINY_FAMILY)   \
    534            || defined(_EFM32_WONDER_FAMILY) \
    535            || defined(_EFM32_ZERO_FAMILY)
    536            // all revisions have the errata
    537            return true;
    538          #else
    539            /* SYSTEM_ChipRevisionGet() could have been used here, but a faster implementation
    540             * would be needed in this case.
    541             */
    542            uint16_t majorMinorRev;
    543          
    544            /* CHIP MAJOR bit [3:0]. */
    545            majorMinorRev = ((ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK)
    546                             >> _ROMTABLE_PID0_REVMAJOR_SHIFT)
    547                            << 8;
    548            /* CHIP MINOR bit [7:4]. */
    549            majorMinorRev |= ((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
    550                              >> _ROMTABLE_PID2_REVMINORMSB_SHIFT)
    551                             << 4;
    552            /* CHIP MINOR bit [3:0]. */
    553            majorMinorRev |= (ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK)
    554                             >> _ROMTABLE_PID3_REVMINORLSB_SHIFT;
    555          
    556          #if defined(_EFM32_GECKO_FAMILY)
    557            // all GECKO revisions except Revision E have the errata
    558            return (majorMinorRev <= 0x0103);
    559          #elif defined(_EFM32_GIANT_FAMILY)
    560            // all LEOPARD GECKO (Major = 0x01 Or 0x02) revisions have the errata
    561            // all GIANT GECKO (Major = 0x01) revisions except Revision E have the errata
    562            return (majorMinorRev <= 0x0103) || (majorMinorRev == 0x0204) || (majorMinorRev == 0x0205);
    563          #else
    564            /* Invalid configuration. */
    565            EFM_ASSERT(false);
    566            /* Return when assertions are disabled. */
    567            return false;
    568          #endif
    569          #endif /* #if defined(_EFM32_ZERO_FAMILY) || defined(_EFM32_HAPPY_FAMILY) #else */
    570          }
    571          #endif /* #if defined(ERRATA_FIX_EMU_E107_ENABLE) */
    572          
    573          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
    574          /* Get enable conditions for errata EMU_E110 fix. */
    575          __STATIC_INLINE bool getErrataFixEmuE110En(void)
    576          {
    577            /* SYSTEM_ChipRevisionGet() could have been used here, but a faster implementation
    578             * would be needed in this case.
    579             */
    580            uint16_t majorMinorRev;
    581          
    582            /* CHIP MAJOR bit [3:0]. */
    583            majorMinorRev = ((ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK)
    584                             >> _ROMTABLE_PID0_REVMAJOR_SHIFT)
    585                            << 8;
    586            /* CHIP MINOR bit [7:4]. */
    587            majorMinorRev |= ((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
    588                              >> _ROMTABLE_PID2_REVMINORMSB_SHIFT)
    589                             << 4;
    590            /* CHIP MINOR bit [3:0]. */
    591            majorMinorRev |= (ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK)
    592                             >> _ROMTABLE_PID3_REVMINORLSB_SHIFT;
    593          
    594          #if defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_ZERO_FAMILY)
    595            return (majorMinorRev == 0x0100);
    596          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_HAPPY_FAMILY)
    597            return ((majorMinorRev == 0x0100 || majorMinorRev == 0x0101));
    598          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_WONDER_FAMILY)
    599            return (majorMinorRev == 0x0100);
    600          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_GIANT_FAMILY)
    601            return (majorMinorRev == 0x0204);
    602          #else
    603            /* Invalid configuration. */
    604            EFM_ASSERT(false);
    605            /* Return when assertions are disabled. */
    606            return false;
    607          #endif
    608          }
    609          #endif /* #if defined(ERRATA_FIX_EMU_E110_ENABLE) */
    610          
    611          /* LP prepare / LN restore P/NFET count. */
    612          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    613          static void currentLimitersUpdate(void);
    614          static void dcdcFetCntSet(bool lpModeSet)
    615          {
    616            uint32_t tmp;
    617            static uint32_t emuDcdcMiscCtrlReg;
    618          
    619            if (lpModeSet) {
    620              emuDcdcMiscCtrlReg = EMU->DCDCMISCCTRL;
    621              tmp  = EMU->DCDCMISCCTRL
    622                     & ~(_EMU_DCDCMISCCTRL_PFETCNT_MASK | _EMU_DCDCMISCCTRL_NFETCNT_MASK);
    623              tmp |= (DCDC_LP_PFET_CNT << _EMU_DCDCMISCCTRL_PFETCNT_SHIFT)
    624                     | (DCDC_LP_NFET_CNT << _EMU_DCDCMISCCTRL_NFETCNT_SHIFT);
    625              EMU->DCDCMISCCTRL = tmp;
    626              currentLimitersUpdate();
    627            } else {
    628              EMU->DCDCMISCCTRL = emuDcdcMiscCtrlReg;
    629              currentLimitersUpdate();
    630            }
    631          }
    632          #endif
    633          
    634          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
    635          static void dcdcHsFixLnBlock(void)
    636          {
    637            if ((errataFixDcdcHsState == errataFixDcdcHsTrimSet)
    638                || (errataFixDcdcHsState == errataFixDcdcHsBypassLn)) {
    639              /* Wait for LNRUNNING */
    640              if ((EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK) == EMU_DCDCCTRL_DCDCMODE_LOWNOISE) {
    641                while (!(EMU_DCDCSTATUS & (0x1 << 16))) {
    642                }
    643              }
    644              errataFixDcdcHsState = errataFixDcdcHsLnWaitDone;
    645            }
    646          }
    647          #endif
    648          
    649          #if defined(_EMU_CTRL_EM23VSCALE_MASK) && defined(EMU_CTRL_EM23VSCALEAUTOWSEN)
    650          /* Configure EMU and CMU for EM2 and 3 voltage downscale. */
    651          static void vScaleDownEM23Setup(void)
    652          {
    653          #if defined(_SILICON_LABS_32B_SERIES_1)
    654            if (EMU_LDOStatusGet() == false) {
    655              /* Skip voltage scaling if the LDO regulator is turned off. */
    656              return;
    657            }
    658          #endif
    659          
    660            /* Wait until previous scaling is done. */
    661            EMU_VScaleWait();
    662          
    663            uint32_t em23vs = (EMU->CTRL & _EMU_CTRL_EM23VSCALE_MASK) >> _EMU_CTRL_EM23VSCALE_SHIFT;
    664            uint32_t em01vs = (EMU->STATUS & _EMU_STATUS_VSCALE_MASK) >> _EMU_STATUS_VSCALE_SHIFT;
    665          
    666            /* Inverse coding. */
    667            if (em23vs > em01vs) {
    668              EMU->CTRL |= EMU_CTRL_EM23VSCALEAUTOWSEN;
    669          #if defined(_MSC_RAMCTRL_RAMWSEN_MASK)
    670              /* Set RAM wait states for safe EM2 wakeup. */
    671              BUS_RegMaskedSet(&MSC->RAMCTRL, (MSC_RAMCTRL_RAMWSEN
    672                                               | MSC_RAMCTRL_RAM1WSEN
    673                                               | MSC_RAMCTRL_RAM2WSEN));
    674          #endif
    675            } else {
    676              EMU->CTRL &= ~EMU_CTRL_EM23VSCALEAUTOWSEN;
    677            }
    678          }
    679          
    680          /* Handle automatic HFRCO adjustment that may have occurred during EM2/EM3. */
    681          static void vScaleAfterWakeup(void)
    682          {
    683            if ((EMU->CTRL & EMU_CTRL_EM23VSCALEAUTOWSEN) != 0U) {
    684              /* The hardware may have updated the HFRCOCTRL register during EM2/EM3
    685               * entry if voltage scaling in EM2/EM3 is enabled. The hardware would
    686               * then update the HFRCO frequency to 19 MHz automatically. */
    687              uint32_t freqRange = (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_FREQRANGE_MASK)
    688                                   >> _CMU_HFRCOCTRL_FREQRANGE_SHIFT;
    689              if (freqRange == 0x08U) {
    690                SystemHfrcoFreq = 19000000;
    691              }
    692            }
    693          }
    694          #endif
    695          
    696          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
    697          typedef enum {
    698            dpllState_Save,         /* Save DPLL state. */
    699            dpllState_Restore,      /* Restore DPLL.    */
    700          } dpllState_TypeDef;
    701          
    702          /***************************************************************************//**
    703           * @brief
    704           *   Save or restore DPLL state.
    705           *
    706           * @param[in] action
    707           *    Value to indicate saving DPLL state or restoring its state.
    708           *
    709           * @note
    710           *   The function is used in EMU_Save() and EMU_Restore() to handle the
    711           *   DPLL state before entering EM2 or EM3 and after exiting EM2 or EM3.
    712           *   The function is required for the EFR32xG22 and EFR32xG27 families.
    713           *   On those families devices, the DPLL is disabled automatically when
    714           *   entering EM2, EM3. But exiting EM2, EM3 won't re-enable automatically
    715           *   the DPLL. Hence, the software needs to re-enable the DPLL upon EM2/3
    716           *   exit.
    717           ******************************************************************************/
    718          static void dpllState(dpllState_TypeDef action)
    719          {
    720            CMU_ClkDiv_TypeDef div;
    721            static uint32_t dpllRefClk = CMU_DPLLREFCLKCTRL_CLKSEL_DISABLED;
    722          
    723            if (action == dpllState_Save) {
    724              dpllRefClk = CMU_DPLLREFCLKCTRL_CLKSEL_DISABLED;
    725              CMU->CLKEN0_SET = CMU_CLKEN0_DPLL0;
    726              if (DPLL0->EN == DPLL_EN_EN) {
    727                /* DPLL is in use, save reference clock selection. */
    728                dpllRefClk = CMU->DPLLREFCLKCTRL;
    729              }
    730            } else { /* Restore */
    731              if ((dpllRefClk != CMU_DPLLREFCLKCTRL_CLKSEL_DISABLED)
    732                  && (DPLL0->EN != DPLL_EN_EN)) {
    733                /* Restore DPLL reference clock selection. */
    734                CMU->DPLLREFCLKCTRL = dpllRefClk;
    735                /* Only wait for DPLL lock if HFRCODPLL is used as SYSCLK. */
    736                if (CMU_ClockSelectGet(cmuClock_SYSCLK) == cmuSelect_HFRCODPLL) {
    737                  /* Set HCLK prescaler to safe value to avoid overclocking while locking. */
    738                  div = CMU_ClockDivGet(cmuClock_HCLK);
    739                  if (div == 1U) {
    740                    CMU_ClockDivSet(cmuClock_HCLK, 2U);
    741                  }
    742          
    743                  /* Relock DPLL and wait for ready. */
    744                  DPLL0->IF_CLR = DPLL_IF_LOCK | DPLL_IF_LOCKFAILLOW | DPLL_IF_LOCKFAILHIGH;
    745                  DPLL0->EN_SET = DPLL_EN_EN;
    746                  while ((DPLL0->IF & DPLL_IF_LOCK) == 0U) {
    747                  }
    748          
    749                  /* Restore HCLK prescaler. */
    750                  if (div == 1U) {
    751                    CMU_ClockDivSet(cmuClock_HCLK, 1U);
    752                  }
    753                } else {
    754                  /* Relock DPLL and exit without waiting for ready. */
    755                  DPLL0->EN_SET = DPLL_EN_EN;
    756                }
    757              }
    758            }
    759          }
    760          #endif
    761          
    762          /*******************************************************************************
    763           **************************   GLOBAL FUNCTIONS   *******************************
    764           ******************************************************************************/
    765          
    766          /***************************************************************************//**
    767           * @addtogroup emu EMU - Energy Management Unit
    768           * @brief Energy Management Unit (EMU) Peripheral API
    769           * @details
    770           *  This module contains functions to control the EMU peripheral of Silicon
    771           *  Labs 32-bit MCUs and SoCs. The EMU handles the different low energy modes
    772           *  in Silicon Labs microcontrollers.
    773           * @{
    774           ******************************************************************************/
    775          
    776          #if defined(EMU_VSCALE_EM01_PRESENT)
    777          /***************************************************************************//**
    778           * @brief
    779           *   Update the EMU module with Energy Mode 0 and 1 configuration.
    780           *
    781           * @param[in] em01Init
    782           *    Energy Mode 0 and 1 configuration structure.
    783           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    784          void EMU_EM01Init(const EMU_EM01Init_TypeDef *em01Init)
    785          {
    786            vScaleEM01Config.vScaleEM01LowPowerVoltageEnable =
    787              em01Init->vScaleEM01LowPowerVoltageEnable;
   \                     EMU_EM01Init: (+1)
   \        0x0   0x7803             LDRB     R3,[R0, #+0]
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable18_1
    788            EMU_VScaleEM01ByClock(0, true);
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x7013             STRB     R3,[R2, #+0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x....             B.N      EMU_VScaleEM01ByClock
    789          }
    790          #endif
    791          
    792          /***************************************************************************//**
    793           * @brief
    794           *   Update the EMU module with Energy Mode 2 and 3 configuration.
    795           *
    796           * @param[in] em23Init
    797           *    Energy Mode 2 and 3 configuration structure.
    798           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    799          void EMU_EM23Init(const EMU_EM23Init_TypeDef *em23Init)
    800          {
    801          #if defined(_EMU_CTRL_EMVREG_MASK)
    802            EMU->CTRL = em23Init->em23VregFullEn ? (EMU->CTRL | EMU_CTRL_EMVREG)
    803                        : (EMU->CTRL & ~EMU_CTRL_EMVREG);
    804          #elif defined(_EMU_CTRL_EM23VREG_MASK)
    805            EMU->CTRL = em23Init->em23VregFullEn ? (EMU->CTRL | EMU_CTRL_EM23VREG)
    806                        : (EMU->CTRL & ~EMU_CTRL_EM23VREG);
    807          #else
    808            (void)em23Init;
    809          #endif
    810          
    811          #if defined(EMU_VSCALE_PRESENT)
    812            EMU->CTRL = (EMU->CTRL & ~_EMU_CTRL_EM23VSCALE_MASK)
    813                        | ((uint32_t)em23Init->vScaleEM23Voltage << _EMU_CTRL_EM23VSCALE_SHIFT);
   \                     EMU_EM23Init: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x7840             LDRB     R0,[R0, #+1]
   \        0x8   0xF422 0x7240      BIC      R2,R2,#0x300
   \        0xC   0xEA42 0x2200      ORR      R2,R2,R0, LSL #+8
   \       0x10   0x600A             STR      R2,[R1, #+0]
    814          #if defined(CMU_HFXOCTRL_AUTOSTARTSELEM0EM1)
    815            if (em23Init->vScaleEM23Voltage == emuVScaleEM23_LowPower) {
    816              /* Voltage scaling is not compatible with HFXO auto start and select. */
    817              EFM_ASSERT((CMU->HFXOCTRL & CMU_HFXOCTRL_AUTOSTARTSELEM0EM1) == 0U);
    818            }
    819          #endif
    820          #endif
    821          }
   \       0x12   0x4770             BX       LR
    822          
    823          /***************************************************************************//**
    824           * @brief
    825           *   Energy mode 2/3 pre-sleep hook function.
    826           *
    827           * @details
    828           *   This function is called by EMU_EnterEM2() and EMU_EnterEM3() functions
    829           *   just prior to execution of the WFI instruction. The function implementation
    830           *   does not perform anything, but it is SL_WEAK so that it can be re-
    831           *   implemented in application code if actions are needed.
    832           ******************************************************************************/

   \                                 In section .text, align 2
    833          SL_WEAK void EMU_EM23PresleepHook(void)
    834          {
    835          }
   \                     EMU_EM23PresleepHook: (+1)
   \        0x0   0x4770             BX       LR
    836          
    837          /***************************************************************************//**
    838           * @brief
    839           *   EFP's Energy mode 2/3 pre-sleep hook function.
    840           *
    841           * @details
    842           *   This function is similar to @ref EMU_EM23PresleepHook() but is reserved
    843           *   for EFP usage.
    844           *
    845           * @note
    846           *   The function is primarily meant to be used in systems with EFP circuitry.
    847           *   (EFP = Energy Friendly Pmic (PMIC = Power Management IC)).
    848           *   In such systems there is a need to drive certain signals to EFP pins to
    849           *   notify about energy mode transitions.
    850           ******************************************************************************/

   \                                 In section .text, align 2
    851          SL_WEAK void EMU_EFPEM23PresleepHook(void)
    852          {
    853          }
   \                     EMU_EFPEM23PresleepHook: (+1)
   \        0x0   0x4770             BX       LR
    854          
    855          /***************************************************************************//**
    856           * @brief
    857           *   Energy mode 2/3 post-sleep hook function.
    858           *
    859           * @details
    860           *   This function is called by EMU_EnterEM2() and EMU_EnterEM3() functions
    861           *   just after wakeup from the WFI instruction. The function implementation
    862           *   does not perform anything, but it is SL_WEAK so that it can be re-
    863           *   implemented in application code if actions are needed.
    864           ******************************************************************************/

   \                                 In section .text, align 2
    865          SL_WEAK void EMU_EM23PostsleepHook(void)
    866          {
    867          }
   \                     EMU_EM23PostsleepHook: (+1)
   \        0x0   0x4770             BX       LR
    868          
    869          /***************************************************************************//**
    870           * @brief
    871           *   EFP's Energy mode 2/3 post-sleep hook function.
    872           *
    873           * @details
    874           *   This function is similar to @ref EMU_EM23PostsleepHook() but is reserved
    875           *   for EFP usage.
    876           *
    877           * @note
    878           *   The function is primarily meant to be used in systems with EFP circuitry.
    879           *   (EFP = Energy Friendly Pmic (PMIC = Power Management IC)).
    880           *   In such systems there is a need to drive certain signals to EFP pins to
    881           *   notify about energy mode transitions.
    882           ******************************************************************************/

   \                                 In section .text, align 2
    883          SL_WEAK void EMU_EFPEM23PostsleepHook(void)
    884          {
    885          }
   \                     EMU_EFPEM23PostsleepHook: (+1)
   \        0x0   0x4770             BX       LR
    886          
    887          /***************************************************************************//**
    888           * @brief
    889           *   Enter energy mode 2 (EM2).
    890           *
    891           * @details
    892           *   When entering EM2, high-frequency clocks are disabled, i.e., HFXO, HFRCO
    893           *   and AUXHFRCO (for AUXHFRCO, see exception note below). When re-entering
    894           *   EM0, HFRCO is re-enabled and the core will be clocked by the configured
    895           *   HFRCO band. This ensures a quick wakeup from EM2.
    896           *
    897           *   However, prior to entering EM2, the core may have been using another
    898           *   oscillator than HFRCO. The @p restore parameter gives the user the option
    899           *   to restore all HF oscillators according to state prior to entering EM2,
    900           *   as well as the clock used to clock the core. This restore procedure is
    901           *   handled by SW. However, since handled by SW, it will not be restored
    902           *   before completing the interrupt function(s) waking up the core!
    903           *
    904           * @note
    905           *   If restoring core clock to use the HFXO oscillator, which has been
    906           *   disabled during EM2 mode, this function will stall until the oscillator
    907           *   has stabilized. Stalling time can be reduced by adding interrupt
    908           *   support detecting stable oscillator, and an asynchronous switch to the
    909           *   original oscillator. See CMU documentation. Such a feature is however
    910           *   outside the scope of the implementation in this function.
    911           * @note
    912           *   If ERRATA_FIX_EMU_E110_ENABLE is active, the core's SLEEPONEXIT feature
    913           *   can not be used.
    914           * @note
    915           *   This function is incompatible with the Power Manager module. When the
    916           *   Power Manager module is present, it must be the one deciding at which
    917           *   EM level the device sleeps to ensure the application properly works. Using
    918           *   both at the same time could lead to undefined behavior in the application.
    919           * @par
    920           *   If HFXO is re-enabled by this function, and NOT used to clock the core,
    921           *   this function will not wait for HFXO to stabilize. This must be considered
    922           *   by the application if trying to use features relying on that oscillator
    923           *   upon return.
    924           * @par
    925           *   If a debugger is attached, the AUXHFRCO will not be disabled if enabled
    926           *   upon entering EM2. It will thus remain enabled when returning to EM0
    927           *   regardless of the @p restore parameter.
    928           * @par
    929           *   If HFXO autostart and select is enabled by using CMU_HFXOAutostartEnable(),
    930           *   the automatic starting and selecting of the core clocks will be done,
    931           *   regardless of the @p restore parameter, when waking up on the wakeup
    932           *   sources corresponding to the autostart and select setting.
    933           * @par
    934           *   If voltage scaling is supported, the restore parameter is true and the EM0
    935           *   voltage scaling level is set higher than the EM2 level, then the EM0 level is
    936           *   also restored.
    937           * @par
    938           *   On Series 2 Config 2 devices (EFRxG22), this function will also relock the
    939           *   DPLL if the DPLL is used and @p restore is true.
    940           *
    941           *   Note that the hardware will automatically update the HFRCO frequency in the
    942           *   case where voltage scaling is used in EM2/EM3 and not in EM0/EM1. When the
    943           *   restore argument to this function is true then software will restore the
    944           *   original HFRCO frequency after EM2/EM3 wake up. If the restore argument is
    945           *   false then the HFRCO frequency is 19 MHz when coming out of EM2/EM3 and
    946           *   all wait states are at a safe value.
    947           *
    948           * @param[in] restore
    949           *   @li true - save and restore oscillators, clocks and voltage scaling, see
    950           *   function details.
    951           *   @li false - do not save and restore oscillators and clocks, see function
    952           *   details.
    953           * @par
    954           *   The @p restore option should only be used if all clock control is done
    955           *   via the CMU API.
    956           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    957          void EMU_EnterEM2(bool restore)
    958          {
   \                     EMU_EnterEM2: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    959          #if defined(SLI_METRIC_EM2_HOOK)
    960            sli_metric_em23_wake_init(SLI_INIT_EM2_WAKE);
    961          #endif
    962          
    963          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    964            bool errataFixEmuE107En;
    965            uint32_t nonWicIntEn[2];
    966          #endif
    967          
    968          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
    969            bool errataFixEmuE110En;
    970          #endif
    971          
    972          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
    973            if (restore) {
    974              dpllState(dpllState_Save);
    975            }
    976          #endif
    977          
    978          #if (_SILICON_LABS_32B_SERIES < 2)
    979            /* Only save EMU and CMU state if restored on wake-up. */
    980            if (restore) {
    981              emState(emState_Save);
    982            }
    983          #endif
    984          
    985          #if defined(_EMU_CTRL_EM23VSCALE_MASK) && defined(EMU_CTRL_EM23VSCALEAUTOWSEN)
    986            vScaleDownEM23Setup();
    987          #endif
    988          
    989            /* Enter Cortex deep sleep mode. */
    990            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \        0x8   0x6808             LDR      R0,[R1, #+0]
   \        0xA   0xF040 0x0004      ORR      R0,R0,#0x4
   \        0xE   0x6008             STR      R0,[R1, #+0]
    991          
    992            /* Fix for errata EMU_E107 - store non-WIC interrupt enable flags.
    993               Disable the enabled non-WIC interrupts. */
    994          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    995            errataFixEmuE107En = getErrataFixEmuE107En();
    996            if (errataFixEmuE107En) {
    997              nonWicIntEn[0] = NVIC->ISER[0] & NON_WIC_INT_MASK_0;
    998              NVIC->ICER[0] = nonWicIntEn[0];
    999          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
   1000              nonWicIntEn[1] = NVIC->ISER[1] & NON_WIC_INT_MASK_1;
   1001              NVIC->ICER[1] = nonWicIntEn[1];
   1002          #endif
   1003            }
   1004          #endif
   1005          
   1006          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
   1007            dcdcFetCntSet(true);
   1008          #endif
   1009          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
   1010            dcdcHsFixLnBlock();
   1011          #endif
   1012          
   1013            EMU_EM23PresleepHook();
   \       0x10   0x.... 0x....      BL       EMU_EM23PresleepHook
   1014            EMU_EFPEM23PresleepHook();
   \       0x14   0x.... 0x....      BL       EMU_EFPEM23PresleepHook
   1015          
   1016          #if defined(_GPIO_IF_EM4WU_MASK)
   1017            // Clear all EM4WU interrupts before entering sleep
   1018            GPIO_IntClear(_GPIO_IF_EM4WU_MASK);
   \       0x18   0x.... 0x....      BL       ?Subroutine4
   1019          #endif
   1020          
   1021          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_205) \
   1022            || defined(ERRATA_FIX_EMU_E110_ENABLE)
   1023          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
   1024            errataFixEmuE110En = getErrataFixEmuE110En();
   1025            if (errataFixEmuE110En) {
   1026          #endif
   1027            CORE_CRITICAL_SECTION(ramWFI(); )
   1028          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
   1029          } else {
   1030            __WFI();
   1031          }
   1032          #endif
   1033          #elif defined(ERRATA_FIX_EMU_E220_DECBOD_ENABLE)
   1034            // Apply errata fix if voltage scaling in EM2 is used.
   1035            if ((EMU->CTRL & EMU_CTRL_EM23VSCALEAUTOWSEN) != 0U) {
   1036              CORE_CRITICAL_SECTION(ramWFI(); )
   1037            } else {
   1038              __WFI();
   1039            }
   1040          #else
   1041            __WFI();
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x1C   0xBF30             WFI
   1042          #endif
   1043            EMU_EFPEM23PostsleepHook();
   \       0x1E   0x.... 0x....      BL       EMU_EFPEM23PostsleepHook
   1044            EMU_EM23PostsleepHook();
   \       0x22   0x.... 0x....      BL       EMU_EM23PostsleepHook
   1045          
   1046          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
   1047            dcdcFetCntSet(false);
   1048          #endif
   1049          
   1050            /* Fix for errata EMU_E107 - restore state of non-WIC interrupt enable flags. */
   1051          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
   1052            if (errataFixEmuE107En) {
   1053              NVIC->ISER[0] = nonWicIntEn[0];
   1054          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
   1055              NVIC->ISER[1] = nonWicIntEn[1];
   1056          #endif
   1057            }
   1058          #endif
   1059          
   1060          #if (_SILICON_LABS_32B_SERIES < 2)
   1061            /* Restore oscillators/clocks and voltage scaling if supported. */
   1062            if (restore) {
   1063              emState(emState_Restore);
   1064            }
   1065          #if defined(_EMU_CTRL_EM23VSCALE_MASK) && defined(EMU_CTRL_EM23VSCALEAUTOWSEN)
   1066            else {
   1067              vScaleAfterWakeup();
   1068            }
   1069          #if defined(ERRATA_FIX_EMU_E220_DECBOD_ENABLE)
   1070            /* Third part of EMU_E220 DECBOD Errata fix. Calibration needs to be enabled
   1071             * after voltage scaling completes. */
   1072            EMU_PORBOD &= ~(EMU_PORBOD_GMC_CALIB_DISABLE);
   1073          #endif
   1074          #endif
   1075          #endif
   1076          
   1077          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
   1078            if (restore) {
   1079              dpllState(dpllState_Restore);
   1080            }
   1081          #endif
   1082          
   1083            if (!restore) {
   \       0x26   0xB904             CBNZ.N   R4,??EMU_EnterEM2_0
   1084              /* If not restoring, and the original clock was not HFRCO, the CMSIS */
   1085              /* core clock variable must be updated since HF clock has changed */
   1086              /* to HFRCO. */
   1087              SystemCoreClockUpdate();
   \       0x28   0x....             B.N      ?Subroutine2
   1088            }
   1089          }
   \                     ??EMU_EnterEM2_0: (+1)
   \       0x2A   0xBD10             POP      {R4,PC}
   1090          
   1091          /***************************************************************************//**
   1092           * @brief
   1093           *   Enter energy mode 3 (EM3).
   1094           *
   1095           * @details
   1096           *   When entering EM3, the high-frequency clocks are disabled by hardware, i.e., HFXO,
   1097           *   HFRCO, and AUXHFRCO (for AUXHFRCO, see exception note below). In addition,
   1098           *   the low-frequency clocks, i.e., LFXO and LFRCO are disabled by software. When
   1099           *   re-entering EM0, HFRCO is re-enabled and the core will be clocked by the
   1100           *   configured HFRCO band. This ensures a quick wakeup from EM3.
   1101           *
   1102           *   However, prior to entering EM3, the core may have been using an
   1103           *   oscillator other than HFRCO. The @p restore parameter gives the user the option
   1104           *   to restore all HF/LF oscillators according to state prior to entering EM3,
   1105           *   as well as the clock used to clock the core. This restore procedure is
   1106           *   handled by software. However, since it is handled by software, it will not be restored
   1107           *   before completing the interrupt function(s) waking up the core!
   1108           *
   1109           * @note
   1110           *   If restoring core clock to use an oscillator other than HFRCO, this
   1111           *   function will stall until the oscillator has stabilized. Stalling time
   1112           *   can be reduced by adding interrupt support detecting stable oscillator,
   1113           *   and an asynchronous switch to the original oscillator. See CMU
   1114           *   documentation. This feature is, however, outside the scope of the
   1115           *   implementation in this function.
   1116           * @note
   1117           *   If ERRATA_FIX_EMU_E110_ENABLE is active, the core's SLEEPONEXIT feature
   1118           *   can't be used.
   1119           * @note
   1120           *   This function is incompatible with the Power Manager module. When the
   1121           *   Power Manager module is present, it must be the one deciding at which
   1122           *   EM level the device sleeps to ensure the application properly works. Using
   1123           *   both at the same time could lead to undefined behavior in the application.
   1124           * @par
   1125           *   If HFXO/LFXO/LFRCO are re-enabled by this function, and NOT used to clock
   1126           *   the core, this function will not wait for those oscillators to stabilize.
   1127           *   This must be considered by the application if trying to use features
   1128           *   relying on those oscillators upon return.
   1129           * @par
   1130           *   If a debugger is attached, the AUXHFRCO will not be disabled if enabled
   1131           *   upon entering EM3. It will, therefore, remain enabled when returning to EM0
   1132           *   regardless of the @p restore parameter.
   1133           * @par
   1134           *   If voltage scaling is supported, the restore parameter is true and the EM0
   1135           *   voltage scaling level is set higher than the EM3 level, then the EM0 level is
   1136           *   also restored.
   1137           * @par
   1138           *   On Series 2 Config 2 devices (EFRxG22), this function will also relock the
   1139           *   DPLL if the DPLL is used and @p restore is true.
   1140           *
   1141           * @param[in] restore
   1142           *   @li true - save and restore oscillators, clocks and voltage scaling, see
   1143           *   function details.
   1144           *   @li false - do not save and restore oscillators and clocks, see function
   1145           *   details.
   1146           * @par
   1147           *   The @p restore option should only be used if all clock control is done
   1148           *   via the CMU API.
   1149           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1150          void EMU_EnterEM3(bool restore)
   1151          {
   \                     EMU_EnterEM3: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1152          #if defined(SLI_METRIC_EM3_HOOK)
   1153            sli_metric_em23_wake_init(SLI_INIT_EM3_WAKE);
   1154          #endif
   1155          
   1156          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
   1157            bool errataFixEmuE107En;
   1158            uint32_t nonWicIntEn[2];
   1159          #endif
   1160          
   1161          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
   1162            bool errataFixEmuE110En;
   1163          #endif
   1164          
   1165          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
   1166            if (restore) {
   1167              dpllState(dpllState_Save);
   1168            }
   1169          #endif
   1170          
   1171          #if (_SILICON_LABS_32B_SERIES < 2)
   1172            /* Only save EMU and CMU state if restored on wake-up. */
   1173            if (restore) {
   1174              emState(emState_Save);
   1175            }
   1176          #endif
   1177          
   1178          #if defined(_EMU_CTRL_EM23VSCALE_MASK) && defined(EMU_CTRL_EM23VSCALEAUTOWSEN)
   1179            vScaleDownEM23Setup();
   1180          #endif
   1181          
   1182          #if defined(_CMU_OSCENCMD_MASK)
   1183            uint32_t cmuLocked;
   1184            cmuLocked = CMU->LOCK & CMU_LOCK_LOCKKEY_LOCKED;
   1185            CMU_Unlock();
   1186          
   1187            /* Disable LF oscillators. */
   1188            CMU->OSCENCMD = CMU_OSCENCMD_LFXODIS | CMU_OSCENCMD_LFRCODIS;
   1189          
   1190            /* Restore CMU register locking. */
   1191            if (cmuLocked != 0U) {
   1192              CMU_Lock();
   1193            }
   1194          #endif
   1195          
   1196            /* Enter Cortex deep sleep mode. */
   1197            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   1198          
   1199            /* Fix for errata EMU_E107 - store non-WIC interrupt enable flags.
   1200               Disable the enabled non-WIC interrupts. */
   1201          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
   1202            errataFixEmuE107En = getErrataFixEmuE107En();
   1203            if (errataFixEmuE107En) {
   1204              nonWicIntEn[0] = NVIC->ISER[0] & NON_WIC_INT_MASK_0;
   1205              NVIC->ICER[0] = nonWicIntEn[0];
   1206          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
   1207              nonWicIntEn[1] = NVIC->ISER[1] & NON_WIC_INT_MASK_1;
   1208              NVIC->ICER[1] = nonWicIntEn[1];
   1209          #endif
   1210            }
   1211          #endif
   1212          
   1213          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
   1214            dcdcFetCntSet(true);
   1215          #endif
   1216          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
   1217            dcdcHsFixLnBlock();
   1218          #endif
   1219          
   1220          #if defined(_GPIO_IF_EM4WU_MASK)
   1221            // Clear all EM4WU interrupts before entering sleep
   1222            GPIO_IntClear(_GPIO_IF_EM4WU_MASK);
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable18_4
   \        0xE   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x12   0x6002             STR      R2,[R0, #+0]
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \       0x18   0x6001             STR      R1,[R0, #+0]
   1223          #endif
   1224          
   1225            EMU_EM23PresleepHook();
   \       0x1A   0x.... 0x....      BL       EMU_EM23PresleepHook
   1226          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_205) \
   1227            || defined(ERRATA_FIX_EMU_E110_ENABLE)
   1228          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
   1229            errataFixEmuE110En = getErrataFixEmuE110En();
   1230            if (errataFixEmuE110En) {
   1231          #endif
   1232            CORE_CRITICAL_SECTION(ramWFI(); )
   1233          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
   1234          } else {
   1235            __WFI();
   1236          }
   1237          #endif
   1238          #elif defined(ERRATA_FIX_EMU_E220_DECBOD_ENABLE)
   1239            // Apply errata fix if voltage scaling in EM2 is used.
   1240            if ((EMU->CTRL & EMU_CTRL_EM23VSCALEAUTOWSEN) != 0U) {
   1241              CORE_CRITICAL_SECTION(ramWFI(); )
   1242            } else {
   1243              __WFI();
   1244            }
   1245          #else
   1246            __WFI();
   \       0x1E   0xBF30             WFI
   1247          #endif
   1248            EMU_EM23PostsleepHook();
   \       0x20   0x.... 0x....      BL       EMU_EM23PostsleepHook
   1249          
   1250          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
   1251            dcdcFetCntSet(false);
   1252          #endif
   1253          
   1254            /* Fix for errata EMU_E107 - restore state of non-WIC interrupt enable flags. */
   1255          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
   1256            if (errataFixEmuE107En) {
   1257              NVIC->ISER[0] = nonWicIntEn[0];
   1258          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
   1259              NVIC->ISER[1] = nonWicIntEn[1];
   1260          #endif
   1261            }
   1262          #endif
   1263          
   1264          #if (_SILICON_LABS_32B_SERIES < 2)
   1265            /* Restore oscillators/clocks and voltage scaling if supported. */
   1266            if (restore) {
   1267              emState(emState_Restore);
   1268            }
   1269          #if defined(_EMU_CTRL_EM23VSCALE_MASK) && defined(EMU_CTRL_EM23VSCALEAUTOWSEN)
   1270            else {
   1271              vScaleAfterWakeup();
   1272            }
   1273          #if defined(ERRATA_FIX_EMU_E220_DECBOD_ENABLE)
   1274            /* Third part of EMU_E220 DECBOD Errata fix. Calibration needs to be enabled
   1275             * after voltage scaling completes. */
   1276            EMU_PORBOD &= ~(EMU_PORBOD_GMC_CALIB_DISABLE);
   1277          #endif
   1278          #endif
   1279          #endif
   1280          
   1281          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
   1282            if (restore) {
   1283              dpllState(dpllState_Restore);
   1284            }
   1285          #endif
   1286          
   1287            if (!restore) {
   \       0x24   0xB904             CBNZ.N   R4,??EMU_EnterEM3_0
   1288              /* If not restoring, and the original clock was not HFRCO, the CMSIS */
   1289              /* core clock variable must be updated since HF clock has changed */
   1290              /* to HFRCO. */
   1291              SystemCoreClockUpdate();
   \       0x26   0x....             B.N      ?Subroutine2
   1292            }
   1293          }
   \                     ??EMU_EnterEM3_0: (+1)
   \       0x28   0xBD10             POP      {R4,PC}
   1294          
   1295          /***************************************************************************//**
   1296           * @brief
   1297           *   Save the CMU HF clock select state, oscillator enable, and voltage scaling
   1298           *   (if available) before @ref EMU_EnterEM2() or @ref EMU_EnterEM3() are called
   1299           *   with the restore parameter set to false. Calling this function is
   1300           *   equivalent to calling @ref EMU_EnterEM2() or @ref EMU_EnterEM3() with the
   1301           *   restore parameter set to true, but it allows the state to be saved without
   1302           *   going to sleep. The state can be restored manually by calling
   1303           *   @ref EMU_Restore().
   1304           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1305          void EMU_Save(void)
   1306          {
   1307          #if (_SILICON_LABS_32B_SERIES < 2)
   1308            emState(emState_Save);
   1309          #endif
   1310          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
   1311            dpllState(dpllState_Save);
   1312          #endif
   1313          }
   \                     EMU_Save: (+1)
   \        0x0   0x4770             BX       LR
   1314          
   1315          /***************************************************************************//**
   1316           * @brief
   1317           *   Restore CMU HF clock select state, oscillator enable, and voltage scaling
   1318           *   (if available) after @ref EMU_EnterEM2() or @ref EMU_EnterEM3() are called
   1319           *   with the restore parameter set to false. Calling this function is
   1320           *   equivalent to calling @ref EMU_EnterEM2() or @ref EMU_EnterEM3() with the
   1321           *   restore parameter set to true, but it allows the application to evaluate the
   1322           *   wakeup reason before restoring state.
   1323           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1324          void EMU_Restore(void)
   1325          {
   1326          #if (_SILICON_LABS_32B_SERIES < 2)
   1327            emState(emState_Restore);
   1328          #endif
   1329          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
   1330            dpllState(dpllState_Restore);
   1331          #endif
   1332          }
   \                     EMU_Restore: (+1)
   \        0x0   0x4770             BX       LR
   1333          
   1334          #if defined(_EMU_EM4CONF_MASK) || defined(_EMU_EM4CTRL_MASK)
   1335          /***************************************************************************//**
   1336           * @brief
   1337           *   Update the EMU module with Energy Mode 4 configuration.
   1338           *
   1339           * @param[in] em4Init
   1340           *    Energy Mode 4 configuration structure.
   1341           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1342          void EMU_EM4Init(const EMU_EM4Init_TypeDef *em4Init)
   1343          {
   1344          #if defined(_EMU_EM4CONF_MASK)
   1345            /* Initialization for platforms with EMU->EM4CONF register. */
   1346            uint32_t em4conf = EMU->EM4CONF;
   1347          
   1348            /* Clear fields that will be reconfigured. */
   1349            em4conf &= ~(_EMU_EM4CONF_LOCKCONF_MASK
   1350                         | _EMU_EM4CONF_OSC_MASK
   1351                         | _EMU_EM4CONF_BURTCWU_MASK
   1352                         | _EMU_EM4CONF_VREGEN_MASK
   1353                         | _EMU_EM4CONF_BUBODRSTDIS_MASK);
   1354          
   1355            /* Configure new settings. */
   1356            em4conf |= (em4Init->lockConfig << _EMU_EM4CONF_LOCKCONF_SHIFT)
   1357                       | (em4Init->osc)
   1358                       | (em4Init->buRtcWakeup << _EMU_EM4CONF_BURTCWU_SHIFT)
   1359                       | (em4Init->vreg << _EMU_EM4CONF_VREGEN_SHIFT)
   1360                       | (em4Init->buBodRstDis << _EMU_EM4CONF_BUBODRSTDIS_SHIFT);
   1361          
   1362            /* Apply configuration. Note that lock can be set after this stage. */
   1363            EMU->EM4CONF = em4conf;
   1364          
   1365          #elif defined(_EMU_EM4CTRL_EM4STATE_MASK)
   1366            /* Initialization for platforms with EMU->EM4CTRL register and EM4H and EM4S. */
   1367          
   1368            uint32_t em4ctrl = EMU->EM4CTRL;
   1369          
   1370            em4ctrl &= ~(_EMU_EM4CTRL_RETAINLFXO_MASK
   1371                         | _EMU_EM4CTRL_RETAINLFRCO_MASK
   1372                         | _EMU_EM4CTRL_RETAINULFRCO_MASK
   1373                         | _EMU_EM4CTRL_EM4STATE_MASK
   1374                         | _EMU_EM4CTRL_EM4IORETMODE_MASK);
   1375          
   1376            em4ctrl |= (em4Init->retainLfxo     ? EMU_EM4CTRL_RETAINLFXO : 0U)
   1377                       | (em4Init->retainLfrco  ? EMU_EM4CTRL_RETAINLFRCO : 0U)
   1378                       | (em4Init->retainUlfrco ? EMU_EM4CTRL_RETAINULFRCO : 0U)
   1379                       | (em4Init->em4State == emuEM4Hibernate
   1380                          ? EMU_EM4CTRL_EM4STATE_EM4H : 0U)
   1381                       | ((uint32_t)em4Init->pinRetentionMode);
   1382          
   1383            EMU->EM4CTRL = em4ctrl;
   1384          #elif defined(_EMU_EM4CTRL_MASK)
   1385            EMU->EM4CTRL = (EMU->EM4CTRL & ~_EMU_EM4CTRL_EM4IORETMODE_MASK)
   1386                           | (uint32_t)em4Init->pinRetentionMode;
   \                     EMU_EM4Init: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable18_6
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x7900             LDRB     R0,[R0, #+4]
   \        0x8   0xF021 0x0130      BIC      R1,R1,#0x30
   \        0xC   0x4301             ORRS     R1,R0,R1
   \        0xE   0x6011             STR      R1,[R2, #+0]
   1387          #endif
   1388          
   1389          #if defined(_EMU_CTRL_EM4HVSCALE_MASK)
   1390            EMU->CTRL = (EMU->CTRL & ~_EMU_CTRL_EM4HVSCALE_MASK)
   1391                        | ((uint32_t)em4Init->vScaleEM4HVoltage << _EMU_CTRL_EM4HVSCALE_SHIFT);
   1392          #endif
   1393          }
   \       0x10   0x4770             BX       LR
   1394          #endif
   1395          
   1396          /***************************************************************************//**
   1397           * @brief
   1398           *   Energy mode 4 pre-sleep hook function.
   1399           *
   1400           * @details
   1401           *   This function is called by @ref EMU_EnterEM4() just prior to the sequence
   1402           *   of writes to put the device in EM4. The function implementation does not
   1403           *   perform anything, but it is SL_WEAK so that it can be re-implemented in
   1404           *   application code if actions are needed.
   1405           ******************************************************************************/

   \                                 In section .text, align 2
   1406          SL_WEAK void EMU_EM4PresleepHook(void)
   1407          {
   1408          }
   \                     EMU_EM4PresleepHook: (+1)
   \        0x0   0x4770             BX       LR
   1409          
   1410          /***************************************************************************//**
   1411           * @brief
   1412           *   EFP's Energy mode 4 pre-sleep hook function.
   1413           *
   1414           * @details
   1415           *   This function is similar to @ref EMU_EM4PresleepHook() but is reserved for
   1416           *   EFP usage.
   1417           *
   1418           * @note
   1419           *   The function is primarily meant to be used in systems with EFP circuitry.
   1420           *   (EFP = Energy Friendly Pmic (PMIC = Power Management IC)).
   1421           *   In such systems there is a need to drive certain signals to EFP pins to
   1422           *   notify about energy mode transitions.
   1423           ******************************************************************************/

   \                                 In section .text, align 2
   1424          SL_WEAK void EMU_EFPEM4PresleepHook(void)
   1425          {
   1426          }
   \                     EMU_EFPEM4PresleepHook: (+1)
   \        0x0   0x4770             BX       LR
   1427          
   1428          /***************************************************************************//**
   1429           * @brief
   1430           *   Enter energy mode 4 (EM4).
   1431           *
   1432           * @note
   1433           *   Only a power on reset or external reset pin can wake the device from EM4.
   1434           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1435          void EMU_EnterEM4(void)
   1436          {
   \                     EMU_EnterEM4: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1437          #if defined(SL_CATALOG_METRIC_EM4_WAKE_PRESENT)
   1438            sli_metric_em4_wake_init();
   1439          #endif
   1440            int i;
   1441          
   1442          #if defined(_EMU_EM4CTRL_EM4ENTRY_SHIFT)
   1443            uint32_t em4seq2 = (EMU->EM4CTRL & ~_EMU_EM4CTRL_EM4ENTRY_MASK)
   1444                               | (2U << _EMU_EM4CTRL_EM4ENTRY_SHIFT);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable18_7
   \        0x6   0x68E5             LDR      R5,[R4, #+12]
   \        0x8   0x2002             MOVS     R0,#+2
   1445            uint32_t em4seq3 = (EMU->EM4CTRL & ~_EMU_EM4CTRL_EM4ENTRY_MASK)
   1446                               | (3U << _EMU_EM4CTRL_EM4ENTRY_SHIFT);
   \        0xA   0x68E6             LDR      R6,[R4, #+12]
   \        0xC   0xF360 0x0501      BFI      R5,R0,#+0,#+2
   1447          #else
   1448            uint32_t em4seq2 = (EMU->CTRL & ~_EMU_CTRL_EM4CTRL_MASK)
   1449                               | (2U << _EMU_CTRL_EM4CTRL_SHIFT);
   1450            uint32_t em4seq3 = (EMU->CTRL & ~_EMU_CTRL_EM4CTRL_MASK)
   1451                               | (3U << _EMU_CTRL_EM4CTRL_SHIFT);
   1452          #endif
   1453          
   1454            /* Make sure that the register write lock is disabled. */
   1455            EMU_Unlock();
   \       0x10   0xF64A 0x50E8      MOVW     R0,#+44520
   \       0x14   0x6020             STR      R0,[R4, #+0]
   1456          
   1457          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   1458            /* The DCDC is not supported in EM4S. EFM32xG1 and EFR32xG1 devices should
   1459             * switch to bypass mode before entering EM4S. Other devices handle this
   1460             * automatically at the hardware level. */
   1461            if ((EMU->EM4CTRL & _EMU_EM4CTRL_EM4STATE_MASK) == EMU_EM4CTRL_EM4STATE_EM4S) {
   1462              uint32_t dcdcMode = EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK;
   1463              if (dcdcMode == EMU_DCDCCTRL_DCDCMODE_LOWNOISE
   1464                  || dcdcMode == EMU_DCDCCTRL_DCDCMODE_LOWPOWER) {
   1465                EMU_DCDCModeSet(emuDcdcMode_Bypass);
   1466              }
   1467            }
   1468          #endif
   1469          
   1470          #if defined(_DCDC_IF_EM4ERR_MASK)
   1471            /* Make sure DCDC Mode is not modified, from this point forward,
   1472             * by another code section. */
   1473            CORE_DECLARE_IRQ_STATE;
   1474            CORE_ENTER_CRITICAL();
   \       0x16   0x.... 0x....      BL       CORE_EnterCritical
   \       0x1A   0x4607             MOV      R7,R0
   1475          
   1476            /* Workaround for bug that may cause a Hard Fault on EM4 entry */
   1477            CMU_CLOCK_SELECT_SET(SYSCLK, FSRCO);
   \       0x1C   0x.... 0x....      BL       sli_em_cmu_SYSCLKInitPreClockSelect
   \       0x20   0x.... 0x....      LDR.W    R2,??DataTable18_8
   \       0x24   0x6811             LDR      R1,[R2, #+0]
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xF046 0x0603      ORR      R6,R6,#0x3
   \       0x2C   0xF360 0x0102      BFI      R1,R0,#+0,#+3
   \       0x30   0x6011             STR      R1,[R2, #+0]
   \       0x32   0x.... 0x....      BL       sli_em_cmu_SYSCLKInitPostClockSelect
   1478            /* The buck DC-DC is available in all energy modes except for EM4.
   1479             * The DC-DC converter must first be turned off and switched over to bypass mode. */
   1480          #if defined(EMU_SERIES1_DCDC_BUCK_PRESENT)   \
   1481            || (defined(EMU_SERIES2_DCDC_BUCK_PRESENT) \
   1482            || defined(EMU_SERIES2_DCDC_BOOST_PRESENT))
   1483            EMU_DCDCModeSet(emuDcdcMode_Bypass);
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x.... 0x....      BL       EMU_DCDCModeSet
   1484          #endif
   1485          #endif
   1486          
   1487          #if defined(_EMU_EM4CTRL_MASK) && defined(ERRATA_FIX_EMU_E208_ENABLE)
   1488            if (EMU->EM4CTRL & EMU_EM4CTRL_EM4STATE_EM4H) {
   1489              /* Fix for errata EMU_E208 - Occasional Full Reset After Exiting EM4H.
   1490               * Full description of errata fix can be found in the errata document. */
   1491              __disable_irq();
   1492              *(volatile uint32_t *)(EMU_BASE + 0x190UL)  = 0x0000ADE8UL;
   1493              *(volatile uint32_t *)(EMU_BASE + 0x198UL) |= (0x1UL << 7);
   1494              *(volatile uint32_t *)(EMU_BASE + 0x88UL)  |= (0x1UL << 8);
   1495            }
   1496          #endif
   1497          
   1498          #if defined(ERRATA_FIX_EMU_E108_ENABLE)
   1499            /* Fix for errata EMU_E108 - High Current Consumption on EM4 Entry. */
   1500            __disable_irq();
   1501            *(volatile uint32_t *)0x400C80E4 = 0;
   1502          #endif
   1503          
   1504          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
   1505            dcdcFetCntSet(true);
   1506          #endif
   1507          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
   1508            dcdcHsFixLnBlock();
   1509          #endif
   1510          
   1511          #if defined(ERRATA_FIX_EM4S_DELAY_ENTRY)
   1512            /* Fix for errata where firmware must clear ANASW and delay EM4S entry by 30 us. */
   1513            if ((EMU->EM4CTRL & _EMU_EM4CTRL_EM4STATE_MASK) == EMU_EM4CTRL_EM4STATE_EM4S) {
   1514              if ((EMU->PWRCTRL & _EMU_PWRCTRL_ANASW_MASK) == EMU_PWRCTRL_ANASW_DVDD) {
   1515                BUS_RegMaskedClear(&EMU->PWRCTRL, _EMU_PWRCTRL_ANASW_MASK);
   1516                /* Switch to 1 MHz HFRCO. This delays enough to meet the 30 us requirement
   1517                 * before entering EM4. */
   1518                uint32_t freqCal = (DEVINFO->HFRCOCAL0 & ~_CMU_HFRCOCTRL_CLKDIV_MASK)
   1519                                   | CMU_HFRCOCTRL_CLKDIV_DIV4;
   1520                while ((CMU->SYNCBUSY & CMU_SYNCBUSY_HFRCOBSY) != 0UL) {
   1521                }
   1522                CMU->HFRCOCTRL = freqCal;
   1523                CMU->OSCENCMD = CMU_OSCENCMD_HFRCOEN;
   1524                while ((CMU->STATUS & CMU_STATUS_HFRCORDY) == 0U) {
   1525                }
   1526                CMU->HFCLKSEL = CMU_HFCLKSEL_HF_HFRCO;
   1527                __NOP();
   1528              }
   1529            }
   1530          #endif
   1531          
   1532            EMU_EM4PresleepHook();
   \       0x3C   0x.... 0x....      BL       EMU_EM4PresleepHook
   1533            EMU_EFPEM4PresleepHook();
   \       0x40   0x.... 0x....      BL       EMU_EFPEM4PresleepHook
   1534          
   1535          #if defined(_GPIO_IF_EM4WU_MASK)
   1536            // Clear all EM4WU interrupts before entering sleep
   1537            GPIO_IntClear(_GPIO_IF_EM4WU_MASK);
   \       0x44   0x.... 0x....      BL       ?Subroutine4
   1538          #endif
   1539          
   1540            for (i = 0; i < 4; i++) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x48   0x2004             MOVS     R0,#+4
   1541          #if defined(_EMU_EM4CTRL_EM4ENTRY_SHIFT)
   1542              EMU->EM4CTRL = em4seq2;
   \                     ??EMU_EnterEM4_0: (+1)
   \       0x4A   0x60E5             STR      R5,[R4, #+12]
   1543              EMU->EM4CTRL = em4seq3;
   \       0x4C   0x60E6             STR      R6,[R4, #+12]
   1544            }
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0xD1FB             BNE.N    ??EMU_EnterEM4_0
   1545            EMU->EM4CTRL = em4seq2;
   \       0x52   0x60E5             STR      R5,[R4, #+12]
   1546          #else
   1547              EMU->CTRL = em4seq2;
   1548              EMU->CTRL = em4seq3;
   1549            }
   1550            EMU->CTRL = em4seq2;
   1551          #endif
   1552          
   1553          #if defined(_DCDC_IF_EM4ERR_MASK)
   1554            EFM_ASSERT((DCDC->IF & _DCDC_IF_EM4ERR_MASK) == 0);
   \       0x54   0x.... 0x....      LDR.W    R2,??DataTable18_9
   \       0x58   0x6811             LDR      R1,[R2, #+0]
   \       0x5A   0x0608             LSLS     R0,R1,#+24
   \       0x5C   0xD505             BPL.N    ??EMU_EnterEM4_1
   \       0x5E   0xF240 0x6112      MOVW     R1,#+1554
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable18_10
   \       0x66   0x.... 0x....      BL       assertEFM
   1555            CORE_EXIT_CRITICAL();
   \                     ??EMU_EnterEM4_1: (+1)
   \       0x6A   0x4638             MOV      R0,R7
   \       0x6C   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x70   0x.... 0x....      B.W      CORE_ExitCritical
   1556          #endif
   1557          }
   1558          
   1559          /***************************************************************************//**
   1560           * @brief
   1561           *   Enter energy mode 4 (EM4).
   1562           *
   1563           * @details
   1564           *   This function waits after the EM4 entry request to make sure the CPU
   1565           *   is properly shutdown or the EM4 entry failed.
   1566           *
   1567           * @note
   1568           *   Only a power on reset or external reset pin can wake the device from EM4.
   1569           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1570          void EMU_EnterEM4Wait(void)
   1571          {
   \                     EMU_EnterEM4Wait: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1572            EMU_EnterEM4();
   \        0x2   0x.... 0x....      BL       EMU_EnterEM4
   1573          
   1574            // The EM4 entry waiting loop should take 4 cycles by loop minimally (Compiler dependent).
   1575            // We would then wait for (EMU_EM4_ENTRY_WAIT_LOOPS * 4) clock cycles.
   1576            for (uint16_t i = 0; i < EMU_EM4_ENTRY_WAIT_LOOPS; i++) {
   \        0x6   0x20C8             MOVS     R0,#+200
   1577              __NOP();
   \                     ??EMU_EnterEM4Wait_0: (+1)
   \        0x8   0xBF00             Nop
   1578            }
   \        0xA   0x1E40             SUBS     R0,R0,#+1
   \        0xC   0xD1FC             BNE.N    ??EMU_EnterEM4Wait_0
   1579          }
   \        0xE   0xBD01             POP      {R0,PC}
   1580          
   1581          #if defined(_EMU_EM4CTRL_MASK)
   1582          /***************************************************************************//**
   1583           * @brief
   1584           *   Enter energy mode 4 hibernate (EM4H).
   1585           *
   1586           * @note
   1587           *   Retention of clocks and GPIO in EM4 can be configured using
   1588           *   @ref EMU_EM4Init before calling this function.
   1589           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1590          void EMU_EnterEM4H(void)
   1591          {
   1592          #if defined(_EMU_EM4CTRL_EM4STATE_MASK)
   1593            BUS_RegBitWrite(&EMU->EM4CTRL, _EMU_EM4CTRL_EM4STATE_SHIFT, 1);
   1594          #endif
   1595            EMU_EnterEM4();
   \                     EMU_EnterEM4H: (+1)
   \        0x0   0x....             B.N      EMU_EnterEM4
   1596          }
   1597          
   1598          /***************************************************************************//**
   1599           * @brief
   1600           *   Enter energy mode 4 shutoff (EM4S).
   1601           *
   1602           * @note
   1603           *   Retention of clocks and GPIO in EM4 can be configured using
   1604           *   @ref EMU_EM4Init before calling this function.
   1605           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1606          void EMU_EnterEM4S(void)
   1607          {
   1608          #if defined(_EMU_EM4CTRL_EM4STATE_MASK)
   1609            BUS_RegBitWrite(&EMU->EM4CTRL, _EMU_EM4CTRL_EM4STATE_SHIFT, 0);
   1610          #endif
   1611            EMU_EnterEM4();
   \                     EMU_EnterEM4S: (+1)
   \        0x0   0x....             B.N      EMU_EnterEM4
   1612          }
   1613          #endif
   1614          
   1615          /***************************************************************************//**
   1616           * @brief
   1617           *   Power down memory block.
   1618           *
   1619           * @param[in] blocks
   1620           *   Specifies a logical OR of bits indicating memory blocks to power down.
   1621           *   Bit 0 selects block 1, bit 1 selects block 2, and so on. Memory block 0 cannot
   1622           *   be disabled. See the reference manual for available
   1623           *   memory blocks for a device.
   1624           *
   1625           * @note
   1626           *   Only a POR reset can power up the specified memory block(s) after power down.
   1627           *
   1628           * @deprecated
   1629           *   This function is deprecated, use @ref EMU_RamPowerDown() instead which
   1630           *   maps a user provided memory range into RAM blocks to power down.
   1631           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1632          void EMU_MemPwrDown(uint32_t blocks)
   1633          {
   1634          #if defined(_EMU_MEMCTRL_MASK)
   1635            EMU->MEMCTRL = blocks & _EMU_MEMCTRL_MASK;
   1636          #elif defined(_EMU_RAM0CTRL_MASK)
   1637            EMU->RAM0CTRL = blocks & _EMU_RAM0CTRL_MASK;
   1638          #else
   1639            (void)blocks;
   1640          #endif
   1641          }
   \                     EMU_MemPwrDown: (+1)
   \        0x0   0x4770             BX       LR
   1642          
   1643          /***************************************************************************//**
   1644           * @brief
   1645           *   Power down RAM memory blocks.
   1646           *
   1647           * @details
   1648           *   This function will power down all the RAM blocks that are within a given
   1649           *   range. The RAM block layout is different between device families, so this
   1650           *   function can be used in a generic way to power down a RAM memory region
   1651           *   which is known to be unused.
   1652           *
   1653           *   This function will only power down blocks which are completely enclosed
   1654           *   by the memory range given by [start, end).
   1655           *
   1656           *   This is an example to power down all RAM blocks except the first
   1657           *   one. The first RAM block is special in that it cannot be powered down
   1658           *   by the hardware. The size of the first RAM block is device-specific.
   1659           *   See the reference manual to find the RAM block sizes.
   1660           *
   1661           * @code
   1662           *   EMU_RamPowerDown(SRAM_BASE, SRAM_BASE + SRAM_SIZE);
   1663           * @endcode
   1664           *
   1665           * @note
   1666           *   Only a reset can power up the specified memory block(s) after power down
   1667           *   on a series 0 device. The specified memory block(s) will stay off
   1668           *   until a call to EMU_RamPowerUp() is done on series 1/2.
   1669           *
   1670           * @param[in] start
   1671           *   The start address of the RAM region to power down. This address is
   1672           *   inclusive.
   1673           *
   1674           * @param[in] end
   1675           *   The end address of the RAM region to power down. This address is
   1676           *   exclusive. If this parameter is 0, all RAM blocks contained in the
   1677           *   region from start to the upper RAM address will be powered down.
   1678           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1679          void EMU_RamPowerDown(uint32_t start, uint32_t end)
   1680          {
   \                     EMU_RamPowerDown: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1681            uint32_t mask = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   1682            (void) start;
   1683          
   1684            if (end == 0U) {
   \        0x4   0xB119             CBZ.N    R1,??EMU_RamPowerDown_0
   1685              end = SRAM_BASE + SRAM_SIZE;
   1686            }
   1687          
   1688            // Check to see if something in RAM0 can be powered down.
   1689            if (end > RAM0_END) {
   \        0x6   0x.... 0x....      LDR.W    R3,??DataTable18_11
   \        0xA   0x4299             CMP      R1,R3
   \        0xC   0xD30B             BCC.N    ??EMU_RamPowerDown_1
   1690          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_84) // EFM32xG12 and EFR32xG12
   1691              // Block 0 is 16 kB and cannot be powered off.
   1692              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20004000UL) << 0; // Block 1, 16 kB
   1693              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20008000UL) << 1; // Block 2, 16 kB
   1694              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x2000C000UL) << 2; // Block 3, 16 kB
   1695              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20010000UL) << 3; // Block 4, 64 kB
   1696          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80) // EFM32xG1 and EFR32xG1
   1697              // Block 0 is 4 kB and cannot be powered off.
   1698              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20001000UL) << 0; // Block 1, 4 kB
   1699              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20002000UL) << 1; // Block 2, 8 kB
   1700              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20004000UL) << 2; // Block 3, 8 kB
   1701              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20006000UL) << 3; // Block 4, 7 kB
   1702          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1703              // Lynx has 2 blocks. We do no shut off block 0 because we dont want to disable all RAM0
   1704              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20006000UL) << 1; // Block 1, 8 kB
   1705          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_7)
   1706              // Leopard has 3 blocks. We do no shut off block 0 because we dont want to disable all RAM0
   1707              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20006000UL) << 1; // Block 1, 8 kB
   1708              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20008000UL) << 2; // Block 2, 32 kB
   1709          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_8)
   1710              // These platforms have equally-sized RAM blocks and block 0 can be powered down but should not.
   1711              // This condition happens when the block 0 disable bit flag is available in the retention control register.
   1712              for (unsigned i = 1; i < RAM0_BLOCKS; i++) {
   \                     ??EMU_RamPowerDown_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   1713                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM_MEM_BASE + (i * RAM0_BLOCK_SIZE)) << (i);
   \                     ??EMU_RamPowerDown_2: (+1)
   \       0x10   0x038C             LSLS     R4,R1,#+14
   \       0x12   0xF104 0x5400      ADD      R4,R4,#+536870912
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xD302             BCC.N    ??EMU_RamPowerDown_3
   \       0x1A   0x2301             MOVS     R3,#+1
   \       0x1C   0x408B             LSLS     R3,R3,R1
   \       0x1E   0x431A             ORRS     R2,R3,R2
   1714              }
   \                     ??EMU_RamPowerDown_3: (+1)
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x2910             CMP      R1,#+16
   \       0x24   0xD3F4             BCC.N    ??EMU_RamPowerDown_2
   1715          #elif defined(RAM0_BLOCKS)
   1716              // These platforms have equally-sized RAM blocks and block 0 cannot be powered down.
   1717              for (unsigned i = 1; i < RAM0_BLOCKS; i++) {
   1718                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM_MEM_BASE + (i * RAM0_BLOCK_SIZE)) << (i - 1U);
   1719              }
   1720          #endif
   1721            }
   1722          
   1723            // Power down the selected blocks.
   1724          #if defined(_EMU_MEMCTRL_MASK)
   1725            EMU->MEMCTRL = EMU->MEMCTRL   | mask;
   1726          #elif defined(_EMU_RAM0CTRL_MASK)
   1727            EMU->RAM0CTRL = EMU->RAM0CTRL | mask;
   1728          #elif defined(_SILICON_LABS_32B_SERIES_2)
   1729          #if defined(CMU_CLKEN0_SYSCFG)
   1730            CMU->CLKEN0_SET = CMU_CLKEN0_SYSCFG;
   \                     ??EMU_RamPowerDown_1: (+1)
   \       0x26   0xF44F 0x3180      MOV      R1,#+65536
   \       0x2A   0x....             LDR.N    R0,??DataTable18_12
   \       0x2C   0x6001             STR      R1,[R0, #+0]
   1731          #endif
   1732            SYSCFG_maskDmem0RetnCtrl(mask);
   \       0x2E   0x....             LDR.N    R0,??DataTable18_13
   \       0x30   0x6803             LDR      R3,[R0, #+0]
   \       0x32   0x431A             ORRS     R2,R2,R3
   \       0x34   0x6002             STR      R2,[R0, #+0]
   1733          #else
   1734            // These devices are unable to power down RAM blocks.
   1735            (void) mask;
   1736            (void) start;
   1737          #endif
   1738          
   1739          #if defined(RAM1_MEM_END)
   1740            mask = 0;
   1741            if (end > RAM1_MEM_END) {
   1742              for (unsigned i = 0; i < RAM1_BLOCKS; i++) {
   1743                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM1_MEM_BASE + (i * RAM1_BLOCK_SIZE)) << i;
   1744              }
   1745            }
   1746            EMU->RAM1CTRL |= mask;
   1747          #endif
   1748          
   1749          #if defined(RAM2_MEM_END)
   1750            mask = 0;
   1751            if (end > RAM2_MEM_END) {
   1752              for (unsigned i = 0; i < RAM2_BLOCKS; i++) {
   1753                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM2_MEM_BASE + (i * RAM2_BLOCK_SIZE)) << i;
   1754              }
   1755            }
   1756            EMU->RAM2CTRL |= mask;
   1757          #endif
   1758          }
   \       0x36   0xBD10             POP      {R4,PC}
   1759          
   1760          /***************************************************************************//**
   1761           * @brief
   1762           *   Power up all available RAM memory blocks.
   1763           *
   1764           * @details
   1765           *   This function will power up all the RAM blocks on a device, this means
   1766           *   that the RAM blocks are retained in EM2/EM3. Note that this functionality
   1767           *   is not supported on Series 0 devices. Only a reset will power up the RAM
   1768           *   blocks on a series 0 device.
   1769           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1770          void EMU_RamPowerUp(void)
   1771          {
   1772          #if defined(_EMU_RAM0CTRL_MASK)
   1773            EMU->RAM0CTRL = 0x0UL;
   1774          #endif
   1775          #if defined(_EMU_RAM1CTRL_MASK)
   1776            EMU->RAM1CTRL = 0x0UL;
   1777          #endif
   1778          #if defined(_EMU_RAM2CTRL_MASK)
   1779            EMU->RAM2CTRL = 0x0UL;
   1780          #endif
   1781          #if defined(_SYSCFG_DMEM0RETNCTRL_MASK)
   1782          #if defined(CMU_CLKEN0_SYSCFG)
   1783            CMU->CLKEN0_SET = CMU_CLKEN0_SYSCFG;
   \                     EMU_RamPowerUp: (+1)
   \        0x0   0xF44F 0x3380      MOV      R3,#+65536
   \        0x4   0x....             LDR.N    R2,??DataTable18_12
   \        0x6   0x6013             STR      R3,[R2, #+0]
   1784          #endif
   1785            SYSCFG_zeroDmem0RetnCtrl();
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....             LDR.N    R0,??DataTable18_13
   \        0xC   0x6001             STR      R1,[R0, #+0]
   1786          #endif
   1787          }
   \        0xE   0x4770             BX       LR
   1788          
   1789          #if defined(_EMU_EM23PERNORETAINCTRL_MASK)
   1790          /***************************************************************************//**
   1791           * @brief
   1792           *   Set EM2 3 peripheral retention control.
   1793           *
   1794           * @param[in] periMask
   1795           *  A peripheral select mask. Use | operator to select multiple peripherals, for example
   1796           *  @ref emuPeripheralRetention_LEUART0 | @ref emuPeripheralRetention_VDAC0.
   1797           * @param[in] enable
   1798           *  Peripheral retention enable (true) or disable (false).
   1799           *
   1800           *
   1801           * @note
   1802           *   Only peripheral retention disable is currently supported. Peripherals are
   1803           *   enabled by default and can only be disabled.
   1804           ******************************************************************************/
   1805          void EMU_PeripheralRetention(EMU_PeripheralRetention_TypeDef periMask, bool enable)
   1806          {
   1807            EFM_ASSERT(!enable);
   1808            EMU->EM23PERNORETAINCTRL = (uint32_t)periMask
   1809                                       & (uint32_t)emuPeripheralRetention_ALL;
   1810          }
   1811          #endif
   1812          
   1813          /***************************************************************************//**
   1814           * @brief
   1815           *   Update EMU module with CMU oscillator selection/enable status.
   1816           *
   1817           * @deprecated
   1818           *   Oscillator status is saved in @ref EMU_EnterEM2() and @ref EMU_EnterEM3().
   1819           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1820          void EMU_UpdateOscConfig(void)
   1821          {
   1822          #if (_SILICON_LABS_32B_SERIES < 2)
   1823            emState(emState_Save);
   1824          #endif
   1825          }
   \                     EMU_UpdateOscConfig: (+1)
   \        0x0   0x4770             BX       LR
   1826          
   1827          #if defined(_SILICON_LABS_32B_SERIES_2) && defined(EMU_VSCALE_EM01_PRESENT)
   1828          /***************************************************************************//**
   1829           * @brief
   1830           *   Energy mode 01 voltage scaling hook function.
   1831           *
   1832           * @param[in] voltage
   1833           *   Voltage scaling level requested.
   1834           *
   1835           * @details
   1836           *   This function is called by EMU_VScaleEM01 to let EFP know that voltage scaling
   1837           *   is requested.
   1838           ******************************************************************************/

   \                                 In section .text, align 2
   1839          SL_WEAK void EMU_EFPEM01VScale(EMU_VScaleEM01_TypeDef voltage)
   1840          {
   1841            (void)voltage;
   1842          }
   \                     EMU_EFPEM01VScale: (+1)
   \        0x0   0x4770             BX       LR
   1843          #endif
   1844          
   1845          #if defined(EMU_VSCALE_EM01_PRESENT)
   1846          /***************************************************************************//**
   1847           * @brief
   1848           *   Voltage scale in EM0 and 1 by clock frequency.
   1849           *
   1850           * @param[in] clockFrequency
   1851           *   Use CMSIS HF clock if 0 or override to custom clock. Providing a
   1852           *   custom clock frequency is required if using a non-standard HFXO
   1853           *   frequency.
   1854           * @param[in] wait
   1855           *   Wait for scaling to complete.
   1856           *
   1857           * @note
   1858           *   This function is primarily needed by the @ref cmu.
   1859           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1860          void EMU_VScaleEM01ByClock(uint32_t clockFrequency, bool wait)
   1861          {
   \                     EMU_VScaleEM01ByClock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   1862            uint32_t hfSrcClockFrequency;
   1863          
   1864          #if defined(_SILICON_LABS_32B_SERIES_1)
   1865            if (EMU_LDOStatusGet() == false) {
   1866              /* Skip voltage scaling if the LDO regulator is turned off. */
   1867              return;
   1868            }
   1869          #endif
   1870          
   1871            /* VSCALE frequency is HFSRCCLK. */
   1872            if (clockFrequency == 0U) {
   \        0x4   0xB908             CBNZ.N   R0,??EMU_VScaleEM01ByClock_0
   1873          #if defined(_SILICON_LABS_32B_SERIES_2)
   1874              hfSrcClockFrequency = SystemSYSCLKGet();
   \        0x6   0x.... 0x....      BL       SystemSYSCLKGet
   1875          #else
   1876              uint32_t hfPresc = 1U + ((CMU->HFPRESC & _CMU_HFPRESC_PRESC_MASK)
   1877                                       >> _CMU_HFPRESC_PRESC_SHIFT);
   1878              hfSrcClockFrequency = SystemHFClockGet() * hfPresc;
   1879          #endif
   1880            } else {
   1881              hfSrcClockFrequency = clockFrequency;
   1882            }
   1883          
   1884            /* Apply EM0 and 1 voltage scaling command. */
   1885            if (vScaleEM01Config.vScaleEM01LowPowerVoltageEnable
   1886                && (hfSrcClockFrequency <= CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX)) {
   \                     ??EMU_VScaleEM01ByClock_0: (+1)
   \        0xA   0x....             LDR.N    R2,??DataTable18_1
   \        0xC   0x7811             LDRB     R1,[R2, #+0]
   \        0xE   0xB129             CBZ.N    R1,??EMU_VScaleEM01ByClock_1
   \       0x10   0x....             LDR.N    R2,??DataTable18_14
   \       0x12   0x4290             CMP      R0,R2
   \       0x14   0xD202             BCS.N    ??EMU_VScaleEM01ByClock_1
   1887              EMU_VScaleEM01(emuVScaleEM01_LowPower, wait);
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE001             B.N      ??EMU_VScaleEM01ByClock_2
   1888            } else {
   1889              EMU_VScaleEM01(emuVScaleEM01_HighPerformance, wait);
   \                     ??EMU_VScaleEM01ByClock_1: (+1)
   \       0x1C   0x4621             MOV      R1,R4
   \       0x1E   0x2002             MOVS     R0,#+2
   \                     ??EMU_VScaleEM01ByClock_2: (+1)
   \       0x20   0xE8BD 0x4010      POP      {R4,LR}
   \       0x24                      REQUIRE EMU_VScaleEM01
   \       0x24                      ;; // Fall through to label EMU_VScaleEM01
   1890            }
   1891          }
   1892          #endif
   1893          
   1894          #if defined(EMU_VSCALE_EM01_PRESENT)
   1895          /***************************************************************************//**
   1896           * @brief
   1897           *   Force voltage scaling in EM0 and 1 to a specific voltage level.
   1898           *
   1899           * @param[in] voltage
   1900           *   Target VSCALE voltage level.
   1901           * @param[in] wait
   1902           *   Wait for scaling to complete.
   1903           *
   1904           * @note
   1905           *   This function is useful for upscaling before programming Flash from @ref msc
   1906           *   and downscaling after programming is done. Flash programming is only supported
   1907           *   at @ref emuVScaleEM01_HighPerformance.
   1908           *
   1909           * @note
   1910           *  This function ignores vScaleEM01LowPowerVoltageEnable set from @ref
   1911           *  EMU_EM01Init().
   1912           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1913          void EMU_VScaleEM01(EMU_VScaleEM01_TypeDef voltage, bool wait)
   1914          {
   \                     EMU_VScaleEM01: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x....             LDR.N    R4,??DataTable18_15
   1915            uint32_t hfFreq;
   1916            uint32_t hfSrcClockFrequency;
   1917          
   1918          #if defined(_SILICON_LABS_32B_SERIES_1)
   1919            if (EMU_LDOStatusGet() == false) {
   1920              /* Skip voltage scaling if the LDO regulator is turned off. */
   1921              return;
   1922            }
   1923          #endif
   1924          
   1925            if (EMU_VScaleGet() == voltage) {
   \                     ??EMU_VScaleEM01_0: (+1)
   \        0x8   0x6A20             LDR      R0,[R4, #+32]
   \        0xA   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD1FA             BNE.N    ??EMU_VScaleEM01_0
   \       0x12   0x6A20             LDR      R0,[R4, #+32]
   \       0x14   0xF3C0 0x1181      UBFX     R1,R0,#+6,#+2
   \       0x18   0x42A9             CMP      R1,R5
   \       0x1A   0xD03A             BEQ.N    ??EMU_VScaleEM01_1
   1926              /* Voltage is already at the correct level. */
   1927              return;
   1928            }
   1929          
   1930          #if defined(_SILICON_LABS_32B_SERIES_2)
   1931            (void)wait;
   1932            CORE_DECLARE_IRQ_STATE;
   1933          
   1934            hfFreq = SystemSYSCLKGet();
   \       0x1C   0x.... 0x....      BL       SystemSYSCLKGet
   \       0x20   0x4606             MOV      R6,R0
   1935            hfSrcClockFrequency = hfFreq;
   1936          
   1937            if (voltage == emuVScaleEM01_LowPower) {
   \       0x22   0x....             LDR.N    R7,??DataTable18_10
   \       0x24   0x2D01             CMP      R5,#+1
   \       0x26   0xD10B             BNE.N    ??EMU_VScaleEM01_2
   1938              EFM_ASSERT(hfSrcClockFrequency <= CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX);
   \       0x28   0x....             LDR.N    R0,??DataTable18_14
   \       0x2A   0x4286             CMP      R6,R0
   \       0x2C   0xD304             BCC.N    ??EMU_VScaleEM01_3
   \       0x2E   0xF240 0x7192      MOVW     R1,#+1938
   \       0x32   0x4638             MOV      R0,R7
   \       0x34   0x.... 0x....      BL       assertEFM
   1939              /* Update wait states before scaling down voltage. */
   1940              CMU_UpdateWaitStates(hfFreq, VSCALE_EM01_LOW_POWER);
   \                     ??EMU_VScaleEM01_3: (+1)
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0x.... 0x....      BL       CMU_UpdateWaitStates
   1941            }
   1942          
   1943            CORE_ENTER_CRITICAL();
   \                     ??EMU_VScaleEM01_2: (+1)
   \       0x40   0x.... 0x....      BL       CORE_EnterCritical
   \       0x44   0x4680             MOV      R8,R0
   1944            EMU->IF_CLR = EMU_IF_VSCALEDONE;
   \       0x46   0xF04F 0x7100      MOV      R1,#+33554432
   \       0x4A   0x....             LDR.N    R0,??DataTable18_16
   \       0x4C   0x6001             STR      R1,[R0, #+0]
   1945            EMU_EFPEM01VScale(voltage);
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x.... 0x....      BL       EMU_EFPEM01VScale
   1946            EMU->CMD = vScaleEM01Cmd(voltage);
   \       0x54   0xF44F 0x6180      MOV      R1,#+1024
   \       0x58   0x1E68             SUBS     R0,R5,#+1
   \       0x5A   0x4081             LSLS     R1,R1,R0
   \       0x5C   0x60E1             STR      R1,[R4, #+12]
   \       0x5E   0xE007             B.N      ??EMU_VScaleEM01_4
   1947          
   1948            // Note that VSCALEDONE interrupt flag must be used instead of VSCALEBUSY
   1949            // because hardware does not set the VSCALEBUSY flag immediately.
   1950            while (((EMU->IF & EMU_IF_VSCALEDONE) == 0U)
   1951                   && ((EMU->STATUS & EMU_STATUS_VSCALEFAILED) == 0U)) {
   1952              EFM_ASSERT((EMU->STATUS & EMU_STATUS_VSCALEFAILED) == 0U);
   \                     ??EMU_VScaleEM01_5: (+1)
   \       0x60   0x6A21             LDR      R1,[R4, #+32]
   \       0x62   0x0688             LSLS     R0,R1,#+26
   \       0x64   0xD504             BPL.N    ??EMU_VScaleEM01_4
   \       0x66   0xF44F 0x61F4      MOV      R1,#+1952
   \       0x6A   0x4638             MOV      R0,R7
   \       0x6C   0x.... 0x....      BL       assertEFM
   1953              // Wait for VSCALE completion.
   1954              // SRAM accesses will fault the core while scaling.
   1955            }
   \                     ??EMU_VScaleEM01_4: (+1)
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x0188             LSLS     R0,R1,#+6
   \       0x74   0xD402             BMI.N    ??EMU_VScaleEM01_6
   \       0x76   0x6A21             LDR      R1,[R4, #+32]
   \       0x78   0x0688             LSLS     R0,R1,#+26
   \       0x7A   0xD5F1             BPL.N    ??EMU_VScaleEM01_5
   1956            CORE_EXIT_CRITICAL();
   \                     ??EMU_VScaleEM01_6: (+1)
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0x.... 0x....      BL       CORE_ExitCritical
   1957          
   1958          #else
   1959            uint32_t hfPresc = 1U + ((CMU->HFPRESC & _CMU_HFPRESC_PRESC_MASK)
   1960                                     >> _CMU_HFPRESC_PRESC_SHIFT);
   1961            hfFreq = SystemHFClockGet();
   1962            hfSrcClockFrequency = hfFreq * hfPresc;
   1963          
   1964            if (voltage == emuVScaleEM01_LowPower) {
   1965              EFM_ASSERT(hfSrcClockFrequency <= CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX);
   1966              /* Update wait states before scaling down voltage. */
   1967              CMU_UpdateWaitStates(hfFreq, VSCALE_EM01_LOW_POWER);
   1968            }
   1969          
   1970            EMU->CMD = vScaleEM01Cmd(voltage);
   1971          
   1972            if (wait) {
   1973              EMU_VScaleWait();
   1974            }
   1975          #endif
   1976          
   1977            if (voltage == emuVScaleEM01_HighPerformance) {
   \       0x82   0x2D02             CMP      R5,#+2
   \       0x84   0xD105             BNE.N    ??EMU_VScaleEM01_1
   1978              /* Update wait states after scaling up voltage. */
   1979              CMU_UpdateWaitStates(hfFreq, VSCALE_EM01_HIGH_PERFORMANCE);
   \       0x86   0x4630             MOV      R0,R6
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x8E   0x.... 0x....      B.W      CMU_UpdateWaitStates
   1980            }
   1981          }
   \                     ??EMU_VScaleEM01_1: (+1)
   \       0x92   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1982          #endif
   1983          
   1984          #if defined(BU_PRESENT) && defined(_SILICON_LABS_32B_SERIES_0)
   1985          /***************************************************************************//**
   1986           * @brief
   1987           *   Configure Backup Power Domain settings.
   1988           *
   1989           * @param[in] bupdInit
   1990           *   Backup power domain initialization structure.
   1991           ******************************************************************************/
   1992          void EMU_BUPDInit(const EMU_BUPDInit_TypeDef *bupdInit)
   1993          {
   1994            uint32_t reg;
   1995          
   1996            /* Set the power connection configuration. */
   1997            reg = EMU->PWRCONF & ~(_EMU_PWRCONF_PWRRES_MASK
   1998                                   | _EMU_PWRCONF_VOUTSTRONG_MASK
   1999                                   | _EMU_PWRCONF_VOUTMED_MASK
   2000                                   | _EMU_PWRCONF_VOUTWEAK_MASK);
   2001          
   2002            reg |= bupdInit->resistor
   2003                   | (bupdInit->voutStrong << _EMU_PWRCONF_VOUTSTRONG_SHIFT)
   2004                   | (bupdInit->voutMed    << _EMU_PWRCONF_VOUTMED_SHIFT)
   2005                   | (bupdInit->voutWeak   << _EMU_PWRCONF_VOUTWEAK_SHIFT);
   2006          
   2007            EMU->PWRCONF = reg;
   2008          
   2009            /* Set the backup domain inactive mode configuration. */
   2010            reg = EMU->BUINACT & ~(_EMU_BUINACT_PWRCON_MASK);
   2011            reg |= (bupdInit->inactivePower);
   2012            EMU->BUINACT = reg;
   2013          
   2014            /* Set the backup domain active mode configuration. */
   2015            reg = EMU->BUACT & ~(_EMU_BUACT_PWRCON_MASK);
   2016            reg |= (bupdInit->activePower);
   2017            EMU->BUACT = reg;
   2018          
   2019            /* Set the power control configuration */
   2020            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_PROBE_MASK
   2021                                  | _EMU_BUCTRL_BODCAL_MASK
   2022                                  | _EMU_BUCTRL_STATEN_MASK
   2023                                  | _EMU_BUCTRL_EN_MASK);
   2024          
   2025            /* Note the use of ->enable to enable BUPD. Use BU_VIN pin input and
   2026               release reset. */
   2027            reg |= bupdInit->probe
   2028                   | (bupdInit->bodCal          << _EMU_BUCTRL_BODCAL_SHIFT)
   2029                   | (bupdInit->statusPinEnable << _EMU_BUCTRL_STATEN_SHIFT)
   2030                   | (bupdInit->enable          << _EMU_BUCTRL_EN_SHIFT);
   2031          
   2032            /* Enable configuration. */
   2033            EMU->BUCTRL = reg;
   2034          
   2035            /* If enable is true, enable BU_VIN input power pin. If not, disable it.  */
   2036            EMU_BUPinEnable(bupdInit->enable);
   2037          
   2038            /* If enable is true, release BU reset. If not, keep reset asserted. */
   2039            BUS_RegBitWrite(&(RMU->CTRL), _RMU_CTRL_BURSTEN_SHIFT, !bupdInit->enable);
   2040          }
   2041          
   2042          /***************************************************************************//**
   2043           * @brief
   2044           *   Configure the Backup Power Domain BOD Threshold value.
   2045           * @note
   2046           *   These values are precalibrated.
   2047           * @param[in] mode Active or Inactive mode
   2048           * @param[in] value
   2049           ******************************************************************************/
   2050          void EMU_BUThresholdSet(EMU_BODMode_TypeDef mode, uint32_t value)
   2051          {
   2052            EFM_ASSERT(value < 8);
   2053            EFM_ASSERT(value <= (_EMU_BUACT_BUEXTHRES_MASK >> _EMU_BUACT_BUEXTHRES_SHIFT));
   2054          
   2055            switch (mode) {
   2056              case emuBODMode_Active:
   2057                EMU->BUACT = (EMU->BUACT & ~_EMU_BUACT_BUEXTHRES_MASK)
   2058                             | (value << _EMU_BUACT_BUEXTHRES_SHIFT);
   2059                break;
   2060              case emuBODMode_Inactive:
   2061                EMU->BUINACT = (EMU->BUINACT & ~_EMU_BUINACT_BUENTHRES_MASK)
   2062                               | (value << _EMU_BUINACT_BUENTHRES_SHIFT);
   2063                break;
   2064            }
   2065          }
   2066          
   2067          /***************************************************************************//**
   2068           * @brief
   2069           *  Configure the Backup Power Domain BOD Threshold Range.
   2070           * @note
   2071           *  These values are precalibrated.
   2072           * @param[in] mode Active or Inactive mode
   2073           * @param[in] value
   2074           ******************************************************************************/
   2075          void EMU_BUThresRangeSet(EMU_BODMode_TypeDef mode, uint32_t value)
   2076          {
   2077            EFM_ASSERT(value < 4);
   2078            EFM_ASSERT(value <= (_EMU_BUACT_BUEXRANGE_MASK >> _EMU_BUACT_BUEXRANGE_SHIFT));
   2079          
   2080            switch (mode) {
   2081              case emuBODMode_Active:
   2082                EMU->BUACT = (EMU->BUACT & ~_EMU_BUACT_BUEXRANGE_MASK)
   2083                             | (value << _EMU_BUACT_BUEXRANGE_SHIFT);
   2084                break;
   2085              case emuBODMode_Inactive:
   2086                EMU->BUINACT = (EMU->BUINACT & ~_EMU_BUINACT_BUENRANGE_MASK)
   2087                               | (value << _EMU_BUINACT_BUENRANGE_SHIFT);
   2088                break;
   2089            }
   2090          }
   2091          #endif
   2092          
   2093          #if defined(BU_PRESENT) && defined(_SILICON_LABS_32B_SERIES_1)
   2094          /***************************************************************************//**
   2095           * @brief
   2096           *   Configure Backup Power Domain settings.
   2097           *
   2098           * @param[in] buInit
   2099           *   Backup power domain initialization structure.
   2100           ******************************************************************************/
   2101          void EMU_BUInit(const EMU_BUInit_TypeDef *buInit)
   2102          {
   2103            uint32_t reg = 0;
   2104          
   2105            /* Set the backup power configuration. */
   2106            reg |= (buInit->disMaxComp << _EMU_BUCTRL_DISMAXCOMP_SHIFT);
   2107            reg |= (uint32_t)(buInit->inactivePwrCon);
   2108            reg |= (uint32_t)(buInit->activePwrCon);
   2109            reg |= (uint32_t)(buInit->pwrRes);
   2110            reg |= (uint32_t)(buInit->voutRes);
   2111            reg |= (buInit->buVinProbeEn << _EMU_BUCTRL_BUVINPROBEEN_SHIFT);
   2112            reg |= (buInit->staEn << _EMU_BUCTRL_STATEN_SHIFT);
   2113            reg |= (buInit->enable << _EMU_BUCTRL_EN_SHIFT);
   2114            EMU->BUCTRL = reg;
   2115          }
   2116          #endif
   2117          
   2118          #if defined(_EMU_BUCTRL_DISMAXCOMP_MASK)
   2119          /***************************************************************************//**
   2120           * @brief
   2121           *   Disable Main Backup Power Domain comparator.
   2122           *
   2123           * @param[in] disableMainBuComparator
   2124           *   True to disable main BU comparator.
   2125           ******************************************************************************/
   2126          void EMU_BUDisMaxCompSet(bool disableMainBuComparator)
   2127          {
   2128            uint32_t reg;
   2129          
   2130            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_DISMAXCOMP_MASK);
   2131            reg |= (disableMainBuComparator << _EMU_BUCTRL_DISMAXCOMP_SHIFT);
   2132            EMU->BUCTRL = reg;
   2133          }
   2134          #endif
   2135          
   2136          #if defined(_EMU_BUCTRL_BUINACTPWRCON_MASK)
   2137          /***************************************************************************//**
   2138           * @brief
   2139           *   Configure power connection configuration when not in Backup mode.
   2140           *
   2141           * @param[in] inactPwrCon
   2142           *   Inactive power configuration.
   2143           ******************************************************************************/
   2144          void EMU_BUBuInactPwrConSet(EMU_BUBuInactPwrCon_TypeDef inactPwrCon)
   2145          {
   2146            uint32_t reg;
   2147          
   2148            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_BUINACTPWRCON_MASK);
   2149            reg |= (uint32_t)(inactPwrCon);
   2150            EMU->BUCTRL = reg;
   2151          }
   2152          #endif
   2153          
   2154          #if defined(_EMU_BUCTRL_BUACTPWRCON_MASK)
   2155          /***************************************************************************//**
   2156           * @brief
   2157           *   Configure power connection configuration when in Backup mode.
   2158           *
   2159           * @param[in] actPwrCon
   2160           *   Active power configuration.
   2161           ******************************************************************************/
   2162          void EMU_BUBuActPwrConSet(EMU_BUBuActPwrCon_TypeDef actPwrCon)
   2163          {
   2164            uint32_t reg;
   2165          
   2166            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_BUACTPWRCON_MASK);
   2167            reg |= (uint32_t)(actPwrCon);
   2168            EMU->BUCTRL = reg;
   2169          }
   2170          #endif
   2171          
   2172          #if defined(_EMU_BUCTRL_PWRRES_MASK)
   2173          /***************************************************************************//**
   2174           * @brief
   2175           *   Power domain resistor selection.
   2176           *
   2177           * @param[in] pwrRes
   2178           *   Resistor selection.
   2179           ******************************************************************************/
   2180          void EMU_BUPwrResSet(EMU_BUPwrRes_TypeDef pwrRes)
   2181          {
   2182            uint32_t reg;
   2183          
   2184            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_PWRRES_MASK);
   2185            reg |= (uint32_t)(pwrRes);
   2186            EMU->BUCTRL = reg;
   2187          }
   2188          #endif
   2189          
   2190          #if defined(_EMU_BUCTRL_VOUTRES_MASK)
   2191          /***************************************************************************//**
   2192           * @brief
   2193           *   B_VOUT resistor select.
   2194           *
   2195           * @param[in] resistorSel
   2196           *   Resistor selection.
   2197           ******************************************************************************/
   2198          void EMU_BUVoutResSet(EMU_BUVoutRes_TypeDef resistorSel)
   2199          {
   2200            uint32_t reg;
   2201          
   2202            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_VOUTRES_MASK);
   2203            reg |= (uint32_t)(resistorSel);
   2204            EMU->BUCTRL = reg;
   2205          }
   2206          #endif
   2207          
   2208          #if defined(_EMU_BUCTRL_BUVINPROBEEN_MASK)
   2209          /***************************************************************************//**
   2210           * @brief
   2211           *   Enable BU_VIN probing
   2212           *
   2213           * @param[in] enable
   2214           *   True to enable BU_VIN probing. False to disable.
   2215           ******************************************************************************/
   2216          void EMU_BUBuVinProbeEnSet(bool enable)
   2217          {
   2218            uint32_t reg;
   2219          
   2220            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_BUVINPROBEEN_MASK);
   2221            reg |= (enable << _EMU_BUCTRL_BUVINPROBEEN_SHIFT);
   2222            EMU->BUCTRL = reg;
   2223          }
   2224          #endif
   2225          
   2226          #if defined(_EMU_BUCTRL_STATEN_MASK)
   2227          /***************************************************************************//**
   2228           * @brief
   2229           *   Enable backup mode status export.
   2230           *
   2231           * @param[in] enable
   2232           *   True to enable status export. False to disable.
   2233           ******************************************************************************/
   2234          void EMU_BUStatEnSet(bool enable)
   2235          {
   2236            uint32_t reg;
   2237          
   2238            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_STATEN_MASK);
   2239            reg |= (enable << _EMU_BUCTRL_STATEN_SHIFT);
   2240            EMU->BUCTRL = reg;
   2241          }
   2242          #endif
   2243          
   2244          #if defined(_EMU_BUCTRL_EN_MASK)
   2245          /***************************************************************************//**
   2246           * @brief
   2247           *   Enable backup mode.
   2248           *
   2249           * @param[in] enable
   2250           *   True to enable backup mode. False to disable.
   2251           ******************************************************************************/
   2252          void EMU_BUEnableSet(bool enable)
   2253          {
   2254            uint32_t reg;
   2255          
   2256            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_EN_MASK);
   2257            reg |= (enable << _EMU_BUCTRL_EN_SHIFT);
   2258            EMU->BUCTRL = reg;
   2259          }
   2260          #endif
   2261          
   2262          #if defined(EMU_SERIES1_DCDC_BUCK_PRESENT)
   2263          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
   2264          /* Internal DCDC trim modes. */
   2265          typedef enum {
   2266            dcdcTrimMode_EM234H_LP = 0,
   2267          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2268            dcdcTrimMode_EM01_LP,
   2269          #endif
   2270            dcdcTrimMode_LN,
   2271          } dcdcTrimMode_TypeDef;
   2272          
   2273          /** @endcond */
   2274          
   2275          /***************************************************************************//**
   2276           * @brief
   2277           *   Load DCDC calibration constants from the DI page. A constant means that calibration
   2278           *   data that does not change depending on other configuration parameters.
   2279           *
   2280           * @return
   2281           *   False if calibration registers are locked.
   2282           ******************************************************************************/
   2283          static bool dcdcConstCalibrationLoad(void)
   2284          {
   2285          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2286            uint32_t val;
   2287            volatile uint32_t *reg;
   2288          
   2289            /* DI calibration data in Flash. */
   2290            volatile uint32_t* const diCal_EMU_DCDCLNFREQCTRL =  (volatile uint32_t *)(0x0FE08038);
   2291            volatile uint32_t* const diCal_EMU_DCDCLNVCTRL =     (volatile uint32_t *)(0x0FE08040);
   2292            volatile uint32_t* const diCal_EMU_DCDCLPCTRL =      (volatile uint32_t *)(0x0FE08048);
   2293            volatile uint32_t* const diCal_EMU_DCDCLPVCTRL =     (volatile uint32_t *)(0x0FE08050);
   2294            volatile uint32_t* const diCal_EMU_DCDCTRIM0 =       (volatile uint32_t *)(0x0FE08058);
   2295            volatile uint32_t* const diCal_EMU_DCDCTRIM1 =       (volatile uint32_t *)(0x0FE08060);
   2296          
   2297            if (DEVINFO->DCDCLPVCTRL0 != UINT_MAX) {
   2298              val = *(diCal_EMU_DCDCLNFREQCTRL + 1);
   2299              reg = (volatile uint32_t *)*diCal_EMU_DCDCLNFREQCTRL;
   2300              *reg = val;
   2301          
   2302              val = *(diCal_EMU_DCDCLNVCTRL + 1);
   2303              reg = (volatile uint32_t *)*diCal_EMU_DCDCLNVCTRL;
   2304              *reg = val;
   2305          
   2306              val = *(diCal_EMU_DCDCLPCTRL + 1);
   2307              reg = (volatile uint32_t *)*diCal_EMU_DCDCLPCTRL;
   2308              *reg = val;
   2309          
   2310              val = *(diCal_EMU_DCDCLPVCTRL + 1);
   2311              reg = (volatile uint32_t *)*diCal_EMU_DCDCLPVCTRL;
   2312              *reg = val;
   2313          
   2314              val = *(diCal_EMU_DCDCTRIM0 + 1);
   2315              reg = (volatile uint32_t *)*diCal_EMU_DCDCTRIM0;
   2316              *reg = val;
   2317          
   2318              val = *(diCal_EMU_DCDCTRIM1 + 1);
   2319              reg = (volatile uint32_t *)*diCal_EMU_DCDCTRIM1;
   2320              *reg = val;
   2321          
   2322              return true;
   2323            }
   2324            EFM_ASSERT(false);
   2325            /* Return when assertions are disabled. */
   2326            return false;
   2327          
   2328          #else
   2329            return true;
   2330          #endif
   2331          }
   2332          
   2333          /***************************************************************************//**
   2334           * @brief
   2335           *   Set recommended and validated current optimization and timing settings.
   2336           *
   2337           ******************************************************************************/
   2338          static void dcdcValidatedConfigSet(void)
   2339          {
   2340            uint32_t lnForceCcm;
   2341          
   2342          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2343            uint32_t dcdcTiming;
   2344            SYSTEM_ChipRevision_TypeDef rev;
   2345          #endif
   2346          
   2347            /* Enable duty cycling of the bias. */
   2348            EMU->DCDCLPCTRL |= EMU_DCDCLPCTRL_LPVREFDUTYEN;
   2349          
   2350            /* Set low-noise RCO for LNFORCECCM configuration.
   2351             * LNFORCECCM is default 1 for EFR32
   2352             * LNFORCECCM is default 0 for EFM32
   2353             */
   2354            lnForceCcm = BUS_RegBitRead(&EMU->DCDCMISCCTRL, _EMU_DCDCMISCCTRL_LNFORCECCM_SHIFT);
   2355            if (lnForceCcm != 0U) {
   2356              /* 7 MHz is recommended for LNFORCECCM = 1. */
   2357              EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_7MHz);
   2358            } else {
   2359              /* 3 MHz is recommended for LNFORCECCM = 0. */
   2360              EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_3MHz);
   2361            }
   2362          
   2363          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2364            EMU->DCDCTIMING &= ~_EMU_DCDCTIMING_DUTYSCALE_MASK;
   2365            EMU->DCDCMISCCTRL |= EMU_DCDCMISCCTRL_LPCMPHYSDIS
   2366                                 | EMU_DCDCMISCCTRL_LPCMPHYSHI;
   2367          
   2368            SYSTEM_ChipRevisionGet(&rev);
   2369            if ((rev.major == 1)
   2370                && (rev.minor < 3)
   2371                && (errataFixDcdcHsState == errataFixDcdcHsInit)) {
   2372              /* LPCMPWAITDIS = 1 */
   2373              EMU_DCDCSMCTRL |= 1;
   2374          
   2375              dcdcTiming = EMU->DCDCTIMING;
   2376              dcdcTiming &= ~(_EMU_DCDCTIMING_LPINITWAIT_MASK
   2377                              | _EMU_DCDCTIMING_LNWAIT_MASK
   2378                              | _EMU_DCDCTIMING_BYPWAIT_MASK);
   2379          
   2380              dcdcTiming |= ((180 << _EMU_DCDCTIMING_LPINITWAIT_SHIFT)
   2381                             | (12 << _EMU_DCDCTIMING_LNWAIT_SHIFT)
   2382                             | (180 << _EMU_DCDCTIMING_BYPWAIT_SHIFT));
   2383              EMU->DCDCTIMING = dcdcTiming;
   2384          
   2385              errataFixDcdcHsState = errataFixDcdcHsTrimSet;
   2386            }
   2387          #endif
   2388          }
   2389          
   2390          /***************************************************************************//**
   2391           * @brief
   2392           *   Compute current limiters:
   2393           *     LNCLIMILIMSEL: LN current limiter threshold
   2394           *     LPCLIMILIMSEL: LP current limiter threshold
   2395           *     DCDCZDETCTRL:  zero detector limiter threshold
   2396           ******************************************************************************/
   2397          static void currentLimitersUpdate(void)
   2398          {
   2399            uint32_t lncLimSel;
   2400            uint32_t zdetLimSel;
   2401            uint32_t pFetCnt;
   2402            uint16_t maxReverseCurrent_mA;
   2403          
   2404            /* 80 mA as recommended peak in Application Note AN0948.
   2405               The peak current is the average current plus 50% of the current ripple.
   2406               Hence, a 14 mA average current is recommended in LP mode. Since LP PFETCNT is also
   2407               a constant, lpcLimImSel = 1. The following calculation is provided
   2408               for documentation only. */
   2409            const uint32_t lpcLim = (((14 + 40) + ((14 + 40) / 2))
   2410                                     / (5 * (DCDC_LP_PFET_CNT + 1)))
   2411                                    - 1;
   2412            const uint32_t lpcLimSel = lpcLim << _EMU_DCDCMISCCTRL_LPCLIMILIMSEL_SHIFT;
   2413          
   2414            /* Get enabled PFETs. */
   2415            pFetCnt = (EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_PFETCNT_MASK)
   2416                      >> _EMU_DCDCMISCCTRL_PFETCNT_SHIFT;
   2417          
   2418            /* Compute the LN current limiter threshold from the nominal user input current and
   2419               LN PFETCNT as described in the register description for
   2420               EMU_DCDCMISCCTRL_LNCLIMILIMSEL. */
   2421            lncLimSel = ((((uint32_t)dcdcMaxCurrent_mA + 40U)
   2422                          + (((uint32_t)dcdcMaxCurrent_mA + 40U) / 2U))
   2423                         / (5U * (pFetCnt + 1U)))
   2424                        - 1U;
   2425          
   2426            /* Saturate the register field value. */
   2427            lncLimSel = SL_MIN(lncLimSel,
   2428                               _EMU_DCDCMISCCTRL_LNCLIMILIMSEL_MASK
   2429                               >> _EMU_DCDCMISCCTRL_LNCLIMILIMSEL_SHIFT);
   2430          
   2431            lncLimSel <<= _EMU_DCDCMISCCTRL_LNCLIMILIMSEL_SHIFT;
   2432          
   2433            /* Check for overflow. */
   2434            EFM_ASSERT((lncLimSel & ~_EMU_DCDCMISCCTRL_LNCLIMILIMSEL_MASK) == 0x0U);
   2435            EFM_ASSERT((lpcLimSel & ~_EMU_DCDCMISCCTRL_LPCLIMILIMSEL_MASK) == 0x0U);
   2436          
   2437            EMU->DCDCMISCCTRL = (EMU->DCDCMISCCTRL & ~(_EMU_DCDCMISCCTRL_LNCLIMILIMSEL_MASK
   2438                                                       | _EMU_DCDCMISCCTRL_LPCLIMILIMSEL_MASK))
   2439                                | (lncLimSel | lpcLimSel);
   2440          
   2441            /* Compute the reverse current limit threshold for the zero detector from the user input
   2442               maximum reverse current and LN PFETCNT as described in the register description
   2443               for EMU_DCDCZDETCTRL_ZDETILIMSEL. */
   2444            if (dcdcReverseCurrentControl >= 0) {
   2445              /* If dcdcReverseCurrentControl < 0, EMU_DCDCZDETCTRL_ZDETILIMSEL is "don't care". */
   2446              maxReverseCurrent_mA = (uint16_t)dcdcReverseCurrentControl;
   2447          
   2448              zdetLimSel = ((((uint32_t)maxReverseCurrent_mA + 40U)
   2449                             + (((uint32_t)maxReverseCurrent_mA + 40U) / 2U))
   2450                            / ((2U * (pFetCnt + 1U)) + ((pFetCnt + 1U) / 2U)));
   2451              /* Saturate the register field value. */
   2452              zdetLimSel = SL_MIN(zdetLimSel,
   2453                                  _EMU_DCDCZDETCTRL_ZDETILIMSEL_MASK
   2454                                  >> _EMU_DCDCZDETCTRL_ZDETILIMSEL_SHIFT);
   2455          
   2456              zdetLimSel <<= _EMU_DCDCZDETCTRL_ZDETILIMSEL_SHIFT;
   2457          
   2458              /* Check for overflow. */
   2459              EFM_ASSERT((zdetLimSel & ~_EMU_DCDCZDETCTRL_ZDETILIMSEL_MASK) == 0x0U);
   2460          
   2461              EMU->DCDCZDETCTRL = (EMU->DCDCZDETCTRL & ~_EMU_DCDCZDETCTRL_ZDETILIMSEL_MASK)
   2462                                  | zdetLimSel;
   2463            }
   2464          }
   2465          
   2466          /***************************************************************************//**
   2467           * @brief
   2468           *   Set static variables that hold the user set maximum peak current
   2469           *   and reverse current. Update limiters.
   2470           *
   2471           * @param[in] maxCurrent_mA
   2472           *   Set the maximum peak current that the DCDC can draw from the power source.
   2473           * @param[in] reverseCurrentControl
   2474           *   Reverse the current control as defined by
   2475           *   @ref EMU_DcdcLnReverseCurrentControl_TypeDef. Positive values have unit mA.
   2476           ******************************************************************************/
   2477          static void userCurrentLimitsSet(uint32_t maxCurrent_mA,
   2478                                           EMU_DcdcLnReverseCurrentControl_TypeDef reverseCurrentControl)
   2479          {
   2480            dcdcMaxCurrent_mA = (uint16_t)maxCurrent_mA;
   2481            dcdcReverseCurrentControl = reverseCurrentControl;
   2482          }
   2483          
   2484          /***************************************************************************//**
   2485           * @brief
   2486           *   Set DCDC low noise compensator control register.
   2487           *
   2488           * @param[in] comp
   2489           *   Low-noise mode compensator trim setpoint.
   2490           ******************************************************************************/
   2491          static void compCtrlSet(EMU_DcdcLnCompCtrl_TypeDef comp)
   2492          {
   2493            switch (comp) {
   2494              case emuDcdcLnCompCtrl_1u0F:
   2495                EMU->DCDCLNCOMPCTRL = 0x57204077UL;
   2496                break;
   2497          
   2498              case emuDcdcLnCompCtrl_4u7F:
   2499                EMU->DCDCLNCOMPCTRL = 0xB7102137UL;
   2500                break;
   2501          
   2502              default:
   2503                EFM_ASSERT(false);
   2504                break;
   2505            }
   2506          }
   2507          
   2508          /***************************************************************************//**
   2509           * @brief
   2510           *   Load EMU_DCDCLPCTRL_LPCMPHYSSEL depending on LP bias, LP feedback
   2511           *   attenuation, and DEVINFOREV.
   2512           *
   2513           * @param[in] lpAttenuation
   2514           *   LP feedback attenuation.
   2515           * @param[in] lpCmpBias
   2516           *   lpCmpBias selection.
   2517           * @param[in] trimMode
   2518           *   DCDC trim mode.
   2519           ******************************************************************************/
   2520          static bool lpCmpHystCalibrationLoad(bool lpAttenuation,
   2521                                               uint8_t lpCmpBias,
   2522                                               dcdcTrimMode_TypeDef trimMode)
   2523          {
   2524            uint32_t lpcmpHystSel;
   2525          #if !defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2526            (void)lpAttenuation;
   2527          #endif
   2528          
   2529            /* Get calibration data revision. */
   2530          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2531            uint8_t devinfoRev = SYSTEM_GetDevinfoRev();
   2532          
   2533            /* Load LPATT indexed calibration data. */
   2534            if (devinfoRev < 4) {
   2535              lpcmpHystSel = DEVINFO->DCDCLPCMPHYSSEL0;
   2536          
   2537              if (lpAttenuation) {
   2538                lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT1_MASK)
   2539                               >> _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT1_SHIFT;
   2540              } else {
   2541                lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT0_MASK)
   2542                               >> _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT0_SHIFT;
   2543              }
   2544            } else
   2545          #endif
   2546            {
   2547              /* devinfoRev >= 4: load LPCMPBIAS indexed calibration data. */
   2548              lpcmpHystSel = DEVINFO->DCDCLPCMPHYSSEL1;
   2549              switch (lpCmpBias) {
   2550                case 0:
   2551                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS0_MASK)
   2552                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS0_SHIFT;
   2553                  break;
   2554          
   2555                case 1:
   2556                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS1_MASK)
   2557                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS1_SHIFT;
   2558                  break;
   2559          
   2560                case 2:
   2561                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS2_MASK)
   2562                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS2_SHIFT;
   2563                  break;
   2564          
   2565                case 3:
   2566                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS3_MASK)
   2567                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS3_SHIFT;
   2568                  break;
   2569          
   2570                default:
   2571                  EFM_ASSERT(false);
   2572                  /* Return when assertions are disabled. */
   2573                  return false;
   2574              }
   2575            }
   2576          
   2577            /* Set trims. */
   2578            if (trimMode == dcdcTrimMode_EM234H_LP) {
   2579              /* Make sure the sel value is within the field range. */
   2580              lpcmpHystSel <<= _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT;
   2581              if ((lpcmpHystSel & ~_GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK) != 0U) {
   2582                EFM_ASSERT(false);
   2583                /* Return when assertions are disabled. */
   2584                return false;
   2585              }
   2586              EMU->DCDCLPCTRL = (EMU->DCDCLPCTRL & ~_GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK) | lpcmpHystSel;
   2587            }
   2588          
   2589          #if defined(_EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_MASK)
   2590            if (trimMode == dcdcTrimMode_EM01_LP) {
   2591              /* Make sure the sel value is within the field range. */
   2592              lpcmpHystSel <<= _EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_SHIFT;
   2593              if ((lpcmpHystSel & ~_EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_MASK) != 0U) {
   2594                EFM_ASSERT(false);
   2595                /* Return when assertions are disabled. */
   2596                return false;
   2597              }
   2598              EMU->DCDCLPEM01CFG = (EMU->DCDCLPEM01CFG & ~_EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_MASK) | lpcmpHystSel;
   2599            }
   2600          #endif
   2601          
   2602            return true;
   2603          }
   2604          
   2605          /***************************************************************************//**
   2606           * @brief
   2607           *   Load LPVREF low and high from DEVINFO.
   2608           *
   2609           * @param[out] vrefL
   2610           *   LPVREF low from DEVINFO.
   2611           * @param[out] vrefH
   2612           *   LPVREF high from DEVINFO.
   2613           * @param[in] lpAttenuation
   2614           *   LP feedback attenuation.
   2615           * @param[in] lpcmpBias
   2616           *   lpcmpBias to look up in DEVINFO.
   2617           ******************************************************************************/
   2618          static void lpGetDevinfoVrefLowHigh(uint32_t *vrefL,
   2619                                              uint32_t *vrefH,
   2620                                              bool lpAttenuation,
   2621                                              uint8_t lpcmpBias)
   2622          {
   2623            uint32_t vrefLow = 0;
   2624            uint32_t vrefHigh = 0;
   2625          
   2626            /* Find VREF high and low in DEVINFO indexed by LPCMPBIAS (lpcmpBias)
   2627               and LPATT (lpAttenuation) */
   2628            uint32_t switchVal = ((uint32_t)lpcmpBias << 8) | (lpAttenuation ? 1U : 0U);
   2629            switch (switchVal) {
   2630              case ((0 << 8) | 1):
   2631                vrefLow  = DEVINFO->DCDCLPVCTRL2;
   2632                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS0_MASK)
   2633                           >> _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS0_SHIFT;
   2634                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS0_MASK)
   2635                           >> _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS0_SHIFT;
   2636                break;
   2637          
   2638              case ((1 << 8) | 1):
   2639                vrefLow  = DEVINFO->DCDCLPVCTRL2;
   2640                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS1_MASK)
   2641                           >> _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS1_SHIFT;
   2642                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS1_MASK)
   2643                           >> _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS1_SHIFT;
   2644                break;
   2645          
   2646              case ((2 << 8) | 1):
   2647                vrefLow  = DEVINFO->DCDCLPVCTRL3;
   2648                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS2_MASK)
   2649                           >> _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS2_SHIFT;
   2650                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS2_MASK)
   2651                           >> _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS2_SHIFT;
   2652                break;
   2653          
   2654              case ((3 << 8) | 1):
   2655                vrefLow  = DEVINFO->DCDCLPVCTRL3;
   2656                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS3_MASK)
   2657                           >> _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS3_SHIFT;
   2658                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS3_MASK)
   2659                           >> _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS3_SHIFT;
   2660                break;
   2661          
   2662              case ((0 << 8) | 0):
   2663                vrefLow  = DEVINFO->DCDCLPVCTRL0;
   2664                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS0_MASK)
   2665                           >> _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS0_SHIFT;
   2666                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS0_MASK)
   2667                           >> _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS0_SHIFT;
   2668                break;
   2669          
   2670              case ((1 << 8) | 0):
   2671                vrefLow  = DEVINFO->DCDCLPVCTRL0;
   2672                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS1_MASK)
   2673                           >> _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS1_SHIFT;
   2674                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS1_MASK)
   2675                           >> _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS1_SHIFT;
   2676                break;
   2677          
   2678              case ((2 << 8) | 0):
   2679                vrefLow  = DEVINFO->DCDCLPVCTRL1;
   2680                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS2_MASK)
   2681                           >> _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS2_SHIFT;
   2682                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS2_MASK)
   2683                           >> _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS2_SHIFT;
   2684                break;
   2685          
   2686              case ((3 << 8) | 0):
   2687                vrefLow  = DEVINFO->DCDCLPVCTRL1;
   2688                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS3_MASK)
   2689                           >> _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS3_SHIFT;
   2690                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS3_MASK)
   2691                           >> _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS3_SHIFT;
   2692                break;
   2693          
   2694              default:
   2695                EFM_ASSERT(false);
   2696                break;
   2697            }
   2698            *vrefL = vrefLow;
   2699            *vrefH = vrefHigh;
   2700          }
   2701          
   2702          /***************************************************************************//**
   2703           * @brief
   2704           *   Configure the DCDC regulator.
   2705           *
   2706           * @note
   2707           * Do not call this function if the power circuit is configured for NODCDC as
   2708           * described in the Power Configurations section of the Reference Manual.
   2709           * Instead, call @ref EMU_DCDCPowerOff().
   2710           *
   2711           * @param[in] dcdcInit
   2712           *  The DCDC initialization structure.
   2713           *
   2714           * @return
   2715           *   True if initialization parameters are valid.
   2716           ******************************************************************************/
   2717          bool EMU_DCDCInit(const EMU_DCDCInit_TypeDef *dcdcInit)
   2718          {
   2719            uint32_t lpCmpBiasSelEM234H;
   2720          
   2721          #if defined(_EMU_PWRCFG_MASK)
   2722            /* Set the external power configuration. This enables writing to the other
   2723               DCDC registers. */
   2724            EMU->PWRCFG = EMU_PWRCFG_PWRCFG_DCDCTODVDD;
   2725          
   2726            /* EMU->PWRCFG is write-once and POR reset only. Check that
   2727               the desired power configuration was set. */
   2728            if ((EMU->PWRCFG & _EMU_PWRCFG_PWRCFG_MASK) != EMU_PWRCFG_PWRCFG_DCDCTODVDD) {
   2729              /* If this assert triggers unexpectedly, power cycle the
   2730                 kit to reset the power configuration. */
   2731              EFM_ASSERT(false);
   2732              /* Return when assertions are disabled. */
   2733              return false;
   2734            }
   2735          #endif
   2736          
   2737            /* Load DCDC calibration data from the DI page. */
   2738            (void)dcdcConstCalibrationLoad();
   2739          
   2740            /* Check current parameters */
   2741            EFM_ASSERT(dcdcInit->maxCurrent_mA <= 200U);
   2742            EFM_ASSERT(dcdcInit->em01LoadCurrent_mA <= dcdcInit->maxCurrent_mA);
   2743            EFM_ASSERT(dcdcInit->reverseCurrentControl <= 200);
   2744          
   2745            if (dcdcInit->dcdcMode == emuDcdcMode_LowNoise) {
   2746              /* DCDC low-noise supports max 200 mA. */
   2747              EFM_ASSERT(dcdcInit->em01LoadCurrent_mA <= 200U);
   2748            }
   2749          #if (_SILICON_LABS_GECKO_INTERNAL_SDID != 80)
   2750            else if (dcdcInit->dcdcMode == emuDcdcMode_LowPower) {
   2751              /* Up to 10 mA is supported for EM01-LP mode. */
   2752              EFM_ASSERT(dcdcInit->em01LoadCurrent_mA <= 10U);
   2753            }
   2754          #endif
   2755            else {
   2756              /* No need to check the EM01 load limit. */
   2757            }
   2758          
   2759            /* EM2/3/4 current above 10 mA is not supported. */
   2760            EFM_ASSERT(dcdcInit->em234LoadCurrent_uA <= 10000U);
   2761          
   2762            if (dcdcInit->em234LoadCurrent_uA < 75U) {
   2763              lpCmpBiasSelEM234H  = 0;
   2764            } else if (dcdcInit->em234LoadCurrent_uA < 500U) {
   2765              lpCmpBiasSelEM234H  = 1U << _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT;
   2766            } else if (dcdcInit->em234LoadCurrent_uA < 2500U) {
   2767              lpCmpBiasSelEM234H  = 2U << _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT;
   2768            } else {
   2769              lpCmpBiasSelEM234H  = 3U << _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT;
   2770            }
   2771          
   2772            /* ==== THESE NEXT STEPS ARE STRONGLY ORDER DEPENDENT ==== */
   2773          
   2774            /* Set DCDC low-power mode comparator bias selection. */
   2775          
   2776            /* 1. Set DCDC low-power mode comparator bias selection and forced CCM.
   2777                  => Updates DCDCMISCCTRL_LNFORCECCM */
   2778            EMU->DCDCMISCCTRL = (EMU->DCDCMISCCTRL & ~(_GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK
   2779                                                       | _EMU_DCDCMISCCTRL_LNFORCECCM_MASK))
   2780                                | ((uint32_t)lpCmpBiasSelEM234H
   2781                                   | (dcdcInit->reverseCurrentControl >= 0
   2782                                      ? EMU_DCDCMISCCTRL_LNFORCECCM : 0U));
   2783          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2784            /* Only 10 mA EM01-LP current is supported. */
   2785            EMU->DCDCLPEM01CFG = (EMU->DCDCLPEM01CFG & ~_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2786                                 | EMU_DCDCLPEM01CFG_LPCMPBIASEM01_BIAS3;
   2787          #endif
   2788          
   2789            /* 2. Set recommended and validated current optimization settings.
   2790                  <= Depends on LNFORCECCM
   2791                  => Updates DCDCLNFREQCTRL_RCOBAND */
   2792            dcdcEm01LoadCurrent_mA = dcdcInit->em01LoadCurrent_mA;
   2793            dcdcValidatedConfigSet();
   2794          
   2795            /* 3. Updated static currents and limits user data.
   2796                  Limiters are updated in @ref EMU_DCDCOptimizeSlice(). */
   2797            userCurrentLimitsSet(dcdcInit->maxCurrent_mA,
   2798                                 dcdcInit->reverseCurrentControl);
   2799          
   2800            /* 4. Optimize LN slice based on the given user input load current.
   2801                  <= Depends on DCDCMISCCTRL_LNFORCECCM and DCDCLNFREQCTRL_RCOBAND
   2802                  <= Depends on dcdcInit->maxCurrent_mA and dcdcInit->reverseCurrentControl
   2803                  => Updates DCDCMISCCTRL_P/NFETCNT
   2804                  => Updates DCDCMISCCTRL_LNCLIMILIMSEL and DCDCMISCCTRL_LPCLIMILIMSEL
   2805                  => Updates DCDCZDETCTRL_ZDETILIMSEL */
   2806            EMU_DCDCOptimizeSlice(dcdcInit->em01LoadCurrent_mA);
   2807          
   2808            /* ======================================================= */
   2809          
   2810            /* Set DCDC low noise mode compensator control register. */
   2811            compCtrlSet(dcdcInit->dcdcLnCompCtrl);
   2812          
   2813            /* Set DCDC output voltage. */
   2814            if (!EMU_DCDCOutputVoltageSet(dcdcInit->mVout, true, true)) {
   2815              EFM_ASSERT(false);
   2816              /* Return when assertions are disabled. */
   2817              return false;
   2818            }
   2819          
   2820          #if (_SILICON_LABS_GECKO_INTERNAL_SDID == 80)
   2821            /* Select analog peripheral power supply. This must be done before
   2822               DCDC mode is set for all EFM32xG1 and EFR32xG1 devices. */
   2823            BUS_RegBitWrite(&EMU->PWRCTRL,
   2824                            _EMU_PWRCTRL_ANASW_SHIFT,
   2825                            dcdcInit->anaPeripheralPower ? 1 : 0);
   2826          #endif
   2827          
   2828          #if defined(_EMU_PWRCTRL_REGPWRSEL_MASK)
   2829            /* Select DVDD as input to the digital regulator. The switch to DVDD will take
   2830               effect once the DCDC output is stable. */
   2831            EMU->PWRCTRL |= EMU_PWRCTRL_REGPWRSEL_DVDD;
   2832          #endif
   2833          
   2834            /* Set EM0 DCDC operating mode. Output voltage set in
   2835               @ref EMU_DCDCOutputVoltageSet() above takes effect if mode
   2836               is changed from bypass/off mode. */
   2837            EMU_DCDCModeSet(dcdcInit->dcdcMode);
   2838          
   2839          #if (_SILICON_LABS_GECKO_INTERNAL_SDID != 80)
   2840            /* Select the analog peripheral power supply. This must be done after
   2841               DCDC mode is set for all devices other than EFM32xG1 and EFR32xG1. */
   2842            BUS_RegBitWrite(&EMU->PWRCTRL,
   2843                            _EMU_PWRCTRL_ANASW_SHIFT,
   2844                            dcdcInit->anaPeripheralPower
   2845                            == emuDcdcAnaPeripheralPower_DCDC ? 1U : 0U);
   2846          #endif
   2847          
   2848            return true;
   2849          }
   2850          
   2851          /***************************************************************************//**
   2852           * @brief
   2853           *   Set DCDC regulator operating mode.
   2854           *
   2855           * @param[in] dcdcMode
   2856           *   DCDC mode.
   2857           ******************************************************************************/
   2858          void EMU_DCDCModeSet(EMU_DcdcMode_TypeDef dcdcMode)
   2859          {
   2860            bool dcdcLocked;
   2861            uint32_t currentDcdcMode;
   2862          
   2863            dcdcLocked = (EMU->PWRLOCK == EMU_PWRLOCK_LOCKKEY_LOCKED);
   2864            EMU_PowerUnlock();
   2865          
   2866            /* Wait for any previous write sync to complete and read DCDC mode. */
   2867            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2868            }
   2869            currentDcdcMode = (EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK);
   2870          
   2871            /* Enable bypass current limiter when not in bypass mode to prevent
   2872               excessive current between VREGVDD and DVDD supplies when reentering bypass mode.  */
   2873            if (currentDcdcMode != EMU_DCDCCTRL_DCDCMODE_BYPASS) {
   2874              BUS_RegBitWrite(&EMU->DCDCCLIMCTRL, _EMU_DCDCCLIMCTRL_BYPLIMEN_SHIFT, 1);
   2875            }
   2876          
   2877            if ((EMU_DcdcMode_TypeDef)currentDcdcMode == dcdcMode) {
   2878              /* Mode already set. If already in bypass, make sure the bypass current limiter
   2879                 is disabled. */
   2880              if (dcdcMode == emuDcdcMode_Bypass) {
   2881                BUS_RegBitWrite(&EMU->DCDCCLIMCTRL, _EMU_DCDCCLIMCTRL_BYPLIMEN_SHIFT, 0);
   2882              }
   2883              return;
   2884            }
   2885          
   2886          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2887          
   2888            /* Fix for errata DCDC_E203. */
   2889            if ((currentDcdcMode == EMU_DCDCCTRL_DCDCMODE_BYPASS)
   2890                && (dcdcMode == emuDcdcMode_LowNoise)) {
   2891              errataFixDcdcHsState = errataFixDcdcHsBypassLn;
   2892            }
   2893          #endif // (_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2894          
   2895          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_84)
   2896          
   2897            /* Fix for errata DCDC_E204. */
   2898            if (((currentDcdcMode == EMU_DCDCCTRL_DCDCMODE_OFF) || (currentDcdcMode == EMU_DCDCCTRL_DCDCMODE_BYPASS))
   2899                && ((dcdcMode == emuDcdcMode_LowPower) || (dcdcMode == emuDcdcMode_LowNoise))) {
   2900              /* Always start in LOWNOISE. Switch to LOWPOWER mode once LOWNOISE startup is complete. */
   2901              EMU_IntClear(EMU_IFC_DCDCLNRUNNING);
   2902              while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2903              }
   2904              EMU->DCDCCTRL = (EMU->DCDCCTRL & ~_EMU_DCDCCTRL_DCDCMODE_MASK) | EMU_DCDCCTRL_DCDCMODE_LOWNOISE;
   2905              while ((EMU_IntGet() & EMU_IF_DCDCLNRUNNING) == 0U) {
   2906              }
   2907            }
   2908          #endif // (_SILICON_LABS_GECKO_INTERNAL_SDID_84)
   2909          
   2910            /* Set user-requested mode. */
   2911            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0UL) {
   2912            }
   2913            EMU->DCDCCTRL = (EMU->DCDCCTRL & ~_EMU_DCDCCTRL_DCDCMODE_MASK)
   2914                            | (uint32_t)dcdcMode;
   2915          
   2916            /* Disable bypass current limiter after bypass mode is entered.
   2917               Enable the limiter if any other mode is entered. */
   2918            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2919            }
   2920            BUS_RegBitWrite(&EMU->DCDCCLIMCTRL,
   2921                            _EMU_DCDCCLIMCTRL_BYPLIMEN_SHIFT,
   2922                            dcdcMode == emuDcdcMode_Bypass ? 0U : 1U);
   2923          
   2924            if (dcdcLocked) {
   2925              EMU_PowerLock();
   2926            }
   2927          }
   2928          
   2929          #if defined(EMU_DCDCCTRL_DCDCMODEEM23)
   2930          /***************************************************************************//**
   2931           * @brief
   2932           *   Set DCDC Mode EM23 operating mode.
   2933           *
   2934           * @param[in] dcdcModeEM23
   2935           *   DCDC mode EM23.
   2936           ******************************************************************************/
   2937          void EMU_DCDCModeEM23Set(EMU_DcdcModeEM23_TypeDef dcdcModeEM23)
   2938          {
   2939            bool dcdcLocked;
   2940          
   2941            dcdcLocked = (EMU->PWRLOCK == EMU_PWRLOCK_LOCKKEY_LOCKED);
   2942            EMU_PowerUnlock();
   2943          
   2944            /* Set user-requested mode. */
   2945            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0UL) {
   2946            }
   2947            EMU->DCDCCTRL = (EMU->DCDCCTRL & ~_EMU_DCDCCTRL_DCDCMODEEM23_MASK)
   2948                            | (uint32_t)dcdcModeEM23;
   2949          
   2950            if (dcdcLocked) {
   2951              EMU_PowerLock();
   2952            }
   2953          }
   2954          #endif
   2955          
   2956          /***************************************************************************//**
   2957           * @brief
   2958           *   Power off the DCDC regulator.
   2959           *
   2960           * @details
   2961           *   This function powers off the DCDC controller. This function should only be
   2962           *   used if the external power circuit is wired for no DCDC. If the external power
   2963           *   circuit is wired for DCDC usage, use @ref EMU_DCDCInit() and set the
   2964           *   DCDC in bypass mode to disable DCDC.
   2965           *
   2966           * @return
   2967           *   Return false if the DCDC could not be disabled.
   2968           ******************************************************************************/
   2969          bool EMU_DCDCPowerOff(void)
   2970          {
   2971            bool dcdcModeSet;
   2972          
   2973          #if defined(_EMU_PWRCFG_MASK)
   2974            /* Set DCDCTODVDD only to enable write access to EMU->DCDCCTRL. */
   2975            EMU->PWRCFG = EMU_PWRCFG_PWRCFG_DCDCTODVDD;
   2976          #endif
   2977          
   2978            /* Select DVDD as input to the digital regulator. */
   2979          #if defined(EMU_PWRCTRL_IMMEDIATEPWRSWITCH)
   2980            EMU->PWRCTRL |= EMU_PWRCTRL_REGPWRSEL_DVDD | EMU_PWRCTRL_IMMEDIATEPWRSWITCH;
   2981          #elif defined(EMU_PWRCTRL_REGPWRSEL_DVDD)
   2982            EMU->PWRCTRL |= EMU_PWRCTRL_REGPWRSEL_DVDD;
   2983          #endif
   2984          
   2985            /* Set DCDC to OFF and disable LP in EM2/3/4. Verify that the required
   2986               mode could be set. */
   2987            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2988            }
   2989            EMU->DCDCCTRL = EMU_DCDCCTRL_DCDCMODE_OFF;
   2990          
   2991            dcdcModeSet = (EMU->DCDCCTRL == EMU_DCDCCTRL_DCDCMODE_OFF);
   2992            EFM_ASSERT(dcdcModeSet);
   2993          
   2994            return dcdcModeSet;
   2995          }
   2996          
   2997          /***************************************************************************//**
   2998           * @brief
   2999           *   Set DCDC LN regulator conduction mode.
   3000           *
   3001           * @param[in] conductionMode
   3002           *   DCDC LN conduction mode.
   3003           * @param[in] rcoDefaultSet
   3004           *   The default DCDC RCO band for the conductionMode will be used if true.
   3005           *   Otherwise, the current RCO configuration is used.
   3006           ******************************************************************************/
   3007          void EMU_DCDCConductionModeSet(EMU_DcdcConductionMode_TypeDef conductionMode,
   3008                                         bool rcoDefaultSet)
   3009          {
   3010            EMU_DcdcMode_TypeDef currentDcdcMode
   3011              = (EMU_DcdcMode_TypeDef)((uint32_t)
   3012                                       (EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK));
   3013            EMU_DcdcLnRcoBand_TypeDef rcoBand
   3014              = (EMU_DcdcLnRcoBand_TypeDef)((uint32_t)
   3015                                            ((EMU->DCDCLNFREQCTRL
   3016                                              & _EMU_DCDCLNFREQCTRL_RCOBAND_MASK)
   3017                                             >> _EMU_DCDCLNFREQCTRL_RCOBAND_SHIFT));
   3018          
   3019            /* Set bypass mode and wait for bypass mode to settle before
   3020               EMU_DCDCMISCCTRL_LNFORCECCM is set. Restore current DCDC mode. */
   3021            EMU_IntClear(EMU_IFC_DCDCINBYPASS);
   3022            EMU_DCDCModeSet(emuDcdcMode_Bypass);
   3023            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   3024            }
   3025            while ((EMU_IntGet() & EMU_IF_DCDCINBYPASS) == 0U) {
   3026            }
   3027            if (conductionMode == emuDcdcConductionMode_DiscontinuousLN) {
   3028              EMU->DCDCMISCCTRL &= ~EMU_DCDCMISCCTRL_LNFORCECCM;
   3029              if (rcoDefaultSet) {
   3030                EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_3MHz);
   3031              } else {
   3032                /* emuDcdcConductionMode_DiscontinuousLN supports up to 4MHz LN RCO. */
   3033                EFM_ASSERT(rcoBand <= emuDcdcLnRcoBand_4MHz);
   3034              }
   3035            } else {
   3036              EMU->DCDCMISCCTRL |= EMU_DCDCMISCCTRL_LNFORCECCM;
   3037              if (rcoDefaultSet) {
   3038                EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_7MHz);
   3039              }
   3040            }
   3041            EMU_DCDCModeSet(currentDcdcMode);
   3042            /* Update slice configuration as it depends on conduction mode and RCO band.*/
   3043            EMU_DCDCOptimizeSlice(dcdcEm01LoadCurrent_mA);
   3044          }
   3045          
   3046          /***************************************************************************//**
   3047           * @brief
   3048           *   Set the DCDC output voltage.
   3049           *
   3050           * @note
   3051           *   The DCDC is not characterized for the entire valid output voltage range.
   3052           *   For that reason an upper limit of 3.0V output voltage is enforced.
   3053           *
   3054           * @param[in] mV
   3055           *   Target DCDC output voltage in mV.
   3056           *
   3057           * @param[in] setLpVoltage
   3058           *   Update LP voltage
   3059           *
   3060           * @param[in] setLnVoltage
   3061           *   Update LN voltage
   3062           *
   3063           * @return
   3064           *   True if the mV parameter is valid.
   3065           ******************************************************************************/
   3066          bool EMU_DCDCOutputVoltageSet(uint32_t mV,
   3067                                        bool setLpVoltage,
   3068                                        bool setLnVoltage)
   3069          {
   3070          #if defined(_DEVINFO_DCDCLNVCTRL0_3V0LNATT1_MASK)
   3071          
   3072            bool validOutVoltage;
   3073            bool attenuationSet;
   3074            uint32_t mVlow = 0;
   3075            uint32_t mVhigh = 0;
   3076            uint32_t mVdiff;
   3077            uint32_t vrefVal[DCDC_TRIM_MODES] = { 0 };
   3078            uint32_t vrefLow[DCDC_TRIM_MODES] = { 0 };
   3079            uint32_t vrefHigh[DCDC_TRIM_MODES] = { 0 };
   3080            uint8_t lpcmpBias[DCDC_TRIM_MODES] = { 0 };
   3081          
   3082            /* Check that the set voltage is within valid range.
   3083               Voltages are obtained from the data sheet. */
   3084            validOutVoltage = (mV >= PWRCFG_DCDCTODVDD_VMIN)
   3085                              && (mV <= PWRCFG_DCDCTODVDD_VMAX);
   3086          
   3087            if (!validOutVoltage) {
   3088              EFM_ASSERT(false);
   3089              /* Return when assertions are disabled. */
   3090              return false;
   3091            }
   3092          
   3093            /* Set attenuation to use and low/high range. */
   3094            attenuationSet = mV > 1800U;
   3095            if (attenuationSet) {
   3096              mVlow = 1800;
   3097              mVhigh = 3000;
   3098              mVdiff = mVhigh - mVlow;
   3099            } else {
   3100              mVlow = 1200;
   3101              mVhigh = 1800;
   3102              mVdiff = mVhigh - mVlow;
   3103            }
   3104          
   3105            /* Get 2-point calibration data from DEVINFO. */
   3106          
   3107            /* LN mode */
   3108            if (attenuationSet) {
   3109              vrefLow[dcdcTrimMode_LN]  = DEVINFO->DCDCLNVCTRL0;
   3110              vrefHigh[dcdcTrimMode_LN] = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_3V0LNATT1_MASK)
   3111                                          >> _DEVINFO_DCDCLNVCTRL0_3V0LNATT1_SHIFT;
   3112              vrefLow[dcdcTrimMode_LN]  = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_1V8LNATT1_MASK)
   3113                                          >> _DEVINFO_DCDCLNVCTRL0_1V8LNATT1_SHIFT;
   3114            } else {
   3115              vrefLow[dcdcTrimMode_LN]  = DEVINFO->DCDCLNVCTRL0;
   3116              vrefHigh[dcdcTrimMode_LN] = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_1V8LNATT0_MASK)
   3117                                          >> _DEVINFO_DCDCLNVCTRL0_1V8LNATT0_SHIFT;
   3118              vrefLow[dcdcTrimMode_LN]  = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_1V2LNATT0_MASK)
   3119                                          >> _DEVINFO_DCDCLNVCTRL0_1V2LNATT0_SHIFT;
   3120            }
   3121          
   3122            /* LP EM234H mode */
   3123            lpcmpBias[dcdcTrimMode_EM234H_LP] = (uint8_t)
   3124                                                ((EMU->DCDCMISCCTRL & _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK)
   3125                                                 >> _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT);
   3126            lpGetDevinfoVrefLowHigh(&vrefLow[dcdcTrimMode_EM234H_LP],
   3127                                    &vrefHigh[dcdcTrimMode_EM234H_LP],
   3128                                    attenuationSet,
   3129                                    lpcmpBias[dcdcTrimMode_EM234H_LP]);
   3130          
   3131          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   3132            /* LP EM01 mode */
   3133            lpcmpBias[dcdcTrimMode_EM01_LP] = (uint8_t)
   3134                                              ((EMU->DCDCLPEM01CFG & _EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   3135                                               >> _EMU_DCDCLPEM01CFG_LPCMPBIASEM01_SHIFT);
   3136            lpGetDevinfoVrefLowHigh(&vrefLow[dcdcTrimMode_EM01_LP],
   3137                                    &vrefHigh[dcdcTrimMode_EM01_LP],
   3138                                    attenuationSet,
   3139                                    lpcmpBias[dcdcTrimMode_EM01_LP]);
   3140          #endif
   3141          
   3142            /* Calculate output voltage trims. */
   3143            vrefVal[dcdcTrimMode_LN]         = ((mV - mVlow) * (vrefHigh[dcdcTrimMode_LN] - vrefLow[dcdcTrimMode_LN]))
   3144                                               / mVdiff;
   3145            vrefVal[dcdcTrimMode_LN]        += vrefLow[dcdcTrimMode_LN];
   3146          
   3147            vrefVal[dcdcTrimMode_EM234H_LP]  = ((mV - mVlow) * (vrefHigh[dcdcTrimMode_EM234H_LP] - vrefLow[dcdcTrimMode_EM234H_LP]))
   3148                                               / mVdiff;
   3149            vrefVal[dcdcTrimMode_EM234H_LP] += vrefLow[dcdcTrimMode_EM234H_LP];
   3150          
   3151          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   3152            vrefVal[dcdcTrimMode_EM01_LP]    = ((mV - mVlow) * (vrefHigh[dcdcTrimMode_EM01_LP] - vrefLow[dcdcTrimMode_EM01_LP]))
   3153                                               / mVdiff;
   3154            vrefVal[dcdcTrimMode_EM01_LP]   += vrefLow[dcdcTrimMode_EM01_LP];
   3155          #endif
   3156          
   3157            /* Range checks */
   3158            if ((vrefVal[dcdcTrimMode_LN] > vrefHigh[dcdcTrimMode_LN])
   3159                || (vrefVal[dcdcTrimMode_LN] < vrefLow[dcdcTrimMode_LN])
   3160          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   3161                || (vrefVal[dcdcTrimMode_EM01_LP] > vrefHigh[dcdcTrimMode_EM01_LP])
   3162                || (vrefVal[dcdcTrimMode_EM01_LP] < vrefLow[dcdcTrimMode_EM01_LP])
   3163          #endif
   3164                || (vrefVal[dcdcTrimMode_EM234H_LP] > vrefHigh[dcdcTrimMode_EM234H_LP])
   3165                || (vrefVal[dcdcTrimMode_EM234H_LP] < vrefLow[dcdcTrimMode_EM234H_LP])) {
   3166              EFM_ASSERT(false);
   3167              /* Return when assertions are disabled. */
   3168              return false;
   3169            }
   3170          
   3171            /* Update output voltage tuning for LN and LP modes. */
   3172            if (setLnVoltage) {
   3173              EMU->DCDCLNVCTRL = (EMU->DCDCLNVCTRL & ~(_EMU_DCDCLNVCTRL_LNVREF_MASK | _EMU_DCDCLNVCTRL_LNATT_MASK))
   3174                                 | (vrefVal[dcdcTrimMode_LN] << _EMU_DCDCLNVCTRL_LNVREF_SHIFT)
   3175                                 | (attenuationSet ? EMU_DCDCLNVCTRL_LNATT : 0U);
   3176            }
   3177          
   3178            if (setLpVoltage) {
   3179              /* Load LP EM234H comparator hysteresis calibration. */
   3180              if (!(lpCmpHystCalibrationLoad(attenuationSet, lpcmpBias[dcdcTrimMode_EM234H_LP], dcdcTrimMode_EM234H_LP))) {
   3181                EFM_ASSERT(false);
   3182                /* Return when assertions are disabled. */
   3183                return false;
   3184              }
   3185          
   3186          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   3187              /* Load LP EM234H comparator hysteresis calibration. */
   3188              if (!(lpCmpHystCalibrationLoad(attenuationSet, lpcmpBias[dcdcTrimMode_EM01_LP], dcdcTrimMode_EM01_LP))) {
   3189                EFM_ASSERT(false);
   3190                /* Return when assertions are disabled. */
   3191                return false;
   3192              }
   3193          
   3194              /* LP VREF is that maximum of trims for EM01 and EM234H. */
   3195              vrefVal[dcdcTrimMode_EM234H_LP] = SL_MAX(vrefVal[dcdcTrimMode_EM234H_LP], vrefVal[dcdcTrimMode_EM01_LP]);
   3196          #endif
   3197          
   3198              /* Don't exceed the maximum available code as specified in the reference manual for EMU_DCDCLPVCTRL. */
   3199              vrefVal[dcdcTrimMode_EM234H_LP] = SL_MIN(vrefVal[dcdcTrimMode_EM234H_LP], 0xE7U);
   3200              EMU->DCDCLPVCTRL = (EMU->DCDCLPVCTRL & ~(_EMU_DCDCLPVCTRL_LPVREF_MASK | _EMU_DCDCLPVCTRL_LPATT_MASK))
   3201                                 | (vrefVal[dcdcTrimMode_EM234H_LP] << _EMU_DCDCLPVCTRL_LPVREF_SHIFT)
   3202                                 | (attenuationSet ? EMU_DCDCLPVCTRL_LPATT : 0U);
   3203            }
   3204          #endif
   3205            return true;
   3206          }
   3207          
   3208          /***************************************************************************//**
   3209           * @brief
   3210           *   Optimize the DCDC slice count based on the estimated average load current
   3211           *   in EM0.
   3212           *
   3213           * @param[in] em0LoadCurrentmA
   3214           *   Estimated average EM0 load current in mA.
   3215           ******************************************************************************/
   3216          void EMU_DCDCOptimizeSlice(uint32_t em0LoadCurrentmA)
   3217          {
   3218            uint32_t sliceCount = 0;
   3219            uint32_t rcoBand = (EMU->DCDCLNFREQCTRL & _EMU_DCDCLNFREQCTRL_RCOBAND_MASK)
   3220                               >> _EMU_DCDCLNFREQCTRL_RCOBAND_SHIFT;
   3221          
   3222            /* Set the recommended slice count. */
   3223            if (((EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_LNFORCECCM_MASK) != 0U)
   3224                && (rcoBand >= (uint32_t)emuDcdcLnRcoBand_5MHz)) {
   3225              if (em0LoadCurrentmA < 20U) {
   3226                sliceCount = 4;
   3227              } else if ((em0LoadCurrentmA >= 20U) && (em0LoadCurrentmA < 40U)) {
   3228                sliceCount = 8;
   3229              } else {
   3230                sliceCount = 16;
   3231              }
   3232            } else if (((EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_LNFORCECCM_MASK) == 0U)
   3233                       && (rcoBand <= (uint32_t)emuDcdcLnRcoBand_4MHz)) {
   3234              if (em0LoadCurrentmA < 10U) {
   3235                sliceCount = 4;
   3236              } else if ((em0LoadCurrentmA >= 10U) && (em0LoadCurrentmA < 20U)) {
   3237                sliceCount = 8;
   3238              } else {
   3239                sliceCount = 16;
   3240              }
   3241            } else if (((EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_LNFORCECCM_MASK) != 0U)
   3242                       && (rcoBand <= (uint32_t)emuDcdcLnRcoBand_4MHz)) {
   3243              if (em0LoadCurrentmA < 40U) {
   3244                sliceCount = 8;
   3245              } else {
   3246                sliceCount = 16;
   3247              }
   3248            } else {
   3249              /* This configuration is not recommended. @ref EMU_DCDCInit() applies a recommended
   3250                 configuration. */
   3251              EFM_ASSERT(false);
   3252            }
   3253          
   3254            /* The selected slices are PSLICESEL + 1. */
   3255            sliceCount--;
   3256          
   3257            /* Apply slice count to both N and P slice. */
   3258            sliceCount = (sliceCount << _EMU_DCDCMISCCTRL_PFETCNT_SHIFT
   3259                          | sliceCount << _EMU_DCDCMISCCTRL_NFETCNT_SHIFT);
   3260            EMU->DCDCMISCCTRL = (EMU->DCDCMISCCTRL & ~(_EMU_DCDCMISCCTRL_PFETCNT_MASK
   3261                                                       | _EMU_DCDCMISCCTRL_NFETCNT_MASK))
   3262                                | sliceCount;
   3263          
   3264            /* Update the current limiters. */
   3265            currentLimitersUpdate();
   3266          }
   3267          
   3268          /***************************************************************************//**
   3269           * @brief
   3270           *   Set DCDC Low-noise RCO band.
   3271           *
   3272           * @param[in] band
   3273           *   RCO band to set.
   3274           ******************************************************************************/
   3275          void EMU_DCDCLnRcoBandSet(EMU_DcdcLnRcoBand_TypeDef band)
   3276          {
   3277            uint32_t forcedCcm;
   3278            forcedCcm = BUS_RegBitRead(&EMU->DCDCMISCCTRL, _EMU_DCDCMISCCTRL_LNFORCECCM_SHIFT);
   3279          
   3280            /* DCM mode supports up to 4 MHz LN RCO. */
   3281            EFM_ASSERT(((forcedCcm == 0U) && band <= emuDcdcLnRcoBand_4MHz)
   3282                       || (forcedCcm != 0U));
   3283          
   3284            EMU->DCDCLNFREQCTRL = (EMU->DCDCLNFREQCTRL & ~_EMU_DCDCLNFREQCTRL_RCOBAND_MASK)
   3285                                  | ((uint32_t)band << _EMU_DCDCLNFREQCTRL_RCOBAND_SHIFT);
   3286          
   3287            /* Update slice configuration as this depends on the RCO band. */
   3288            EMU_DCDCOptimizeSlice(dcdcEm01LoadCurrent_mA);
   3289          }
   3290          #endif /* EMU_SERIES1_DCDC_BUCK_PRESENT */
   3291          
   3292          #if defined(EMU_SERIES2_DCDC_BOOST_PRESENT)
   3293          /***************************************************************************//**
   3294           * @brief
   3295           *   Configure the DCDC Boost regulator.
   3296           *
   3297           * @param[in] dcdcBoostInit
   3298           *  The DCDC initialization structure.
   3299           *
   3300           * @return
   3301           *   True if initialization parameters are valid.
   3302           ******************************************************************************/
   3303          bool EMU_DCDCBoostInit(const EMU_DCDCBoostInit_TypeDef *dcdcBoostInit)
   3304          {
   3305            bool dcdcLocked;
   3306          
   3307            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   3308          #if defined(_DCDC_EN_EN_MASK)
   3309            DCDC->EN_SET    = DCDC_EN_EN;
   3310          #endif
   3311            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   3312            EMU_DCDCUnlock();
   3313          
   3314          #if defined(_DCDC_SYNCBUSY_MASK)
   3315            EMU_DCDCSync(_DCDC_SYNCBUSY_MASK);
   3316          #endif
   3317          
   3318            DCDC->BSTCTRL = (DCDC->BSTCTRL & ~(_DCDC_BSTCTRL_IPKTMAXCTRL_MASK))
   3319                            | ((uint32_t)dcdcBoostInit->tonMax << _DCDC_BSTCTRL_IPKTMAXCTRL_SHIFT);
   3320            DCDC->BSTEM01CTRL = ((uint32_t)dcdcBoostInit->driveSpeedEM01 << _DCDC_BSTEM01CTRL_DRVSPEED_SHIFT)
   3321                                | ((uint32_t)dcdcBoostInit->peakCurrentEM01 << _DCDC_BSTEM01CTRL_IPKVAL_SHIFT);
   3322            DCDC->BSTEM23CTRL = ((uint32_t)dcdcBoostInit->driveSpeedEM23 << _DCDC_BSTEM23CTRL_DRVSPEED_SHIFT)
   3323                                | ((uint32_t)dcdcBoostInit->peakCurrentEM23 << _DCDC_BSTEM23CTRL_IPKVAL_SHIFT);
   3324          
   3325            EMU_BoostExternalShutdownEnable(dcdcBoostInit->externalShutdownEn);
   3326          
   3327            EMU_DCDCModeSet(emuDcdcMode_Regulation);
   3328          
   3329            if (dcdcLocked) {
   3330              EMU_DCDCLock();
   3331            }
   3332          
   3333            EMU_DCDCUpdatedHook();
   3334          
   3335            return true;
   3336          }
   3337          
   3338          /***************************************************************************//**
   3339           * @brief
   3340           *   Set EM01 mode Boost Peak Current setting.
   3341           *
   3342           * @param[in] boostPeakCurrentEM01
   3343           *  Boost Peak load current coefficient in EM01 mode.
   3344           ******************************************************************************/
   3345          void EMU_EM01BoostPeakCurrentSet(const EMU_DcdcBoostEM01PeakCurrent_TypeDef boostPeakCurrentEM01)
   3346          {
   3347            bool dcdcLocked = false;
   3348            bool dcdcClkWasEnabled = false;
   3349          
   3350            dcdcClkWasEnabled = ((CMU->CLKEN0 & CMU_CLKEN0_DCDC) != 0);
   3351            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   3352          
   3353            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   3354            EMU_DCDCUnlock();
   3355          
   3356            /* Wait for synchronization before writing new value */
   3357          #if defined(_DCDC_SYNCBUSY_MASK)
   3358            EMU_DCDCSync(_DCDC_SYNCBUSY_MASK);
   3359          #endif
   3360          
   3361            BUS_RegMaskedWrite(&DCDC->BSTEM01CTRL,
   3362                               _DCDC_BSTEM01CTRL_IPKVAL_MASK,
   3363                               ((uint32_t)boostPeakCurrentEM01 << _DCDC_BSTEM01CTRL_IPKVAL_SHIFT));
   3364          
   3365            if (dcdcLocked) {
   3366              EMU_DCDCLock();
   3367            }
   3368          
   3369            if (!dcdcClkWasEnabled) {
   3370              CMU->CLKEN0_CLR = CMU_CLKEN0_DCDC;
   3371            }
   3372          
   3373            EMU_DCDCUpdatedHook();
   3374          }
   3375          
   3376          /***************************************************************************//**
   3377           * @brief
   3378           *   Enable/disable Boost External Shutdown Mode.
   3379           *
   3380           * @param[in] enable
   3381           *   The boost DC-DC converter can be activated or deactivated
   3382           *   from a dedicated BOOST_EN pin on the device if enable is true.
   3383           ******************************************************************************/
   3384          void EMU_BoostExternalShutdownEnable(bool enable)
   3385          {
   3386            if (enable) {
   3387              EMU->BOOSTCTRL_CLR = EMU_BOOSTCTRL_BOOSTENCTRL;
   3388            } else {
   3389              EMU->BOOSTCTRL_SET = EMU_BOOSTCTRL_BOOSTENCTRL;
   3390            }
   3391          }
   3392          #endif /* EMU_SERIES2_DCDC_BOOST_PRESENT */
   3393          
   3394          #if defined(EMU_SERIES2_DCDC_BUCK_PRESENT) \
   3395            || defined(EMU_SERIES2_DCDC_BOOST_PRESENT)
   3396          /***************************************************************************//**
   3397           * @brief
   3398           *   Indicate that the DCDC peripheral bus clock enable has changed allowing
   3399           *   RAIL to react accordingly.
   3400           *
   3401           * @details
   3402           *   This function is called after DCDC has been enabled or disabled.
   3403           *   The function implementation does not perform anything, but it is SL_WEAK
   3404           *   so that it can use the RAIL version if needed.
   3405           ******************************************************************************/

   \                                 In section .text, align 2
   3406          SL_WEAK void EMU_DCDCUpdatedHook(void)
   3407          {
   3408          }
   \                     EMU_DCDCUpdatedHook: (+1)
   \        0x0   0x4770             BX       LR
   3409          
   3410          /***************************************************************************//**
   3411           * @brief
   3412           *   Set DCDC regulator operating mode.
   3413           *
   3414           * @param[in] dcdcMode
   3415           *   DCDC mode.
   3416           * @return
   3417           *   Returns the status of the DCDC mode set operation.
   3418           * @verbatim
   3419           *   SL_STATUS_OK - Operation completed successfully.
   3420           *   SL_STATUS_TIMEOUT - Operation EMU DCDC set mode timeout.
   3421           * @endverbatim
   3422           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3423          sl_status_t EMU_DCDCModeSet(EMU_DcdcMode_TypeDef dcdcMode)
   3424          {
   3425            bool dcdcLocked;
   3426            uint32_t currentDcdcMode;
   3427            sl_status_t error = SL_STATUS_OK;
   3428            uint32_t timeout = 0;
   3429            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   \                     EMU_DCDCModeSet: (+1)
   \        0x0   0xF04F 0x4200      MOV      R2,#+2147483648
   \        0x4   0x....             LDR.N    R1,??DataTable18_12
   \        0x6   0xB5F8             PUSH     {R3-R7,LR}
   \        0x8   0x600A             STR      R2,[R1, #+0]
   3430          #if defined(_DCDC_EN_EN_MASK)
   3431            DCDC->EN_SET = DCDC_EN_EN;
   3432          #endif
   3433            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   \        0xA   0x....             LDR.N    R1,??DataTable18_17
   \        0xC   0x6C0A             LDR      R2,[R1, #+64]
   3434            EMU_DCDCUnlock();
   \        0xE   0xF64A 0x33CD      MOVW     R3,#+43981
   \       0x12   0x63CB             STR      R3,[R1, #+60]
   \       0x14   0x2400             MOVS     R4,#+0
   \       0x16   0x2600             MOVS     R6,#+0
   \       0x18   0xF002 0x0201      AND      R2,R2,#0x1
   3435          
   3436            if (dcdcMode == emuDcdcMode_Bypass) {
   \       0x1C   0x....             LDR.N    R3,??DataTable18_18
   \       0x1E   0x....             LDR.N    R5,??DataTable18_19
   \       0x20   0xB988             CBNZ.N   R0,??EMU_DCDCModeSet_0
   \                     ??EMU_DCDCModeSet_1: (+1)
   \       0x22   0x6B0F             LDR      R7,[R1, #+48]
   \       0x24   0x07F8             LSLS     R0,R7,#+31
   \       0x26   0xD4FC             BMI.N    ??EMU_DCDCModeSet_1
   3437          #if defined(_DCDC_SYNCBUSY_MASK)
   3438          #if defined(_DCDC_SYNCBUSY_CTRL_MASK)
   3439              EMU_DCDCSync(DCDC_SYNCBUSY_CTRL);
   3440          #else
   3441              EMU_DCDCSync(_DCDC_SYNCBUSY_MASK);
   3442          #endif
   3443          #endif
   3444              currentDcdcMode = (DCDC->CTRL & _DCDC_CTRL_MODE_MASK) >> _DCDC_CTRL_MODE_SHIFT;
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   3445          
   3446              if (currentDcdcMode != emuDcdcMode_Bypass) {
   \       0x2A   0x07C7             LSLS     R7,R0,#+31
   \       0x2C   0xD522             BPL.N    ??EMU_DCDCModeSet_2
   3447                /* Switch to BYPASS mode if it is not the current mode */
   3448                DCDC->CTRL_CLR = DCDC_CTRL_MODE;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x6028             STR      R0,[R5, #+0]
   \       0x32   0xE000             B.N      ??EMU_DCDCModeSet_3
   3449                while (((DCDC->STATUS & DCDC_STATUS_BYPSW) == 0U) && (timeout < EMU_DCDC_MODE_SET_TIMEOUT)) {
   3450                  /* Wait for BYPASS switch enable. */
   3451                  timeout++;
   \                     ??EMU_DCDCModeSet_4: (+1)
   \       0x34   0x1C76             ADDS     R6,R6,#+1
   3452                }
   \                     ??EMU_DCDCModeSet_3: (+1)
   \       0x36   0x6ACD             LDR      R5,[R1, #+44]
   \       0x38   0x07E8             LSLS     R0,R5,#+31
   \       0x3A   0xD401             BMI.N    ??EMU_DCDCModeSet_5
   \       0x3C   0x429E             CMP      R6,R3
   \       0x3E   0xD3F9             BCC.N    ??EMU_DCDCModeSet_4
   3453                if (timeout >= EMU_DCDC_MODE_SET_TIMEOUT) {
   \                     ??EMU_DCDCModeSet_5: (+1)
   \       0x40   0x429E             CMP      R6,R3
   \       0x42   0xE015             B.N      ??EMU_DCDCModeSet_6
   3454                  error = SL_STATUS_TIMEOUT;
   3455                }
   3456              }
   3457          #if defined(_DCDC_EN_EN_MASK)
   3458              DCDC->EN_CLR = DCDC_EN_EN;
   3459          #endif
   3460            } else {
   3461              while (((DCDC->STATUS & DCDC_STATUS_VREGIN) != 0U) && (timeout < EMU_DCDC_MODE_SET_TIMEOUT)) {
   3462                /* Wait for VREGIN voltage to rise above threshold. */
   3463                timeout++;
   \                     ??EMU_DCDCModeSet_7: (+1)
   \       0x44   0x1C76             ADDS     R6,R6,#+1
   3464              }
   \                     ??EMU_DCDCModeSet_0: (+1)
   \       0x46   0x6ACF             LDR      R7,[R1, #+44]
   \       0x48   0x0738             LSLS     R0,R7,#+28
   \       0x4A   0xD501             BPL.N    ??EMU_DCDCModeSet_8
   \       0x4C   0x429E             CMP      R6,R3
   \       0x4E   0xD3F9             BCC.N    ??EMU_DCDCModeSet_7
   3465              if (timeout >= EMU_DCDC_MODE_SET_TIMEOUT) {
   \                     ??EMU_DCDCModeSet_8: (+1)
   \       0x50   0x429E             CMP      R6,R3
   \       0x52   0xD20E             BCS.N    ??EMU_DCDCModeSet_9
   3466                error = SL_STATUS_TIMEOUT;
   3467              } else {
   3468                DCDC->IF_CLR = DCDC_IF_REGULATION;
   \       0x54   0x2620             MOVS     R6,#+32
   \       0x56   0x626E             STR      R6,[R5, #+36]
   3469                DCDC->CTRL_SET = DCDC_CTRL_MODE;
   \       0x58   0x2501             MOVS     R5,#+1
   \       0x5A   0x....             LDR.N    R0,??DataTable18_20
   \       0x5C   0x6005             STR      R5,[R0, #+0]
   3470                timeout = 0;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE000             B.N      ??EMU_DCDCModeSet_10
   3471                while (((DCDC->IF & DCDC_IF_REGULATION) == 0U) && (timeout < EMU_DCDC_MODE_SET_TIMEOUT)) {
   3472                  /* Wait for DCDC to complete it's startup. */
   3473                  timeout++;
   \                     ??EMU_DCDCModeSet_11: (+1)
   \       0x62   0x1C40             ADDS     R0,R0,#+1
   3474                }
   \                     ??EMU_DCDCModeSet_10: (+1)
   \       0x64   0x6A4E             LDR      R6,[R1, #+36]
   \       0x66   0x06B5             LSLS     R5,R6,#+26
   \       0x68   0xD401             BMI.N    ??EMU_DCDCModeSet_12
   \       0x6A   0x4298             CMP      R0,R3
   \       0x6C   0xD3F9             BCC.N    ??EMU_DCDCModeSet_11
   3475                if (timeout >= EMU_DCDC_MODE_SET_TIMEOUT) {
   \                     ??EMU_DCDCModeSet_12: (+1)
   \       0x6E   0x4298             CMP      R0,R3
   \                     ??EMU_DCDCModeSet_6: (+1)
   \       0x70   0xD300             BCC.N    ??EMU_DCDCModeSet_2
   3476                  error = SL_STATUS_TIMEOUT;
   \                     ??EMU_DCDCModeSet_9: (+1)
   \       0x72   0x2407             MOVS     R4,#+7
   3477                }
   3478              }
   3479            }
   3480          
   3481            if (dcdcLocked) {
   \                     ??EMU_DCDCModeSet_2: (+1)
   \       0x74   0xB10A             CBZ.N    R2,??EMU_DCDCModeSet_13
   3482              EMU_DCDCLock();
   \       0x76   0x....             LDR.N    R0,??DataTable18_21
   \       0x78   0x63C8             STR      R0,[R1, #+60]
   3483            }
   3484          
   3485            EMU_DCDCUpdatedHook();
   \                     ??EMU_DCDCModeSet_13: (+1)
   \       0x7A   0x.... 0x....      BL       EMU_DCDCUpdatedHook
   3486            return error;
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0xBDF2             POP      {R1,R4-R7,PC}
   3487          }
   3488          #endif /* EMU_SERIES2_DCDC_BUCK_PRESENT || EMU_SERIES2_DCDC_BOOST_PRESENT */
   3489          
   3490          #if defined(EMU_SERIES2_DCDC_BUCK_PRESENT)
   3491          /***************************************************************************//**
   3492           * @brief
   3493           *   Configure the DCDC regulator.
   3494           *
   3495           * @param[in] dcdcInit
   3496           *  The DCDC initialization structure.
   3497           *
   3498           * @return
   3499           *   True if initialization parameters are valid.
   3500           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3501          bool EMU_DCDCInit(const EMU_DCDCInit_TypeDef *dcdcInit)
   3502          {
   \                     EMU_DCDCInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3503            bool dcdcLocked;
   3504          
   3505            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   \        0x2   0xF04F 0x4200      MOV      R2,#+2147483648
   \        0x6   0x....             LDR.N    R1,??DataTable18_12
   \        0x8   0x600A             STR      R2,[R1, #+0]
   3506          #if defined(_DCDC_EN_EN_MASK)
   3507            DCDC->EN_SET    = DCDC_EN_EN;
   3508          #endif
   3509            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   3510            EMU_DCDCUnlock();
   \        0xA   0xF64A 0x31CD      MOVW     R1,#+43981
   \        0xE   0x....             LDR.N    R4,??DataTable18_17
   \       0x10   0x6C25             LDR      R5,[R4, #+64]
   \       0x12   0x63E1             STR      R1,[R4, #+60]
   3511          
   3512            EMU->VREGVDDCMPCTRL = ((uint32_t)dcdcInit->cmpThreshold
   3513                                   << _EMU_VREGVDDCMPCTRL_THRESSEL_SHIFT)
   3514                                  | EMU_VREGVDDCMPCTRL_VREGINCMPEN;
   \       0x14   0x7842             LDRB     R2,[R0, #+1]
   \       0x16   0x....             LDR.N    R1,??DataTable18_22
   \       0x18   0xF005 0x0501      AND      R5,R5,#0x1
   \       0x1C   0x0052             LSLS     R2,R2,#+1
   \       0x1E   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x22   0x600A             STR      R2,[R1, #+0]
   3515          
   3516          #if defined(_DCDC_SYNCBUSY_MASK)
   3517          #if defined(_DCDC_SYNCBUSY_CTRL_MASK)
   3518            EMU_DCDCSync(DCDC_SYNCBUSY_CTRL | DCDC_SYNCBUSY_EM01CTRL0 | DCDC_SYNCBUSY_EM23CTRL0);
   \                     ??EMU_DCDCInit_0: (+1)
   \       0x24   0x6B22             LDR      R2,[R4, #+48]
   \       0x26   0xF012 0x0F0B      TST      R2,#0xB
   \       0x2A   0xD1FB             BNE.N    ??EMU_DCDCInit_0
   3519          #else
   3520            EMU_DCDCSync(_DCDC_SYNCBUSY_MASK);
   3521          #endif
   3522          #endif
   3523          #if defined(_DCDC_CTRL_DCMONLYEN_MASK)
   3524            DCDC->CTRL = (DCDC->CTRL & ~(_DCDC_CTRL_IPKTMAXCTRL_MASK
   3525                                         | _DCDC_CTRL_DCMONLYEN_MASK))
   3526                         | ((uint32_t)dcdcInit->tonMax << _DCDC_CTRL_IPKTMAXCTRL_SHIFT)
   3527                         | ((uint32_t)(dcdcInit->dcmOnlyEn ? 1U : 0U) << _DCDC_CTRL_DCMONLYEN_SHIFT);
   3528          #else
   3529            DCDC->CTRL = (DCDC->CTRL & ~(_DCDC_CTRL_IPKTMAXCTRL_MASK))
   3530                         | ((uint32_t)dcdcInit->tonMax << _DCDC_CTRL_IPKTMAXCTRL_SHIFT);
   \       0x2C   0x6822             LDR      R2,[R4, #+0]
   \       0x2E   0x7881             LDRB     R1,[R0, #+2]
   \       0x30   0xF422 0x72F8      BIC      R2,R2,#0x1F0
   \       0x34   0xEA42 0x1201      ORR      R2,R2,R1, LSL #+4
   \       0x38   0x6022             STR      R2,[R4, #+0]
   3531          #endif
   3532            DCDC->EM01CTRL0 = ((uint32_t)dcdcInit->driveSpeedEM01 << _DCDC_EM01CTRL0_DRVSPEED_SHIFT)
   3533                              | ((uint32_t)dcdcInit->peakCurrentEM01 << _DCDC_EM01CTRL0_IPKVAL_SHIFT);
   \       0x3A   0x78C2             LDRB     R2,[R0, #+3]
   \       0x3C   0x7941             LDRB     R1,[R0, #+5]
   \       0x3E   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x42   0x6061             STR      R1,[R4, #+4]
   3534            DCDC->EM23CTRL0 = ((uint32_t)dcdcInit->driveSpeedEM23 << _DCDC_EM23CTRL0_DRVSPEED_SHIFT)
   3535                              | ((uint32_t)dcdcInit->peakCurrentEM23 << _DCDC_EM23CTRL0_IPKVAL_SHIFT);
   \       0x44   0x7902             LDRB     R2,[R0, #+4]
   \       0x46   0x7981             LDRB     R1,[R0, #+6]
   \       0x48   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x4C   0x60E1             STR      R1,[R4, #+12]
   3536          
   3537            EMU_DCDCModeSet(dcdcInit->mode);
   \       0x4E   0x7800             LDRB     R0,[R0, #+0]
   \       0x50   0x.... 0x....      BL       EMU_DCDCModeSet
   3538          
   3539            if (dcdcLocked) {
   \       0x54   0xB10D             CBZ.N    R5,??EMU_DCDCInit_1
   3540              EMU_DCDCLock();
   \       0x56   0x....             LDR.N    R0,??DataTable18_21
   \       0x58   0x63E0             STR      R0,[R4, #+60]
   3541            }
   3542          
   3543            EMU_DCDCUpdatedHook();
   \                     ??EMU_DCDCInit_1: (+1)
   \       0x5A   0x.... 0x....      BL       EMU_DCDCUpdatedHook
   3544          
   3545            return true;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}
   3546          }
   3547          
   3548          /***************************************************************************//**
   3549           * @brief
   3550           *   Power off the DCDC regulator.
   3551           *
   3552           * @return
   3553           *   Returns true.
   3554           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3555          bool EMU_DCDCPowerOff(void)
   3556          {
   \                     EMU_DCDCPowerOff: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3557            EMU_DCDCModeSet(emuDcdcMode_Bypass);
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      BL       EMU_DCDCModeSet
   3558            return true;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xBD02             POP      {R1,PC}
   3559          }
   3560          
   3561          /***************************************************************************//**
   3562           * @brief
   3563           *   Set EMO1 mode Peak Current setting.
   3564           *
   3565           * @param[in] peakCurrentEM01
   3566           *  Peak load current coefficient in EM01 mode.
   3567           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3568          void EMU_EM01PeakCurrentSet(const EMU_DcdcPeakCurrent_TypeDef peakCurrentEM01)
   3569          {
   \                     EMU_EM01PeakCurrentSet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   3570            bool dcdcLocked = false;
   3571            bool dcdcClkWasEnabled = false;
   3572          
   3573            dcdcClkWasEnabled = ((CMU->CLKEN0 & CMU_CLKEN0_DCDC) != 0);
   3574            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   \        0x6   0xF04F 0x4500      MOV      R5,#+2147483648
   \        0xA   0x....             LDR.N    R0,??DataTable18_23
   3575          
   3576          #if defined(_DCDC_EN_EN_MASK)
   3577            bool dcdcWasEnabled = ((DCDC->EN & DCDC_EN_EN) != 0);
   3578            DCDC->EN_SET = DCDC_EN_EN;
   3579          #endif
   3580          
   3581            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   \        0xC   0x....             LDR.N    R6,??DataTable18_24
   \        0xE   0x6804             LDR      R4,[R0, #+0]
   \       0x10   0x....             LDR.N    R0,??DataTable18_12
   \       0x12   0x6005             STR      R5,[R0, #+0]
   \       0x14   0x6BF7             LDR      R7,[R6, #+60]
   3582            EMU_DCDCUnlock();
   \       0x16   0xF64A 0x30CD      MOVW     R0,#+43981
   \       0x1A   0x0FE4             LSRS     R4,R4,#+31
   \       0x1C   0xF007 0x0701      AND      R7,R7,#0x1
   \       0x20   0x63B0             STR      R0,[R6, #+56]
   3583          
   3584            /* Wait for synchronization before writing new value */
   3585          #if defined(_DCDC_SYNCBUSY_MASK)
   3586          #if defined(_DCDC_SYNCBUSY_EM01CTRL0_MASK)
   3587            EMU_DCDCSync(DCDC_SYNCBUSY_EM01CTRL0);
   \                     ??EMU_EM01PeakCurrentSet_0: (+1)
   \       0x22   0x6AF1             LDR      R1,[R6, #+44]
   \       0x24   0x0788             LSLS     R0,R1,#+30
   \       0x26   0xD4FC             BMI.N    ??EMU_EM01PeakCurrentSet_0
   3588          #else
   3589            EMU_DCDCSync(_DCDC_SYNCBUSY_MASK);
   3590          #endif
   3591          #endif
   3592          
   3593            BUS_RegMaskedWrite(&DCDC->EM01CTRL0,
   3594                               _DCDC_EM01CTRL0_IPKVAL_MASK,
   3595                               ((uint32_t)peakCurrentEM01 << _DCDC_EM01CTRL0_IPKVAL_SHIFT));
   \       0x28   0x.... 0x....      BL       CORE_EnterCritical
   \       0x2C   0x6831             LDR      R1,[R6, #+0]
   \       0x2E   0xF368 0x0103      BFI      R1,R8,#+0,#+4
   \       0x32   0x6031             STR      R1,[R6, #+0]
   \       0x34   0x.... 0x....      BL       CORE_ExitCritical
   3596          
   3597          #if defined(_DCDC_EN_EN_MASK)
   3598            if (!dcdcWasEnabled) {
   3599              DCDC->EN_CLR = DCDC_EN_EN;
   3600            }
   3601          #endif
   3602          
   3603            if (dcdcLocked) {
   \       0x38   0xB10F             CBZ.N    R7,??EMU_EM01PeakCurrentSet_1
   3604              EMU_DCDCLock();
   \       0x3A   0x....             LDR.N    R0,??DataTable18_21
   \       0x3C   0x63B0             STR      R0,[R6, #+56]
   3605            }
   3606          
   3607            if (!dcdcClkWasEnabled) {
   \                     ??EMU_EM01PeakCurrentSet_1: (+1)
   \       0x3E   0xB90C             CBNZ.N   R4,??EMU_EM01PeakCurrentSet_2
   3608              CMU->CLKEN0_CLR = CMU_CLKEN0_DCDC;
   \       0x40   0x....             LDR.N    R0,??DataTable18_25
   \       0x42   0x6005             STR      R5,[R0, #+0]
   3609            }
   3610          
   3611            EMU_DCDCUpdatedHook();
   \                     ??EMU_EM01PeakCurrentSet_2: (+1)
   \       0x44   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x48   0x.... 0x....      B.W      EMU_DCDCUpdatedHook
   3612          }
   3613          
   3614          #if defined(_DCDC_PFMXCTRL_IPKVAL_MASK)
   3615          /***************************************************************************//**
   3616           * @brief
   3617           *   Set PFMX mode Peak Current setting.
   3618           *
   3619           * @param[in] value
   3620           *  Peak load current coefficient in PFMX mode.
   3621           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3622          void EMU_DCDCSetPFMXModePeakCurrent(uint32_t value)
   3623          {
   \                     EMU_DCDCSetPFMXModePeakCurrent: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   3624            bool dcdcLocked = false;
   3625            bool dcdcClkWasEnabled = false;
   3626          
   3627            /* Verification that the parameter is in range. */
   3628            /* if not, restrict value to maximum allowed.   */
   3629            EFM_ASSERT(value <= (_DCDC_PFMXCTRL_IPKVAL_MASK >> _DCDC_PFMXCTRL_IPKVAL_SHIFT));
   \        0x2   0x2810             CMP      R0,#+16
   \        0x4   0xD305             BCC.N    ??EMU_DCDCSetPFMXModePeakCurrent_0
   \        0x6   0xF640 0x612D      MOVW     R1,#+3629
   \        0xA   0x....             LDR.N    R0,??DataTable18_10
   \        0xC   0x.... 0x....      BL       assertEFM
   3630            if (value > (_DCDC_PFMXCTRL_IPKVAL_MASK >> _DCDC_PFMXCTRL_IPKVAL_SHIFT)) {
   3631              value = (_DCDC_PFMXCTRL_IPKVAL_MASK >> _DCDC_PFMXCTRL_IPKVAL_SHIFT);
   \       0x10   0x200F             MOVS     R0,#+15
   3632            }
   3633          
   3634            dcdcClkWasEnabled = ((CMU->CLKEN0 & CMU_CLKEN0_DCDC) != 0);
   3635            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   \                     ??EMU_DCDCSetPFMXModePeakCurrent_0: (+1)
   \       0x12   0xF04F 0x4200      MOV      R2,#+2147483648
   \       0x16   0x....             LDR.N    R3,??DataTable18_12
   \       0x18   0x.... 0x....      BL       ?Subroutine5
   3636          
   3637            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   3638            EMU_DCDCUnlock();
   3639          
   3640          #if defined(_DCDC_SYNCBUSY_MASK)
   3641            /* Wait for synchronization before writing new value */
   3642            EMU_DCDCSync(DCDC_SYNCBUSY_PFMXCTRL);
   3643          #endif
   3644          
   3645            DCDC->PFMXCTRL = ((DCDC->PFMXCTRL & ~_DCDC_PFMXCTRL_IPKVAL_MASK)
   3646                              | value << _DCDC_PFMXCTRL_IPKVAL_SHIFT);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x1C   0x092D             LSRS     R5,R5,#+4
   \       0x1E   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \       0x22   0x6018             STR      R0,[R3, #+0]
   3647          
   3648            if (dcdcLocked) {
   \       0x24   0x....             B.N      ?Subroutine3
   3649              EMU_DCDCLock();
   3650            }
   3651          
   3652            if (!dcdcClkWasEnabled) {
   3653              CMU->CLKEN0_CLR = CMU_CLKEN0_DCDC;
   3654            }
   3655          
   3656            EMU_DCDCUpdatedHook();
   3657          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xB10C             CBZ.N    R4,??Subroutine3_0
   \        0x2   0x....             LDR.N    R0,??DataTable18_21
   \        0x4   0x6218             STR      R0,[R3, #+32]
   \                     ??Subroutine3_0: (+1)
   \        0x6   0xB909             CBNZ.N   R1,??Subroutine3_1
   \        0x8   0x....             LDR.N    R0,??DataTable18_25
   \        0xA   0x6002             STR      R2,[R0, #+0]
   \                     ??Subroutine3_1: (+1)
   \        0xC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x10   0x.... 0x....      B.W      EMU_DCDCUpdatedHook

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable18_23
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x601A             STR      R2,[R3, #+0]
   \        0x6   0x....             LDR.N    R3,??DataTable18_26
   \        0x8   0x6A5C             LDR      R4,[R3, #+36]
   \        0xA   0xF64A 0x35CD      MOVW     R5,#+43981
   \        0xE   0x0FC9             LSRS     R1,R1,#+31
   \       0x10   0xF004 0x0401      AND      R4,R4,#0x1
   \       0x14   0x621D             STR      R5,[R3, #+32]
   \                     ??Subroutine5_0: (+1)
   \       0x16   0x695D             LDR      R5,[R3, #+20]
   \       0x18   0x062E             LSLS     R6,R5,#+24
   \       0x1A   0xD4FC             BMI.N    ??Subroutine5_0
   \       0x1C   0x681D             LDR      R5,[R3, #+0]
   \       0x1E   0x4770             BX       LR
   3658          #endif /* _DCDC_PFMXCTRL_IPKVAL_MASK */
   3659          
   3660          #if defined(_DCDC_PFMXCTRL_IPKTMAXCTRL_MASK)
   3661          /***************************************************************************//**
   3662           * @brief
   3663           *   Set Ton_max timeout control.
   3664           *
   3665           * @param[in] value
   3666           *  Maximum time for peak current detection.
   3667           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3668          void EMU_DCDCSetPFMXTimeoutMaxCtrl(EMU_DcdcTonMaxTimeout_TypeDef value)
   3669          {
   3670            bool dcdcLocked = false;
   3671            bool dcdcClkWasEnabled = false;
   3672          
   3673            dcdcClkWasEnabled = ((CMU->CLKEN0 & CMU_CLKEN0_DCDC) != 0);
   3674            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   \                     EMU_DCDCSetPFMXTimeoutMaxCtrl: (+1)
   \        0x0   0xF04F 0x4200      MOV      R2,#+2147483648
   \        0x4   0x....             LDR.N    R3,??DataTable18_12
   \        0x6   0xB570             PUSH     {R4-R6,LR}
   \        0x8   0x.... 0x....      BL       ?Subroutine5
   3675          
   3676            dcdcLocked = ((DCDC->LOCKSTATUS & DCDC_LOCKSTATUS_LOCK) != 0);
   3677            EMU_DCDCUnlock();
   3678          
   3679          #if defined(_DCDC_SYNCBUSY_MASK)
   3680            /* Wait for synchronization before writing new value */
   3681            EMU_DCDCSync(DCDC_SYNCBUSY_PFMXCTRL);
   3682          #endif
   3683          
   3684            DCDC->PFMXCTRL = ((DCDC->PFMXCTRL & ~_DCDC_PFMXCTRL_IPKTMAXCTRL_MASK)
   3685                              | value << _DCDC_PFMXCTRL_IPKTMAXCTRL_SHIFT);
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xC   0xF425 0x55F8      BIC      R5,R5,#0x1F00
   \       0x10   0xEA45 0x2500      ORR      R5,R5,R0, LSL #+8
   \       0x14   0x601D             STR      R5,[R3, #+0]
   3686          
   3687            if (dcdcLocked) {
   \       0x16                      REQUIRE ?Subroutine3
   \       0x16                      ;; // Fall through to label ?Subroutine3
   3688              EMU_DCDCLock();
   3689            }
   3690          
   3691            if (!dcdcClkWasEnabled) {
   3692              CMU->CLKEN0_CLR = CMU_CLKEN0_DCDC;
   3693            }
   3694          
   3695            EMU_DCDCUpdatedHook();
   3696          }
   3697          #endif /* _DCDC_PFMXCTRL_IPKTMAXCTRL_MASK */
   3698          #endif /* EMU_SERIES2_DCDC_BUCK_PRESENT */
   3699          
   3700          #if defined(EMU_STATUS_VMONRDY)
   3701          
   3702          /***************************************************************************//**
   3703           * @brief
   3704           *   Get the calibrated threshold value.
   3705           *
   3706           * @details
   3707           *   All VMON channels have two calibration fields in the DI page that
   3708           *   describes the threshold at 1.86 V and 2.98 V. This function will convert
   3709           *   the uncalibrated input voltage threshold in millivolts into a calibrated
   3710           *   threshold.
   3711           *
   3712           * @param[in] channel
   3713           *   A VMON channel.
   3714           *
   3715           * @param[in] threshold
   3716           *   A desired threshold in millivolts.
   3717           *
   3718           * @return
   3719           *   A calibrated threshold value to use. The first digit of the return value is placed
   3720           *   in the "fine" register fields while the next digits are placed in the
   3721           *   "coarse" register fields.
   3722           ******************************************************************************/
   3723          static uint32_t vmonCalibratedThreshold(EMU_VmonChannel_TypeDef channel,
   3724                                                  int threshold)
   3725          {
   3726            uint32_t tDiff = 0;
   3727            uint32_t tLow = 0;
   3728            uint32_t tHigh = 0;
   3729            uint32_t calReg;
   3730          
   3731            /* Get calibration values for 1.86 V and 2.98 V */
   3732            switch (channel) {
   3733              case emuVmonChannel_AVDD:
   3734                calReg = DEVINFO->VMONCAL0;
   3735                tLow = (10U * ((calReg & _DEVINFO_VMONCAL0_AVDD1V86THRESCOARSE_MASK)
   3736                               >> _DEVINFO_VMONCAL0_AVDD1V86THRESCOARSE_SHIFT))
   3737                       + ((calReg & _DEVINFO_VMONCAL0_AVDD1V86THRESFINE_MASK)
   3738                          >> _DEVINFO_VMONCAL0_AVDD1V86THRESFINE_SHIFT);
   3739                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL0_AVDD2V98THRESCOARSE_MASK)
   3740                                >> _DEVINFO_VMONCAL0_AVDD2V98THRESCOARSE_SHIFT))
   3741                        + ((calReg & _DEVINFO_VMONCAL0_AVDD2V98THRESFINE_MASK)
   3742                           >> _DEVINFO_VMONCAL0_AVDD2V98THRESFINE_SHIFT);
   3743                break;
   3744              case emuVmonChannel_ALTAVDD:
   3745                calReg = DEVINFO->VMONCAL0;
   3746                tLow = (10U * ((calReg & _DEVINFO_VMONCAL0_ALTAVDD1V86THRESCOARSE_MASK)
   3747                               >> _DEVINFO_VMONCAL0_ALTAVDD1V86THRESCOARSE_SHIFT))
   3748                       + ((calReg & _DEVINFO_VMONCAL0_ALTAVDD1V86THRESFINE_MASK)
   3749                          >> _DEVINFO_VMONCAL0_ALTAVDD1V86THRESFINE_SHIFT);
   3750                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL0_ALTAVDD2V98THRESCOARSE_MASK)
   3751                                >> _DEVINFO_VMONCAL0_ALTAVDD2V98THRESCOARSE_SHIFT))
   3752                        + ((calReg & _DEVINFO_VMONCAL0_ALTAVDD2V98THRESFINE_MASK)
   3753                           >> _DEVINFO_VMONCAL0_ALTAVDD2V98THRESFINE_SHIFT);
   3754                break;
   3755              case emuVmonChannel_DVDD:
   3756                calReg = DEVINFO->VMONCAL1;
   3757                tLow = (10U * ((calReg & _DEVINFO_VMONCAL1_DVDD1V86THRESCOARSE_MASK)
   3758                               >> _DEVINFO_VMONCAL1_DVDD1V86THRESCOARSE_SHIFT))
   3759                       + ((calReg & _DEVINFO_VMONCAL1_DVDD1V86THRESFINE_MASK)
   3760                          >> _DEVINFO_VMONCAL1_DVDD1V86THRESFINE_SHIFT);
   3761                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL1_DVDD2V98THRESCOARSE_MASK)
   3762                                >> _DEVINFO_VMONCAL1_DVDD2V98THRESCOARSE_SHIFT))
   3763                        + ((calReg & _DEVINFO_VMONCAL1_DVDD2V98THRESFINE_MASK)
   3764                           >> _DEVINFO_VMONCAL1_DVDD2V98THRESFINE_SHIFT);
   3765                break;
   3766              case emuVmonChannel_IOVDD0:
   3767                calReg = DEVINFO->VMONCAL1;
   3768                tLow = (10U * ((calReg & _DEVINFO_VMONCAL1_IO01V86THRESCOARSE_MASK)
   3769                               >> _DEVINFO_VMONCAL1_IO01V86THRESCOARSE_SHIFT))
   3770                       + ((calReg & _DEVINFO_VMONCAL1_IO01V86THRESFINE_MASK)
   3771                          >> _DEVINFO_VMONCAL1_IO01V86THRESFINE_SHIFT);
   3772                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL1_IO02V98THRESCOARSE_MASK)
   3773                                >> _DEVINFO_VMONCAL1_IO02V98THRESCOARSE_SHIFT))
   3774                        + ((calReg & _DEVINFO_VMONCAL1_IO02V98THRESFINE_MASK)
   3775                           >> _DEVINFO_VMONCAL1_IO02V98THRESFINE_SHIFT);
   3776                break;
   3777          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   3778              case emuVmonChannel_IOVDD1:
   3779                calReg = DEVINFO->VMONCAL2;
   3780                tLow = (10U * ((calReg & _DEVINFO_VMONCAL2_IO11V86THRESCOARSE_MASK)
   3781                               >> _DEVINFO_VMONCAL2_IO11V86THRESCOARSE_SHIFT))
   3782                       + ((calReg & _DEVINFO_VMONCAL2_IO11V86THRESFINE_MASK)
   3783                          >> _DEVINFO_VMONCAL2_IO11V86THRESFINE_SHIFT);
   3784                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL2_IO12V98THRESCOARSE_MASK)
   3785                                >> _DEVINFO_VMONCAL2_IO12V98THRESCOARSE_SHIFT))
   3786                        + ((calReg & _DEVINFO_VMONCAL2_IO12V98THRESFINE_MASK)
   3787                           >> _DEVINFO_VMONCAL2_IO12V98THRESFINE_SHIFT);
   3788                break;
   3789          #endif
   3790          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   3791              case emuVmonChannel_BUVDD:
   3792                calReg = DEVINFO->VMONCAL2;
   3793                tLow = (10U * ((calReg & _DEVINFO_VMONCAL2_BUVDD1V86THRESCOARSE_MASK)
   3794                               >> _DEVINFO_VMONCAL2_BUVDD1V86THRESCOARSE_SHIFT))
   3795                       + ((calReg & _DEVINFO_VMONCAL2_BUVDD1V86THRESFINE_MASK)
   3796                          >> _DEVINFO_VMONCAL2_BUVDD1V86THRESFINE_SHIFT);
   3797                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL2_BUVDD2V98THRESCOARSE_MASK)
   3798                                >> _DEVINFO_VMONCAL2_BUVDD2V98THRESCOARSE_SHIFT))
   3799                        + ((calReg & _DEVINFO_VMONCAL2_BUVDD2V98THRESFINE_MASK)
   3800                           >> _DEVINFO_VMONCAL2_BUVDD2V98THRESFINE_SHIFT);
   3801                break;
   3802          #endif
   3803              default:
   3804                EFM_ASSERT(false);
   3805                break;
   3806            }
   3807          
   3808            tDiff = tHigh - tLow;
   3809            if (tDiff > 0) {
   3810              /* Calculate threshold.
   3811               *
   3812               * Note that volt is used in the reference manual. However, the results
   3813               * should be in millivolts. The precision of Va and Vb are increased in the
   3814               * calculation instead of using floating points.
   3815               */
   3816              uint32_t va = (1120U * 100U) / (tDiff);
   3817              uint32_t vb = (1860U * 100U) - (va * tLow);
   3818              // If (tHigh - tLow) is large, Va could be zero. Caught by CSTAT.
   3819              if (va != 0) {
   3820                /* Round the threshold to the nearest integer value. */
   3821                return (((uint32_t)threshold * 100U) - vb + (va / 2U)) / va;
   3822              }
   3823            }
   3824          
   3825            /* Uncalibrated device guard. */
   3826            return (uint32_t)threshold;
   3827          }
   3828          
   3829          /***************************************************************************//**
   3830           * @brief
   3831           *   Initialize a VMON channel.
   3832           *
   3833           * @details
   3834           *   Initialize a VMON channel without hysteresis. If the channel supports
   3835           *   separate rise and fall triggers, both thresholds will be set to the same
   3836           *   value. The threshold will be converted to a register field value based
   3837           *   on calibration values from the DI page.
   3838           *
   3839           * @param[in] vmonInit
   3840           *   The VMON initialization structure.
   3841           ******************************************************************************/
   3842          void EMU_VmonInit(const EMU_VmonInit_TypeDef *vmonInit)
   3843          {
   3844            uint32_t thresholdCoarse, thresholdFine;
   3845            uint32_t threshold;
   3846          
   3847            EFM_ASSERT((vmonInit->threshold >= 1620) && (vmonInit->threshold <= 3400));
   3848          
   3849            threshold = vmonCalibratedThreshold(vmonInit->channel, vmonInit->threshold);
   3850            thresholdFine = threshold % 10U;
   3851            thresholdCoarse = threshold / 10U;
   3852          
   3853            /* Saturate the threshold to maximum values. */
   3854            if (thresholdCoarse > 0xFU) {
   3855              thresholdCoarse = 0xF;
   3856              thresholdFine = 9;
   3857            }
   3858          
   3859            switch (vmonInit->channel) {
   3860              case emuVmonChannel_AVDD:
   3861                EMU->VMONAVDDCTRL = (thresholdCoarse << _EMU_VMONAVDDCTRL_RISETHRESCOARSE_SHIFT)
   3862                                    | (thresholdFine << _EMU_VMONAVDDCTRL_RISETHRESFINE_SHIFT)
   3863                                    | (thresholdCoarse << _EMU_VMONAVDDCTRL_FALLTHRESCOARSE_SHIFT)
   3864                                    | (thresholdFine << _EMU_VMONAVDDCTRL_FALLTHRESFINE_SHIFT)
   3865                                    | (vmonInit->riseWakeup ? EMU_VMONAVDDCTRL_RISEWU : 0U)
   3866                                    | (vmonInit->fallWakeup ? EMU_VMONAVDDCTRL_FALLWU : 0U)
   3867                                    | (vmonInit->enable     ? EMU_VMONAVDDCTRL_EN     : 0U);
   3868                break;
   3869              case emuVmonChannel_ALTAVDD:
   3870                EMU->VMONALTAVDDCTRL = (thresholdCoarse << _EMU_VMONALTAVDDCTRL_THRESCOARSE_SHIFT)
   3871                                       | (thresholdFine << _EMU_VMONALTAVDDCTRL_THRESFINE_SHIFT)
   3872                                       | (vmonInit->riseWakeup ? EMU_VMONALTAVDDCTRL_RISEWU : 0U)
   3873                                       | (vmonInit->fallWakeup ? EMU_VMONALTAVDDCTRL_FALLWU : 0U)
   3874                                       | (vmonInit->enable     ? EMU_VMONALTAVDDCTRL_EN     : 0U);
   3875                break;
   3876              case emuVmonChannel_DVDD:
   3877                EMU->VMONDVDDCTRL = (thresholdCoarse << _EMU_VMONDVDDCTRL_THRESCOARSE_SHIFT)
   3878                                    | (thresholdFine << _EMU_VMONDVDDCTRL_THRESFINE_SHIFT)
   3879                                    | (vmonInit->riseWakeup ? EMU_VMONDVDDCTRL_RISEWU : 0U)
   3880                                    | (vmonInit->fallWakeup ? EMU_VMONDVDDCTRL_FALLWU : 0U)
   3881                                    | (vmonInit->enable     ? EMU_VMONDVDDCTRL_EN     : 0U);
   3882                break;
   3883              case emuVmonChannel_IOVDD0:
   3884                EMU->VMONIO0CTRL = (thresholdCoarse << _EMU_VMONIO0CTRL_THRESCOARSE_SHIFT)
   3885                                   | (thresholdFine << _EMU_VMONIO0CTRL_THRESFINE_SHIFT)
   3886                                   | (vmonInit->retDisable ? EMU_VMONIO0CTRL_RETDIS : 0U)
   3887                                   | (vmonInit->riseWakeup ? EMU_VMONIO0CTRL_RISEWU : 0U)
   3888                                   | (vmonInit->fallWakeup ? EMU_VMONIO0CTRL_FALLWU : 0U)
   3889                                   | (vmonInit->enable     ? EMU_VMONIO0CTRL_EN     : 0U);
   3890                break;
   3891          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   3892              case emuVmonChannel_IOVDD1:
   3893                EMU->VMONIO1CTRL = (thresholdCoarse << _EMU_VMONIO1CTRL_THRESCOARSE_SHIFT)
   3894                                   | (thresholdFine << _EMU_VMONIO1CTRL_THRESFINE_SHIFT)
   3895                                   | (vmonInit->retDisable ? EMU_VMONIO1CTRL_RETDIS : 0U)
   3896                                   | (vmonInit->riseWakeup ? EMU_VMONIO1CTRL_RISEWU : 0U)
   3897                                   | (vmonInit->fallWakeup ? EMU_VMONIO1CTRL_FALLWU : 0U)
   3898                                   | (vmonInit->enable     ? EMU_VMONIO1CTRL_EN     : 0U);
   3899                break;
   3900          #endif
   3901          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   3902              case emuVmonChannel_BUVDD:
   3903                EMU->VMONBUVDDCTRL = (thresholdCoarse << _EMU_VMONBUVDDCTRL_THRESCOARSE_SHIFT)
   3904                                     | (thresholdFine << _EMU_VMONBUVDDCTRL_THRESFINE_SHIFT)
   3905                                     | (vmonInit->riseWakeup ? EMU_VMONBUVDDCTRL_RISEWU : 0U)
   3906                                     | (vmonInit->fallWakeup ? EMU_VMONBUVDDCTRL_FALLWU : 0U)
   3907                                     | (vmonInit->enable     ? EMU_VMONBUVDDCTRL_EN     : 0U);
   3908                break;
   3909          #endif
   3910              default:
   3911                EFM_ASSERT(false);
   3912                return;
   3913            }
   3914          }
   3915          
   3916          /***************************************************************************//**
   3917           * @brief
   3918           *   Initialize a VMON channel with hysteresis (separate rise and fall triggers).
   3919           *
   3920           * @details
   3921           *   Initialize a VMON channel which supports hysteresis. The AVDD channel is
   3922           *   the only channel to support separate rise and fall triggers. The rise and
   3923           *   fall thresholds will be converted to a register field value based on the
   3924           *   calibration values from the DI page.
   3925           *
   3926           * @param[in] vmonInit
   3927           *   The VMON hysteresis initialization structure.
   3928           ******************************************************************************/
   3929          void EMU_VmonHystInit(const EMU_VmonHystInit_TypeDef *vmonInit)
   3930          {
   3931            uint32_t riseThreshold;
   3932            uint32_t fallThreshold;
   3933          
   3934            /* VMON supports voltages between 1620 mV and 3400 mV (inclusive). */
   3935            EFM_ASSERT((vmonInit->riseThreshold >= 1620) && (vmonInit->riseThreshold <= 3400));
   3936            EFM_ASSERT((vmonInit->fallThreshold >= 1620) && (vmonInit->fallThreshold <= 3400));
   3937            /* The fall threshold has to be lower than rise threshold. */
   3938            EFM_ASSERT(vmonInit->fallThreshold <= vmonInit->riseThreshold);
   3939          
   3940            riseThreshold = vmonCalibratedThreshold(vmonInit->channel, vmonInit->riseThreshold);
   3941            fallThreshold = vmonCalibratedThreshold(vmonInit->channel, vmonInit->fallThreshold);
   3942          
   3943            switch (vmonInit->channel) {
   3944              case emuVmonChannel_AVDD:
   3945                EMU->VMONAVDDCTRL = ((riseThreshold / 10U) << _EMU_VMONAVDDCTRL_RISETHRESCOARSE_SHIFT)
   3946                                    | ((riseThreshold % 10U) << _EMU_VMONAVDDCTRL_RISETHRESFINE_SHIFT)
   3947                                    | ((fallThreshold / 10U) << _EMU_VMONAVDDCTRL_FALLTHRESCOARSE_SHIFT)
   3948                                    | ((fallThreshold % 10U) << _EMU_VMONAVDDCTRL_FALLTHRESFINE_SHIFT)
   3949                                    | (vmonInit->riseWakeup ? EMU_VMONAVDDCTRL_RISEWU : 0U)
   3950                                    | (vmonInit->fallWakeup ? EMU_VMONAVDDCTRL_FALLWU : 0U)
   3951                                    | (vmonInit->enable     ? EMU_VMONAVDDCTRL_EN     : 0U);
   3952                break;
   3953              default:
   3954                EFM_ASSERT(false);
   3955                return;
   3956            }
   3957          }
   3958          
   3959          /***************************************************************************//**
   3960           * @brief
   3961           *   Enable or disable a VMON channel.
   3962           *
   3963           * @param[in] channel
   3964           *   A VMON channel to enable/disable.
   3965           *
   3966           * @param[in] enable
   3967           *   Indicates whether to enable or disable.
   3968           ******************************************************************************/
   3969          void EMU_VmonEnable(EMU_VmonChannel_TypeDef channel, bool enable)
   3970          {
   3971            uint32_t volatile * reg;
   3972            uint32_t bit;
   3973          
   3974            switch (channel) {
   3975              case emuVmonChannel_AVDD:
   3976                reg = &(EMU->VMONAVDDCTRL);
   3977                bit = _EMU_VMONAVDDCTRL_EN_SHIFT;
   3978                break;
   3979              case emuVmonChannel_ALTAVDD:
   3980                reg = &(EMU->VMONALTAVDDCTRL);
   3981                bit = _EMU_VMONALTAVDDCTRL_EN_SHIFT;
   3982                break;
   3983              case emuVmonChannel_DVDD:
   3984                reg = &(EMU->VMONDVDDCTRL);
   3985                bit = _EMU_VMONDVDDCTRL_EN_SHIFT;
   3986                break;
   3987              case emuVmonChannel_IOVDD0:
   3988                reg = &(EMU->VMONIO0CTRL);
   3989                bit = _EMU_VMONIO0CTRL_EN_SHIFT;
   3990                break;
   3991          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   3992              case emuVmonChannel_IOVDD1:
   3993                reg = &(EMU->VMONIO1CTRL);
   3994                bit = _EMU_VMONIO1CTRL_EN_SHIFT;
   3995                break;
   3996          #endif
   3997          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   3998              case emuVmonChannel_BUVDD:
   3999                reg = &(EMU->VMONBUVDDCTRL);
   4000                bit = _EMU_VMONBUVDDCTRL_EN_SHIFT;
   4001                break;
   4002          #endif
   4003              default:
   4004                EFM_ASSERT(false);
   4005                return;
   4006            }
   4007          
   4008            BUS_RegBitWrite(reg, bit, (uint32_t)enable);
   4009          }
   4010          
   4011          /***************************************************************************//**
   4012           * @brief
   4013           *   Get the status of a voltage monitor channel.
   4014           *
   4015           * @param[in] channel
   4016           *   A VMON channel to get the status for.
   4017           *
   4018           * @return
   4019           *   A status of the selected VMON channel. True if the channel is triggered.
   4020           ******************************************************************************/
   4021          bool EMU_VmonChannelStatusGet(EMU_VmonChannel_TypeDef channel)
   4022          {
   4023            uint32_t bit;
   4024            switch (channel) {
   4025              case emuVmonChannel_AVDD:
   4026                bit = _EMU_STATUS_VMONAVDD_SHIFT;
   4027                break;
   4028              case emuVmonChannel_ALTAVDD:
   4029                bit = _EMU_STATUS_VMONALTAVDD_SHIFT;
   4030                break;
   4031              case emuVmonChannel_DVDD:
   4032                bit = _EMU_STATUS_VMONDVDD_SHIFT;
   4033                break;
   4034              case emuVmonChannel_IOVDD0:
   4035                bit = _EMU_STATUS_VMONIO0_SHIFT;
   4036                break;
   4037          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   4038              case emuVmonChannel_IOVDD1:
   4039                bit = _EMU_STATUS_VMONIO1_SHIFT;
   4040                break;
   4041          #endif
   4042          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   4043              case emuVmonChannel_BUVDD:
   4044                bit = _EMU_STATUS_VMONBUVDD_SHIFT;
   4045                break;
   4046          #endif
   4047              default:
   4048                bit = 0;
   4049                EFM_ASSERT(false);
   4050                break;
   4051            }
   4052          
   4053            return BUS_RegBitRead(&EMU->STATUS, bit) != 0U;
   4054          }
   4055          #endif /* EMU_STATUS_VMONRDY */
   4056          
   4057          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   4058          /***************************************************************************//**
   4059           * @brief
   4060           *   Adjust the bias refresh rate.
   4061           *
   4062           * @details
   4063           *   This function is only meant to be used under high-temperature operation on
   4064           *   EFR32xG1 and EFM32xG1 devices. Adjusting the bias mode will
   4065           *   increase the typical current consumption. See application note 1027
   4066           *   and errata documents for more details.
   4067           *
   4068           * @param [in] mode
   4069           *   The new bias refresh rate.
   4070           ******************************************************************************/
   4071          void EMU_SetBiasMode(EMU_BiasMode_TypeDef mode)
   4072          {
   4073            uint32_t freq = 0x2u;
   4074            bool emuTestLocked = false;
   4075          
   4076            if (mode == emuBiasMode_1KHz) {
   4077              freq = 0x0u;
   4078            }
   4079          
   4080            if (EMU_TESTLOCK == 0x1u) {
   4081              emuTestLocked = true;
   4082              EMU_TESTLOCK = 0xADE8u;
   4083            }
   4084          
   4085            if (mode == emuBiasMode_Continuous) {
   4086              EMU_BIASCONF &= ~0x74u;
   4087            } else {
   4088              EMU_BIASCONF |= 0x74u;
   4089            }
   4090          
   4091            EMU_BIASTESTCTRL |= 0x8u;
   4092            CMU_ULFRCOCTRL    = (CMU_ULFRCOCTRL & ~0xC00u)
   4093                                | ((freq & 0x3u) << 10u);
   4094            EMU_BIASTESTCTRL &= ~0x8u;
   4095          
   4096            if (emuTestLocked) {
   4097              EMU_TESTLOCK = 0u;
   4098            }
   4099          }
   4100          #endif
   4101          
   4102          #if defined(_EMU_TEMP_TEMP_MASK)
   4103          /***************************************************************************//**
   4104           * @brief
   4105           *   Get temperature in degrees Celsius
   4106           *
   4107           * @return
   4108           *   Temperature in degrees Celsius
   4109           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   4110          float EMU_TemperatureGet(void)
   4111          {
   4112          #if defined(_EMU_TEMP_TEMPLSB_MASK)
   4113            return ((float) ((EMU->TEMP & (_EMU_TEMP_TEMP_MASK | _EMU_TEMP_TEMPLSB_MASK) )
   4114                             >> _EMU_TEMP_TEMPLSB_SHIFT)
   4115                    ) / 4.0f - EMU_TEMP_ZERO_C_IN_KELVIN;
   \                     EMU_TemperatureGet: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable18_27
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0xED9F 0x....      VLDR.W   S0,??DataTable18
   \        0x8   0xF3C0 0x000A      UBFX     R0,R0,#+0,#+11
   \        0xC   0xEE00 0x0A90      VMOV     S1,R0
   \       0x10   0xEEFB 0x0ACF      VCVT.F32.U32 S1,S1,#+2
   \       0x14   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \       0x18   0x4770             BX       LR
   4116          #else
   4117            uint32_t val1;
   4118            uint32_t val2;
   4119            float tempCo;
   4120            uint32_t diTemp, diEmu;
   4121          
   4122            // Calculate calibration temp based on DI page values
   4123            diTemp = ((DEVINFO->CAL & _DEVINFO_CAL_TEMP_MASK) >> _DEVINFO_CAL_TEMP_SHIFT);
   4124            diEmu = ((DEVINFO->EMUTEMP & _DEVINFO_EMUTEMP_EMUTEMPROOM_MASK) >> _DEVINFO_EMUTEMP_EMUTEMPROOM_SHIFT);
   4125            tempCo = EMU_TEMPCO_CONST + (diEmu / 100.0f);
   4126          
   4127            // Read temperature twice to ensure a stable value
   4128            do {
   4129              val1 = (EMU->TEMP & _EMU_TEMP_TEMP_MASK)
   4130                     >> _EMU_TEMP_TEMP_SHIFT;
   4131              val2 = (EMU->TEMP & _EMU_TEMP_TEMP_MASK)
   4132                     >> _EMU_TEMP_TEMP_SHIFT;
   4133            } while (val1 != val2);
   4134          
   4135            return diTemp + tempCo * ((int) diEmu - (int) val1);
   4136          #endif
   4137          }
   4138          #endif // defined(_EMU_TEMP_TEMP_MASK)
   4139          
   4140          #if defined(EMU_CTRL_EFPDIRECTMODEEN)
   4141          /***************************************************************************//**
   4142           * @brief
   4143           *   Enable/disable EFP Direct Mode.
   4144           *
   4145           * @param[in] enable
   4146           *   True to enable direct mode.
   4147           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4148          void EMU_EFPDirectModeEnable(bool enable)
   4149          {
   4150            if (enable) {
   \                     EMU_EFPDirectModeEnable: (+1)
   \        0x0   0xF04F 0x5100      MOV      R1,#+536870912
   \        0x4   0xB100             CBZ.N    R0,??EMU_EFPDirectModeEnable_0
   4151              EMU->CTRL_SET = EMU_CTRL_EFPDIRECTMODEEN;
   \        0x6   0x....             B.N      ?Subroutine1
   4152            } else {
   4153              EMU->CTRL_CLR = EMU_CTRL_EFPDIRECTMODEEN;
   \                     ??EMU_EFPDirectModeEnable_0: (+1)
   \        0x8   0x....             B.N      ?Subroutine0
   4154            }
   4155          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable18_28
   \        0x2   0x6011             STR      R1,[R2, #+0]
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_29
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x4770             BX       LR
   4156          #endif
   4157          
   4158          #if defined(EMU_CTRL_EFPDRVDECOUPLE)
   4159          /***************************************************************************//**
   4160           * @brief
   4161           *   Set to enable EFP to drive Decouple voltage.
   4162           *
   4163           * @details
   4164           *   Once set, internal LDO will be disabled, and the EMU will control EFP for
   4165           *   voltage-scaling. Note that because this bit disables the internal LDO
   4166           *   powering the core, it should not be set until after EFP's DECOUPLE output has
   4167           *   been configured and enabled.
   4168           *
   4169           * @param[in] enable
   4170           *   True to enable EFP to drive Decouple voltage.
   4171           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4172          void EMU_EFPDriveDecoupleSet(bool enable)
   4173          {
   4174            if (enable) {
   \                     EMU_EFPDriveDecoupleSet: (+1)
   \        0x0   0xF04F 0x4180      MOV      R1,#+1073741824
   \        0x4   0xB100             CBZ.N    R0,??EMU_EFPDriveDecoupleSet_0
   4175              EMU->CTRL_SET = EMU_CTRL_EFPDRVDECOUPLE;
   \        0x6   0x....             B.N      ?Subroutine1
   4176            } else {
   4177              EMU->CTRL_CLR = EMU_CTRL_EFPDRVDECOUPLE;
   \                     ??EMU_EFPDriveDecoupleSet_0: (+1)
   \        0x8   0x....             B.N      ?Subroutine0
   4178            }
   4179          }
   4180          #endif
   4181          
   4182          #if defined(EMU_CTRL_EFPDRVDVDD)
   4183          /***************************************************************************//**
   4184           * @brief
   4185           *   Set to enable EFP to drive DVDD voltage.
   4186           *
   4187           * @details
   4188           *   Set this if EFP's DCDC output is powering DVDD supply. This mode assumes that
   4189           *   internal DCDC is not being used.
   4190           *
   4191           * @param[in] enable
   4192           *   True to enable EFP to drive DVDD voltage.
   4193           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4194          void EMU_EFPDriveDvddSet(bool enable)
   4195          {
   4196            if (enable) {
   \                     EMU_EFPDriveDvddSet: (+1)
   \        0x0   0xF04F 0x4100      MOV      R1,#+2147483648
   \        0x4   0xB100             CBZ.N    R0,??EMU_EFPDriveDvddSet_0
   4197              EMU->CTRL_SET = EMU_CTRL_EFPDRVDVDD;
   \        0x6   0x....             B.N      ?Subroutine1
   4198            } else {
   4199              EMU->CTRL_CLR = EMU_CTRL_EFPDRVDVDD;
   \                     ??EMU_EFPDriveDvddSet_0: (+1)
   \        0x8   0x....             B.N      ?Subroutine0
   4200            }
   4201          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xE8BD 0x4010      POP      {R4,LR}
   \        0x4   0x.... 0x....      B.W      SystemHCLKGet

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable18_4
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \        0x8   0x6001             STR      R1,[R0, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0xC388'9333        DC32     0xc3889333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     vScaleEM01Config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x5000'4074        DC32     0x50004074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0xE000'ED10        DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x0FFF'0000        DC32     0xfff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \        0x0   0x5003'E420        DC32     0x5003e420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \        0x0   0x5000'406C        DC32     0x5000406c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \        0x0   0x5000'4060        DC32     0x50004060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \        0x0   0x5000'8070        DC32     0x50008070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \        0x0   0x5009'4028        DC32     0x50094028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \        0x0   0x2004'0000        DC32     0x20040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \        0x0   0x5000'9064        DC32     0x50009064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \        0x0   0x5007'C208        DC32     0x5007c208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \        0x0   0x0262'5A01        DC32     0x2625a01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \        0x0   0x5000'4064        DC32     0x50004064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_16:
   \        0x0   0x5000'6064        DC32     0x50006064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_17:
   \        0x0   0x5009'4004        DC32     0x50094004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_18:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_19:
   \        0x0   0x5009'6004        DC32     0x50096004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_20:
   \        0x0   0x5009'5004        DC32     0x50095004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_21:
   \        0x0   0xFFFF'5432        DC32     0xffff5432

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_22:
   \        0x0   0x5000'403C        DC32     0x5000403c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_23:
   \        0x0   0x5000'8064        DC32     0x50008064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_24:
   \        0x0   0x5009'4008        DC32     0x50094008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_25:
   \        0x0   0x5000'A064        DC32     0x5000a064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_26:
   \        0x0   0x5009'4020        DC32     0x50094020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_27:
   \        0x0   0x5000'4088        DC32     0x50004088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_28:
   \        0x0   0x5000'5074        DC32     0x50005074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_29:
   \        0x0   0x5000'6074        DC32     0x50006074

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x65          DC8 0x5C, 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x73
   \              0x6D 0x6C    
   \              0x69 0x62    
   \              0x5C 0x73
   \       0x58   0x72 0x63          DC8 0x72, 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x65, 0x6D
   \              0x5C 0x65    
   \              0x6D 0x5F    
   \              0x65 0x6D
   \       0x60   0x75 0x2E          DC8 0x75, 0x2E, 0x63, 0
   \              0x63 0x00
   4202          #endif
   4203          
   4204          /** @} (end addtogroup emu) */
   4205          #endif /* __EM_EMU_H */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   EMU_DCDCInit
        16   -> EMU_DCDCModeSet
        16   -> EMU_DCDCUpdatedHook
      24   EMU_DCDCModeSet
        24   -> EMU_DCDCUpdatedHook
       8   EMU_DCDCPowerOff
         8   -> EMU_DCDCModeSet
      16   EMU_DCDCSetPFMXModePeakCurrent
         0   -> EMU_DCDCUpdatedHook
        16   -> assertEFM
      16   EMU_DCDCSetPFMXTimeoutMaxCtrl
         0   -> EMU_DCDCUpdatedHook
       0   EMU_DCDCUpdatedHook
       0   EMU_EFPDirectModeEnable
       0   EMU_EFPDriveDecoupleSet
       0   EMU_EFPDriveDvddSet
       0   EMU_EFPEM01VScale
       0   EMU_EFPEM23PostsleepHook
       0   EMU_EFPEM23PresleepHook
       0   EMU_EFPEM4PresleepHook
       0   EMU_EM01Init
         0   -> EMU_VScaleEM01ByClock
      24   EMU_EM01PeakCurrentSet
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
         0   -> EMU_DCDCUpdatedHook
       0   EMU_EM23Init
       0   EMU_EM23PostsleepHook
       0   EMU_EM23PresleepHook
       0   EMU_EM4Init
       0   EMU_EM4PresleepHook
       8   EMU_EnterEM2
         8   -> EMU_EFPEM23PostsleepHook
         8   -> EMU_EFPEM23PresleepHook
         8   -> EMU_EM23PostsleepHook
         8   -> EMU_EM23PresleepHook
         0   -> SystemHCLKGet
       8   EMU_EnterEM3
         8   -> EMU_EM23PostsleepHook
         8   -> EMU_EM23PresleepHook
         0   -> SystemHCLKGet
      24   EMU_EnterEM4
        24   -> CORE_EnterCritical
         0   -> CORE_ExitCritical
        24   -> EMU_DCDCModeSet
        24   -> EMU_EFPEM4PresleepHook
        24   -> EMU_EM4PresleepHook
        24   -> assertEFM
        24   -> sli_em_cmu_SYSCLKInitPostClockSelect
        24   -> sli_em_cmu_SYSCLKInitPreClockSelect
       0   EMU_EnterEM4H
         0   -> EMU_EnterEM4
       0   EMU_EnterEM4S
         0   -> EMU_EnterEM4
       8   EMU_EnterEM4Wait
         8   -> EMU_EnterEM4
       0   EMU_MemPwrDown
       8   EMU_RamPowerDown
       0   EMU_RamPowerUp
       0   EMU_Restore
       0   EMU_Save
       0   EMU_TemperatureGet
       0   EMU_UpdateOscConfig
      24   EMU_VScaleEM01
         0   -> CMU_UpdateWaitStates
        24   -> CMU_UpdateWaitStates
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
        24   -> EMU_EFPEM01VScale
        24   -> SystemSYSCLKGet
        24   -> assertEFM
       8   EMU_VScaleEM01ByClock
         0   -> EMU_VScaleEM01
         8   -> SystemSYSCLKGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_19
       4  ??DataTable18_2
       4  ??DataTable18_20
       4  ??DataTable18_21
       4  ??DataTable18_22
       4  ??DataTable18_23
       4  ??DataTable18_24
       4  ??DataTable18_25
       4  ??DataTable18_26
       4  ??DataTable18_27
       4  ??DataTable18_28
       4  ??DataTable18_29
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
       6  ?Subroutine0
       6  ?Subroutine1
       8  ?Subroutine2
      20  ?Subroutine3
      12  ?Subroutine4
      32  ?Subroutine5
     100  ?_0
      98  EMU_DCDCInit
     130  EMU_DCDCModeSet
      12  EMU_DCDCPowerOff
      38  EMU_DCDCSetPFMXModePeakCurrent
      22  EMU_DCDCSetPFMXTimeoutMaxCtrl
       2  EMU_DCDCUpdatedHook
      10  EMU_EFPDirectModeEnable
      10  EMU_EFPDriveDecoupleSet
      10  EMU_EFPDriveDvddSet
       2  EMU_EFPEM01VScale
       2  EMU_EFPEM23PostsleepHook
       2  EMU_EFPEM23PresleepHook
       2  EMU_EFPEM4PresleepHook
      14  EMU_EM01Init
      76  EMU_EM01PeakCurrentSet
      20  EMU_EM23Init
       2  EMU_EM23PostsleepHook
       2  EMU_EM23PresleepHook
      18  EMU_EM4Init
       2  EMU_EM4PresleepHook
      44  EMU_EnterEM2
      42  EMU_EnterEM3
     116  EMU_EnterEM4
       2  EMU_EnterEM4H
       2  EMU_EnterEM4S
      16  EMU_EnterEM4Wait
       2  EMU_MemPwrDown
      56  EMU_RamPowerDown
      16  EMU_RamPowerUp
       2  EMU_Restore
       2  EMU_Save
      26  EMU_TemperatureGet
       2  EMU_UpdateOscConfig
     150  EMU_VScaleEM01
      36  EMU_VScaleEM01ByClock
       1  vScaleEM01Config

 
     1 byte  in section .bss
   100 bytes in section .rodata
 1'192 bytes in section .text
 
 1'176 bytes of CODE  memory (+ 16 bytes shared)
   100 bytes of CONST memory
     1 byte  of DATA  memory

Errors: none
Warnings: none
