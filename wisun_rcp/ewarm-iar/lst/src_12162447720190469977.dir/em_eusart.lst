###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:54
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_eusart.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_eusart.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_eusart.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_eusart.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir\em_eusart.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_eusart.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_eusart.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Universal asynchronous receiver/transmitter (EUSART) peripheral API
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2019 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "em_eusart.h"
     32          #if defined(EUART_PRESENT) || defined(EUSART_PRESENT)
     33          #include "em_cmu.h"
     34          #include <stddef.h>
     35          
     36          /*******************************************************************************
     37           *********************************   DEFINES   *********************************
     38           ******************************************************************************/
     39          
     40          #if defined(EUART_PRESENT)
     41            #define EUSART_REF_VALID(ref)    ((ref) == EUART0)
     42            #define EUSART_EM2_CAPABLE(ref)  (true)
     43            #define EUSART_RX_FIFO_SIZE  4u
     44          #elif defined(EUSART_PRESENT)
     45            #define EUSART_REF_VALID(ref)    (EUSART_NUM(ref) != -1)
     46            #define EUSART_RX_FIFO_SIZE  16u
     47          #endif
     48          
     49          /*******************************************************************************
     50           **************************   LOCAL VARIABLES   ********************************
     51           ******************************************************************************/
     52          #if defined(EUSART_DALICFG_DALIEN)
     53          static uint8_t dali_tx_nb_packets[EUSART_COUNT];
     54          static uint8_t dali_rx_nb_packets[EUSART_COUNT];
     55          #endif /* EUSART_DALICFG_DALIEN */
     56          
     57          /*******************************************************************************
     58           **************************   LOCAL FUNCTIONS   ********************************
     59           ******************************************************************************/
     60          
     61          static CMU_Clock_TypeDef EUSART_ClockGet(EUSART_TypeDef *eusart);
     62          
     63          static void EUSART_AsyncInitCommon(EUSART_TypeDef *eusart,
     64                                             const EUSART_UartInit_TypeDef *init,
     65                                             const EUSART_IrDAInit_TypeDef *irdaInit,
     66                                             const EUSART_DaliInit_TypeDef *daliInit);
     67          
     68          #if defined(EUSART_PRESENT)
     69          static void EUSART_SyncInitCommon(EUSART_TypeDef *eusart,
     70                                            const EUSART_SpiInit_TypeDef  *init);
     71          #endif
     72          
     73          /***************************************************************************//**
     74           * Wait for ongoing sync of register(s) to the low-frequency domain to complete.
     75           *
     76           * @param eusart Pointer to the EUSART peripheral register block.
     77           * @param mask A bitmask corresponding to SYNCBUSY register defined bits,
     78           *             indicating registers that must complete any ongoing
     79           *             synchronization.
     80           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     81          __STATIC_INLINE void eusart_sync(EUSART_TypeDef *eusart, uint32_t mask)
     82          {
     83            // Wait for any pending previous write operation to have been completed
     84            // in the low-frequency domain.
     85            while ((eusart->SYNCBUSY & mask) != 0U) {
   \                     eusart_sync: (+1)
   \                     ??eusart_sync_0: (+1)
   \        0x0   0x6D42             LDR      R2,[R0, #+84]
   \        0x2   0x420A             TST      R2,R1
   \        0x4   0xD1FC             BNE.N    ??eusart_sync_0
     86            }
     87          }
   \        0x6   0x4770             BX       LR
     88          
     89          /***************************************************************************//**
     90           *   Calculate baudrate for a given reference frequency, clock division,
     91           *   and oversampling rate.
     92           ******************************************************************************/
     93          __STATIC_INLINE uint32_t EUSART_AsyncBaudrateCalc(uint32_t refFreq,
     94                                                            uint32_t clkdiv,
     95                                                            EUSART_OVS_TypeDef ovs);
     96          
     97          /***************************************************************************//**
     98           *   Execute the EUSART peripheral disabling sequence.
     99           ******************************************************************************/
    100          __STATIC_INLINE void EUSART_Disable(EUSART_TypeDef *eusart);
    101          
    102          /*******************************************************************************
    103           **************************   GLOBAL FUNCTIONS   *******************************
    104           ******************************************************************************/
    105          
    106          /***************************************************************************//**
    107           * Initializes the EUSART when used with the high frequency clock.
    108           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    109          void EUSART_UartInitHf(EUSART_TypeDef *eusart, const EUSART_UartInit_TypeDef *init)
    110          {
   \                     EUSART_UartInitHf: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4605             MOV      R5,R0
    111            // Make sure the module exists on the selected chip.
    112            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable15
   \        0xA   0x.... 0x....      LDR.W    R6,??DataTable15_1
   \        0xE   0x428D             CMP      R5,R1
   \       0x10   0xBF1F             ITTTT    NE
   \       0x12   0x.... 0x....      LDRNE.W  R0,??DataTable15_2
   \       0x16   0x4285             CMPNE    R5,R0
   \       0x18   0x.... 0x....      LDRNE.W  R2,??DataTable15_3
   \       0x1C   0x4295             CMPNE    R5,R2
   \       0x1E   0xD002             BEQ.N    ??CrossCallReturnLabel_21
   \       0x20   0x2170             MOVS     R1,#+112
   \       0x22   0x.... 0x....      BL       ?Subroutine3
    113            // Init structure must be provided.
    114            EFM_ASSERT(init);
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x26   0xB914             CBNZ.N   R4,??CrossCallReturnLabel_20
   \       0x28   0x2172             MOVS     R1,#+114
   \       0x2A   0x.... 0x....      BL       ?Subroutine3
    115          
    116            // Assert features specific to HF.
    117            // The oversampling must not be disabled when using a high frequency clock.
    118            EFM_ASSERT(init->oversampling != eusartOVS0);
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x2E   0x7B20             LDRB     R0,[R4, #+12]
   \       0x30   0x2880             CMP      R0,#+128
   \       0x32   0xD102             BNE.N    ??CrossCallReturnLabel_19
   \       0x34   0x2176             MOVS     R1,#+118
   \       0x36   0x.... 0x....      BL       ?Subroutine3
    119          
    120            // Uart mode only supports up to 9 databits frame.
    121            EFM_ASSERT(init->databits <= eusartDataBits9);
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x3A   0x7B60             LDRB     R0,[R4, #+13]
   \       0x3C   0x2804             CMP      R0,#+4
   \       0x3E   0xDB02             BLT.N    ??CrossCallReturnLabel_18
   \       0x40   0x2179             MOVS     R1,#+121
   \       0x42   0x.... 0x....      BL       ?Subroutine3
    122          
    123            // Initialize EUSART with common features to HF and LF.
    124            EUSART_AsyncInitCommon(eusart, init, NULL, NULL);
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x46   0x4621             MOV      R1,R4
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x2300             MOVS     R3,#+0
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x52   0x.... 0x....      B.W      EUSART_AsyncInitCommon
    125          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x.... 0x....      B.W      assertEFM
    126          
    127          /***************************************************************************//**
    128           * Initializes the EUSART when used with the low frequency clock.
    129           *
    130           * @note (1) When EUSART oversampling is set to eusartOVS0 (Disable), the peripheral
    131           *           clock frequency must be at least three times higher than the
    132           *           chosen baud rate. In LF, max input clock is 32768 (LFXO or LFRCO),
    133           *           thus 32768 / 3 ~ 9600 baudrate.
    134           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          void EUSART_UartInitLf(EUSART_TypeDef *eusart, const EUSART_UartInit_TypeDef *init)
    136          {
   \                     EUSART_UartInitLf: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine4
    137            // Make sure the module exists and is Low frequency capable.
    138            EFM_ASSERT(EUSART_REF_VALID(eusart) && EUSART_EM2_CAPABLE(EUSART_NUM(eusart)));
   \                     ??CrossCallReturnLabel_22: (+1)
   \        0x6   0xD002             BEQ.N    ??CrossCallReturnLabel_17
   \        0x8   0x218A             MOVS     R1,#+138
   \        0xA   0x.... 0x....      BL       ?Subroutine3
    139            // Init structure must be provided.
    140            EFM_ASSERT(init);
   \                     ??CrossCallReturnLabel_17: (+1)
   \        0xE   0xB914             CBNZ.N   R4,??CrossCallReturnLabel_16
   \       0x10   0x218C             MOVS     R1,#+140
   \       0x12   0x.... 0x....      BL       ?Subroutine3
    141          
    142            // Assert features specific to LF.
    143            // LFXO, LFRCO, ULFRCO can be a clock source in LF.
    144          #if defined(DEBUG_EFM) || defined(DEBUG_EFM_USER)
    145            {
    146              CMU_Select_TypeDef clock_source = (CMU_Select_TypeDef) NULL;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
    147          #if defined(EUART_PRESENT)
    148              if (eusart == EUART0) {
    149                clock_source = CMU_ClockSelectGet(cmuClock_EUART0);
    150              }
    151          #endif
    152          #if defined(EUSART_PRESENT) && defined(EUSART0)
    153              if (eusart == EUSART0) {
   \       0x18   0x42BD             CMP      R5,R7
   \       0x1A   0xD106             BNE.N    ??EUSART_UartInitLf_0
    154                clock_source = CMU_ClockSelectGet(cmuClock_EUSART0);
   \       0x1C   0x2056             MOVS     R0,#+86
   \       0x1E   0x.... 0x....      BL       CMU_ClockSelectGet
    155              }
    156          #endif
    157          
    158              EFM_ASSERT(
    159                (clock_source == cmuSelect_ULFRCO)
    160                || (clock_source == cmuSelect_LFXO)
    161                || (clock_source == cmuSelect_LFRCO)
    162                || (clock_source == cmuSelect_EM23GRPACLK)
    163          #if defined(_CMU_EUSART0CLKCTRL_CLKSEL_EM01GRPCCLK)
    164                || (clock_source == cmuSelect_EM01GRPCCLK) /* ULFRCO, LFXO, LFRCO, EM23GRPACLK or EM01GRPCCLK */
    165          #endif
    166                );
   \       0x22   0x280B             CMP      R0,#+11
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2809             CMPNE    R0,#+9
   \       0x28   0xD007             BEQ.N    ??CrossCallReturnLabel_15
   \                     ??EUSART_UartInitLf_0: (+1)
   \       0x2A   0x280A             CMP      R0,#+10
   \       0x2C   0xBF1C             ITT      NE
   \       0x2E   0x2810             CMPNE    R0,#+16
   \       0x30   0x2811             CMPNE    R0,#+17
   \       0x32   0xD002             BEQ.N    ??CrossCallReturnLabel_15
   \       0x34   0x21A6             MOVS     R1,#+166
    167            }
   \       0x36   0x.... 0x....      BL       ?Subroutine3
    168          #endif
    169            // Uart mode only supports up to 9 databits frame.
    170            EFM_ASSERT(init->databits <= eusartDataBits9);
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x3A   0x7B60             LDRB     R0,[R4, #+13]
   \       0x3C   0x2804             CMP      R0,#+4
   \       0x3E   0xDB02             BLT.N    ??CrossCallReturnLabel_14
   \       0x40   0x21AA             MOVS     R1,#+170
   \       0x42   0x.... 0x....      BL       ?Subroutine3
    171            // The oversampling must be disabled when using a low frequency clock.
    172            EFM_ASSERT(init->oversampling == eusartOVS0);
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x46   0x7B20             LDRB     R0,[R4, #+12]
   \       0x48   0x2880             CMP      R0,#+128
   \       0x4A   0xD002             BEQ.N    ??CrossCallReturnLabel_13
   \       0x4C   0x21AC             MOVS     R1,#+172
   \       0x4E   0x.... 0x....      BL       ?Subroutine3
    173            // The Majority Vote must be disabled when using a low frequency clock.
    174            EFM_ASSERT(init->majorityVote == eusartMajorityVoteDisable);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x52   0x6960             LDR      R0,[R4, #+20]
   \       0x54   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x58   0xD002             BEQ.N    ??CrossCallReturnLabel_12
   \       0x5A   0x21AE             MOVS     R1,#+174
   \       0x5C   0x.... 0x....      BL       ?Subroutine3
    175            // Number of stop bits can only be 1 or 2 in LF.
    176            EFM_ASSERT((init->stopbits == eusartStopbits1) || (init->stopbits == eusartStopbits2));
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x60   0xF9B4 0x0010      LDRSH    R0,[R4, #+16]
   \       0x64   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x68   0xBF18             IT       NE
   \       0x6A   0xF5B0 0x5F40      CMPNE    R0,#+12288
   \       0x6E   0xD002             BEQ.N    ??CrossCallReturnLabel_11
   \       0x70   0x21B0             MOVS     R1,#+176
   \       0x72   0x.... 0x....      BL       ?Subroutine3
    177            // In LF, max baudrate is 9600. See Note #1.
    178            EFM_ASSERT(init->baudrate <= 9600 && init->baudrate != 0);
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x76   0x68A0             LDR      R0,[R4, #+8]
   \       0x78   0xF242 0x5181      MOVW     R1,#+9601
   \       0x7C   0x4288             CMP      R0,R1
   \       0x7E   0xD200             BCS.N    ??EUSART_UartInitLf_1
   \       0x80   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_10
   \                     ??EUSART_UartInitLf_1: (+1)
   \       0x82   0x21B2             MOVS     R1,#+178
   \       0x84   0x.... 0x....      BL       ?Subroutine3
    179          
    180            // Initialize EUSART with common features to HF and LF.
    181            EUSART_AsyncInitCommon(eusart, init, NULL, NULL);
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x88   0x4621             MOV      R1,R4
   \       0x8A   0x4628             MOV      R0,R5
   \       0x8C   0xB001             ADD      SP,SP,#+4
   \       0x8E   0x2300             MOVS     R3,#+0
   \       0x90   0x2200             MOVS     R2,#+0
   \       0x92   0x....             B.N      ?Subroutine2
    182          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \        0x4   0x....             B.N      EUSART_AsyncInitCommon

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0x.... 0x....      LDR.W    R7,??DataTable15
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x.... 0x....      LDR.W    R6,??DataTable15_1
   \        0xC   0x42BD             CMP      R5,R7
   \        0xE   0x4770             BX       LR
    183          
    184          /***************************************************************************//**
    185           * Initializes the EUSART when used in IrDA mode with the high or low
    186           * frequency clock.
    187           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    188          void EUSART_IrDAInit(EUSART_TypeDef *eusart,
    189                               const EUSART_IrDAInit_TypeDef *irdaInit)
    190          {
   \                     EUSART_IrDAInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine4
    191            // Make sure the module exists on the selected chip.
    192            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \                     ??CrossCallReturnLabel_23: (+1)
   \        0x6   0xBF1F             ITTTT    NE
   \        0x8   0x.... 0x....      LDRNE.W  R0,??DataTable15_2
   \        0xC   0x4285             CMPNE    R5,R0
   \        0xE   0x.... 0x....      LDRNE.W  R2,??DataTable15_3
   \       0x12   0x4295             CMPNE    R5,R2
   \       0x14   0xD002             BEQ.N    ??CrossCallReturnLabel_9
   \       0x16   0x21C0             MOVS     R1,#+192
   \       0x18   0x.... 0x....      BL       ?Subroutine3
    193            // Init structure must be provided.
    194            EFM_ASSERT(irdaInit);
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x1C   0xB914             CBNZ.N   R4,??CrossCallReturnLabel_8
   \       0x1E   0x21C2             MOVS     R1,#+194
   \       0x20   0x.... 0x....      BL       ?Subroutine3
    195          
    196            if (irdaInit->irDALowFrequencyEnable) {
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x24   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x28   0xB320             CBZ.N    R0,??EUSART_IrDAInit_0
    197              // Validate the low frequency capability of the EUSART instance.
    198              EFM_ASSERT(EUSART_EM2_CAPABLE(EUSART_NUM(eusart)));
   \       0x2A   0x42BD             CMP      R5,R7
   \       0x2C   0xD002             BEQ.N    ??CrossCallReturnLabel_7
   \       0x2E   0x21C6             MOVS     R1,#+198
   \       0x30   0x.... 0x....      BL       ?Subroutine3
    199              // The oversampling must be disabled when using a low frequency clock.
    200              EFM_ASSERT(irdaInit->init.oversampling == eusartOVS0);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x34   0x7B20             LDRB     R0,[R4, #+12]
   \       0x36   0x2880             CMP      R0,#+128
   \       0x38   0xD002             BEQ.N    ??CrossCallReturnLabel_6
   \       0x3A   0x21C8             MOVS     R1,#+200
   \       0x3C   0x.... 0x....      BL       ?Subroutine3
    201              // Number of stop bits can only be 1 or 2 in LF.
    202              EFM_ASSERT((irdaInit->init.stopbits == eusartStopbits1) || (irdaInit->init.stopbits == eusartStopbits2));
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x40   0xF9B4 0x0010      LDRSH    R0,[R4, #+16]
   \       0x44   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x48   0xBF18             IT       NE
   \       0x4A   0xF5B0 0x5F40      CMPNE    R0,#+12288
   \       0x4E   0xD002             BEQ.N    ??CrossCallReturnLabel_5
   \       0x50   0x21CA             MOVS     R1,#+202
   \       0x52   0x.... 0x....      BL       ?Subroutine3
    203              // In LF, max baudrate is 9600. See Note #1.
    204              EFM_ASSERT(irdaInit->init.baudrate <= 9600);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x56   0x68A1             LDR      R1,[R4, #+8]
   \       0x58   0xF242 0x5081      MOVW     R0,#+9601
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xD302             BCC.N    ??CrossCallReturnLabel_4
   \       0x60   0x21CC             MOVS     R1,#+204
   \       0x62   0x.... 0x....      BL       ?Subroutine3
    205              EFM_ASSERT(irdaInit->init.enable == eusartEnableRx || irdaInit->init.enable == eusartDisable);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x66   0x7820             LDRB     R0,[R4, #+0]
   \       0x68   0x2809             CMP      R0,#+9
   \       0x6A   0xBF18             IT       NE
   \       0x6C   0x2800             CMPNE    R0,#+0
   \       0x6E   0xD011             BEQ.N    ??CrossCallReturnLabel_2
   \       0x70   0x21CD             MOVS     R1,#+205
   \       0x72   0xE00D             B.N      ??EUSART_IrDAInit_1
    206            } else {
    207              EFM_ASSERT(irdaInit->init.oversampling != eusartOVS0);
   \                     ??EUSART_IrDAInit_0: (+1)
   \       0x74   0x7B20             LDRB     R0,[R4, #+12]
   \       0x76   0x2880             CMP      R0,#+128
   \       0x78   0xD102             BNE.N    ??CrossCallReturnLabel_3
   \       0x7A   0x21CF             MOVS     R1,#+207
   \       0x7C   0x.... 0x....      BL       ?Subroutine3
    208              // In HF, 2.4 kbps <= baudrate <= 1.152 Mbps.
    209              EFM_ASSERT(irdaInit->init.baudrate >= 2400 && irdaInit->init.baudrate <= 1152000);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x80   0x68A1             LDR      R1,[R4, #+8]
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \       0x86   0xF5A1 0x6116      SUB      R1,R1,#+2400
   \       0x8A   0x4281             CMP      R1,R0
   \       0x8C   0xD302             BCC.N    ??CrossCallReturnLabel_2
   \       0x8E   0x21D1             MOVS     R1,#+209
    210            }
   \                     ??EUSART_IrDAInit_1: (+1)
   \       0x90   0x.... 0x....      BL       ?Subroutine3
    211          
    212            // Initialize EUSART with common features to HF and LF.
    213            EUSART_AsyncInitCommon(eusart, &irdaInit->init, irdaInit, NULL);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x94   0x4622             MOV      R2,R4
   \       0x96   0x4621             MOV      R1,R4
   \       0x98   0x4628             MOV      R0,R5
   \       0x9A   0xB001             ADD      SP,SP,#+4
   \       0x9C   0x2300             MOVS     R3,#+0
   \       0x9E                      REQUIRE ?Subroutine2
   \       0x9E                      ;; // Fall through to label ?Subroutine2
    214          }
    215          
    216          #if defined(EUSART_PRESENT)
    217          /***************************************************************************//**
    218           * Initializes the EUSART when used in SPI mode.
    219           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void EUSART_SpiInit(EUSART_TypeDef *eusart, EUSART_SpiInit_TypeDef const *init)
    221          {
   \                     EUSART_SpiInit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
    222            // Make sure the module exists on the selected chip.
    223            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R8,??DataTable15
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable15_1
   \       0x10   0x.... 0x....      LDR.W    R9,??DataTable15_3
   \       0x14   0x.... 0x....      LDR.W    R7,??DataTable15_2
   \       0x18   0x4545             CMP      R5,R8
   \       0x1A   0xBF1C             ITT      NE
   \       0x1C   0x42BD             CMPNE    R5,R7
   \       0x1E   0x454D             CMPNE    R5,R9
   \       0x20   0xD002             BEQ.N    ??CrossCallReturnLabel_43
   \       0x22   0x21DF             MOVS     R1,#+223
   \       0x24   0x.... 0x....      BL       ?Subroutine7
    224            // Init structure must be provided.
    225            EFM_ASSERT(init);
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x28   0xB916             CBNZ.N   R6,??CrossCallReturnLabel_42
   \       0x2A   0x21E1             MOVS     R1,#+225
   \       0x2C   0x.... 0x....      BL       ?Subroutine7
    226            if (init->master) {
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x30   0x7B70             LDRB     R0,[R6, #+13]
   \       0x32   0x68B1             LDR      R1,[R6, #+8]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD00E             BEQ.N    ??EUSART_SpiInit_0
    227              EFM_ASSERT(init->bitRate <= 20000000);
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \       0x3C   0x4281             CMP      R1,R0
   \       0x3E   0xD302             BCC.N    ??CrossCallReturnLabel_41
   \       0x40   0x21E3             MOVS     R1,#+227
   \       0x42   0x.... 0x....      BL       ?Subroutine7
    228          
    229              if (init->advancedSettings) {
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x46   0x6930             LDR      R0,[R6, #+16]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xBF1C             ITT      NE
   \       0x4C   0x7BC0             LDRBNE   R0,[R0, #+15]
   \       0x4E   0x2800             CMPNE    R0,#+0
    230                EFM_ASSERT(!(init->advancedSettings->prsClockEnable));
   \       0x50   0xD01C             BEQ.N    ??CrossCallReturnLabel_39
   \       0x52   0x21E6             MOVS     R1,#+230
   \       0x54   0xE018             B.N      ??EUSART_SpiInit_1
    231              }
    232            } else {
    233              EFM_ASSERT(init->bitRate <= 10000000);
   \                     ??EUSART_SpiInit_0: (+1)
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \       0x5A   0x4281             CMP      R1,R0
   \       0x5C   0xD302             BCC.N    ??CrossCallReturnLabel_40
   \       0x5E   0x21E9             MOVS     R1,#+233
   \       0x60   0x.... 0x....      BL       ?Subroutine7
    234              if (init->advancedSettings && init->advancedSettings->forceLoad) {
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x64   0x6930             LDR      R0,[R6, #+16]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xBF1C             ITT      NE
   \       0x6A   0x7F01             LDRBNE   R1,[R0, #+28]
   \       0x6C   0x2900             CMPNE    R1,#+0
   \       0x6E   0xD00D             BEQ.N    ??CrossCallReturnLabel_39
    235                // If baud-rate is more than 5MHz, a value of 4 is recommended, any values
    236                // smaller than that can be tried out but avoid using 0. If baud-rate is less than 5MHz,
    237                // value of 5 is recommended, values higher than 5 can be used but it may make the load
    238                // error easy to occur. The recommended values for frequency bands should be sufficient
    239                // to work all the time.
    240                EFM_ASSERT((init->bitRate >= 5000000 && init->advancedSettings->setupWindow <= 4)
    241                           || (init->bitRate < 5000000 && init->advancedSettings->setupWindow >= 5));
   \       0x70   0x68B2             LDR      R2,[R6, #+8]
   \       0x72   0x.... 0x....      LDR.W    R1,??DataTable15_7
   \       0x76   0x7F40             LDRB     R0,[R0, #+29]
   \       0x78   0x428A             CMP      R2,R1
   \       0x7A   0xD302             BCC.N    ??EUSART_SpiInit_2
   \       0x7C   0x2804             CMP      R0,#+4
   \       0x7E   0xDD05             BLE.N    ??CrossCallReturnLabel_39
   \       0x80   0xE001             B.N      ??EUSART_SpiInit_3
   \                     ??EUSART_SpiInit_2: (+1)
   \       0x82   0x2804             CMP      R0,#+4
   \       0x84   0xDC02             BGT.N    ??CrossCallReturnLabel_39
   \                     ??EUSART_SpiInit_3: (+1)
   \       0x86   0x21F1             MOVS     R1,#+241
    242              }
    243            }
   \                     ??EUSART_SpiInit_1: (+1)
   \       0x88   0x.... 0x....      BL       ?Subroutine7
    244          
    245            EUSART_SyncInitCommon(eusart, init);
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x8C   0x6934             LDR      R4,[R6, #+16]
   \       0x8E   0x6868             LDR      R0,[R5, #+4]
   \       0x90   0xB110             CBZ.N    R0,??EUSART_SpiInit_4
   \                     ??EUSART_SpiInit_5: (+1)
   \       0x92   0x6D69             LDR      R1,[R5, #+84]
   \       0x94   0x0508             LSLS     R0,R1,#+20
   \       0x96   0xD1FC             BNE.N    ??EUSART_SpiInit_5
   \                     ??EUSART_SpiInit_4: (+1)
   \       0x98   0x4628             MOV      R0,R5
   \       0x9A   0x.... 0x....      BL       EUSART_Reset
   \       0x9E   0x692A             LDR      R2,[R5, #+16]
   \       0xA0   0x7B70             LDRB     R0,[R6, #+13]
   \       0xA2   0x7BB1             LDRB     R1,[R6, #+14]
   \       0xA4   0xF022 0x0287      BIC      R2,R2,#0x87
   \       0xA8   0x4302             ORRS     R2,R0,R2
   \       0xAA   0x430A             ORRS     R2,R1,R2
   \       0xAC   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0xB0   0x612A             STR      R2,[R5, #+16]
   \       0xB2   0xB30C             CBZ.N    R4,??EUSART_SpiInit_6
   \       0xB4   0x6932             LDR      R2,[R6, #+16]
   \       0xB6   0x6929             LDR      R1,[R5, #+16]
   \       0xB8   0x7F13             LDRB     R3,[R2, #+28]
   \       0xBA   0x7910             LDRB     R0,[R2, #+4]
   \       0xBC   0xF021 0x01F8      BIC      R1,R1,#0xF8
   \       0xC0   0xEA41 0x11C3      ORR      R1,R1,R3, LSL #+7
   \       0xC4   0x7A53             LDRB     R3,[R2, #+9]
   \       0xC6   0xEA41 0x1140      ORR      R1,R1,R0, LSL #+5
   \       0xCA   0x7810             LDRB     R0,[R2, #+0]
   \       0xCC   0xEA41 0x1103      ORR      R1,R1,R3, LSL #+4
   \       0xD0   0x7BD3             LDRB     R3,[R2, #+15]
   \       0xD2   0x4301             ORRS     R1,R0,R1
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable15_8
   \       0xD8   0xEA41 0x1183      ORR      R1,R1,R3, LSL #+6
   \       0xDC   0x6129             STR      R1,[R5, #+16]
   \       0xDE   0x68EB             LDR      R3,[R5, #+12]
   \       0xE0   0x6951             LDR      R1,[R2, #+20]
   \       0xE2   0x4003             ANDS     R3,R0,R3
   \       0xE4   0x6990             LDR      R0,[R2, #+24]
   \       0xE6   0x430B             ORRS     R3,R1,R3
   \       0xE8   0x7B11             LDRB     R1,[R2, #+12]
   \       0xEA   0x4303             ORRS     R3,R0,R3
   \       0xEC   0x7B50             LDRB     R0,[R2, #+13]
   \       0xEE   0xEA43 0x2381      ORR      R3,R3,R1, LSL #+10
   \       0xF2   0xEA43 0x33C0      ORR      R3,R3,R0, LSL #+15
   \       0xF6   0x60EB             STR      R3,[R5, #+12]
   \                     ??EUSART_SpiInit_6: (+1)
   \       0xF8   0x68A9             LDR      R1,[R5, #+8]
   \       0xFA   0x7BF0             LDRB     R0,[R6, #+15]
   \       0xFC   0x0889             LSRS     R1,R1,#+2
   \       0xFE   0xEA40 0x0181      ORR      R1,R0,R1, LSL #+2
   \      0x102   0xF041 0x0101      ORR      R1,R1,#0x1
   \      0x106   0x60A9             STR      R1,[R5, #+8]
   \      0x108   0xB1CC             CBZ.N    R4,??EUSART_SpiInit_7
   \      0x10A   0x6930             LDR      R0,[R6, #+16]
   \      0x10C   0x68A9             LDR      R1,[R5, #+8]
   \      0x10E   0x8842             LDRH     R2,[R0, #+2]
   \      0x110   0xF402 0x42C0      AND      R2,R2,#0x6000
   \      0x114   0x4311             ORRS     R1,R2,R1
   \      0x116   0x60A9             STR      R1,[R5, #+8]
   \      0x118   0x68A9             LDR      R1,[R5, #+8]
   \      0x11A   0x7942             LDRB     R2,[R0, #+5]
   \      0x11C   0xEA41 0x2182      ORR      R1,R1,R2, LSL #+10
   \      0x120   0x60A9             STR      R1,[R5, #+8]
   \      0x122   0x6A69             LDR      R1,[R5, #+36]
   \      0x124   0x7982             LDRB     R2,[R0, #+6]
   \      0x126   0xF362 0x1106      BFI      R1,R2,#+4,#+3
   \      0x12A   0x79C2             LDRB     R2,[R0, #+7]
   \      0x12C   0xF362 0x210A      BFI      R1,R2,#+8,#+3
   \      0x130   0x7A02             LDRB     R2,[R0, #+8]
   \      0x132   0x7F40             LDRB     R0,[R0, #+29]
   \      0x134   0xF362 0x310E      BFI      R1,R2,#+12,#+3
   \      0x138   0xF360 0x4113      BFI      R1,R0,#+16,#+4
   \      0x13C   0x6269             STR      R1,[R5, #+36]
   \                     ??EUSART_SpiInit_7: (+1)
   \      0x13E   0x6969             LDR      R1,[R5, #+20]
   \      0x140   0x7B30             LDRB     R0,[R6, #+12]
   \      0x142   0x0909             LSRS     R1,R1,#+4
   \      0x144   0xEA40 0x1101      ORR      R1,R0,R1, LSL #+4
   \      0x148   0x6169             STR      R1,[R5, #+20]
   \      0x14A   0xB384             CBZ.N    R4,??EUSART_SpiInit_8
   \      0x14C   0x6931             LDR      R1,[R6, #+16]
   \      0x14E   0x.... 0x....      LDR.W    R2,??DataTable15_9
   \      0x152   0x8948             LDRH     R0,[R1, #+10]
   \      0x154   0x61A8             STR      R0,[R5, #+24]
   \      0x156   0x7B48             LDRB     R0,[R1, #+13]
   \      0x158   0xB198             CBZ.N    R0,??EUSART_SpiInit_9
   \      0x15A   0x4545             CMP      R5,R8
   \      0x15C   0xD104             BNE.N    ??EUSART_SpiInit_10
   \      0x15E   0x7B88             LDRB     R0,[R1, #+14]
   \      0x160   0xF000 0x000F      AND      R0,R0,#0xF
   \      0x164   0x6050             STR      R0,[R2, #+4]
   \      0x166   0xE00C             B.N      ??EUSART_SpiInit_9
   \                     ??EUSART_SpiInit_10: (+1)
   \      0x168   0x42BD             CMP      R5,R7
   \      0x16A   0xD104             BNE.N    ??EUSART_SpiInit_11
   \      0x16C   0x7B88             LDRB     R0,[R1, #+14]
   \      0x16E   0xF000 0x000F      AND      R0,R0,#0xF
   \      0x172   0x6110             STR      R0,[R2, #+16]
   \      0x174   0xE005             B.N      ??EUSART_SpiInit_9
   \                     ??EUSART_SpiInit_11: (+1)
   \      0x176   0x454D             CMP      R5,R9
   \      0x178   0xD103             BNE.N    ??EUSART_SpiInit_9
   \      0x17A   0x7B88             LDRB     R0,[R1, #+14]
   \      0x17C   0xF000 0x000F      AND      R0,R0,#0xF
   \      0x180   0x61D0             STR      R0,[R2, #+28]
   \                     ??EUSART_SpiInit_9: (+1)
   \      0x182   0x7BC8             LDRB     R0,[R1, #+15]
   \      0x184   0xB198             CBZ.N    R0,??EUSART_SpiInit_8
   \      0x186   0x4545             CMP      R5,R8
   \      0x188   0xD104             BNE.N    ??EUSART_SpiInit_12
   \      0x18A   0x7C08             LDRB     R0,[R1, #+16]
   \      0x18C   0xF000 0x000F      AND      R0,R0,#0xF
   \      0x190   0x6010             STR      R0,[R2, #+0]
   \      0x192   0xE00C             B.N      ??EUSART_SpiInit_8
   \                     ??EUSART_SpiInit_12: (+1)
   \      0x194   0x42BD             CMP      R5,R7
   \      0x196   0xD104             BNE.N    ??EUSART_SpiInit_13
   \      0x198   0x7C08             LDRB     R0,[R1, #+16]
   \      0x19A   0xF000 0x000F      AND      R0,R0,#0xF
   \      0x19E   0x60D0             STR      R0,[R2, #+12]
   \      0x1A0   0xE005             B.N      ??EUSART_SpiInit_8
   \                     ??EUSART_SpiInit_13: (+1)
   \      0x1A2   0x454D             CMP      R5,R9
   \      0x1A4   0xD103             BNE.N    ??EUSART_SpiInit_8
   \      0x1A6   0x7C08             LDRB     R0,[R1, #+16]
   \      0x1A8   0xF000 0x000F      AND      R0,R0,#0xF
   \      0x1AC   0x6190             STR      R0,[R2, #+24]
   \                     ??EUSART_SpiInit_8: (+1)
   \      0x1AE   0x68B2             LDR      R2,[R6, #+8]
   \      0x1B0   0x6871             LDR      R1,[R6, #+4]
   \      0x1B2   0x4628             MOV      R0,R5
   \      0x1B4   0x.... 0x....      BL       EUSART_BaudrateSet
   \      0x1B8   0x2105             MOVS     R1,#+5
   \      0x1BA   0x4628             MOV      R0,R5
   \      0x1BC   0x.... 0x....      BL       EUSART_Enable
   \                     ??EUSART_SpiInit_14: (+1)
   \      0x1C0   0x6D68             LDR      R0,[R5, #+84]
   \      0x1C2   0xF010 0x0F28      TST      R0,#0x28
   \      0x1C6   0xD1FB             BNE.N    ??EUSART_SpiInit_14
   \      0x1C8   0x7830             LDRB     R0,[R6, #+0]
   \      0x1CA   0x63A8             STR      R0,[R5, #+56]
   \                     ??EUSART_SpiInit_15: (+1)
   \      0x1CC   0x6D68             LDR      R0,[R5, #+84]
   \      0x1CE   0xF010 0x0F28      TST      R0,#0x28
   \      0x1D2   0xD1FB             BNE.N    ??EUSART_SpiInit_15
   \                     ??EUSART_SpiInit_16: (+1)
   \      0x1D4   0x6CA8             LDR      R0,[R5, #+72]
   \      0x1D6   0x43C0             MVNS     R0,R0
   \      0x1D8   0xF410 0x5F40      TST      R0,#0x3000
   \      0x1DC   0xD1FA             BNE.N    ??EUSART_SpiInit_16
    246          }
   \      0x1DE   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x.... 0x....      B.W      assertEFM
    247          
    248          #if defined(EUSART_DALICFG_DALIEN)
    249          /***************************************************************************//**
    250           * Initializes the EUSART when used in DALI mode with the high or low
    251           * frequency clock.
    252           *
    253           * @note (1) When EUSART oversampling is set to eusartOVS0 (Disable), the peripheral
    254           *           clock frequency must be at least three times higher than the
    255           *           chosen baud rate. In LF, max input clock is 32768 (LFXO or LFRCO),
    256           *           thus 32768 / 3 ~ 9600 baudrate.
    257           ******************************************************************************/
    258          void EUSART_DaliInit(EUSART_TypeDef *eusart,
    259                               const EUSART_DaliInit_TypeDef *daliInit)
    260          {
    261            // Make sure the module exists on the selected chip.
    262            EFM_ASSERT(EUSART_REF_VALID(eusart));
    263            // Init structure must be provided.
    264            EFM_ASSERT(daliInit);
    265          
    266            if (daliInit->init.loopbackEnable) {
    267              // If LOOPBK in CFG0 is set to 1 in order to do loopback testing for DALI,
    268              // then in this case DALIRXENDT should be set to 1 and DALIRXDATABITS should
    269              // be set the same as DALITXDATABITS.
    270              EFM_ASSERT( (daliInit->TXdatabits >> _EUSART_DALICFG_DALITXDATABITS_SHIFT)
    271                          == (daliInit->RXdatabits >> _EUSART_DALICFG_DALIRXDATABITS_SHIFT));
    272            }
    273          
    274            if (daliInit->daliLowFrequencyEnable) {
    275              // Validate the low frequency capability of the EUSART instance.
    276              EFM_ASSERT(EUSART_EM2_CAPABLE(EUSART_NUM(eusart)));
    277              // The oversampling must be disabled when using a low frequency clock.
    278              EFM_ASSERT(daliInit->init.oversampling == eusartOVS0);
    279              // In LF, max baudrate is 9600. See Note #1.
    280              // but manchester is running at 2x clock 9600 => 4800
    281              EFM_ASSERT(daliInit->init.baudrate <= 4800);
    282            } else {
    283              EFM_ASSERT(daliInit->init.oversampling != eusartOVS0);
    284              // In HF, 2.4 kbps <= baudrate <= 1.152 Mbps.
    285              // but manchester is running at 2x clock so 2.4 kbps => 1.2 kbps
    286              EFM_ASSERT(daliInit->init.baudrate >= 1200 && daliInit->init.baudrate <= 57600);
    287            }
    288          
    289            // Initialize EUSART with common features to HF and LF.
    290            EUSART_AsyncInitCommon(eusart, &daliInit->init, NULL, daliInit);
    291          }
    292          #endif /* EUSART_DALICFG_DALIEN */
    293          #endif /* EUSART_PRESENT */
    294          
    295          /***************************************************************************//**
    296           * Configure the EUSART to its reset state.
    297           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    298          void EUSART_Reset(EUSART_TypeDef *eusart)
    299          {
   \                     EUSART_Reset: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    300            // 1. Properly disable the module
    301            EUSART_Disable(eusart);
   \        0x4   0x.... 0x....      BL       EUSART_Disable
    302          
    303          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_3)  \
    304            || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_4) \
    305            || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_5) \
    306            || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_6)
    307            // Manual toggling tx_sclk_mst to synchronize handshake
    308            // when switching from SPI master to other modes
    309            // so module is disabling correctly.
    310            uint32_t forcedClkCycle = 4u;
    311          
    312            while (forcedClkCycle--) {
    313              eusart->CFG2_SET = _EUSART_CFG2_CLKPHA_MASK;
    314              eusart->CFG2_CLR = _EUSART_CFG2_CLKPHA_MASK;
    315            }
    316          #endif
    317            // All registers that end with CFG should be programmed before EUSART gets enabled (EUSARTn_EN is set).
    318            // Set all configurable register to its reset value.
    319            // Note: Program desired settings to all registers that have names ending with CFG in the following sequence:
    320            //  a. CFG2
    321          #if defined(EUSART_PRESENT)
    322            eusart->CFG2 = _EUSART_CFG2_RESETVALUE;
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0x6120             STR      R0,[R4, #+16]
    323          #endif
    324            //  b. CFG1
    325            eusart->CFG1 = _EUSART_CFG1_RESETVALUE;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60E1             STR      R1,[R4, #+12]
    326            //  c. CFG0
    327            eusart->CFG0 = _EUSART_CFG0_RESETVALUE;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x60A0             STR      R0,[R4, #+8]
    328            //  d. FRAMECFG, DTXDATCFG, TIMINGCFG (Any sequence)
    329            eusart->FRAMECFG = _EUSART_FRAMECFG_RESETVALUE;
   \       0x14   0xF241 0x0102      MOVW     R1,#+4098
   \       0x18   0x6161             STR      R1,[R4, #+20]
    330          #if defined(EUSART_PRESENT)
    331            eusart->DTXDATCFG = _EUSART_DTXDATCFG_RESETVALUE;
   \       0x1A   0x61A0             STR      R0,[R4, #+24]
    332          #if defined(EUSART_DALICFG_DALIEN)
    333            eusart->DALICFG = _EUSART_DALICFG_RESETVALUE;
    334          #endif /* EUSART_DALICFG_DALIEN */
    335          #endif /* EUSART_PRESENT */
    336            eusart->TIMINGCFG = _EUSART_TIMINGCFG_RESETVALUE;
   \       0x1C   0xF44F 0x21A0      MOV      R1,#+327680
   \       0x20   0x6261             STR      R1,[R4, #+36]
    337            eusart->IRHFCFG = _EUSART_IRHFCFG_RESETVALUE;
   \       0x22   0x61E0             STR      R0,[R4, #+28]
    338            eusart->IRLFCFG = _EUSART_IRLFCFG_RESETVALUE;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x6221             STR      R1,[R4, #+32]
    339            eusart->STARTFRAMECFG = _EUSART_STARTFRAMECFG_RESETVALUE;
   \       0x28   0x62A0             STR      R0,[R4, #+40]
    340            eusart->SIGFRAMECFG = _EUSART_SIGFRAMECFG_RESETVALUE;
   \       0x2A   0x62E1             STR      R1,[R4, #+44]
    341            eusart->TRIGCTRL = _EUSART_TRIGCTRL_RESETVALUE;
   \       0x2C   0x6360             STR      R0,[R4, #+52]
    342            eusart->IEN = _EUSART_IEN_RESETVALUE;
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x6522             STR      R2,[R4, #+80]
    343            eusart->IF_CLR = _EUSART_IF_MASK;
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \       0x36   0xF242 0x004C      MOVW     R0,#+8268
   \       0x3A   0x5021             STR      R1,[R4, R0]
    344          
    345            // no need to sync while EN=0, multiple writes can be queued up,
    346            // and the last one will synchronize once EN=1
    347            eusart->CLKDIV = _EUSART_CLKDIV_RESETVALUE;
   \       0x3C   0x6322             STR      R2,[R4, #+48]
    348          }
   \       0x3E   0xBD10             POP      {R4,PC}
    349          
    350          /***************************************************************************//**
    351           * Enables/disables the EUSART receiver and/or transmitter.
    352           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          void EUSART_Enable(EUSART_TypeDef *eusart, EUSART_Enable_TypeDef enable)
    354          {
   \                     EUSART_Enable: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
    355            uint32_t tmp = 0;
    356          
    357            // Make sure that the module exists on the selected chip.
    358            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \                     ??CrossCallReturnLabel_44: (+1)
   \        0x6   0xBF1F             ITTTT    NE
   \        0x8   0x.... 0x....      LDRNE.W  R0,??DataTable15_2
   \        0xC   0x4284             CMPNE    R4,R0
   \        0xE   0x.... 0x....      LDRNE.W  R2,??DataTable15_3
   \       0x12   0x4294             CMPNE    R4,R2
   \       0x14   0xD003             BEQ.N    ??CrossCallReturnLabel_38
   \       0x16   0xF44F 0x71B3      MOV      R1,#+358
   \       0x1A   0x.... 0x....      BL       ?Subroutine6
    359          
    360            if (enable == eusartDisable) {
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xD103             BNE.N    ??EUSART_Enable_0
    361              EUSART_Disable(eusart);
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x28   0x....             B.N      EUSART_Disable
    362            } else {
    363              // Enable peripheral to configure Rx and Tx.
    364              eusart->EN_SET = EUSART_EN_EN;
   \                     ??EUSART_Enable_0: (+1)
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0xF241 0x0004      MOVW     R0,#+4100
   \       0x30   0x5021             STR      R1,[R4, R0]
    365          
    366              // Enable or disable Rx and/or Tx
    367              tmp = (enable)
    368                    & (_EUSART_CMD_RXEN_MASK | _EUSART_CMD_TXEN_MASK
    369                       | _EUSART_CMD_RXDIS_MASK | _EUSART_CMD_TXDIS_MASK);
   \       0x32   0xF005 0x000F      AND      R0,R5,#0xF
    370          
    371              eusart_sync(eusart, _EUSART_SYNCBUSY_MASK);
   \                     ??EUSART_Enable_1: (+1)
   \       0x36   0x6D62             LDR      R2,[R4, #+84]
   \       0x38   0x0511             LSLS     R1,R2,#+20
   \       0x3A   0xD1FC             BNE.N    ??EUSART_Enable_1
    372              eusart->CMD = tmp;
   \       0x3C   0x63A0             STR      R0,[R4, #+56]
    373              eusart_sync(eusart,
    374                          EUSART_SYNCBUSY_RXEN | EUSART_SYNCBUSY_TXEN
    375                          | EUSART_SYNCBUSY_RXDIS | EUSART_SYNCBUSY_TXDIS);
   \                     ??EUSART_Enable_2: (+1)
   \       0x3E   0x6D60             LDR      R0,[R4, #+84]
   \       0x40   0xF010 0x0F78      TST      R0,#0x78
   \       0x44   0xD1FB             BNE.N    ??EUSART_Enable_2
    376          
    377              // Wait for the status register to be updated.
    378              tmp = 0;
   \       0x46   0x2000             MOVS     R0,#+0
    379              if (_EUSART_CMD_RXEN_MASK & enable) {
   \       0x48   0x07E9             LSLS     R1,R5,#+31
   \       0x4A   0xBF48             IT       MI
   \       0x4C   0x2001             MOVMI    R0,#+1
    380                tmp |= EUSART_STATUS_RXENS;
    381              }
    382              if (_EUSART_CMD_TXEN_MASK & enable) {
   \       0x4E   0x0769             LSLS     R1,R5,#+29
   \       0x50   0xBF48             IT       MI
   \       0x52   0xF040 0x0002      ORRMI    R0,R0,#0x2
    383                tmp |= EUSART_STATUS_TXENS;
    384              }
    385              while ((eusart->STATUS & (_EUSART_STATUS_TXENS_MASK | _EUSART_STATUS_RXENS_MASK)) != tmp) {
   \                     ??EUSART_Enable_3: (+1)
   \       0x56   0x6CA1             LDR      R1,[R4, #+72]
   \       0x58   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x5C   0x4281             CMP      R1,R0
   \       0x5E   0xD1FA             BNE.N    ??EUSART_Enable_3
    386              }
    387            }
    388          }
   \       0x60   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x460D             MOV      R5,R1
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x....             LDR.N    R1,??DataTable15
   \        0x6   0x428C             CMP      R4,R1
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable15_1
   \        0x2   0x.... 0x....      B.W      assertEFM
    389          
    390          /***************************************************************************//**
    391           * Receives one 8 bit frame, (or part of 9 bit frame).
    392           *
    393           * @note (1) Handles the case where the RX Fifo Watermark has been set to N frames,
    394           *       and when N is greater than one. Attempt to read a frame from the RX Fifo.
    395           *       If the read is unsuccessful (i.e. no frames in the RX fifo), the RXFU
    396           *       interrupt flag is set. If the flag is set, wait to read again until the RXFL
    397           *       status flag is set, indicating there are N frames in the RX Fifo, where N
    398           *       is equal to the RX watermark level. Once there are N frames in the Fifo,
    399           *       read and return one frame. For consecutive N-1 reads there will be data available
    400           *       in the Fifo. Therefore, the RXUF interrupt will not be triggered eliminating
    401           *       delays between reads and sending N data frames in "bursts".
    402           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    403          uint8_t EUSART_Rx(EUSART_TypeDef *eusart)
    404          {
   \                     EUSART_Rx: (+1)
   \        0x0   0x4601             MOV      R1,R0
    405            // If RX watermark has not been configured.
    406            if ((eusart->CFG1 & _EUSART_CFG1_RXFIW_MASK) == EUSART_CFG1_RXFIW_DEFAULT) {
   \        0x2   0x68C8             LDR      R0,[R1, #+12]
   \        0x4   0xF010 0x4FF0      TST      R0,#0x78000000
   \        0x8   0xD103             BNE.N    ??EUSART_Rx_0
    407              while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     ??EUSART_Rx_1: (+1)
   \        0xA   0x6C8A             LDR      R2,[R1, #+72]
   \        0xC   0x0610             LSLS     R0,R2,#+24
   \        0xE   0xD5FC             BPL.N    ??EUSART_Rx_1
    408              } // Wait for incoming data.
    409              return (uint8_t)eusart->RXDATA;
   \       0x10   0xE006             B.N      ??EUSART_Rx_2
    410            }
    411          
    412            // See Note #1.
    413            uint8_t rx_data = eusart->RXDATA;
   \                     ??EUSART_Rx_0: (+1)
   \       0x12   0x6BC8             LDR      R0,[R1, #+60]
    414            // If there is underflow i.e Rx data read was unsuccessful
    415            if (eusart->IF & EUSART_IF_RXUF) {
   \       0x14   0x6CCB             LDR      R3,[R1, #+76]
   \       0x16   0x069A             LSLS     R2,R3,#+26
   \       0x18   0xD503             BPL.N    ??EUSART_Rx_3
    416              // Wait until data becomes available in Rx fifo
    417              while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     ??EUSART_Rx_4: (+1)
   \       0x1A   0x6C8B             LDR      R3,[R1, #+72]
   \       0x1C   0x0618             LSLS     R0,R3,#+24
   \       0x1E   0xD5FC             BPL.N    ??EUSART_Rx_4
    418              }
    419              // Read Rx data again once data is available in the fifo
    420              rx_data = eusart->RXDATA;
   \                     ??EUSART_Rx_2: (+1)
   \       0x20   0x6BC8             LDR      R0,[R1, #+60]
    421            }
    422          
    423            return rx_data;
   \                     ??EUSART_Rx_3: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x4770             BX       LR
    424          }
    425          
    426          /***************************************************************************//**
    427           * Receives one 8-9 bit frame with extended information.
    428           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    429          uint16_t EUSART_RxExt(EUSART_TypeDef *eusart)
    430          {
    431            while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     EUSART_RxExt: (+1)
   \                     ??EUSART_RxExt_0: (+1)
   \        0x0   0x6C82             LDR      R2,[R0, #+72]
   \        0x2   0x0611             LSLS     R1,R2,#+24
   \        0x4   0xD5FC             BPL.N    ??EUSART_RxExt_0
    432            } // Wait for incoming data.
    433          
    434            return (uint16_t)eusart->RXDATA;
   \        0x6   0x....             B.N      ?Subroutine1
    435          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6BC0             LDR      R0,[R0, #+60]
   \        0x2   0xB280             UXTH     R0,R0
   \        0x4   0x4770             BX       LR
    436          
    437          /***************************************************************************//**
    438           * Transmits one frame.
    439           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          void EUSART_Tx(EUSART_TypeDef *eusart, uint8_t data)
    441          {
   \                     EUSART_Tx: (+1)
   \        0x0   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
    442            // Check that transmit FIFO is not full.
    443            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
   \                     ?Subroutine0: (+1)
   \        0x0   0x6C83             LDR      R3,[R0, #+72]
   \        0x2   0x065A             LSLS     R2,R3,#+25
   \        0x4   0xD5FC             BPL.N    ?Subroutine0
    444            }
    445          
    446            eusart->TXDATA = (uint32_t)data;
   \        0x6   0x6441             STR      R1,[R0, #+68]
    447          }
   \        0x8   0x4770             BX       LR
    448          
    449          /***************************************************************************//**
    450           * Transmits one 8-9 bit frame with extended control.
    451           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    452          void EUSART_TxExt(EUSART_TypeDef *eusart, uint16_t data)
    453          {
   \                     EUSART_TxExt: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
    454            // Check that transmit FIFO is not full.
    455            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
    456            }
    457          
    458            eusart->TXDATA = (uint32_t)data;
    459          }
    460          
    461          #if defined(EUSART_PRESENT)
    462          /***************************************************************************//**
    463           * Transmits one 8-16 bit frame and return received data.
    464           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    465          uint16_t EUSART_Spi_TxRx(EUSART_TypeDef *eusart, uint16_t data)
    466          {
    467            // Check that transmit FIFO is not full.
    468            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
   \                     EUSART_Spi_TxRx: (+1)
   \                     ??EUSART_Spi_TxRx_0: (+1)
   \        0x0   0x6C83             LDR      R3,[R0, #+72]
   \        0x2   0x065A             LSLS     R2,R3,#+25
   \        0x4   0xD5FC             BPL.N    ??EUSART_Spi_TxRx_0
    469            }
    470            eusart->TXDATA = (uint32_t)data;
   \        0x6   0x6441             STR      R1,[R0, #+68]
    471          
    472            // Wait for Rx data to be available.
    473            while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
   \                     ??EUSART_Spi_TxRx_1: (+1)
   \        0x8   0x6C82             LDR      R2,[R0, #+72]
   \        0xA   0x0611             LSLS     R1,R2,#+24
   \        0xC   0xD5FC             BPL.N    ??EUSART_Spi_TxRx_1
    474            }
    475            return (uint16_t)eusart->RXDATA;
   \        0xE                      REQUIRE ?Subroutine1
   \        0xE                      ;; // Fall through to label ?Subroutine1
    476          }
    477          
    478          #if defined(EUSART_DALICFG_DALIEN)
    479          /***************************************************************************//**
    480           * Transmits one frame.
    481           ******************************************************************************/
    482          void EUSART_Dali_Tx(EUSART_TypeDef *eusart, uint32_t data)
    483          {
    484            uint32_t packet;
    485          
    486            // Make sure the module exists on the selected chip.
    487            EFM_ASSERT(EUSART_REF_VALID(eusart));
    488          
    489            // Check that transmit FIFO is not full.
    490            while (!(eusart->STATUS & EUSART_STATUS_TXFL)) {
    491            }
    492          
    493            for (uint8_t index = 0; index < dali_tx_nb_packets[EUSART_NUM(eusart)]; index++) {
    494              // when DALICFG.DALIEN is set to 1, then all 16 bits [15:0] represent data
    495              // First write to TXDATA register should contain 16 LSBs of the TX frame.
    496              // Transmission will not start after this first write.
    497              // Second write to TXDATA register should contain the remaining TX frame bits.
    498              // This second write will result in start of transmission.
    499              packet = (data >> (index * 16));
    500              // To ensure compatibility with future devices, always write bits [31:16] to 0.
    501              packet &= 0x0000FFFF;
    502              eusart->TXDATA = packet;
    503            }
    504          }
    505          
    506          /***************************************************************************//**
    507           * Receive one frame.
    508           ******************************************************************************/
    509          uint32_t EUSART_Dali_Rx(EUSART_TypeDef *eusart)
    510          {
    511            uint32_t data = 0;
    512          
    513            // Make sure the module exists on the selected chip.
    514            EFM_ASSERT(EUSART_REF_VALID(eusart));
    515          
    516            while (!(eusart->STATUS & EUSART_STATUS_RXFL)) {
    517            }   // Wait for incoming data.
    518          
    519            for (uint8_t index = 0; index < dali_rx_nb_packets[EUSART_NUM(eusart)]; index++) {
    520              // when DALICFG.DALIEN is set to 1, then all 16 bits [15:0] represent data
    521              // When receiving a frame that has more than 16 databits,
    522              // RXDATA register needs to be read twice:
    523              //    First read will provide 16 LSBs of the received frame.
    524              //    Second read will provide the remaining RX frame bits.
    525              data |= ((eusart->RXDATA & _EUSART_RXDATA_RXDATA_MASK) << (index * 16));
    526            }
    527            return data;
    528          }
    529          
    530          #endif /* EUSART_DALICFG_DALIEN */
    531          #endif /* EUSART_PRESENT */
    532          
    533          /***************************************************************************//**
    534           * Configures the baudrate (or as close as possible to a specified baudrate)
    535           * depending on the current mode of the EU(S)ART peripheral.
    536           *
    537           * @note (1) When the oversampling is disabled, the peripheral clock frequency
    538           *           must be at least three times higher than the chosen baud rate.
    539           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    540          void EUSART_BaudrateSet(EUSART_TypeDef *eusart,
    541                                  uint32_t refFreq,
    542                                  uint32_t baudrate)
    543          {
   \                     EUSART_BaudrateSet: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x0015             MOVS     R5,R2
    544            uint32_t          clkdiv;
    545            uint8_t           oversample = 0;
    546          
    547            // Prevent dividing by 0.
    548            EFM_ASSERT(baudrate);
   \        0xA   0x.... 0x....      LDR.W    R8,??DataTable15_1
   \        0xE   0xD103             BNE.N    ??CrossCallReturnLabel_34
   \       0x10   0xF44F 0x7109      MOV      R1,#+548
   \       0x14   0x.... 0x....      BL       ?Subroutine5
    549          
    550            // Make sure the module exists on the selected chip.
    551            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable15
   \       0x1C   0x4294             CMP      R4,R2
   \       0x1E   0xBF1F             ITTTT    NE
   \       0x20   0x.... 0x....      LDRNE.W  R1,??DataTable15_2
   \       0x24   0x428C             CMPNE    R4,R1
   \       0x26   0x.... 0x....      LDRNE.W  R0,??DataTable15_3
   \       0x2A   0x4284             CMPNE    R4,R0
   \       0x2C   0xD003             BEQ.N    ??CrossCallReturnLabel_33
   \       0x2E   0xF240 0x2127      MOVW     R1,#+551
   \       0x32   0x.... 0x....      BL       ?Subroutine5
    552          
    553            // Get the current frequency.
    554            if (!refFreq) {
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x36   0xB92E             CBNZ.N   R6,??EUSART_BaudrateSet_0
    555              refFreq = CMU_ClockFreqGet(EUSART_ClockGet(eusart));
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       EUSART_ClockGet
   \       0x3E   0x.... 0x....      BL       CMU_ClockFreqGet
   \       0x42   0x4606             MOV      R6,R0
    556            }
    557          
    558          #if defined(EUSART_PRESENT)
    559            // In synchronous mode (ex: SPI)
    560            if (eusart->CFG0 & _EUSART_CFG0_SYNC_MASK ) {
   \                     ??EUSART_BaudrateSet_0: (+1)
   \       0x44   0x68A1             LDR      R1,[R4, #+8]
   \       0x46   0x07C8             LSLS     R0,R1,#+31
   \       0x48   0xD53E             BPL.N    ??EUSART_BaudrateSet_1
    561              EFM_ASSERT(baudrate <= refFreq);
   \       0x4A   0x42AE             CMP      R6,R5
   \       0x4C   0xD203             BCS.N    ??CrossCallReturnLabel_32
   \       0x4E   0xF240 0x2131      MOVW     R1,#+561
   \       0x52   0x.... 0x....      BL       ?Subroutine5
    562          
    563              EUSART_Enable_TypeDef txrxEnStatus = eusartDisable;
    564              bool wasEnabled = (eusart->EN & _EUSART_EN_EN_MASK) == true;
    565              clkdiv = refFreq / baudrate - 1UL;
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x56   0xFBB6 0xF5F5      UDIV     R5,R6,R5
   \       0x5A   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \       0x5E   0x2700             MOVS     R7,#+0
   \       0x60   0x1E6D             SUBS     R5,R5,#+1
   \       0x62   0xF009 0x0901      AND      R9,R9,#0x1
    566          
    567              // If the desired bit rate requires a divider larger than the Synchronous divider bitfield (CFG2_SDIV),
    568              // the resulting spi master bus clock will be undefined because the result will be truncated.
    569              EFM_ASSERT(clkdiv <= (_EUSART_CFG2_SDIV_MASK >> _EUSART_CFG2_SDIV_SHIFT));
   \       0x66   0xF5B5 0x7F80      CMP      R5,#+256
   \       0x6A   0xD303             BCC.N    ??CrossCallReturnLabel_31
   \       0x6C   0xF240 0x2139      MOVW     R1,#+569
   \       0x70   0x.... 0x....      BL       ?Subroutine5
    570          
    571              if (wasEnabled) {
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x74   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x78   0xD01A             BEQ.N    ??EUSART_BaudrateSet_2
   \                     ??EUSART_BaudrateSet_3: (+1)
   \       0x7A   0x6D60             LDR      R0,[R4, #+84]
   \       0x7C   0xF010 0x0F28      TST      R0,#0x28
   \       0x80   0xD1FB             BNE.N    ??EUSART_BaudrateSet_3
    572                eusart_sync(eusart, _EUSART_SYNCBUSY_RXEN_MASK | _EUSART_SYNCBUSY_TXEN_MASK);
    573          
    574                // Save the state of the reveiver and transmitter before disabling the peripheral.
    575                if (eusart->STATUS & (_EUSART_STATUS_RXENS_MASK | _EUSART_STATUS_TXENS_MASK)) {
   \       0x82   0x6CA0             LDR      R0,[R4, #+72]
   \       0x84   0xF010 0x0F03      TST      R0,#0x3
   \       0x88   0xBF18             IT       NE
   \       0x8A   0x2705             MOVNE    R7,#+5
    576                  txrxEnStatus = eusartEnable;
   \       0x8C   0xD10D             BNE.N    ??EUSART_BaudrateSet_4
    577                } else if (eusart->STATUS & (_EUSART_STATUS_RXENS_MASK)) {
   \       0x8E   0x6CA1             LDR      R1,[R4, #+72]
   \       0x90   0x07C8             LSLS     R0,R1,#+31
   \       0x92   0xBF48             IT       MI
   \       0x94   0x2709             MOVMI    R7,#+9
    578                  txrxEnStatus = eusartEnableRx;
   \       0x96   0xD408             BMI.N    ??EUSART_BaudrateSet_4
    579                } else if (eusart->STATUS & (_EUSART_STATUS_TXENS_MASK)) {
   \       0x98   0x6CA1             LDR      R1,[R4, #+72]
   \       0x9A   0x0788             LSLS     R0,R1,#+30
   \       0x9C   0xBF4F             ITEEE    MI
    580                  txrxEnStatus = eusartEnableTx;
   \       0x9E   0x2706             MOVMI    R7,#+6
    581                } else {
    582                  EFM_ASSERT(false);
   \       0xA0   0xF240 0x2146      MOVWPL   R1,#+582
   \       0xA4   0x4640             MOVPL    R0,R8
   \       0xA6   0x.... 0x....      BLPL     assertEFM
    583                }
    584          
    585                // Disable the eusart to be able to modify the CFG2 register.
    586                EUSART_Disable(eusart);
   \                     ??EUSART_BaudrateSet_4: (+1)
   \       0xAA   0x4620             MOV      R0,R4
   \       0xAC   0x.... 0x....      BL       EUSART_Disable
    587              }
    588          
    589              // In Synchronous mode the clock divider that is managing the bitRate
    590              // is located inside the sdiv bitfield of the CFG2 register instead of
    591              // the CLKDIV register combined with the oversample setting for asynchronous mode.
    592              eusart->CFG2 = (eusart->CFG2 & ~(_EUSART_CFG2_SDIV_MASK)) | ((clkdiv << _EUSART_CFG2_SDIV_SHIFT) & _EUSART_CFG2_SDIV_MASK);
   \                     ??EUSART_BaudrateSet_2: (+1)
   \       0xB0   0x6920             LDR      R0,[R4, #+16]
    593          
    594              if (wasEnabled) {
   \       0xB2   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xB6   0xF365 0x601F      BFI      R0,R5,#+24,#+8
   \       0xBA   0x6120             STR      R0,[R4, #+16]
   \       0xBC   0xD036             BEQ.N    ??EUSART_BaudrateSet_5
    595                EUSART_Enable(eusart, txrxEnStatus);
   \       0xBE   0x4639             MOV      R1,R7
   \       0xC0   0x4620             MOV      R0,R4
   \       0xC2   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \       0xC6   0x....             B.N      EUSART_Enable
    596              }
    597            } else // In asynchronous mode (ex: UART)
    598          #endif
    599            {
    600              // The peripheral must be enabled to configure the baud rate.
    601              EFM_ASSERT(eusart->EN == EUSART_EN_EN);
   \                     ??EUSART_BaudrateSet_1: (+1)
   \       0xC8   0x6860             LDR      R0,[R4, #+4]
   \       0xCA   0x2801             CMP      R0,#+1
   \       0xCC   0xD003             BEQ.N    ??CrossCallReturnLabel_30
   \       0xCE   0xF240 0x2159      MOVW     R1,#+601
   \       0xD2   0x.... 0x....      BL       ?Subroutine5
    602          
    603          #if defined(EUSART_DALICFG_DALIEN)
    604              if (eusart->DALICFG & EUSART_DALICFG_DALIEN) {
    605                // adjust for manchester double-clocking scheme
    606                baudrate *= 2;
    607              }
    608          #endif
    609          
    610              /*
    611               * Use integer division to avoid forcing in float division
    612               * utils, and yet keep rounding effect errors to a minimum.
    613               *
    614               * CLKDIV is given by:
    615               *
    616               * CLKDIV = 256 * (fUARTn/(oversample * br) - 1)
    617               * or
    618               * CLKDIV = (256 * fUARTn)/(oversample * br) - 256
    619               *
    620               * Since fUARTn may be derived from HFCORECLK, consider the overflow when
    621               * using integer arithmetic.
    622               *
    623               * The basic problem with integer division in the above formula is that
    624               * the dividend (256 * fUARTn) may become higher than the maximum 32 bit
    625               * integer. Yet, the dividend should be evaluated first before dividing
    626               * to get as small rounding effects as possible.
    627               * Also, harsh restrictions on the maximum fUARTn value should not be made.
    628               *
    629               * Since the last 3 bits of CLKDIV are don't care, base the
    630               * integer arithmetic on the below formula:
    631               *
    632               * CLKDIV/8 = ((32*fUARTn)/(br * Oversample)) - 32
    633               *
    634               * and calculate 1/8 of CLKDIV first. This allows for fUARTn
    635               * up to 128 MHz without overflowing a 32 bit value.
    636               */
    637          
    638              // Map oversampling.
    639              switch (eusart->CFG0 & _EUSART_CFG0_OVS_MASK) {
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0xD6   0x68A0             LDR      R0,[R4, #+8]
   \       0xD8   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \       0xDC   0xD008             BEQ.N    ??EUSART_BaudrateSet_6
   \       0xDE   0x2820             CMP      R0,#+32
   \       0xE0   0xD026             BEQ.N    ??EUSART_BaudrateSet_7
   \       0xE2   0x2840             CMP      R0,#+64
   \       0xE4   0xD02D             BEQ.N    ??EUSART_BaudrateSet_8
   \       0xE6   0x2860             CMP      R0,#+96
   \       0xE8   0xD036             BEQ.N    ??EUSART_BaudrateSet_9
   \       0xEA   0x2880             CMP      R0,#+128
   \       0xEC   0xD03D             BEQ.N    ??EUSART_BaudrateSet_10
   \       0xEE   0xE046             B.N      ??EUSART_BaudrateSet_11
    640                case eusartOVS16:
    641                  EFM_ASSERT(baudrate <= (refFreq / 16));
   \                     ??EUSART_BaudrateSet_6: (+1)
   \       0xF0   0x0931             LSRS     R1,R6,#+4
   \       0xF2   0x42A9             CMP      R1,R5
   \       0xF4   0xD203             BCS.N    ??CrossCallReturnLabel_29
   \       0xF6   0xF240 0x2181      MOVW     R1,#+641
   \       0xFA   0x.... 0x....      BL       ?Subroutine5
    642                  oversample = 16;
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0xFE   0x2010             MOVS     R0,#+16
    643                  break;
    644          
    645                case eusartOVS8:
    646                  EFM_ASSERT(baudrate <= (refFreq / 8));
    647                  oversample = 8;
    648                  break;
    649          
    650                case eusartOVS6:
    651                  EFM_ASSERT(baudrate <= (refFreq / 6));
    652                  oversample = 6;
    653                  break;
    654          
    655                case eusartOVS4:
    656                  EFM_ASSERT(baudrate <= (refFreq / 4));
    657                  oversample = 4;
    658                  break;
    659          
    660                case eusartOVS0:
    661                  EFM_ASSERT(refFreq >= (3 * baudrate)); // See Note #1.
    662                  oversample = 1;
    663                  break;
    664          
    665                default:
    666                  // Invalid input
    667                  EFM_ASSERT(0);
    668                  break;
    669              }
    670          
    671              if (oversample > 0U) {
    672                // Calculate and set the CLKDIV with fractional bits.
    673                clkdiv  = (32 * refFreq) / (baudrate * oversample);
    674                clkdiv -= 32;
    675                clkdiv *= 8;
   \                     ??EUSART_BaudrateSet_12: (+1)
   \      0x100   0x4345             MULS     R5,R0,R5
   \      0x102   0x0176             LSLS     R6,R6,#+5
   \      0x104   0xFBB6 0xF5F5      UDIV     R5,R6,R5
    676          
    677                // Verify that the resulting clock divider is within limits.
    678                EFM_ASSERT(clkdiv <= _EUSART_CLKDIV_MASK);
   \      0x108   0x.... 0x....      LDR.W    R6,??DataTable15_11
   \      0x10C   0x3D20             SUBS     R5,R5,#+32
   \      0x10E   0x00ED             LSLS     R5,R5,#+3
   \      0x110   0x42B5             CMP      R5,R6
   \      0x112   0xD903             BLS.N    ??CrossCallReturnLabel_28
   \      0x114   0xF240 0x21A6      MOVW     R1,#+678
   \      0x118   0x.... 0x....      BL       ?Subroutine5
    679          
    680                // If the EFM_ASSERT is not enabled, make sure not to write to reserved bits.
    681                clkdiv &= _EUSART_CLKDIV_MASK;
   \                     ??CrossCallReturnLabel_28: (+1)
   \      0x11C   0x4035             ANDS     R5,R6,R5
    682          
    683                eusart_sync(eusart, _EUSART_SYNCBUSY_DIV_MASK);
   \                     ??EUSART_BaudrateSet_13: (+1)
   \      0x11E   0x6D60             LDR      R0,[R4, #+84]
   \      0x120   0x07C1             LSLS     R1,R0,#+31
   \      0x122   0xD4FC             BMI.N    ??EUSART_BaudrateSet_13
    684                eusart->CLKDIV = clkdiv;
   \      0x124   0x6325             STR      R5,[R4, #+48]
    685                eusart_sync(eusart, _EUSART_SYNCBUSY_DIV_MASK);
   \                     ??EUSART_BaudrateSet_14: (+1)
   \      0x126   0x6D60             LDR      R0,[R4, #+84]
   \      0x128   0x07C1             LSLS     R1,R0,#+31
   \      0x12A   0xD4FC             BMI.N    ??EUSART_BaudrateSet_14
    686              }
    687            }
    688          }
   \                     ??EUSART_BaudrateSet_5: (+1)
   \      0x12C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   \                     ??EUSART_BaudrateSet_7: (+1)
   \      0x130   0x08F0             LSRS     R0,R6,#+3
   \      0x132   0x42A8             CMP      R0,R5
   \      0x134   0xD203             BCS.N    ??CrossCallReturnLabel_27
   \      0x136   0xF240 0x2186      MOVW     R1,#+646
   \      0x13A   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_27: (+1)
   \      0x13E   0x2008             MOVS     R0,#+8
   \      0x140   0xE7DE             B.N      ??EUSART_BaudrateSet_12
   \                     ??EUSART_BaudrateSet_8: (+1)
   \      0x142   0x2006             MOVS     R0,#+6
   \      0x144   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \      0x148   0x42A8             CMP      R0,R5
   \      0x14A   0xD203             BCS.N    ??CrossCallReturnLabel_26
   \      0x14C   0xF240 0x218B      MOVW     R1,#+651
   \      0x150   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_26: (+1)
   \      0x154   0x2006             MOVS     R0,#+6
   \      0x156   0xE7D3             B.N      ??EUSART_BaudrateSet_12
   \                     ??EUSART_BaudrateSet_9: (+1)
   \      0x158   0x08B0             LSRS     R0,R6,#+2
   \      0x15A   0x42A8             CMP      R0,R5
   \      0x15C   0xD203             BCS.N    ??CrossCallReturnLabel_25
   \      0x15E   0xF44F 0x7124      MOV      R1,#+656
   \      0x162   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_25: (+1)
   \      0x166   0x2004             MOVS     R0,#+4
   \      0x168   0xE7CA             B.N      ??EUSART_BaudrateSet_12
   \                     ??EUSART_BaudrateSet_10: (+1)
   \      0x16A   0xEB05 0x0045      ADD      R0,R5,R5, LSL #+1
   \      0x16E   0x4286             CMP      R6,R0
   \      0x170   0xD203             BCS.N    ??CrossCallReturnLabel_24
   \      0x172   0xF240 0x2195      MOVW     R1,#+661
   \      0x176   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_24: (+1)
   \      0x17A   0x2001             MOVS     R0,#+1
   \      0x17C   0xE7C0             B.N      ??EUSART_BaudrateSet_12
   \                     ??EUSART_BaudrateSet_11: (+1)
   \      0x17E   0x4640             MOV      R0,R8
   \      0x180   0xF240 0x219B      MOVW     R1,#+667
   \      0x184   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \      0x188   0x.... 0x....      B.W      assertEFM

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x.... 0x....      B.W      assertEFM
    689          
    690          /***************************************************************************//**
    691           * Gets the current baudrate.
    692           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    693          uint32_t EUSART_BaudrateGet(EUSART_TypeDef *eusart)
    694          {
   \                     EUSART_BaudrateGet: (+1)
   \        0x0   0xE92D 0x45F8      PUSH     {R3-R8,R10,LR}
   \        0x4   0x4607             MOV      R7,R0
    695            uint32_t freq;
    696            uint32_t div = 1;
    697            uint32_t br = 0;
    698            EUSART_OVS_TypeDef ovs = eusartOVS0;
    699          
    700            // Make sure the module exists on the selected chip.
    701            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable15
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable15_1
   \        0xE   0x428F             CMP      R7,R1
   \       0x10   0xBF1F             ITTTT    NE
   \       0x12   0x.... 0x....      LDRNE.W  R0,??DataTable15_2
   \       0x16   0x4287             CMPNE    R7,R0
   \       0x18   0x.... 0x....      LDRNE.W  R2,??DataTable15_3
   \       0x1C   0x4297             CMPNE    R7,R2
   \       0x1E   0xD004             BEQ.N    ??EUSART_BaudrateGet_0
   \       0x20   0xF240 0x21BD      MOVW     R1,#+701
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       assertEFM
    702          
    703            freq = CMU_ClockFreqGet(EUSART_ClockGet(eusart));
   \                     ??EUSART_BaudrateGet_0: (+1)
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0x.... 0x....      BL       EUSART_ClockGet
   \       0x30   0x.... 0x....      BL       CMU_ClockFreqGet
    704          
    705          #if defined(EUSART_PRESENT)
    706            // In synchronous mode (ex: SPI)
    707            if (eusart->CFG0 & _EUSART_CFG0_SYNC_MASK) {
   \       0x34   0x68B9             LDR      R1,[R7, #+8]
   \       0x36   0x4680             MOV      R8,R0
   \       0x38   0x07C8             LSLS     R0,R1,#+31
   \       0x3A   0xD505             BPL.N    ??EUSART_BaudrateGet_1
    708              div = (eusart->CFG2 & _EUSART_CFG2_SDIV_MASK) >> _EUSART_CFG2_SDIV_SHIFT;
    709              br = freq / (div + 1);
   \       0x3C   0x6939             LDR      R1,[R7, #+16]
   \       0x3E   0x0E09             LSRS     R1,R1,#+24
   \       0x40   0x1C49             ADDS     R1,R1,#+1
   \       0x42   0xFBB8 0xF0F1      UDIV     R0,R8,R1
   \       0x46   0xE039             B.N      ??EUSART_BaudrateGet_2
    710            }
    711            // In asynchronous mode (ex: UART)
    712            else
    713          #endif
    714            {
    715              div = eusart->CLKDIV;
   \                     ??EUSART_BaudrateGet_1: (+1)
   \       0x48   0x6B3C             LDR      R4,[R7, #+48]
    716              ovs = (EUSART_OVS_TypeDef)(eusart->CFG0 & _EUSART_CFG0_OVS_MASK);
    717              br = EUSART_AsyncBaudrateCalc(freq, div, ovs);
   \       0x4A   0x68BF             LDR      R7,[R7, #+8]
   \       0x4C   0x.... 0x....      LDR.W    R6,??DataTable15_11
   \       0x50   0x42B4             CMP      R4,R6
   \       0x52   0xF007 0x07E0      AND      R7,R7,#0xE0
   \       0x56   0xD904             BLS.N    ??EUSART_BaudrateGet_3
   \       0x58   0xF44F 0x619D      MOV      R1,#+1256
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0x.... 0x....      BL       assertEFM
   \                     ??EUSART_BaudrateGet_3: (+1)
   \       0x62   0x4034             ANDS     R4,R6,R4
   \       0x64   0xB1A7             CBZ.N    R7,??EUSART_BaudrateGet_4
   \       0x66   0x2F20             CMP      R7,#+32
   \       0x68   0xD00F             BEQ.N    ??EUSART_BaudrateGet_5
   \       0x6A   0x2F40             CMP      R7,#+64
   \       0x6C   0xD00A             BEQ.N    ??EUSART_BaudrateGet_6
   \       0x6E   0x2F60             CMP      R7,#+96
   \       0x70   0xD005             BEQ.N    ??EUSART_BaudrateGet_7
   \       0x72   0x2F80             CMP      R7,#+128
   \       0x74   0xD121             BNE.N    ??EUSART_BaudrateGet_8
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xF44F 0x7680      MOV      R6,#+256
   \       0x7C   0xE00A             B.N      ??EUSART_BaudrateGet_9
   \                     ??EUSART_BaudrateGet_7: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0x2640             MOVS     R6,#+64
   \       0x82   0xE007             B.N      ??EUSART_BaudrateGet_9
   \                     ??EUSART_BaudrateGet_6: (+1)
   \       0x84   0x2003             MOVS     R0,#+3
   \       0x86   0x2680             MOVS     R6,#+128
   \       0x88   0xE004             B.N      ??EUSART_BaudrateGet_9
   \                     ??EUSART_BaudrateGet_5: (+1)
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x2620             MOVS     R6,#+32
   \       0x8E   0xE001             B.N      ??EUSART_BaudrateGet_9
   \                     ??EUSART_BaudrateGet_4: (+1)
   \       0x90   0x2001             MOVS     R0,#+1
   \       0x92   0x2610             MOVS     R6,#+16
   \                     ??EUSART_BaudrateGet_9: (+1)
   \       0x94   0xF504 0x7480      ADD      R4,R4,#+256
   \       0x98   0x4344             MULS     R4,R4,R0
   \       0x9A   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x9E   0x4682             MOV      R10,R0
   \       0xA0   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0xA4   0xFBA2 0x0106      UMULL    R0,R1,R2,R6
   \       0xA8   0x4622             MOV      R2,R4
   \       0xAA   0xFB03 0x1106      MLA      R1,R3,R6,R1
   \       0xAE   0x2300             MOVS     R3,#+0
   \       0xB0   0x.... 0x....      BL       __aeabi_uldivmod
   \       0xB4   0xFB0A 0x0006      MLA      R0,R10,R6,R0
   \       0xB8   0xE000             B.N      ??EUSART_BaudrateGet_2
   \                     ??EUSART_BaudrateGet_8: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
    718          
    719          #if defined(EUSART_DALICFG_DALIEN)
    720              if (eusart->DALICFG & EUSART_DALICFG_DALIEN) {
    721                // adjust for manchester double-clocking scheme
    722                br /= 2;
    723              }
    724          #endif
    725            }
    726          
    727            return br;
   \                     ??EUSART_BaudrateGet_2: (+1)
   \       0xBC   0xE8BD 0x85F2      POP      {R1,R4-R8,R10,PC}
    728          }
    729          
    730          /***************************************************************************//**
    731           * Enable/Disable reception operations until the configured start frame is
    732           * received.
    733           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    734          void EUSART_RxBlock(EUSART_TypeDef *eusart, EUSART_BlockRx_TypeDef enable)
    735          {
   \                     EUSART_RxBlock: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
    736            uint32_t tmp;
    737          
    738            // Make sure that the module exists on the selected chip.
    739            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \                     ??CrossCallReturnLabel_45: (+1)
   \        0x6   0xBF1F             ITTTT    NE
   \        0x8   0x....             LDRNE.N  R0,??DataTable15_2
   \        0xA   0x4284             CMPNE    R4,R0
   \        0xC   0x....             LDRNE.N  R2,??DataTable15_3
   \        0xE   0x4294             CMPNE    R4,R2
   \       0x10   0xD003             BEQ.N    ??CrossCallReturnLabel_37
   \       0x12   0xF240 0x21E3      MOVW     R1,#+739
   \       0x16   0x.... 0x....      BL       ?Subroutine6
    740          
    741            tmp   = ((uint32_t)(enable));
    742            tmp  &= (_EUSART_CMD_RXBLOCKEN_MASK | _EUSART_CMD_RXBLOCKDIS_MASK);
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x1A   0xF005 0x0030      AND      R0,R5,#0x30
    743          
    744            eusart_sync(eusart, EUSART_SYNCBUSY_RXBLOCKEN | EUSART_SYNCBUSY_RXBLOCKDIS);
   \                     ??EUSART_RxBlock_0: (+1)
   \       0x1E   0x6D61             LDR      R1,[R4, #+84]
   \       0x20   0xF411 0x7FC0      TST      R1,#0x180
   \       0x24   0xD1FB             BNE.N    ??EUSART_RxBlock_0
    745            eusart->CMD_SET = tmp;
   \       0x26   0xF241 0x0138      MOVW     R1,#+4152
   \       0x2A   0x5060             STR      R0,[R4, R1]
    746            eusart_sync(eusart, EUSART_SYNCBUSY_RXBLOCKEN | EUSART_SYNCBUSY_RXBLOCKDIS);
   \                     ??EUSART_RxBlock_1: (+1)
   \       0x2C   0x6D60             LDR      R0,[R4, #+84]
   \       0x2E   0xF410 0x7FC0      TST      R0,#0x180
   \       0x32   0xD1FB             BNE.N    ??EUSART_RxBlock_1
    747          
    748            tmp = 0u;
   \       0x34   0x2000             MOVS     R0,#+0
    749            if ((_EUSART_CMD_RXBLOCKEN_MASK & enable) != 0u) {
   \       0x36   0x06E9             LSLS     R1,R5,#+27
   \       0x38   0xBF48             IT       MI
   \       0x3A   0x2008             MOVMI    R0,#+8
    750              tmp |= EUSART_STATUS_RXBLOCK;
    751            }
    752            while ((eusart->STATUS & _EUSART_STATUS_RXBLOCK_MASK) != tmp) {
   \                     ??EUSART_RxBlock_2: (+1)
   \       0x3C   0x6CA1             LDR      R1,[R4, #+72]
   \       0x3E   0xF001 0x0108      AND      R1,R1,#0x8
   \       0x42   0x4281             CMP      R1,R0
   \       0x44   0xD1FA             BNE.N    ??EUSART_RxBlock_2
    753            } // Wait for the status register to be updated.
    754          }
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}
    755          
    756          /***************************************************************************//**
    757           * Enables/Disables the tristating of the transmitter output.
    758           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    759          void  EUSART_TxTristateSet(EUSART_TypeDef *eusart,
    760                                     EUSART_TristateTx_TypeDef enable)
    761          {
   \                     EUSART_TxTristateSet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
    762            uint32_t tmp;
    763          
    764            // Make sure that the module exists on the selected chip.
    765            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \                     ??CrossCallReturnLabel_46: (+1)
   \        0x6   0xBF1F             ITTTT    NE
   \        0x8   0x....             LDRNE.N  R0,??DataTable15_2
   \        0xA   0x4284             CMPNE    R4,R0
   \        0xC   0x....             LDRNE.N  R2,??DataTable15_3
   \        0xE   0x4294             CMPNE    R4,R2
   \       0x10   0xD003             BEQ.N    ??CrossCallReturnLabel_36
   \       0x12   0xF240 0x21FD      MOVW     R1,#+765
   \       0x16   0x.... 0x....      BL       ?Subroutine6
    766          
    767            tmp   = ((uint32_t)(enable));
    768            tmp  &= (_EUSART_CMD_TXTRIEN_MASK | _EUSART_CMD_TXTRIDIS_MASK);
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x1A   0xF005 0x01C0      AND      R1,R5,#0xC0
    769          
    770            eusart_sync(eusart, EUSART_SYNCBUSY_TXTRIEN | EUSART_SYNCBUSY_TXTRIDIS);
   \                     ??EUSART_TxTristateSet_0: (+1)
   \       0x1E   0x6D60             LDR      R0,[R4, #+84]
   \       0x20   0xF410 0x6FC0      TST      R0,#0x600
   \       0x24   0xD1FB             BNE.N    ??EUSART_TxTristateSet_0
    771            eusart->CMD = tmp;
   \       0x26   0x63A1             STR      R1,[R4, #+56]
    772            eusart_sync(eusart, EUSART_SYNCBUSY_TXTRIEN | EUSART_SYNCBUSY_TXTRIDIS);
   \                     ??EUSART_TxTristateSet_1: (+1)
   \       0x28   0x6D60             LDR      R0,[R4, #+84]
   \       0x2A   0xF410 0x6FC0      TST      R0,#0x600
   \       0x2E   0xD1FB             BNE.N    ??EUSART_TxTristateSet_1
    773          
    774            tmp = 0u;
   \       0x30   0x2000             MOVS     R0,#+0
    775            if ((_EUSART_CMD_TXTRIEN_MASK & enable) != 0u) {
   \       0x32   0x0669             LSLS     R1,R5,#+25
   \       0x34   0xBF48             IT       MI
   \       0x36   0x2010             MOVMI    R0,#+16
    776              tmp |= EUSART_STATUS_TXTRI;
    777            }
    778            while ((eusart->STATUS & _EUSART_STATUS_TXTRI_MASK) != tmp) {
   \                     ??EUSART_TxTristateSet_2: (+1)
   \       0x38   0x6CA1             LDR      R1,[R4, #+72]
   \       0x3A   0xF001 0x0110      AND      R1,R1,#0x10
   \       0x3E   0x4281             CMP      R1,R0
   \       0x40   0xD1FA             BNE.N    ??EUSART_TxTristateSet_2
    779            } // Wait for the status register to be updated.
    780          }
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}
    781          
    782          /***************************************************************************//**
    783           * Initializes the automatic enabling of transmissions and/or reception using
    784           * the PRS as a trigger.
    785           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    786          void EUSART_PrsTriggerEnable(EUSART_TypeDef *eusart,
    787                                       const EUSART_PrsTriggerInit_TypeDef *init)
    788          {
   \                     EUSART_PrsTriggerEnable: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
    789            uint32_t tmp;
    790          
    791            // Make sure that the module exists on the selected chip.
    792            EFM_ASSERT(EUSART_REF_VALID(eusart));
   \        0x6   0x.... 0x....      LDR.W    R9,??DataTable15
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x....             LDR.N    R6,??DataTable15_1
   \        0xE   0x....             LDR.N    R7,??DataTable15_3
   \       0x10   0x.... 0x....      LDR.W    R8,??DataTable15_2
   \       0x14   0x454C             CMP      R4,R9
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x4544             CMPNE    R4,R8
   \       0x1A   0x42BC             CMPNE    R4,R7
   \       0x1C   0xD003             BEQ.N    ??CrossCallReturnLabel_1
   \       0x1E   0xF44F 0x7146      MOV      R1,#+792
   \       0x22   0x.... 0x....      BL       ?Subroutine3
    793          
    794            // The peripheral must be enabled to configure the PRS trigger.
    795            EFM_ASSERT(eusart->EN == EUSART_EN_EN);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x26   0x6860             LDR      R0,[R4, #+4]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD003             BEQ.N    ??CrossCallReturnLabel_0
   \       0x2C   0xF240 0x311B      MOVW     R1,#+795
   \       0x30   0x.... 0x....      BL       ?Subroutine3
    796          
    797          #if defined(EUART_PRESENT)
    798            PRS->CONSUMER_EUART0_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUART0_TRIGGER_MASK);
    799          #else
    800          
    801          #if defined(EUSART0)
    802            if (eusart == EUSART0) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable15_12
   \       0x36   0x454C             CMP      R4,R9
   \       0x38   0xD104             BNE.N    ??EUSART_PrsTriggerEnable_0
    803              PRS->CONSUMER_EUSART0_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART0_TRIGGER_MASK);
   \       0x3A   0x7869             LDRB     R1,[R5, #+1]
   \       0x3C   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x40   0x6001             STR      R1,[R0, #+0]
   \       0x42   0xE00C             B.N      ??EUSART_PrsTriggerEnable_1
    804            }
    805          #endif
    806          #if defined(EUSART1)
    807            if (eusart == EUSART1) {
   \                     ??EUSART_PrsTriggerEnable_0: (+1)
   \       0x44   0x4544             CMP      R4,R8
   \       0x46   0xD104             BNE.N    ??EUSART_PrsTriggerEnable_2
    808              PRS->CONSUMER_EUSART1_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART1_TRIGGER_MASK);
   \       0x48   0x7869             LDRB     R1,[R5, #+1]
   \       0x4A   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
   \       0x50   0xE005             B.N      ??EUSART_PrsTriggerEnable_1
    809            }
    810          #endif
    811          #if defined(EUSART2)
    812            if (eusart == EUSART2) {
   \                     ??EUSART_PrsTriggerEnable_2: (+1)
   \       0x52   0x42BC             CMP      R4,R7
   \       0x54   0xD103             BNE.N    ??EUSART_PrsTriggerEnable_1
    813              PRS->CONSUMER_EUSART2_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART2_TRIGGER_MASK);
   \       0x56   0x7869             LDRB     R1,[R5, #+1]
   \       0x58   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x5C   0x6181             STR      R1,[R0, #+24]
    814            }
    815          #endif
    816          #if defined(EUSART3)
    817            if (eusart == EUSART3) {
    818              PRS->CONSUMER_EUSART3_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART3_TRIGGER_MASK);
    819            }
    820          #endif
    821          #if defined(EUSART4)
    822            if (eusart == EUSART4) {
    823              PRS->CONSUMER_EUSART4_TRIGGER = (init->prs_trigger_channel & _PRS_CONSUMER_EUSART4_TRIGGER_MASK);
    824            }
    825          #endif
    826          #endif
    827          
    828            tmp   = ((uint32_t)(init->prs_trigger_enable));
    829            tmp  &= (_EUSART_TRIGCTRL_RXTEN_MASK | _EUSART_TRIGCTRL_TXTEN_MASK);
    830          
    831            eusart->TRIGCTRL_SET = tmp;
   \                     ??EUSART_PrsTriggerEnable_1: (+1)
   \       0x5E   0x7829             LDRB     R1,[R5, #+0]
   \       0x60   0xF241 0x0034      MOVW     R0,#+4148
   \       0x64   0x.... 0x....      BL       ?Subroutine10
    832            eusart_sync(eusart, EUSART_SYNCBUSY_RXTEN | EUSART_SYNCBUSY_TXTEN);
    833          
    834            tmp   = ~((uint32_t)(init->prs_trigger_enable));
    835            tmp  &= (_EUSART_TRIGCTRL_RXTEN_MASK | _EUSART_TRIGCTRL_TXTEN_MASK);
    836            eusart->TRIGCTRL_CLR = tmp;
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0x68   0x7829             LDRB     R1,[R5, #+0]
   \       0x6A   0xF242 0x0034      MOVW     R0,#+8244
   \       0x6E   0x43C9             MVNS     R1,R1
   \       0x70   0x.... 0x....      BL       ?Subroutine10
    837            eusart_sync(eusart, EUSART_SYNCBUSY_RXTEN | EUSART_SYNCBUSY_TXTEN);
    838          }
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0x74   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xF001 0x0103      AND      R1,R1,#0x3
   \        0x4   0x5021             STR      R1,[R4, R0]
   \                     ??Subroutine10_0: (+1)
   \        0x6   0x6D61             LDR      R1,[R4, #+84]
   \        0x8   0xF011 0x0F06      TST      R1,#0x6
   \        0xC   0xD1FB             BNE.N    ??Subroutine10_0
   \        0xE   0x4770             BX       LR
    839          
    840          /*******************************************************************************
    841           **************************   LOCAL FUNCTIONS   ********************************
    842           ******************************************************************************/
    843          
    844          /***************************************************************************//**
    845           * Gets the clock associated to the specified EUSART instance.
    846           *
    847           * @param eusart Pointer to the EUSART peripheral register block.
    848           *
    849           * @return Clock corresponding to the eusart.
    850           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    851          static CMU_Clock_TypeDef EUSART_ClockGet(EUSART_TypeDef *eusart)
    852          {
    853            CMU_Clock_TypeDef clock;
    854          
    855          #if defined(EUART0)
    856            if (eusart == EUART0) {
    857              clock = cmuClock_EUART0;
    858            }
    859          #endif
    860          #if defined(EUSART0)
    861            if (eusart == EUSART0) {
   \                     EUSART_ClockGet: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable15
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD101             BNE.N    ??EUSART_ClockGet_0
    862              clock = cmuClock_EUSART0;
   \        0x8   0x2056             MOVS     R0,#+86
    863            }
    864          #endif
    865          #if defined(EUSART1)
    866            else if (eusart == EUSART1) {
    867              clock = cmuClock_EUSART1;
    868            }
    869          #endif
    870          #if defined(EUSART2)
    871            else if (eusart == EUSART2) {
    872              clock = cmuClock_EUSART2;
    873            }
    874          #endif
    875          #if defined(EUSART3)
    876            else if (eusart == EUSART3) {
    877              clock = cmuClock_EUSART3;
    878            }
    879          #endif
    880          #if defined(EUSART4)
    881            else if (eusart == EUSART4) {
    882              clock = cmuClock_EUSART4;
    883            }
    884          #endif
    885            else {
    886              EFM_ASSERT(0);
    887              return (CMU_Clock_TypeDef)0u;
    888            }
    889            return clock;
   \        0xA   0xBD02             POP      {R1,PC}
   \                     ??EUSART_ClockGet_0: (+1)
   \        0xC   0x....             LDR.N    R1,??DataTable15_2
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD101             BNE.N    ??EUSART_ClockGet_1
   \       0x12   0x2057             MOVS     R0,#+87
   \       0x14   0xBD02             POP      {R1,PC}
   \                     ??EUSART_ClockGet_1: (+1)
   \       0x16   0x....             LDR.N    R1,??DataTable15_3
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xD101             BNE.N    ??EUSART_ClockGet_2
   \       0x1C   0x2058             MOVS     R0,#+88
   \       0x1E   0xBD02             POP      {R1,PC}
   \                     ??EUSART_ClockGet_2: (+1)
   \       0x20   0xF240 0x3176      MOVW     R1,#+886
   \       0x24   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD02             POP      {R1,PC}
    890          }
    891          
    892          /***************************************************************************//**
    893           * Initializes the EUSART with asynchronous common settings to high
    894           * and low frequency clock.
    895           *
    896           * @param eusart Pointer to the EUSART peripheral register block.
    897           * @param init A pointer to the initialization structure.
    898           * @param irdaInit Pointer to IrDA initialization structure.
    899           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    900          static void EUSART_AsyncInitCommon(EUSART_TypeDef *eusart,
    901                                             const EUSART_UartInit_TypeDef  *init,
    902                                             const EUSART_IrDAInit_TypeDef  *irdaInit,
    903                                             const EUSART_DaliInit_TypeDef  *daliInit)
    904          {
   \                     EUSART_AsyncInitCommon: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4614             MOV      R4,R2
    905            // LF register about to be modified requires sync busy check.
    906            if (eusart->EN) {
   \        0x6   0x6872             LDR      R2,[R6, #+4]
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0xB11A             CBZ.N    R2,??EUSART_AsyncInitCommon_0
    907              eusart_sync(eusart, _EUSART_SYNCBUSY_MASK);
   \        0xC   0xF640 0x71FF      MOVW     R1,#+4095
   \       0x10   0x.... 0x....      BL       eusart_sync
    908            }
    909            // Initialize EUSART registers to hardware reset state.
    910            EUSART_Reset(eusart);
   \                     ??EUSART_AsyncInitCommon_0: (+1)
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x.... 0x....      BL       EUSART_Reset
    911          
    912            // Configure frame format
    913            eusart->FRAMECFG = (eusart->FRAMECFG & ~(_EUSART_FRAMECFG_DATABITS_MASK
    914                                                     | _EUSART_FRAMECFG_STOPBITS_MASK
    915                                                     | _EUSART_FRAMECFG_PARITY_MASK))
    916                               | (uint32_t)(init->databits)
    917                               | (uint32_t)(init->parity)
    918                               | (uint32_t)(init->stopbits);
   \       0x1A   0x6972             LDR      R2,[R6, #+20]
   \       0x1C   0x7B69             LDRB     R1,[R5, #+13]
   \       0x1E   0x....             LDR.N    R0,??DataTable15_13
   \       0x20   0x4002             ANDS     R2,R0,R2
   \       0x22   0xF9B5 0x000E      LDRSH    R0,[R5, #+14]
   \       0x26   0x430A             ORRS     R2,R1,R2
   \       0x28   0xF9B5 0x1010      LDRSH    R1,[R5, #+16]
   \       0x2C   0x4302             ORRS     R2,R0,R2
    919          
    920            // Configure global configuration register 0.
    921            eusart->CFG0 = (eusart->CFG0 & ~(_EUSART_CFG0_OVS_MASK
    922                                             | _EUSART_CFG0_LOOPBK_MASK
    923                                             | _EUSART_CFG0_MVDIS_MASK))
    924                           | (uint32_t)(init->oversampling)
    925                           | (uint32_t)(init->loopbackEnable)
    926                           | (uint32_t)(init->majorityVote);
   \       0x2E   0x....             LDR.N    R0,??DataTable15_14
   \       0x30   0x430A             ORRS     R2,R1,R2
   \       0x32   0x6172             STR      R2,[R6, #+20]
   \       0x34   0x68B2             LDR      R2,[R6, #+8]
   \       0x36   0x7B29             LDRB     R1,[R5, #+12]
   \       0x38   0x4002             ANDS     R2,R0,R2
   \       0x3A   0x7E28             LDRB     R0,[R5, #+24]
   \       0x3C   0x430A             ORRS     R2,R1,R2
   \       0x3E   0x6969             LDR      R1,[R5, #+20]
   \       0x40   0x4302             ORRS     R2,R0,R2
   \       0x42   0x430A             ORRS     R2,R1,R2
   \       0x44   0x60B2             STR      R2,[R6, #+8]
    927          
    928            if (init->baudrate == 0) {
   \       0x46   0x68A8             LDR      R0,[R5, #+8]
   \       0x48   0xB918             CBNZ.N   R0,??EUSART_AsyncInitCommon_1
    929              eusart->CFG0 |= EUSART_CFG0_AUTOBAUDEN;
   \       0x4A   0x68B0             LDR      R0,[R6, #+8]
   \       0x4C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \       0x50   0x60B0             STR      R0,[R6, #+8]
    930            }
    931          
    932            if (init->advancedSettings) {
   \                     ??EUSART_AsyncInitCommon_1: (+1)
   \       0x52   0x69E8             LDR      R0,[R5, #+28]
   \       0x54   0xF241 0x011C      MOVW     R1,#+4124
   \       0x58   0x1873             ADDS     R3,R6,R1
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD078             BEQ.N    ??EUSART_AsyncInitCommon_2
    933              eusart->CFG0 = (eusart->CFG0 & ~(_EUSART_CFG0_ERRSDMA_MASK | _EUSART_CFG0_AUTOTRI_MASK
    934                                               | _EUSART_CFG0_RXINV_MASK | _EUSART_CFG0_TXINV_MASK
    935                                               | _EUSART_CFG0_CCEN_MASK  | _EUSART_CFG0_MPM_MASK
    936                                               | _EUSART_CFG0_MPAB_MASK  | _EUSART_CFG0_MSBF_MASK))
    937                             | (uint32_t)(init->advancedSettings->dmaHaltOnError << _EUSART_CFG0_ERRSDMA_SHIFT)
    938                             | (uint32_t)(init->advancedSettings->txAutoTristate << _EUSART_CFG0_AUTOTRI_SHIFT)
    939                             | (uint32_t)(init->advancedSettings->invertIO & (_EUSART_CFG0_RXINV_MASK | _EUSART_CFG0_TXINV_MASK))
    940                             | (uint32_t)(init->advancedSettings->collisionDetectEnable << _EUSART_CFG0_CCEN_SHIFT)
    941                             | (uint32_t)(init->advancedSettings->multiProcessorEnable << _EUSART_CFG0_MPM_SHIFT)
    942                             | (uint32_t)(init->advancedSettings->multiProcessorAddressBitHigh << _EUSART_CFG0_MPAB_SHIFT)
    943                             | (uint32_t)(init->advancedSettings->msbFirst << _EUSART_CFG0_MSBF_SHIFT);
   \       0x5E   0x68B2             LDR      R2,[R6, #+8]
   \       0x60   0x7A07             LDRB     R7,[R0, #+8]
   \       0x62   0x....             LDR.N    R1,??DataTable15_15
   \       0x64   0x400A             ANDS     R2,R1,R2
   \       0x66   0xEA42 0x5287      ORR      R2,R2,R7, LSL #+22
   \       0x6A   0x7A81             LDRB     R1,[R0, #+10]
   \       0x6C   0x8887             LDRH     R7,[R0, #+4]
   \       0x6E   0xEA42 0x4241      ORR      R2,R2,R1, LSL #+17
   \       0x72   0x7841             LDRB     R1,[R0, #+1]
   \       0x74   0xF407 0x47C0      AND      R7,R7,#0x6000
   \       0x78   0x433A             ORRS     R2,R7,R2
   \       0x7A   0x7B47             LDRB     R7,[R0, #+13]
   \       0x7C   0xEA42 0x0281      ORR      R2,R2,R1, LSL #+2
   \       0x80   0x7B81             LDRB     R1,[R0, #+14]
   \       0x82   0xEA42 0x02C7      ORR      R2,R2,R7, LSL #+3
   \       0x86   0x7887             LDRB     R7,[R0, #+2]
   \       0x88   0xEA42 0x1201      ORR      R2,R2,R1, LSL #+4
    944          
    945              // Configure global configuration register 1.
    946              eusart->CFG1 = (eusart->CFG1 & ~(_EUSART_CFG1_RXFIW_MASK | _EUSART_CFG1_TXFIW_MASK
    947                                               | _EUSART_CFG1_RXDMAWU_MASK | _EUSART_CFG1_TXDMAWU_MASK))
    948                             | (uint32_t)(init->advancedSettings->RxFifoWatermark)
    949                             | (uint32_t)(init->advancedSettings->TxFifoWatermark)
    950                             | (uint32_t)(init->advancedSettings->dmaWakeUpOnRx << _EUSART_CFG1_RXDMAWU_SHIFT)
    951                             | (uint32_t)(init->advancedSettings->dmaWakeUpOnTx << _EUSART_CFG1_TXDMAWU_SHIFT);
   \       0x8C   0x....             LDR.N    R1,??DataTable15_16
   \       0x8E   0xEA42 0x2287      ORR      R2,R2,R7, LSL #+10
   \       0x92   0x60B2             STR      R2,[R6, #+8]
   \       0x94   0x68F7             LDR      R7,[R6, #+12]
   \       0x96   0x6902             LDR      R2,[R0, #+16]
   \       0x98   0x400F             ANDS     R7,R1,R7
   \       0x9A   0x6941             LDR      R1,[R0, #+20]
   \       0x9C   0x4317             ORRS     R7,R2,R7
   \       0x9E   0x7982             LDRB     R2,[R0, #+6]
   \       0xA0   0x430F             ORRS     R7,R1,R7
   \       0xA2   0x79C1             LDRB     R1,[R0, #+7]
   \       0xA4   0xEA47 0x2782      ORR      R7,R7,R2, LSL #+10
   \       0xA8   0xEA47 0x2741      ORR      R7,R7,R1, LSL #+9
   \       0xAC   0x60F7             STR      R7,[R6, #+12]
    952          
    953              if (init->advancedSettings->hwFlowControl == eusartHwFlowControlCts
    954                  || init->advancedSettings->hwFlowControl == eusartHwFlowControlCtsAndRts) {
   \       0xAE   0x7801             LDRB     R1,[R0, #+0]
   \       0xB0   0x2901             CMP      R1,#+1
   \       0xB2   0xBF18             IT       NE
   \       0xB4   0x2903             CMPNE    R1,#+3
   \       0xB6   0xD103             BNE.N    ??EUSART_AsyncInitCommon_3
    955                eusart->CFG1 |= EUSART_CFG1_CTSEN;
   \       0xB8   0x68F1             LDR      R1,[R6, #+12]
   \       0xBA   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0xBE   0x60F1             STR      R1,[R6, #+12]
    956              }
    957              // Enable RTS route pin if necessary. CTS is an input so it is enabled by default.
    958              if ((init->advancedSettings->hwFlowControl == eusartHwFlowControlRts)
    959                  || (init->advancedSettings->hwFlowControl == eusartHwFlowControlCtsAndRts)) {
   \                     ??EUSART_AsyncInitCommon_3: (+1)
   \       0xC0   0x7801             LDRB     R1,[R0, #+0]
   \       0xC2   0x....             LDR.N    R2,??DataTable15_3
   \       0xC4   0x....             LDR.N    R7,??DataTable15_2
   \       0xC6   0x.... 0x....      LDR.W    R12,??DataTable15
   \       0xCA   0x2902             CMP      R1,#+2
   \       0xCC   0xBF16             ITET     NE
   \       0xCE   0x2903             CMPNE    R1,#+3
   \       0xD0   0x.... 0x....      LDREQ.W  LR,??DataTable15_17
   \       0xD4   0x.... 0x....      LDRNE.W  LR,??DataTable15_18
    960          #if defined(EUART0)
    961                GPIO->EUARTROUTE_SET->ROUTEEN = GPIO_EUART_ROUTEEN_RTSPEN;
    962          #elif defined(EUSART0)
    963                GPIO->EUSARTROUTE_SET[EUSART_NUM(eusart)].ROUTEEN = GPIO_EUSART_ROUTEEN_RTSPEN;
    964          #endif
    965              } else {
    966          #if defined(EUART0)
    967                GPIO->EUARTROUTE_CLR->ROUTEEN = GPIO_EUART_ROUTEEN_RTSPEN;
    968          #elif defined(EUSART0)
    969                GPIO->EUSARTROUTE_CLR[EUSART_NUM(eusart)].ROUTEEN = GPIO_EUSART_ROUTEEN_RTSPEN;
   \       0xD8   0x4566             CMP      R6,R12
   \       0xDA   0xBF08             IT       EQ
   \       0xDC   0xF10E 0x0E20      ADDEQ    LR,LR,#+32
   \       0xE0   0xD008             BEQ.N    ??EUSART_AsyncInitCommon_4
   \       0xE2   0x42BE             CMP      R6,R7
   \       0xE4   0xBF08             IT       EQ
   \       0xE6   0xF10E 0x0E40      ADDEQ    LR,LR,#+64
   \       0xEA   0xD003             BEQ.N    ??EUSART_AsyncInitCommon_4
   \       0xEC   0x4296             CMP      R6,R2
   \       0xEE   0xBF08             IT       EQ
   \       0xF0   0xF10E 0x0E60      ADDEQ    LR,LR,#+96
   \                     ??EUSART_AsyncInitCommon_4: (+1)
   \       0xF4   0x2102             MOVS     R1,#+2
   \       0xF6   0xF8CE 0x1000      STR      R1,[LR, #+0]
    970          #endif
    971              }
    972              eusart->STARTFRAMECFG_SET = (uint32_t)init->advancedSettings->startFrame;
   \       0xFA   0xF890 0xE009      LDRB     LR,[R0, #+9]
   \       0xFE   0xF8C3 0xE00C      STR      LR,[R3, #+12]
    973              if (init->advancedSettings->startFrame) {
   \      0x102   0x7A41             LDRB     R1,[R0, #+9]
   \      0x104   0xB119             CBZ.N    R1,??EUSART_AsyncInitCommon_5
    974                eusart->CFG1 |= EUSART_CFG1_SFUBRX;
   \      0x106   0x68F1             LDR      R1,[R6, #+12]
   \      0x108   0xF441 0x6100      ORR      R1,R1,#0x800
   \      0x10C   0x60F1             STR      R1,[R6, #+12]
    975              }
    976              if (init->advancedSettings->prsRxEnable) {
   \                     ??EUSART_AsyncInitCommon_5: (+1)
   \      0x10E   0x7AC1             LDRB     R1,[R0, #+11]
   \      0x110   0xB1C1             CBZ.N    R1,??EUSART_AsyncInitCommon_6
    977                eusart->CFG1 |= EUSART_CFG1_RXPRSEN;
   \      0x112   0x68F1             LDR      R1,[R6, #+12]
    978                // Configure PRS channel as input data line for EUSART.
    979          #if defined(EUART_PRESENT)
    980                PRS->CONSUMER_EUART0_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUART0_RX_MASK);
    981          #elif defined(EUSART_PRESENT)
    982          
    983                if (eusart == EUSART0) {
   \      0x114   0x4566             CMP      R6,R12
   \      0x116   0xF441 0x4100      ORR      R1,R1,#0x8000
   \      0x11A   0x60F1             STR      R1,[R6, #+12]
   \      0x11C   0x....             LDR.N    R1,??DataTable15_19
   \      0x11E   0xD104             BNE.N    ??EUSART_AsyncInitCommon_7
    984                  PRS->CONSUMER_EUSART0_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART0_RX_MASK);
   \      0x120   0x7B02             LDRB     R2,[R0, #+12]
   \      0x122   0xF002 0x020F      AND      R2,R2,#0xF
   \      0x126   0x600A             STR      R2,[R1, #+0]
   \      0x128   0xE00C             B.N      ??EUSART_AsyncInitCommon_6
    985                }
    986          #if defined(EUSART1)
    987                if (eusart == EUSART1) {
   \                     ??EUSART_AsyncInitCommon_7: (+1)
   \      0x12A   0x42BE             CMP      R6,R7
   \      0x12C   0xD104             BNE.N    ??EUSART_AsyncInitCommon_8
    988                  PRS->CONSUMER_EUSART1_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART1_RX_MASK);
   \      0x12E   0x7B02             LDRB     R2,[R0, #+12]
   \      0x130   0xF002 0x020F      AND      R2,R2,#0xF
   \      0x134   0x60CA             STR      R2,[R1, #+12]
   \      0x136   0xE005             B.N      ??EUSART_AsyncInitCommon_6
    989                }
    990          #endif
    991          #if defined(EUSART2)
    992                if (eusart == EUSART2) {
   \                     ??EUSART_AsyncInitCommon_8: (+1)
   \      0x138   0x4296             CMP      R6,R2
   \      0x13A   0xD103             BNE.N    ??EUSART_AsyncInitCommon_6
    993                  PRS->CONSUMER_EUSART2_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART2_RX_MASK);
   \      0x13C   0x7B02             LDRB     R2,[R0, #+12]
   \      0x13E   0xF002 0x020F      AND      R2,R2,#0xF
   \      0x142   0x618A             STR      R2,[R1, #+24]
    994                }
    995          #endif
    996          #if defined(EUSART3)
    997                if (eusart == EUSART3) {
    998                  PRS->CONSUMER_EUSART3_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART3_RX_MASK);
    999                }
   1000          #endif
   1001          #if defined(EUSART4)
   1002                if (eusart == EUSART4) {
   1003                  PRS->CONSUMER_EUSART4_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART4_RX_MASK);
   1004                }
   1005          #endif
   1006          #endif
   1007              }
   1008          
   1009              // Configure global configuration timing register.
   1010              eusart->TIMINGCFG = (eusart->TIMINGCFG & ~_EUSART_TIMINGCFG_TXDELAY_MASK)
   1011                                  | (uint32_t)(init->advancedSettings->autoTxDelay);
   \                     ??EUSART_AsyncInitCommon_6: (+1)
   \      0x144   0x6A71             LDR      R1,[R6, #+36]
   \      0x146   0x7BC0             LDRB     R0,[R0, #+15]
   \      0x148   0x0889             LSRS     R1,R1,#+2
   \      0x14A   0xEA40 0x0181      ORR      R1,R0,R1, LSL #+2
   \      0x14E   0x6271             STR      R1,[R6, #+36]
   1012            }
   1013          
   1014            if (irdaInit) {
   \                     ??EUSART_AsyncInitCommon_2: (+1)
   \      0x150   0xB184             CBZ.N    R4,??EUSART_AsyncInitCommon_9
   1015              if (irdaInit->irDALowFrequencyEnable) {
   \      0x152   0xF104 0x0120      ADD      R1,R4,#+32
   \      0x156   0x7808             LDRB     R0,[R1, #+0]
   \      0x158   0xB110             CBZ.N    R0,??EUSART_AsyncInitCommon_10
   1016                eusart->IRLFCFG_SET = (uint32_t)(EUSART_IRLFCFG_IRLFEN);
   \      0x15A   0x2101             MOVS     R1,#+1
   \      0x15C   0x6059             STR      R1,[R3, #+4]
   \      0x15E   0xE009             B.N      ??EUSART_AsyncInitCommon_9
   1017              } else {
   1018                // Configure IrDA HF configuration register.
   1019                eusart->IRHFCFG_SET = (eusart->IRHFCFG & ~(_EUSART_IRHFCFG_IRHFEN_MASK
   1020                                                           | _EUSART_IRHFCFG_IRHFEN_MASK
   1021                                                           | _EUSART_IRHFCFG_IRHFFILT_MASK))
   1022                                      | (uint32_t)(EUSART_IRHFCFG_IRHFEN)
   1023                                      | (uint32_t)(irdaInit->irDAPulseWidth)
   1024                                      | (uint32_t)(irdaInit->irDARxFilterEnable);
   \                     ??EUSART_AsyncInitCommon_10: (+1)
   \      0x160   0x69F2             LDR      R2,[R6, #+28]
   \      0x162   0x7888             LDRB     R0,[R1, #+2]
   \      0x164   0x7849             LDRB     R1,[R1, #+1]
   \      0x166   0xF022 0x0209      BIC      R2,R2,#0x9
   \      0x16A   0x4302             ORRS     R2,R0,R2
   \      0x16C   0x430A             ORRS     R2,R1,R2
   \      0x16E   0xF042 0x0201      ORR      R2,R2,#0x1
   \      0x172   0x601A             STR      R2,[R3, #+0]
   1025              }
   1026            }
   1027          
   1028          #if defined(EUSART_DALICFG_DALIEN)
   1029            // DALI-specific configuration section
   1030            if (daliInit) {
   1031              if (init->loopbackEnable) {
   1032                // If LOOPBK in CFG0 is set to 1 in order to do loopback testing for DALI,
   1033                // then in this case DALIRXENDT should be set to 1.
   1034                eusart->DALICFG_SET = EUSART_DALICFG_DALIRXENDT;
   1035              }
   1036          
   1037              if (EUSART_REF_VALID(eusart)) {
   1038                uint8_t index = EUSART_NUM(eusart);
   1039          
   1040                // keep track of the number of 16-bits packet to send
   1041                if (daliInit->TXdatabits <= eusartDaliTxDataBits16) {
   1042                  dali_tx_nb_packets[index] = 1;
   1043                } else {
   1044                  dali_tx_nb_packets[index] = 2;
   1045                }
   1046          
   1047                // keep track of the number of 16-bits packet to receive
   1048                if (daliInit->RXdatabits <= eusartDaliRxDataBits16) {
   1049                  dali_rx_nb_packets[index] = 1;
   1050                } else {
   1051                  dali_rx_nb_packets[index] = 2;
   1052                }
   1053              }
   1054          
   1055              // Configure the numbers of bits per TX and RX frames
   1056              eusart->DALICFG = (eusart->DALICFG & ~(_EUSART_DALICFG_DALITXDATABITS_MASK
   1057                                                     | _EUSART_DALICFG_DALIRXDATABITS_MASK))
   1058                                | daliInit->TXdatabits
   1059                                | daliInit->RXdatabits;
   1060              eusart->DALICFG_SET = EUSART_DALICFG_DALIEN;
   1061            }
   1062          #else
   1063            (void)(daliInit);
   1064          #endif /* EUSART_DALICFG_DALIEN */
   1065          
   1066            // Enable EUSART IP.
   1067            EUSART_Enable(eusart, eusartEnable);
   \                     ??EUSART_AsyncInitCommon_9: (+1)
   \      0x174   0x2105             MOVS     R1,#+5
   \      0x176   0x4630             MOV      R0,R6
   \      0x178   0x.... 0x....      BL       EUSART_Enable
   1068          
   1069            // Configure the baudrate if auto baud detection is not used.
   1070            if (init->baudrate) {
   \      0x17C   0x68AA             LDR      R2,[R5, #+8]
   \      0x17E   0xB11A             CBZ.N    R2,??EUSART_AsyncInitCommon_11
   1071              EUSART_BaudrateSet(eusart, init->refFreq, init->baudrate);
   \      0x180   0x6869             LDR      R1,[R5, #+4]
   \      0x182   0x4630             MOV      R0,R6
   \      0x184   0x.... 0x....      BL       EUSART_BaudrateSet
   1072            }
   1073          
   1074            // Finally enable the Rx and/or Tx channel (as specified).
   1075            EUSART_Enable(eusart, init->enable);
   \                     ??EUSART_AsyncInitCommon_11: (+1)
   \      0x188   0x7829             LDRB     R1,[R5, #+0]
   \      0x18A   0x4630             MOV      R0,R6
   \      0x18C   0x.... 0x....      BL       EUSART_Enable
   1076            while (~EUSART_StatusGet(eusart) & (_EUSART_STATUS_RXIDLE_MASK | _EUSART_STATUS_TXIDLE_MASK)) {
   \                     ??EUSART_AsyncInitCommon_12: (+1)
   \      0x190   0x6CB0             LDR      R0,[R6, #+72]
   \      0x192   0x43C0             MVNS     R0,R0
   \      0x194   0xF410 0x5F40      TST      R0,#0x3000
   \      0x198   0xD1FA             BNE.N    ??EUSART_AsyncInitCommon_12
   1077            }
   1078          }
   \      0x19A   0xBDF1             POP      {R0,R4-R7,PC}
   1079          
   1080          #if defined(EUSART_PRESENT)
   1081          /***************************************************************************//**
   1082           * Initializes the EUSART with synchronous common settings to high
   1083           * and low frequency clock.
   1084           *
   1085           * @param eusart Pointer to the EUSART peripheral register block.
   1086           * @param init A pointer to the initialization structure.
   1087           ******************************************************************************/
   1088          static void EUSART_SyncInitCommon(EUSART_TypeDef *eusart,
   1089                                            EUSART_SpiInit_TypeDef const *init)
   1090          {
   1091            void* advancedSetting_ptr = (void*)init->advancedSettings; // Used to avoid GCC over optimization.
   1092          
   1093            // LF register about to be modified requires sync busy check.
   1094            if (eusart->EN) {
   1095              eusart_sync(eusart, _EUSART_SYNCBUSY_MASK);
   1096            }
   1097          
   1098            // Initialize EUSART registers to hardware reset state.
   1099            EUSART_Reset(eusart);
   1100          
   1101            // Configure global configuration register 2.
   1102            eusart->CFG2 = (eusart->CFG2 & ~(_EUSART_CFG2_MASTER_MASK
   1103                                             | _EUSART_CFG2_CLKPOL_MASK
   1104                                             | _EUSART_CFG2_CLKPHA_MASK
   1105                                             | _EUSART_CFG2_FORCELOAD_MASK))
   1106                           | (uint32_t)(init->master)
   1107                           | (uint32_t)(init->clockMode)
   1108                           | (uint32_t)(EUSART_CFG2_FORCELOAD); // Force load feature enabled by default.
   1109          
   1110            if (advancedSetting_ptr) {
   1111              // Configure global configuration register 2.
   1112              eusart->CFG2 = (eusart->CFG2 & ~(_EUSART_CFG2_FORCELOAD_MASK
   1113                                               | _EUSART_CFG2_AUTOCS_MASK
   1114                                               | _EUSART_CFG2_AUTOTX_MASK
   1115                                               | _EUSART_CFG2_CSINV_MASK
   1116                                               | _EUSART_CFG2_CLKPRSEN_MASK))
   1117                             | (uint32_t)(init->advancedSettings->forceLoad << _EUSART_CFG2_FORCELOAD_SHIFT)
   1118                             | (uint32_t)(init->advancedSettings->autoCsEnable << _EUSART_CFG2_AUTOCS_SHIFT)
   1119                             | (uint32_t)(init->advancedSettings->autoTxEnable << _EUSART_CFG2_AUTOTX_SHIFT)
   1120                             | (uint32_t)(init->advancedSettings->csPolarity)
   1121                             | (uint32_t)(init->advancedSettings->prsClockEnable << _EUSART_CFG2_CLKPRSEN_SHIFT);
   1122          
   1123              // Only applicable to EM2 (low frequency) capable EUSART instances.
   1124              eusart->CFG1 = (eusart->CFG1 & ~(_EUSART_CFG1_RXFIW_MASK
   1125                                               | _EUSART_CFG1_TXFIW_MASK))
   1126                             | (uint32_t)(init->advancedSettings->RxFifoWatermark)
   1127                             | (uint32_t)(init->advancedSettings->TxFifoWatermark)
   1128                             | (uint32_t)(init->advancedSettings->dmaWakeUpOnRx << _EUSART_CFG1_RXDMAWU_SHIFT)
   1129                             | (uint32_t)(init->advancedSettings->prsRxEnable << _EUSART_CFG1_RXPRSEN_SHIFT);
   1130            }
   1131          
   1132            eusart->CFG0 = (eusart->CFG0 & ~(_EUSART_CFG0_SYNC_MASK
   1133                                             | _EUSART_CFG0_LOOPBK_MASK))
   1134                           | (uint32_t)(_EUSART_CFG0_SYNC_SYNC)
   1135                           | (uint32_t)(init->loopbackEnable);
   1136          
   1137            if (advancedSetting_ptr) {
   1138              eusart->CFG0 |= (uint32_t)init->advancedSettings->invertIO & (_EUSART_CFG0_RXINV_MASK | _EUSART_CFG0_TXINV_MASK);
   1139              eusart->CFG0 |= (uint32_t)init->advancedSettings->msbFirst << _EUSART_CFG0_MSBF_SHIFT;
   1140          
   1141              // Configure global configurationTiming register.
   1142              eusart->TIMINGCFG = (eusart->TIMINGCFG & ~(_EUSART_TIMINGCFG_CSSETUP_MASK
   1143                                                         | _EUSART_TIMINGCFG_CSHOLD_MASK
   1144                                                         | _EUSART_TIMINGCFG_ICS_MASK
   1145                                                         | _EUSART_TIMINGCFG_SETUPWINDOW_MASK))
   1146                                  | ((uint32_t)(init->advancedSettings->autoCsSetupTime << _EUSART_TIMINGCFG_CSSETUP_SHIFT)
   1147                                     & _EUSART_TIMINGCFG_CSSETUP_MASK)
   1148                                  | ((uint32_t)(init->advancedSettings->autoCsHoldTime << _EUSART_TIMINGCFG_CSHOLD_SHIFT)
   1149                                     & _EUSART_TIMINGCFG_CSHOLD_MASK)
   1150                                  | ((uint32_t)(init->advancedSettings->autoInterFrameTime << _EUSART_TIMINGCFG_ICS_SHIFT)
   1151                                     & _EUSART_TIMINGCFG_ICS_MASK)
   1152                                  | ((uint32_t)(init->advancedSettings->setupWindow << _EUSART_TIMINGCFG_SETUPWINDOW_SHIFT)
   1153                                     & _EUSART_TIMINGCFG_SETUPWINDOW_MASK)
   1154              ;
   1155            }
   1156          
   1157            // Configure frame format
   1158            eusart->FRAMECFG = (eusart->FRAMECFG & ~(_EUSART_FRAMECFG_DATABITS_MASK))
   1159                               | (uint32_t)(init->databits);
   1160          
   1161            if (advancedSetting_ptr) {
   1162              eusart->DTXDATCFG = (init->advancedSettings->defaultTxData & _EUSART_DTXDATCFG_MASK);
   1163          
   1164              if (init->advancedSettings->prsRxEnable) {
   1165                //Configure PRS channel as input data line for EUSART.
   1166                if (eusart == EUSART0) {
   1167                  PRS->CONSUMER_EUSART0_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART0_RX_MASK);
   1168                }
   1169          #if defined(EUSART1)
   1170                if (eusart == EUSART1) {
   1171                  PRS->CONSUMER_EUSART1_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART1_RX_MASK);
   1172                }
   1173          #endif
   1174          #if defined(EUSART2)
   1175                if (eusart == EUSART2) {
   1176                  PRS->CONSUMER_EUSART2_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART2_RX_MASK);
   1177                }
   1178          #endif
   1179          #if defined(EUSART3)
   1180                if (eusart == EUSART3) {
   1181                  PRS->CONSUMER_EUSART3_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART3_RX_MASK);
   1182                }
   1183          #endif
   1184          #if defined(EUSART4)
   1185                if (eusart == EUSART4) {
   1186                  PRS->CONSUMER_EUSART4_RX_SET = (init->advancedSettings->prsRxChannel & _PRS_CONSUMER_EUSART4_RX_MASK);
   1187                }
   1188          #endif
   1189              }
   1190          
   1191              if (init->advancedSettings->prsClockEnable) {
   1192                //Configure PRS channel as SCLK input for EUSART.
   1193                if (eusart == EUSART0) {
   1194                  PRS->CONSUMER_EUSART0_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART0_CLK_MASK);
   1195                }
   1196          #if defined(EUSART1)
   1197                if (eusart == EUSART1) {
   1198                  PRS->CONSUMER_EUSART1_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART1_CLK_MASK);
   1199                }
   1200          #endif
   1201          #if defined(EUSART2)
   1202                if (eusart == EUSART2) {
   1203                  PRS->CONSUMER_EUSART2_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART2_CLK_MASK);
   1204                }
   1205          #endif
   1206          #if defined(EUSART3)
   1207                if (eusart == EUSART3) {
   1208                  PRS->CONSUMER_EUSART3_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART3_CLK_MASK);
   1209                }
   1210          #endif
   1211          #if defined(EUSART4)
   1212                if (eusart == EUSART4) {
   1213                  PRS->CONSUMER_EUSART4_CLK_SET = (init->advancedSettings->prsClockChannel & _PRS_CONSUMER_EUSART4_CLK_MASK);
   1214                }
   1215          #endif
   1216              }
   1217            }
   1218          
   1219            // Set baudrate for synchronous operation mode.
   1220            EUSART_BaudrateSet(eusart, init->refFreq, init->bitRate);
   1221          
   1222            // Enable EUSART IP.
   1223            EUSART_Enable(eusart, eusartEnable);
   1224          
   1225            // Finally enable the Rx and/or Tx channel (as specified).
   1226            eusart_sync(eusart, _EUSART_SYNCBUSY_RXEN_MASK | _EUSART_SYNCBUSY_TXEN_MASK); // Wait for low frequency register synchronization.
   1227            eusart->CMD = (uint32_t)init->enable;
   1228            eusart_sync(eusart, _EUSART_SYNCBUSY_RXEN_MASK | _EUSART_SYNCBUSY_TXEN_MASK);
   1229            while (~EUSART_StatusGet(eusart) & (_EUSART_STATUS_RXIDLE_MASK | _EUSART_STATUS_TXIDLE_MASK)) {
   1230            }
   1231          }
   1232          #endif
   1233          
   1234          /***************************************************************************//**
   1235           * Calculate baudrate for a given reference frequency, clock division,
   1236           * and oversampling rate when the module is in UART mode.
   1237           *
   1238           * @param refFreq The EUSART reference clock frequency in Hz that will be used.
   1239           * @param clkdiv Clock division factor to be used.
   1240           * @param ovs Oversampling to be used.
   1241           *
   1242           * @return Computed baudrate from given settings.
   1243           ******************************************************************************/
   1244          __STATIC_INLINE uint32_t EUSART_AsyncBaudrateCalc(uint32_t refFreq,
   1245                                                            uint32_t clkdiv,
   1246                                                            EUSART_OVS_TypeDef ovs)
   1247          {
   1248            uint32_t oversample;
   1249            uint64_t divisor;
   1250            uint64_t factor;
   1251            uint64_t remainder;
   1252            uint64_t quotient;
   1253            uint32_t br;
   1254          
   1255            // Out of bound clkdiv.
   1256            EFM_ASSERT(clkdiv <= _EUSART_CLKDIV_MASK);
   1257          
   1258            // Mask out unused bits
   1259            clkdiv &= _EUSART_CLKDIV_MASK;
   1260          
   1261            /* Use integer division to avoid forcing in float division
   1262             * utils and yet keep rounding effect errors to a minimum.
   1263             *
   1264             * Baudrate in is given by:
   1265             *
   1266             * br = fUARTn/(oversample * (1 + (CLKDIV / 256)))
   1267             * or
   1268             * br = (256 * fUARTn)/(oversample * (256 + CLKDIV))
   1269             *
   1270             * 256 factor of the dividend is reduced with a
   1271             * (part of) oversample part of the divisor.
   1272             */
   1273          
   1274            switch (ovs) {
   1275              case eusartOVS16:
   1276                oversample = 1;
   1277                factor = 256 / 16;
   1278                break;
   1279          
   1280              case eusartOVS8:
   1281                oversample = 1;
   1282                factor = 256 / 8;
   1283                break;
   1284          
   1285              case eusartOVS6:
   1286                oversample = 3;
   1287                factor = 256 / 2;
   1288                break;
   1289          
   1290              case eusartOVS4:
   1291                oversample = 1;
   1292                factor = 256 / 4;
   1293                break;
   1294          
   1295              case eusartOVS0:
   1296                oversample = 1;
   1297                factor = 256;
   1298                break;
   1299          
   1300              default:
   1301                return 0u;
   1302                break;
   1303            }
   1304          
   1305            /*
   1306             * The basic problem with integer division in the above formula is that
   1307             * the dividend (factor * fUARTn) may become larger than a 32 bit
   1308             * integer. Yet we want to evaluate the dividend first before dividing
   1309             * to get as small rounding effects as possible. Too harsh restrictions
   1310             * should not be made on the maximum fUARTn value either.
   1311             *
   1312             * For division a/b,
   1313             *
   1314             * a = qb + r
   1315             *
   1316             * where q is the quotient and r is the remainder, both integers.
   1317             *
   1318             * The original baudrate formula can be rewritten as
   1319             *
   1320             * br = xa / b = x(qb + r)/b = xq + xr/b
   1321             *
   1322             * where x is 'factor', a is 'refFreq' and b is 'divisor', referring to
   1323             * variable names.
   1324             */
   1325          
   1326            /*
   1327             * The divisor will never exceed max 32 bit value since
   1328             * clkdiv <= _EUSART_CLKDIV_MASK (currently 0x7FFFF8)
   1329             * and 'oversample' has been reduced to <= 3.
   1330             */
   1331            divisor = (uint64_t)(oversample * (256 + clkdiv));
   1332          
   1333            quotient = refFreq / divisor;
   1334            remainder = refFreq % divisor;
   1335          
   1336            // The factor <= 128 and since divisor >= 256, the below cannot exceed the maximum
   1337            // 32 bit value. However, factor * remainder can become larger than 32-bit
   1338            // because of the size of _EUSART_CLKDIV_DIV_MASK on some families.
   1339            br = (uint32_t) (factor * quotient);
   1340          
   1341            /*
   1342             * The factor <= 128 and remainder < (oversample*(256 + clkdiv)), which
   1343             * means dividend (factor * remainder) worst case is
   1344             * 128 * (3 * (256 + _EUSART_CLKDIV_MASK)) = 0xC001_7400.
   1345             */
   1346            br += (uint32_t) ((factor * remainder) / divisor);
   1347          
   1348            return br;
   1349          }
   1350          
   1351          /***************************************************************************//**
   1352           * Perform EUSART Module disablement - resetting all internal flops/FSM.
   1353           *
   1354           * @param eusart Pointer to the EUSART peripheral register block.
   1355           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1356          __STATIC_INLINE void EUSART_Disable(EUSART_TypeDef *eusart)
   1357          {
   \                     EUSART_Disable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1358            if (eusart->EN & _EUSART_EN_EN_MASK) {
   \        0x4   0x6861             LDR      R1,[R4, #+4]
   \        0x6   0x07C8             LSLS     R0,R1,#+31
   \        0x8   0xD516             BPL.N    ??EUSART_Disable_0
   1359              // This step should be skipped especially in Synchronous Slave mode when
   1360              // external SCLK is not running and CS is active
   1361          #if defined(EUSART_PRESENT)
   1362              if (!(eusart->CFG0 & _EUSART_CFG0_SYNC_MASK) || (eusart->CFG2 & _EUSART_CFG2_MASTER_MASK))
   \        0xA   0x68A1             LDR      R1,[R4, #+8]
   \        0xC   0x07C8             LSLS     R0,R1,#+31
   \        0xE   0xD502             BPL.N    ??EUSART_Disable_1
   \       0x10   0x6921             LDR      R1,[R4, #+16]
   \       0x12   0x07C8             LSLS     R0,R1,#+31
   \       0x14   0xD509             BPL.N    ??EUSART_Disable_2
   1363          #endif
   1364              {
   1365                // General Programming Guideline to properly disable the module:
   1366                // 1a. Disable TX and RX using TXDIS and RXDIS cmd
   1367                eusart->CMD = EUSART_CMD_TXDIS | EUSART_CMD_RXDIS;
   \                     ??EUSART_Disable_1: (+1)
   \       0x16   0x220A             MOVS     R2,#+10
   \       0x18   0x63A2             STR      R2,[R4, #+56]
   1368                // 1b. Poll for EUSARTn_SYNCBUSY.TXDIS and EUSARTn_SYNCBUSY.RXDIS to go low;
   1369                eusart_sync(eusart, (EUSART_SYNCBUSY_TXDIS | EUSART_SYNCBUSY_RXDIS));
   \       0x1A   0x2150             MOVS     R1,#+80
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       eusart_sync
   1370                // 1c. Wait for EUSARTn_STATUS.TXENS and EUSARTn_STATUS.RXENS to go low
   1371                while (eusart->STATUS & (_EUSART_STATUS_TXENS_MASK | _EUSART_STATUS_RXENS_MASK)) {
   \                     ??EUSART_Disable_3: (+1)
   \       0x22   0x6CA0             LDR      R0,[R4, #+72]
   \       0x24   0xF010 0x0F03      TST      R0,#0x3
   \       0x28   0xD1FB             BNE.N    ??EUSART_Disable_3
   1372                }
   1373              }
   1374          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1375              eusart->CLKDIV = eusart->CLKDIV;
   1376              eusart_sync(eusart, _EUSART_SYNCBUSY_DIV_MASK);
   1377          
   1378              // Read data until FIFO is emptied
   1379              // but taking care not to underflow the receiver
   1380              while (eusart->STATUS & EUSART_STATUS_RXFL) {
   1381                eusart->RXDATA;
   1382              }
   1383          #endif
   1384          
   1385              eusart->EN_CLR = EUSART_EN_EN;
   \                     ??EUSART_Disable_2: (+1)
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0xF242 0x0004      MOVW     R0,#+8196
   \       0x30   0x5021             STR      R1,[R4, R0]
   1386          
   1387          #if defined(_EUSART_EN_DISABLING_MASK)
   1388              // 2. Polling for EUSARTn_EN.DISABLING = 0.
   1389              while (eusart->EN & _EUSART_EN_DISABLING_MASK) {
   \                     ??EUSART_Disable_4: (+1)
   \       0x32   0x6861             LDR      R1,[R4, #+4]
   \       0x34   0x0788             LSLS     R0,R1,#+30
   \       0x36   0xD4FC             BMI.N    ??EUSART_Disable_4
   1390              }
   1391          #endif
   1392            }
   1393          }
   \                     ??EUSART_Disable_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x4622             MOV      R2,R4
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x.... 0x....      B.W      __aeabi_uldivmod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x5B01'0000        DC32     0x5b010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x500A'0000        DC32     0x500a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x500A'4000        DC32     0x500a4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x0011'8AA1        DC32     0x118aa1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x0131'2D01        DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x0098'9681        DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0x004C'4B40        DC32     0x4c4b40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0x87F0'FFFF        DC32     0x87f0ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0x5003'9060        DC32     0x50039060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0x030D'3FFF        DC32     0x30d3fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0x007F'FFF8        DC32     0x7ffff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0x5003'8068        DC32     0x50038068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0xFFFF'CCF0        DC32     0xffffccf0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0xBFFF'FF1D        DC32     0xbfffff1d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0xFFBD'9BE3        DC32     0xffbd9be3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \        0x0   0x87F0'F9FF        DC32     0x87f0f9ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \        0x0   0x5003'D4A4        DC32     0x5003d4a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \        0x0   0x5003'E4A4        DC32     0x5003e4a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \        0x0   0x5003'9064        DC32     0x50039064

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x65          DC8 0x5C, 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x73
   \              0x6D 0x6C    
   \              0x69 0x62    
   \              0x5C 0x73
   \       0x58   0x72 0x63          DC8 0x72, 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x65, 0x75
   \              0x5C 0x65    
   \              0x6D 0x5F    
   \              0x65 0x75
   \       0x60   0x73 0x61          DC8 0x73, 0x61, 0x72, 0x74, 0x2E, 0x63, 0
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00
   \       0x67                      DS8 1
   1394          
   1395          #endif /* defined(EUART_PRESENT) || defined(EUSART_PRESENT) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   EUSART_AsyncInitCommon
        24   -> EUSART_BaudrateSet
        24   -> EUSART_Enable
        24   -> EUSART_Reset
        24   -> eusart_sync
      32   EUSART_BaudrateGet
        32   -> CMU_ClockFreqGet
        32   -> EUSART_ClockGet
        32   -> assertEFM
        32 __aeabi_uldivmod
      32   EUSART_BaudrateSet
        32   -> CMU_ClockFreqGet
        32   -> EUSART_ClockGet
        32   -> EUSART_Disable
         0   -> EUSART_Enable
         0   -> assertEFM
        32   -> assertEFM
       8   EUSART_ClockGet
         8   -> assertEFM
       8   EUSART_Disable
         8   -> eusart_sync
      16   EUSART_Enable
         0   -> EUSART_Disable
        16   -> assertEFM
      24   EUSART_IrDAInit
         0   -> EUSART_AsyncInitCommon
        24   -> assertEFM
      32   EUSART_PrsTriggerEnable
        32   -> assertEFM
       8   EUSART_Reset
         8   -> EUSART_Disable
       0   EUSART_Rx
      16   EUSART_RxBlock
        16   -> assertEFM
       0   EUSART_RxExt
      32   EUSART_SpiInit
        32   -> EUSART_BaudrateSet
        32   -> EUSART_Enable
        32   -> EUSART_Reset
        32   -> assertEFM
       0   EUSART_Spi_TxRx
       0   EUSART_Tx
       0   EUSART_TxExt
      16   EUSART_TxTristateSet
        16   -> assertEFM
      16   EUSART_UartInitHf
         0   -> EUSART_AsyncInitCommon
        16   -> assertEFM
      24   EUSART_UartInitLf
        24   -> CMU_ClockSelectGet
         0   -> EUSART_AsyncInitCommon
        24   -> assertEFM
       0   eusart_sync


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      10  ?Subroutine0
       6  ?Subroutine1
      16  ?Subroutine10
       6  ?Subroutine2
       6  ?Subroutine3
      16  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       6  ?Subroutine7
      10  ?Subroutine8
      12  ?Subroutine9
     104  ?_0
     412  EUSART_AsyncInitCommon
     192  EUSART_BaudrateGet
     396  EUSART_BaudrateSet
      44  EUSART_ClockGet
      58  EUSART_Disable
      98  EUSART_Enable
     158  EUSART_IrDAInit
     120  EUSART_PrsTriggerEnable
      64  EUSART_Reset
      38  EUSART_Rx
      72  EUSART_RxBlock
       8  EUSART_RxExt
     482  EUSART_SpiInit
      14  EUSART_Spi_TxRx
       2  EUSART_Tx
       2  EUSART_TxExt
      68  EUSART_TxTristateSet
      86  EUSART_UartInitHf
     148  EUSART_UartInitLf
       8  eusart_sync

 
   104 bytes in section .rodata
 2'650 bytes in section .text
 
 2'650 bytes of CODE  memory
   104 bytes of CONST memory

Errors: none
Warnings: none
