###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:55
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_prs.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_prs.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_prs.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_prs.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_12162447720190469977.dir\em_prs.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_12162447720190469977.dir\em_prs.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\src\em_prs.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Peripheral Reflex System (PRS) Peripheral API
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "em_prs.h"
     32          #if defined(PRS_COUNT) && (PRS_COUNT > 0)
     33          
     34          #include "sl_assert.h"
     35          
     36          /***************************************************************************//**
     37           * @addtogroup prs PRS - Peripheral Reflex System
     38           * @brief Peripheral Reflex System (PRS) Peripheral API
     39           * @details
     40           *  This module contains functions to control the PRS peripheral of Silicon
     41           *  Labs 32-bit MCUs and SoCs. The PRS allows configurable, fast, and autonomous
     42           *  communication between peripherals on the MCU or SoC.
     43           * @{
     44           ******************************************************************************/
     45          
     46          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     47          
     48          /*******************************************************************************
     49           *******************************   DEFINES   ***********************************
     50           ******************************************************************************/
     51          
     52          /* Generic defines for async and sync signals applying to all TIMER instances.
     53           * Those defines map to TIMER2 but it could be any TIMER instance number. */
     54          #define   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERUF   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMER2UF
     55          #define   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMEROF   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMER2OF
     56          #define   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERCC0  _PRS_ASYNC_CH_CTRL_SIGSEL_TIMER2CC0
     57          #define   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERCC1  _PRS_ASYNC_CH_CTRL_SIGSEL_TIMER2CC1
     58          #define   _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERCC2  _PRS_ASYNC_CH_CTRL_SIGSEL_TIMER2CC2
     59          
     60          #define   _PRS_SYNC_CH_CTRL_SIGSEL_TIMERUF   _PRS_SYNC_CH_CTRL_SIGSEL_TIMER2UF
     61          #define   _PRS_SYNC_CH_CTRL_SIGSEL_TIMEROF   _PRS_SYNC_CH_CTRL_SIGSEL_TIMER2OF
     62          #define   _PRS_SYNC_CH_CTRL_SIGSEL_TIMERCC0  _PRS_SYNC_CH_CTRL_SIGSEL_TIMER2CC0
     63          #define   _PRS_SYNC_CH_CTRL_SIGSEL_TIMERCC1  _PRS_SYNC_CH_CTRL_SIGSEL_TIMER2CC1
     64          #define   _PRS_SYNC_CH_CTRL_SIGSEL_TIMERCC2  _PRS_SYNC_CH_CTRL_SIGSEL_TIMER2CC2
     65          
     66          /*******************************************************************************
     67           **************************   LOCAL FUNCTIONS   ********************************
     68           ******************************************************************************/
     69          
     70          /***************************************************************************//**
     71           * @brief
     72           *   Get PRS source signal for a channel.
     73           *
     74           * @param[in] type
     75           *   PRS channel type. This can be either @ref prsTypeAsync or
     76           *   @ref prsTypeSync.
     77           *
     78           * @param[in] ch
     79           *   channel number.
     80           *
     81           * @return
     82           *   PRS signal assigned to the channel.
     83           ******************************************************************************/
     84          static PRS_Signal_t getSignal(unsigned int ch, PRS_ChType_t type)
     85          {
     86            PRS_Signal_t signal;
     87          
     88          #if defined(_PRS_ASYNC_CH_CTRL_SOURCESEL_MASK)
     89            if (type == prsTypeAsync) {
     90              signal = (PRS_Signal_t) (PRS->ASYNC_CH[ch].CTRL
     91                                       & (_PRS_ASYNC_CH_CTRL_SOURCESEL_MASK | _PRS_ASYNC_CH_CTRL_SIGSEL_MASK));
     92            } else {
     93              signal = (PRS_Signal_t) (PRS->SYNC_CH[ch].CTRL
     94                                       & (_PRS_SYNC_CH_CTRL_SOURCESEL_MASK | _PRS_SYNC_CH_CTRL_SIGSEL_MASK));
     95            }
     96          #else
     97            (void) type;
     98            signal = (PRS_Signal_t) (PRS->CH[ch].CTRL
     99                                     & (_PRS_CH_CTRL_SOURCESEL_MASK | _PRS_CH_CTRL_SIGSEL_MASK));
    100          #endif
    101            return signal;
    102          }
    103          
    104          /** @endcond */
    105          
    106          /*******************************************************************************
    107           **************************   GLOBAL FUNCTIONS   *******************************
    108           ******************************************************************************/
    109          
    110          #if defined(_SILICON_LABS_32B_SERIES_2)
    111          /***************************************************************************//**
    112           * @brief
    113           *   Convert an async PRS source to a sync source.
    114           *
    115           * @details
    116           *   This conversion must be done because the id's of the same peripheral
    117           *   source is different depending on if it's used as an asynchronous PRS source
    118           *   or a synchronous PRS source.
    119           *
    120           * @param[in] asyncSource
    121           *   The id of the asynchronous PRS source.
    122           *
    123           * @return
    124           *   The id of the corresponding synchronous PRS source.
    125           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          uint32_t PRS_ConvertToSyncSource(uint32_t asyncSource)
    127          {
   \                     PRS_ConvertToSyncSource: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    128            uint32_t syncSource = 0;
   \        0x2   0x2400             MOVS     R4,#+0
    129          
    130            switch (asyncSource) {
   \        0x4   0xB1F8             CBZ.N    R0,??CrossCallReturnLabel_2
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD00C             BEQ.N    ??PRS_ConvertToSyncSource_0
   \        0xA   0x280C             CMP      R0,#+12
   \        0xC   0xD016             BEQ.N    ??PRS_ConvertToSyncSource_1
   \        0xE   0x2821             CMP      R0,#+33
   \       0x10   0xD00A             BEQ.N    ??PRS_ConvertToSyncSource_2
   \       0x12   0x2822             CMP      R0,#+34
   \       0x14   0xD00A             BEQ.N    ??PRS_ConvertToSyncSource_3
   \       0x16   0x2823             CMP      R0,#+35
   \       0x18   0xD00A             BEQ.N    ??PRS_ConvertToSyncSource_4
   \       0x1A   0x2824             CMP      R0,#+36
   \       0x1C   0xD00A             BEQ.N    ??PRS_ConvertToSyncSource_5
   \       0x1E   0x2832             CMP      R0,#+50
   \       0x20   0xD00A             BEQ.N    ??PRS_ConvertToSyncSource_6
   \       0x22   0xE00D             B.N      ??PRS_ConvertToSyncSource_7
    131              case _PRS_ASYNC_CH_CTRL_SOURCESEL_NONE:
    132                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_NONE;
    133                break;
    134          #if defined(IADC_PRESENT)
    135              case _PRS_ASYNC_CH_CTRL_SOURCESEL_IADC0:
    136                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_IADC0;
   \                     ??PRS_ConvertToSyncSource_0: (+1)
   \       0x24   0x2403             MOVS     R4,#+3
    137                break;
   \       0x26   0xE00E             B.N      ??CrossCallReturnLabel_2
    138          #endif
    139              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER0:
    140                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER0;
   \                     ??PRS_ConvertToSyncSource_2: (+1)
   \       0x28   0x2401             MOVS     R4,#+1
    141                break;
   \       0x2A   0xE00C             B.N      ??CrossCallReturnLabel_2
    142              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER1:
    143                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER1;
   \                     ??PRS_ConvertToSyncSource_3: (+1)
   \       0x2C   0x2402             MOVS     R4,#+2
    144                break;
   \       0x2E   0xE00A             B.N      ??CrossCallReturnLabel_2
    145              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER2:
    146                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER2;
   \                     ??PRS_ConvertToSyncSource_4: (+1)
   \       0x30   0x2404             MOVS     R4,#+4
    147                break;
   \       0x32   0xE008             B.N      ??CrossCallReturnLabel_2
    148              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER3:
    149                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER3;
   \                     ??PRS_ConvertToSyncSource_5: (+1)
   \       0x34   0x2405             MOVS     R4,#+5
    150                break;
   \       0x36   0xE006             B.N      ??CrossCallReturnLabel_2
    151          #if defined(TIMER4)
    152              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER4:
    153                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER4;
   \                     ??PRS_ConvertToSyncSource_6: (+1)
   \       0x38   0x2406             MOVS     R4,#+6
    154                break;
   \       0x3A   0xE004             B.N      ??CrossCallReturnLabel_2
    155          #endif
    156          #if defined(TIMER5)
    157              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER5:
    158                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER5;
    159                break;
    160          #endif
    161          #if defined(TIMER6)
    162              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER6:
    163                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER6;
    164                break;
    165          #endif
    166          #if defined(TIMER7)
    167              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER7:
    168                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_TIMER7;
    169                break;
    170          #endif
    171          #if defined(VDAC0)
    172              case _PRS_ASYNC_CH_CTRL_SOURCESEL_VDAC0L:
    173                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_VDAC0;
   \                     ??PRS_ConvertToSyncSource_1: (+1)
   \       0x3C   0x2407             MOVS     R4,#+7
    174                break;
   \       0x3E   0xE002             B.N      ??CrossCallReturnLabel_2
    175          #endif
    176          #if defined(VDAC1)
    177              case _PRS_ASYNC_CH_CTRL_SOURCESEL_VDAC1L:
    178                syncSource = _PRS_SYNC_CH_CTRL_SOURCESEL_VDAC1;
    179                break;
    180          #endif
    181              default:
    182                EFM_ASSERT(false);
   \                     ??PRS_ConvertToSyncSource_7: (+1)
   \       0x40   0x21B6             MOVS     R1,#+182
   \       0x42   0x.... 0x....      BL       ?Subroutine0
    183                break;
    184            }
    185            return syncSource;
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0xBD10             POP      {R4,PC}
    186          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable9
   \        0x2   0x.... 0x....      B.W      assertEFM
    187          
    188          /***************************************************************************//**
    189           * @brief
    190           *   Convert an async PRS signal to a sync signal.
    191           *
    192           * @details
    193           *   PRS values for some peripherals signals differ between asynchronous and
    194           *   synchronous PRS channels. This function must be used to handle the
    195           *   conversion.
    196           *
    197           * @param[in] asyncSource
    198           *   The id of the asynchronous PRS source.
    199           *
    200           * @param[in] asyncSignal
    201           *   The id of the asynchronous PRS signal.
    202           *
    203           * @return
    204           *   The id of the corresponding synchronous PRS signal.
    205           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    206          uint32_t PRS_ConvertToSyncSignal(uint32_t asyncSource, uint32_t asyncSignal)
    207          {
   \                     PRS_ConvertToSyncSignal: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4602             MOV      R2,R0
    208            uint32_t syncSignal = asyncSignal;
   \        0x4   0x460C             MOV      R4,R1
    209          
    210            switch (asyncSource) {
   \        0x6   0x....             LDR.N    R0,??DataTable9
   \        0x8   0x1E52             SUBS     R2,R2,#+1
   \        0xA   0xD013             BEQ.N    ??PRS_ConvertToSyncSignal_1
   \        0xC   0x3A0B             SUBS     R2,R2,#+11
   \        0xE   0xD01B             BEQ.N    ??PRS_ConvertToSyncSignal_2
   \       0x10   0x3A15             SUBS     R2,R2,#+21
   \       0x12   0x2A03             CMP      R2,#+3
   \       0x14   0xD901             BLS.N    ??PRS_ConvertToSyncSignal_3
   \       0x16   0x3A11             SUBS     R2,R2,#+17
   \       0x18   0xD123             BNE.N    ??PRS_ConvertToSyncSignal_4
    211              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER0:
    212              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER1:
    213              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER2:
    214              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER3:
    215          #if defined(_PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER4)
    216              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER4:
    217          #endif
    218          #if defined(_PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER5)
    219              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER5:
    220          #endif
    221          #if defined(_PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER6)
    222              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER6:
    223          #endif
    224          #if defined(_PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER7)
    225              case _PRS_ASYNC_CH_CTRL_SOURCESEL_TIMER7:
    226          #endif
    227                /* Async and sync signal values are consistent across all timers instances.
    228                 * Generic defines are used. */
    229                switch (asyncSignal) {
   \                     ??PRS_ConvertToSyncSignal_3: (+1)
   \       0x1A   0x2904             CMP      R1,#+4
   \       0x1C   0xD808             BHI.N    ??PRS_ConvertToSyncSignal_5
   \       0x1E   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??PRS_ConvertToSyncSignal_0:
   \       0x22   0x18 0x1A          DC8      0x18,0x1A,0xE,0x3
   \              0x0E 0x03
   \       0x26   0x05 0x00          DC8      0x5,0x0
    230                  case _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERUF:
    231                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_TIMERUF;
    232                    break;
    233                  case _PRS_ASYNC_CH_CTRL_SIGSEL_TIMEROF:
    234                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_TIMEROF;
    235                    break;
    236                  case _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERCC0:
    237                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_TIMERCC0;
    238                    break;
    239                  case _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERCC1:
    240                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_TIMERCC1;
   \                     ??PRS_ConvertToSyncSignal_6: (+1)
   \       0x28   0x2403             MOVS     R4,#+3
    241                    break;
   \       0x2A   0xE01A             B.N      ??PRS_ConvertToSyncSignal_4
    242                  case _PRS_ASYNC_CH_CTRL_SIGSEL_TIMERCC2:
    243                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_TIMERCC2;
   \                     ??PRS_ConvertToSyncSignal_7: (+1)
   \       0x2C   0x2404             MOVS     R4,#+4
    244                    break;
   \       0x2E   0xE018             B.N      ??PRS_ConvertToSyncSignal_4
    245                  default:
    246                    EFM_ASSERT(false);
   \                     ??PRS_ConvertToSyncSignal_5: (+1)
   \       0x30   0x21F6             MOVS     R1,#+246
   \       0x32   0xE014             B.N      ??PRS_ConvertToSyncSignal_8
    247                    break;
    248                }
    249                break;
    250          #if defined(IADC0)
    251              case _PRS_ASYNC_CH_CTRL_SOURCESEL_IADC0:
    252                switch (asyncSignal) {
   \                     ??PRS_ConvertToSyncSignal_1: (+1)
   \       0x34   0xB169             CBZ.N    R1,??PRS_ConvertToSyncSignal_9
   \       0x36   0x2902             CMP      R1,#+2
   \       0x38   0xD001             BEQ.N    ??PRS_ConvertToSyncSignal_10
   \       0x3A   0xD30C             BCC.N    ??PRS_ConvertToSyncSignal_11
   \       0x3C   0xE001             B.N      ??PRS_ConvertToSyncSignal_12
    253                  case _PRS_ASYNC_CH_CTRL_SIGSEL_IADC0SCANENTRYDONE:
    254                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_IADC0SCANENTRYDONE;
    255                    break;
    256                  case _PRS_ASYNC_CH_CTRL_SIGSEL_IADC0SCANTABLEDONE:
    257                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_IADC0SCANTABLEDONE;
    258                    break;
    259                  case _PRS_ASYNC_CH_CTRL_SIGSEL_IADC0SINGLEDONE:
    260                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_IADC0SINGLEDONE;
   \                     ??PRS_ConvertToSyncSignal_10: (+1)
   \       0x3E   0x2402             MOVS     R4,#+2
    261                    break;
   \       0x40   0xE00F             B.N      ??PRS_ConvertToSyncSignal_4
    262                  default:
    263                    EFM_ASSERT(false);
   \                     ??PRS_ConvertToSyncSignal_12: (+1)
   \       0x42   0xF240 0x1107      MOVW     R1,#+263
   \       0x46   0xE00A             B.N      ??PRS_ConvertToSyncSignal_8
    264                    break;
    265                }
    266                break;
    267          #endif
    268          #if defined(VDAC0)
    269              case _PRS_ASYNC_CH_CTRL_SOURCESEL_VDAC0L:
    270                switch (asyncSignal) {
   \                     ??PRS_ConvertToSyncSignal_2: (+1)
   \       0x48   0x2902             CMP      R1,#+2
   \       0x4A   0xD002             BEQ.N    ??PRS_ConvertToSyncSignal_9
   \       0x4C   0x2903             CMP      R1,#+3
   \       0x4E   0xD002             BEQ.N    ??PRS_ConvertToSyncSignal_11
   \       0x50   0xE003             B.N      ??PRS_ConvertToSyncSignal_13
    271                  case _PRS_ASYNC_CH_CTRL_SIGSEL_VDAC0LCH0DONEASYNC:
    272                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_VDAC0CH0DONESYNC;
   \                     ??PRS_ConvertToSyncSignal_9: (+1)
   \       0x52   0x2400             MOVS     R4,#+0
    273                    break;
   \       0x54   0xE005             B.N      ??PRS_ConvertToSyncSignal_4
    274                  case _PRS_ASYNC_CH_CTRL_SIGSEL_VDAC0LCH1DONEASYNC:
    275                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_VDAC0CH1DONESYNC;
   \                     ??PRS_ConvertToSyncSignal_11: (+1)
   \       0x56   0x2401             MOVS     R4,#+1
    276                    break;
   \       0x58   0xE003             B.N      ??PRS_ConvertToSyncSignal_4
    277                  default:
    278                    EFM_ASSERT(false);
   \                     ??PRS_ConvertToSyncSignal_13: (+1)
   \       0x5A   0xF44F 0x718B      MOV      R1,#+278
   \                     ??PRS_ConvertToSyncSignal_8: (+1)
   \       0x5E   0x.... 0x....      BL       assertEFM
    279                    break;
    280                }
    281                break;
    282          #endif
    283          #if defined(VDAC1)
    284              case _PRS_ASYNC_CH_CTRL_SOURCESEL_VDAC1L:
    285                switch (asyncSignal) {
    286                  case _PRS_ASYNC_CH_CTRL_SIGSEL_VDAC1LCH0DONEASYNC:
    287                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_VDAC1CH0DONESYNC;
    288                    break;
    289                  case _PRS_ASYNC_CH_CTRL_SIGSEL_VDAC1LCH1DONEASYNC:
    290                    syncSignal = _PRS_SYNC_CH_CTRL_SIGSEL_VDAC1CH1DONESYNC;
    291                    break;
    292                  default:
    293                    EFM_ASSERT(false);
    294                    break;
    295                }
    296                break;
    297          #endif
    298              default:
    299                // No translation
    300                break;
    301            }
    302            return syncSignal;
   \                     ??PRS_ConvertToSyncSignal_4: (+1)
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0xBD10             POP      {R4,PC}
    303          }
    304          #endif
    305          
    306          /***************************************************************************//**
    307           * @brief
    308           *   Set a source and signal for a channel.
    309           *
    310           * @param[in] ch
    311           *   A channel to define the signal and source for.
    312           *
    313           * @param[in] source
    314           *   A source to select for the channel. Use one of PRS_CH_CTRL_SOURCESEL_x defines.
    315           *
    316           * @param[in] signal
    317           *   A signal (for selected @p source) to use. Use one of PRS_CH_CTRL_SIGSEL_x
    318           *   defines.
    319           *
    320           * @param[in] edge
    321           *   An edge (for selected source/signal) to generate the pulse for.
    322           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    323          void PRS_SourceSignalSet(unsigned int ch,
    324                                   uint32_t source,
    325                                   uint32_t signal,
    326                                   PRS_Edge_TypeDef edge)
    327          {
   \                     PRS_SourceSignalSet: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    328          #if defined(_PRS_SYNC_CH_CTRL_MASK)
    329            (void) edge;
    330            EFM_ASSERT(ch < PRS_SYNC_CHAN_COUNT);
   \        0x8   0x2C04             CMP      R4,#+4
   \        0xA   0xD303             BCC.N    ??CrossCallReturnLabel_1
   \        0xC   0xF44F 0x71A5      MOV      R1,#+330
   \       0x10   0x.... 0x....      BL       ?Subroutine0
    331            PRS->SYNC_CH[ch].CTRL = (source & _PRS_SYNC_CH_CTRL_SOURCESEL_MASK)
    332                                    | (signal & _PRS_SYNC_CH_CTRL_SIGSEL_MASK);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x14   0xF405 0x45FE      AND      R5,R5,#0x7F00
   \       0x18   0xF006 0x0607      AND      R6,R6,#0x7
   \       0x1C   0x4335             ORRS     R5,R6,R5
   \       0x1E   0x....             LDR.N    R0,??DataTable9_1
   \       0x20   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
    333          #else
    334            EFM_ASSERT(ch < PRS_CHAN_COUNT);
    335            PRS->CH[ch].CTRL = (source & _PRS_CH_CTRL_SOURCESEL_MASK)
    336                               | (signal & _PRS_CH_CTRL_SIGSEL_MASK)
    337                               | (uint32_t)edge << _PRS_CH_CTRL_EDSEL_SHIFT;
    338          #endif
    339          }
   \       0x24   0xBD70             POP      {R4-R6,PC}
    340          
    341          #if defined(PRS_ASYNC_SUPPORTED)
    342          /***************************************************************************//**
    343           * @brief
    344           *   Set the source and asynchronous signal for a channel.
    345           *
    346           * @details
    347           *   Asynchronous reflexes are not clocked on HFPERCLK and can be used even in
    348           *   EM2/EM3.
    349           *   There is a limitation to reflexes operating in asynchronous mode in
    350           *   that they can only be used by a subset of the reflex consumers. See
    351           *   the PRS chapter in the reference manual for the complete list of
    352           *   supported asynchronous signals and consumers.
    353           *
    354           * @note
    355           *   This function is not supported on EFM32GxxxFyyy parts.
    356           *   In asynchronous mode, the edge detector only works in EM0 and should
    357           *   not be used. The EDSEL parameter in PRS_CHx_CTRL register is set to 0 (OFF)
    358           *   by default.
    359           *
    360           * @param[in] ch
    361           *   A channel to define the source and asynchronous signal for.
    362           *
    363           * @param[in] source
    364           *   A source to select for the channel. Use one of PRS_CH_CTRL_SOURCESEL_x defines.
    365           *
    366           * @param[in] signal
    367           *   An asynchronous signal (for selected @p source) to use. Use one of the
    368           *   PRS_CH_CTRL_SIGSEL_x defines that support asynchronous operation.
    369           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    370          void PRS_SourceAsyncSignalSet(unsigned int ch,
    371                                        uint32_t source,
    372                                        uint32_t signal)
    373          {
    374            PRS_ConnectSignal(ch, prsTypeAsync, (PRS_Signal_t) (source | signal));
   \                     PRS_SourceAsyncSignalSet: (+1)
   \        0x0   0x4311             ORRS     R1,R2,R1
   \        0x2   0xB20A             SXTH     R2,R1
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....             B.N      PRS_ConnectSignal
    375          }
    376          #endif
    377          
    378          #if defined(_PRS_ROUTELOC0_MASK) || (defined(_PRS_ROUTE_MASK) && (_PRS_ROUTE_MASK))
    379          /***************************************************************************//**
    380           * @brief
    381           *   Send the output of a PRS channel to a GPIO pin.
    382           *
    383           * @details
    384           *   This function is used to send the output of a PRS channel to a GPIO pin.
    385           *   Note that there are certain restrictions to where a PRS channel can be
    386           *   routed. Consult the datasheet of the device to see if a channel can be
    387           *   routed to the requested GPIO pin.
    388           *
    389           * @param[in] ch
    390           *   PRS channel number.
    391           *
    392           * @param[in] location
    393           *   PRS routing location.
    394           ******************************************************************************/
    395          void PRS_GpioOutputLocation(unsigned int ch,
    396                                      unsigned int location)
    397          {
    398            EFM_ASSERT(ch < PRS_CHAN_COUNT);
    399          
    400          #if defined(_PRS_ROUTE_MASK)
    401            PRS->ROUTE |= (location << _PRS_ROUTE_LOCATION_SHIFT)
    402                          | (1 << ch);
    403          #else
    404            uint32_t shift = (ch % 4) * 8;
    405            uint32_t mask = location << shift;
    406            uint32_t locationGroup = ch / 4;
    407            /* Since all ROUTELOCx registers are in consecutive memory locations, treat them
    408             * as an array starting at ROUTELOC0 and use locationGroup to index into this array */
    409            volatile uint32_t * routeloc = &PRS->ROUTELOC0;
    410            routeloc[locationGroup] |= mask;
    411            PRS->ROUTEPEN |= 1 << ch;
    412          #endif
    413          }
    414          #endif
    415          
    416          /***************************************************************************//**
    417           * @brief
    418           *   Search for the first free PRS channel.
    419           *
    420           * @param[in] type
    421           *   PRS channel type. This can be either @ref prsTypeAsync or
    422           *   @ref prsTypeSync.
    423           *
    424           * @return
    425           *   Channel number >= 0 if an unused PRS channel was found. If no free PRS
    426           *   channel was found then -1 is returned.
    427           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          int PRS_GetFreeChannel(PRS_ChType_t type)
    429          {
   \                     PRS_GetFreeChannel: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xB570             PUSH     {R4-R6,LR}
    430            int ch = -1;
   \        0x4   0xF04F 0x30FF      MOV      R0,#+4294967295
    431            PRS_Signal_t signal;
    432            int max;
    433          
    434            if (type == prsTypeAsync) {
   \        0x8   0x000A             MOVS     R2,R1
   \        0xA   0xBF0C             ITE      EQ
   \        0xC   0x230C             MOVEQ    R3,#+12
   \        0xE   0x2304             MOVNE    R3,#+4
    435              max = PRS_ASYNC_CHAN_COUNT;
    436            } else {
    437              max = PRS_SYNC_CHAN_COUNT;
    438            }
    439          
    440            for (int i = 0; i < max; i++) {
   \       0x10   0x2500             MOVS     R5,#+0
   \       0x12   0xF647 0x7207      MOVW     R2,#+32519
   \       0x16   0xE000             B.N      ??PRS_GetFreeChannel_0
   \                     ??PRS_GetFreeChannel_1: (+1)
   \       0x18   0x1C6D             ADDS     R5,R5,#+1
   \                     ??PRS_GetFreeChannel_0: (+1)
   \       0x1A   0x429D             CMP      R5,R3
   \       0x1C   0xDA09             BGE.N    ??PRS_GetFreeChannel_2
    441              signal = getSignal(i, type);
   \       0x1E   0x462C             MOV      R4,R5
   \       0x20   0x000E             MOVS     R6,R1
   \       0x22   0xBF0C             ITE      EQ
   \       0x24   0x....             LDREQ.N  R6,??DataTable9_2
   \       0x26   0x....             LDRNE.N  R6,??DataTable9_1
   \       0x28   0xF856 0x4024      LDR      R4,[R6, R4, LSL #+2]
   \       0x2C   0x4014             ANDS     R4,R2,R4
    442              if (signal == prsSignalNone) {
   \       0x2E   0xD1F3             BNE.N    ??PRS_GetFreeChannel_1
    443                ch = i;
   \       0x30   0x4628             MOV      R0,R5
    444                break;
    445              }
    446            }
    447            return ch;
   \                     ??PRS_GetFreeChannel_2: (+1)
   \       0x32   0xBD70             POP      {R4-R6,PC}
    448          }
    449          
    450          /***************************************************************************//**
    451           * @brief
    452           *   Reset all PRS channels
    453           *
    454           * @details
    455           *   This function will reset all the PRS channel configuration.
    456           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    457          void PRS_Reset(void)
    458          {
    459            unsigned int i;
    460          
    461          #if defined(_SILICON_LABS_32B_SERIES_2)
    462            PRS->ASYNC_SWLEVEL = 0;
   \                     PRS_Reset: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             LDR.N    R0,??DataTable9_3
   \        0x4   0x6001             STR      R1,[R0, #+0]
    463            for (i = 0; i < PRS_ASYNC_CHAN_COUNT; i++) {
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x....             LDR.N    R0,??DataTable9_2
   \        0xA   0xF44F 0x2140      MOV      R1,#+786432
    464              PRS->ASYNC_CH[i].CTRL = _PRS_ASYNC_CH_CTRL_RESETVALUE;
   \                     ??PRS_Reset_0: (+1)
   \        0xE   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
    465            }
   \       0x12   0x1C52             ADDS     R2,R2,#+1
   \       0x14   0x2A0C             CMP      R2,#+12
   \       0x16   0xD3FA             BCC.N    ??PRS_Reset_0
    466            for (i = 0; i < PRS_SYNC_CHAN_COUNT; i++) {
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x....             LDR.N    R0,??DataTable9_1
   \       0x1C   0x2100             MOVS     R1,#+0
    467              PRS->SYNC_CH[i].CTRL = _PRS_SYNC_CH_CTRL_RESETVALUE;
   \                     ??PRS_Reset_1: (+1)
   \       0x1E   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
    468            }
   \       0x22   0x1C52             ADDS     R2,R2,#+1
   \       0x24   0x2A04             CMP      R2,#+4
   \       0x26   0xD3FA             BCC.N    ??PRS_Reset_1
    469          #else
    470            PRS->SWLEVEL = 0x0;
    471            for (i = 0; i < PRS_CHAN_COUNT; i++) {
    472              PRS->CH[i].CTRL = _PRS_CH_CTRL_RESETVALUE;
    473            }
    474          #endif
    475          }
   \       0x28   0x4770             BX       LR
    476          
    477          /***************************************************************************//**
    478           * @brief
    479           *   Connect a PRS signal to a channel.
    480           *
    481           * @details
    482           *   This function will make the PRS signal available on the specific channel.
    483           *   Only a single PRS signal can be connected to any given channel.
    484           *
    485           * @param[in] ch
    486           *   PRS channel number.
    487           *
    488           * @param[in] type
    489           *   PRS channel type. This can be either @ref prsTypeAsync or
    490           *   @ref prsTypeSync.
    491           *
    492           * @param[in] signal
    493           *   This is the PRS signal that should be placed on the channel.
    494           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    495          void PRS_ConnectSignal(unsigned int ch, PRS_ChType_t type, PRS_Signal_t signal)
    496          {
   \                     PRS_ConnectSignal: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    497          #if defined(_PRS_ASYNC_CH_CTRL_MASK)
    498            // Series 2 devices
    499            uint32_t sourceField = ((uint32_t)signal & _PRS_ASYNC_CH_CTRL_SOURCESEL_MASK)
    500                                   >> _PRS_ASYNC_CH_CTRL_SOURCESEL_SHIFT;
   \        0x4   0xF3C2 0x2506      UBFX     R5,R2,#+8,#+7
    501            uint32_t signalField = ((uint32_t)signal & _PRS_ASYNC_CH_CTRL_SIGSEL_MASK)
    502                                   >> _PRS_ASYNC_CH_CTRL_SIGSEL_SHIFT;
   \        0x8   0xF002 0x0607      AND      R6,R2,#0x7
    503            if (type == prsTypeAsync) {
   \        0xC   0x....             LDR.N    R0,??DataTable9
   \        0xE   0xB959             CBNZ.N   R1,??PRS_ConnectSignal_0
    504              EFM_ASSERT(ch < PRS_ASYNC_CHAN_COUNT);
   \       0x10   0x2C0C             CMP      R4,#+12
   \       0x12   0xBF24             ITT      CS
   \       0x14   0xF44F 0x71FC      MOVCS    R1,#+504
   \       0x18   0x.... 0x....      BLCS     assertEFM
    505              PRS->ASYNC_CH[ch].CTRL = PRS_ASYNC_CH_CTRL_FNSEL_A
    506                                       | (sourceField << _PRS_ASYNC_CH_CTRL_SOURCESEL_SHIFT)
    507                                       | (signalField << _PRS_ASYNC_CH_CTRL_SIGSEL_SHIFT);
   \       0x1C   0xEA46 0x2605      ORR      R6,R6,R5, LSL #+8
   \       0x20   0x....             LDR.N    R0,??DataTable9_2
   \       0x22   0xF446 0x2640      ORR      R6,R6,#0xC0000
   \       0x26   0xE010             B.N      ??PRS_ConnectSignal_1
    508            } else {
    509              EFM_ASSERT(ch < PRS_SYNC_CHAN_COUNT);
   \                     ??PRS_ConnectSignal_0: (+1)
   \       0x28   0x2C04             CMP      R4,#+4
   \       0x2A   0xBF24             ITT      CS
   \       0x2C   0xF240 0x11FD      MOVWCS   R1,#+509
   \       0x30   0x.... 0x....      BLCS     assertEFM
    510              signalField = PRS_ConvertToSyncSignal(sourceField, signalField);
   \       0x34   0x4631             MOV      R1,R6
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       PRS_ConvertToSyncSignal
   \       0x3C   0x4606             MOV      R6,R0
    511              sourceField = PRS_ConvertToSyncSource(sourceField);
    512              PRS->SYNC_CH[ch].CTRL = (sourceField << _PRS_SYNC_CH_CTRL_SOURCESEL_SHIFT)
    513                                      | (signalField << _PRS_SYNC_CH_CTRL_SIGSEL_SHIFT);
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0x.... 0x....      BL       PRS_ConvertToSyncSource
   \       0x44   0xEA46 0x2600      ORR      R6,R6,R0, LSL #+8
   \       0x48   0x....             LDR.N    R0,??DataTable9_1
   \                     ??PRS_ConnectSignal_1: (+1)
   \       0x4A   0xF840 0x6024      STR      R6,[R0, R4, LSL #+2]
    514            }
    515          #else
    516            // Series 0 and Series 1 devices
    517            uint32_t signalField = (uint32_t) signal & (_PRS_CH_CTRL_SOURCESEL_MASK
    518                                                        | _PRS_CH_CTRL_SIGSEL_MASK);
    519            if (type == prsTypeAsync) {
    520          #if defined(PRS_ASYNC_SUPPORTED)
    521              EFM_ASSERT(ch < PRS_ASYNC_CHAN_COUNT);
    522              PRS->CH[ch].CTRL = PRS_CH_CTRL_EDSEL_OFF
    523                                 | PRS_CH_CTRL_ASYNC
    524                                 | signalField;
    525          #endif
    526            } else {
    527              EFM_ASSERT(ch < PRS_SYNC_CHAN_COUNT);
    528              PRS->CH[ch].CTRL = PRS_CH_CTRL_EDSEL_OFF
    529                                 | signalField;
    530            }
    531          #endif
    532          }
   \       0x4E   0xBD70             POP      {R4-R6,PC}
    533          
    534          #if defined(_SILICON_LABS_32B_SERIES_2)
    535          /***************************************************************************//**
    536           * @brief
    537           *   Connect a peripheral consumer to a PRS channel.
    538           *
    539           * @details
    540           *   Different peripherals can use PRS channels as their input. This function
    541           *   can be used to connect a peripheral consumer to a PRS channel. Multiple
    542           *   consumers can be connected to a single PRS channel.
    543           *
    544           * @param[in] ch
    545           *   PRS channel number.
    546           *
    547           * @param[in] type
    548           *   PRS channel type. This can be either @ref prsTypeAsync or
    549           *   @ref prsTypeSync.
    550           *
    551           * @param[in] consumer
    552           *   This is the PRS consumer.
    553           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    554          void PRS_ConnectConsumer(unsigned int ch, PRS_ChType_t type, PRS_Consumer_t consumer)
    555          {
   \                     PRS_ConnectConsumer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4616             MOV      R6,R2
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    556            EFM_ASSERT((uint32_t)consumer <= 0xFFF);
   \        0x8   0xF5B6 0x5F80      CMP      R6,#+4096
   \        0xC   0xD303             BCC.N    ??CrossCallReturnLabel_0
   \        0xE   0xF44F 0x710B      MOV      R1,#+556
   \       0x12   0x.... 0x....      BL       ?Subroutine0
    557            volatile uint32_t * addr = (volatile uint32_t *) PRS;
    558            uint32_t offset = (uint32_t) consumer;
    559            addr = addr + offset / 4;
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x16   0x....             LDR.N    R1,??DataTable9_4
   \       0x18   0x08B7             LSRS     R7,R6,#+2
   \       0x1A   0xEB01 0x0087      ADD      R0,R1,R7, LSL #+2
    560          
    561            if (consumer != prsConsumerNone) {
   \       0x1E   0xB116             CBZ.N    R6,??PRS_ConnectConsumer_0
    562              if (type == prsTypeAsync) {
   \       0x20   0xB105             CBZ.N    R5,??PRS_ConnectConsumer_1
    563                *addr = ch << _PRS_CONSUMER_TIMER0_CC0_PRSSEL_SHIFT;
    564              } else {
    565                *addr = ch << _PRS_CONSUMER_TIMER0_CC0_SPRSSEL_SHIFT;
   \       0x22   0x0224             LSLS     R4,R4,#+8
   \                     ??PRS_ConnectConsumer_1: (+1)
   \       0x24   0x6004             STR      R4,[R0, #+0]
    566              }
    567            }
    568          }
   \                     ??PRS_ConnectConsumer_0: (+1)
   \       0x26   0xBDF1             POP      {R0,R4-R7,PC}
    569          
    570          /***************************************************************************//**
    571           * @brief
    572           *   Send the output of a PRS channel to a GPIO pin.
    573           *
    574           * @details
    575           *   This function is used to send the output of a PRS channel to a GPIO pin.
    576           *   Note that there are certain restrictions to where a PRS channel can be
    577           *   routed. Consult the datasheet of the device to see if a channel can be
    578           *   routed to the requested GPIO pin. Some devices for instance can only route
    579           *   the async channels 0-5 on GPIO pins PAx and PBx while async channels 6-11
    580           *   can only be routed to GPIO pins PCx and PDx
    581           *
    582           * @param[in] ch
    583           *   PRS channel number.
    584           *
    585           * @param[in] type
    586           *   PRS channel type. This can be either @ref prsTypeAsync or
    587           *   @ref prsTypeSync.
    588           *
    589           * @param[in] port
    590           *   GPIO port
    591           *
    592           * @param[in] pin
    593           *   GPIO pin
    594           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    595          void PRS_PinOutput(unsigned int ch, PRS_ChType_t type, GPIO_Port_TypeDef port, uint8_t pin)
    596          {
   \                     PRS_PinOutput: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    597            volatile uint32_t * addr;
    598            if (type == prsTypeAsync) {
   \        0x2   0x....             LDR.N    R4,??DataTable9_5
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0xBF0C             ITE      EQ
   \        0x8   0x1D25             ADDEQ    R5,R4,#+4
   \        0xA   0xF104 0x0534      ADDNE    R5,R4,#+52
    599              addr = &GPIO->PRSROUTE[0].ASYNCH0ROUTE;
    600            } else {
    601              addr = &GPIO->PRSROUTE[0].SYNCH0ROUTE;
    602            }
    603            addr += ch;
    604            *addr = ((uint32_t)port << _GPIO_PRS_ASYNCH0ROUTE_PORT_SHIFT)
    605                    | ((uint32_t)pin << _GPIO_PRS_ASYNCH0ROUTE_PIN_SHIFT);
   \        0xE   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \       0x12   0xF845 0x2020      STR      R2,[R5, R0, LSL #+2]
    606          
    607            if (type == prsTypeAsync) {
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0xB921             CBNZ.N   R1,??PRS_PinOutput_0
    608              GPIO->PRSROUTE[0].ROUTEEN |= 0x1 << (ch + _GPIO_PRS_ROUTEEN_ASYNCH0PEN_SHIFT);
   \       0x1A   0x6823             LDR      R3,[R4, #+0]
   \       0x1C   0xFA02 0xF000      LSL      R0,R2,R0
   \       0x20   0x4318             ORRS     R0,R0,R3
   \       0x22   0xE004             B.N      ??PRS_PinOutput_1
    609            } else {
    610              GPIO->PRSROUTE[0].ROUTEEN |= 0x1 << (ch + _GPIO_PRS_ROUTEEN_SYNCH0PEN_SHIFT);
   \                     ??PRS_PinOutput_0: (+1)
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x300C             ADDS     R0,R0,#+12
   \       0x28   0xFA02 0xF000      LSL      R0,R2,R0
   \       0x2C   0x4308             ORRS     R0,R0,R1
   \                     ??PRS_PinOutput_1: (+1)
   \       0x2E   0x6020             STR      R0,[R4, #+0]
    611            }
    612          }
   \       0x30   0xBD30             POP      {R4,R5,PC}
    613          
    614          /***************************************************************************//**
    615           * @brief
    616           *   Combine two PRS channels using a logic function.
    617           *
    618           * @details
    619           *   This function allows you to combine the output of one PRS channel with the
    620           *   the signal of another PRS channel using various logic functions. Note that
    621           *   for series 2, config 1 devices, the hardware only allows a PRS channel to
    622           *   be combined with the previous channel. So for instance channel 5 can be
    623           *   combined only with channel 4.
    624           *
    625           *   The logic function operates on two PRS channels called A and B. The output
    626           *   of PRS channel B is combined with the PRS source configured for channel A
    627           *   to produce an output. This output is used as the output of channel A.
    628           *
    629           * @param[in] chA
    630           *   PRS Channel for the A input.
    631           *
    632           * @param[in] chB
    633           *   PRS Channel for the B input.
    634           *
    635           * @param[in] logic
    636           *   The logic function to use when combining the Channel A and Channel B. The
    637           *   output of the logic function is the output of Channel A. Function like
    638           *   AND, OR, XOR, NOT and more are available.
    639           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    640          void PRS_Combine(unsigned int chA, unsigned int chB, PRS_Logic_t logic)
    641          {
   \                     PRS_Combine: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    642            EFM_ASSERT(chA < PRS_ASYNC_CHAN_COUNT);
   \        0x8   0x....             LDR.N    R7,??DataTable9
   \        0xA   0x2C0C             CMP      R4,#+12
   \        0xC   0xD304             BCC.N    ??PRS_Combine_0
   \        0xE   0xF240 0x2182      MOVW     R1,#+642
   \       0x12   0x4638             MOV      R0,R7
   \       0x14   0x.... 0x....      BL       assertEFM
    643            EFM_ASSERT(chB < PRS_ASYNC_CHAN_COUNT);
   \                     ??PRS_Combine_0: (+1)
   \       0x18   0x2D0C             CMP      R5,#+12
   \       0x1A   0xD304             BCC.N    ??PRS_Combine_1
   \       0x1C   0xF240 0x2183      MOVW     R1,#+643
   \       0x20   0x4638             MOV      R0,R7
   \       0x22   0x.... 0x....      BL       assertEFM
    644          
    645          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    646            EFM_ASSERT(chA == ((chB + 1) % PRS_ASYNC_CHAN_COUNT));
    647            PRS->ASYNC_CH[chA].CTRL = (PRS->ASYNC_CH[chA].CTRL & ~_PRS_ASYNC_CH_CTRL_FNSEL_MASK)
    648                                      | ((uint32_t)logic << _PRS_ASYNC_CH_CTRL_FNSEL_SHIFT);
    649          
    650          #else
    651            PRS->ASYNC_CH[chA].CTRL = (PRS->ASYNC_CH[chA].CTRL
    652                                       & ~(_PRS_ASYNC_CH_CTRL_FNSEL_MASK
    653                                           | _PRS_ASYNC_CH_CTRL_AUXSEL_MASK))
    654                                      | ((uint32_t)logic << _PRS_ASYNC_CH_CTRL_FNSEL_SHIFT)
    655                                      | ((uint32_t)chB << _PRS_ASYNC_CH_CTRL_AUXSEL_SHIFT);
   \                     ??PRS_Combine_1: (+1)
   \       0x26   0x....             LDR.N    R2,??DataTable9_2
   \       0x28   0xF852 0x1024      LDR      R1,[R2, R4, LSL #+2]
   \       0x2C   0x....             LDR.N    R0,??DataTable9_6
   \       0x2E   0x4001             ANDS     R1,R0,R1
   \       0x30   0xEA41 0x4106      ORR      R1,R1,R6, LSL #+16
   \       0x34   0xEA41 0x6105      ORR      R1,R1,R5, LSL #+24
   \       0x38   0xF842 0x1024      STR      R1,[R2, R4, LSL #+2]
    656          #endif
    657          }
   \       0x3C   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x5003'8048        DC32     0x50038048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x5003'8018        DC32     0x50038018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x5003'800C        DC32     0x5003800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x5003'8000        DC32     0x50038000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x5003'C648        DC32     0x5003c648

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0xF0F0'FFFF        DC32     0xf0f0ffff

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x65          DC8 0x5C, 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x73
   \              0x6D 0x6C    
   \              0x69 0x62    
   \              0x5C 0x73
   \       0x58   0x72 0x63          DC8 0x72, 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x70, 0x72
   \              0x5C 0x65    
   \              0x6D 0x5F    
   \              0x70 0x72
   \       0x60   0x73 0x2E          DC8 0x73, 0x2E, 0x63, 0
   \              0x63 0x00
    658          #endif
    659          
    660          /** @} (end addtogroup prs) */
    661          #endif /* defined(PRS_COUNT) && (PRS_COUNT > 0) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   PRS_Combine
        24   -> assertEFM
      24   PRS_ConnectConsumer
        24   -> assertEFM
      16   PRS_ConnectSignal
        16   -> PRS_ConvertToSyncSignal
        16   -> PRS_ConvertToSyncSource
        16   -> assertEFM
       8   PRS_ConvertToSyncSignal
         8   -> assertEFM
       8   PRS_ConvertToSyncSource
         8   -> assertEFM
      16   PRS_GetFreeChannel
      12   PRS_PinOutput
       0   PRS_Reset
       0   PRS_SourceAsyncSignalSet
         0   -> PRS_ConnectSignal
      16   PRS_SourceSignalSet
        16   -> assertEFM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       6  ?Subroutine0
     100  ?_0
      62  PRS_Combine
      40  PRS_ConnectConsumer
      80  PRS_ConnectSignal
     102  PRS_ConvertToSyncSignal
      74  PRS_ConvertToSyncSource
      52  PRS_GetFreeChannel
      50  PRS_PinOutput
      42  PRS_Reset
       8  PRS_SourceAsyncSignalSet
      38  PRS_SourceSignalSet

 
 100 bytes in section .rodata
 582 bytes in section .text
 
 582 bytes of CODE  memory
 100 bytes of CONST memory

Errors: none
Warnings: none
