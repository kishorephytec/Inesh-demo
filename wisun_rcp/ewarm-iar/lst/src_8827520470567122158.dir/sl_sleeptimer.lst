###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:15
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\sl_sleeptimer.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir\sl_sleeptimer.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\sl_sleeptimer.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_8827520470567122158.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir\sl_sleeptimer.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_8827520470567122158.dir\sl_sleeptimer.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir\sl_sleeptimer.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\sl_sleeptimer.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief SLEEPTIMER API implementation.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2019 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          #include <time.h>
     31          #include <stdlib.h>
     32          
     33          #include "em_device.h"
     34          #include "em_core_generic.h"
     35          #include "sl_sleeptimer.h"
     36          #include "sli_sleeptimer_hal.h"
     37          #include "sl_atomic.h"
     38          #include "sl_sleeptimer_config.h"
     39          
     40          #if defined(SL_COMPONENT_CATALOG_PRESENT)
     41          #include "sl_component_catalog.h"
     42          #endif
     43          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
     44          #include "sl_power_manager.h"
     45          #include "sli_power_manager.h"
     46          #endif
     47          
     48          #define TIME_UNIX_EPOCH                         (1970u)
     49          #define TIME_NTP_EPOCH                          (1900u)
     50          #define TIME_ZIGBEE_EPOCH                       (2000u)
     51          #define TIME_64_EPOCH                           TIME_NTP_EPOCH
     52          #define TIME_NTP_UNIX_EPOCH_DIFF                (TIME_UNIX_EPOCH - TIME_NTP_EPOCH)
     53          #define TIME_ZIGBEE_UNIX_EPOCH_DIFF             (TIME_ZIGBEE_EPOCH - TIME_UNIX_EPOCH)
     54          #define TIME_DAY_COUNT_NTP_TO_UNIX_EPOCH        (TIME_NTP_UNIX_EPOCH_DIFF * 365u + 17u)                  ///< 70 years and 17 leap days
     55          #define TIME_DAY_COUNT_ZIGBEE_TO_UNIX_EPOCH     (TIME_ZIGBEE_UNIX_EPOCH_DIFF * 365u + 7u)                ///< 30 years and 7 leap days
     56          #define TIME_SEC_PER_DAY                        (60u * 60u * 24u)
     57          #define TIME_NTP_EPOCH_OFFSET_SEC               (TIME_DAY_COUNT_NTP_TO_UNIX_EPOCH * TIME_SEC_PER_DAY)
     58          #define TIME_ZIGBEE_EPOCH_OFFSET_SEC            (TIME_DAY_COUNT_ZIGBEE_TO_UNIX_EPOCH * TIME_SEC_PER_DAY)
     59          #define TIME_DAY_PER_YEAR                       (365u)
     60          #define TIME_SEC_PER_YEAR                       (TIME_SEC_PER_DAY * TIME_DAY_PER_YEAR)
     61          #define TIME_UNIX_TIMESTAMP_MAX                 (0x7FFFFFFF)
     62          #define TIME_64_BIT_UNIX_TIMESTAMP_MAX          (0x497968BD7F)                                           /// Max 64 bit timestamp supported is 11:59:59 PM 12/31/11899
     63          #define TIME_UNIX_YEAR_MAX                      (2038u - TIME_NTP_EPOCH)                                 ///< Max UNIX year based from a 1900 epoch
     64          #define TIME_64_BIT_YEAR_MAX                    (11899u - TIME_NTP_EPOCH)                                ///< Max 64 bit format year based from a 1900 epoch
     65          #define TIME_64_TO_32_EPOCH_OFFSET_SEC          TIME_NTP_EPOCH_OFFSET_SEC
     66          #define TIME_UNIX_TO_NTP_MAX                    (0xFFFFFFFF - TIME_NTP_EPOCH_OFFSET_SEC)
     67          
     68          // Minimum count difference used when evaluating if a timer expired or not after an interrupt
     69          // by comparing the current count value and the expected expiration count value.
     70          // The difference should be null or of few ticks since the counter never stop.
     71          #define MIN_DIFF_BETWEEN_COUNT_AND_EXPIRATION  2
     72          
     73          /// @brief Time Format.
     74          SLEEPTIMER_ENUM(sl_sleeptimer_time_format_t) {
     75            TIME_FORMAT_UNIX = 0,           ///< Number of seconds since January 1, 1970, 00:00. Type is signed, so represented on 31 bit.
     76            TIME_FORMAT_NTP = 1,            ///< Number of seconds since January 1, 1900, 00:00. Type is unsigned, so represented on 32 bit.
     77            TIME_FORMAT_ZIGBEE_CLUSTER = 2, ///< Number of seconds since January 1, 2000, 00:00. Type is unsigned, so represented on 32 bit.
     78            TIME_FORMAT_UNIX_64_BIT = 3,    ///< Number of seconds since January 1, 1900, 00:00. Type is unsigned, so represented on 64 bit.
     79          };
     80          
     81          // tick_count, it can wrap around.
     82          typedef uint32_t sl_sleeptimer_tick_count_t;
     83          
     84          // Overflow counter used to provide 64-bits tick count.

   \                                 In section .bss, align 4
     85          static volatile uint16_t overflow_counter;
     86          
     87          #if SL_SLEEPTIMER_WALLCLOCK_CONFIG
     88          // Current time count.
     89          static sl_sleeptimer_timestamp_64_t second_count;
     90          // Tick rest when the frequency is not a divider of the timer width.
     91          static uint32_t overflow_tick_rest = 0;
     92          // Current time zone offset.
     93          static sl_sleeptimer_time_zone_offset_t tz_offset = 0;
     94          // Precalculated tick rest in case of overflow.
     95          static uint32_t calculated_tick_rest = 0;
     96          // Precalculated timer overflow duration in seconds.
     97          static uint32_t calculated_sec_count = 0;
     98          #endif
     99          
    100          // Timer frequency in Hz.
    101          static uint32_t timer_frequency;
    102          
    103          // Head of timer list.
    104          static sl_sleeptimer_timer_handle_t *timer_head;
    105          
    106          // Count at last update of delta of first timer.
    107          static volatile sl_sleeptimer_tick_count_t last_delta_update_count;
    108          
    109          // Initialization flag.
    110          static bool is_sleeptimer_initialized = false;
   \                     is_sleeptimer_initialized:
   \        0x0                      DS8 1
   \        0x1                      DS8 1
   \        0x2                      DS8 1
   \        0x3                      DS8 1
   \        0x4                      DS8 2
   \        0x6                      DS8 2
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
   \       0x14                      DS8 4
    111          
    112          // Flag that indicates if power manager's timer will expire at next compare match.
    113          static bool next_timer_to_expire_is_power_manager = false;
    114          
    115          // Precalculated value to avoid millisecond to tick conversion overflow.
    116          static uint32_t max_millisecond_conversion;
    117          
    118          // Sleep on ISR exit flag.
    119          static bool sleep_on_isr_exit = false;
    120          
    121          static void delta_list_insert_timer(sl_sleeptimer_timer_handle_t *handle,
    122                                              sl_sleeptimer_tick_count_t timeout);
    123          
    124          static sl_status_t delta_list_remove_timer(sl_sleeptimer_timer_handle_t *handle);
    125          
    126          static void set_comparator_for_next_timer(void);
    127          
    128          static void update_delta_list(void);
    129          
    130          __STATIC_INLINE uint32_t div_to_log2(uint32_t div);
    131          
    132          __STATIC_INLINE bool is_power_of_2(uint32_t nbr);
    133          
    134          static sl_status_t create_timer(sl_sleeptimer_timer_handle_t *handle,
    135                                          sl_sleeptimer_tick_count_t timeout_initial,
    136                                          sl_sleeptimer_tick_count_t timeout_periodic,
    137                                          sl_sleeptimer_timer_callback_t callback,
    138                                          void *callback_data,
    139                                          uint8_t priority,
    140                                          uint16_t option_flags);
    141          
    142          static void update_next_timer_to_expire_is_power_manager(void);
    143          
    144          static void delay_callback(sl_sleeptimer_timer_handle_t *handle,
    145                                     void *data);
    146          
    147          #if SL_SLEEPTIMER_WALLCLOCK_CONFIG
    148          static bool is_leap_year(uint16_t year);
    149          static uint16_t number_of_leap_days(uint32_t base_year, uint32_t current_year);
    150          
    151          static sl_sleeptimer_weekDay_t compute_day_of_week(uint32_t day);
    152          static sl_sleeptimer_weekDay_t compute_day_of_week_64(uint64_t day);
    153          static uint16_t compute_day_of_year(sl_sleeptimer_month_t month, uint8_t day, bool isLeapYear);
    154          
    155          static bool is_valid_time(sl_sleeptimer_timestamp_t time,
    156                                    sl_sleeptimer_time_format_t format,
    157                                    sl_sleeptimer_time_zone_offset_t time_zone);
    158          
    159          static bool is_valid_time_64(sl_sleeptimer_timestamp_64_t time,
    160                                       sl_sleeptimer_time_format_t format,
    161                                       sl_sleeptimer_time_zone_offset_t time_zone);
    162          
    163          static bool is_valid_date(sl_sleeptimer_date_t *date);
    164          
    165          static bool is_valid_date_64(sl_sleeptimer_date_t *date);
    166          
    167          static const uint8_t days_in_month[2u][12] = {
    168            /* Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec */
    169            { 31u, 28u, 31u, 30u, 31u, 30u, 31u, 31u, 30u, 31u, 30u, 31u },
    170            { 31u, 29u, 31u, 30u, 31u, 30u, 31u, 31u, 30u, 31u, 30u, 31u }
    171          };
    172          #endif
    173          
    174          /**************************************************************************//**
    175           * Initializes sleep timer.
    176           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    177          sl_status_t sl_sleeptimer_init(void)
    178          {
   \                     sl_sleeptimer_init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    179            CORE_DECLARE_IRQ_STATE;
    180          
    181            CORE_ENTER_ATOMIC();
   \        0x2   0x.... 0x....      BL       CORE_EnterAtomic
   \        0x6   0x4605             MOV      R5,R0
    182            if (!is_sleeptimer_initialized) {
   \        0x8   0x.... 0x....      LDR.W    R4,??DataTable22
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0xB9E8             CBNZ.N   R0,??sl_sleeptimer_init_0
    183              timer_head  = NULL;
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x60E2             STR      R2,[R4, #+12]
    184              last_delta_update_count = 0u;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6121             STR      R1,[R4, #+16]
    185              overflow_counter = 0u;
   \       0x18   0x80A0             STRH     R0,[R4, #+4]
    186              sleeptimer_hal_init_timer();
   \       0x1A   0x.... 0x....      BL       sleeptimer_hal_init_timer
    187              sleeptimer_hal_enable_int(SLEEPTIMER_EVENT_OF);
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x.... 0x....      BL       sleeptimer_hal_enable_int
    188              timer_frequency = sleeptimer_hal_get_timer_frequency();
   \       0x24   0x.... 0x....      BL       sleeptimer_hal_get_timer_frequency
   \       0x28   0x60A0             STR      R0,[R4, #+8]
    189              if (timer_frequency == 0) {
   \       0x2A   0x0002             MOVS     R2,R0
   \       0x2C   0xD104             BNE.N    ??sl_sleeptimer_init_1
    190                CORE_EXIT_ATOMIC();
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x.... 0x....      BL       CORE_ExitAtomic
    191                return SL_STATUS_INVALID_CONFIGURATION;
   \       0x34   0x2023             MOVS     R0,#+35
   \       0x36   0xBD70             POP      {R4-R6,PC}
    192              }
    193          
    194          #if SL_SLEEPTIMER_WALLCLOCK_CONFIG
    195              second_count = 0;
    196              calculated_tick_rest = ((uint64_t)UINT32_MAX + 1) % (uint64_t)timer_frequency;
    197              calculated_sec_count = (((uint64_t)UINT32_MAX + 1) / (uint64_t)timer_frequency);
    198          #endif
    199              max_millisecond_conversion = (uint32_t)(((uint64_t)UINT32_MAX * (uint64_t)1000u) / timer_frequency);
   \                     ??sl_sleeptimer_init_1: (+1)
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \       0x3C   0xF240 0x31E7      MOVW     R1,#+999
   \       0x40   0x2300             MOVS     R3,#+0
   \       0x42   0x.... 0x....      BL       __aeabi_uldivmod
    200              is_sleeptimer_initialized = true;
   \       0x46   0x2601             MOVS     R6,#+1
   \       0x48   0x6160             STR      R0,[R4, #+20]
   \       0x4A   0x7026             STRB     R6,[R4, #+0]
    201            }
    202            CORE_EXIT_ATOMIC();
   \                     ??sl_sleeptimer_init_0: (+1)
   \       0x4C   0x4628             MOV      R0,R5
   \       0x4E   0x.... 0x....      BL       CORE_ExitAtomic
    203          
    204            return SL_STATUS_OK;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBD70             POP      {R4-R6,PC}
    205          }
    206          
    207          /**************************************************************************//**
    208           * Starts a 32 bits timer.
    209           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          sl_status_t sl_sleeptimer_start_timer(sl_sleeptimer_timer_handle_t *handle,
    211                                                uint32_t timeout,
    212                                                sl_sleeptimer_timer_callback_t callback,
    213                                                void *callback_data,
    214                                                uint8_t priority,
    215                                                uint16_t option_flags)
    216          {
   \                     sl_sleeptimer_start_timer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB084             SUB      SP,SP,#+16
    217            bool is_running = false;
   \        0x6   0x.... 0x....      BL       ?Subroutine1
    218          
    219            if (handle == NULL) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xA   0xB90C             CBNZ.N   R4,??sl_sleeptimer_start_timer_0
    220              return SL_STATUS_NULL_POINTER;
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0xE00D             B.N      ??CrossCallReturnLabel_14
    221            }
    222          
    223            handle->conversion_error = 0;
   \                     ??sl_sleeptimer_start_timer_0: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine3
    224            handle->accumulated_error = 0;
    225          
    226            sl_sleeptimer_is_timer_running(handle, &is_running);
    227            if (is_running == true) {
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x14   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0x2003             MOVEQ    R0,#+3
    228              return SL_STATUS_NOT_READY;
   \       0x1E   0xD005             BEQ.N    ??CrossCallReturnLabel_14
    229            }
    230          
    231            return create_timer(handle,
    232                                timeout,
    233                                0,
    234                                callback,
    235                                callback_data,
    236                                priority,
    237                                option_flags);
   \       0x20   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
    238          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xF8BD 0x102C      LDRH     R1,[SP, #+44]
   \        0x4   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \        0x8   0x9102             STR      R1,[SP, #+8]
   \        0xA   0x9700             STR      R7,[SP, #+0]
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x4633             MOV      R3,R6
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x83A0             STRH     R0,[R4, #+28]
   \        0x2   0x83E0             STRH     R0,[R4, #+30]
   \        0x4   0xA903             ADD      R1,SP,#+12
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....             B.N      sl_sleeptimer_is_timer_running

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x461F             MOV      R7,R3
   \        0x8   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine8_0: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x....             B.N      create_timer
    239          
    240          /**************************************************************************//**
    241           * Restarts a 32 bits timer.
    242           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          sl_status_t sl_sleeptimer_restart_timer(sl_sleeptimer_timer_handle_t *handle,
    244                                                  uint32_t timeout,
    245                                                  sl_sleeptimer_timer_callback_t callback,
    246                                                  void *callback_data,
    247                                                  uint8_t priority,
    248                                                  uint16_t option_flags)
    249          {
   \                     sl_sleeptimer_restart_timer: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    250            if (handle == NULL) {
   \        0xA   0xD101             BNE.N    ??sl_sleeptimer_restart_timer_0
    251              return SL_STATUS_NULL_POINTER;
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0xBDFE             POP      {R1-R7,PC}
    252            }
    253          
    254            handle->conversion_error = 0;
   \                     ??sl_sleeptimer_restart_timer_0: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine2
    255            handle->accumulated_error = 0;
    256          
    257            //Trying to stop the Timer. Failing to do so implies the timer is not running.
    258            sl_sleeptimer_stop_timer(handle);
    259          
    260            //Creates the timer in any case.
    261            return create_timer(handle,
    262                                timeout,
    263                                0,
    264                                callback,
    265                                callback_data,
    266                                priority,
    267                                option_flags);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x14   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x....             B.N      ?Subroutine0
    268          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4629             MOV      R1,R5
   \        0x2   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_12: (+1)
   \        0x6   0xBDFE             POP      {R1-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xF8BD 0x1024      LDRH     R1,[SP, #+36]
   \        0x4   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \        0x8   0x9102             STR      R1,[SP, #+8]
   \        0xA   0x9700             STR      R7,[SP, #+0]
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x4633             MOV      R3,R6
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x83A1             STRH     R1,[R4, #+28]
   \        0x4   0x83E1             STRH     R1,[R4, #+30]
   \        0x6   0x....             B.N      sl_sleeptimer_stop_timer
    269          
    270          /**************************************************************************//**
    271           * Starts a 32 bits periodic timer.
    272           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    273          sl_status_t sl_sleeptimer_start_periodic_timer(sl_sleeptimer_timer_handle_t *handle,
    274                                                         uint32_t timeout,
    275                                                         sl_sleeptimer_timer_callback_t callback,
    276                                                         void *callback_data,
    277                                                         uint8_t priority,
    278                                                         uint16_t option_flags)
    279          {
   \                     sl_sleeptimer_start_periodic_timer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB084             SUB      SP,SP,#+16
    280            bool is_running = false;
   \        0x6   0x.... 0x....      BL       ?Subroutine1
    281          
    282            if (handle == NULL) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xA   0xB90C             CBNZ.N   R4,??sl_sleeptimer_start_periodic_timer_0
    283              return SL_STATUS_NULL_POINTER;
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0xE00D             B.N      ??CrossCallReturnLabel_13
    284            }
    285          
    286            handle->conversion_error = 0;
   \                     ??sl_sleeptimer_start_periodic_timer_0: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine3
    287            handle->accumulated_error = 0;
    288          
    289            sl_sleeptimer_is_timer_running(handle, &is_running);
    290            if (is_running == true) {
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x14   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0x2002             MOVEQ    R0,#+2
    291              return SL_STATUS_INVALID_STATE;
   \       0x1E   0xD005             BEQ.N    ??CrossCallReturnLabel_13
    292            }
    293          
    294            return create_timer(handle,
    295                                timeout,
    296                                timeout,
    297                                callback,
    298                                callback_data,
    299                                priority,
    300                                option_flags);
   \       0x20   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x24   0x462A             MOV      R2,R5
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
    301          }
    302          
    303          /**************************************************************************//**
    304           * Starts a 32 bits periodic timer using milliseconds as the timebase.
    305           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    306          sl_status_t sl_sleeptimer_start_periodic_timer_ms(sl_sleeptimer_timer_handle_t *handle,
    307                                                            uint32_t timeout_ms,
    308                                                            sl_sleeptimer_timer_callback_t callback,
    309                                                            void *callback_data,
    310                                                            uint8_t priority,
    311                                                            uint16_t option_flags)
    312          {
   \                     sl_sleeptimer_start_periodic_timer_ms: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB085             SUB      SP,SP,#+20
    313            bool is_running = false;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x460F             MOV      R7,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0xF88D 0x000C      STRB     R0,[SP, #+12]
    314            sl_status_t status;
    315            uint32_t timeout_tick;
    316          
    317            if (handle == NULL) {
   \       0x12   0xB90C             CBNZ.N   R4,??sl_sleeptimer_start_periodic_timer_ms_0
    318              return SL_STATUS_NULL_POINTER;
   \       0x14   0x2022             MOVS     R0,#+34
   \       0x16   0xE01C             B.N      ??CrossCallReturnLabel_16
    319            }
    320          
    321            sl_sleeptimer_is_timer_running(handle, &is_running);
   \                     ??sl_sleeptimer_start_periodic_timer_ms_0: (+1)
   \       0x18   0xA903             ADD      R1,SP,#+12
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       sl_sleeptimer_is_timer_running
    322            if (is_running == true) {
   \       0x20   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xBF08             IT       EQ
   \       0x28   0x2002             MOVEQ    R0,#+2
    323              return SL_STATUS_INVALID_STATE;
   \       0x2A   0xD012             BEQ.N    ??CrossCallReturnLabel_16
    324            }
    325          
    326            status = sl_sleeptimer_ms32_to_tick(timeout_ms, &timeout_tick);
   \       0x2C   0xA904             ADD      R1,SP,#+16
   \       0x2E   0x4638             MOV      R0,R7
   \       0x30   0x.... 0x....      BL       sl_sleeptimer_ms32_to_tick
    327            if (status != SL_STATUS_OK) {
   \       0x34   0xB968             CBNZ.N   R0,??CrossCallReturnLabel_16
    328              return status;
    329            }
    330          
    331            // Calculate ms to ticks conversion error
    332            handle->conversion_error = 1000
    333                                       - ((uint64_t)(timeout_ms * sl_sleeptimer_get_timer_frequency())
    334                                          % 1000);
   \       0x36   0x.... 0x....      BL       ?Subroutine5
    335            if (handle->conversion_error == 1000) {
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x3A   0xBF08             IT       EQ
   \       0x3C   0x2000             MOVEQ    R0,#+0
    336              handle->conversion_error = 0;
   \       0x3E   0x83A0             STRH     R0,[R4, #+28]
    337            }
    338            // Initialize accumulated error to 0. The calculated conversion error will
    339            // be added to this variable each time a timer in the series of periodic timers
    340            // expires.
    341            handle->accumulated_error = 0;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x83E0             STRH     R0,[R4, #+30]
    342          
    343            return create_timer(handle,
    344                                timeout_tick,
    345                                timeout_tick,
    346                                callback,
    347                                callback_data,
    348                                priority,
    349                                option_flags);
   \       0x44   0xF8BD 0x102C      LDRH     R1,[SP, #+44]
   \       0x48   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0x4C   0x9A04             LDR      R2,[SP, #+16]
   \       0x4E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x52   0xB005             ADD      SP,SP,#+20
   \       0x54   0xBDF0             POP      {R4-R7,PC}
    350          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x9102             STR      R1,[SP, #+8]
   \        0x2   0x9001             STR      R0,[SP, #+4]
   \        0x4   0x9600             STR      R6,[SP, #+0]
   \        0x6   0x462B             MOV      R3,R5
   \        0x8   0x4611             MOV      R1,R2
   \        0xA                      REQUIRE ??Subroutine8_0
   \        0xA                      ;; // Fall through to label ??Subroutine8_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable22
   \        0x4   0x6890             LDR      R0,[R2, #+8]
   \        0x6   0xF44F 0x717A      MOV      R1,#+1000
   \        0xA   0x4347             MULS     R7,R0,R7
   \        0xC   0xFBB7 0xF0F1      UDIV     R0,R7,R1
   \       0x10   0xFB00 0x7011      MLS      R0,R0,R1,R7
   \       0x14   0xF5C0 0x707A      RSB      R0,R0,#+1000
   \       0x18   0xB281             UXTH     R1,R0
   \       0x1A   0xF5B1 0x7F7A      CMP      R1,#+1000
   \       0x1E   0x4770             BX       LR
    351          
    352          /**************************************************************************//**
    353           * Restarts a 32 bits periodic timer.
    354           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    355          sl_status_t sl_sleeptimer_restart_periodic_timer(sl_sleeptimer_timer_handle_t *handle,
    356                                                           uint32_t timeout,
    357                                                           sl_sleeptimer_timer_callback_t callback,
    358                                                           void *callback_data,
    359                                                           uint8_t priority,
    360                                                           uint16_t option_flags)
    361          {
   \                     sl_sleeptimer_restart_periodic_timer: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    362            if (handle == NULL) {
   \        0xA   0xD101             BNE.N    ??sl_sleeptimer_restart_periodic_timer_0
    363              return SL_STATUS_NULL_POINTER;
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0xBDFE             POP      {R1-R7,PC}
    364            }
    365          
    366            handle->conversion_error = 0;
   \                     ??sl_sleeptimer_restart_periodic_timer_0: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine2
    367            handle->accumulated_error = 0;
    368          
    369            //Trying to stop the Timer. Failing to do so implies the timer has already been stopped.
    370            sl_sleeptimer_stop_timer(handle);
    371          
    372            //Creates the timer in any case.
    373            return create_timer(handle,
    374                                timeout,
    375                                timeout,
    376                                callback,
    377                                callback_data,
    378                                priority,
    379                                option_flags);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x14   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x18   0x462A             MOV      R2,R5
   \       0x1A                      REQUIRE ?Subroutine0
   \       0x1A                      ;; // Fall through to label ?Subroutine0
    380          }
    381          
    382          /**************************************************************************//**
    383           * Restarts a 32 bits periodic timer using milliseconds as the timebase.
    384           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    385          sl_status_t sl_sleeptimer_restart_periodic_timer_ms(sl_sleeptimer_timer_handle_t *handle,
    386                                                              uint32_t timeout_ms,
    387                                                              sl_sleeptimer_timer_callback_t callback,
    388                                                              void *callback_data,
    389                                                              uint8_t priority,
    390                                                              uint16_t option_flags)
    391          {
   \                     sl_sleeptimer_restart_periodic_timer_ms: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
    392            sl_status_t status;
    393            uint32_t timeout_tick;
    394          
    395            if (handle == NULL) {
   \        0xC   0xBF08             IT       EQ
   \        0xE   0x2022             MOVEQ    R0,#+34
    396              return SL_STATUS_NULL_POINTER;
   \       0x10   0xD015             BEQ.N    ??CrossCallReturnLabel_15
    397            }
    398          
    399            status = sl_sleeptimer_ms32_to_tick(timeout_ms, &timeout_tick);
   \       0x12   0xA903             ADD      R1,SP,#+12
   \       0x14   0x4638             MOV      R0,R7
   \       0x16   0x.... 0x....      BL       sl_sleeptimer_ms32_to_tick
    400            if (status != SL_STATUS_OK) {
   \       0x1A   0xB980             CBNZ.N   R0,??CrossCallReturnLabel_15
    401              return status;
    402            }
    403          
    404            // Calculate ms to ticks conversion error
    405            handle->conversion_error = 1000
    406                                       - ((uint64_t)(timeout_ms * sl_sleeptimer_get_timer_frequency())
    407                                          % 1000);
   \       0x1C   0x.... 0x....      BL       ?Subroutine5
    408            if (handle->conversion_error == 1000) {
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x20   0xBF08             IT       EQ
   \       0x22   0x2000             MOVEQ    R0,#+0
    409              handle->conversion_error = 0;
   \       0x24   0x83A0             STRH     R0,[R4, #+28]
    410            }
    411          
    412            // Initialize accumulated error to 0. The calculated conversion error will
    413            // be added to this variable each time a timer in the series of periodic timers
    414            // expires.
    415            handle->accumulated_error = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x83E0             STRH     R0,[R4, #+30]
    416          
    417            //Trying to stop the Timer. Failing to do so implies the timer has already been stopped.
    418            sl_sleeptimer_stop_timer(handle);
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       sl_sleeptimer_stop_timer
    419          
    420            //Creates the timer in any case.
    421            return create_timer(handle,
    422                                timeout_tick,
    423                                timeout_tick,
    424                                callback,
    425                                callback_data,
    426                                priority,
    427                                option_flags);
   \       0x30   0xF8BD 0x102C      LDRH     R1,[SP, #+44]
   \       0x34   0xF89D 0x0028      LDRB     R0,[SP, #+40]
   \       0x38   0x9A03             LDR      R2,[SP, #+12]
   \       0x3A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x3E   0xB005             ADD      SP,SP,#+20
   \       0x40   0xBDF0             POP      {R4-R7,PC}
    428          }
    429          
    430          /**************************************************************************//**
    431           * Stops a 32 bits timer.
    432           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    433          sl_status_t sl_sleeptimer_stop_timer(sl_sleeptimer_timer_handle_t *handle)
    434          {
   \                     sl_sleeptimer_stop_timer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
    435            CORE_DECLARE_IRQ_STATE;
    436            sl_status_t error;
    437            bool set_comparator = false;
   \        0x4   0x2400             MOVS     R4,#+0
    438          
    439            // Disable PRS compare and capture channel, if configured for early wakeup
    440          #if ((SL_SLEEPTIMER_PERIPHERAL == SL_SLEEPTIMER_PERIPHERAL_SYSRTC) \
    441            && defined(SL_CATALOG_POWER_MANAGER_PRESENT)                     \
    442            && !defined(SL_CATALOG_POWER_MANAGER_NO_DEEPSLEEP_PRESENT))
    443            if (handle->option_flags == (SLI_SLEEPTIMER_POWER_MANAGER_EARLY_WAKEUP_TIMER_FLAG | SLI_SLEEPTIMER_POWER_MANAGER_HF_ACCURACY_CLK_FLAG)) {
    444              sleeptimer_hal_disable_prs_compare_and_capture_channel();
    445            }
    446          #endif
    447          
    448            if (handle == NULL) {
   \        0x6   0xB90D             CBNZ.N   R5,??sl_sleeptimer_stop_timer_0
    449              return SL_STATUS_NULL_POINTER;
   \        0x8   0x2022             MOVS     R0,#+34
   \        0xA   0xBDF2             POP      {R1,R4-R7,PC}
    450            }
    451          
    452            CORE_ENTER_CRITICAL();
   \                     ??sl_sleeptimer_stop_timer_0: (+1)
   \        0xC   0x.... 0x....      BL       CORE_EnterCritical
   \       0x10   0x4606             MOV      R6,R0
    453            update_delta_list();
   \       0x12   0x.... 0x....      BL       update_delta_list
    454          
    455            // If first timer in list, update timer comparator.
    456            if (timer_head == handle) {
   \       0x16   0x.... 0x....      LDR.W    R7,??DataTable22
   \       0x1A   0x68F8             LDR      R0,[R7, #+12]
   \       0x1C   0x42A8             CMP      R0,R5
   \       0x1E   0xBF08             IT       EQ
   \       0x20   0x2401             MOVEQ    R4,#+1
    457              set_comparator = true;
    458            }
    459          
    460            error = delta_list_remove_timer(handle);
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x.... 0x....      BL       delta_list_remove_timer
   \       0x28   0x0005             MOVS     R5,R0
    461            if (error != SL_STATUS_OK) {
   \       0x2A   0xD004             BEQ.N    ??sl_sleeptimer_stop_timer_1
    462              CORE_EXIT_CRITICAL();
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0x.... 0x....      BL       CORE_ExitCritical
    463          
    464              return error;
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0xBDF2             POP      {R1,R4-R7,PC}
    465            }
    466          
    467            if (set_comparator && timer_head) {
   \                     ??sl_sleeptimer_stop_timer_1: (+1)
   \       0x36   0x68F8             LDR      R0,[R7, #+12]
   \       0x38   0xB11C             CBZ.N    R4,??sl_sleeptimer_stop_timer_2
   \       0x3A   0xB118             CBZ.N    R0,??sl_sleeptimer_stop_timer_3
    468              set_comparator_for_next_timer();
   \       0x3C   0x.... 0x....      BL       set_comparator_for_next_timer
   \       0x40   0xE003             B.N      ??sl_sleeptimer_stop_timer_4
    469            } else if (!timer_head) {
   \                     ??sl_sleeptimer_stop_timer_2: (+1)
   \       0x42   0xB910             CBNZ.N   R0,??sl_sleeptimer_stop_timer_4
    470              sleeptimer_hal_disable_int(SLEEPTIMER_EVENT_COMP);
   \                     ??sl_sleeptimer_stop_timer_3: (+1)
   \       0x44   0x2002             MOVS     R0,#+2
   \       0x46   0x.... 0x....      BL       sleeptimer_hal_disable_int
    471            }
    472          
    473            CORE_EXIT_CRITICAL();
   \                     ??sl_sleeptimer_stop_timer_4: (+1)
   \       0x4A   0x4630             MOV      R0,R6
   \       0x4C   0x.... 0x....      BL       CORE_ExitCritical
    474          
    475            return SL_STATUS_OK;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xBDF2             POP      {R1,R4-R7,PC}
    476          }
    477          
    478          /**************************************************************************//**
    479           * Gets the status of a timer.
    480           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          sl_status_t sl_sleeptimer_is_timer_running(sl_sleeptimer_timer_handle_t *handle,
    482                                                     bool *running)
    483          {
   \                     sl_sleeptimer_is_timer_running: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    484            CORE_DECLARE_IRQ_STATE;
    485            sl_sleeptimer_timer_handle_t *current;
    486          
    487            if (handle == NULL || running == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2D00             CMPNE    R5,#+0
   \        0xA   0xD101             BNE.N    ??sl_sleeptimer_is_timer_running_0
    488              return SL_STATUS_NULL_POINTER;
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    489            } else {
    490              *running = false;
   \                     ??sl_sleeptimer_is_timer_running_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x7028             STRB     R0,[R5, #+0]
    491              CORE_ENTER_ATOMIC();
   \       0x14   0x.... 0x....      BL       CORE_EnterAtomic
    492              current = timer_head;
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable22
   \       0x1C   0x68C9             LDR      R1,[R1, #+12]
   \       0x1E   0x782B             LDRB     R3,[R5, #+0]
   \       0x20   0xE000             B.N      ??sl_sleeptimer_is_timer_running_1
    493              while (current != NULL && !*running) {
    494                if (current == handle) {
    495                  *running = true;
    496                } else {
    497                  current = current->next;
   \                     ??sl_sleeptimer_is_timer_running_2: (+1)
   \       0x22   0x6889             LDR      R1,[R1, #+8]
    498                }
   \                     ??sl_sleeptimer_is_timer_running_1: (+1)
   \       0x24   0xB119             CBZ.N    R1,??sl_sleeptimer_is_timer_running_3
   \       0x26   0xB913             CBNZ.N   R3,??sl_sleeptimer_is_timer_running_3
   \       0x28   0x42A1             CMP      R1,R4
   \       0x2A   0xD1FA             BNE.N    ??sl_sleeptimer_is_timer_running_2
   \       0x2C   0x2301             MOVS     R3,#+1
   \                     ??sl_sleeptimer_is_timer_running_3: (+1)
   \       0x2E   0x702B             STRB     R3,[R5, #+0]
    499              }
    500              CORE_EXIT_ATOMIC();
   \       0x30   0x.... 0x....      BL       CORE_ExitAtomic
    501            }
    502            return SL_STATUS_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    503          }
    504          
    505          /**************************************************************************//**
    506           * Gets a 32 bits timer's time remaining.
    507           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    508          sl_status_t sl_sleeptimer_get_timer_time_remaining(sl_sleeptimer_timer_handle_t *handle,
    509                                                             uint32_t *time)
    510          {
   \                     sl_sleeptimer_get_timer_time_remaining: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x460C             MOV      R4,R1
    511            CORE_DECLARE_IRQ_STATE;
    512            sl_sleeptimer_timer_handle_t *current;
    513          
    514            if (handle == NULL || time == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2C00             CMPNE    R4,#+0
   \        0xA   0xD101             BNE.N    ??sl_sleeptimer_get_timer_time_remaining_0
    515              return SL_STATUS_NULL_POINTER;
   \        0xC   0x2022             MOVS     R0,#+34
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
    516            }
    517          
    518            CORE_ENTER_ATOMIC();
   \                     ??sl_sleeptimer_get_timer_time_remaining_0: (+1)
   \       0x10   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x14   0x4606             MOV      R6,R0
    519          
    520            update_delta_list();
   \       0x16   0x.... 0x....      BL       update_delta_list
    521            *time  = handle->delta;
    522          
    523            // Retrieve timer in list and add the deltas.
    524            current = timer_head;
   \       0x1A   0x.... 0x....      LDR.W    R7,??DataTable22
   \       0x1E   0x696A             LDR      R2,[R5, #+20]
   \       0x20   0x68F8             LDR      R0,[R7, #+12]
   \       0x22   0xE002             B.N      ??sl_sleeptimer_get_timer_time_remaining_1
    525            while (current != handle && current != NULL) {
    526              *time += current->delta;
   \                     ??sl_sleeptimer_get_timer_time_remaining_2: (+1)
   \       0x24   0x6941             LDR      R1,[R0, #+20]
    527              current = current->next;
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0x188A             ADDS     R2,R1,R2
    528            }
   \                     ??sl_sleeptimer_get_timer_time_remaining_1: (+1)
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xD007             BEQ.N    ??sl_sleeptimer_get_timer_time_remaining_3
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0x6022             STR      R2,[R4, #+0]
   \       0x32   0xD1F7             BNE.N    ??sl_sleeptimer_get_timer_time_remaining_2
    529          
    530            if (current != handle) {
    531              CORE_EXIT_ATOMIC();
   \       0x34   0x4630             MOV      R0,R6
   \       0x36   0x.... 0x....      BL       CORE_ExitAtomic
    532          
    533              return SL_STATUS_NOT_READY;
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0xBDF2             POP      {R1,R4-R7,PC}
    534            }
   \                     ??sl_sleeptimer_get_timer_time_remaining_3: (+1)
   \       0x3E   0x6022             STR      R2,[R4, #+0]
    535          
    536            // Substract time since last compare match.
    537            if (*time > sleeptimer_hal_get_counter() - last_delta_update_count) {
   \       0x40   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x44   0x6939             LDR      R1,[R7, #+16]
   \       0x46   0x6822             LDR      R2,[R4, #+0]
   \       0x48   0x1A40             SUBS     R0,R0,R1
   \       0x4A   0x4290             CMP      R0,R2
   \       0x4C   0xD206             BCS.N    ??sl_sleeptimer_get_timer_time_remaining_4
    538              *time -= sleeptimer_hal_get_counter() - last_delta_update_count;
   \       0x4E   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x1A08             SUBS     R0,R1,R0
   \       0x56   0x6939             LDR      R1,[R7, #+16]
   \       0x58   0x1809             ADDS     R1,R1,R0
   \       0x5A   0xE000             B.N      ??sl_sleeptimer_get_timer_time_remaining_5
    539            } else {
    540              *time = 0;
   \                     ??sl_sleeptimer_get_timer_time_remaining_4: (+1)
   \       0x5C   0x2100             MOVS     R1,#+0
   \                     ??sl_sleeptimer_get_timer_time_remaining_5: (+1)
   \       0x5E   0x6021             STR      R1,[R4, #+0]
    541            }
    542          
    543            CORE_EXIT_ATOMIC();
   \       0x60   0x4630             MOV      R0,R6
   \       0x62   0x.... 0x....      BL       CORE_ExitAtomic
    544          
    545            return SL_STATUS_OK;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xBDF2             POP      {R1,R4-R7,PC}
    546          }
    547          
    548          /**************************************************************************//**
    549           * Gets the time remaining until the first timer with the matching set of flags
    550           * expires.
    551           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    552          sl_status_t sl_sleeptimer_get_remaining_time_of_first_timer(uint16_t option_flags,
    553                                                                      uint32_t *time_remaining)
    554          {
   \                     sl_sleeptimer_get_remaining_time_of_first_timer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    555            CORE_DECLARE_IRQ_STATE;
    556            sl_sleeptimer_timer_handle_t *current;
    557            uint32_t time = 0;
    558          
    559            CORE_ENTER_ATOMIC();
   \        0x8   0x.... 0x....      BL       CORE_EnterAtomic
   \        0xC   0x4680             MOV      R8,R0
    560            // parse list and retrieve first timer with option flags requirement.
    561            current = timer_head;
   \        0xE   0x.... 0x....      LDR.W    R7,??DataTable22
   \       0x12   0x2400             MOVS     R4,#+0
   \       0x14   0x68F8             LDR      R0,[R7, #+12]
   \       0x16   0xE000             B.N      ??sl_sleeptimer_get_remaining_time_of_first_tim_0
    562            while (current != NULL) {
    563              // save time remaining for timer.
    564              time += current->delta;
    565              // Check if the current timer has the flags requested
    566              if (current->option_flags == option_flags
    567                  || option_flags == SL_SLEEPTIMER_ANY_FLAG) {
    568                // Substract time since last compare match.
    569                if (time > (sleeptimer_hal_get_counter() - last_delta_update_count)) {
    570                  time -= (sleeptimer_hal_get_counter() - last_delta_update_count);
    571                } else {
    572                  time = 0;
    573                }
    574                *time_remaining = time;
    575                CORE_EXIT_ATOMIC();
    576          
    577                return SL_STATUS_OK;
    578              }
    579              current = current->next;
   \                     ??sl_sleeptimer_get_remaining_time_of_first_tim_1: (+1)
   \       0x18   0x6880             LDR      R0,[R0, #+8]
   \                     ??sl_sleeptimer_get_remaining_time_of_first_tim_0: (+1)
   \       0x1A   0xB1C8             CBZ.N    R0,??sl_sleeptimer_get_remaining_time_of_first_tim_2
   \       0x1C   0x6943             LDR      R3,[R0, #+20]
   \       0x1E   0x88C2             LDRH     R2,[R0, #+6]
   \       0x20   0x191C             ADDS     R4,R3,R4
   \       0x22   0x42AA             CMP      R2,R5
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2DFF             CMPNE    R5,#+255
   \       0x28   0xD1F6             BNE.N    ??sl_sleeptimer_get_remaining_time_of_first_tim_1
   \       0x2A   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x2E   0x6939             LDR      R1,[R7, #+16]
   \       0x30   0x1A40             SUBS     R0,R0,R1
   \       0x32   0x42A0             CMP      R0,R4
   \       0x34   0xD205             BCS.N    ??sl_sleeptimer_get_remaining_time_of_first_tim_3
   \       0x36   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x3A   0x1A24             SUBS     R4,R4,R0
   \       0x3C   0x6938             LDR      R0,[R7, #+16]
   \       0x3E   0x1904             ADDS     R4,R0,R4
   \       0x40   0xE000             B.N      ??sl_sleeptimer_get_remaining_time_of_first_tim_4
   \                     ??sl_sleeptimer_get_remaining_time_of_first_tim_3: (+1)
   \       0x42   0x2400             MOVS     R4,#+0
   \                     ??sl_sleeptimer_get_remaining_time_of_first_tim_4: (+1)
   \       0x44   0x6034             STR      R4,[R6, #+0]
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0x.... 0x....      BL       CORE_ExitAtomic
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xE003             B.N      ??sl_sleeptimer_get_remaining_time_of_first_tim_5
    580            }
    581            CORE_EXIT_ATOMIC();
   \                     ??sl_sleeptimer_get_remaining_time_of_first_tim_2: (+1)
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       CORE_ExitAtomic
    582          
    583            return SL_STATUS_EMPTY;
   \       0x56   0x201B             MOVS     R0,#+27
   \                     ??sl_sleeptimer_get_remaining_time_of_first_tim_5: (+1)
   \       0x58   0xE8BD 0x81F0      POP      {R4-R8,PC}
    584          }
    585          
    586          /**************************************************************************//**
    587           * Determines if next timer to expire has the option flag
    588           * "SL_SLEEPTIMER_POWER_MANAGER_EARLY_WAKEUP_TIMER_FLAG".
    589           *
    590           * @note This function is for internal use only.
    591           *
    592           * @note A check to validate that the Power Manager Sleeptimer is expired on
    593           *       top of being the next timer was added. This is because
    594           *       this function is called when coming back from EM2 sleep to validate
    595           *       that the system woke up because of this precise timer expiration.
    596           *       Some race conditions, seen with FreeRTOS, could create invalid RTC
    597           *       interrupt leading to believe that the power manager timer was expired
    598           *       when it was not.
    599           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    600          bool sli_sleeptimer_is_power_manager_timer_next_to_expire(void)
    601          {
   \                     sli_sleeptimer_is_power_manager_timer_next_to_expire: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    602            bool next_timer_is_power_manager;
    603          
    604            sl_atomic_load(next_timer_is_power_manager, next_timer_to_expire_is_power_manager);
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable22
   \        0x6   0x786C             LDRB     R4,[R5, #+1]
    605          
    606            // Make sure that the Power Manager Sleeptimer is actually expired in addition
    607            // to being the next timer.
    608            if ((next_timer_is_power_manager)
    609                && ((sl_sleeptimer_get_tick_count() - timer_head->timeout_expected_tc) > MIN_DIFF_BETWEEN_COUNT_AND_EXPIRATION)) {
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0xD007             BEQ.N    ??sli_sleeptimer_is_power_manager_timer_next_to_0
   \        0xC   0x.... 0x....      BL       sl_sleeptimer_get_tick_count
   \       0x10   0x68EA             LDR      R2,[R5, #+12]
   \       0x12   0x6991             LDR      R1,[R2, #+24]
   \       0x14   0x1A40             SUBS     R0,R0,R1
   \       0x16   0x2803             CMP      R0,#+3
   \       0x18   0xBF28             IT       CS
   \       0x1A   0x2400             MOVCS    R4,#+0
    610              next_timer_is_power_manager = false;
    611            }
    612          
    613            return next_timer_is_power_manager;
   \                     ??sli_sleeptimer_is_power_manager_timer_next_to_0: (+1)
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
    614          }
    615          
    616          /***************************************************************************//**
    617          * Gets current 32 bits tick count.
    618          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    619          uint32_t sl_sleeptimer_get_tick_count(void)
    620          {
   \                     sl_sleeptimer_get_tick_count: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    621            uint32_t cnt;
    622            CORE_DECLARE_IRQ_STATE;
    623          
    624            CORE_ENTER_ATOMIC();
   \        0x2   0x.... 0x....      BL       CORE_EnterAtomic
   \        0x6   0x4605             MOV      R5,R0
    625            cnt = sleeptimer_hal_get_counter();
   \        0x8   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \        0xC   0x4604             MOV      R4,R0
    626            CORE_EXIT_ATOMIC();
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       CORE_ExitAtomic
    627          
    628            return cnt;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}
    629          }
    630          
    631          /***************************************************************************//**
    632          * Gets current 64 bits tick count.
    633          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    634          uint64_t sl_sleeptimer_get_tick_count64(void)
    635          {
   \                     sl_sleeptimer_get_tick_count64: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    636            uint32_t tick_cnt;
    637            uint32_t of_cnt;
    638            CORE_DECLARE_IRQ_STATE;
    639          
    640            CORE_ENTER_ATOMIC();
   \        0x2   0x.... 0x....      BL       CORE_EnterAtomic
   \        0x6   0x4606             MOV      R6,R0
    641            tick_cnt = sleeptimer_hal_get_counter();
   \        0x8   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \        0xC   0x4604             MOV      R4,R0
    642            of_cnt = overflow_counter;
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x12   0x8885             LDRH     R5,[R0, #+4]
    643          
    644            if (sli_sleeptimer_hal_is_int_status_set(SLEEPTIMER_EVENT_OF)) {
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x.... 0x....      BL       sli_sleeptimer_hal_is_int_status_set
   \       0x1A   0xB118             CBZ.N    R0,??sl_sleeptimer_get_tick_count64_0
    645              tick_cnt = sleeptimer_hal_get_counter();
   \       0x1C   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x20   0x4604             MOV      R4,R0
    646              of_cnt++;
   \       0x22   0x1C6D             ADDS     R5,R5,#+1
    647            }
    648            CORE_EXIT_ATOMIC();
   \                     ??sl_sleeptimer_get_tick_count64_0: (+1)
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x.... 0x....      BL       CORE_ExitAtomic
    649          
    650            return (((uint64_t) of_cnt) << 32) | tick_cnt;
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0xBD70             POP      {R4-R6,PC}
    651          }
    652          
    653          /***************************************************************************//**
    654           * Get timer frequency.
    655           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    656          uint32_t sl_sleeptimer_get_timer_frequency(void)
    657          {
    658            return timer_frequency;
   \                     sl_sleeptimer_get_timer_frequency: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable22
   \        0x4   0x6880             LDR      R0,[R0, #+8]
   \        0x6   0x4770             BX       LR
    659          }
    660          
    661          #if SL_SLEEPTIMER_WALLCLOCK_CONFIG
    662          /***************************************************************************//**
    663           * Retrieves current 32 bit time.
    664           ******************************************************************************/
    665          sl_sleeptimer_timestamp_t sl_sleeptimer_get_time(void)
    666          {
    667            uint64_t temp_time = sl_sleeptimer_get_time_64();
    668            // Add offset for 64 to 32 bit time
    669            if (temp_time >= TIME_64_TO_32_EPOCH_OFFSET_SEC) {
    670              temp_time -= TIME_64_TO_32_EPOCH_OFFSET_SEC;
    671            }
    672            // Return lower 32 bits of 64 bit time
    673            uint32_t time = (temp_time & 0xFFFFFFFF);
    674          
    675            return time;
    676          }
    677          
    678          /***************************************************************************//**
    679           * Retrieves current 64 bit time.
    680           ******************************************************************************/
    681          sl_sleeptimer_timestamp_64_t sl_sleeptimer_get_time_64(void)
    682          {
    683            uint32_t cnt = 0u;
    684            uint32_t freq = 0u;
    685            sl_sleeptimer_timestamp_64_t time;
    686            CORE_DECLARE_IRQ_STATE;
    687          
    688            cnt = sleeptimer_hal_get_counter();
    689            freq = sl_sleeptimer_get_timer_frequency();
    690          
    691            CORE_ENTER_ATOMIC();
    692            time = second_count + cnt / freq;
    693          
    694            if (cnt % freq + overflow_tick_rest >= freq) {
    695              time++;
    696            }
    697            CORE_EXIT_ATOMIC();
    698          
    699            return time;
    700          }
    701          
    702          /***************************************************************************//**
    703           * Sets current time from 32 bit variable.
    704           ******************************************************************************/
    705          sl_status_t sl_sleeptimer_set_time(sl_sleeptimer_timestamp_t time)
    706          {
    707            // convert 32 bit time to 64 bit time
    708            uint64_t temp_time = time + TIME_64_TO_32_EPOCH_OFFSET_SEC;
    709            sl_status_t err_code = sl_sleeptimer_set_time_64(temp_time);
    710            return err_code;
    711          }
    712          
    713          /***************************************************************************//**
    714           * Sets current time from 64 bit variable.
    715           ******************************************************************************/
    716          sl_status_t sl_sleeptimer_set_time_64(sl_sleeptimer_timestamp_64_t time)
    717          {
    718            uint32_t freq = 0u;
    719            uint32_t counter_sec = 0u;
    720            uint32_t cnt = 0;
    721            CORE_DECLARE_IRQ_STATE;
    722          
    723            // convert 64 bit time to 32 bit time
    724            if (!is_valid_time_64(time, TIME_FORMAT_UNIX_64_BIT, 0u)) {
    725              return SL_STATUS_INVALID_PARAMETER;
    726            }
    727          
    728            freq = sl_sleeptimer_get_timer_frequency();
    729            cnt = sleeptimer_hal_get_counter();
    730          
    731            CORE_ENTER_ATOMIC();
    732            // store 64 bit time as 64 bits's
    733            second_count = time;
    734          
    735            // Convert 64 bit time to 32 bit time in order to check for overflow
    736            // i.e. if 32 bit time is >=counter_sec
    737            uint64_t temp_time = second_count - TIME_64_TO_32_EPOCH_OFFSET_SEC;
    738            uint32_t second_time_32 = (temp_time & 0xFFFFFFFF);
    739          
    740            overflow_tick_rest = 0;
    741            counter_sec = cnt / freq;
    742          
    743            if (second_time_32 >= counter_sec) {
    744              second_count -= counter_sec;
    745            } else {
    746              CORE_EXIT_ATOMIC();
    747          
    748              return SL_STATUS_INVALID_PARAMETER;
    749            }
    750          
    751            CORE_EXIT_ATOMIC();
    752          
    753            return SL_STATUS_OK;
    754          }
    755          
    756          /***************************************************************************//**
    757           * Gets current date.
    758           ******************************************************************************/
    759          sl_status_t sl_sleeptimer_get_datetime(sl_sleeptimer_date_t *date)
    760          {
    761            sl_sleeptimer_timestamp_64_t time = 0u;
    762            sl_sleeptimer_time_zone_offset_t tz;
    763            sl_status_t err_code = SL_STATUS_OK;
    764          
    765            // Fetch 64 bit timestamp
    766            time = sl_sleeptimer_get_time_64();
    767            tz = sl_sleeptimer_get_tz();
    768            err_code = sl_sleeptimer_convert_time_to_date_64(time, tz, date);
    769          
    770            return err_code;
    771          }
    772          
    773          /***************************************************************************//**
    774           * Sets current time, in date format.
    775           ******************************************************************************/
    776          sl_status_t sl_sleeptimer_set_datetime(sl_sleeptimer_date_t *date)
    777          {
    778            sl_sleeptimer_timestamp_64_t time = 0u;
    779            sl_status_t err_code = SL_STATUS_OK;
    780            CORE_DECLARE_IRQ_STATE;
    781          
    782            if (!is_valid_date_64(date)) {
    783              return SL_STATUS_INVALID_PARAMETER;
    784            }
    785          
    786            err_code = sl_sleeptimer_convert_date_to_time_64(date, &time);
    787            if (err_code != SL_STATUS_OK) {
    788              return err_code;
    789            }
    790          
    791            CORE_ENTER_ATOMIC();
    792            // sets the 64 bit second_time value
    793            err_code = sl_sleeptimer_set_time_64(time);
    794            if (err_code == SL_STATUS_OK) {
    795              sl_sleeptimer_set_tz(date->time_zone);
    796            }
    797            CORE_EXIT_ATOMIC();
    798          
    799            return err_code;
    800          }
    801          
    802          /***************************************************************************//**
    803           * Builds a date time structure based on the provided parameters.
    804           ******************************************************************************/
    805          sl_status_t sl_sleeptimer_build_datetime(sl_sleeptimer_date_t *date,
    806                                                   uint16_t year,
    807                                                   sl_sleeptimer_month_t month,
    808                                                   uint8_t month_day,
    809                                                   uint8_t hour,
    810                                                   uint8_t min,
    811                                                   uint8_t sec,
    812                                                   sl_sleeptimer_time_zone_offset_t tz_offset)
    813          {
    814            if (date == NULL) {
    815              return SL_STATUS_NULL_POINTER;
    816            }
    817          
    818            // If year is smaller than 1900, assume NTP Epoch is used.
    819            date->year = ((year < TIME_NTP_EPOCH) ? year : (year - TIME_NTP_EPOCH));
    820            date->month = month;
    821            date->month_day = month_day;
    822            date->hour = hour;
    823            date->min = min;
    824            date->sec = sec;
    825            date->time_zone = tz_offset;
    826          
    827            // Validate that input parameters are correct before filing the missing fields
    828            if (!is_valid_date(date)) {
    829              return SL_STATUS_INVALID_PARAMETER;
    830            }
    831          
    832            date->day_of_year = compute_day_of_year(date->month, date->month_day, is_leap_year(date->year));
    833            date->day_of_week = compute_day_of_week(((date->year - TIME_NTP_UNIX_EPOCH_DIFF)  * TIME_DAY_PER_YEAR)
    834                                                    + number_of_leap_days(TIME_UNIX_EPOCH, (date->year + TIME_NTP_EPOCH))
    835                                                    + date->day_of_year - 1);
    836          
    837            return SL_STATUS_OK;
    838          }
    839          
    840          /***************************************************************************//**
    841           * Builds a date time structure based on the provided parameters.
    842           ******************************************************************************/
    843          sl_status_t sl_sleeptimer_build_datetime_64(sl_sleeptimer_date_t *date,
    844                                                      uint16_t year,
    845                                                      sl_sleeptimer_month_t month,
    846                                                      uint8_t month_day,
    847                                                      uint8_t hour,
    848                                                      uint8_t min,
    849                                                      uint8_t sec,
    850                                                      sl_sleeptimer_time_zone_offset_t tz_offset)
    851          {
    852            if (date == NULL) {
    853              return SL_STATUS_NULL_POINTER;
    854            }
    855          
    856            // Ensure that year is greater than 1900 and based on 0 epoch
    857            if (year < TIME_NTP_EPOCH) {
    858              return SL_STATUS_INVALID_PARAMETER;
    859            }
    860          
    861            // Convert year based on 0 epoch to a valid date->year based on 1900 epoch
    862            date->year = (year - TIME_NTP_EPOCH);
    863            date->month = month;
    864            date->month_day = month_day;
    865            date->hour = hour;
    866            date->min = min;
    867            date->sec = sec;
    868            date->time_zone = tz_offset;
    869          
    870            // Validate that input parameters are correct before filing the missing fields
    871            if (!is_valid_date_64(date)) {
    872              return SL_STATUS_INVALID_PARAMETER;
    873            }
    874          
    875            date->day_of_year = compute_day_of_year(date->month, date->month_day, is_leap_year(date->year));
    876            date->day_of_week = compute_day_of_week_64((date->year * TIME_DAY_PER_YEAR)
    877                                                       + number_of_leap_days(TIME_NTP_EPOCH, (date->year + TIME_NTP_EPOCH))
    878                                                       + date->day_of_year - 1);
    879          
    880            return SL_STATUS_OK;
    881          }
    882          
    883          /*******************************************************************************
    884           * Convert a 32 bit time stamp into a date structure.
    885           ******************************************************************************/
    886          sl_status_t sl_sleeptimer_convert_time_to_date(sl_sleeptimer_timestamp_t time,
    887                                                         sl_sleeptimer_time_zone_offset_t time_zone,
    888                                                         sl_sleeptimer_date_t *date)
    889          {
    890            // convert 32 bit timestamp to 64 bit
    891            sl_sleeptimer_timestamp_64_t temp_time = (uint64_t)time + TIME_64_TO_32_EPOCH_OFFSET_SEC;
    892            sl_status_t err_code = sl_sleeptimer_convert_time_to_date_64(temp_time, time_zone, date);
    893            return err_code;
    894          }
    895          
    896          /*******************************************************************************
    897           * Convert a 64 bit time stamp into a date structure.
    898           ******************************************************************************/
    899          sl_status_t sl_sleeptimer_convert_time_to_date_64(sl_sleeptimer_timestamp_64_t time,
    900                                                            sl_sleeptimer_time_zone_offset_t time_zone,
    901                                                            sl_sleeptimer_date_t *date)
    902          {
    903            uint16_t full_year = 0;
    904            uint16_t leap_day = 0;
    905            uint8_t leap_year_flag = 0;
    906            uint8_t current_month = 0;
    907          
    908            if (!is_valid_time_64(time, TIME_FORMAT_UNIX_64_BIT, time_zone)) {
    909              return SL_STATUS_INVALID_PARAMETER;
    910            }
    911          
    912            time += time_zone;  // add UTC offset to convert to Standard Time
    913            date->sec = time % 60;
    914            time /= 60;
    915            date->min = time % 60;
    916            time /= 60;
    917            date->hour = time % 24;
    918            time /= 24; // time is now the number of days since 1900
    919          
    920            date->day_of_week = (sl_sleeptimer_weekDay_t)compute_day_of_week_64(time);
    921          
    922            full_year = time / TIME_DAY_PER_YEAR; // Approximates the number of full years
    923            uint32_t base_year = 1900u;
    924            uint32_t current_year = full_year + base_year;
    925          
    926            if (full_year > 4) { // 1904 is the first leap year since 1900
    927              leap_day = number_of_leap_days(base_year, current_year);  // Approximates the number of leap days.
    928              full_year = (time - leap_day) / TIME_DAY_PER_YEAR; // Computes the number of year integrating the leap days.
    929              current_year = full_year + base_year;
    930              leap_day = number_of_leap_days(base_year, current_year); // Computes the actual number of leap days of the previous years.
    931            }
    932            date->year = full_year; // Year in date struct must be based on a 1900 epoch.
    933            if (is_leap_year(date->year)) {
    934              leap_year_flag = 1;
    935            }
    936          
    937            time = (time - leap_day) - (TIME_DAY_PER_YEAR * full_year);  // Subtracts days of previous year.
    938            date->day_of_year = time + 1;
    939          
    940            while (time >= days_in_month[leap_year_flag][current_month]) {
    941              time -= days_in_month[leap_year_flag][current_month]; // Subtracts the number of days of the passed month.
    942              current_month++;
    943            }
    944            date->month = (sl_sleeptimer_month_t)current_month;
    945            date->month_day = time + 1;
    946            date->time_zone = time_zone;
    947          
    948            return SL_STATUS_OK;
    949          }
    950          
    951          /*******************************************************************************
    952           * Convert a date structure into a 32 bit time stamp.
    953           ******************************************************************************/
    954          sl_status_t sl_sleeptimer_convert_date_to_time(sl_sleeptimer_date_t *date,
    955                                                         sl_sleeptimer_timestamp_t *time)
    956          {
    957            // Create a 64 bit time stamp
    958            sl_sleeptimer_timestamp_64_t temp_time =  0;
    959            sl_status_t err_code = sl_sleeptimer_convert_date_to_time_64(date, &temp_time);
    960          
    961            if (err_code != SL_STATUS_OK) {
    962              return err_code;
    963            }
    964            // Convert 64 bit time to 32 bit time
    965          
    966            sl_sleeptimer_timestamp_64_t time_32 = temp_time;
    967            time_32 -= TIME_64_TO_32_EPOCH_OFFSET_SEC;
    968            *time = (time_32 & 0xFFFFFFFF);
    969          
    970            return err_code;
    971          }
    972          
    973          /*******************************************************************************
    974           * Convert a date structure into a 64 bit time stamp.
    975           ******************************************************************************/
    976          sl_status_t sl_sleeptimer_convert_date_to_time_64(sl_sleeptimer_date_t *date,
    977                                                            sl_sleeptimer_timestamp_64_t *time)
    978          {
    979            uint16_t month_days = 0;
    980            uint8_t  month;
    981            uint16_t  full_year = 0;
    982            uint8_t  leap_year_flag = 0;
    983            uint16_t  leap_days = 0;
    984          
    985            if (!is_valid_date_64(date)) {
    986              return SL_STATUS_INVALID_PARAMETER;
    987            }
    988          
    989            full_year = (date->year);                                  // base year for 64 bits its 1900 not 1970
    990            month = date->month;                              // offset to get months value from 1 to 12.
    991          
    992            uint32_t base_year = 1900u;
    993            uint32_t current_year = full_year + base_year;
    994          
    995            *time = (full_year * (uint64_t)TIME_SEC_PER_YEAR);
    996          
    997            if (full_year > 4) {                                       // 1904 is the first leap year since 1900
    998              leap_days = number_of_leap_days(base_year, current_year);
    999              month_days = leap_days;
   1000            }
   1001          
   1002            if (is_leap_year(date->year)) {
   1003              leap_year_flag = 1;
   1004            }
   1005          
   1006            for (int i = 0; i < month; i++) {
   1007              month_days += days_in_month[leap_year_flag][i];         // Add the number of days of the month of the year.
   1008            }
   1009          
   1010            month_days += (date->month_day - 1);                       // Add full days of the current month.
   1011            *time += month_days * TIME_SEC_PER_DAY;
   1012            *time += (3600 * date->hour) + (60 * date->min) + date->sec;
   1013            *time -= date->time_zone;
   1014          
   1015            return SL_STATUS_OK;
   1016          }
   1017          
   1018          /*******************************************************************************
   1019           * Convert a date structure to string.
   1020           ******************************************************************************/
   1021          uint32_t sl_sleeptimer_convert_date_to_str(char *str,
   1022                                                     size_t size,
   1023                                                     const uint8_t *format,
   1024                                                     sl_sleeptimer_date_t *date)
   1025          {
   1026            uint32_t  return_size = 0u;
   1027            if (is_valid_date(date)) {
   1028              struct tm date_struct;
   1029          
   1030              date_struct.tm_hour = date->hour;
   1031              date_struct.tm_mday = date->month_day;
   1032              date_struct.tm_min = date->min;
   1033              date_struct.tm_mon = date->month;
   1034              date_struct.tm_sec = date->sec;
   1035              date_struct.tm_wday = date->day_of_week;
   1036              date_struct.tm_yday = date->day_of_year;
   1037              date_struct.tm_year = date->year;
   1038          
   1039              return_size = strftime(str,
   1040                                     size,
   1041                                     (const char *)format,
   1042                                     &date_struct);
   1043            }
   1044          
   1045            return return_size;
   1046          }
   1047          
   1048          /***************************************************************************//**
   1049           * Sets time zone offset.
   1050           *
   1051           * @param  offset  Time zone offset, in seconds.
   1052           ******************************************************************************/
   1053          void sl_sleeptimer_set_tz(sl_sleeptimer_time_zone_offset_t offset)
   1054          {
   1055            CORE_DECLARE_IRQ_STATE;
   1056          
   1057            CORE_ENTER_ATOMIC();
   1058            tz_offset = offset;
   1059            CORE_EXIT_ATOMIC();
   1060          }
   1061          
   1062          /***************************************************************************//**
   1063           * Gets time zone offset.
   1064           *
   1065           * @return Time zone offset, in seconds.
   1066           ******************************************************************************/
   1067          sl_sleeptimer_time_zone_offset_t sl_sleeptimer_get_tz(void)
   1068          {
   1069            sl_sleeptimer_time_zone_offset_t offset;
   1070            CORE_DECLARE_IRQ_STATE;
   1071          
   1072            CORE_ENTER_ATOMIC();
   1073            offset = tz_offset;
   1074            CORE_EXIT_ATOMIC();
   1075          
   1076            return offset;
   1077          }
   1078          
   1079          /***************************************************************************//**
   1080           * Converts Unix 32 timestamp into NTP timestamp.
   1081           ******************************************************************************/
   1082          sl_status_t sl_sleeptimer_convert_unix_time_to_ntp(sl_sleeptimer_timestamp_t time,
   1083                                                             uint32_t *ntp_time)
   1084          {
   1085            if (time > TIME_UNIX_TO_NTP_MAX) {
   1086              // Maximum Unix timestamp that can be converted to NTP is 2085978495
   1087              return SL_STATUS_INVALID_PARAMETER;
   1088            }
   1089          
   1090            uint32_t temp_ntp_time;
   1091            temp_ntp_time = time + TIME_NTP_EPOCH_OFFSET_SEC;
   1092            if (!is_valid_time(temp_ntp_time, TIME_FORMAT_NTP, 0u)) {
   1093              return SL_STATUS_INVALID_PARAMETER;
   1094            } else {
   1095              *ntp_time = temp_ntp_time;
   1096              return SL_STATUS_OK;
   1097            }
   1098          }
   1099          
   1100          /***************************************************************************//**
   1101           * Converts NTP timestamp into Unix timestamp.
   1102           ******************************************************************************/
   1103          sl_status_t sl_sleeptimer_convert_ntp_time_to_unix(uint32_t ntp_time,
   1104                                                             sl_sleeptimer_timestamp_t *time)
   1105          {
   1106            uint32_t temp_time;
   1107            temp_time = ntp_time - TIME_NTP_EPOCH_OFFSET_SEC;
   1108            if (!is_valid_time(temp_time, TIME_FORMAT_UNIX, 0u)) {
   1109              return SL_STATUS_INVALID_PARAMETER;
   1110            } else {
   1111              *time = temp_time;
   1112              return SL_STATUS_OK;
   1113            }
   1114          }
   1115          
   1116          /***************************************************************************//**
   1117           * Converts Unix timestamp into Zigbee timestamp.
   1118           ******************************************************************************/
   1119          sl_status_t sl_sleeptimer_convert_unix_time_to_zigbee(sl_sleeptimer_timestamp_t time,
   1120                                                                uint32_t *zigbee_time)
   1121          {
   1122            uint32_t temp_zigbee_time;
   1123            temp_zigbee_time = time - TIME_ZIGBEE_EPOCH_OFFSET_SEC;
   1124            if (!is_valid_time(temp_zigbee_time, TIME_FORMAT_ZIGBEE_CLUSTER, 0u)) {
   1125              return SL_STATUS_INVALID_PARAMETER;
   1126            } else {
   1127              *zigbee_time = temp_zigbee_time;
   1128              return SL_STATUS_OK;
   1129            }
   1130          }
   1131          
   1132          /***************************************************************************//**
   1133           * Converts Zigbee timestamp into Unix timestamp.
   1134           ******************************************************************************/
   1135          sl_status_t sl_sleeptimer_convert_zigbee_time_to_unix(uint32_t zigbee_time,
   1136                                                                sl_sleeptimer_timestamp_t *time)
   1137          {
   1138            uint32_t temp_time;
   1139            temp_time = zigbee_time + TIME_ZIGBEE_EPOCH_OFFSET_SEC;
   1140            if (!is_valid_time(temp_time, TIME_FORMAT_UNIX, 0u)) {
   1141              return SL_STATUS_INVALID_PARAMETER;
   1142            } else {
   1143              *time = temp_time;
   1144              return SL_STATUS_OK;
   1145            }
   1146          }
   1147          
   1148          #endif // SL_SLEEPTIMER_WALLCLOCK_CONFIG
   1149          
   1150          /*******************************************************************************
   1151           * Active delay of 'time_ms' milliseconds.
   1152           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1153          void sl_sleeptimer_delay_millisecond(uint16_t time_ms)
   1154          {
   \                     sl_sleeptimer_delay_millisecond: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0xB08B             SUB      SP,SP,#+44
   1155            volatile bool wait = true;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1156            sl_status_t error_code;
   1157            sl_sleeptimer_timer_handle_t delay_timer;
   1158            uint32_t delay = sl_sleeptimer_ms_to_tick(time_ms);
   1159          
   1160            error_code = sl_sleeptimer_start_timer(&delay_timer,
   1161                                                   delay,
   1162                                                   delay_callback,
   1163                                                   (void *)&wait,
   1164                                                   0,
   1165                                                   0);
   1166            if (error_code == SL_STATUS_OK) {
   \        0xC   0x2700             MOVS     R7,#+0
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x9701             STR      R7,[SP, #+4]
   \       0x12   0x9100             STR      R1,[SP, #+0]
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x18   0x6887             LDR      R7,[R0, #+8]
   \       0x1A   0xF240 0x30E7      MOVW     R0,#+999
   \       0x1E   0xF44F 0x727A      MOV      R2,#+1000
   \       0x22   0xFBE7 0x0106      UMLAL    R0,R1,R7,R6
   \       0x26   0x2300             MOVS     R3,#+0
   \       0x28   0xAD02             ADD      R5,SP,#+8
   \       0x2A   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x2E   0x.... 0x....      ADR.W    R4,delay_callback
   \       0x32   0x4601             MOV      R1,R0
   \       0x34   0x462B             MOV      R3,R5
   \       0x36   0x4622             MOV      R2,R4
   \       0x38   0xA803             ADD      R0,SP,#+12
   \       0x3A   0x.... 0x....      BL       sl_sleeptimer_start_timer
   \       0x3E   0xB918             CBNZ.N   R0,??sl_sleeptimer_delay_millisecond_0
   1167              while (wait) { // Active delay loop.
   \                     ??sl_sleeptimer_delay_millisecond_1: (+1)
   \       0x40   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD1FB             BNE.N    ??sl_sleeptimer_delay_millisecond_1
   1168              }
   1169            }
   1170          }
   \                     ??sl_sleeptimer_delay_millisecond_0: (+1)
   \       0x48   0xB00B             ADD      SP,SP,#+44
   \       0x4A   0xBDF0             POP      {R4-R7,PC}
   1171          
   1172          /*******************************************************************************
   1173           * Converts milliseconds in ticks.
   1174           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1175          uint32_t sl_sleeptimer_ms_to_tick(uint16_t time_ms)
   1176          {
   \                     sl_sleeptimer_ms_to_tick: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1177            return (uint32_t)((((uint64_t)time_ms * timer_frequency) + 999) / 1000);
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable22
   \        0x6   0x689C             LDR      R4,[R3, #+8]
   \        0x8   0x4602             MOV      R2,R0
   \        0xA   0xF240 0x30E7      MOVW     R0,#+999
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0xFBE4 0x0102      UMLAL    R0,R1,R4,R2
   \       0x14   0xF44F 0x727A      MOV      R2,#+1000
   \       0x18   0x2300             MOVS     R3,#+0
   \       0x1A   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1E   0x.... 0x....      B.W      __aeabi_uldivmod
   1178          }
   1179          
   1180          /*******************************************************************************
   1181           * Converts 32-bits milliseconds in ticks.
   1182           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1183          sl_status_t sl_sleeptimer_ms32_to_tick(uint32_t time_ms,
   1184                                                 uint32_t *tick)
   1185          {
   \                     sl_sleeptimer_ms32_to_tick: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4602             MOV      R2,R0
   1186            if (time_ms <= max_millisecond_conversion) {
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable22
   \        0xA   0x6948             LDR      R0,[R1, #+20]
   \        0xC   0x4290             CMP      R0,R2
   \        0xE   0xD30D             BCC.N    ??sl_sleeptimer_ms32_to_tick_0
   1187              *tick = (uint32_t)((((uint64_t)time_ms * timer_frequency) + 999) / 1000u);
   \       0x10   0x688D             LDR      R5,[R1, #+8]
   \       0x12   0xF240 0x30E7      MOVW     R0,#+999
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0xFBE5 0x0102      UMLAL    R0,R1,R5,R2
   \       0x1C   0xF44F 0x727A      MOV      R2,#+1000
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x26   0x6020             STR      R0,[R4, #+0]
   1188              return SL_STATUS_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD30             POP      {R4,R5,PC}
   1189            } else {
   1190              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_sleeptimer_ms32_to_tick_0: (+1)
   \       0x2C   0x2021             MOVS     R0,#+33
   \       0x2E   0xBD30             POP      {R4,R5,PC}
   1191            }
   1192          }
   1193          
   1194          /***************************************************************************//**
   1195           * Gets the maximum value that can be passed to the functions that have a
   1196           * 32-bits time or timeout argument expressed in milliseconds.
   1197           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1198          uint32_t sl_sleeptimer_get_max_ms32_conversion(void)
   1199          {
   1200            return max_millisecond_conversion;
   \                     sl_sleeptimer_get_max_ms32_conversion: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable22
   \        0x4   0x6940             LDR      R0,[R0, #+20]
   \        0x6   0x4770             BX       LR
   1201          }
   1202          
   1203          /*******************************************************************************
   1204           * Converts ticks in milliseconds.
   1205           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1206          uint32_t sl_sleeptimer_tick_to_ms(uint32_t tick)
   1207          {
   \                     sl_sleeptimer_tick_to_ms: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1208            uint32_t time_ms;
   1209            time_ms = 0;
   1210          
   1211            if (timer_frequency != 0u) {
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable22
   \        0x6   0x6896             LDR      R6,[R2, #+8]
   \        0x8   0x4601             MOV      R1,R0
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xB1CE             CBZ.N    R6,??sl_sleeptimer_tick_to_ms_0
   1212              if (is_power_of_2(timer_frequency)) {
   \        0xE   0xF44F 0x707A      MOV      R0,#+1000
   \       0x12   0xFBA0 0x4501      UMULL    R4,R5,R0,R1
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x.... 0x....      BL       is_power_of_2
   \       0x1C   0xB148             CBZ.N    R0,??sl_sleeptimer_tick_to_ms_1
   1213                time_ms = (uint32_t)(((uint64_t)tick * (uint64_t)1000u) >> div_to_log2(timer_frequency));
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       div_to_log2
   \       0x24   0x4602             MOV      R2,R0
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x4629             MOV      R1,R5
   \       0x2A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x2E   0x.... 0x....      B.W      __aeabi_llsr
   1214              } else {
   1215                time_ms = (uint32_t)(((uint64_t)tick * (uint64_t)1000u) / timer_frequency);
   \                     ??sl_sleeptimer_tick_to_ms_1: (+1)
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0x4632             MOV      R2,R6
   \       0x38   0x2300             MOVS     R3,#+0
   \       0x3A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x3E   0x.... 0x....      B.W      __aeabi_uldivmod
   1216              }
   1217            }
   1218          
   1219            return time_ms;
   \                     ??sl_sleeptimer_tick_to_ms_0: (+1)
   \       0x42   0xBD70             POP      {R4-R6,PC}
   1220          }
   1221          
   1222          /*******************************************************************************
   1223           * Converts 64-bits ticks in milliseconds.
   1224           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1225          sl_status_t sl_sleeptimer_tick64_to_ms(uint64_t tick,
   1226                                                 uint64_t *ms)
   1227          
   1228          {
   \                     sl_sleeptimer_tick64_to_ms: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1229            if ((tick <= UINT64_MAX / 1000)
   1230                && (timer_frequency != 0u)) {
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable22_2
   \        0x8   0x.... 0x....      LDR.W    R4,??DataTable22_3
   \        0xC   0x42A9             CMP      R1,R5
   \        0xE   0xD824             BHI.N    ??sl_sleeptimer_tick64_to_ms_0
   \       0x10   0xBF28             IT       CS
   \       0x12   0x42A0             CMPCS    R0,R4
   \       0x14   0xD221             BCS.N    ??sl_sleeptimer_tick64_to_ms_0
   \       0x16   0x.... 0x....      LDR.W    R3,??DataTable22
   \       0x1A   0x689F             LDR      R7,[R3, #+8]
   \       0x1C   0xB1EF             CBZ.N    R7,??sl_sleeptimer_tick64_to_ms_0
   1231              if (is_power_of_2(timer_frequency)) {
   \       0x1E   0xF44F 0x787A      MOV      R8,#+1000
   \       0x22   0xFBA8 0x4500      UMULL    R4,R5,R8,R0
   \       0x26   0x4616             MOV      R6,R2
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0xFB08 0x5501      MLA      R5,R8,R1,R5
   \       0x2E   0x.... 0x....      BL       is_power_of_2
   \       0x32   0xB140             CBZ.N    R0,??sl_sleeptimer_tick64_to_ms_1
   1232                *ms =  (uint64_t)(((uint64_t)tick * (uint64_t)1000u) >> div_to_log2(timer_frequency));
   \       0x34   0x4638             MOV      R0,R7
   \       0x36   0x.... 0x....      BL       div_to_log2
   \       0x3A   0x4602             MOV      R2,R0
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x4629             MOV      R1,R5
   \       0x40   0x.... 0x....      BL       __aeabi_llsr
   \       0x44   0xE005             B.N      ??sl_sleeptimer_tick64_to_ms_2
   1233                return SL_STATUS_OK;
   1234              } else {
   1235                *ms = (uint64_t)(((uint64_t)tick * (uint64_t)1000u) / timer_frequency);
   \                     ??sl_sleeptimer_tick64_to_ms_1: (+1)
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x4629             MOV      R1,R5
   \       0x4A   0x463A             MOV      R2,R7
   \       0x4C   0x2300             MOVS     R3,#+0
   \       0x4E   0x.... 0x....      BL       __aeabi_uldivmod
   \                     ??sl_sleeptimer_tick64_to_ms_2: (+1)
   \       0x52   0xE9C6 0x0100      STRD     R0,R1,[R6, #+0]
   1236                return SL_STATUS_OK;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xE000             B.N      ??sl_sleeptimer_tick64_to_ms_3
   1237              }
   1238            } else {
   1239              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_sleeptimer_tick64_to_ms_0: (+1)
   \       0x5A   0x2021             MOVS     R0,#+33
   \                     ??sl_sleeptimer_tick64_to_ms_3: (+1)
   \       0x5C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1240            }
   1241          }
   1242          
   1243          /*******************************************************************************
   1244           * Process timer interrupt.
   1245           *
   1246           * @param local_flag Flag indicating the type of timer interrupt.
   1247           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1248          void process_timer_irq(uint8_t local_flag)
   1249          {
   \                     process_timer_irq: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   1250            CORE_DECLARE_IRQ_STATE;
   1251            if (local_flag & SLEEPTIMER_EVENT_OF) {
   \        0x6   0x....             LDR.N    R5,??DataTable22
   \        0x8   0x07E1             LSLS     R1,R4,#+31
   \        0xA   0xD508             BPL.N    ??process_timer_irq_0
   1252          #if SL_SLEEPTIMER_WALLCLOCK_CONFIG
   1253              uint32_t timer_freq = sl_sleeptimer_get_timer_frequency();
   1254          
   1255              overflow_tick_rest += calculated_tick_rest;
   1256              if (overflow_tick_rest >= timer_freq) {
   1257                second_count++;
   1258                overflow_tick_rest -= timer_freq;
   1259              }
   1260              second_count = second_count + calculated_sec_count;
   1261          #endif
   1262              overflow_counter++;
   \        0xC   0x88A8             LDRH     R0,[R5, #+4]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \       0x10   0x80A8             STRH     R0,[R5, #+4]
   1263          
   1264              update_delta_list();
   \       0x12   0x.... 0x....      BL       update_delta_list
   1265          
   1266              if (timer_head) {
   \       0x16   0x68E8             LDR      R0,[R5, #+12]
   \       0x18   0xB108             CBZ.N    R0,??process_timer_irq_0
   1267                set_comparator_for_next_timer();
   \       0x1A   0x.... 0x....      BL       set_comparator_for_next_timer
   1268              }
   1269            }
   1270          
   1271            if (local_flag & SLEEPTIMER_EVENT_COMP) {
   \                     ??process_timer_irq_0: (+1)
   \       0x1E   0x07A0             LSLS     R0,R4,#+30
   \       0x20   0xF140 0x8086      BPL.W    ??process_timer_irq_1
   1272              sl_sleeptimer_timer_handle_t *current = NULL;
   1273          
   1274              uint32_t nb_timer_expire = 0u;
   1275              uint16_t option_flags = 0;
   1276          
   1277              CORE_ENTER_ATOMIC();
   \       0x24   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x28   0x4683             MOV      R11,R0
   \       0x2A   0x2600             MOVS     R6,#+0
   \       0x2C   0x2400             MOVS     R4,#+0
   1278              // Make sure the timers list is up to date with the time elapsed since the last update
   1279              update_delta_list();
   \       0x2E   0x.... 0x....      BL       update_delta_list
   \       0x32   0x.... 0x....      LDR.W    R10,??DataTable22_4
   \       0x36   0xE063             B.N      ??process_timer_irq_2
   1280          
   1281              // Process all timers that have expired.
   1282              while ((timer_head) && (timer_head->delta == 0)) {
   1283                sl_sleeptimer_timer_handle_t *temp = timer_head;
   1284                current = timer_head;
   1285                int32_t periodic_correction = 0u;
   1286                int64_t timeout_temp = 0;
   1287                bool skip_remove = false;
   1288          
   1289                // Process timers with higher priority first
   1290                while ((temp != NULL) && (temp->delta == 0)) {
   1291                  if (current->priority > temp->priority) {
   1292                    current = temp;
   1293                  }
   1294                  temp = temp->next;
   1295                }
   1296                CORE_EXIT_ATOMIC();
   1297          
   1298                // Check if current periodic timer was delayed more than its actual timeout value
   1299                // and keep it at the head of the timers list if it's the case so that the
   1300                // callback function can be called the number of required time.
   1301                if (current->timeout_periodic != 0u) {
   1302                  timeout_temp = current->timeout_periodic;
   1303          
   1304                  periodic_correction = sleeptimer_hal_get_counter() - current->timeout_expected_tc;
   1305                  if (periodic_correction > timeout_temp) {
   1306                    skip_remove = true;
   1307                    current->timeout_expected_tc += current->timeout_periodic;
   1308                  }
   1309                }
   1310          
   1311                // Remove current timer from timer list except if the current timer is a periodic timer
   1312                // that was intentionally kept at the head of the timers list.
   1313                if (skip_remove != true) {
   1314                  CORE_ENTER_ATOMIC();
   \                     ??process_timer_irq_3: (+1)
   \       0x38   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x3C   0x4683             MOV      R11,R0
   1315                  delta_list_remove_timer(current);
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x.... 0x....      BL       delta_list_remove_timer
   1316                  CORE_EXIT_ATOMIC();
   \       0x44   0x4658             MOV      R0,R11
   \       0x46   0x.... 0x....      BL       CORE_ExitAtomic
   1317                }
   1318          
   1319                // Re-insert periodic timer that was previsouly removed from the list
   1320                // and compensate for any deviation from the periodic timer frequency.
   1321                if (current->timeout_periodic != 0u && skip_remove != true) {
   \       0x4A   0x6938             LDR      R0,[R7, #+16]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD04B             BEQ.N    ??process_timer_irq_4
   1322                  timeout_temp -= periodic_correction;
   \       0x50   0xEBB4 0x0409      SUBS     R4,R4,R9
   \       0x54   0xEB78 0x78E9      SBCS     R8,R8,R9, ASR #+31
   1323                  EFM_ASSERT(timeout_temp >= 0);
   \       0x58   0xD504             BPL.N    ??process_timer_irq_5
   \       0x5A   0xF240 0x512B      MOVW     R1,#+1323
   \       0x5E   0x4650             MOV      R0,R10
   \       0x60   0x.... 0x....      BL       assertEFM
   1324                  // Compensate for drift caused by ms to ticks conversion
   1325                  if (current->conversion_error > 0) {
   \                     ??process_timer_irq_5: (+1)
   \       0x64   0x8BB8             LDRH     R0,[R7, #+28]
   \       0x66   0xB160             CBZ.N    R0,??process_timer_irq_6
   1326                    // Increment accumulated error by the ms to ticks conversion error
   1327                    current->accumulated_error += current->conversion_error;
   \       0x68   0x8BF9             LDRH     R1,[R7, #+30]
   \       0x6A   0x1840             ADDS     R0,R0,R1
   1328                    // If the accumulated error exceeds a tick, subtract that tick from the next
   1329                    // periodic timer's timeout value.
   1330                    if (current->accumulated_error >= 1000) {
   \       0x6C   0xB281             UXTH     R1,R0
   \       0x6E   0xF5B1 0x7F7A      CMP      R1,#+1000
   \       0x72   0xDB05             BLT.N    ??process_timer_irq_7
   1331                      current->accumulated_error -= 1000;
   1332                      timeout_temp -= 1;
   1333                      current->timeout_expected_tc -= 1;
   \       0x74   0x69B9             LDR      R1,[R7, #+24]
   \       0x76   0xF5A0 0x707A      SUB      R0,R0,#+1000
   \       0x7A   0x1E64             SUBS     R4,R4,#+1
   \       0x7C   0x1E49             SUBS     R1,R1,#+1
   \       0x7E   0x61B9             STR      R1,[R7, #+24]
   \                     ??process_timer_irq_7: (+1)
   \       0x80   0x83F8             STRH     R0,[R7, #+30]
   1334                    }
   1335                  }
   1336                  CORE_ENTER_ATOMIC();
   \                     ??process_timer_irq_6: (+1)
   \       0x82   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x86   0x4681             MOV      R9,R0
   1337                  delta_list_insert_timer(current, (sl_sleeptimer_tick_count_t)timeout_temp);
   \       0x88   0x4621             MOV      R1,R4
   \       0x8A   0x4638             MOV      R0,R7
   \       0x8C   0x.... 0x....      BL       delta_list_insert_timer
   1338                  current->timeout_expected_tc += current->timeout_periodic;
   \       0x90   0x69B9             LDR      R1,[R7, #+24]
   \       0x92   0x6938             LDR      R0,[R7, #+16]
   \       0x94   0x1841             ADDS     R1,R0,R1
   \       0x96   0x61B9             STR      R1,[R7, #+24]
   1339                  CORE_EXIT_ATOMIC();
   \       0x98   0x4648             MOV      R0,R9
   \       0x9A   0x.... 0x....      BL       CORE_ExitAtomic
   \       0x9E   0xE023             B.N      ??process_timer_irq_4
   1340                }
   \                     ??process_timer_irq_8: (+1)
   \       0xA0   0x2400             MOVS     R4,#+0
   \       0xA2   0x4638             MOV      R0,R7
   \       0xA4   0xF04F 0x0900      MOV      R9,#+0
   \       0xA8   0x46A0             MOV      R8,R4
   \                     ??process_timer_irq_9: (+1)
   \       0xAA   0x6941             LDR      R1,[R0, #+20]
   \       0xAC   0xB939             CBNZ.N   R1,??process_timer_irq_10
   \       0xAE   0x7902             LDRB     R2,[R0, #+4]
   \       0xB0   0x7939             LDRB     R1,[R7, #+4]
   \       0xB2   0x428A             CMP      R2,R1
   \       0xB4   0xBF38             IT       CC
   \       0xB6   0x4607             MOVCC    R7,R0
   \       0xB8   0x6880             LDR      R0,[R0, #+8]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD1F5             BNE.N    ??process_timer_irq_9
   \                     ??process_timer_irq_10: (+1)
   \       0xBE   0x4658             MOV      R0,R11
   \       0xC0   0x.... 0x....      BL       CORE_ExitAtomic
   \       0xC4   0x6938             LDR      R0,[R7, #+16]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD0B6             BEQ.N    ??process_timer_irq_3
   \       0xCA   0x4604             MOV      R4,R0
   \       0xCC   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0xD0   0x69BB             LDR      R3,[R7, #+24]
   \       0xD2   0xEBA0 0x0903      SUB      R9,R0,R3
   \       0xD6   0xEBB8 0x7FE9      CMP      R8,R9, ASR #+31
   \       0xDA   0xDCAD             BGT.N    ??process_timer_irq_3
   \       0xDC   0xDB01             BLT.N    ??process_timer_irq_11
   \       0xDE   0x454C             CMP      R4,R9
   \       0xE0   0xD2AA             BCS.N    ??process_timer_irq_3
   \                     ??process_timer_irq_11: (+1)
   \       0xE2   0x693A             LDR      R2,[R7, #+16]
   \       0xE4   0x18D3             ADDS     R3,R2,R3
   \       0xE6   0x61BB             STR      R3,[R7, #+24]
   1341          
   1342                // Save current option flag and the number of timers that expired.
   1343                option_flags = current->option_flags;
   1344                nb_timer_expire++;
   1345          
   1346                // Call current timer callback function if any.
   1347                if (current->callback != NULL) {
   \                     ??process_timer_irq_4: (+1)
   \       0xE8   0x68FA             LDR      R2,[R7, #+12]
   \       0xEA   0x88FC             LDRH     R4,[R7, #+6]
   \       0xEC   0x1C76             ADDS     R6,R6,#+1
   \       0xEE   0xB112             CBZ.N    R2,??process_timer_irq_12
   1348                  current->callback(current, current->callback_data);
   \       0xF0   0x6839             LDR      R1,[R7, #+0]
   \       0xF2   0x4638             MOV      R0,R7
   \       0xF4   0x4790             BLX      R2
   1349                }
   1350          
   1351                CORE_ENTER_ATOMIC();
   \                     ??process_timer_irq_12: (+1)
   \       0xF6   0x.... 0x....      BL       CORE_EnterAtomic
   \       0xFA   0x4683             MOV      R11,R0
   1352          
   1353                // Re-update the list to account for delays during timer's callback.
   1354                update_delta_list();
   \       0xFC   0x.... 0x....      BL       update_delta_list
   1355              }
   \                     ??process_timer_irq_2: (+1)
   \      0x100   0x68EF             LDR      R7,[R5, #+12]
   \      0x102   0xB117             CBZ.N    R7,??process_timer_irq_13
   \      0x104   0x6978             LDR      R0,[R7, #+20]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD0CA             BEQ.N    ??process_timer_irq_8
   1356          
   1357              // If the only timer expired is the internal Power Manager one,
   1358              // from the Sleeptimer perspective, the system can go back to sleep after the ISR handling.
   1359              sleep_on_isr_exit = false;
   \                     ??process_timer_irq_13: (+1)
   \      0x10A   0x2000             MOVS     R0,#+0
   1360              if (nb_timer_expire == 1u) {
   \      0x10C   0x2E01             CMP      R6,#+1
   \      0x10E   0xD102             BNE.N    ??process_timer_irq_14
   1361                if (option_flags & SLI_SLEEPTIMER_POWER_MANAGER_EARLY_WAKEUP_TIMER_FLAG) {
   \      0x110   0x07A1             LSLS     R1,R4,#+30
   \      0x112   0xBF48             IT       MI
   \      0x114   0x2001             MOVMI    R0,#+1
   1362                  sleep_on_isr_exit = true;
   \                     ??process_timer_irq_14: (+1)
   \      0x116   0x70A8             STRB     R0,[R5, #+2]
   1363                }
   1364              }
   1365          
   1366              if (timer_head) {
   \      0x118   0xB117             CBZ.N    R7,??process_timer_irq_15
   1367                set_comparator_for_next_timer();
   \      0x11A   0x.... 0x....      BL       set_comparator_for_next_timer
   \      0x11E   0xE002             B.N      ??process_timer_irq_16
   1368              } else {
   1369                sleeptimer_hal_disable_int(SLEEPTIMER_EVENT_COMP);
   \                     ??process_timer_irq_15: (+1)
   \      0x120   0x2002             MOVS     R0,#+2
   \      0x122   0x.... 0x....      BL       sleeptimer_hal_disable_int
   1370              }
   1371              CORE_EXIT_ATOMIC();
   \                     ??process_timer_irq_16: (+1)
   \      0x126   0x4658             MOV      R0,R11
   \      0x128   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \      0x12C   0x.... 0x....      B.W      CORE_ExitAtomic
   1372            }
   1373          }
   \                     ??process_timer_irq_1: (+1)
   \      0x130   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}
   1374          
   1375          /*******************************************************************************
   1376           * Timer expiration callback for the delay function.
   1377           *
   1378           * @param handle Pointer to handle to timer.
   1379           * @param data Pointer to delay flag.
   1380           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1381          static void delay_callback(sl_sleeptimer_timer_handle_t *handle,
   1382                                     void *data)
   1383          {
   1384            volatile bool *wait_flag = (bool *)data;
   1385          
   1386            (void)handle;  // Unused parameter.
   1387          
   1388            *wait_flag = false;
   \                     delay_callback: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   1389          }
   \        0x4   0x4770             BX       LR
   1390          
   1391          /*******************************************************************************
   1392           * Inserts a timer in the delta list.
   1393           *
   1394           * @param handle Pointer to handle to timer.
   1395           * @param timeout Timer timeout, in ticks.
   1396           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1397          static void delta_list_insert_timer(sl_sleeptimer_timer_handle_t *handle,
   1398                                              sl_sleeptimer_tick_count_t timeout)
   1399          {
   \                     delta_list_insert_timer: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x....             LDR.N    R7,??DataTable22
   \        0x4   0x68FD             LDR      R5,[R7, #+12]
   1400            sl_sleeptimer_tick_count_t local_handle_delta = timeout;
   1401          
   1402          #ifdef SL_CATALOG_POWER_MANAGER_PRESENT
   1403            // If Power Manager is present, it's possible that a clock restore is needed right away
   1404            // if we are in the context of a deepsleep and the timeout value is smaller than the restore time.
   1405            // If it's the case, the restore will be started and the timeout value will be updated to match
   1406            // the restore delay.
   1407            if (handle->option_flags == 0) {
   1408              uint32_t wakeup_delay = sli_power_manager_get_restore_delay();
   1409          
   1410              if (local_handle_delta < wakeup_delay) {
   1411                local_handle_delta = wakeup_delay;
   1412                sli_power_manager_initiate_restore();
   1413              }
   1414            }
   1415          #endif
   1416          
   1417            handle->delta = local_handle_delta;
   \        0x6   0x6141             STR      R1,[R0, #+20]
   1418          
   1419            if (timer_head != NULL) {
   \        0x8   0xB1E5             CBZ.N    R5,??delta_list_insert_timer_0
   1420              sl_sleeptimer_timer_handle_t *prev = NULL;
   \        0xA   0x2600             MOVS     R6,#+0
   1421              sl_sleeptimer_timer_handle_t *current = timer_head;
   \        0xC   0x462A             MOV      R2,R5
   \                     ??delta_list_insert_timer_1: (+1)
   \        0xE   0x6953             LDR      R3,[R2, #+20]
   \       0x10   0x4299             CMP      R1,R3
   \       0x12   0xD207             BCS.N    ??delta_list_insert_timer_2
   \       0x14   0xB133             CBZ.N    R3,??delta_list_insert_timer_2
   \       0x16   0x1ACC             SUBS     R4,R1,R3
   \       0x18   0xD10A             BNE.N    ??delta_list_insert_timer_3
   \       0x1A   0xF892 0xC004      LDRB     R12,[R2, #+4]
   \       0x1E   0x7904             LDRB     R4,[R0, #+4]
   \       0x20   0x45A4             CMP      R12,R4
   \       0x22   0xD205             BCS.N    ??delta_list_insert_timer_3
   1422              // Find timer position taking into accounts the deltas and priority.
   1423              while (current != NULL
   1424                     && (local_handle_delta >= current->delta || current->delta == 0u
   1425                         || (((local_handle_delta - current->delta) == 0) && (handle->priority > current->priority)))) {
   1426                local_handle_delta -= current->delta;
   \                     ??delta_list_insert_timer_2: (+1)
   \       0x24   0x1AC9             SUBS     R1,R1,R3
   1427                handle->delta = local_handle_delta;
   \       0x26   0x6141             STR      R1,[R0, #+20]
   1428                prev = current;
   \       0x28   0x4616             MOV      R6,R2
   1429                current = current->next;
   \       0x2A   0x6892             LDR      R2,[R2, #+8]
   1430              }
   \       0x2C   0x2A00             CMP      R2,#+0
   \       0x2E   0xD1EE             BNE.N    ??delta_list_insert_timer_1
   1431          
   1432              // Insert timer in middle of delta list.
   1433              if (prev != NULL) {
   \                     ??delta_list_insert_timer_3: (+1)
   \       0x30   0x2E00             CMP      R6,#+0
   \       0x32   0xBF14             ITE      NE
   \       0x34   0x60B0             STRNE    R0,[R6, #+8]
   \       0x36   0x4605             MOVEQ    R5,R0
   1434                prev->next = handle;
   1435              } else {
   1436                timer_head = handle;
   1437              }
   1438              handle->next = current;
   \       0x38   0x0014             MOVS     R4,R2
   1439          
   1440              if (current != NULL) {
   \       0x3A   0xD005             BEQ.N    ??delta_list_insert_timer_4
   1441                current->delta -= local_handle_delta;
   \       0x3C   0x6953             LDR      R3,[R2, #+20]
   \       0x3E   0x1A59             SUBS     R1,R3,R1
   \       0x40   0x6151             STR      R1,[R2, #+20]
   \       0x42   0xE001             B.N      ??delta_list_insert_timer_4
   1442              }
   1443            } else {
   1444              timer_head = handle;
   \                     ??delta_list_insert_timer_0: (+1)
   \       0x44   0x4605             MOV      R5,R0
   1445              handle->next = NULL;
   \       0x46   0x2400             MOVS     R4,#+0
   1446            }
   1447          }
   \                     ??delta_list_insert_timer_4: (+1)
   \       0x48   0x6084             STR      R4,[R0, #+8]
   \       0x4A   0x60FD             STR      R5,[R7, #+12]
   \       0x4C   0xBDF0             POP      {R4-R7,PC}
   1448          
   1449          /*******************************************************************************
   1450           * Removes a timer from delta list.
   1451           *
   1452           * @param handle Pointer to handle to timer.
   1453           *
   1454           * @return 0 if successful. Error code otherwise.
   1455           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1456          static sl_status_t delta_list_remove_timer(sl_sleeptimer_timer_handle_t *handle)
   1457          {
   1458            sl_sleeptimer_timer_handle_t *prev = NULL;
   1459            sl_sleeptimer_timer_handle_t *current = timer_head;
   \                     delta_list_remove_timer: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable22
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x68D9             LDR      R1,[R3, #+12]
   \        0x6   0xE001             B.N      ??delta_list_remove_timer_0
   1460          
   1461            // Retrieve timer in delta list.
   1462            while (current != NULL && current != handle) {
   1463              prev = current;
   \                     ??delta_list_remove_timer_1: (+1)
   \        0x8   0x460A             MOV      R2,R1
   1464              current = current->next;
   \        0xA   0x6889             LDR      R1,[R1, #+8]
   1465            }
   \                     ??delta_list_remove_timer_0: (+1)
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF18             IT       NE
   \       0x10   0x4281             CMPNE    R1,R0
   \       0x12   0xD1F9             BNE.N    ??delta_list_remove_timer_1
   1466          
   1467            if (current != handle) {
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD001             BEQ.N    ??delta_list_remove_timer_2
   1468              return SL_STATUS_INVALID_STATE;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x4770             BX       LR
   1469            }
   1470          
   1471            if (prev != NULL) {
   \                     ??delta_list_remove_timer_2: (+1)
   \       0x1C   0x6881             LDR      R1,[R0, #+8]
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xBF14             ITE      NE
   \       0x22   0x6091             STRNE    R1,[R2, #+8]
   \       0x24   0x60D9             STREQ    R1,[R3, #+12]
   1472              prev->next = handle->next;
   1473            } else {
   1474              timer_head = handle->next;
   1475            }
   1476          
   1477            // Update delta of next timer
   1478            if (handle->next != NULL) {
   \       0x26   0x6881             LDR      R1,[R0, #+8]
   \       0x28   0xB119             CBZ.N    R1,??delta_list_remove_timer_3
   1479              handle->next->delta += handle->delta;
   \       0x2A   0x694A             LDR      R2,[R1, #+20]
   \       0x2C   0x6940             LDR      R0,[R0, #+20]
   \       0x2E   0x1882             ADDS     R2,R0,R2
   \       0x30   0x614A             STR      R2,[R1, #+20]
   1480            }
   1481          
   1482            return SL_STATUS_OK;
   \                     ??delta_list_remove_timer_3: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x4770             BX       LR
   1483          }
   1484          
   1485          /*******************************************************************************
   1486           * Sets comparator for next timer.
   1487           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1488          static void set_comparator_for_next_timer(void)
   1489          {
   \                     set_comparator_for_next_timer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1490            if (timer_head->delta > 0) {
   \        0x2   0x....             LDR.N    R5,??DataTable22
   \        0x4   0x68E8             LDR      R0,[R5, #+12]
   \        0x6   0x6944             LDR      R4,[R0, #+20]
   \        0x8   0xB144             CBZ.N    R4,??set_comparator_for_next_timer_0
   1491              sl_sleeptimer_tick_count_t compare_value;
   1492          
   1493              compare_value = last_delta_update_count + timer_head->delta;
   \        0xA   0x6929             LDR      R1,[R5, #+16]
   1494          
   1495              sleeptimer_hal_enable_int(SLEEPTIMER_EVENT_COMP);
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0x1864             ADDS     R4,R4,R1
   \       0x10   0x.... 0x....      BL       sleeptimer_hal_enable_int
   1496              sleeptimer_hal_set_compare(compare_value);
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       sleeptimer_hal_set_compare
   \       0x1A   0xE005             B.N      ??set_comparator_for_next_timer_1
   1497            } else {
   1498              // In case timer has already expire, don't attempt to set comparator. Just
   1499              // trigger compare match interrupt.
   1500              sleeptimer_hal_enable_int(SLEEPTIMER_EVENT_COMP);
   \                     ??set_comparator_for_next_timer_0: (+1)
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x.... 0x....      BL       sleeptimer_hal_enable_int
   1501              sleeptimer_hal_set_int(SLEEPTIMER_EVENT_COMP);
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x.... 0x....      BL       sleeptimer_hal_set_int
   1502            }
   1503          
   1504            update_next_timer_to_expire_is_power_manager();
   \                     ??set_comparator_for_next_timer_1: (+1)
   \       0x28   0x68E8             LDR      R0,[R5, #+12]
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x2200             MOVS     R2,#+0
   \                     ??set_comparator_for_next_timer_2: (+1)
   \       0x2E   0x7984             LDRB     R4,[R0, #+6]
   \       0x30   0x07A3             LSLS     R3,R4,#+30
   \       0x32   0xD406             BMI.N    ??set_comparator_for_next_timer_3
   \       0x34   0x6880             LDR      R0,[R0, #+8]
   \       0x36   0xB128             CBZ.N    R0,??set_comparator_for_next_timer_4
   \       0x38   0x6943             LDR      R3,[R0, #+20]
   \       0x3A   0x1859             ADDS     R1,R3,R1
   \       0x3C   0x2902             CMP      R1,#+2
   \       0x3E   0xD3F6             BCC.N    ??set_comparator_for_next_timer_2
   \       0x40   0xE000             B.N      ??set_comparator_for_next_timer_4
   \                     ??set_comparator_for_next_timer_3: (+1)
   \       0x42   0x2201             MOVS     R2,#+1
   1505          }
   \                     ??set_comparator_for_next_timer_4: (+1)
   \       0x44   0x706A             STRB     R2,[R5, #+1]
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}
   1506          
   1507          /*******************************************************************************
   1508           * Updates timer list's deltas.
   1509           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1510          static void update_delta_list(void)
   1511          {
   \                     update_delta_list: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1512            sl_sleeptimer_tick_count_t current_cnt = sleeptimer_hal_get_counter();
   \        0x2   0x.... 0x....      BL       sleeptimer_hal_get_counter
   1513            sl_sleeptimer_timer_handle_t *timer_handle = timer_head;
   \        0x6   0x....             LDR.N    R3,??DataTable22
   \        0x8   0x68D9             LDR      R1,[R3, #+12]
   1514            sl_sleeptimer_tick_count_t time_diff = current_cnt - last_delta_update_count;
   \        0xA   0x691A             LDR      R2,[R3, #+16]
   \        0xC   0x1A82             SUBS     R2,R0,R2
   \        0xE   0xE008             B.N      ??update_delta_list_0
   1515          
   1516            // Go through the delta timer list and update every necessary deltas
   1517            // according to the time elapsed since the last update.
   1518            while (timer_handle != NULL && time_diff > 0) {
   1519              if (timer_handle->delta >= time_diff) {
   \                     ??update_delta_list_1: (+1)
   \       0x10   0x694C             LDR      R4,[R1, #+20]
   \       0x12   0x4294             CMP      R4,R2
   \       0x14   0xBF39             ITTEE    CC
   \       0x16   0x1B12             SUBCC    R2,R2,R4
   \       0x18   0x2400             MOVCC    R4,#+0
   \       0x1A   0x1AA4             SUBCS    R4,R4,R2
   \       0x1C   0x2200             MOVCS    R2,#+0
   1520                timer_handle->delta -= time_diff;
   1521                time_diff = 0;
   1522              } else {
   1523                time_diff -= timer_handle->delta;
   1524                timer_handle->delta = 0;
   \       0x1E   0x614C             STR      R4,[R1, #+20]
   1525              }
   1526              timer_handle = timer_handle->next;
   \       0x20   0x6889             LDR      R1,[R1, #+8]
   1527            }
   \                     ??update_delta_list_0: (+1)
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2A00             CMPNE    R2,#+0
   \       0x28   0xD1F2             BNE.N    ??update_delta_list_1
   1528          
   1529            last_delta_update_count = current_cnt;
   \       0x2A   0x6118             STR      R0,[R3, #+16]
   1530          }
   \       0x2C   0xBD10             POP      {R4,PC}
   1531          
   1532          /*******************************************************************************
   1533           * Creates and start a 32 bits timer.
   1534           *
   1535           * @param handle Pointer to handle to timer.
   1536           * @param timeout_initial Initial timeout, in timer ticks.
   1537           * @param timeout_periodic Periodic timeout, in timer ticks. This timeout
   1538           *        applies once timeoutInitial expires. Can be set to 0 for a one
   1539           *        shot timer.
   1540           * @param callback Callback function that will be called when
   1541           *        initial/periodic timeout expires.
   1542           * @param callback_data Pointer to user data that will be passed to callback.
   1543           * @param priority Priority of callback. Useful in case multiple timer expire
   1544           *        at the same time. 0 = highest priority.
   1545           *
   1546           * @return 0 if successful. Error code otherwise.
   1547           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1548          static sl_status_t create_timer(sl_sleeptimer_timer_handle_t *handle,
   1549                                          sl_sleeptimer_tick_count_t timeout_initial,
   1550                                          sl_sleeptimer_tick_count_t timeout_periodic,
   1551                                          sl_sleeptimer_timer_callback_t callback,
   1552                                          void *callback_data,
   1553                                          uint8_t priority,
   1554                                          uint16_t option_flags)
   1555          {
   \                     create_timer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x9805             LDR      R0,[SP, #+20]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x9A04             LDR      R2,[SP, #+16]
   \        0xC   0x9906             LDR      R1,[SP, #+24]
   1556            CORE_DECLARE_IRQ_STATE;
   1557          
   1558            handle->priority = priority;
   \        0xE   0x7130             STRB     R0,[R6, #+4]
   1559            handle->callback_data = callback_data;
   \       0x10   0x6032             STR      R2,[R6, #+0]
   1560            handle->next = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x60B0             STR      R0,[R6, #+8]
   1561            handle->timeout_periodic = timeout_periodic;
   \       0x16   0x6134             STR      R4,[R6, #+16]
   1562            handle->callback = callback;
   \       0x18   0x60F3             STR      R3,[R6, #+12]
   1563            handle->option_flags = option_flags;
   \       0x1A   0x80F1             STRH     R1,[R6, #+6]
   1564            if (timeout_periodic == 0) {
   \       0x1C   0xB91C             CBNZ.N   R4,??create_timer_0
   1565              handle->timeout_expected_tc = sleeptimer_hal_get_counter() + timeout_initial;
   \       0x1E   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x22   0x1828             ADDS     R0,R5,R0
   \       0x24   0xE002             B.N      ??create_timer_1
   1566            } else {
   1567              handle->timeout_expected_tc = sleeptimer_hal_get_counter() + timeout_periodic;
   \                     ??create_timer_0: (+1)
   \       0x26   0x.... 0x....      BL       sleeptimer_hal_get_counter
   \       0x2A   0x1820             ADDS     R0,R4,R0
   \                     ??create_timer_1: (+1)
   \       0x2C   0x61B0             STR      R0,[R6, #+24]
   1568            }
   1569          
   1570            if (timeout_initial == 0) {
   \       0x2E   0xB945             CBNZ.N   R5,??create_timer_2
   1571              handle->delta = 0;
   1572              if (handle->callback != NULL) {
   \       0x30   0x68F2             LDR      R2,[R6, #+12]
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6170             STR      R0,[R6, #+20]
   \       0x36   0xB112             CBZ.N    R2,??create_timer_3
   1573                handle->callback(handle, handle->callback_data);
   \       0x38   0x6831             LDR      R1,[R6, #+0]
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0x4790             BLX      R2
   1574              }
   1575              if (timeout_periodic != 0) {
   \                     ??create_timer_3: (+1)
   \       0x3E   0xB194             CBZ.N    R4,??create_timer_4
   1576                timeout_initial = timeout_periodic;
   \       0x40   0x4625             MOV      R5,R4
   1577              } else {
   1578                return SL_STATUS_OK;
   1579              }
   1580            }
   1581          
   1582          #if ((SL_SLEEPTIMER_PERIPHERAL == SL_SLEEPTIMER_PERIPHERAL_SYSRTC) \
   1583            && defined(SL_CATALOG_POWER_MANAGER_PRESENT)                     \
   1584            && !defined(SL_CATALOG_POWER_MANAGER_NO_DEEPSLEEP_PRESENT))
   1585            if (option_flags == (SLI_SLEEPTIMER_POWER_MANAGER_EARLY_WAKEUP_TIMER_FLAG | SLI_SLEEPTIMER_POWER_MANAGER_HF_ACCURACY_CLK_FLAG)) {
   1586              HFXO0->CTRL |= HFXO_CTRL_EM23ONDEMAND;
   1587              sleeptimer_hal_set_compare_prs_hfxo_startup(timeout_initial);
   1588              return SL_STATUS_OK;
   1589            }
   1590          #endif
   1591          
   1592            CORE_ENTER_CRITICAL();
   \                     ??create_timer_2: (+1)
   \       0x42   0x.... 0x....      BL       CORE_EnterCritical
   \       0x46   0x4604             MOV      R4,R0
   1593            update_delta_list();
   \       0x48   0x.... 0x....      BL       update_delta_list
   1594            delta_list_insert_timer(handle, timeout_initial);
   \       0x4C   0x4629             MOV      R1,R5
   \       0x4E   0x4630             MOV      R0,R6
   \       0x50   0x.... 0x....      BL       delta_list_insert_timer
   1595          
   1596            // If first timer, update timer comparator.
   1597            if (timer_head == handle) {
   \       0x54   0x....             LDR.N    R1,??DataTable22
   \       0x56   0x68C8             LDR      R0,[R1, #+12]
   \       0x58   0x42B0             CMP      R0,R6
   \       0x5A   0xBF08             IT       EQ
   1598              set_comparator_for_next_timer();
   \       0x5C   0x.... 0x....      BLEQ     set_comparator_for_next_timer
   1599            }
   1600          
   1601            CORE_EXIT_CRITICAL();
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0x.... 0x....      BL       CORE_ExitCritical
   1602          
   1603            return SL_STATUS_OK;
   \                     ??create_timer_4: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xBD70             POP      {R4-R6,PC}
   1604          }
   1605          
   1606          /*******************************************************************************
   1607           * Updates internal flag that indicates if next timer to expire is the power
   1608           * manager's one.
   1609           ******************************************************************************/
   1610          static void update_next_timer_to_expire_is_power_manager(void)
   1611          {
   1612            sl_sleeptimer_timer_handle_t *current = timer_head;
   1613            uint32_t delta_diff_with_first = 0;
   1614          
   1615            next_timer_to_expire_is_power_manager = false;
   1616          
   1617            while (delta_diff_with_first <= 1) {
   1618              if (current->option_flags & SLI_SLEEPTIMER_POWER_MANAGER_EARLY_WAKEUP_TIMER_FLAG) {
   1619                next_timer_to_expire_is_power_manager = true;
   1620                break;
   1621              }
   1622          
   1623              current = current->next;
   1624              if (current == NULL) {
   1625                break;
   1626              }
   1627          
   1628              delta_diff_with_first += current->delta;
   1629            }
   1630          }
   1631          
   1632          /**************************************************************************//**
   1633           * Determines if the power manager's early wakeup expired during the last ISR
   1634           * and it was the only timer to expire in that period.
   1635           *
   1636           * @return true if power manager sleep can return to sleep,
   1637           *         false otherwise.
   1638           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1639          bool sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire(void)
   1640          {
   \                     sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1641            CORE_DECLARE_IRQ_STATE;
   1642            bool sleep;
   1643          
   1644            CORE_ENTER_ATOMIC();
   \        0x2   0x.... 0x....      BL       CORE_EnterAtomic
   1645            sleep = sleep_on_isr_exit;
   \        0x6   0x....             LDR.N    R1,??DataTable22
   \        0x8   0x788C             LDRB     R4,[R1, #+2]
   1646            CORE_EXIT_ATOMIC();
   \        0xA   0x.... 0x....      BL       CORE_ExitAtomic
   1647          
   1648            return sleep;
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0xBD10             POP      {R4,PC}
   1649          }
   1650          
   1651          /*******************************************************************************
   1652           * Convert dividend to logarithmic value. It only works for even
   1653           * numbers equal to 2^n.
   1654           *
   1655           * @param  div An unscaled dividend.
   1656           *
   1657           * @return Logarithm of 2.
   1658           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1659          __STATIC_INLINE uint32_t div_to_log2(uint32_t div)
   1660          {
   1661            return 31UL - __CLZ(div);  // Count leading zeroes and "reverse" result.
   \                     div_to_log2: (+1)
   \        0x0   0xFAB0 0xF080      CLZ      R0,R0
   \        0x4   0xF1C0 0x001F      RSB      R0,R0,#+31
   \        0x8   0x4770             BX       LR
   1662          }
   1663          
   1664          /*******************************************************************************
   1665           * Determines if a number is a power of two.
   1666           *
   1667           * @param  nbr Input value.
   1668           *
   1669           * @return True if the number is a power of two.
   1670           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1671          __STATIC_INLINE bool is_power_of_2(uint32_t nbr)
   1672          {
   1673            if ((((nbr) != 0u) && (((nbr) & ((nbr) - 1u)) == 0u))) {
   \                     is_power_of_2: (+1)
   \        0x0   0xB120             CBZ.N    R0,??is_power_of_2_0
   \        0x2   0x1E41             SUBS     R1,R0,#+1
   \        0x4   0x4208             TST      R0,R1
   \        0x6   0xD101             BNE.N    ??is_power_of_2_0
   1674              return true;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   1675            } else {
   1676              return false;
   \                     ??is_power_of_2_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   1677            }
   1678          }
   1679          
   1680          #if SL_SLEEPTIMER_WALLCLOCK_CONFIG
   1681          /*******************************************************************************
   1682           * Compute the day of the week.
   1683           *
   1684           * @param day Days since January 1st of 1970.
   1685           *
   1686           * @return the day of the week.
   1687           ******************************************************************************/
   1688          static sl_sleeptimer_weekDay_t compute_day_of_week(uint32_t day)
   1689          {
   1690            return (sl_sleeptimer_weekDay_t)((day + 4) % 7); // January 1st was a Thursday(4) in 1970
   1691          }
   1692          
   1693          /*******************************************************************************
   1694           * Compute the day of the week.
   1695           *
   1696           * @param day Days since January 1st of 1900.
   1697           *
   1698           * @return the day of the week.
   1699           ******************************************************************************/
   1700          static sl_sleeptimer_weekDay_t compute_day_of_week_64(uint64_t day)
   1701          {
   1702            return (sl_sleeptimer_weekDay_t)((day + 1) % 7);  // January 1st was a Monday(1) in 1900
   1703          }
   1704          
   1705          /*******************************************************************************
   1706           * Compute the day of the year. This function assumes that the inputs are properly
   1707           * sanitized.
   1708           *
   1709           * @param month Number of months since January.
   1710           * @param day Day of the month
   1711           * @param is_leap_year Specifies if the year computed against is a leap year.
   1712           *
   1713           * @return the number of days since the beginning of the year
   1714           ******************************************************************************/
   1715          static uint16_t compute_day_of_year(sl_sleeptimer_month_t month, uint8_t day, bool is_leap_year)
   1716          {
   1717            uint8_t i;
   1718            uint16_t dayOfYear = 0;
   1719          
   1720            for (i = 0; i < month; ++i) {
   1721              dayOfYear += days_in_month[is_leap_year][i];
   1722            }
   1723            dayOfYear += day;
   1724          
   1725            return dayOfYear;
   1726          }
   1727          
   1728          /*******************************************************************************
   1729           * Checks if the year is a leap year.
   1730           *
   1731           * @param year Year to check.
   1732           *
   1733           * @return true if the year is a leap year. False otherwise.
   1734           ******************************************************************************/
   1735          static bool is_leap_year(uint16_t year)
   1736          {
   1737            // 1900 is not a leap year but 0 % anything is 0.
   1738            if (year == 0) {
   1739              return false;
   1740            }
   1741          
   1742            bool leap_year;
   1743          
   1744            leap_year = (((year %   4u) == 0u)
   1745                         && (((year % 100u) != 0u) || ((year % 400u) == 0u))) ? true : false;
   1746          
   1747            return (leap_year);
   1748          }
   1749          
   1750          /*******************************************************************************
   1751           * Checks if the time stamp, format and time zone are
   1752           *  within the supported range.
   1753           *
   1754           * @param base_year Year to start from to compute leap days.
   1755           * @param current_year Year end at for computing leap days.
   1756           *
   1757           * @return leap_days Days number of leap days between base_year and current_year.
   1758           ******************************************************************************/
   1759          static uint16_t number_of_leap_days(uint32_t base_year, uint32_t current_year)
   1760          {
   1761            // Regular leap years
   1762            uint16_t lo_reg = (base_year - 0) / 4;
   1763            uint16_t hi_reg = (current_year - 1) / 4;
   1764            uint16_t leap_days = hi_reg - lo_reg;
   1765          
   1766            // Account for non leap years
   1767            uint16_t lo_century = (base_year - 0) / 100;
   1768            uint16_t hi_century = (current_year - 1) / 100;
   1769            leap_days -= hi_century - lo_century;
   1770          
   1771            // Account for quad century leap years
   1772            uint16_t lo_quad = (base_year - 0) / 400;
   1773            uint16_t hi_quad = (current_year - 1) / 400;
   1774            leap_days += hi_quad - lo_quad;
   1775          
   1776            return (leap_days);
   1777          }
   1778          
   1779          /*******************************************************************************
   1780           * Checks if the time stamp, format and time zone are
   1781           *  within the supported range.
   1782           *
   1783           * @param time Time stamp to check.
   1784           * @param format Format of the time.
   1785           * @param time_zone Time zone offset in second.
   1786           *
   1787           * @return true if the time is valid. False otherwise.
   1788           ******************************************************************************/
   1789          static bool is_valid_time(sl_sleeptimer_timestamp_t time,
   1790                                    sl_sleeptimer_time_format_t format,
   1791                                    sl_sleeptimer_time_zone_offset_t time_zone)
   1792          {
   1793            bool valid_time = false;
   1794          
   1795            // Check for overflow.
   1796            if ((time_zone < 0 && time > (uint32_t)abs(time_zone)) \
   1797                || (time_zone >= 0 && (time <= UINT32_MAX - time_zone))) {
   1798              valid_time = true;
   1799            }
   1800            if (format == TIME_FORMAT_UNIX) {
   1801              if (time > TIME_UNIX_TIMESTAMP_MAX) { // Check if Unix time stamp is an unsigned 31 bits.
   1802                valid_time = false;
   1803              }
   1804            } else {
   1805              if ((format == TIME_FORMAT_NTP) && (time >= TIME_NTP_EPOCH_OFFSET_SEC)) {
   1806                valid_time &= true;
   1807              } else if ((format == TIME_FORMAT_ZIGBEE_CLUSTER) && (time <= TIME_UNIX_TIMESTAMP_MAX - TIME_ZIGBEE_EPOCH_OFFSET_SEC)) {
   1808                valid_time &= true;
   1809              } else {
   1810                valid_time = false;
   1811              }
   1812            }
   1813            return valid_time;
   1814          }
   1815          
   1816          /*******************************************************************************
   1817           * Checks if the time stamp, format and time zone are
   1818           *  within the supported range.
   1819           *
   1820           * @param time Time stamp to check.
   1821           * @param format Format of the time.
   1822           * @param time_zone Time zone offset in second.
   1823           *
   1824           * @return true if the time is valid. False otherwise.
   1825           ******************************************************************************/
   1826          static bool is_valid_time_64(sl_sleeptimer_timestamp_64_t time,
   1827                                       sl_sleeptimer_time_format_t format,
   1828                                       sl_sleeptimer_time_zone_offset_t time_zone)
   1829          {
   1830            bool valid_time = false;
   1831          
   1832            // Check for overflow.
   1833            if ((time_zone < 0 && time > (uint64_t)abs(time_zone))
   1834                || (time_zone >= 0 && (time <= UINT64_MAX - time_zone))) {
   1835              valid_time = true;
   1836            }
   1837            if (format == TIME_FORMAT_UNIX_64_BIT) {
   1838              if (time > TIME_64_BIT_UNIX_TIMESTAMP_MAX) { // Check if time stamp is an unsigned 64 bits.
   1839                valid_time = false;
   1840              }
   1841            }
   1842            return valid_time;
   1843          }
   1844          
   1845          /*******************************************************************************
   1846           * Checks if the date is valid.
   1847           *
   1848           * @param date Date to check.
   1849           *
   1850           * @return true if the date is valid. False otherwise.
   1851           ******************************************************************************/
   1852          static bool is_valid_date(sl_sleeptimer_date_t *date)
   1853          {
   1854            if ((date == NULL)
   1855                || (date->year > TIME_UNIX_YEAR_MAX)
   1856                || (date->month > MONTH_DECEMBER)
   1857                || (date->month_day == 0 || date->month_day > days_in_month[is_leap_year(date->year)][date->month])
   1858                || (date->hour > 23)
   1859                || (date->min > 59)
   1860                || (date->sec > 59)) {
   1861              return false;
   1862            }
   1863          
   1864            // Unix is valid until the 19th of January 2038 at 03:14:07
   1865            if (date->year == TIME_UNIX_YEAR_MAX) {
   1866              if ((uint8_t)date->month > (uint8_t)MONTH_JANUARY) {
   1867                return false;
   1868              } else if (date->month_day > 19) {
   1869                return false;
   1870              } else if (date->hour > 3) {
   1871                return false;
   1872              } else if (date->min > 14) {
   1873                return false;
   1874              } else if (date->sec > 7) {
   1875                return false;
   1876              }
   1877            }
   1878          
   1879            return true;
   1880          }
   1881          
   1882          /*******************************************************************************
   1883           * Checks if the date is valid.
   1884           *
   1885           * @param date Date to check.
   1886           *
   1887           * @return true if the date is valid. False otherwise.
   1888           ******************************************************************************/
   1889          static bool is_valid_date_64(sl_sleeptimer_date_t *date)
   1890          {
   1891            if ((date == NULL)
   1892                || (date->year > TIME_64_BIT_YEAR_MAX)
   1893                || (date->month > MONTH_DECEMBER)
   1894                || (date->month_day == 0 || date->month_day > days_in_month[is_leap_year(date->year)][date->month])
   1895                || (date->hour > 23)
   1896                || (date->min > 59)
   1897                || (date->sec > 59)) {
   1898              return false;
   1899            }
   1900            return true;
   1901          }
   1902          #endif
   1903          
   1904          /*******************************************************************************
   1905           * @brief
   1906           *   Gets the precision (in PPM) of the sleeptimer's clock.
   1907           *
   1908           * @return
   1909           *   Clock accuracy, in PPM.
   1910           *
   1911           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1912          uint16_t sl_sleeptimer_get_clock_accuracy(void)
   1913          {
   1914            return sleeptimer_hal_get_clock_accuracy();
   \                     sl_sleeptimer_get_clock_accuracy: (+1)
   \        0x0   0x.... 0x....      B.W      sleeptimer_hal_get_clock_accuracy
   1915          }
   1916          
   1917          /***************************************************************************//**
   1918           * @brief
   1919           *   Update sleep_on_isr_exit flag.
   1920           *
   1921           * @param flag Value update_sleep_on_isr_exit will be set to.
   1922           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1923          void sli_sleeptimer_update_sleep_on_isr_exit(bool flag)
   1924          {
   1925            sleep_on_isr_exit = flag;
   \                     sli_sleeptimer_update_sleep_on_isr_exit: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable22
   \        0x2   0x7088             STRB     R0,[R1, #+2]
   1926          }
   \        0x4   0x4770             BX       LR
   1927          
   1928          /*******************************************************************************
   1929           * Gets the associated peripheral capture channel current value.
   1930           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1931          uint32_t sli_sleeptimer_get_capture(void)
   1932          {
   1933            return sleeptimer_hal_get_capture();
   \                     sli_sleeptimer_get_capture: (+1)
   \        0x0   0x.... 0x....      B.W      sleeptimer_hal_get_capture
   1934          }
   1935          
   1936          /*******************************************************************************
   1937           * Resets the PRS signal triggered by the associated peripheral.
   1938           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1939          void sli_sleeptimer_reset_prs_signal(void)
   1940          {
   1941            sleeptimer_hal_reset_prs_signal();
   \                     sli_sleeptimer_reset_prs_signal: (+1)
   \        0x0   0x.... 0x....      B.W      sleeptimer_hal_reset_prs_signal
   1942          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     is_sleeptimer_initialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0xFFFF'FC18        DC32     0xfffffc18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x0041'8937        DC32     0x418937

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x4BC6'A7F0        DC32     0x4bc6a7f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x73          DC8 0x5C, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65
   \              0x65 0x72    
   \              0x76 0x69    
   \              0x63 0x65
   \       0x58   0x5C 0x73          DC8 0x5C, 0x73, 0x6C, 0x65, 0x65, 0x70, 0x74, 0x69
   \              0x6C 0x65    
   \              0x65 0x70    
   \              0x74 0x69
   \       0x60   0x6D 0x65          DC8 0x6D, 0x65, 0x72, 0x5C, 0x73, 0x72, 0x63, 0x5C
   \              0x72 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C
   \       0x68   0x73 0x6C          DC8 0x73, 0x6C, 0x5F, 0x73, 0x6C, 0x65, 0x65, 0x70
   \              0x5F 0x73    
   \              0x6C 0x65    
   \              0x65 0x70
   \       0x70   0x74 0x69          DC8 0x74, 0x69, 0x6D, 0x65, 0x72, 0x2E, 0x63, 0
   \              0x6D 0x65    
   \              0x72 0x2E    
   \              0x63 0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   create_timer
        16   -- Indirect call
        16   -> CORE_EnterCritical
        16   -> CORE_ExitCritical
        16   -> delta_list_insert_timer
        16   -> set_comparator_for_next_timer
        16   -> sleeptimer_hal_get_counter
        16   -> update_delta_list
       0   delay_callback
      20   delta_list_insert_timer
       0   delta_list_remove_timer
       0   div_to_log2
       0   is_power_of_2
      40   process_timer_irq
        40   -- Indirect call
        40   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic
        40   -> CORE_ExitAtomic
        40   -> assertEFM
        40   -> delta_list_insert_timer
        40   -> delta_list_remove_timer
        40   -> set_comparator_for_next_timer
        40   -> sleeptimer_hal_disable_int
        40   -> sleeptimer_hal_get_counter
        40   -> update_delta_list
      16   set_comparator_for_next_timer
        16   -> sleeptimer_hal_enable_int
        16   -> sleeptimer_hal_set_compare
        16   -> sleeptimer_hal_set_int
      64   sl_sleeptimer_delay_millisecond
        64   -> sl_sleeptimer_start_timer
        64 __aeabi_uldivmod
       0   sl_sleeptimer_get_clock_accuracy
         0   -> sleeptimer_hal_get_clock_accuracy
       0   sl_sleeptimer_get_max_ms32_conversion
      24   sl_sleeptimer_get_remaining_time_of_first_timer
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> sleeptimer_hal_get_counter
      16   sl_sleeptimer_get_tick_count
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> sleeptimer_hal_get_counter
      16   sl_sleeptimer_get_tick_count64
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> sleeptimer_hal_get_counter
        16   -> sli_sleeptimer_hal_is_int_status_set
       0   sl_sleeptimer_get_timer_frequency
      24   sl_sleeptimer_get_timer_time_remaining
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> sleeptimer_hal_get_counter
        24   -> update_delta_list
      16   sl_sleeptimer_init
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> sleeptimer_hal_enable_int
        16   -> sleeptimer_hal_get_timer_frequency
        16   -> sleeptimer_hal_init_timer
        16 __aeabi_uldivmod
       8   sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
      16   sl_sleeptimer_is_timer_running
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
      12   sl_sleeptimer_ms32_to_tick
        12 __aeabi_uldivmod
       8   sl_sleeptimer_ms_to_tick
         0 __aeabi_uldivmod
      32   sl_sleeptimer_restart_periodic_timer
        32   -> create_timer
        32   -> sl_sleeptimer_stop_timer
      40   sl_sleeptimer_restart_periodic_timer_ms
        40   -> create_timer
        40   -> sl_sleeptimer_ms32_to_tick
        40   -> sl_sleeptimer_stop_timer
      32   sl_sleeptimer_restart_timer
        32   -> create_timer
        32   -> sl_sleeptimer_stop_timer
      40   sl_sleeptimer_start_periodic_timer
        40   -> create_timer
        40   -> sl_sleeptimer_is_timer_running
      40   sl_sleeptimer_start_periodic_timer_ms
        40   -> create_timer
        40   -> sl_sleeptimer_is_timer_running
        40   -> sl_sleeptimer_ms32_to_tick
      40   sl_sleeptimer_start_timer
        40   -> create_timer
        40   -> sl_sleeptimer_is_timer_running
      24   sl_sleeptimer_stop_timer
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
        24   -> delta_list_remove_timer
        24   -> set_comparator_for_next_timer
        24   -> sleeptimer_hal_disable_int
        24   -> update_delta_list
      24   sl_sleeptimer_tick64_to_ms
        24   -> div_to_log2
        24   -> is_power_of_2
        24 __aeabi_llsr
        24 __aeabi_uldivmod
      16   sl_sleeptimer_tick_to_ms
        16   -> div_to_log2
        16   -> is_power_of_2
         0 __aeabi_llsr
         0 __aeabi_uldivmod
       0   sli_sleeptimer_get_capture
         0   -> sleeptimer_hal_get_capture
      16   sli_sleeptimer_is_power_manager_timer_next_to_expire
        16   -> sl_sleeptimer_get_tick_count
       0   sli_sleeptimer_reset_prs_signal
         0   -> sleeptimer_hal_reset_prs_signal
       0   sli_sleeptimer_update_sleep_on_isr_exit
       8   update_delta_list
         8   -> sleeptimer_hal_get_counter


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??Subroutine8_0
       8  ?Subroutine0
      14  ?Subroutine1
       8  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
      32  ?Subroutine5
      18  ?Subroutine6
      18  ?Subroutine7
     120  ?_0
     106  create_timer
       6  delay_callback
      78  delta_list_insert_timer
      54  delta_list_remove_timer
      10  div_to_log2
      16  is_power_of_2
      24  is_sleeptimer_initialized
          next_timer_to_expire_is_power_manager
          sleep_on_isr_exit
          overflow_counter
          timer_frequency
          timer_head
          last_delta_update_count
          max_millisecond_conversion
     308  process_timer_irq
      72  set_comparator_for_next_timer
      76  sl_sleeptimer_delay_millisecond
       4  sl_sleeptimer_get_clock_accuracy
       8  sl_sleeptimer_get_max_ms32_conversion
      92  sl_sleeptimer_get_remaining_time_of_first_timer
      24  sl_sleeptimer_get_tick_count
      48  sl_sleeptimer_get_tick_count64
       8  sl_sleeptimer_get_timer_frequency
     106  sl_sleeptimer_get_timer_time_remaining
      86  sl_sleeptimer_init
      18  sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire
      56  sl_sleeptimer_is_timer_running
      48  sl_sleeptimer_ms32_to_tick
      34  sl_sleeptimer_ms_to_tick
      26  sl_sleeptimer_restart_periodic_timer
      66  sl_sleeptimer_restart_periodic_timer_ms
      28  sl_sleeptimer_restart_timer
      48  sl_sleeptimer_start_periodic_timer
      86  sl_sleeptimer_start_periodic_timer_ms
      48  sl_sleeptimer_start_timer
      84  sl_sleeptimer_stop_timer
      96  sl_sleeptimer_tick64_to_ms
      68  sl_sleeptimer_tick_to_ms
       4  sli_sleeptimer_get_capture
      32  sli_sleeptimer_is_power_manager_timer_next_to_expire
       4  sli_sleeptimer_reset_prs_signal
       6  sli_sleeptimer_update_sleep_on_isr_exit
      46  update_delta_list

 
    24 bytes in section .bss
   120 bytes in section .rodata
 2'042 bytes in section .text
 
 2'042 bytes of CODE  memory
   120 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
