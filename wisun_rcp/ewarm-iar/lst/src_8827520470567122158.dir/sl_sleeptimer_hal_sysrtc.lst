###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:16
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\sl_sleeptimer_hal_sysrtc.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir\sl_sleeptimer_hal_sysrtc.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\sl_sleeptimer_hal_sysrtc.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_8827520470567122158.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir\sl_sleeptimer_hal_sysrtc.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_8827520470567122158.dir\sl_sleeptimer_hal_sysrtc.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_8827520470567122158.dir\sl_sleeptimer_hal_sysrtc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\src\sl_sleeptimer_hal_sysrtc.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief SLEEPTIMER hardware abstraction implementation for SYSRTC.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #if defined(SL_COMPONENT_CATALOG_PRESENT)
     32          #include "sl_component_catalog.h"
     33          #endif
     34          #include "peripheral_sysrtc.h"
     35          #include "sl_sleeptimer.h"
     36          #include "sli_sleeptimer_hal.h"
     37          #include "em_core.h"
     38          #include "em_cmu.h"
     39          
     40          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
     41          #include "sl_power_manager.h"
     42          #endif
     43          
     44          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT) || defined(SL_CATALOG_HFXO_MANAGER_PRESENT)
     45          #if defined(_SILICON_LABS_32B_SERIES_2)
     46          #include "em_prs.h"
     47          #else
     48          #include "sl_peripheral_prs.h"
     49          #endif
     50          #endif
     51          
     52          #if SL_SLEEPTIMER_PERIPHERAL == SL_SLEEPTIMER_PERIPHERAL_SYSRTC
     53          
     54          // Minimum difference between current count value and what the comparator of the timer can be set to.
     55          // 1 tick is added to the minimum diff for the algorithm of compensation for the IRQ handler that
     56          // triggers when CNT == compare_value + 1. For more details refer to sleeptimer_hal_set_compare() function's header.
     57          #define SLEEPTIMER_COMPARE_MIN_DIFF  (2 + 1)
     58          
     59          #define SLEEPTIMER_TMR_WIDTH (_SYSRTC_CNT_MASK)
     60          

   \                                 In section .data, align 1
     61          static bool cc_disabled = true;
   \                     cc_disabled:
   \        0x0   0x01               DC8 1
     62          

   \                                 In section .data, align 1
     63          static bool cc1_disabled = true;
   \                     cc1_disabled:
   \        0x0   0x01               DC8 1
     64          
     65          __STATIC_INLINE uint32_t get_time_diff(uint32_t a,
     66                                                 uint32_t b);
     67          
     68          /******************************************************************************
     69           * Initializes SYSRTC sleep timer.
     70           *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     71          void sleeptimer_hal_init_timer(void)
     72          {
   \                     sleeptimer_hal_init_timer: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF88D 0x1000      STRB     R1,[SP, #+0]
     73            sl_hal_sysrtc_config_t sysrtc_config = SYSRTC_CONFIG_DEFAULT;
     74            sl_hal_sysrtc_group_config_t group_config = SYSRTC_GROUP_CONFIG_DEFAULT;
   \        0xA   0xA801             ADD      R0,SP,#+4
   \        0xC   0x....             ADR.N    R1,?_0
   \        0xE   0x2210             MOVS     R2,#+16
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy4
     75          
     76            CMU_ClockEnable(cmuClock_SYSRTC, true);
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x203E             MOVS     R0,#+62
   \       0x18   0x.... 0x....      BL       CMU_ClockEnable
     77          
     78          #if (SL_SLEEPTIMER_DEBUGRUN == 1)
     79            sysrtc_config.enable_debug_run = true;
     80          #endif
     81          
     82            sl_hal_sysrtc_init(&sysrtc_config);
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x.... 0x....      BL       sl_hal_sysrtc_init
     83          
     84            group_config.compare_channel0_enable = false;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xF88D 0x0004      STRB     R0,[SP, #+4]
     85          
     86            sl_hal_sysrtc_init_group(0u, &group_config);
   \       0x28   0xA901             ADD      R1,SP,#+4
   \       0x2A   0x.... 0x....      BL       sl_hal_sysrtc_init_group
     87          
     88            sl_hal_sysrtc_disable_group_interrupts(0u, _SYSRTC_GRP0_IEN_MASK);
   \       0x2E   0x210F             MOVS     R1,#+15
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x.... 0x....      BL       sl_hal_sysrtc_disable_group_interrupts
     89            sl_hal_sysrtc_clear_group_interrupts(0u, _SYSRTC_GRP0_IF_MASK);
   \       0x36   0x210F             MOVS     R1,#+15
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x.... 0x....      BL       sl_hal_sysrtc_clear_group_interrupts
     90            sl_hal_sysrtc_enable();
   \       0x3E   0x.... 0x....      BL       sl_hal_sysrtc_enable
     91            sl_hal_sysrtc_set_counter(0u);
   \       0x42   0x....             LDR.N    R1,??DataTable8
   \                     ??sleeptimer_hal_init_timer_0: (+1)
   \       0x44   0x6808             LDR      R0,[R1, #+0]
   \       0x46   0x07C2             LSLS     R2,R0,#+31
   \       0x48   0xD502             BPL.N    ??sleeptimer_hal_init_timer_1
   \       0x4A   0x6988             LDR      R0,[R1, #+24]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD1F9             BNE.N    ??sleeptimer_hal_init_timer_0
   \                     ??sleeptimer_hal_init_timer_1: (+1)
   \       0x50   0x2400             MOVS     R4,#+0
   \       0x52   0x614C             STR      R4,[R1, #+20]
     92          
     93            NVIC_ClearPendingIRQ(SYSRTC_APP_IRQn);
   \       0x54   0x2340             MOVS     R3,#+64
   \       0x56   0x....             LDR.N    R2,??DataTable8_1
   \       0x58   0x6013             STR      R3,[R2, #+0]
     94            NVIC_EnableIRQ(SYSRTC_APP_IRQn);
   \       0x5A   0x2140             MOVS     R1,#+64
   \       0x5C   0x....             LDR.N    R0,??DataTable8_2
   \       0x5E   0x6001             STR      R1,[R0, #+0]
     95          }
   \       0x60   0xB006             ADD      SP,SP,#+24
   \       0x62   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x01 0x00          DC8 1, 0, 0
   \              0x00
   \        0x3                      DS8 1
   \        0x4   0x0000'0000        DC32 0x0, 0x0, 0x0
   \              0x0000'0000  
   \              0x0000'0000
     96          
     97          /*******************************************************************************
     98           * Hardware Abstraction Layer to perform initialization related to Power Manager.
     99           ******************************************************************************/
    100          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    101          void sli_sleeptimer_hal_power_manager_integration_init(void)
    102          {
    103            // Initialize PRS to start HFXO for early wakeup
    104            CMU_ClockEnable(cmuClock_PRS, true);
    105          
    106          #if defined(_SILICON_LABS_32B_SERIES_2)
    107            PRS_ConnectSignal(1UL, prsTypeAsync, prsSignalSYSRTC0_GRP0OUT1);
    108            PRS_ConnectConsumer(1UL, prsTypeAsync, prsConsumerHFXO0_OSCREQ);
    109          #else
    110            sl_hal_prs_async_connect_channel_producer(1UL, SL_HAL_PRS_ASYNC_SYSRTC0_GRP0OUT1);
    111            sl_hal_prs_connect_channel_consumer(1UL, SL_HAL_PRS_TYPE_ASYNC, SL_HAL_PRS_CONSUMER_HFXO0_OSCREQ);
    112          #endif
    113          
    114            // Set SYSRTC Compare Channel 1
    115            SYSRTC0->GRP0_CTRL |= (_SYSRTC_GRP0_CTRL_CMP1CMOA_CMPIF << _SYSRTC_GRP0_CTRL_CMP1CMOA_SHIFT);
    116          }
    117          #endif
    118          
    119          /*******************************************************************************
    120           * Hardware Abstraction Layer to perform initialization related to HFXO Manager.
    121           ******************************************************************************/
    122          #if defined(SL_CATALOG_HFXO_MANAGER_PRESENT)
    123          void sli_sleeptimer_hal_hfxo_manager_integration_init(void)
    124          {
    125            // Set PRS signal from HFXO to SYSRTC capture channel
    126            CMU_ClockEnable(cmuClock_PRS, true);
    127          
    128          #if defined(_SILICON_LABS_32B_SERIES_2)
    129            PRS_ConnectSignal(2UL, prsTypeAsync, prsSignalHFXO0L_STATUS1);
    130            PRS_ConnectConsumer(2UL, prsTypeAsync, prsConsumerSYSRTC0_SRC0);
    131          #else
    132            sl_hal_prs_async_connect_channel_producer(2UL, SL_HAL_PRS_ASYNC_SYXO0L_STATUS1);
    133            sl_hal_prs_connect_channel_consumer(2UL, SL_HAL_PRS_TYPE_ASYNC, SL_HAL_PRS_CONSUMER_SYSRTC0_IN0);
    134          #endif
    135          
    136            // Set SYSRTC Capture Channel
    137            SYSRTC0->GRP0_CTRL |= (_SYSRTC_GRP0_CTRL_CAP0EDGE_RISING << _SYSRTC_GRP0_CTRL_CAP0EDGE_SHIFT);
    138          }
    139          #endif
    140          
    141          /******************************************************************************
    142           * Gets SYSRTC counter value.
    143           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          uint32_t sleeptimer_hal_get_counter(void)
    145          {
    146            return sl_hal_sysrtc_get_counter();
   \                     sleeptimer_hal_get_counter: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable8
   \                     ??sleeptimer_hal_get_counter_0: (+1)
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x07C2             LSLS     R2,R0,#+31
   \        0x6   0xD502             BPL.N    ??sleeptimer_hal_get_counter_1
   \        0x8   0x6988             LDR      R0,[R1, #+24]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD1F9             BNE.N    ??sleeptimer_hal_get_counter_0
   \                     ??sleeptimer_hal_get_counter_1: (+1)
   \        0xE   0x6948             LDR      R0,[R1, #+20]
   \       0x10   0x4770             BX       LR
    147          }
    148          
    149          /******************************************************************************
    150           * Gets SYSRTC channel zero's compare value.
    151           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    152          uint32_t sleeptimer_hal_get_compare(void)
    153          {
    154            return sl_hal_sysrtc_get_group_compare_channel_value(0u, 0u);
   \                     sleeptimer_hal_get_compare: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      B.W      sl_hal_sysrtc_get_group_compare_channel_value
    155          }
    156          
    157          /******************************************************************************
    158           * Sets SYSRTC channel zero's compare value.
    159           *
    160           * @note Compare match value is set to the requested value - 1. This is done
    161           * to compensate for the fact that the SYSRTC compare match interrupt always
    162           * triggers at the end of the requested ticks and that the IRQ handler is
    163           * executed when current tick count == compare_value + 1.
    164           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    165          void sleeptimer_hal_set_compare(uint32_t value)
    166          {
   \                     sleeptimer_hal_set_compare: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
    167            CORE_DECLARE_IRQ_STATE;
    168            uint32_t counter;
    169            uint32_t compare;
    170            uint32_t compare_value = value;
    171          
    172            CORE_ENTER_CRITICAL();
   \        0x6   0x.... 0x....      BL       CORE_EnterCritical
   \        0xA   0x4680             MOV      R8,R0
    173            counter = sleeptimer_hal_get_counter();
   \        0xC   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x10   0x6967             LDR      R7,[R4, #+20]
    174            compare = sleeptimer_hal_get_compare();
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x.... 0x....      BL       sl_hal_sysrtc_get_group_compare_channel_value
   \       0x1A   0x4605             MOV      R5,R0
    175          
    176            if (((sl_hal_sysrtc_get_group_interrupts(0u) & SYSRTC_GRP0_IEN_CMP0) != 0)
    177                || get_time_diff(compare, counter) > SLEEPTIMER_COMPARE_MIN_DIFF
    178                || compare == counter) {
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x.... 0x....      BL       sl_hal_sysrtc_get_group_interrupts
   \       0x22   0x0780             LSLS     R0,R0,#+30
   \       0x24   0xD404             BMI.N    ??sleeptimer_hal_set_compare_0
   \       0x26   0x1BE8             SUBS     R0,R5,R7
   \       0x28   0x2803             CMP      R0,#+3
   \       0x2A   0xD801             BHI.N    ??sleeptimer_hal_set_compare_0
   \       0x2C   0x42BD             CMP      R5,R7
   \       0x2E   0xD10D             BNE.N    ??sleeptimer_hal_set_compare_1
    179              // Add margin if necessary
    180              if (get_time_diff(compare_value, counter) < SLEEPTIMER_COMPARE_MIN_DIFF) {
   \                     ??sleeptimer_hal_set_compare_0: (+1)
   \       0x30   0x1BF0             SUBS     R0,R6,R7
   \       0x32   0x2803             CMP      R0,#+3
   \       0x34   0xBF38             IT       CC
   \       0x36   0x1CFE             ADDCC    R6,R7,#+3
    181                compare_value = counter + SLEEPTIMER_COMPARE_MIN_DIFF;
    182              }
    183              compare_value %= SLEEPTIMER_TMR_WIDTH;
    184          
    185              sl_hal_sysrtc_set_group_compare_channel_value(0u, 0u, compare_value - 1);
   \       0x38   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x3C   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x.... 0x....      BL       ?Subroutine1
    186              sleeptimer_hal_enable_int(SLEEPTIMER_EVENT_COMP);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x.... 0x....      BL       sleeptimer_hal_enable_int
    187            }
    188            CORE_EXIT_CRITICAL();
   \                     ??sleeptimer_hal_set_compare_1: (+1)
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x.... 0x....      BL       CORE_ExitCritical
    189          
    190            if (cc_disabled) {
   \       0x52   0x....             LDR.N    R1,??DataTable8_3
   \       0x54   0x7808             LDRB     R0,[R1, #+0]
   \       0x56   0xB128             CBZ.N    R0,??sleeptimer_hal_set_compare_2
    191              SYSRTC0->GRP0_CTRL |= SYSRTC_GRP0_CTRL_CMP0EN;
   \       0x58   0x6C60             LDR      R0,[R4, #+68]
    192              cc_disabled = false;
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x60   0x6460             STR      R0,[R4, #+68]
   \       0x62   0x700A             STRB     R2,[R1, #+0]
    193            }
    194          }
   \                     ??sleeptimer_hal_set_compare_2: (+1)
   \       0x64   0xE8BD 0x81F0      POP      {R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xEBA0 0x0040      SUB      R0,R0,R0, LSL #+1
   \        0x4   0x1A36             SUBS     R6,R6,R0
   \        0x6   0x1E72             SUBS     R2,R6,#+1
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x.... 0x....      B.W      sl_hal_sysrtc_set_group_compare_channel_value
    195          
    196          /*******************************************************************************
    197           * Sets SYSRTC channel one's compare value.
    198           *
    199           * @note Compare match value is set to the requested value - 1. This is done
    200           * to compensate for the fact that the SYSRTC compare match interrupt always
    201           * triggers at the end of the requested ticks and that the IRQ handler is
    202           * executed when current tick count == compare_value + 1.
    203           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          void sleeptimer_hal_set_compare_prs_hfxo_startup(int32_t value)
    205          {
   \                     sleeptimer_hal_set_compare_prs_hfxo_startup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
    206            CORE_DECLARE_IRQ_STATE;
    207            uint32_t counter;
    208            uint32_t compare_value;
    209          
    210            CORE_ENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       CORE_EnterCritical
   \        0x8   0x4605             MOV      R5,R0
    211          
    212            counter = sleeptimer_hal_get_counter();
   \        0xA   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xE   0x6961             LDR      R1,[R4, #+20]
    213          
    214            compare_value = value + counter;
   \       0x10   0x198E             ADDS     R6,R1,R6
    215          
    216            // Add margin if necessary
    217            if (get_time_diff(compare_value, counter) < SLEEPTIMER_COMPARE_MIN_DIFF) {
   \       0x12   0x1A70             SUBS     R0,R6,R1
   \       0x14   0x2803             CMP      R0,#+3
   \       0x16   0xBF38             IT       CC
   \       0x18   0x1CCE             ADDCC    R6,R1,#+3
    218              compare_value = counter + SLEEPTIMER_COMPARE_MIN_DIFF;
    219            }
    220          
    221            compare_value %= SLEEPTIMER_TMR_WIDTH;
    222          
    223            sl_hal_sysrtc_set_group_compare_channel_value(0u, 1u, compare_value - 1);
   \       0x1A   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x1E   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x.... 0x....      BL       ?Subroutine1
    224          
    225            CORE_EXIT_CRITICAL();
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       CORE_ExitCritical
    226          
    227            if (cc1_disabled) {
   \       0x2E   0x....             LDR.N    R1,??DataTable8_4
   \       0x30   0x7808             LDRB     R0,[R1, #+0]
   \       0x32   0xB148             CBZ.N    R0,??sleeptimer_hal_set_compare_prs_hfxo_startup_0
    228              SYSRTC0->GRP0_CTRL |= SYSRTC_GRP0_CTRL_CMP1EN;
   \       0x34   0x6C60             LDR      R0,[R4, #+68]
    229              SYSRTC0->GRP0_CTRL |= SYSRTC_GRP0_CTRL_CAP0EN;
    230              cc1_disabled = false;
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x3C   0x6460             STR      R0,[R4, #+68]
   \       0x3E   0x6C60             LDR      R0,[R4, #+68]
   \       0x40   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x44   0x6460             STR      R0,[R4, #+68]
   \       0x46   0x700A             STRB     R2,[R1, #+0]
    231            }
    232          }
   \                     ??sleeptimer_hal_set_compare_prs_hfxo_startup_0: (+1)
   \       0x48   0xBD70             POP      {R4-R6,PC}
    233          
    234          /******************************************************************************
    235           * Enables SYSRTC interrupts.
    236           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    237          void sleeptimer_hal_enable_int(uint8_t local_flag)
    238          {
    239            uint32_t sysrtc_ien = 0u;
   \                     sleeptimer_hal_enable_int: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    240          
    241            if (local_flag & SLEEPTIMER_EVENT_OF) {
   \        0x2   0x07C2             LSLS     R2,R0,#+31
   \        0x4   0xBF48             IT       MI
   \        0x6   0x2101             MOVMI    R1,#+1
    242              sysrtc_ien |= SYSRTC_GRP0_IEN_OVF;
    243            }
    244          
    245            if (local_flag & SLEEPTIMER_EVENT_COMP) {
   \        0x8   0x0780             LSLS     R0,R0,#+30
   \        0xA   0xBF48             IT       MI
   \        0xC   0xF041 0x0102      ORRMI    R1,R1,#0x2
    246              sysrtc_ien |= SYSRTC_GRP0_IEN_CMP0;
    247            }
    248          
    249            sl_hal_sysrtc_enable_group_interrupts(0u, sysrtc_ien);
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x.... 0x....      B.W      sl_hal_sysrtc_enable_group_interrupts
    250          }
    251          
    252          /******************************************************************************
    253           * Disables SYSRTC interrupts.
    254           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    255          void sleeptimer_hal_disable_int(uint8_t local_flag)
    256          {
    257            uint32_t sysrtc_int_dis = 0u;
   \                     sleeptimer_hal_disable_int: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    258          
    259            if (local_flag & SLEEPTIMER_EVENT_OF) {
   \        0x2   0x07C2             LSLS     R2,R0,#+31
   \        0x4   0xBF48             IT       MI
   \        0x6   0x2101             MOVMI    R1,#+1
    260              sysrtc_int_dis |= SYSRTC_GRP0_IEN_OVF;
    261            }
    262          
    263            if (local_flag & SLEEPTIMER_EVENT_COMP) {
   \        0x8   0x0780             LSLS     R0,R0,#+30
   \        0xA   0xD509             BPL.N    ??sleeptimer_hal_disable_int_0
    264              sysrtc_int_dis |= SYSRTC_GRP0_IEN_CMP0;
    265          
    266              cc_disabled = true;
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0x....             LDR.N    R0,??DataTable8_3
   \       0x10   0x7002             STRB     R2,[R0, #+0]
    267              SYSRTC0->GRP0_CTRL &= ~_SYSRTC_GRP0_CTRL_CMP0EN_MASK;
   \       0x12   0x....             LDR.N    R0,??DataTable8_5
   \       0x14   0x6803             LDR      R3,[R0, #+0]
   \       0x16   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x1A   0x085B             LSRS     R3,R3,#+1
   \       0x1C   0x005B             LSLS     R3,R3,#+1
   \       0x1E   0x6003             STR      R3,[R0, #+0]
    268            }
    269          
    270            sl_hal_sysrtc_disable_group_interrupts(0u, sysrtc_int_dis);
   \                     ??sleeptimer_hal_disable_int_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x.... 0x....      B.W      sl_hal_sysrtc_disable_group_interrupts
    271          }
    272          
    273          /*******************************************************************************
    274           * Hardware Abstraction Layer to set timer interrupts.
    275           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    276          void sleeptimer_hal_set_int(uint8_t local_flag)
    277          {
    278            if (local_flag & SLEEPTIMER_EVENT_COMP) {
   \                     sleeptimer_hal_set_int: (+1)
   \        0x0   0x0782             LSLS     R2,R0,#+30
   \        0x2   0xD502             BPL.N    ??sleeptimer_hal_set_int_0
    279              SYSRTC0->GRP0_IF_SET = SYSRTC_GRP0_IF_CMP0;
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x....             LDR.N    R0,??DataTable8_6
   \        0x8   0x6001             STR      R1,[R0, #+0]
    280            }
    281          }
   \                     ??sleeptimer_hal_set_int_0: (+1)
   \        0xA   0x4770             BX       LR
    282          
    283          /******************************************************************************
    284           * Gets status of specified interrupt.
    285           *
    286           * Note: This function must be called with interrupts disabled.
    287           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    288          bool sli_sleeptimer_hal_is_int_status_set(uint8_t local_flag)
    289          {
   \                     sli_sleeptimer_hal_is_int_status_set: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
    290            bool int_is_set = false;
    291            uint32_t irq_flag = sl_hal_sysrtc_get_group_interrupts(0u);
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x.... 0x....      BL       sl_hal_sysrtc_get_group_interrupts
    292          
    293            switch (local_flag) {
   \        0xC   0x2D01             CMP      R5,#+1
   \        0xE   0xD005             BEQ.N    ??sli_sleeptimer_hal_is_int_status_set_0
   \       0x10   0x2D02             CMP      R5,#+2
   \       0x12   0xD105             BNE.N    ??sli_sleeptimer_hal_is_int_status_set_1
    294              case SLEEPTIMER_EVENT_COMP:
    295                int_is_set = ((irq_flag & SYSRTC_GRP0_IF_CMP0) == SYSRTC_GRP0_IF_CMP0);
   \       0x14   0x0844             LSRS     R4,R0,#+1
   \       0x16   0xF004 0x0401      AND      R4,R4,#0x1
    296                break;
   \       0x1A   0xE001             B.N      ??sli_sleeptimer_hal_is_int_status_set_1
    297          
    298              case SLEEPTIMER_EVENT_OF:
    299                int_is_set = ((irq_flag & SYSRTC_GRP0_IF_OVF) == SYSRTC_GRP0_IF_OVF);
   \                     ??sli_sleeptimer_hal_is_int_status_set_0: (+1)
   \       0x1C   0xF000 0x0401      AND      R4,R0,#0x1
    300                break;
    301          
    302              default:
    303                break;
    304            }
    305          
    306            return int_is_set;
   \                     ??sli_sleeptimer_hal_is_int_status_set_1: (+1)
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
    307          }
    308          
    309          /*******************************************************************************
    310           * SYSRTC interrupt handler.
    311           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          void SYSRTC_APP_IRQHandler(void)
    313          {
   \                     SYSRTC_APP_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    314            CORE_DECLARE_IRQ_STATE;
    315            uint8_t local_flag = 0;
    316            uint32_t irq_flag;
    317          
    318            CORE_ENTER_ATOMIC();
   \        0x2   0x.... 0x....      BL       CORE_EnterAtomic
   \        0x6   0x4604             MOV      R4,R0
    319            irq_flag = sl_hal_sysrtc_get_group_interrupts(0u);
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x.... 0x....      BL       sl_hal_sysrtc_get_group_interrupts
    320          
    321            if (irq_flag & SYSRTC_GRP0_IF_OVF) {
   \       0x10   0x07C1             LSLS     R1,R0,#+31
   \       0x12   0xBF48             IT       MI
   \       0x14   0x2501             MOVMI    R5,#+1
    322              local_flag |= SLEEPTIMER_EVENT_OF;
    323            }
    324          
    325            if (irq_flag & SYSRTC_GRP0_IF_CMP0) {
   \       0x16   0x0781             LSLS     R1,R0,#+30
   \       0x18   0xBF48             IT       MI
   \       0x1A   0xF045 0x0502      ORRMI    R5,R5,#0x2
    326              local_flag |= SLEEPTIMER_EVENT_COMP;
    327            }
    328            sl_hal_sysrtc_clear_group_interrupts(0u, irq_flag & (SYSRTC_GRP0_IF_OVF | SYSRTC_GRP0_IF_CMP0));
   \       0x1E   0xF000 0x0103      AND      R1,R0,#0x3
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x.... 0x....      BL       sl_hal_sysrtc_clear_group_interrupts
    329          
    330            process_timer_irq(local_flag);
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       process_timer_irq
    331          
    332            CORE_EXIT_ATOMIC();
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x34   0x.... 0x....      B.W      CORE_ExitAtomic
    333          }
    334          
    335          /*******************************************************************************
    336           * Gets SYSRTC timer frequency.
    337           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    338          uint32_t sleeptimer_hal_get_timer_frequency(void)
    339          {
    340            return (CMU_ClockFreqGet(cmuClock_SYSRTC));
   \                     sleeptimer_hal_get_timer_frequency: (+1)
   \        0x0   0x203E             MOVS     R0,#+62
   \        0x2   0x.... 0x....      B.W      CMU_ClockFreqGet
    341          }
    342          
    343          /*******************************************************************************
    344           * Computes difference between two times taking into account timer wrap-around.
    345           *
    346           * @param a Time.
    347           * @param b Time to substract from a.
    348           *
    349           * @return Time difference.
    350           ******************************************************************************/
    351          __STATIC_INLINE uint32_t get_time_diff(uint32_t a,
    352                                                 uint32_t b)
    353          {
    354            return (a - b);
    355          }
    356          
    357          /*******************************************************************************
    358           * @brief
    359           *   Gets the precision (in PPM) of the sleeptimer's clock.
    360           *
    361           * @return
    362           *   Clock accuracy, in PPM.
    363           *
    364           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    365          uint16_t sleeptimer_hal_get_clock_accuracy(void)
    366          {
    367            return CMU_LF_ClockPrecisionGet(cmuClock_SYSRTC);
   \                     sleeptimer_hal_get_clock_accuracy: (+1)
   \        0x0   0x203E             MOVS     R0,#+62
   \        0x2   0x.... 0x....      B.W      CMU_LF_ClockPrecisionGet
    368          }
    369          
    370          /*******************************************************************************
    371           * Hardware Abstraction Layer to get the capture channel value.
    372           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    373          uint32_t sleeptimer_hal_get_capture(void)
    374          {
   \                     sleeptimer_hal_get_capture: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    375            if ((sl_hal_sysrtc_get_group_interrupts(0) & _SYSRTC_GRP0_IF_CAP0_MASK) != 0) {
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      BL       sl_hal_sysrtc_get_group_interrupts
   \        0x8   0x0700             LSLS     R0,R0,#+28
   \        0xA   0xD508             BPL.N    ??sleeptimer_hal_get_capture_0
    376              sl_hal_sysrtc_clear_group_interrupts(0, _SYSRTC_GRP0_IF_CAP0_MASK);
   \        0xC   0x2108             MOVS     R1,#+8
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x.... 0x....      BL       sl_hal_sysrtc_clear_group_interrupts
    377              return sl_hal_sysrtc_get_group_capture_channel_value(0);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE8BD 0x4002      POP      {R1,LR}
   \       0x1A   0x.... 0x....      B.W      sl_hal_sysrtc_get_group_capture_channel_value
    378            } else {
    379              return 0;
   \                     ??sleeptimer_hal_get_capture_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD02             POP      {R1,PC}
    380            }
    381          }
    382          
    383          /*******************************************************************************
    384           * Hardware Abstraction Layer to reset PRS signal triggered by the associated
    385           * peripheral.
    386           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    387          void sleeptimer_hal_reset_prs_signal(void)
    388          {
    389            sl_hal_sysrtc_clear_group_interrupts(0, SYSRTC_GRP0_IF_CMP1);
   \                     sleeptimer_hal_reset_prs_signal: (+1)
   \        0x0   0x2104             MOVS     R1,#+4
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      B.W      sl_hal_sysrtc_clear_group_interrupts
    390          }
    391          
    392          /*******************************************************************************
    393           * Hardware Abstraction Layer to disable PRS compare and capture channel.
    394           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    395          void sleeptimer_hal_disable_prs_compare_and_capture_channel(void)
    396          {
    397            if (!cc1_disabled) {
   \                     sleeptimer_hal_disable_prs_compare_and_capture_channel: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable8_4
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
   \        0x4   0xB950             CBNZ.N   R0,??sleeptimer_hal_disable_prs_compare_and_captur_0
    398              SYSRTC0->GRP0_CTRL &= ~SYSRTC_GRP0_CTRL_CMP1EN;
   \        0x6   0x....             LDR.N    R0,??DataTable8_5
   \        0x8   0x6803             LDR      R3,[R0, #+0]
   \        0xA   0xF023 0x0302      BIC      R3,R3,#0x2
   \        0xE   0x6003             STR      R3,[R0, #+0]
    399              SYSRTC0->GRP0_CTRL &= ~SYSRTC_GRP0_CTRL_CAP0EN;
   \       0x10   0x6802             LDR      R2,[R0, #+0]
   \       0x12   0xF022 0x0204      BIC      R2,R2,#0x4
   \       0x16   0x6002             STR      R2,[R0, #+0]
    400              cc1_disabled = true;
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x7008             STRB     R0,[R1, #+0]
    401            }
    402          }
   \                     ??sleeptimer_hal_disable_prs_compare_and_captur_0: (+1)
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R4,??DataTable8
   \                     ??Subroutine0_0: (+1)
   \        0x2   0x6820             LDR      R0,[R4, #+0]
   \        0x4   0x07C1             LSLS     R1,R0,#+31
   \        0x6   0xD502             BPL.N    ??Subroutine0_1
   \        0x8   0x69A0             LDR      R0,[R4, #+24]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD1F9             BNE.N    ??Subroutine0_0
   \                     ??Subroutine0_1: (+1)
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x500A'8004        DC32     0x500a8004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0xE000'E288        DC32     0xe000e288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xE000'E108        DC32     0xe000e108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     cc_disabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     cc1_disabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x500A'8048        DC32     0x500a8048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x500A'9040        DC32     0x500a9040
    403          
    404          /***************************************************************************//**
    405           * Set lowest energy mode based on a project's configurations and clock source
    406           *
    407           * @note If power_manager_no_deepsleep component is included in a project, the
    408           *       lowest possible energy mode is EM1, else lowest energy mode is
    409           *       determined by clock source.
    410           ******************************************************************************/
    411          #if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
    412          void sli_sleeptimer_set_pm_em_requirement(void)
    413          {
    414            switch (CMU->SYSRTC0CLKCTRL & _CMU_SYSRTC0CLKCTRL_CLKSEL_MASK) {
    415              case CMU_SYSRTC0CLKCTRL_CLKSEL_LFRCO:
    416              case CMU_SYSRTC0CLKCTRL_CLKSEL_LFXO:
    417                sl_power_manager_add_em_requirement(SL_POWER_MANAGER_EM2);
    418                break;
    419              default:
    420                break;
    421            }
    422          }
    423          #endif
    424          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SYSRTC_APP_IRQHandler
        16   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic
        16   -> process_timer_irq
        16   -> sl_hal_sysrtc_clear_group_interrupts
        16   -> sl_hal_sysrtc_get_group_interrupts
       0   sleeptimer_hal_disable_int
         0   -> sl_hal_sysrtc_disable_group_interrupts
       0   sleeptimer_hal_disable_prs_compare_and_capture_channel
       0   sleeptimer_hal_enable_int
         0   -> sl_hal_sysrtc_enable_group_interrupts
       8   sleeptimer_hal_get_capture
         8   -> sl_hal_sysrtc_clear_group_interrupts
         0   -> sl_hal_sysrtc_get_group_capture_channel_value
         8   -> sl_hal_sysrtc_get_group_interrupts
       0   sleeptimer_hal_get_clock_accuracy
         0   -> CMU_LF_ClockPrecisionGet
       0   sleeptimer_hal_get_compare
         0   -> sl_hal_sysrtc_get_group_compare_channel_value
       0   sleeptimer_hal_get_counter
       0   sleeptimer_hal_get_timer_frequency
         0   -> CMU_ClockFreqGet
      32   sleeptimer_hal_init_timer
        32   -> CMU_ClockEnable
        32   -> __aeabi_memcpy4
        32   -> sl_hal_sysrtc_clear_group_interrupts
        32   -> sl_hal_sysrtc_disable_group_interrupts
        32   -> sl_hal_sysrtc_enable
        32   -> sl_hal_sysrtc_init
        32   -> sl_hal_sysrtc_init_group
       0   sleeptimer_hal_reset_prs_signal
         0   -> sl_hal_sysrtc_clear_group_interrupts
      24   sleeptimer_hal_set_compare
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
        24   -> sl_hal_sysrtc_get_group_compare_channel_value
        24   -> sl_hal_sysrtc_get_group_interrupts
        24   -> sl_hal_sysrtc_set_group_compare_channel_value
        24   -> sleeptimer_hal_enable_int
      16   sleeptimer_hal_set_compare_prs_hfxo_startup
        16   -> CORE_EnterCritical
        16   -> CORE_ExitCritical
        16   -> sl_hal_sysrtc_set_group_compare_channel_value
       0   sleeptimer_hal_set_int
      16   sli_sleeptimer_hal_is_int_status_set
        16   -> sl_hal_sysrtc_get_group_interrupts


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
      16  ?Subroutine0
      14  ?Subroutine1
      16  ?_0
      56  SYSRTC_APP_IRQHandler
       1  cc1_disabled
       1  cc_disabled
      38  sleeptimer_hal_disable_int
      30  sleeptimer_hal_disable_prs_compare_and_capture_channel
      22  sleeptimer_hal_enable_int
      34  sleeptimer_hal_get_capture
       6  sleeptimer_hal_get_clock_accuracy
       8  sleeptimer_hal_get_compare
      18  sleeptimer_hal_get_counter
       6  sleeptimer_hal_get_timer_frequency
     100  sleeptimer_hal_init_timer
       8  sleeptimer_hal_reset_prs_signal
     104  sleeptimer_hal_set_compare
      74  sleeptimer_hal_set_compare_prs_hfxo_startup
      12  sleeptimer_hal_set_int
      36  sli_sleeptimer_hal_is_int_status_set

 
   2 bytes in section .data
 626 bytes in section .text
 
 626 bytes of CODE memory
   2 bytes of DATA memory

Errors: none
Warnings: none
