###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:51
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\src\dmadrv.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_11258711289537696942.dir\dmadrv.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\src\dmadrv.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_11258711289537696942.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_11258711289537696942.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_11258711289537696942.dir\dmadrv.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_11258711289537696942.dir\dmadrv.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_11258711289537696942.dir\dmadrv.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\src\dmadrv.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief DMADRV API implementation.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include <stdbool.h>
     32          #include <stddef.h>
     33          
     34          #include "em_device.h"
     35          #include "em_core.h"
     36          
     37          #include "dmadrv.h"
     38          
     39          #if defined(EMDRV_DMADRV_UDMA)
     40          #include "em_cmu.h"
     41          #include "dmactrl.h"
     42          #endif
     43          
     44          /// @cond DO_NOT_INCLUDE_WITH_DOXYGEN
     45          
     46          #if !defined(EMDRV_DMADRV_DMA_CH_COUNT) \
     47            || (EMDRV_DMADRV_DMA_CH_COUNT > DMA_CHAN_COUNT)
     48          #define EMDRV_DMADRV_DMA_CH_COUNT DMA_CHAN_COUNT
     49          #endif
     50          
     51          typedef enum {
     52            dmaDirectionMemToPeripheral,
     53            dmaDirectionPeripheralToMem
     54          } DmaDirection_t;
     55          
     56          typedef enum {
     57            dmaModeBasic,
     58            dmaModePingPong
     59          } DmaMode_t;
     60          
     61          typedef struct {
     62            DMADRV_Callback_t callback;
     63            void              *userParam;
     64            unsigned int      callbackCount;
     65          #if defined(EMDRV_DMADRV_UDMA)
     66            int               length;
     67          #endif
     68            bool              allocated;
     69          #if defined(EMDRV_DMADRV_LDMA) || defined(EMDRV_DMADRV_LDMA_S3)
     70            DmaMode_t         mode;
     71          #endif
     72          } ChTable_t;
     73          

   \                                 In section .bss, align 1
     74          static bool initialized = false;
   \                     initialized:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     75          static ChTable_t chTable[EMDRV_DMADRV_DMA_CH_COUNT];
   \                     chTable:
   \        0x0                      DS8 128
     76          
     77          #if defined(EMDRV_DMADRV_UDMA)
     78          static DMA_CB_TypeDef dmaCallBack[EMDRV_DMADRV_DMA_CH_COUNT];
     79          #endif
     80          
     81          #if defined(EMDRV_DMADRV_LDMA) || defined(EMDRV_DMADRV_LDMA_S3)
     82          #if defined(EMDRV_DMADRV_LDMA)

   \                                 In section .rodata, align 4, keep-with-next
     83          const LDMA_TransferCfg_t xferCfgPeripheral = LDMA_TRANSFER_CFG_PERIPHERAL(0);
   \                     xferCfgPeripheral:
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00
   \        0xE                      DS8 2

   \                                 In section .text, align 4, keep-with-next
     84          const LDMA_Descriptor_t m2p = LDMA_DESCRIPTOR_SINGLE_M2P_BYTE(NULL, NULL, 1UL);
   \                     m2p:
   \        0x0   0x00 0x00          DC8 0, 0, 16, 48
   \              0x10 0x30
   \        0x4   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
     85          const LDMA_Descriptor_t p2m = LDMA_DESCRIPTOR_SINGLE_P2M_BYTE(NULL, NULL, 1UL);
   \                     p2m:
   \        0x0   0x00 0x00          DC8 0, 0, 16, 3
   \              0x10 0x03
   \        0x4   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00
     86          
     87          typedef struct {
     88            LDMA_Descriptor_t desc[2];
     89          } DmaXfer_t;
     90          #else
     91          const sl_hal_ldma_transfer_config_t xferCfgPeripheral = SL_HAL_LDMA_TRANSFER_CFG_PERIPHERAL(0);
     92          const sl_hal_ldma_descriptor_t m2p = SL_HAL_LDMA_DESCRIPTOR_SINGLE_M2P(SL_HAL_LDMA_CTRL_SIZE_BYTE, NULL, NULL, 1UL);
     93          const sl_hal_ldma_descriptor_t p2m = SL_HAL_LDMA_DESCRIPTOR_SINGLE_P2M(SL_HAL_LDMA_CTRL_SIZE_BYTE, NULL, NULL, 1UL);
     94          
     95          typedef struct {
     96            sl_hal_ldma_descriptor_t desc[2];
     97          } DmaXfer_t;
     98          #endif
     99          

   \                                 In section .bss, align 4
    100          static DmaXfer_t dmaXfer[EMDRV_DMADRV_DMA_CH_COUNT];
   \                     dmaXfer:
   \        0x0                      DS8 256
    101          #endif
    102          
    103          static Ecode_t StartTransfer(DmaMode_t                 mode,
    104                                       DmaDirection_t            direction,
    105                                       unsigned int              channelId,
    106                                       DMADRV_PeripheralSignal_t peripheralSignal,
    107                                       void                      *buf0,
    108                                       void                      *buf1,
    109                                       void                      *buf2,
    110                                       bool                      bufInc,
    111                                       int                       len,
    112                                       DMADRV_DataSize_t         size,
    113                                       DMADRV_Callback_t         callback,
    114                                       void                      *cbUserParam);
    115          
    116          #if defined(EMDRV_DMADRV_LDMA_S3)
    117          static void LDMA_IRQHandlerDefault(uint8_t chnum);
    118          #endif
    119          
    120          /// @endcond
    121          
    122          /***************************************************************************//**
    123           * @brief
    124           *  Allocate (reserve) a DMA channel.
    125           *
    126           * @param[out] channelId
    127           *  The channel ID assigned by DMADRV.
    128           *
    129           * @param[in] capabilities
    130           *  Not used.
    131           *
    132           * @return
    133           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    134           *  DMADRV @ref Ecode_t is returned.
    135           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          Ecode_t DMADRV_AllocateChannel(unsigned int *channelId, void *capabilities)
    137          {
   \                     DMADRV_AllocateChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    138            unsigned int i;
    139            (void)capabilities;
    140            CORE_DECLARE_IRQ_STATE;
    141          
    142            if ( !initialized ) {
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable23
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0xB900             CBNZ.N   R0,??DMADRV_AllocateChannel_0
    143              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xC   0x....             B.N      ?Subroutine2
    144            }
    145          
    146            if ( channelId == NULL ) {
   \                     ??DMADRV_AllocateChannel_0: (+1)
   \        0xE   0xB904             CBNZ.N   R4,??DMADRV_AllocateChannel_1
    147              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \       0x10   0x....             B.N      ?Subroutine1
    148            }
    149          
    150            CORE_ENTER_ATOMIC();
   \                     ??DMADRV_AllocateChannel_1: (+1)
   \       0x12   0x.... 0x....      BL       CORE_EnterAtomic
   \       0x16   0x4601             MOV      R1,R0
    151            for ( i = 0U; i < (unsigned int)EMDRV_DMADRV_DMA_CH_COUNT; i++ ) {
   \       0x18   0x2600             MOVS     R6,#+0
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable23_1
    152              if ( !chTable[i].allocated ) {
   \                     ??DMADRV_AllocateChannel_2: (+1)
   \       0x1E   0x0135             LSLS     R5,R6,#+4
   \       0x20   0x1953             ADDS     R3,R2,R5
   \       0x22   0x7B18             LDRB     R0,[R3, #+12]
   \       0x24   0xB118             CBZ.N    R0,??DMADRV_AllocateChannel_3
   \       0x26   0x1C76             ADDS     R6,R6,#+1
   \       0x28   0x2E08             CMP      R6,#+8
   \       0x2A   0xD3F8             BCC.N    ??DMADRV_AllocateChannel_2
   \       0x2C   0xE009             B.N      ??DMADRV_AllocateChannel_4
    153                *channelId           = i;
   \                     ??DMADRV_AllocateChannel_3: (+1)
   \       0x2E   0x6026             STR      R6,[R4, #+0]
    154                chTable[i].allocated = true;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x7318             STRB     R0,[R3, #+12]
    155                chTable[i].callback  = NULL;
   \       0x34   0x2300             MOVS     R3,#+0
   \       0x36   0x5153             STR      R3,[R2, R5]
    156                CORE_EXIT_ATOMIC();
   \       0x38   0x4608             MOV      R0,R1
   \       0x3A   0x.... 0x....      BL       CORE_ExitAtomic
    157                return ECODE_EMDRV_DMADRV_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD70             POP      {R4-R6,PC}
    158              }
    159            }
    160            CORE_EXIT_ATOMIC();
   \                     ??DMADRV_AllocateChannel_4: (+1)
   \       0x42   0x4608             MOV      R0,R1
   \       0x44   0x.... 0x....      BL       CORE_ExitAtomic
    161            return ECODE_EMDRV_DMADRV_CHANNELS_EXHAUSTED;
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \       0x4C   0xBD70             POP      {R4-R6,PC}
    162          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable23_7
   \        0x4   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable23_8
   \        0x4   0xBD70             POP      {R4-R6,PC}
    163          
    164          /***************************************************************************//**
    165           * @brief
    166           *  Deinitialize DMADRV.
    167           *
    168           * @details
    169           *  If DMA channels are not currently allocated, it will disable DMA hardware
    170           *  and mask associated interrupts.
    171           *
    172           * @return
    173           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    174           *  DMADRV @ref Ecode_t is returned.
    175           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    176          Ecode_t DMADRV_DeInit(void)
    177          {
   \                     DMADRV_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    178            int i;
    179            bool inUse;
    180            CORE_DECLARE_IRQ_STATE;
    181          
    182            inUse = false;
    183          
    184            CORE_ENTER_ATOMIC();
   \        0x2   0x.... 0x....      BL       CORE_EnterAtomic
   \        0x6   0x4604             MOV      R4,R0
    185            for ( i = 0; i < (int)EMDRV_DMADRV_DMA_CH_COUNT; i++ ) {
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable23_1
    186              if ( chTable[i].allocated ) {
   \                     ??DMADRV_DeInit_0: (+1)
   \        0xE   0xEB01 0x1302      ADD      R3,R1,R2, LSL #+4
   \       0x12   0x7B18             LDRB     R0,[R3, #+12]
   \       0x14   0xB918             CBNZ.N   R0,??DMADRV_DeInit_1
   \       0x16   0x1C52             ADDS     R2,R2,#+1
   \       0x18   0x2A08             CMP      R2,#+8
   \       0x1A   0xDBF8             BLT.N    ??DMADRV_DeInit_0
   \       0x1C   0xE005             B.N      ??DMADRV_DeInit_2
    187                inUse = true;
    188                break;
    189              }
    190            }
    191          
    192            if ( !inUse ) {
    193          #if defined(EMDRV_DMADRV_UDMA)
    194              NVIC_DisableIRQ(DMA_IRQn);
    195              DMA->IEN    = _DMA_IEN_RESETVALUE;
    196              DMA->CONFIG = _DMA_CONFIG_RESETVALUE;
    197              CMU_ClockEnable(cmuClock_DMA, false);
    198          #elif defined(EMDRV_DMADRV_LDMA)
    199              LDMA_DeInit();
    200          #elif defined(EMDRV_DMADRV_LDMA_S3)
    201              NVIC_DisableIRQ(LDMA_CHNL0_IRQn);
    202              NVIC_DisableIRQ(LDMA_CHNL1_IRQn);
    203              NVIC_DisableIRQ(LDMA_CHNL2_IRQn);
    204              NVIC_DisableIRQ(LDMA_CHNL3_IRQn);
    205              NVIC_DisableIRQ(LDMA_CHNL4_IRQn);
    206              NVIC_DisableIRQ(LDMA_CHNL5_IRQn);
    207              NVIC_DisableIRQ(LDMA_CHNL6_IRQn);
    208              NVIC_DisableIRQ(LDMA_CHNL7_IRQn);
    209          
    210              sl_hal_ldma_reset();
    211          
    212              // TODO CM add call to the equivalent of CMU_ClockEnable() to disable cmuClock_LDMA. It will require to include the proper S3 CMU header file.
    213          #endif
    214              initialized = false;
    215              CORE_EXIT_ATOMIC();
    216              return ECODE_EMDRV_DMADRV_OK;
    217            }
    218            CORE_EXIT_ATOMIC();
   \                     ??DMADRV_DeInit_1: (+1)
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       CORE_ExitAtomic
    219          
    220            return ECODE_EMDRV_DMADRV_IN_USE;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \       0x28   0xBD10             POP      {R4,PC}
   \                     ??DMADRV_DeInit_2: (+1)
   \       0x2A   0x.... 0x....      BL       LDMA_DeInit
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable23
   \       0x34   0x7001             STRB     R1,[R0, #+0]
   \       0x36   0x4620             MOV      R0,R4
   \       0x38                      REQUIRE ?Subroutine3
   \       0x38                      ;; // Fall through to label ?Subroutine3
    221          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x.... 0x....      BL       CORE_ExitAtomic
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD10             POP      {R4,PC}
    222          
    223          /***************************************************************************//**
    224           * @brief
    225           *  Free an allocated (reserved) DMA channel.
    226           *
    227           * @param[in] channelId
    228           *  The channel ID to free.
    229           *
    230           * @return
    231           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    232           *  DMADRV @ref Ecode_t is returned.
    233           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          Ecode_t DMADRV_FreeChannel(unsigned int channelId)
    235          {
   \                     DMADRV_FreeChannel: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    236            CORE_DECLARE_IRQ_STATE;
    237          
    238            if ( !initialized ) {
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable23
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0xB900             CBNZ.N   R0,??DMADRV_FreeChannel_0
    239              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xC   0x....             B.N      ?Subroutine6
    240            }
    241          
    242            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_FreeChannel_0: (+1)
   \        0xE   0x2C08             CMP      R4,#+8
   \       0x10   0xD300             BCC.N    ??DMADRV_FreeChannel_1
    243              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \       0x12   0x....             B.N      ?Subroutine5
    244            }
    245          
    246            CORE_ENTER_ATOMIC();
   \                     ??DMADRV_FreeChannel_1: (+1)
   \       0x14   0x.... 0x....      BL       CORE_EnterAtomic
    247            if ( chTable[channelId].allocated ) {
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable23_1
   \       0x1C   0xEB02 0x1204      ADD      R2,R2,R4, LSL #+4
   \       0x20   0x7B11             LDRB     R1,[R2, #+12]
   \       0x22   0xB111             CBZ.N    R1,??DMADRV_FreeChannel_2
    248              chTable[channelId].allocated = false;
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x7313             STRB     R3,[R2, #+12]
    249              CORE_EXIT_ATOMIC();
   \       0x28   0x....             B.N      ?Subroutine3
    250              return ECODE_EMDRV_DMADRV_OK;
    251            }
    252            CORE_EXIT_ATOMIC();
   \                     ??DMADRV_FreeChannel_2: (+1)
   \       0x2A   0x.... 0x....      BL       CORE_ExitAtomic
    253          
    254            return ECODE_EMDRV_DMADRV_ALREADY_FREED;
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable23_4
   \       0x32   0xBD10             POP      {R4,PC}
    255          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable23_7
   \        0x2   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable23_8
   \        0x2   0xBD10             POP      {R4,PC}
    256          
    257          /***************************************************************************//**
    258           * @brief
    259           *  Initialize DMADRV.
    260           *
    261           * @details
    262           *  The DMA hardware is initialized.
    263           *
    264           * @return
    265           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    266           *  DMADRV @ref Ecode_t is returned.
    267           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    268          Ecode_t DMADRV_Init(void)
    269          {
   \                     DMADRV_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    270            int i;
    271            CORE_DECLARE_IRQ_STATE;
    272          #if defined(EMDRV_DMADRV_UDMA)
    273            DMA_Init_TypeDef dmaInit;
    274          #elif defined(EMDRV_DMADRV_LDMA)
    275            LDMA_Init_t dmaInit = LDMA_INIT_DEFAULT;
   \        0x2   0x.... 0x....      ADR.W    R3,?_0
   \        0x6   0x681A             LDR      R2,[R3, #+0]
    276            dmaInit.ldmaInitCtrlNumFixed = EMDRV_DMADRV_DMA_CH_PRIORITY;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x9200             STR      R2,[SP, #+0]
   \        0xC   0xF88D 0x1000      STRB     R1,[SP, #+0]
    277          #elif defined(EMDRV_DMADRV_LDMA_S3)
    278            sl_hal_ldma_config_t dmaInit = SL_HAL_LDMA_INIT_DEFAULT;
    279            dmaInit.num_fixed_priority = EMDRV_DMADRV_DMA_CH_PRIORITY;
    280          #endif
    281          
    282            CORE_ENTER_ATOMIC();
   \       0x10   0x.... 0x....      BL       CORE_EnterAtomic
    283            if ( initialized ) {
   \       0x14   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x18   0xB121             CBZ.N    R1,??DMADRV_Init_0
    284              CORE_EXIT_ATOMIC();
   \       0x1A   0x.... 0x....      BL       CORE_ExitAtomic
    285              return ECODE_EMDRV_DMADRV_ALREADY_INITIALIZED;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable23_5
   \       0x22   0xBD02             POP      {R1,PC}
    286            }
    287            initialized = true;
   \                     ??DMADRV_Init_0: (+1)
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x7011             STRB     R1,[R2, #+0]
    288            CORE_EXIT_ATOMIC();
   \       0x28   0x.... 0x....      BL       CORE_ExitAtomic
    289          
    290            if ( EMDRV_DMADRV_DMA_IRQ_PRIORITY >= (1 << __NVIC_PRIO_BITS) ) {
    291              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
    292            }
    293          
    294            for ( i = 0; i < (int)EMDRV_DMADRV_DMA_CH_COUNT; i++ ) {
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \       0x32   0x2100             MOVS     R1,#+0
    295              chTable[i].allocated = false;
   \                     ??DMADRV_Init_1: (+1)
   \       0x34   0xEB00 0x1302      ADD      R3,R0,R2, LSL #+4
    296            }
   \       0x38   0x1C52             ADDS     R2,R2,#+1
   \       0x3A   0x2A08             CMP      R2,#+8
   \       0x3C   0x7319             STRB     R1,[R3, #+12]
   \       0x3E   0xDBF9             BLT.N    ??DMADRV_Init_1
    297          
    298          #if defined(EMDRV_DMADRV_UDMA)
    299            NVIC_SetPriority(DMA_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    300            dmaInit.hprot        = 0;
    301            dmaInit.controlBlock = dmaControlBlock;
    302            DMA_Init(&dmaInit);
    303          #elif defined(EMDRV_DMADRV_LDMA)
    304            dmaInit.ldmaInitIrqPriority = EMDRV_DMADRV_DMA_IRQ_PRIORITY;
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0xF88D 0x0003      STRB     R0,[SP, #+3]
    305            LDMA_Init(&dmaInit);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       LDMA_Init
    306          #elif defined(EMDRV_DMADRV_LDMA_S3)
    307            sl_hal_ldma_init(&dmaInit);
    308          
    309            NVIC_ClearPendingIRQ(LDMA_CHNL0_IRQn);
    310            NVIC_ClearPendingIRQ(LDMA_CHNL1_IRQn);
    311            NVIC_ClearPendingIRQ(LDMA_CHNL2_IRQn);
    312            NVIC_ClearPendingIRQ(LDMA_CHNL3_IRQn);
    313            NVIC_ClearPendingIRQ(LDMA_CHNL4_IRQn);
    314            NVIC_ClearPendingIRQ(LDMA_CHNL5_IRQn);
    315            NVIC_ClearPendingIRQ(LDMA_CHNL6_IRQn);
    316            NVIC_ClearPendingIRQ(LDMA_CHNL7_IRQn);
    317          
    318            NVIC_SetPriority(LDMA_CHNL0_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    319            NVIC_SetPriority(LDMA_CHNL1_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    320            NVIC_SetPriority(LDMA_CHNL2_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    321            NVIC_SetPriority(LDMA_CHNL3_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    322            NVIC_SetPriority(LDMA_CHNL4_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    323            NVIC_SetPriority(LDMA_CHNL5_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    324            NVIC_SetPriority(LDMA_CHNL6_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    325            NVIC_SetPriority(LDMA_CHNL7_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    326          
    327            NVIC_EnableIRQ(LDMA_CHNL0_IRQn);
    328            NVIC_EnableIRQ(LDMA_CHNL1_IRQn);
    329            NVIC_EnableIRQ(LDMA_CHNL2_IRQn);
    330            NVIC_EnableIRQ(LDMA_CHNL3_IRQn);
    331            NVIC_EnableIRQ(LDMA_CHNL4_IRQn);
    332            NVIC_EnableIRQ(LDMA_CHNL5_IRQn);
    333            NVIC_EnableIRQ(LDMA_CHNL6_IRQn);
    334            NVIC_EnableIRQ(LDMA_CHNL7_IRQn);
    335          
    336            sl_hal_ldma_enable();
    337          #endif
    338          
    339            return ECODE_EMDRV_DMADRV_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD02             POP      {R1,PC}
    340          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x460C             MOV      R4,R1
   \                     ??Subroutine15_0: (+1)
   \        0x2   0x....             LDR.N    R2,??DataTable23
   \        0x4   0x7811             LDRB     R1,[R2, #+0]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x1E 0x00          DC8 30, 0, 0, 3
   \              0x00 0x03
    341          
    342          #if defined(EMDRV_DMADRV_LDMA) || defined(DOXYGEN)
    343          /***************************************************************************//**
    344           * @brief
    345           *  Start an LDMA transfer.
    346           *
    347           * @details
    348           *  This function is similar to the emlib LDMA function.
    349           *
    350           * @param[in] channelId
    351           *  The channel ID to use.
    352           *
    353           * @param[in] transfer
    354           *  A DMA transfer configuration data structure.
    355           *
    356           * @param[in] descriptor
    357           *  A DMA transfer descriptor, can be an array of descriptors linked together.
    358           *
    359           * @param[in] callback
    360           *  An optional callback function for signalling completion. May be NULL if not
    361           *  needed.
    362           *
    363           * @param[in] cbUserParam
    364           *  An optional user parameter to feed to the callback function. May be NULL if
    365           *  not needed.
    366           *
    367           * @return
    368           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    369           *   DMADRV @ref Ecode_t is returned.
    370           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          Ecode_t DMADRV_LdmaStartTransfer(int                channelId,
    372                                           LDMA_TransferCfg_t *transfer,
    373                                           LDMA_Descriptor_t  *descriptor,
    374                                           DMADRV_Callback_t  callback,
    375                                           void               *cbUserParam)
    376          {
   \                     DMADRV_LdmaStartTransfer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    377            ChTable_t *ch;
    378          
    379            if ( !initialized ) {
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable23
   \        0x6   0x782C             LDRB     R4,[R5, #+0]
   \        0x8   0xB904             CBNZ.N   R4,??DMADRV_LdmaStartTransfer_0
    380              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xA   0x....             B.N      ?Subroutine2
    381            }
    382          
    383            if ( channelId >= (int)EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_LdmaStartTransfer_0: (+1)
   \        0xC   0x2808             CMP      R0,#+8
   \        0xE   0xDB00             BLT.N    ??DMADRV_LdmaStartTransfer_1
    384              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \       0x10   0x....             B.N      ?Subroutine1
    385            }
    386          
    387            ch = &chTable[channelId];
    388            if ( ch->allocated == false ) {
   \                     ??DMADRV_LdmaStartTransfer_1: (+1)
   \       0x12   0x.... 0x....      LDR.W    R6,??DataTable23_1
   \       0x16   0xEB06 0x1500      ADD      R5,R6,R0, LSL #+4
   \       0x1A   0x7B2C             LDRB     R4,[R5, #+12]
   \       0x1C   0xB914             CBNZ.N   R4,??DMADRV_LdmaStartTransfer_2
    389              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable23_6
   \       0x22   0xBD70             POP      {R4-R6,PC}
    390            }
   \                     ??DMADRV_LdmaStartTransfer_2: (+1)
   \       0x24   0x9C04             LDR      R4,[SP, #+16]
    391          
    392            ch->callback      = callback;
   \       0x26   0x602B             STR      R3,[R5, #+0]
    393            ch->userParam     = cbUserParam;
    394            ch->callbackCount = 0;
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x606C             STR      R4,[R5, #+4]
   \       0x2C   0x60AB             STR      R3,[R5, #+8]
    395            LDMA_StartTransfer(channelId, transfer, descriptor);
   \       0x2E   0x.... 0x....      BL       LDMA_StartTransfer
    396          
    397            return ECODE_EMDRV_DMADRV_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD70             POP      {R4-R6,PC}
    398          }
    399          #endif
    400          
    401          /***************************************************************************//**
    402           * @brief
    403           *  Start a memory to a peripheral DMA transfer.
    404           *
    405           * @param[in] channelId
    406           *  The channel ID to use for the transfer.
    407           *
    408           * @param[in] peripheralSignal
    409           *  Selects which peripheral/peripheralsignal to use.
    410           *
    411           * @param[in] dst
    412           *  A destination (peripheral register) memory address.
    413           *
    414           * @param[in] src
    415           *  A source memory address.
    416           *
    417           * @param[in] srcInc
    418           *  Set to true to enable source address increment (increments according to
    419           *  @a size parameter).
    420           *
    421           * @param[in] len
    422           *  A number of items (of @a size size) to transfer.
    423           *
    424           * @param[in] size
    425           *  An item size, byte, halfword or word.
    426           *
    427           * @param[in] callback
    428           *  A function to call on DMA completion, use NULL if not needed.
    429           *
    430           * @param[in] cbUserParam
    431           *  An optional user parameter to feed to the callback function. Use NULL if
    432           *  not needed.
    433           *
    434           * @return
    435           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    436           *   DMADRV @ref Ecode_t is returned.
    437           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    438          Ecode_t DMADRV_MemoryPeripheral(unsigned int          channelId,
    439                                          DMADRV_PeripheralSignal_t
    440                                          peripheralSignal,
    441                                          void                  *dst,
    442                                          void                  *src,
    443                                          bool                  srcInc,
    444                                          int                   len,
    445                                          DMADRV_DataSize_t     size,
    446                                          DMADRV_Callback_t     callback,
    447                                          void                  *cbUserParam)
    448          {
   \                     DMADRV_MemoryPeripheral: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    449            return StartTransfer(dmaModeBasic,
    450                                 dmaDirectionMemToPeripheral,
    451                                 channelId,
    452                                 peripheralSignal,
    453                                 dst,
    454                                 src,
    455                                 NULL,
    456                                 srcInc,
    457                                 len,
    458                                 size,
    459                                 callback,
    460                                 cbUserParam);
   \        0x4   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....             B.N      ?Subroutine0
    461          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      BL       StartTransfer
   \        0x6   0xB008             ADD      SP,SP,#+32
   \        0x8   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x9C10             LDR      R4,[SP, #+64]
   \        0x2   0x9D0F             LDR      R5,[SP, #+60]
   \        0x4   0x9E0D             LDR      R6,[SP, #+52]
   \        0x6   0x9407             STR      R4,[SP, #+28]
   \        0x8   0xF89D 0x4038      LDRB     R4,[SP, #+56]
   \        0xC   0x9506             STR      R5,[SP, #+24]
   \        0xE   0xF89D 0x5030      LDRB     R5,[SP, #+48]
   \       0x12   0x9405             STR      R4,[SP, #+20]
   \       0x14   0x9301             STR      R3,[SP, #+4]
   \       0x16   0x9200             STR      R2,[SP, #+0]
   \       0x18   0x2400             MOVS     R4,#+0
   \       0x1A   0x460B             MOV      R3,R1
   \       0x1C   0x4602             MOV      R2,R0
   \       0x1E   0x9604             STR      R6,[SP, #+16]
   \       0x20   0x9503             STR      R5,[SP, #+12]
   \       0x22   0x9402             STR      R4,[SP, #+8]
   \       0x24   0x4770             BX       LR
    462          
    463          /***************************************************************************//**
    464           * @brief
    465           *  Start a memory to a peripheral ping-pong DMA transfer.
    466           *
    467           * @param[in] channelId
    468           *  The channel ID to use for the transfer.
    469           *
    470           * @param[in] peripheralSignal
    471           *  Selects which peripheral/peripheralsignal to use.
    472           *
    473           * @param[in] dst
    474           *  A destination (peripheral register) memory address.
    475           *
    476           * @param[in] src0
    477           *  A source memory address of the first (ping) buffer.
    478           *
    479           * @param[in] src1
    480           *  A source memory address of the second (pong) buffer.
    481           *
    482           * @param[in] srcInc
    483           *  Set to true to enable source address increment (increments according to
    484           *  @a size parameter).
    485           *
    486           * @param[in] len
    487           *  A number of items (of @a size size) to transfer.
    488           *
    489           * @param[in] size
    490           *  An item size, byte, halfword or word.
    491           *
    492           * @param[in] callback
    493           *  A function to call on DMA completion, use NULL if not needed.
    494           *
    495           * @param[in] cbUserParam
    496           *  An optional user parameter to feed to the callback function. Use NULL if
    497           *  not needed.
    498           *
    499           * @return
    500           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    501           *   DMADRV @ref Ecode_t is returned.
    502           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    503          Ecode_t DMADRV_MemoryPeripheralPingPong(
    504            unsigned int          channelId,
    505            DMADRV_PeripheralSignal_t
    506            peripheralSignal,
    507            void                  *dst,
    508            void                  *src0,
    509            void                  *src1,
    510            bool                  srcInc,
    511            int                   len,
    512            DMADRV_DataSize_t     size,
    513            DMADRV_Callback_t     callback,
    514            void                  *cbUserParam)
    515          {
   \                     DMADRV_MemoryPeripheralPingPong: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    516            return StartTransfer(dmaModePingPong,
    517                                 dmaDirectionMemToPeripheral,
    518                                 channelId,
    519                                 peripheralSignal,
    520                                 dst,
    521                                 src0,
    522                                 src1,
    523                                 srcInc,
    524                                 len,
    525                                 size,
    526                                 callback,
    527                                 cbUserParam);
   \        0x4   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....             B.N      ?Subroutine12
    528          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x.... 0x....      BL       StartTransfer
   \        0x6   0xB009             ADD      SP,SP,#+36
   \        0x8   0xBD30             POP      {R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x9D11             LDR      R5,[SP, #+68]
   \        0x2   0x9C10             LDR      R4,[SP, #+64]
   \        0x4   0x9507             STR      R5,[SP, #+28]
   \        0x6   0xF89D 0x503C      LDRB     R5,[SP, #+60]
   \        0xA   0x9406             STR      R4,[SP, #+24]
   \        0xC   0x9C0E             LDR      R4,[SP, #+56]
   \        0xE   0x9505             STR      R5,[SP, #+20]
   \       0x10   0xF89D 0x5034      LDRB     R5,[SP, #+52]
   \       0x14   0x9404             STR      R4,[SP, #+16]
   \       0x16   0x9C0C             LDR      R4,[SP, #+48]
   \       0x18   0x9301             STR      R3,[SP, #+4]
   \       0x1A   0x9200             STR      R2,[SP, #+0]
   \       0x1C   0x460B             MOV      R3,R1
   \       0x1E   0x4602             MOV      R2,R0
   \       0x20   0x9503             STR      R5,[SP, #+12]
   \       0x22   0x9402             STR      R4,[SP, #+8]
   \       0x24   0x4770             BX       LR
    529          
    530          /***************************************************************************//**
    531           * @brief
    532           *  Start a peripheral to memory DMA transfer.
    533           *
    534           * @param[in] channelId
    535           *  The channel ID to use for the transfer.
    536           *
    537           * @param[in] peripheralSignal
    538           *  Selects which peripheral/peripheralsignal to use.
    539           *
    540           * @param[in] dst
    541           *  A destination memory address.
    542           *
    543           * @param[in] src
    544           *  A source memory (peripheral register) address.
    545           *
    546           * @param[in] dstInc
    547           *  Set to true to enable destination address increment (increments according
    548           *  to @a size parameter).
    549           *
    550           * @param[in] len
    551           *  A number of items (of @a size size) to transfer.
    552           *
    553           * @param[in] size
    554           *  An item size, byte, halfword or word.
    555           *
    556           * @param[in] callback
    557           *  A function to call on DMA completion, use NULL if not needed.
    558           *
    559           * @param[in] cbUserParam
    560           *  An optional user parameter to feed to the callback function. Use NULL if
    561           *  not needed.
    562           *
    563           * @return
    564           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    565           *   DMADRV @ref Ecode_t is returned.
    566           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    567          Ecode_t DMADRV_PeripheralMemory(unsigned int          channelId,
    568                                          DMADRV_PeripheralSignal_t
    569                                          peripheralSignal,
    570                                          void                  *dst,
    571                                          void                  *src,
    572                                          bool                  dstInc,
    573                                          int                   len,
    574                                          DMADRV_DataSize_t     size,
    575                                          DMADRV_Callback_t     callback,
    576                                          void                  *cbUserParam)
    577          {
   \                     DMADRV_PeripheralMemory: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    578            return StartTransfer(dmaModeBasic,
    579                                 dmaDirectionPeripheralToMem,
    580                                 channelId,
    581                                 peripheralSignal,
    582                                 dst,
    583                                 src,
    584                                 NULL,
    585                                 dstInc,
    586                                 len,
    587                                 size,
    588                                 callback,
    589                                 cbUserParam);
   \        0x4   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA                      REQUIRE ?Subroutine0
   \        0xA                      ;; // Fall through to label ?Subroutine0
    590          }
    591          
    592          /***************************************************************************//**
    593           * @brief
    594           *  Start a peripheral to memory ping-pong DMA transfer.
    595           *
    596           * @param[in] channelId
    597           *  The channel ID to use for the transfer.
    598           *
    599           * @param[in] peripheralSignal
    600           *  Selects which peripheral/peripheralsignal to use.
    601           *
    602           * @param[in] dst0
    603           *  A destination memory address of the first (ping) buffer.
    604           *
    605           * @param[in] dst1
    606           *  A destination memory address of the second (pong) buffer.
    607           *
    608           * @param[in] src
    609           *  A source memory (peripheral register) address.
    610           *
    611           * @param[in] dstInc
    612           *  Set to true to enable destination address increment (increments according
    613           *  to @a size parameter).
    614           *
    615           * @param[in] len
    616           *  A number of items (of @a size size) to transfer.
    617           *
    618           * @param[in] size
    619           *  An item size, byte, halfword or word.
    620           *
    621           * @param[in] callback
    622           *  A function to call on DMA completion, use NULL if not needed.
    623           *
    624           * @param[in] cbUserParam
    625           *  An optional user parameter to feed to the callback function. Use NULL if
    626           *  not needed.
    627           *
    628           * @return
    629           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    630           *   DMADRV @ref Ecode_t is returned.
    631           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    632          Ecode_t DMADRV_PeripheralMemoryPingPong(
    633            unsigned int          channelId,
    634            DMADRV_PeripheralSignal_t
    635            peripheralSignal,
    636            void                  *dst0,
    637            void                  *dst1,
    638            void                  *src,
    639            bool                  dstInc,
    640            int                   len,
    641            DMADRV_DataSize_t     size,
    642            DMADRV_Callback_t     callback,
    643            void                  *cbUserParam)
    644          {
   \                     DMADRV_PeripheralMemoryPingPong: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    645            return StartTransfer(dmaModePingPong,
    646                                 dmaDirectionPeripheralToMem,
    647                                 channelId,
    648                                 peripheralSignal,
    649                                 dst0,
    650                                 dst1,
    651                                 src,
    652                                 dstInc,
    653                                 len,
    654                                 size,
    655                                 callback,
    656                                 cbUserParam);
   \        0x4   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA                      REQUIRE ?Subroutine12
   \        0xA                      ;; // Fall through to label ?Subroutine12
    657          }
    658          
    659          /***************************************************************************//**
    660           * @brief
    661           *  Pause an ongoing DMA transfer.
    662           *
    663           * @param[in] channelId
    664           *  The channel ID of the transfer to pause.
    665           *
    666           * @return
    667           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    668           *  DMADRV @ref Ecode_t is returned.
    669           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    670          Ecode_t DMADRV_PauseTransfer(unsigned int channelId)
    671          {
   \                     DMADRV_PauseTransfer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    672            if ( !initialized ) {
   \        0x2   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_PauseTransfer_0
    673              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine11
    674            }
    675          
    676            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_PauseTransfer_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD300             BCC.N    ??DMADRV_PauseTransfer_1
    677              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \        0xE   0x....             B.N      ?Subroutine10
    678            }
    679          
    680            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_PauseTransfer_1: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x14   0xB901             CBNZ.N   R1,??DMADRV_PauseTransfer_2
    681              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x16   0x....             B.N      ?Subroutine9
    682            }
    683          
    684          #if defined(EMDRV_DMADRV_UDMA)
    685            DMA_ChannelRequestEnable(channelId, false);
    686          #elif defined(EMDRV_DMADRV_LDMA)
    687            LDMA_EnableChannelRequest(channelId, false);
   \                     ??DMADRV_PauseTransfer_2: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x....             B.N      ?Subroutine8
    688          #elif defined(EMDRV_DMADRV_LDMA_S3)
    689            sl_hal_ldma_disable_channel_request(channelId);
    690          #endif
    691          
    692            return ECODE_EMDRV_DMADRV_OK;
    693          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable23_7
   \        0x2   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable23_8
   \        0x2   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable23_6
   \        0x2   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x.... 0x....      BL       LDMA_EnableChannelRequest
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable23_1
   \        0x2   0xEB03 0x1200      ADD      R2,R3,R0, LSL #+4
   \        0x6   0x7B11             LDRB     R1,[R2, #+12]
   \        0x8   0x4770             BX       LR
    694          
    695          /***************************************************************************//**
    696           * @brief
    697           *  Resume an ongoing DMA transfer.
    698           *
    699           * @param[in] channelId
    700           *  The channel ID of the transfer to resume.
    701           *
    702           * @return
    703           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    704           *  DMADRV @ref Ecode_t is returned.
    705           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    706          Ecode_t DMADRV_ResumeTransfer(unsigned int channelId)
    707          {
   \                     DMADRV_ResumeTransfer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    708            if ( !initialized ) {
   \        0x2   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_ResumeTransfer_0
    709              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine11
    710            }
    711          
    712            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_ResumeTransfer_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD300             BCC.N    ??DMADRV_ResumeTransfer_1
    713              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \        0xE   0x....             B.N      ?Subroutine10
    714            }
    715          
    716            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_ResumeTransfer_1: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x14   0xB901             CBNZ.N   R1,??DMADRV_ResumeTransfer_2
    717              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x16   0x....             B.N      ?Subroutine9
    718            }
    719          
    720          #if defined(EMDRV_DMADRV_UDMA)
    721            DMA_ChannelRequestEnable(channelId, true);
    722          #elif defined(EMDRV_DMADRV_LDMA)
    723            LDMA_EnableChannelRequest(channelId, true);
   \                     ??DMADRV_ResumeTransfer_2: (+1)
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x....             B.N      ?Subroutine8
    724          #elif defined(EMDRV_DMADRV_LDMA_S3)
    725            sl_hal_ldma_enable_channel_request(channelId);
    726          #endif
    727          
    728            return ECODE_EMDRV_DMADRV_OK;
    729          }
    730          
    731          /***************************************************************************//**
    732           * @brief
    733           *  Stop an ongoing DMA transfer.
    734           *
    735           * @param[in] channelId
    736           *  The channel ID of the transfer to stop.
    737           *
    738           * @return
    739           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    740           *  DMADRV @ref Ecode_t is returned.
    741           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    742          Ecode_t DMADRV_StopTransfer(unsigned int channelId)
    743          {
   \                     DMADRV_StopTransfer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    744            if ( !initialized ) {
   \        0x2   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_StopTransfer_0
    745              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine11
    746            }
    747          
    748            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_StopTransfer_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD300             BCC.N    ??DMADRV_StopTransfer_1
    749              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \        0xE   0x....             B.N      ?Subroutine10
    750            }
    751          
    752            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_StopTransfer_1: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x14   0xB901             CBNZ.N   R1,??DMADRV_StopTransfer_2
    753              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x16   0x....             B.N      ?Subroutine9
    754            }
    755          
    756          #if defined(EMDRV_DMADRV_UDMA)
    757            DMA_ChannelEnable(channelId, false);
    758          #elif defined(EMDRV_DMADRV_LDMA)
    759            LDMA_StopTransfer(channelId);
   \                     ??DMADRV_StopTransfer_2: (+1)
   \       0x18   0x.... 0x....      BL       LDMA_StopTransfer
    760          #elif defined(EMDRV_DMADRV_LDMA_S3)
    761            sl_hal_ldma_stop_transfer(channelId);
    762          #endif
    763          
    764            return ECODE_EMDRV_DMADRV_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD02             POP      {R1,PC}
    765          }
    766          
    767          /***************************************************************************//**
    768           * @brief
    769           *  Check if a transfer is running.
    770           *
    771           * @param[in] channelId
    772           *  The channel ID of the transfer to check.
    773           *
    774           * @param[out] active
    775           *  True if transfer is running, false otherwise.
    776           *
    777           * @return
    778           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    779           *  DMADRV @ref Ecode_t is returned.
    780           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    781          Ecode_t DMADRV_TransferActive(unsigned int channelId, bool *active)
    782          {
   \                     DMADRV_TransferActive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    783            if ( !initialized ) {
   \        0x2   0x....             LDR.N    R3,??DataTable23
   \        0x4   0x781A             LDRB     R2,[R3, #+0]
   \        0x6   0xB902             CBNZ.N   R2,??DMADRV_TransferActive_0
    784              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine6
    785            }
    786          
    787            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    788                 || (active == NULL) ) {
   \                     ??DMADRV_TransferActive_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferActive_1
   \        0xE   0xB901             CBNZ.N   R1,??DMADRV_TransferActive_2
    789              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferActive_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine5
    790            }
    791          
    792            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferActive_2: (+1)
   \       0x12   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x16   0xB902             CBNZ.N   R2,??DMADRV_TransferActive_3
    793              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine7
    794            }
    795          
    796          #if defined(EMDRV_DMADRV_UDMA)
    797            if ( DMA_ChannelEnabled(channelId) )
    798          #elif defined(EMDRV_DMADRV_LDMA)
    799            if ( LDMA_ChannelEnabled(channelId) )
   \                     ??DMADRV_TransferActive_3: (+1)
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xD207             BCS.N    ??DMADRV_TransferActive_4
   \       0x1E   0x....             LDR.N    R3,??DataTable23_9
   \       0x20   0x681A             LDR      R2,[R3, #+0]
   \       0x22   0x40C2             LSRS     R2,R2,R0
   \       0x24   0xF012 0x0001      ANDS     R0,R2,#0x1
   \       0x28   0xD002             BEQ.N    ??DMADRV_TransferActive_5
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE000             B.N      ??DMADRV_TransferActive_5
    800          #elif defined(EMDRV_DMADRV_LDMA_S3)
    801            if ( sl_hal_ldma_channel_is_enabled(channelId) )
    802          #endif
    803            {
    804              *active = true;
    805            } else {
    806              *active = false;
   \                     ??DMADRV_TransferActive_4: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
    807            }
   \                     ??DMADRV_TransferActive_5: (+1)
   \       0x30   0x....             B.N      ?Subroutine4
    808          
    809            return ECODE_EMDRV_DMADRV_OK;
    810          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x....             LDR.N    R4,??DataTable23_1
   \        0x2   0xEB04 0x1300      ADD      R3,R4,R0, LSL #+4
   \        0x6   0x7B1A             LDRB     R2,[R3, #+12]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable23_6
   \        0x2   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x7008             STRB     R0,[R1, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xBD10             POP      {R4,PC}
    811          
    812          /***************************************************************************//**
    813           * @brief
    814           *  Check if a transfer complete is pending.
    815           *
    816           * @details
    817           *  Will check the channel interrupt flag. This assumes that the DMA is configured
    818           *  to give a completion interrupt.
    819           *
    820           * @param[in] channelId
    821           *  The channel ID of the transfer to check.
    822           *
    823           * @param[out] pending
    824           *  True if a transfer complete is pending, false otherwise.
    825           *
    826           * @return
    827           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    828           *  DMADRV @ref Ecode_t is returned.
    829           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    830          Ecode_t DMADRV_TransferCompletePending(unsigned int channelId, bool *pending)
    831          {
   \                     DMADRV_TransferCompletePending: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    832            if ( !initialized ) {
   \        0x2   0x....             LDR.N    R3,??DataTable23
   \        0x4   0x781A             LDRB     R2,[R3, #+0]
   \        0x6   0xB902             CBNZ.N   R2,??DMADRV_TransferCompletePending_0
    833              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine6
    834            }
    835          
    836            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    837                 || (pending == NULL) ) {
   \                     ??DMADRV_TransferCompletePending_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferCompletePending_1
   \        0xE   0xB901             CBNZ.N   R1,??DMADRV_TransferCompletePending_2
    838              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferCompletePending_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine5
    839            }
    840          
    841            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferCompletePending_2: (+1)
   \       0x12   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x16   0xB902             CBNZ.N   R2,??DMADRV_TransferCompletePending_3
    842              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine7
    843            }
    844          
    845          #if defined(EMDRV_DMADRV_UDMA)
    846            if ( DMA->IF & (1 << channelId) )
    847          #elif defined(EMDRV_DMADRV_LDMA)
    848            if ( LDMA->IF & (1 << channelId) )
   \                     ??DMADRV_TransferCompletePending_3: (+1)
   \       0x1A   0x....             LDR.N    R3,??DataTable23_10
   \       0x1C   0x681A             LDR      R2,[R3, #+0]
   \       0x1E   0x40C2             LSRS     R2,R2,R0
   \       0x20   0xF012 0x0001      ANDS     R0,R2,#0x1
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2001             MOVNE    R0,#+1
   \       0x28   0x....             B.N      ?Subroutine4
    849          #elif defined(EMDRV_DMADRV_LDMA_S3)
    850            if ( sl_hal_ldma_get_interrupts() & (1 << channelId) )
    851          #endif
    852            {
    853              *pending = true;
    854            } else {
    855              *pending = false;
    856            }
    857          
    858            return ECODE_EMDRV_DMADRV_OK;
    859          }
    860          
    861          /***************************************************************************//**
    862           * @brief
    863           *  Check if a transfer has completed.
    864           *
    865           * @note
    866           *  This function should be used in a polled environment.
    867           *  Will only work reliably for transfers NOT using the completion interrupt.
    868           *  On UDMA, it will only work on basic transfers on the primary channel.
    869           *
    870           * @param[in] channelId
    871           *  The channel ID of the transfer to check.
    872           *
    873           * @param[out] done
    874           *  True if a transfer has completed, false otherwise.
    875           *
    876           * @return
    877           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    878           *  DMADRV @ref Ecode_t is returned.
    879           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    880          Ecode_t DMADRV_TransferDone(unsigned int channelId, bool *done)
    881          {
   \                     DMADRV_TransferDone: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine15
    882          #if defined(EMDRV_DMADRV_UDMA)
    883            uint32_t remaining, iflag;
    884          #endif
    885          
    886            if ( !initialized ) {
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_TransferDone_0
    887              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine6
    888            }
    889          
    890            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    891                 || (done == NULL) ) {
   \                     ??DMADRV_TransferDone_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferDone_1
   \        0xE   0xB904             CBNZ.N   R4,??DMADRV_TransferDone_2
    892              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferDone_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine5
    893            }
    894          
    895            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferDone_2: (+1)
   \       0x12   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x16   0xB901             CBNZ.N   R1,??DMADRV_TransferDone_3
    896              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine7
    897            }
    898          
    899          #if defined(EMDRV_DMADRV_UDMA)
    900            CORE_ATOMIC_SECTION(
    901              /* This works for primary channel only ! */
    902              remaining = (dmaControlBlock[channelId].CTRL
    903                           & _DMA_CTRL_N_MINUS_1_MASK)
    904                          >> _DMA_CTRL_N_MINUS_1_SHIFT;
    905              iflag = DMA->IF;
    906              )
    907          
    908            if ( (remaining == 0) && (iflag & (1 << channelId)) ) {
    909              *done = true;
    910            } else {
    911              *done = false;
    912            }
    913          #elif defined(EMDRV_DMADRV_LDMA)
    914            *done = LDMA_TransferDone(channelId);
   \                     ??DMADRV_TransferDone_3: (+1)
   \       0x1A   0x.... 0x....      BL       LDMA_TransferDone
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
    915          #elif defined(EMDRV_DMADRV_LDMA_S3)
    916            *done = sl_hal_ldma_transfer_is_done(channelId);
    917          #endif
    918          
    919            return ECODE_EMDRV_DMADRV_OK;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD10             POP      {R4,PC}
    920          }
    921          
    922          /***************************************************************************//**
    923           * @brief
    924           *  Get number of items remaining in a transfer.
    925           *
    926           * @note
    927           *  This function does not take into account that a DMA transfer with
    928           *  a chain of linked transfers might be ongoing. It will only check the
    929           *  count for the current transfer.
    930           *  On UDMA, it will only work on the primary channel.
    931           *
    932           * @param[in] channelId
    933           *  The channel ID of the transfer to check.
    934           *
    935           * @param[out] remaining
    936           *  A number of items remaining in the transfer.
    937           *
    938           * @return
    939           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    940           *  DMADRV @ref Ecode_t is returned.
    941           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    942          Ecode_t DMADRV_TransferRemainingCount(unsigned int channelId,
    943                                                int *remaining)
    944          {
   \                     DMADRV_TransferRemainingCount: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine15
    945          #if defined(EMDRV_DMADRV_UDMA)
    946            uint32_t remain, iflag;
    947          #endif
    948          
    949            if ( !initialized ) {
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_TransferRemainingCount_0
    950              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine6
    951            }
    952          
    953            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    954                 || (remaining == NULL) ) {
   \                     ??DMADRV_TransferRemainingCount_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferRemainingCount_1
   \        0xE   0xB904             CBNZ.N   R4,??DMADRV_TransferRemainingCount_2
    955              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferRemainingCount_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine5
    956            }
    957          
    958            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferRemainingCount_2: (+1)
   \       0x12   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x16   0xB901             CBNZ.N   R1,??DMADRV_TransferRemainingCount_3
    959              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine7
    960            }
    961          
    962          #if defined(EMDRV_DMADRV_UDMA)
    963            CORE_ATOMIC_SECTION(
    964              /* This works for the primary channel only ! */
    965              remain = (dmaControlBlock[channelId].CTRL
    966                        & _DMA_CTRL_N_MINUS_1_MASK)
    967                       >> _DMA_CTRL_N_MINUS_1_SHIFT;
    968              iflag = DMA->IF;
    969              )
    970          
    971            if ( (remain == 0) && (iflag & (1 << channelId)) ) {
    972              *remaining = 0;
    973            } else {
    974              *remaining = 1 + remain;
    975            }
    976          #elif defined(EMDRV_DMADRV_LDMA)
    977            *remaining = LDMA_TransferRemainingCount(channelId);
   \                     ??DMADRV_TransferRemainingCount_3: (+1)
   \       0x1A   0x.... 0x....      BL       LDMA_TransferRemainingCount
   \       0x1E   0x6020             STR      R0,[R4, #+0]
    978          #elif defined(EMDRV_DMADRV_LDMA_S3)
    979            *remaining = sl_hal_ldma_transfer_remaining_count(channelId);
    980          #endif
    981          
    982            return ECODE_EMDRV_DMADRV_OK;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD10             POP      {R4,PC}
    983          }
    984          
    985          /// @cond DO_NOT_INCLUDE_WITH_DOXYGEN
    986          
    987          #if defined(EMDRV_DMADRV_LDMA)
    988          /***************************************************************************//**
    989           * @brief
    990           *  An interrupt handler for LDMA.
    991           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    992          void LDMA_IRQHandler(void)
    993          {
   \                     LDMA_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    994            bool stop;
    995            ChTable_t *ch;
    996            uint32_t pending, chnum, chmask;
    997          
    998            /* Get all pending and enabled interrupts. */
    999            pending  = LDMA->IF;
   \        0x2   0x....             LDR.N    R1,??DataTable23_10
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   1000            pending &= LDMA->IEN;
   \        0x6   0x684C             LDR      R4,[R1, #+4]
   \        0x8   0x4004             ANDS     R4,R4,R0
   1001          
   1002            /* Check for LDMA error. */
   1003            if ( pending & LDMA_IF_ERROR ) {
   \        0xA   0xD500             BPL.N    ??LDMA_IRQHandler_0
   1004              /* Loop to enable debugger to see what has happened. */
   1005              while (true) {
   \                     ??LDMA_IRQHandler_1: (+1)
   \        0xC   0xE7FE             B.N      ??LDMA_IRQHandler_1
   1006                /* Wait forever. */
   1007              }
   1008            }
   1009          
   1010            /* Iterate over all LDMA channels. */
   1011            for ( chnum = 0, chmask = 1;
   \                     ??LDMA_IRQHandler_0: (+1)
   \        0xE   0x2500             MOVS     R5,#+0
   \       0x10   0x2701             MOVS     R7,#+1
   1012                  chnum < EMDRV_DMADRV_DMA_CH_COUNT;
   1013                  chnum++, chmask <<= 1 ) {
   1014              if ( pending & chmask ) {
   \                     ??LDMA_IRQHandler_2: (+1)
   \       0x12   0x423C             TST      R4,R7
   \       0x14   0xD020             BEQ.N    ??LDMA_IRQHandler_3
   1015                /* Clear the interrupt flag. */
   1016          #if defined (LDMA_HAS_SET_CLEAR)
   1017                LDMA->IF_CLR = chmask;
   1018          #else
   1019                LDMA->IFC = chmask;
   1020          #endif
   1021          
   1022                ch = &chTable[chnum];
   1023                if ( ch->callback != NULL ) {
   \       0x16   0x....             LDR.N    R2,??DataTable23_1
   \       0x18   0xEB02 0x1605      ADD      R6,R2,R5, LSL #+4
   \       0x1C   0x....             LDR.N    R3,??DataTable23_11
   \       0x1E   0x601F             STR      R7,[R3, #+0]
   \       0x20   0x6830             LDR      R0,[R6, #+0]
   \       0x22   0xB1C8             CBZ.N    R0,??LDMA_IRQHandler_3
   1024                  ch->callbackCount++;
   \       0x24   0x68B0             LDR      R0,[R6, #+8]
   1025                  stop = !ch->callback(chnum, ch->callbackCount, ch->userParam);
   \       0x26   0x6872             LDR      R2,[R6, #+4]
   \       0x28   0x6833             LDR      R3,[R6, #+0]
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0x60B0             STR      R0,[R6, #+8]
   \       0x2E   0x4601             MOV      R1,R0
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x4798             BLX      R3
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xBF04             ITT      EQ
   \       0x38   0x7B70             LDRBEQ   R0,[R6, #+13]
   \       0x3A   0x2801             CMPEQ    R0,#+1
   1026          
   1027                  if ( (ch->mode == dmaModePingPong) && stop ) {
   \       0x3C   0xD10C             BNE.N    ??LDMA_IRQHandler_3
   1028                    dmaXfer[chnum].desc[0].xfer.link = 0;
   \       0x3E   0x....             LDR.N    R1,??DataTable23_12
   \       0x40   0xEB01 0x1045      ADD      R0,R1,R5, LSL #+5
   \       0x44   0x68C2             LDR      R2,[R0, #+12]
   \       0x46   0xF022 0x0202      BIC      R2,R2,#0x2
   \       0x4A   0x60C2             STR      R2,[R0, #+12]
   1029                    dmaXfer[chnum].desc[1].xfer.link = 0;
   \       0x4C   0xF100 0x0110      ADD      R1,R0,#+16
   \       0x50   0x68C8             LDR      R0,[R1, #+12]
   \       0x52   0xF020 0x0002      BIC      R0,R0,#0x2
   \       0x56   0x60C8             STR      R0,[R1, #+12]
   1030                  }
   1031                }
   1032              }
   1033            }
   \                     ??LDMA_IRQHandler_3: (+1)
   \       0x58   0x1C6D             ADDS     R5,R5,#+1
   \       0x5A   0x007F             LSLS     R7,R7,#+1
   \       0x5C   0x2D08             CMP      R5,#+8
   \       0x5E   0xD3D8             BCC.N    ??LDMA_IRQHandler_2
   1034          }
   \       0x60   0xBDF1             POP      {R0,R4-R7,PC}
   1035          #endif /* defined( EMDRV_DMADRV_LDMA ) */
   1036          
   1037          #if defined(EMDRV_DMADRV_LDMA_S3)
   1038          /***************************************************************************//**
   1039           * @brief
   1040           *  Default interrupt handler for LDMA common to all interrupt channel lines.
   1041           *
   1042           * @param[in] chnum
   1043           *  The channel ID responsible for the interrupt signal trigger.
   1044           ******************************************************************************/
   1045          static void LDMA_IRQHandlerDefault(uint8_t chnum)
   1046          {
   1047            bool stop;
   1048            ChTable_t *ch;
   1049            uint32_t pending;
   1050            uint32_t chmask;
   1051          
   1052            /* Get all pending and enabled interrupts. */
   1053            pending = sl_hal_ldma_get_enabled_interrupts();
   1054          
   1055            /* Check for LDMA error. */
   1056            if ( pending & (LDMA_IF_ERROR0 << chnum) ) {
   1057              /* Loop to enable debugger to see what has happened. */
   1058              while (true) {
   1059                /* Wait forever. */
   1060              }
   1061            }
   1062          
   1063            chmask = 1 << chnum;
   1064            if ( pending & chmask ) {
   1065              /* Clear the interrupt flag. */
   1066              sl_hal_ldma_clear_interrupts(chmask);
   1067          
   1068              /* Callback called if it was provided for the given channel. */
   1069              ch = &chTable[chnum];
   1070              if ( ch->callback != NULL ) {
   1071                ch->callbackCount++;
   1072                stop = !ch->callback(chnum, ch->callbackCount, ch->userParam);
   1073          
   1074                /* Continue or not a ping-pong transfer. */
   1075                if ( (ch->mode == dmaModePingPong) && stop ) {
   1076                  dmaXfer[chnum].desc[0].xfer.link = 0;
   1077                  dmaXfer[chnum].desc[1].xfer.link = 0;
   1078                }
   1079              }
   1080            }
   1081          }
   1082          
   1083          /***************************************************************************//**
   1084           * @brief
   1085           *  Root interrupt handler for LDMA channel 0.
   1086           ******************************************************************************/
   1087          void LDMA_CHNL0_IRQHandler(void)
   1088          {
   1089            LDMA_IRQHandlerDefault(0);
   1090          }
   1091          
   1092          /***************************************************************************//**
   1093           * @brief
   1094           *  Root interrupt handler for LDMA channel 1.
   1095           ******************************************************************************/
   1096          void LDMA_CHNL1_IRQHandler(void)
   1097          {
   1098            LDMA_IRQHandlerDefault(1);
   1099          }
   1100          
   1101          /***************************************************************************//**
   1102           * @brief
   1103           *  Root interrupt handler for LDMA channel 2.
   1104           ******************************************************************************/
   1105          void LDMA_CHNL2_IRQHandler(void)
   1106          {
   1107            LDMA_IRQHandlerDefault(2);
   1108          }
   1109          
   1110          /***************************************************************************//**
   1111           * @brief
   1112           *  Root interrupt handler for LDMA channel 3.
   1113           ******************************************************************************/
   1114          void LDMA_CHNL3_IRQHandler(void)
   1115          {
   1116            LDMA_IRQHandlerDefault(3);
   1117          }
   1118          
   1119          /***************************************************************************//**
   1120           * @brief
   1121           *  Root interrupt handler for LDMA channel 4.
   1122           ******************************************************************************/
   1123          void LDMA_CHNL4_IRQHandler(void)
   1124          {
   1125            LDMA_IRQHandlerDefault(4);
   1126          }
   1127          
   1128          /***************************************************************************//**
   1129           * @brief
   1130           *  Root interrupt handler for LDMA channel 5.
   1131           ******************************************************************************/
   1132          void LDMA_CHNL5_IRQHandler(void)
   1133          {
   1134            LDMA_IRQHandlerDefault(5);
   1135          }
   1136          
   1137          /***************************************************************************//**
   1138           * @brief
   1139           *  Root interrupt handler for LDMA channel 6.
   1140           ******************************************************************************/
   1141          void LDMA_CHNL6_IRQHandler(void)
   1142          {
   1143            LDMA_IRQHandlerDefault(6);
   1144          }
   1145          
   1146          /***************************************************************************//**
   1147           * @brief
   1148           *  Root interrupt handler for LDMA channel 7.
   1149           ******************************************************************************/
   1150          void LDMA_CHNL7_IRQHandler(void)
   1151          {
   1152            LDMA_IRQHandlerDefault(7);
   1153          }
   1154          
   1155          #endif /* defined( EMDRV_DMADRV_LDMA_S3 ) */
   1156          
   1157          #if defined(EMDRV_DMADRV_UDMA)
   1158          /***************************************************************************//**
   1159           * @brief
   1160           *  A callback function for UDMA basic transfers.
   1161           ******************************************************************************/
   1162          static void DmaBasicCallback(unsigned int channel, bool primary, void *user)
   1163          {
   1164            ChTable_t *ch = &chTable[channel];
   1165            (void)user;
   1166            (void)primary;
   1167          
   1168            if ( ch->callback != NULL ) {
   1169              ch->callbackCount++;
   1170              ch->callback(channel, ch->callbackCount, ch->userParam);
   1171            }
   1172          }
   1173          #endif
   1174          
   1175          #if defined(EMDRV_DMADRV_UDMA)
   1176          /***************************************************************************//**
   1177           * @brief
   1178           *  A callback function for UDMA ping-pong transfers.
   1179           ******************************************************************************/
   1180          static void DmaPingPongCallback(unsigned int channel, bool primary, void *user)
   1181          {
   1182            bool stop = true;
   1183            ChTable_t *ch = &chTable[channel];
   1184          
   1185            (void)user;
   1186          
   1187            if ( ch->callback != NULL ) {
   1188              ch->callbackCount++;
   1189              stop = !ch->callback(channel, ch->callbackCount, ch->userParam);
   1190            }
   1191          
   1192            DMA_RefreshPingPong(channel,
   1193                                primary,
   1194                                false,
   1195                                NULL,
   1196                                NULL,
   1197                                ch->length - 1,
   1198                                stop);
   1199          }
   1200          #endif
   1201          
   1202          #if defined(EMDRV_DMADRV_UDMA)
   1203          /***************************************************************************//**
   1204           * @brief
   1205           *  Start a UDMA transfer.
   1206           ******************************************************************************/
   1207          static Ecode_t StartTransfer(DmaMode_t             mode,
   1208                                       DmaDirection_t        direction,
   1209                                       unsigned int          channelId,
   1210                                       DMADRV_PeripheralSignal_t
   1211                                       peripheralSignal,
   1212                                       void                  *buf0,
   1213                                       void                  *buf1,
   1214                                       void                  *buf2,
   1215                                       bool                  bufInc,
   1216                                       int                   len,
   1217                                       DMADRV_DataSize_t     size,
   1218                                       DMADRV_Callback_t     callback,
   1219                                       void                  *cbUserParam)
   1220          {
   1221            ChTable_t *ch;
   1222            DMA_CfgChannel_TypeDef chCfg;
   1223            DMA_CfgDescr_TypeDef   descrCfg;
   1224          
   1225            if ( !initialized ) {
   1226              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   1227            }
   1228          
   1229            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
   1230                 || (buf0 == NULL)
   1231                 || (buf1 == NULL)
   1232                 || (len > DMADRV_MAX_XFER_COUNT)
   1233                 || ((mode == dmaModePingPong) && (buf2 == NULL)) ) {
   1234              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   1235            }
   1236          
   1237            ch = &chTable[channelId];
   1238            if ( ch->allocated == false ) {
   1239              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   1240            }
   1241          
   1242            /* Se tup the interrupt callback routine. */
   1243            if ( mode == dmaModeBasic ) {
   1244              dmaCallBack[channelId].cbFunc  = DmaBasicCallback;
   1245            } else {
   1246              dmaCallBack[channelId].cbFunc  = DmaPingPongCallback;
   1247            }
   1248            dmaCallBack[channelId].userPtr = NULL;
   1249          
   1250            /* Set up the channel */
   1251            chCfg.highPri = false;              /* Can't use hi pri with peripherals. */
   1252          
   1253            /* Whether the interrupt is needed. */
   1254            if ( (callback != NULL) || (mode == dmaModePingPong) ) {
   1255              chCfg.enableInt = true;
   1256            } else {
   1257              chCfg.enableInt = false;
   1258            }
   1259            chCfg.select = peripheralSignal;
   1260            chCfg.cb     = &dmaCallBack[channelId];
   1261            DMA_CfgChannel(channelId, &chCfg);
   1262          
   1263            /* Set up the channel descriptor. */
   1264            if ( direction == dmaDirectionMemToPeripheral ) {
   1265              if ( bufInc ) {
   1266                if ( size == dmadrvDataSize1 ) {
   1267                  descrCfg.srcInc = dmaDataInc1;
   1268                } else if ( size == dmadrvDataSize2 ) {
   1269                  descrCfg.srcInc = dmaDataInc2;
   1270                } else { /* dmadrvDataSize4 */
   1271                  descrCfg.srcInc = dmaDataInc4;
   1272                }
   1273              } else {
   1274                descrCfg.srcInc = dmaDataIncNone;
   1275              }
   1276              descrCfg.dstInc = dmaDataIncNone;
   1277            } else {
   1278              if ( bufInc ) {
   1279                if ( size == dmadrvDataSize1 ) {
   1280                  descrCfg.dstInc = dmaDataInc1;
   1281                } else if ( size == dmadrvDataSize2 ) {
   1282                  descrCfg.dstInc = dmaDataInc2;
   1283                } else { /* dmadrvDataSize4 */
   1284                  descrCfg.dstInc = dmaDataInc4;
   1285                }
   1286              } else {
   1287                descrCfg.dstInc = dmaDataIncNone;
   1288              }
   1289              descrCfg.srcInc = dmaDataIncNone;
   1290            }
   1291            descrCfg.size    = (DMA_DataSize_TypeDef)size;
   1292            descrCfg.arbRate = dmaArbitrate1;
   1293            descrCfg.hprot   = 0;
   1294            DMA_CfgDescr(channelId, true, &descrCfg);
   1295            if ( mode == dmaModePingPong ) {
   1296              DMA_CfgDescr(channelId, false, &descrCfg);
   1297            }
   1298          
   1299            ch->callback      = callback;
   1300            ch->userParam     = cbUserParam;
   1301            ch->callbackCount = 0;
   1302            ch->length        = len;
   1303          
   1304            DMA->IFC = 1 << channelId;
   1305          
   1306            /* Start the DMA cycle. */
   1307            if ( mode == dmaModeBasic ) {
   1308              DMA_ActivateBasic(channelId, true, false, buf0, buf1, len - 1);
   1309            } else {
   1310              if ( direction == dmaDirectionMemToPeripheral ) {
   1311                DMA_ActivatePingPong(channelId,
   1312                                     false,
   1313                                     buf0,                              /* dest */
   1314                                     buf1,                              /* src  */
   1315                                     len - 1,
   1316                                     buf0,                              /* dest */
   1317                                     buf2,                              /* src  */
   1318                                     len - 1);
   1319              } else {
   1320                DMA_ActivatePingPong(channelId,
   1321                                     false,
   1322                                     buf0,                              /* dest */
   1323                                     buf2,                              /* src  */
   1324                                     len - 1,
   1325                                     buf1,                              /* dest */
   1326                                     buf2,                              /* src  */
   1327                                     len - 1);
   1328              }
   1329            }
   1330          
   1331            return ECODE_EMDRV_DMADRV_OK;
   1332          }
   1333          #endif /* defined( EMDRV_DMADRV_UDMA ) */
   1334          
   1335          #if defined(EMDRV_DMADRV_LDMA)
   1336          /***************************************************************************//**
   1337           * @brief
   1338           *  Start an LDMA transfer.
   1339           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1340          static Ecode_t StartTransfer(DmaMode_t             mode,
   1341                                       DmaDirection_t        direction,
   1342                                       unsigned int          channelId,
   1343                                       DMADRV_PeripheralSignal_t
   1344                                       peripheralSignal,
   1345                                       void                  *buf0,
   1346                                       void                  *buf1,
   1347                                       void                  *buf2,
   1348                                       bool                  bufInc,
   1349                                       int                   len,
   1350                                       DMADRV_DataSize_t     size,
   1351                                       DMADRV_Callback_t     callback,
   1352                                       void                  *cbUserParam)
   1353          {
   \                     StartTransfer: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4699             MOV      R9,R3
   1354            ChTable_t *ch;
   1355            LDMA_TransferCfg_t xfer;
   1356            LDMA_Descriptor_t *desc;
   1357          
   1358            if ( !initialized ) {
   \        0x6   0x....             LDR.N    R4,??DataTable23
   \        0x8   0x7823             LDRB     R3,[R4, #+0]
   \        0xA   0xB087             SUB      SP,SP,#+28
   \        0xC   0xB90B             CBNZ.N   R3,??StartTransfer_0
   1359              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xE   0x....             LDR.N    R0,??DataTable23_7
   \       0x10   0xE08F             B.N      ??StartTransfer_1
   1360            }
   \                     ??StartTransfer_0: (+1)
   \       0x12   0x9201             STR      R2,[SP, #+4]
   1361          
   1362            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
   1363                 || (buf0 == NULL)
   1364                 || (buf1 == NULL)
   1365                 || (len > DMADRV_MAX_XFER_COUNT)
   1366                 || ((mode == dmaModePingPong) && (buf2 == NULL)) ) {
   \       0x14   0x2A08             CMP      R2,#+8
   \       0x16   0xD212             BCS.N    ??StartTransfer_2
   \       0x18   0x9C10             LDR      R4,[SP, #+64]
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xBF1C             ITT      NE
   \       0x1E   0x9D11             LDRNE    R5,[SP, #+68]
   \       0x20   0x2D00             CMPNE    R5,#+0
   \       0x22   0xD00C             BEQ.N    ??StartTransfer_2
   \       0x24   0xF8DD 0xB050      LDR      R11,[SP, #+80]
   \       0x28   0xF640 0x0201      MOVW     R2,#+2049
   \       0x2C   0x4593             CMP      R11,R2
   \       0x2E   0xDA06             BGE.N    ??StartTransfer_2
   \       0x30   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x34   0x9E12             LDR      R6,[SP, #+72]
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xBF08             IT       EQ
   \       0x3A   0x2E00             CMPEQ    R6,#+0
   \       0x3C   0xD101             BNE.N    ??StartTransfer_3
   1367              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??StartTransfer_2: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable23_8
   \       0x40   0xE077             B.N      ??StartTransfer_1
   1368            }
   1369          
   1370            ch = &chTable[channelId];
   1371            if ( ch->allocated == false ) {
   \                     ??StartTransfer_3: (+1)
   \       0x42   0x9801             LDR      R0,[SP, #+4]
   \       0x44   0x.... 0x....      LDR.W    R8,??DataTable23_1
   \       0x48   0xF108 0x030C      ADD      R3,R8,#+12
   \       0x4C   0x0100             LSLS     R0,R0,#+4
   \       0x4E   0x9002             STR      R0,[SP, #+8]
   \       0x50   0x5C18             LDRB     R0,[R3, R0]
   \       0x52   0xB908             CBNZ.N   R0,??StartTransfer_4
   1372              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x54   0x....             LDR.N    R0,??DataTable23_6
   \       0x56   0xE06C             B.N      ??StartTransfer_1
   1373            }
   \                     ??StartTransfer_4: (+1)
   \       0x58   0xF88D 0x1001      STRB     R1,[SP, #+1]
   1374          
   1375            xfer = xferCfgPeripheral;
   \       0x5C   0xA803             ADD      R0,SP,#+12
   \       0x5E   0x2110             MOVS     R1,#+16
   \       0x60   0x.... 0x....      BL       __aeabi_memclr4
   1376            desc = &dmaXfer[channelId].desc[0];
   1377          
   1378            if ( direction == dmaDirectionMemToPeripheral ) {
   \       0x64   0x9801             LDR      R0,[SP, #+4]
   \       0x66   0x....             LDR.N    R1,??DataTable23_12
   \       0x68   0xF8DD 0xA04C      LDR      R10,[SP, #+76]
   \       0x6C   0xEB01 0x1740      ADD      R7,R1,R0, LSL #+5
   \       0x70   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0x4638             MOV      R0,R7
   \       0x78   0xD10B             BNE.N    ??StartTransfer_5
   1379              *desc = m2p;
   \       0x7A   0xBF00             Nop
   \       0x7C   0x....             ADR.N    R1,m2p
   \       0x7E   0x2210             MOVS     R2,#+16
   \       0x80   0x.... 0x....      BL       __aeabi_memcpy4
   1380              if ( !bufInc ) {
   \       0x84   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x88   0xD10F             BNE.N    ??StartTransfer_6
   1381                desc->xfer.srcInc = ldmaCtrlSrcIncNone;
   \       0x8A   0x6838             LDR      R0,[R7, #+0]
   \       0x8C   0xF040 0x7040      ORR      R0,R0,#0x3000000
   \       0x90   0xE00A             B.N      ??StartTransfer_7
   1382              }
   1383            } else {
   1384              *desc = p2m;
   \                     ??StartTransfer_5: (+1)
   \       0x92   0xBF00             Nop
   \       0x94   0x....             ADR.N    R1,p2m
   \       0x96   0x2210             MOVS     R2,#+16
   \       0x98   0x.... 0x....      BL       __aeabi_memcpy4
   1385              if ( !bufInc ) {
   \       0x9C   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xA0   0xD103             BNE.N    ??StartTransfer_6
   1386                desc->xfer.dstInc = ldmaCtrlDstIncNone;
   \       0xA2   0x6838             LDR      R0,[R7, #+0]
   \       0xA4   0xF040 0x5040      ORR      R0,R0,#0x30000000
   \                     ??StartTransfer_7: (+1)
   \       0xA8   0x6038             STR      R0,[R7, #+0]
   1387              }
   1388            }
   1389          
   1390            xfer.ldmaReqSel    = peripheralSignal;
   \                     ??StartTransfer_6: (+1)
   \       0xAA   0xF8CD 0x900C      STR      R9,[SP, #+12]
   1391            desc->xfer.xferCnt = len - 1;
   \       0xAE   0x6839             LDR      R1,[R7, #+0]
   \       0xB0   0xF1AB 0x0201      SUB      R2,R11,#+1
   \       0xB4   0x9815             LDR      R0,[SP, #+84]
   \       0xB6   0xF362 0x110E      BFI      R1,R2,#+4,#+11
   \       0xBA   0x6039             STR      R1,[R7, #+0]
   1392            desc->xfer.dstAddr = (uint32_t)(uint8_t *)buf0;
   \       0xBC   0x60BC             STR      R4,[R7, #+8]
   1393            desc->xfer.srcAddr = (uint32_t)(uint8_t *)buf1;
   \       0xBE   0x607D             STR      R5,[R7, #+4]
   1394            desc->xfer.size    = size;
   \       0xC0   0x6839             LDR      R1,[R7, #+0]
   \       0xC2   0xF360 0x619B      BFI      R1,R0,#+26,#+2
   \       0xC6   0x6039             STR      R1,[R7, #+0]
   1395          
   1396            if ( mode == dmaModePingPong ) {
   \       0xC8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xCC   0x9C16             LDR      R4,[SP, #+88]
   \       0xCE   0x2801             CMP      R0,#+1
   \       0xD0   0xD117             BNE.N    ??StartTransfer_8
   1397              desc->xfer.linkMode = ldmaLinkModeRel;
   1398              desc->xfer.link     = 1;
   1399              desc->xfer.linkAddr = 4;      /* Refer to the "pong" descriptor. */
   \       0xD2   0x2113             MOVS     R1,#+19
   \       0xD4   0x60F9             STR      R1,[R7, #+12]
   1400          
   1401              /* Set the "pong" descriptor equal to the "ping" descriptor. */
   1402              dmaXfer[channelId].desc[1] = *desc;
   \       0xD6   0xF107 0x0010      ADD      R0,R7,#+16
   \       0xDA   0x4639             MOV      R1,R7
   \       0xDC   0x2210             MOVS     R2,#+16
   \       0xDE   0x.... 0x....      BL       __aeabi_memcpy4
   1403              /* Refer to the "ping" descriptor. */
   1404              dmaXfer[channelId].desc[1].xfer.linkAddr = -4;
   \       0xE2   0xF107 0x0010      ADD      R0,R7,#+16
   \       0xE6   0x7B01             LDRB     R1,[R0, #+12]
   \       0xE8   0xF001 0x0103      AND      R1,R1,#0x3
   \       0xEC   0xF061 0x010F      ORN      R1,R1,#+15
   \       0xF0   0x60C1             STR      R1,[R0, #+12]
   1405              dmaXfer[channelId].desc[1].xfer.srcAddr = (uint32_t)(uint8_t *)buf2;
   \       0xF2   0x617E             STR      R6,[R7, #+20]
   1406          
   1407              if ( direction == dmaDirectionPeripheralToMem ) {
   \       0xF4   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0xF8   0x2801             CMP      R0,#+1
   \       0xFA   0xD10A             BNE.N    ??StartTransfer_9
   1408                dmaXfer[channelId].desc[1].xfer.dstAddr = (uint32_t)(uint8_t *)buf1;
   \       0xFC   0x61BD             STR      R5,[R7, #+24]
   1409                desc->xfer.srcAddr = (uint32_t)(uint8_t *)buf2;
   \       0xFE   0x607E             STR      R6,[R7, #+4]
   \      0x100   0xE007             B.N      ??StartTransfer_9
   1410              }
   1411            }
   1412          
   1413            /* Whether an interrupt is needed. */
   1414            if ( (callback == NULL) && (mode == dmaModeBasic) ) {
   \                     ??StartTransfer_8: (+1)
   \      0x102   0x0020             MOVS     R0,R4
   \      0x104   0xBF01             ITTTT    EQ
   \      0x106   0xF89D 0x0000      LDRBEQ   R0,[SP, #+0]
   \      0x10A   0x2800             CMPEQ    R0,#+0
   \      0x10C   0xF421 0x1180      BICEQ    R1,R1,#0x100000
   \      0x110   0x6039             STREQ    R1,[R7, #+0]
   1415              desc->xfer.doneIfs = 0;
   1416            }
   1417          
   1418            ch->callback      = callback;
   \                     ??StartTransfer_9: (+1)
   \      0x112   0x9902             LDR      R1,[SP, #+8]
   \      0x114   0x9817             LDR      R0,[SP, #+92]
   1419            ch->userParam     = cbUserParam;
   1420            ch->callbackCount = 0;
   \      0x116   0x2200             MOVS     R2,#+0
   \      0x118   0x4441             ADD      R1,R8,R1
   \      0x11A   0x600C             STR      R4,[R1, #+0]
   \      0x11C   0x6048             STR      R0,[R1, #+4]
   \      0x11E   0x608A             STR      R2,[R1, #+8]
   1421            ch->mode          = mode;
   \      0x120   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   1422          
   1423            LDMA_StartTransfer(channelId, &xfer, desc);
   \      0x124   0x463A             MOV      R2,R7
   \      0x126   0x7348             STRB     R0,[R1, #+13]
   \      0x128   0x9801             LDR      R0,[SP, #+4]
   \      0x12A   0xA903             ADD      R1,SP,#+12
   \      0x12C   0x.... 0x....      BL       LDMA_StartTransfer
   1424          
   1425            return ECODE_EMDRV_DMADRV_OK;
   \      0x130   0x2000             MOVS     R0,#+0
   \                     ??StartTransfer_1: (+1)
   \      0x132   0xB007             ADD      SP,SP,#+28
   \      0x134   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1426          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x....'....        DC32     initialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x....'....        DC32     chTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0xF000'8004        DC32     0xf0008004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0xF000'8005        DC32     0xf0008005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0xF000'8006        DC32     0xf0008006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \        0x0   0xF000'8003        DC32     0xf0008003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \        0x0   0xF000'8007        DC32     0xf0008007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \        0x0   0xF000'8002        DC32     0xf0008002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \        0x0   0xF000'8001        DC32     0xf0008001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \        0x0   0x5004'002C        DC32     0x5004002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \        0x0   0x5004'0050        DC32     0x50040050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \        0x0   0x5004'2050        DC32     0x50042050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \        0x0   0x....'....        DC32     dmaXfer
   1427          #endif /* defined( EMDRV_DMADRV_LDMA ) */
   1428          
   1429          #if defined(EMDRV_DMADRV_LDMA_S3)
   1430          /***************************************************************************//**
   1431           * @brief
   1432           *  Start an LDMA transfer.
   1433           ******************************************************************************/
   1434          static Ecode_t StartTransfer(DmaMode_t             mode,
   1435                                       DmaDirection_t        direction,
   1436                                       unsigned int          channelId,
   1437                                       DMADRV_PeripheralSignal_t
   1438                                       peripheralSignal,
   1439                                       void                  *buf0,
   1440                                       void                  *buf1,
   1441                                       void                  *buf2,
   1442                                       bool                  bufInc,
   1443                                       int                   len,
   1444                                       DMADRV_DataSize_t     size,
   1445                                       DMADRV_Callback_t     callback,
   1446                                       void                  *cbUserParam)
   1447          {
   1448            ChTable_t *ch;
   1449            sl_hal_ldma_transfer_config_t xfer;
   1450            sl_hal_ldma_descriptor_t *desc;
   1451          
   1452            if ( !initialized ) {
   1453              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   1454            }
   1455          
   1456            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
   1457                 || (buf0 == NULL)
   1458                 || (buf1 == NULL)
   1459                 || (len > DMADRV_MAX_XFER_COUNT)
   1460                 || ((mode == dmaModePingPong) && (buf2 == NULL)) ) {
   1461              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   1462            }
   1463          
   1464            ch = &chTable[channelId];
   1465            if ( ch->allocated == false ) {
   1466              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   1467            }
   1468          
   1469            xfer = xferCfgPeripheral;
   1470            desc = &dmaXfer[channelId].desc[0];
   1471          
   1472            if ( direction == dmaDirectionMemToPeripheral ) {
   1473              *desc = m2p;
   1474              if ( !bufInc ) {
   1475                desc->xfer.src_inc = SL_HAL_LDMA_CTRL_SRC_INC_NONE;
   1476              }
   1477            } else {
   1478              *desc = p2m;
   1479              if ( !bufInc ) {
   1480                desc->xfer.dst_inc = SL_HAL_LDMA_CTRL_DST_INC_NONE;
   1481              }
   1482            }
   1483          
   1484            xfer.request_sel      = peripheralSignal;
   1485            desc->xfer.xfer_count = len - 1;
   1486            desc->xfer.dst_addr   = (uint32_t)(uint8_t *)buf0;
   1487            desc->xfer.src_addr   = (uint32_t)(uint8_t *)buf1;
   1488            desc->xfer.size       = size;
   1489          
   1490            if ( mode == dmaModePingPong ) {
   1491              desc->xfer.link_mode = SL_HAL_LDMA_LINK_MODE_REL;
   1492              desc->xfer.link      = 1;
   1493              desc->xfer.link_addr = 4;      /* Refer to the "pong" descriptor. */
   1494          
   1495              /* Set the "pong" descriptor equal to the "ping" descriptor. */
   1496              dmaXfer[channelId].desc[1] = *desc;
   1497              /* Refer to the "ping" descriptor. */
   1498              dmaXfer[channelId].desc[1].xfer.link_addr = -4;
   1499              dmaXfer[channelId].desc[1].xfer.src_addr = (uint32_t)(uint8_t *)buf2;
   1500          
   1501              if ( direction == dmaDirectionPeripheralToMem ) {
   1502                dmaXfer[channelId].desc[1].xfer.dst_addr = (uint32_t)(uint8_t *)buf1;
   1503                desc->xfer.src_addr = (uint32_t)(uint8_t *)buf2;
   1504              }
   1505            }
   1506          
   1507            /* Whether an interrupt is needed. */
   1508            if ( (callback == NULL) && (mode == dmaModeBasic) ) {
   1509              desc->xfer.done_ifs = 0;
   1510            }
   1511          
   1512            ch->callback      = callback;
   1513            ch->userParam     = cbUserParam;
   1514            ch->callbackCount = 0;
   1515            ch->mode          = mode;
   1516          
   1517            sl_hal_ldma_init_transfer(channelId, &xfer, desc);
   1518            sl_hal_ldma_start_transfer(channelId);
   1519            sl_hal_ldma_enable_interrupts((0x1UL << channelId));
   1520          
   1521            return ECODE_EMDRV_DMADRV_OK;
   1522          }
   1523          #endif /* defined( EMDRV_DMADRV_LDMA_S3 ) */
   1524          
   1525          /// @endcond
   1526          
   1527          // ******** THE REST OF THE FILE IS DOCUMENTATION ONLY !***********************
   1528          /// @addtogroup dmadrv DMADRV - DMA Driver
   1529          /// @brief Direct Memory Access Driver
   1530          /// @{
   1531          ///
   1532          ///   @details
   1533          ///
   1534          ///
   1535          ///   @n @section dmadrv_intro Introduction
   1536          ///
   1537          ///   The DMADRV driver supports writing code using DMA which will work
   1538          ///   regardless of the type of the DMA controller on the underlying microcontroller.
   1539          ///   Additionally, DMA can be used in several modules that are
   1540          ///   completely unaware of each other.
   1541          ///   The driver does not preclude use of the native emlib API of the underlying
   1542          ///   DMA controller. On the contrary, it will often result in more efficient
   1543          ///   code and is necessary for complex DMA operations. The housekeeping
   1544          ///   functions of this driver are valuable even in this use-case.
   1545          ///
   1546          ///   The dmadrv.c and dmadrv.h source files are in the
   1547          ///   emdrv/dmadrv folder.
   1548          ///
   1549          ///   @note DMA transfer completion callback functions are called from within the
   1550          ///   DMA interrupt handler.
   1551          ///
   1552          ///   @n @section dmadrv_conf Configuration Options
   1553          ///
   1554          ///   Some properties of the DMADRV driver are compile-time configurable. These
   1555          ///   properties are stored in a file named dmadrv_config.h. A template for this
   1556          ///   file, containing default values, is in the emdrv/config folder.
   1557          ///   Currently the configuration options are as follows:
   1558          ///   @li The interrupt priority of the DMA peripheral.
   1559          ///   @li A number of DMA channels to support.
   1560          ///   @li Use the native emlib API belonging to the underlying DMA hardware in
   1561          ///      combination with the DMADRV API.
   1562          ///
   1563          ///   Both configuration options will help reduce the driver's RAM footprint.
   1564          ///
   1565          ///   To configure DMADRV, provide a custom configuration file. This is an
   1566          ///   example dmadrv_config.h file:
   1567          ///   @code{.c}
   1568          /// #ifndef __SILICON_LABS_DMADRV_CONFIG_H__
   1569          /// #define __SILICON_LABS_DMADRV_CONFIG_H__
   1570          ///
   1571          ///   // DMADRV DMA interrupt priority configuration option.
   1572          ///   // Set DMA interrupt priority. Range is 0..7, 0 is the highest priority.
   1573          /// #define EMDRV_DMADRV_DMA_IRQ_PRIORITY 4
   1574          ///
   1575          ///   // DMADRV channel count configuration option.
   1576          ///   // A number of DMA channels to support. A lower DMA channel count will reduce
   1577          ///   // RAM footprint.
   1578          /// #define EMDRV_DMADRV_DMA_CH_COUNT 4
   1579          ///
   1580          /// #endif
   1581          ///   @endcode
   1582          ///
   1583          ///   @n @section dmadrv_api The API
   1584          ///
   1585          ///   This section contains brief descriptions of the API functions.
   1586          ///   For more information about input and output parameters and return values,
   1587          ///   click on the hyperlinked function names. Most functions return an error
   1588          ///   code, @ref ECODE_EMDRV_DMADRV_OK is returned on success,
   1589          ///   see @ref ecode and @ref dmadrv_error_codes for other error codes.
   1590          ///
   1591          ///   The application code must include @em dmadrv.h header file.
   1592          ///
   1593          ///   @ref DMADRV_Init(), @ref DMADRV_DeInit() @n
   1594          ///    These functions initialize or deinitialize the DMADRV driver. Typically,
   1595          ///    DMADRV_Init() is called once in the startup code.
   1596          ///
   1597          ///   @ref DMADRV_AllocateChannel(), @ref DMADRV_FreeChannel() @n
   1598          ///    DMA channel reserve and release functions. It is recommended that
   1599          ///    application code check that DMADRV_AllocateChannel()
   1600          ///    returns ECODE_EMDRV_DMADRV_OK before starting a DMA
   1601          ///    transfer.
   1602          ///
   1603          ///   @ref DMADRV_MemoryPeripheral() @n
   1604          ///    Start a DMA transfer from memory to a peripheral.
   1605          ///
   1606          ///   @ref DMADRV_PeripheralMemory() @n
   1607          ///    Start a DMA transfer from a peripheral to memory.
   1608          ///
   1609          ///   @ref DMADRV_MemoryPeripheralPingPong() @n
   1610          ///    Start a DMA ping-pong transfer from memory to a peripheral.
   1611          ///
   1612          ///   @ref DMADRV_PeripheralMemoryPingPong() @n
   1613          ///    Start a DMA ping-pong transfer from a peripheral to memory.
   1614          ///
   1615          ///   @ref DMADRV_LdmaStartTransfer() @n
   1616          ///    Start a DMA transfer on an LDMA controller.
   1617          ///
   1618          ///   @ref DMADRV_StopTransfer() @n
   1619          ///    Stop an ongoing DMA transfer.
   1620          ///
   1621          ///   @ref DMADRV_TransferActive() @n
   1622          ///    Check if a transfer is ongoing.
   1623          ///
   1624          ///   @ref DMADRV_TransferCompletePending() @n
   1625          ///    Check if a transfer completion is pending.
   1626          ///
   1627          ///   @ref DMADRV_TransferDone() @n
   1628          ///    Check if a transfer has completed.
   1629          ///
   1630          ///   @ref DMADRV_TransferRemainingCount() @n
   1631          ///    Get number of items remaining in a transfer.
   1632          ///
   1633          ///   @n @section dmadrv_example Example
   1634          ///   Transfer a text string to USART1.
   1635          ///   @code{.c}
   1636          /// #include "dmadrv.h"
   1637          ///
   1638          ///   char str[] = "Hello DMA !";
   1639          ///   unsigned int channel;
   1640          ///
   1641          ///   int main( void )
   1642          ///   {
   1643          ///   // Initialize DMA.
   1644          ///   DMADRV_Init();
   1645          ///
   1646          ///   // Request a DMA channel.
   1647          ///   DMADRV_AllocateChannel( &channel, NULL );
   1648          ///
   1649          ///   // Start the DMA transfer.
   1650          ///   DMADRV_MemoryPeripheral( channel,
   1651          ///                           dmadrvPeripheralSignal_USART1_TXBL,
   1652          ///                           (void*)&(USART1->TXDATA),
   1653          ///                           str,
   1654          ///                           true,
   1655          ///                           sizeof( str ),
   1656          ///                           dmadrvDataSize1,
   1657          ///                           NULL,
   1658          ///                           NULL );
   1659          ///
   1660          ///   return 0;
   1661          ///   }
   1662          ///   @endcode
   1663          ///
   1664          /// @} end group dmadrv ********************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DMADRV_AllocateChannel
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
       8   DMADRV_DeInit
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
         8   -> LDMA_DeInit
       8   DMADRV_FreeChannel
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
       8   DMADRV_Init
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
         8   -> LDMA_Init
      16   DMADRV_LdmaStartTransfer
        16   -> LDMA_StartTransfer
      48   DMADRV_MemoryPeripheral
        48   -> StartTransfer
      48   DMADRV_MemoryPeripheralPingPong
        48   -> StartTransfer
       8   DMADRV_PauseTransfer
         8   -> LDMA_EnableChannelRequest
      48   DMADRV_PeripheralMemory
        48   -> StartTransfer
      48   DMADRV_PeripheralMemoryPingPong
        48   -> StartTransfer
       8   DMADRV_ResumeTransfer
         8   -> LDMA_EnableChannelRequest
       8   DMADRV_StopTransfer
         8   -> LDMA_StopTransfer
       8   DMADRV_TransferActive
       8   DMADRV_TransferCompletePending
       8   DMADRV_TransferDone
         8   -> LDMA_TransferDone
       8   DMADRV_TransferRemainingCount
         8   -> LDMA_TransferRemainingCount
      24   LDMA_IRQHandler
        24   -- Indirect call
      64   StartTransfer
        64   -> LDMA_StartTransfer
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      10  ?Subroutine0
       6  ?Subroutine1
       4  ?Subroutine10
       4  ?Subroutine11
      10  ?Subroutine12
      38  ?Subroutine13
      38  ?Subroutine14
       8  ?Subroutine15
      10  ?Subroutine16
      10  ?Subroutine17
       6  ?Subroutine2
       8  ?Subroutine3
       6  ?Subroutine4
       4  ?Subroutine5
       4  ?Subroutine6
       4  ?Subroutine7
       8  ?Subroutine8
       4  ?Subroutine9
       4  ?_0
      78  DMADRV_AllocateChannel
      56  DMADRV_DeInit
      52  DMADRV_FreeChannel
      80  DMADRV_Init
      54  DMADRV_LdmaStartTransfer
      12  DMADRV_MemoryPeripheral
      12  DMADRV_MemoryPeripheralPingPong
      28  DMADRV_PauseTransfer
      10  DMADRV_PeripheralMemory
      10  DMADRV_PeripheralMemoryPingPong
      28  DMADRV_ResumeTransfer
      32  DMADRV_StopTransfer
      50  DMADRV_TransferActive
      42  DMADRV_TransferCompletePending
      36  DMADRV_TransferDone
      36  DMADRV_TransferRemainingCount
      98  LDMA_IRQHandler
     312  StartTransfer
     128  chTable
     256  dmaXfer
       1  initialized
      16  m2p
      16  p2m
      16  xferCfgPeripheral

 
   385 bytes in section .bss
    16 bytes in section .rodata
 1'296 bytes in section .text
 
 1'296 bytes of CODE  memory
    16 bytes of CONST memory
   385 bytes of DATA  memory

Errors: none
Warnings: none
