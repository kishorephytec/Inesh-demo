###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:13
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Source\cmsis_os2.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\Source_10863626932727399345.dir\cmsis_os2.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Source\cmsis_os2.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\Source_10863626932727399345.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\Source_10863626932727399345.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Source\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\Source_10863626932727399345.dir\cmsis_os2.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\Source_10863626932727399345.dir\cmsis_os2.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\Source_10863626932727399345.dir\cmsis_os2.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Source\cmsis_os2.c
      1          /* --------------------------------------------------------------------------
      2           * Copyright (c) 2013-2020 Arm Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           *      Name:    cmsis_os2.c
     19           *      Purpose: CMSIS RTOS2 wrapper for FreeRTOS
     20           *
     21           *---------------------------------------------------------------------------*/
     22          
     23          #include <string.h>
     24          
     25          #include "cmsis_os2.h"                  // ::CMSIS:RTOS2
     26          #include "cmsis_compiler.h"             // Compiler agnostic definitions
     27          #include "os_tick.h"                    // OS Tick API
     28          
     29          #include "FreeRTOS.h"                   // ARM.FreeRTOS::RTOS:Core
     30          #include "task.h"                       // ARM.FreeRTOS::RTOS:Core
     31          #include "event_groups.h"               // ARM.FreeRTOS::RTOS:Event Groups
     32          #include "semphr.h"                     // ARM.FreeRTOS::RTOS:Core
     33          
     34          #include "freertos_mpool.h"             // osMemoryPool definitions
     35          #include "freertos_os2.h"               // Configuration check and setup
     36          
     37          /*---------------------------------------------------------------------------*/
     38          #ifndef __ARM_ARCH_6M__
     39            #define __ARM_ARCH_6M__         0
     40          #endif
     41          #ifndef __ARM_ARCH_7M__
     42            #define __ARM_ARCH_7M__         0
     43          #endif
     44          #ifndef __ARM_ARCH_7EM__
     45            #define __ARM_ARCH_7EM__        0
     46          #endif
     47          #ifndef __ARM_ARCH_8M_MAIN__
     48            #define __ARM_ARCH_8M_MAIN__    0
     49          #endif
     50          #ifndef __ARM_ARCH_7A__
     51            #define __ARM_ARCH_7A__         0
     52          #endif
     53          
     54          #if   ((__ARM_ARCH_7M__      == 1U) || \
     55                 (__ARM_ARCH_7EM__     == 1U) || \
     56                 (__ARM_ARCH_8M_MAIN__ == 1U))
     57          #define IS_IRQ_MASKED()           ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U))
     58          #elif  (__ARM_ARCH_6M__      == 1U)
     59          #define IS_IRQ_MASKED()           (__get_PRIMASK() != 0U)
     60          #elif (__ARM_ARCH_7A__       == 1U)
     61          /* CPSR mask bits */
     62          #define CPSR_MASKBIT_I            0x80U
     63          
     64          #define IS_IRQ_MASKED()           ((__get_CPSR() & CPSR_MASKBIT_I) != 0U)
     65          #else
     66          #define IS_IRQ_MASKED()           (__get_PRIMASK() != 0U)
     67          #endif
     68          
     69          #if    (__ARM_ARCH_7A__      == 1U)
     70          /* CPSR mode bitmasks */
     71          #define CPSR_MODE_USER            0x10U
     72          #define CPSR_MODE_SYSTEM          0x1FU
     73          
     74          #define IS_IRQ_MODE()             ((__get_mode() != CPSR_MODE_USER) && (__get_mode() != CPSR_MODE_SYSTEM))
     75          #else
     76          #define IS_IRQ_MODE()             (__get_IPSR() != 0U)
     77          #endif
     78          
     79          #define IS_IRQ()                  (IS_IRQ_MODE() || (IS_IRQ_MASKED() && (KernelState == osKernelRunning)))
     80          
     81          /* Limits */
     82          #define MAX_BITS_TASK_NOTIFY      31U
     83          #define MAX_BITS_EVENT_GROUPS     24U
     84          
     85          #define THREAD_FLAGS_INVALID_BITS (~((1UL << MAX_BITS_TASK_NOTIFY)  - 1U))
     86          #define EVENT_FLAGS_INVALID_BITS  (~((1UL << MAX_BITS_EVENT_GROUPS) - 1U))
     87          
     88          /* Kernel version and identification string definition (major.minor.rev: mmnnnrrrr dec) */
     89          #define KERNEL_VERSION            (((uint32_t)tskKERNEL_VERSION_MAJOR * 10000000UL) | \
     90                                             ((uint32_t)tskKERNEL_VERSION_MINOR *    10000UL) | \
     91                                             ((uint32_t)tskKERNEL_VERSION_BUILD *        1UL))
     92          
     93          #define KERNEL_ID                 ("FreeRTOS " tskKERNEL_VERSION_NUMBER)
     94          
     95          /* Timer callback information structure definition */
     96          typedef struct {
     97            osTimerFunc_t func;
     98            void         *arg;
     99          } TimerCallback_t;
    100          
    101          /* Kernel initialization state */

   \                                 In section .bss, align 4
    102          static osKernelState_t KernelState = osKernelInactive;
   \                     KernelState:
   \        0x0                      DS8 4
    103          
    104          /*
    105            Heap region definition used by heap_5 variant
    106          
    107            Define configAPPLICATION_ALLOCATED_HEAP as nonzero value in FreeRTOSConfig.h if
    108            heap regions are already defined and vPortDefineHeapRegions is called in application.
    109          
    110            Otherwise vPortDefineHeapRegions will be called by osKernelInitialize using
    111            definition configHEAP_5_REGIONS as parameter. Overriding configHEAP_5_REGIONS
    112            is possible by defining it globally or in FreeRTOSConfig.h.
    113          */
    114          #if defined(USE_FreeRTOS_HEAP_5)
    115          #if (configAPPLICATION_ALLOCATED_HEAP == 0)
    116            /*
    117              FreeRTOS heap is not defined by the application.
    118              Single region of size configTOTAL_HEAP_SIZE (defined in FreeRTOSConfig.h)
    119              is provided by default. Define configHEAP_5_REGIONS to provide custom
    120              HeapRegion_t array.
    121            */
    122            #define HEAP_5_REGION_SETUP   1
    123            
    124            #ifndef configHEAP_5_REGIONS
    125              #define configHEAP_5_REGIONS xHeapRegions
    126          
    127              static uint8_t ucHeap[configTOTAL_HEAP_SIZE];
    128          
    129              static HeapRegion_t xHeapRegions[] = {
    130                { ucHeap, configTOTAL_HEAP_SIZE },
    131                { NULL,   0                     }
    132              };
    133            #else
    134              /* Global definition is provided to override default heap array */
    135              extern HeapRegion_t configHEAP_5_REGIONS[];
    136            #endif
    137          #else
    138            /*
    139              The application already defined the array used for the FreeRTOS heap and
    140              called vPortDefineHeapRegions to initialize heap.
    141            */
    142            #define HEAP_5_REGION_SETUP   0
    143          #endif /* configAPPLICATION_ALLOCATED_HEAP */
    144          #endif /* USE_FreeRTOS_HEAP_5 */
    145          
    146          #if defined(SysTick)
    147          #undef SysTick_Handler
    148          
    149          /* CMSIS SysTick interrupt handler prototype */
    150          extern void SysTick_Handler     (void);
    151          /* FreeRTOS tick timer interrupt handler prototype */
    152          extern void xPortSysTickHandler (void);
    153          
    154          /*
    155            SysTick handler implementation that also clears overflow flag.
    156          */

   \                                 In section .text, align 2, keep-with-next
    157          void SysTick_Handler (void) {
   \                     SysTick_Handler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    158            /* Clear overflow flag */
    159            SysTick->CTRL;
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable22
   \        0x6   0x6808             LDR      R0,[R1, #+0]
    160          
    161            if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
   \        0x8   0x.... 0x....      BL       xTaskGetSchedulerState
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD003             BEQ.N    ??SysTick_Handler_0
    162              /* Call tick handler */
    163              xPortSysTickHandler();
   \       0x10   0xE8BD 0x4001      POP      {R0,LR}
   \       0x14   0x.... 0x....      B.W      xPortSysTickHandler
    164            }
    165          }
   \                     ??SysTick_Handler_0: (+1)
   \       0x18   0xBD01             POP      {R0,PC}
    166          #endif /* SysTick */
    167          
    168          /*
    169            Setup SVC to reset value.
    170          */
    171          __STATIC_INLINE void SVC_Setup (void) {
    172          #if (__ARM_ARCH_7A__ == 0U)
    173            /* Service Call interrupt might be configured before kernel start     */
    174            /* and when its priority is lower or equal to BASEPRI, svc intruction */
    175            /* causes a Hard Fault.                                               */
    176            NVIC_SetPriority (SVCall_IRQn, 0U);
    177          #endif
    178          }
    179          
    180          /*
    181            Function macro used to retrieve semaphore count from ISR
    182          */
    183          #ifndef uxSemaphoreGetCountFromISR
    184          #define uxSemaphoreGetCountFromISR( xSemaphore ) uxQueueMessagesWaitingFromISR( ( QueueHandle_t ) ( xSemaphore ) )
    185          #endif
    186          
    187          /*---------------------------------------------------------------------------*/
    188          

   \                                 In section .text, align 2, keep-with-next
    189          osStatus_t osKernelInitialize (void) {
    190            osStatus_t stat;
    191          
    192            if (IS_IRQ()) {
   \                     osKernelInitialize: (+1)
   \        0x0   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x4   0xB960             CBNZ.N   R0,??osKernelInitialize_0
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable22_1
   \        0xA   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xBF04             ITT      EQ
   \       0x12   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x16   0x2800             CMPEQ    R0,#+0
   \       0x18   0xD005             BEQ.N    ??osKernelInitialize_1
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD102             BNE.N    ??osKernelInitialize_1
    193              stat = osErrorISR;
   \                     ??osKernelInitialize_0: (+1)
   \       0x20   0xF06F 0x0005      MVN      R0,#+5
   \       0x24   0x4770             BX       LR
    194            }
    195            else {
    196              if (KernelState == osKernelInactive) {
   \                     ??osKernelInitialize_1: (+1)
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0xB910             CBNZ.N   R0,??osKernelInitialize_2
    197                #if defined(USE_TRACE_EVENT_RECORDER)
    198                  EvrFreeRTOSSetup(0U);
    199                #endif
    200                #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
    201                  vPortDefineHeapRegions (configHEAP_5_REGIONS);
    202                #endif
    203                KernelState = osKernelReady;
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x600A             STR      R2,[R1, #+0]
    204                stat = osOK;
   \       0x2E   0x4770             BX       LR
    205              } else {
    206                stat = osError;
   \                     ??osKernelInitialize_2: (+1)
   \       0x30                      REQUIRE ?Subroutine0
   \       0x30                      ;; // Fall through to label ?Subroutine0
    207              }
    208            }
    209          
    210            return (stat);
    211          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#+4294967295
   \        0x4   0x4770             BX       LR
    212          

   \                                 In section .text, align 4, keep-with-next
    213          osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
   \                     osKernelGetInfo: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x460B             MOV      R3,R1
    214          
    215            if (version != NULL) {
   \        0x4   0xB118             CBZ.N    R0,??osKernelGetInfo_0
    216              /* Version encoding is major.minor.rev: mmnnnrrrr dec */
    217              version->api    = KERNEL_VERSION;
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable23
   \        0xA   0x6001             STR      R1,[R0, #+0]
    218              version->kernel = KERNEL_VERSION;
   \        0xC   0x6041             STR      R1,[R0, #+4]
    219            }
    220          
    221            if ((id_buf != NULL) && (id_size != 0U)) {
   \                     ??osKernelGetInfo_0: (+1)
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2A00             CMPNE    R2,#+0
   \       0x14   0xD006             BEQ.N    ??osKernelGetInfo_1
    222              if (id_size > sizeof(KERNEL_ID)) {
   \       0x16   0x2A11             CMP      R2,#+17
   \       0x18   0xBF88             IT       HI
   \       0x1A   0x2211             MOVHI    R2,#+17
    223                id_size = sizeof(KERNEL_ID);
    224              }
    225              memcpy(id_buf, KERNEL_ID, id_size);
   \       0x1C   0x....             ADR.N    R1,?_1
   \       0x1E   0x4618             MOV      R0,R3
   \       0x20   0x.... 0x....      BL       __aeabi_memcpy
    226            }
    227          
    228            return (osOK);
   \                     ??osKernelGetInfo_1: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xBD02             POP      {R1,PC}
    229          }
    230          

   \                                 In section .text, align 2, keep-with-next
    231          osKernelState_t osKernelGetState (void) {
   \                     osKernelGetState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    232            osKernelState_t state;
    233          
    234            switch (xTaskGetSchedulerState()) {
   \        0x2   0x.... 0x....      BL       xTaskGetSchedulerState
   \        0x6   0xB110             CBZ.N    R0,??osKernelGetState_0
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD102             BNE.N    ??osKernelGetState_1
    235              case taskSCHEDULER_RUNNING:
    236                state = osKernelRunning;
    237                break;
   \        0xC   0xBD02             POP      {R1,PC}
    238          
    239              case taskSCHEDULER_SUSPENDED:
    240                state = osKernelLocked;
   \                     ??osKernelGetState_0: (+1)
   \        0xE   0x2003             MOVS     R0,#+3
    241                break;
   \       0x10   0xBD02             POP      {R1,PC}
    242          
    243              case taskSCHEDULER_NOT_STARTED:
    244              default:
    245                if (KernelState == osKernelReady) {
   \                     ??osKernelGetState_1: (+1)
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable22_1
   \       0x16   0x6808             LDR      R0,[R1, #+0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xBF18             IT       NE
   \       0x1C   0x2000             MOVNE    R0,#+0
    246                  state = osKernelReady;
    247                } else {
    248                  state = osKernelInactive;
    249                }
    250                break;
    251            }
    252          
    253            return (state);
   \       0x1E   0xBD02             POP      {R1,PC}
    254          }
    255          

   \                                 In section .text, align 2, keep-with-next
    256          osStatus_t osKernelStart (void) {
   \                     osKernelStart: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    257            osStatus_t stat;
    258          
    259            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0xB958             CBNZ.N   R0,??osKernelStart_0
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable22_1
   \        0xC   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x10   0xBF04             ITT      EQ
   \       0x12   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x16   0x2800             CMPEQ    R0,#+0
   \       0x18   0xD003             BEQ.N    ??osKernelStart_1
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD100             BNE.N    ??osKernelStart_1
    260              stat = osErrorISR;
   \                     ??osKernelStart_0: (+1)
   \       0x20   0x....             B.N      ?Subroutine2
    261            }
    262            else {
    263              if (KernelState == osKernelReady) {
   \                     ??osKernelStart_1: (+1)
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD109             BNE.N    ??osKernelStart_2
    264                /* Ensure SVC priority is at the reset value */
    265                SVC_Setup();
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable24
   \       0x2E   0x7002             STRB     R2,[R0, #+0]
    266                /* Change state to enable IRQ masking check */
    267                KernelState = osKernelRunning;
   \       0x30   0x2302             MOVS     R3,#+2
   \       0x32   0x600B             STR      R3,[R1, #+0]
    268                /* Start the kernel scheduler */
    269                vTaskStartScheduler();
   \       0x34   0x.... 0x....      BL       vTaskStartScheduler
    270                stat = osOK;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD02             POP      {R1,PC}
    271              } else {
    272                stat = osError;
   \                     ??osKernelStart_2: (+1)
   \       0x3C   0x....             B.N      ?Subroutine1
    273              }
    274            }
    275          
    276            return (stat);
    277          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF06F 0x0005      MVN      R0,#+5
   \        0x4   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#+4294967295
   \        0x4   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0x4770             BX       LR
    278          

   \                                 In section .text, align 2, keep-with-next
    279          int32_t osKernelLock (void) {
   \                     osKernelLock: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    280            int32_t lock;
    281          
    282            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0xB948             CBNZ.N   R0,??osKernelLock_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_23: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD003             BEQ.N    ??osKernelLock_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x1A   0xD100             BNE.N    ??osKernelLock_1
    283              lock = (int32_t)osErrorISR;
   \                     ??osKernelLock_0: (+1)
   \       0x1C   0x....             B.N      ?Subroutine2
    284            }
    285            else {
    286              switch (xTaskGetSchedulerState()) {
   \                     ??osKernelLock_1: (+1)
   \       0x1E   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x22   0xB110             CBZ.N    R0,??osKernelLock_2
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD002             BEQ.N    ??osKernelLock_3
   \       0x28   0xE005             B.N      ??osKernelLock_4
    287                case taskSCHEDULER_SUSPENDED:
    288                  lock = 1;
   \                     ??osKernelLock_2: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
    289                  break;
   \       0x2C   0xBD02             POP      {R1,PC}
    290          
    291                case taskSCHEDULER_RUNNING:
    292                  vTaskSuspendAll();
   \                     ??osKernelLock_3: (+1)
   \       0x2E   0x.... 0x....      BL       vTaskSuspendAll
    293                  lock = 0;
   \       0x32   0x2000             MOVS     R0,#+0
    294                  break;
   \       0x34   0xBD02             POP      {R1,PC}
    295          
    296                case taskSCHEDULER_NOT_STARTED:
    297                default:
    298                  lock = (int32_t)osError;
   \                     ??osKernelLock_4: (+1)
   \       0x36   0x....             B.N      ?Subroutine1
    299                  break;
    300              }
    301            }
    302          
    303            return (lock);
    304          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable22_1
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2802             CMP      R0,#+2
   \        0x6   0x4770             BX       LR
    305          

   \                                 In section .text, align 2, keep-with-next
    306          int32_t osKernelUnlock (void) {
   \                     osKernelUnlock: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    307            int32_t lock;
    308          
    309            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0xB948             CBNZ.N   R0,??osKernelUnlock_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_24: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osKernelUnlock_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x1A   0xD102             BNE.N    ??osKernelUnlock_1
    310              lock = (int32_t)osErrorISR;
   \                     ??osKernelUnlock_0: (+1)
   \       0x1C   0xF06F 0x0505      MVN      R5,#+5
   \       0x20   0xE013             B.N      ??osKernelUnlock_2
    311            }
    312            else {
    313              switch (xTaskGetSchedulerState()) {
   \                     ??osKernelUnlock_1: (+1)
   \       0x22   0xF04F 0x34FF      MOV      R4,#+4294967295
   \       0x26   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x2A   0xB110             CBZ.N    R0,??osKernelUnlock_3
   \       0x2C   0x2802             CMP      R0,#+2
   \       0x2E   0xD009             BEQ.N    ??osKernelUnlock_4
   \       0x30   0xE00A             B.N      ??osKernelUnlock_5
    314                case taskSCHEDULER_SUSPENDED:
    315                  lock = 1;
   \                     ??osKernelUnlock_3: (+1)
   \       0x32   0x2501             MOVS     R5,#+1
    316          
    317                  if (xTaskResumeAll() != pdTRUE) {
   \       0x34   0x.... 0x....      BL       xTaskResumeAll
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD006             BEQ.N    ??osKernelUnlock_2
    318                    if (xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) {
   \       0x3C   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x40   0xB918             CBNZ.N   R0,??osKernelUnlock_2
    319                      lock = (int32_t)osError;
   \       0x42   0xE001             B.N      ??osKernelUnlock_5
    320                    }
    321                  }
    322                  break;
    323          
    324                case taskSCHEDULER_RUNNING:
    325                  lock = 0;
   \                     ??osKernelUnlock_4: (+1)
   \       0x44   0x2500             MOVS     R5,#+0
    326                  break;
   \       0x46   0xE000             B.N      ??osKernelUnlock_2
    327          
    328                case taskSCHEDULER_NOT_STARTED:
    329                default:
    330                  lock = (int32_t)osError;
   \                     ??osKernelUnlock_5: (+1)
   \       0x48   0x4625             MOV      R5,R4
    331                  break;
    332              }
    333            }
    334          
    335            return (lock);
   \                     ??osKernelUnlock_2: (+1)
   \       0x4A   0x4628             MOV      R0,R5
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
    336          }
    337          

   \                                 In section .text, align 2, keep-with-next
    338          int32_t osKernelRestoreLock (int32_t lock) {
   \                     osKernelRestoreLock: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
    339          
    340            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_53: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osKernelRestoreLock_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_25: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osKernelRestoreLock_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x1A   0xD102             BNE.N    ??osKernelRestoreLock_1
    341              lock = (int32_t)osErrorISR;
   \                     ??osKernelRestoreLock_0: (+1)
   \       0x1C   0xF06F 0x0405      MVN      R4,#+5
   \       0x20   0xE016             B.N      ??osKernelRestoreLock_2
    342            }
    343            else {
    344              switch (xTaskGetSchedulerState()) {
   \                     ??osKernelRestoreLock_1: (+1)
   \       0x22   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x26   0xF04F 0x35FF      MOV      R5,#+4294967295
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xBF18             IT       NE
   \       0x2E   0x2802             CMPNE    R0,#+2
   \       0x30   0xD10D             BNE.N    ??osKernelRestoreLock_3
    345                case taskSCHEDULER_SUSPENDED:
    346                case taskSCHEDULER_RUNNING:
    347                  if (lock == 1) {
   \       0x32   0x2C01             CMP      R4,#+1
   \       0x34   0xD102             BNE.N    ??osKernelRestoreLock_4
    348                    vTaskSuspendAll();
   \       0x36   0x.... 0x....      BL       vTaskSuspendAll
   \       0x3A   0xE009             B.N      ??osKernelRestoreLock_2
    349                  }
    350                  else {
    351                    if (lock != 0) {
   \                     ??osKernelRestoreLock_4: (+1)
   \       0x3C   0xB93C             CBNZ.N   R4,??osKernelRestoreLock_3
    352                      lock = (int32_t)osError;
    353                    }
    354                    else {
    355                      if (xTaskResumeAll() != pdTRUE) {
   \       0x3E   0x.... 0x....      BL       xTaskResumeAll
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD004             BEQ.N    ??osKernelRestoreLock_2
    356                        if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
   \       0x46   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x4A   0x2802             CMP      R0,#+2
   \       0x4C   0xD000             BEQ.N    ??osKernelRestoreLock_2
    357                          lock = (int32_t)osError;
    358                        }
    359                      }
    360                    }
    361                  }
    362                  break;
    363          
    364                case taskSCHEDULER_NOT_STARTED:
    365                default:
    366                  lock = (int32_t)osError;
   \                     ??osKernelRestoreLock_3: (+1)
   \       0x4E   0x462C             MOV      R4,R5
    367                  break;
    368              }
    369            }
    370          
    371            return (lock);
   \                     ??osKernelRestoreLock_2: (+1)
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0xBD32             POP      {R1,R4,R5,PC}
    372          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x4770             BX       LR
    373          

   \                                 In section .text, align 2, keep-with-next
    374          uint32_t osKernelGetTickCount (void) {
    375            TickType_t ticks;
    376          
    377            if (IS_IRQ()) {
   \                     osKernelGetTickCount: (+1)
   \        0x0   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x4   0xB960             CBNZ.N   R0,??osKernelGetTickCount_0
   \        0x6   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD006             BEQ.N    ??osKernelGetTickCount_1
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable22_1
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD101             BNE.N    ??osKernelGetTickCount_1
    378              ticks = xTaskGetTickCountFromISR();
   \                     ??osKernelGetTickCount_0: (+1)
   \       0x20   0x.... 0x....      B.W      xTaskGetTickCountFromISR
    379            } else {
    380              ticks = xTaskGetTickCount();
   \                     ??osKernelGetTickCount_1: (+1)
   \       0x24   0x.... 0x....      B.W      xTaskGetTickCount
    381            }
    382          
    383            return (ticks);
    384          }
    385          

   \                                 In section .text, align 2, keep-with-next
    386          uint32_t osKernelGetTickFreq (void) {
    387            return (configTICK_RATE_HZ);
   \                     osKernelGetTickFreq: (+1)
   \        0x0   0xF44F 0x707A      MOV      R0,#+1000
   \        0x4   0x4770             BX       LR
    388          }
    389          

   \                                 In section .text, align 2, keep-with-next
    390          uint32_t osKernelGetSysTimerCount (void) {
   \                     osKernelGetSysTimerCount: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    391            uint32_t irqmask = IS_IRQ_MASKED();
   \        0x2   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x6   0xB918             CBNZ.N   R0,??osKernelGetSysTimerCount_0
   \        0x8   0xF3EF 0x8011      MRS      R0,BASEPRI
   \        0xC   0x0004             MOVS     R4,R0
   \        0xE   0xD000             BEQ.N    ??osKernelGetSysTimerCount_1
   \                     ??osKernelGetSysTimerCount_0: (+1)
   \       0x10   0x2401             MOVS     R4,#+1
    392            TickType_t ticks;
    393            uint32_t val;
    394          
    395            __disable_irq();
   \                     ??osKernelGetSysTimerCount_1: (+1)
   \       0x12   0xB672             CPSID    I
    396          
    397            ticks = xTaskGetTickCount();
   \       0x14   0x.... 0x....      BL       xTaskGetTickCount
   \       0x18   0x4606             MOV      R6,R0
    398            val   = OS_Tick_GetCount();
   \       0x1A   0x.... 0x....      BL       OS_Tick_GetCount
   \       0x1E   0x4605             MOV      R5,R0
    399          
    400            if (OS_Tick_GetOverflow() != 0U) {
   \       0x20   0x.... 0x....      BL       OS_Tick_GetOverflow
   \       0x24   0xB118             CBZ.N    R0,??osKernelGetSysTimerCount_2
    401              val = OS_Tick_GetCount();
   \       0x26   0x.... 0x....      BL       OS_Tick_GetCount
   \       0x2A   0x4605             MOV      R5,R0
    402              ticks++;
   \       0x2C   0x1C76             ADDS     R6,R6,#+1
    403            }
    404            val += ticks * OS_Tick_GetInterval();
   \                     ??osKernelGetSysTimerCount_2: (+1)
   \       0x2E   0x.... 0x....      BL       OS_Tick_GetInterval
   \       0x32   0xFB00 0x5606      MLA      R6,R0,R6,R5
    405          
    406            if (irqmask == 0U) {
   \       0x36   0xB904             CBNZ.N   R4,??osKernelGetSysTimerCount_3
    407              __enable_irq();
   \       0x38   0xB662             CPSIE    I
    408            }
    409          
    410            return (val);
   \                     ??osKernelGetSysTimerCount_3: (+1)
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0xBD70             POP      {R4-R6,PC}
    411          }
    412          

   \                                 In section .text, align 2, keep-with-next
    413          uint32_t osKernelGetSysTimerFreq (void) {
    414            return (configCPU_CLOCK_HZ);
   \                     osKernelGetSysTimerFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable26
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
    415          }
    416          
    417          /*---------------------------------------------------------------------------*/
    418          

   \                                 In section .text, align 2, keep-with-next
    419          osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
   \                     osThreadNew: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
    420            const char *name;
    421            uint32_t stack;
    422            TaskHandle_t hTask;
    423            UBaseType_t prio;
    424            int32_t mem;
    425          
    426            hTask = NULL;
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x9303             STR      R3,[SP, #+12]
    427          
    428            if (!IS_IRQ() && (func != NULL)) {
   \        0x8   0xF3EF 0x8305      MRS      R3,IPSR
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD14A             BNE.N    ??osThreadNew_0
   \       0x10   0xF3EF 0x8310      MRS      R3,PRIMASK
   \       0x14   0x2B00             CMP      R3,#+0
   \       0x16   0xBF04             ITT      EQ
   \       0x18   0xF3EF 0x8311      MRSEQ    R3,BASEPRI
   \       0x1C   0x2B00             CMPEQ    R3,#+0
   \       0x1E   0xD004             BEQ.N    ??osThreadNew_1
   \       0x20   0x.... 0x....      LDR.W    R4,??DataTable22_1
   \       0x24   0x6823             LDR      R3,[R4, #+0]
   \       0x26   0x2B02             CMP      R3,#+2
   \       0x28   0xD03D             BEQ.N    ??osThreadNew_0
   \                     ??osThreadNew_1: (+1)
   \       0x2A   0x0003             MOVS     R3,R0
   \       0x2C   0xD03B             BEQ.N    ??osThreadNew_0
    429              stack = configMINIMAL_STACK_SIZE;
   \       0x2E   0x25A0             MOVS     R5,#+160
    430              prio  = (UBaseType_t)osPriorityNormal;
   \       0x30   0x2618             MOVS     R6,#+24
    431          
    432              name = NULL;
   \       0x32   0x2400             MOVS     R4,#+0
    433              mem  = -1;
    434          
    435              if (attr != NULL) {
   \       0x34   0xB35A             CBZ.N    R2,??osThreadNew_2
    436                if (attr->name != NULL) {
   \       0x36   0x6813             LDR      R3,[R2, #+0]
   \       0x38   0xB103             CBZ.N    R3,??osThreadNew_3
    437                  name = attr->name;
   \       0x3A   0x461C             MOV      R4,R3
    438                }
    439                if (attr->priority != osPriorityNone) {
   \                     ??osThreadNew_3: (+1)
   \       0x3C   0x6993             LDR      R3,[R2, #+24]
   \       0x3E   0xB11B             CBZ.N    R3,??osThreadNew_4
    440                  prio = (UBaseType_t)attr->priority;
   \       0x40   0x001E             MOVS     R6,R3
    441                }
    442          
    443                if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
   \       0x42   0xD004             BEQ.N    ??osThreadNew_5
   \       0x44   0x2E39             CMP      R6,#+57
   \       0x46   0xD202             BCS.N    ??osThreadNew_5
   \                     ??osThreadNew_4: (+1)
   \       0x48   0x7917             LDRB     R7,[R2, #+4]
   \       0x4A   0x07FB             LSLS     R3,R7,#+31
   \       0x4C   0xD501             BPL.N    ??osThreadNew_6
    444                  return (NULL);
   \                     ??osThreadNew_5: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE02A             B.N      ??osThreadNew_7
    445                }
    446          
    447                if (attr->stack_size > 0U) {
   \                     ??osThreadNew_6: (+1)
   \       0x52   0x6953             LDR      R3,[R2, #+20]
   \       0x54   0xB103             CBZ.N    R3,??osThreadNew_8
    448                  /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
    449                  /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
    450                  stack = attr->stack_size / sizeof(StackType_t);
   \       0x56   0x089D             LSRS     R5,R3,#+2
    451                }
    452          
    453                if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
    454                    (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
   \                     ??osThreadNew_8: (+1)
   \       0x58   0x6897             LDR      R7,[R2, #+8]
   \       0x5A   0xF8D2 0xC00C      LDR      R12,[R2, #+12]
   \       0x5E   0xB187             CBZ.N    R7,??osThreadNew_9
   \       0x60   0xF1BC 0x0F60      CMP      R12,#+96
   \       0x64   0xD31F             BCC.N    ??osThreadNew_0
   \       0x66   0x6912             LDR      R2,[R2, #+16]
   \       0x68   0x2A00             CMP      R2,#+0
   \       0x6A   0xBF18             IT       NE
   \       0x6C   0x2B00             CMPNE    R3,#+0
   \       0x6E   0xD01A             BEQ.N    ??osThreadNew_0
    455                  mem = 1;
    456                }
    457                else {
    458                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
    459                    mem = 0;
    460                  }
    461                }
    462              }
    463              else {
    464                mem = 0;
    465              }
    466          
    467              if (mem == 1) {
    468                #if (configSUPPORT_STATIC_ALLOCATION == 1)
    469                  hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
    470                                                                                                (StaticTask_t *)attr->cb_mem);
   \       0x70   0x9201             STR      R2,[SP, #+4]
   \       0x72   0x460B             MOV      R3,R1
   \       0x74   0x9702             STR      R7,[SP, #+8]
   \       0x76   0x9600             STR      R6,[SP, #+0]
   \       0x78   0x462A             MOV      R2,R5
   \       0x7A   0x4621             MOV      R1,R4
   \       0x7C   0x.... 0x....      BL       xTaskCreateStatic
   \       0x80   0xE010             B.N      ??osThreadNew_10
    471                #endif
    472              }
   \                     ??osThreadNew_9: (+1)
   \       0x82   0xF1BC 0x0F00      CMP      R12,#+0
   \       0x86   0xBF04             ITT      EQ
   \       0x88   0x6912             LDREQ    R2,[R2, #+16]
   \       0x8A   0x2A00             CMPEQ    R2,#+0
   \       0x8C   0xD10B             BNE.N    ??osThreadNew_0
    473              else {
    474                if (mem == 0) {
    475                  #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
    476                    if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
   \                     ??osThreadNew_2: (+1)
   \       0x8E   0xAB03             ADD      R3,SP,#+12
   \       0x90   0x9301             STR      R3,[SP, #+4]
   \       0x92   0x460B             MOV      R3,R1
   \       0x94   0x9600             STR      R6,[SP, #+0]
   \       0x96   0xB2AA             UXTH     R2,R5
   \       0x98   0x4621             MOV      R1,R4
   \       0x9A   0x.... 0x....      BL       xTaskCreate
   \       0x9E   0x2801             CMP      R0,#+1
   \       0xA0   0xD001             BEQ.N    ??osThreadNew_0
    477                      hTask = NULL;
   \       0xA2   0x2000             MOVS     R0,#+0
   \                     ??osThreadNew_10: (+1)
   \       0xA4   0x9003             STR      R0,[SP, #+12]
    478                    }
    479                  #endif
    480                }
    481              }
    482            }
    483          
    484            return ((osThreadId_t)hTask);
   \                     ??osThreadNew_0: (+1)
   \       0xA6   0x9803             LDR      R0,[SP, #+12]
   \                     ??osThreadNew_7: (+1)
   \       0xA8   0xB005             ADD      SP,SP,#+20
   \       0xAA   0xBDF0             POP      {R4-R7,PC}
    485          }
    486          

   \                                 In section .text, align 2, keep-with-next
    487          const char *osThreadGetName (osThreadId_t thread_id) {
    488            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    489            const char *name;
    490          
    491            if (IS_IRQ() || (hTask == NULL)) {
   \                     osThreadGetName: (+1)
   \        0x0   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x4   0xB969             CBNZ.N   R1,??osThreadGetName_0
   \        0x6   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD004             BEQ.N    ??osThreadGetName_1
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable22_1
   \       0x1A   0x6811             LDR      R1,[R2, #+0]
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD000             BEQ.N    ??osThreadGetName_0
   \                     ??osThreadGetName_1: (+1)
   \       0x20   0xB908             CBNZ.N   R0,??osThreadGetName_2
    492              name = NULL;
   \                     ??osThreadGetName_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x4770             BX       LR
    493            } else {
    494              name = pcTaskGetName (hTask);
   \                     ??osThreadGetName_2: (+1)
   \       0x26   0x.... 0x....      B.W      pcTaskGetName
    495            }
    496          
    497            return (name);
    498          }
    499          

   \                                 In section .text, align 2, keep-with-next
    500          osThreadId_t osThreadGetId (void) {
    501            osThreadId_t id;
    502          
    503            id = (osThreadId_t)xTaskGetCurrentTaskHandle();
    504          
    505            return (id);
   \                     osThreadGetId: (+1)
   \        0x0   0x.... 0x....      B.W      xTaskGetCurrentTaskHandle
    506          }
    507          

   \                                 In section .text, align 4, keep-with-next
    508          osThreadState_t osThreadGetState (osThreadId_t thread_id) {
   \                     osThreadGetState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    509            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    510            osThreadState_t state;
    511          
    512            if (IS_IRQ() || (hTask == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB9D9             CBNZ.N   R1,??osThreadGetState_1
   \        0x8   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_66: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD002             BEQ.N    ??osThreadGetState_2
   \       0x16   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0x1A   0xD011             BEQ.N    ??osThreadGetState_1
   \                     ??osThreadGetState_2: (+1)
   \       0x1C   0xB180             CBZ.N    R0,??osThreadGetState_1
    513              state = osThreadError;
    514            }
    515            else {
    516              switch (eTaskGetState (hTask)) {
   \       0x1E   0x.... 0x....      BL       eTaskGetState
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xD80C             BHI.N    ??osThreadGetState_1
   \       0x26   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??osThreadGetState_0:
   \       0x2A   0x03 0x05          DC8      0x3,0x5,0x7,0x7
   \              0x07 0x07
   \       0x2E   0x09 0x00          DC8      0x9,0x0
    517                case eRunning:   state = osThreadRunning;    break;
   \                     ??osThreadGetState_3: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xBD02             POP      {R1,PC}
    518                case eReady:     state = osThreadReady;      break;
   \                     ??osThreadGetState_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD02             POP      {R1,PC}
    519                case eBlocked:
    520                case eSuspended: state = osThreadBlocked;    break;
   \                     ??osThreadGetState_5: (+1)
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xBD02             POP      {R1,PC}
    521                case eDeleted:   state = osThreadTerminated; break;
   \                     ??osThreadGetState_6: (+1)
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0xBD02             POP      {R1,PC}
    522                case eInvalid:
    523                default:         state = osThreadError;      break;
   \                     ??osThreadGetState_1: (+1)
   \       0x40   0x....             B.N      ?Subroutine1
    524              }
    525            }
    526          
    527            return (state);
    528          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable39
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x2902             CMP      R1,#+2
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0x4770             BX       LR
    529          

   \                                 In section .text, align 2, keep-with-next
    530          uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
   \                     osThreadGetStackSpace: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    531            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    532            uint32_t sz;
    533          
    534            if (IS_IRQ() || (hTask == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB951             CBNZ.N   R1,??osThreadGetStackSpace_0
   \        0x8   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_67: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD002             BEQ.N    ??osThreadGetStackSpace_1
   \       0x16   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x1A   0xD000             BEQ.N    ??osThreadGetStackSpace_0
   \                     ??osThreadGetStackSpace_1: (+1)
   \       0x1C   0xB908             CBNZ.N   R0,??osThreadGetStackSpace_2
    535              sz = 0U;
   \                     ??osThreadGetStackSpace_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD02             POP      {R1,PC}
    536            } else {
    537              sz = (uint32_t)(uxTaskGetStackHighWaterMark(hTask) * sizeof(StackType_t));
   \                     ??osThreadGetStackSpace_2: (+1)
   \       0x22   0x.... 0x....      BL       uxTaskGetStackHighWaterMark
   \       0x26   0x0080             LSLS     R0,R0,#+2
    538            }
    539          
    540            return (sz);
   \       0x28   0xBD02             POP      {R1,PC}
    541          }
    542          

   \                                 In section .text, align 2, keep-with-next
    543          osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
   \                     osThreadSetPriority: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    544            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    545            osStatus_t stat;
    546          
    547            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8205      MRS      R2,IPSR
   \        0x6   0xB94A             CBNZ.N   R2,??osThreadSetPriority_0
   \        0x8   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_89: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8211      MRSEQ    R2,BASEPRI
   \       0x12   0x2A00             CMPEQ    R2,#+0
   \       0x14   0xD005             BEQ.N    ??osThreadSetPriority_1
   \       0x16   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0x1A   0xD102             BNE.N    ??osThreadSetPriority_1
    548              stat = osErrorISR;
   \                     ??osThreadSetPriority_0: (+1)
   \       0x1C   0xF06F 0x0405      MVN      R4,#+5
   \       0x20   0xE009             B.N      ??osThreadSetPriority_2
    549            }
    550            else if ((hTask == NULL) || (priority < osPriorityIdle) || (priority > osPriorityISR)) {
   \                     ??osThreadSetPriority_1: (+1)
   \       0x22   0xB110             CBZ.N    R0,??osThreadSetPriority_3
   \       0x24   0x1E4A             SUBS     R2,R1,#+1
   \       0x26   0x2A38             CMP      R2,#+56
   \       0x28   0xD302             BCC.N    ??osThreadSetPriority_4
    551              stat = osErrorParameter;
   \                     ??osThreadSetPriority_3: (+1)
   \       0x2A   0xF06F 0x0403      MVN      R4,#+3
   \       0x2E   0xE002             B.N      ??osThreadSetPriority_2
    552            }
    553            else {
    554              stat = osOK;
   \                     ??osThreadSetPriority_4: (+1)
   \       0x30   0x2400             MOVS     R4,#+0
    555              vTaskPrioritySet (hTask, (UBaseType_t)priority);
   \       0x32   0x.... 0x....      BL       vTaskPrioritySet
    556            }
    557          
    558            return (stat);
   \                     ??osThreadSetPriority_2: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD10             POP      {R4,PC}
    559          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0xF3EF 0x8210      MRS      R2,PRIMASK
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x.... 0x....      LDR.W    R3,??DataTable39
   \        0x4   0x681A             LDR      R2,[R3, #+0]
   \        0x6   0x2A02             CMP      R2,#+2
   \        0x8   0x4770             BX       LR
    560          

   \                                 In section .text, align 2, keep-with-next
    561          osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
    562            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    563            osPriority_t prio;
    564          
    565            if (IS_IRQ() || (hTask == NULL)) {
   \                     osThreadGetPriority: (+1)
   \        0x0   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x4   0xB969             CBNZ.N   R1,??osThreadGetPriority_0
   \        0x6   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD004             BEQ.N    ??osThreadGetPriority_1
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable22_1
   \       0x1A   0x6811             LDR      R1,[R2, #+0]
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD000             BEQ.N    ??osThreadGetPriority_0
   \                     ??osThreadGetPriority_1: (+1)
   \       0x20   0xB900             CBNZ.N   R0,??osThreadGetPriority_2
    566              prio = osPriorityError;
   \                     ??osThreadGetPriority_0: (+1)
   \       0x22   0x....             B.N      ?Subroutine0
    567            } else {
    568              prio = (osPriority_t)((int32_t)uxTaskPriorityGet (hTask));
   \                     ??osThreadGetPriority_2: (+1)
   \       0x24   0x.... 0x....      B.W      uxTaskPriorityGet
    569            }
    570          
    571            return (prio);
    572          }
    573          

   \                                 In section .text, align 2, keep-with-next
    574          osStatus_t osThreadYield (void) {
   \                     osThreadYield: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    575            osStatus_t stat;
    576          
    577            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0xB948             CBNZ.N   R0,??osThreadYield_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_26: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osThreadYield_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x1A   0xD102             BNE.N    ??osThreadYield_1
    578              stat = osErrorISR;
   \                     ??osThreadYield_0: (+1)
   \       0x1C   0xF06F 0x0405      MVN      R4,#+5
   \       0x20   0xE002             B.N      ??osThreadYield_2
    579            } else {
    580              stat = osOK;
   \                     ??osThreadYield_1: (+1)
   \       0x22   0x2400             MOVS     R4,#+0
    581              taskYIELD();
   \       0x24   0x.... 0x....      BL       vPortYield
    582            }
    583          
    584            return (stat);
   \                     ??osThreadYield_2: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0xBD10             POP      {R4,PC}
    585          }
    586          
    587          #if (configUSE_OS2_THREAD_SUSPEND_RESUME == 1)

   \                                 In section .text, align 2, keep-with-next
    588          osStatus_t osThreadSuspend (osThreadId_t thread_id) {
   \                     osThreadSuspend: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    589            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    590            osStatus_t stat;
    591          
    592            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB961             CBNZ.N   R1,??osThreadSuspend_0
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD007             BEQ.N    ??osThreadSuspend_1
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable22_1
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x2902             CMP      R1,#+2
   \       0x20   0xD102             BNE.N    ??osThreadSuspend_1
    593              stat = osErrorISR;
   \                     ??osThreadSuspend_0: (+1)
   \       0x22   0xF06F 0x0405      MVN      R4,#+5
   \       0x26   0xE006             B.N      ??osThreadSuspend_2
    594            }
    595            else if (hTask == NULL) {
   \                     ??osThreadSuspend_1: (+1)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xBF0E             ITEE     EQ
    596              stat = osErrorParameter;
   \       0x2C   0xF06F 0x0403      MVNEQ    R4,#+3
    597            }
    598            else {
    599              stat = osOK;
   \       0x30   0x2400             MOVNE    R4,#+0
    600              vTaskSuspend (hTask);
   \       0x32   0x.... 0x....      BLNE     vTaskSuspend
    601            }
    602          
    603            return (stat);
   \                     ??osThreadSuspend_2: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD10             POP      {R4,PC}
    604          }
    605          

   \                                 In section .text, align 2, keep-with-next
    606          osStatus_t osThreadResume (osThreadId_t thread_id) {
   \                     osThreadResume: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    607            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    608            osStatus_t stat;
    609          
    610            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB961             CBNZ.N   R1,??osThreadResume_0
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD007             BEQ.N    ??osThreadResume_1
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable22_1
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x2902             CMP      R1,#+2
   \       0x20   0xD102             BNE.N    ??osThreadResume_1
    611              stat = osErrorISR;
   \                     ??osThreadResume_0: (+1)
   \       0x22   0xF06F 0x0405      MVN      R4,#+5
   \       0x26   0xE006             B.N      ??osThreadResume_2
    612            }
    613            else if (hTask == NULL) {
   \                     ??osThreadResume_1: (+1)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xBF0E             ITEE     EQ
    614              stat = osErrorParameter;
   \       0x2C   0xF06F 0x0403      MVNEQ    R4,#+3
    615            }
    616            else {
    617              stat = osOK;
   \       0x30   0x2400             MOVNE    R4,#+0
    618              vTaskResume (hTask);
   \       0x32   0x.... 0x....      BLNE     vTaskResume
    619            }
    620          
    621            return (stat);
   \                     ??osThreadResume_2: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD10             POP      {R4,PC}
    622          }
    623          #endif /* (configUSE_OS2_THREAD_SUSPEND_RESUME == 1) */
    624          

   \                                 In section .text, align 2, keep-with-next
    625          __NO_RETURN void osThreadExit (void) {
    626          #ifndef USE_FreeRTOS_HEAP_1
    627            vTaskDelete (NULL);
   \                     osThreadExit: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      BL       vTaskDelete
    628          #endif
    629            for (;;);
   \                     ??osThreadExit_0: (+1)
   \        0x6   0xE7FE             B.N      ??osThreadExit_0
    630          }
    631          

   \                                 In section .text, align 2, keep-with-next
    632          osStatus_t osThreadTerminate (osThreadId_t thread_id) {
   \                     osThreadTerminate: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
    633            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    634            osStatus_t stat;
    635          #ifndef USE_FreeRTOS_HEAP_1
    636            eTaskState tstate;
    637          
    638            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_54: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osThreadTerminate_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_27: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osThreadTerminate_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x1A   0xD102             BNE.N    ??osThreadTerminate_1
    639              stat = osErrorISR;
   \                     ??osThreadTerminate_0: (+1)
   \       0x1C   0xF06F 0x0505      MVN      R5,#+5
   \       0x20   0xE00F             B.N      ??osThreadTerminate_2
    640            }
    641            else if (hTask == NULL) {
   \                     ??osThreadTerminate_1: (+1)
   \       0x22   0xB914             CBNZ.N   R4,??osThreadTerminate_3
    642              stat = osErrorParameter;
   \       0x24   0xF06F 0x0503      MVN      R5,#+3
   \       0x28   0xE00B             B.N      ??osThreadTerminate_2
    643            }
    644            else {
    645              tstate = eTaskGetState (hTask);
    646          
    647              if (tstate != eDeleted) {
   \                     ??osThreadTerminate_3: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       eTaskGetState
   \       0x30   0x2804             CMP      R0,#+4
   \       0x32   0xD004             BEQ.N    ??osThreadTerminate_4
    648                stat = osOK;
    649                vTaskDelete (hTask);
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x2500             MOVS     R5,#+0
   \       0x38   0x.... 0x....      BL       vTaskDelete
   \       0x3C   0xE001             B.N      ??osThreadTerminate_2
    650              } else {
    651                stat = osErrorResource;
   \                     ??osThreadTerminate_4: (+1)
   \       0x3E   0xF06F 0x0502      MVN      R5,#+2
    652              }
    653            }
    654          #else
    655            stat = osError;
    656          #endif
    657          
    658            return (stat);
   \                     ??osThreadTerminate_2: (+1)
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0xBD32             POP      {R1,R4,R5,PC}
    659          }
    660          

   \                                 In section .text, align 2, keep-with-next
    661          uint32_t osThreadGetCount (void) {
    662            uint32_t count;
    663          
    664            if (IS_IRQ()) {
   \                     osThreadGetCount: (+1)
   \        0x0   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x4   0xB960             CBNZ.N   R0,??osThreadGetCount_0
   \        0x6   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD006             BEQ.N    ??osThreadGetCount_1
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable22_1
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD101             BNE.N    ??osThreadGetCount_1
    665              count = 0U;
   \                     ??osThreadGetCount_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR
    666            } else {
    667              count = uxTaskGetNumberOfTasks();
   \                     ??osThreadGetCount_1: (+1)
   \       0x24   0x.... 0x....      B.W      uxTaskGetNumberOfTasks
    668            }
    669          
    670            return (count);
    671          }
    672          
    673          #if (configUSE_OS2_THREAD_ENUMERATE == 1)

   \                                 In section .text, align 2, keep-with-next
    674          uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
   \                     osThreadEnumerate: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    675            uint32_t i, count;
    676            TaskStatus_t *task;
    677          
    678            if (IS_IRQ() || (thread_array == NULL) || (array_items == 0U)) {
   \        0x8   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xC   0xB968             CBNZ.N   R0,??osThreadEnumerate_0
   \        0xE   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x12   0xBF04             ITT      EQ
   \       0x14   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x18   0x2800             CMPEQ    R0,#+0
   \       0x1A   0xD002             BEQ.N    ??osThreadEnumerate_1
   \       0x1C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x20   0xD003             BEQ.N    ??osThreadEnumerate_0
   \                     ??osThreadEnumerate_1: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2D00             CMPNE    R5,#+0
   \       0x28   0xD101             BNE.N    ??osThreadEnumerate_2
    679              count = 0U;
   \                     ??osThreadEnumerate_0: (+1)
   \       0x2A   0x2700             MOVS     R7,#+0
   \       0x2C   0xE021             B.N      ??osThreadEnumerate_3
    680            } else {
    681              vTaskSuspendAll();
   \                     ??osThreadEnumerate_2: (+1)
   \       0x2E   0x.... 0x....      BL       vTaskSuspendAll
    682          
    683              count = uxTaskGetNumberOfTasks();
   \       0x32   0x.... 0x....      BL       uxTaskGetNumberOfTasks
   \       0x36   0x4607             MOV      R7,R0
    684              task  = pvPortMalloc (count * sizeof(TaskStatus_t));
   \       0x38   0xF04F 0x0824      MOV      R8,#+36
   \       0x3C   0xFB08 0xF007      MUL      R0,R8,R7
   \       0x40   0x.... 0x....      BL       pvPortMalloc
   \       0x44   0x0006             MOVS     R6,R0
    685          
    686              if (task != NULL) {
   \       0x46   0xD00F             BEQ.N    ??osThreadEnumerate_4
    687                count = uxTaskGetSystemState (task, count, NULL);
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0x4639             MOV      R1,R7
   \       0x4C   0x.... 0x....      BL       uxTaskGetSystemState
    688          
    689                for (i = 0U; (i < count) && (i < array_items); i++) {
   \       0x50   0x2700             MOVS     R7,#+0
   \       0x52   0xE005             B.N      ??osThreadEnumerate_5
    690                  thread_array[i] = (osThreadId_t)task[i].xHandle;
   \                     ??osThreadEnumerate_6: (+1)
   \       0x54   0xFB08 0xF107      MUL      R1,R8,R7
   \       0x58   0x5871             LDR      R1,[R6, R1]
   \       0x5A   0xF844 0x1027      STR      R1,[R4, R7, LSL #+2]
    691                }
   \       0x5E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??osThreadEnumerate_5: (+1)
   \       0x60   0x4287             CMP      R7,R0
   \       0x62   0xBF38             IT       CC
   \       0x64   0x42AF             CMPCC    R7,R5
   \       0x66   0xD3F5             BCC.N    ??osThreadEnumerate_6
    692                count = i;
    693              }
    694              (void)xTaskResumeAll();
   \                     ??osThreadEnumerate_4: (+1)
   \       0x68   0x.... 0x....      BL       xTaskResumeAll
    695          
    696              vPortFree (task);
   \       0x6C   0x4630             MOV      R0,R6
   \       0x6E   0x.... 0x....      BL       vPortFree
    697            }
    698          
    699            return (count);
   \                     ??osThreadEnumerate_3: (+1)
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0xE8BD 0x81F0      POP      {R4-R8,PC}
    700          }
    701          #endif /* (configUSE_OS2_THREAD_ENUMERATE == 1) */
    702          
    703          #if (configUSE_OS2_THREAD_FLAGS == 1)

   \                                 In section .text, align 2, keep-with-next
    704          uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
   \                     osThreadFlagsSet: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460A             MOV      R2,R1
    705            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    706            uint32_t rflags;
    707            BaseType_t yield;
    708          
    709            if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
   \        0x6   0xD001             BEQ.N    ??osThreadFlagsSet_0
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD503             BPL.N    ??osThreadFlagsSet_1
    710              rflags = (uint32_t)osErrorParameter;
   \                     ??osThreadFlagsSet_0: (+1)
   \        0xC   0xF06F 0x0203      MVN      R2,#+3
   \       0x10   0x9202             STR      R2,[SP, #+8]
   \       0x12   0xE03B             B.N      ??osThreadFlagsSet_2
    711            }
    712            else {
    713              rflags = (uint32_t)osError;
   \                     ??osThreadFlagsSet_1: (+1)
   \       0x14   0xF04F 0x31FF      MOV      R1,#+4294967295
   \       0x18   0x9102             STR      R1,[SP, #+8]
    714          
    715              if (IS_IRQ()) {
   \       0x1A   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x1E   0xB958             CBNZ.N   R0,??osThreadFlagsSet_3
   \       0x20   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x24   0xBF04             ITT      EQ
   \       0x26   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x2A   0x2800             CMPEQ    R0,#+0
   \       0x2C   0xD020             BEQ.N    ??osThreadFlagsSet_4
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0x2902             CMP      R1,#+2
   \       0x36   0xD11B             BNE.N    ??osThreadFlagsSet_4
    716                yield = pdFALSE;
   \                     ??osThreadFlagsSet_3: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x9003             STR      R0,[SP, #+12]
    717          
    718                (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
   \       0x3C   0xAE03             ADD      R6,SP,#+12
   \       0x3E   0x2500             MOVS     R5,#+0
   \       0x40   0x9601             STR      R6,[SP, #+4]
   \       0x42   0x9500             STR      R5,[SP, #+0]
   \       0x44   0x2301             MOVS     R3,#+1
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x.... 0x....      BL       xTaskGenericNotifyFromISR
    719                (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
   \       0x4E   0xA802             ADD      R0,SP,#+8
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x9201             STR      R2,[SP, #+4]
   \       0x56   0x2300             MOVS     R3,#+0
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x.... 0x....      BL       xTaskGenericNotifyFromISR
    720          
    721                portYIELD_FROM_ISR (yield);
   \       0x60   0x9803             LDR      R0,[SP, #+12]
   \       0x62   0xB198             CBZ.N    R0,??osThreadFlagsSet_2
   \       0x64   0xF04F 0x5280      MOV      R2,#+268435456
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable30
   \       0x6C   0x600A             STR      R2,[R1, #+0]
   \       0x6E   0xE00D             B.N      ??osThreadFlagsSet_2
    722              }
    723              else {
    724                (void)xTaskNotify (hTask, flags, eSetBits);
   \                     ??osThreadFlagsSet_4: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x2301             MOVS     R3,#+1
   \       0x76   0x2100             MOVS     R1,#+0
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x.... 0x....      BL       xTaskGenericNotify
    725                (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
   \       0x7E   0xA802             ADD      R0,SP,#+8
   \       0x80   0x.... 0x....      BL       ??Subroutine16_0
    726              }
    727            }
   \                     ??CrossCallReturnLabel_94: (+1)
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0x4620             MOV      R0,R4
   \       0x88   0x.... 0x....      BL       xTaskGenericNotify
    728            /* Return flags after setting */
    729            return (rflags);
   \                     ??osThreadFlagsSet_2: (+1)
   \       0x8C   0x9802             LDR      R0,[SP, #+8]
   \       0x8E   0xB004             ADD      SP,SP,#+16
   \       0x90   0xBD70             POP      {R4-R6,PC}
    730          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \                     ??Subroutine16_0: (+1)
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x4770             BX       LR
    731          

   \                                 In section .text, align 2, keep-with-next
    732          uint32_t osThreadFlagsClear (uint32_t flags) {
   \                     osThreadFlagsClear: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
    733            TaskHandle_t hTask;
    734            uint32_t rflags, cflags;
    735          
    736            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_55: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osThreadFlagsClear_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_30: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osThreadFlagsClear_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x1A   0xD102             BNE.N    ??osThreadFlagsClear_1
    737              rflags = (uint32_t)osErrorISR;
   \                     ??osThreadFlagsClear_0: (+1)
   \       0x1C   0xF06F 0x0705      MVN      R7,#+5
   \       0x20   0xE020             B.N      ??osThreadFlagsClear_2
    738            }
    739            else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
   \                     ??osThreadFlagsClear_1: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xBF48             IT       MI
   \       0x26   0xF06F 0x0703      MVNMI    R7,#+3
    740              rflags = (uint32_t)osErrorParameter;
   \       0x2A   0xD41B             BMI.N    ??osThreadFlagsClear_2
    741            }
    742            else {
    743              hTask = xTaskGetCurrentTaskHandle();
   \       0x2C   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x30   0x4605             MOV      R5,R0
    744          
    745              if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &cflags) == pdPASS) {
   \       0x32   0xA801             ADD      R0,SP,#+4
   \       0x34   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_95: (+1)
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x.... 0x....      BL       xTaskGenericNotify
   \       0x40   0xF04F 0x36FF      MOV      R6,#+4294967295
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD10C             BNE.N    ??osThreadFlagsClear_3
    746                rflags = cflags;
   \       0x48   0x9F01             LDR      R7,[SP, #+4]
    747                cflags &= ~flags;
    748          
    749                if (xTaskNotify (hTask, cflags, eSetValueWithOverwrite) != pdPASS) {
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x9100             STR      R1,[SP, #+0]
   \       0x4E   0xEA27 0x0404      BIC      R4,R7,R4
   \       0x52   0x9401             STR      R4,[SP, #+4]
   \       0x54   0x9A01             LDR      R2,[SP, #+4]
   \       0x56   0x2303             MOVS     R3,#+3
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x.... 0x....      BL       xTaskGenericNotify
   \       0x5E   0x2801             CMP      R0,#+1
   \       0x60   0xD000             BEQ.N    ??osThreadFlagsClear_2
    750                  rflags = (uint32_t)osError;
    751                }
    752              }
    753              else {
    754                rflags = (uint32_t)osError;
   \                     ??osThreadFlagsClear_3: (+1)
   \       0x62   0x4637             MOV      R7,R6
    755              }
    756            }
    757          
    758            /* Return flags before clearing */
    759            return (rflags);
   \                     ??osThreadFlagsClear_2: (+1)
   \       0x64   0x4638             MOV      R0,R7
   \       0x66   0xBDFE             POP      {R1-R7,PC}
    760          }
    761          

   \                                 In section .text, align 2, keep-with-next
    762          uint32_t osThreadFlagsGet (void) {
   \                     osThreadFlagsGet: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    763            TaskHandle_t hTask;
    764            uint32_t rflags;
    765          
    766            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0xB958             CBNZ.N   R0,??osThreadFlagsGet_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_31: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD007             BEQ.N    ??osThreadFlagsGet_1
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD102             BNE.N    ??osThreadFlagsGet_1
    767              rflags = (uint32_t)osErrorISR;
   \                     ??osThreadFlagsGet_0: (+1)
   \       0x20   0xF06F 0x0005      MVN      R0,#+5
   \       0x24   0xE00C             B.N      ??osThreadFlagsGet_2
    768            }
    769            else {
    770              hTask = xTaskGetCurrentTaskHandle();
   \                     ??osThreadFlagsGet_1: (+1)
   \       0x26   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
    771          
    772              if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags) != pdPASS) {
   \       0x2A   0xA901             ADD      R1,SP,#+4
   \       0x2C   0x9100             STR      R1,[SP, #+0]
   \       0x2E   0x2300             MOVS     R3,#+0
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x.... 0x....      BL       xTaskGenericNotify
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD002             BEQ.N    ??osThreadFlagsGet_3
    773                rflags = (uint32_t)osError;
   \       0x3C   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??osThreadFlagsGet_2: (+1)
   \       0x40   0x9001             STR      R0,[SP, #+4]
    774              }
    775            }
    776          
    777            return (rflags);
   \                     ??osThreadFlagsGet_3: (+1)
   \       0x42   0x9801             LDR      R0,[SP, #+4]
   \       0x44   0xBD0E             POP      {R1-R3,PC}
    778          }
    779          

   \                                 In section .text, align 2, keep-with-next
    780          uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     osThreadFlagsWait: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x460E             MOV      R6,R1
    781            uint32_t rflags, nval;
    782            uint32_t clear;
    783            TickType_t t0, td, tout;
    784            BaseType_t rval;
    785          
    786            if (IS_IRQ()) {
   \        0x8   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xC   0xB948             CBNZ.N   R0,??osThreadFlagsWait_0
   \        0xE   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x12   0xBF04             ITT      EQ
   \       0x14   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x18   0x2800             CMPEQ    R0,#+0
   \       0x1A   0xD006             BEQ.N    ??osThreadFlagsWait_1
   \       0x1C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x20   0xD103             BNE.N    ??osThreadFlagsWait_1
    787              rflags = (uint32_t)osErrorISR;
   \                     ??osThreadFlagsWait_0: (+1)
   \       0x22   0xF06F 0x0005      MVN      R0,#+5
    788            }
    789            else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
    790              rflags = (uint32_t)osErrorParameter;
    791            }
    792            else {
    793              if ((options & osFlagsNoClear) == osFlagsNoClear) {
    794                clear = 0U;
    795              } else {
    796                clear = flags;
    797              }
    798          
    799              rflags = 0U;
    800              tout   = timeout;
    801          
    802              t0 = xTaskGetTickCount();
    803              do {
    804                rval = xTaskNotifyWait (0, clear, &nval, tout);
    805          
    806                if (rval == pdPASS) {
    807                  rflags &= flags;
    808                  rflags |= nval;
    809          
    810                  if ((options & osFlagsWaitAll) == osFlagsWaitAll) {
    811                    if ((flags & rflags) == flags) {
    812                      break;
    813                    } else {
    814                      if (timeout == 0U) {
    815                        rflags = (uint32_t)osErrorResource;
    816                        break;
    817                      }
    818                    }
    819                  }
    820                  else {
    821                    if ((flags & rflags) != 0) {
    822                      break;
    823                    } else {
    824                      if (timeout == 0U) {
    825                        rflags = (uint32_t)osErrorResource;
    826                        break;
    827                      }
    828                    }
    829                  }
    830          
    831                  /* Update timeout */
    832                  td = xTaskGetTickCount() - t0;
    833          
    834                  if (td > tout) {
    835                    tout  = 0;
    836                  } else {
    837                    tout -= td;
    838                  }
    839                }
    840                else {
    841                  if (timeout == 0) {
    842                    rflags = (uint32_t)osErrorResource;
    843                  } else {
    844                    rflags = (uint32_t)osErrorTimeout;
    845                  }
    846                }
    847              }
    848              while (rval != pdFAIL);
    849            }
    850          
    851            /* Return flags before clearing */
    852            return (rflags);
   \                     ??osThreadFlagsWait_2: (+1)
   \       0x26   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   \                     ??osThreadFlagsWait_1: (+1)
   \       0x2A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x2E   0xBF48             IT       MI
   \       0x30   0xF06F 0x0003      MVNMI    R0,#+3
   \       0x34   0xD4F7             BMI.N    ??osThreadFlagsWait_2
   \       0x36   0x07B0             LSLS     R0,R6,#+30
   \       0x38   0xBF4C             ITE      MI
   \       0x3A   0xF04F 0x0800      MOVMI    R8,#+0
   \       0x3E   0x46C8             MOVPL    R8,R9
   \       0x40   0x4614             MOV      R4,R2
   \       0x42   0x.... 0x....      BL       xTaskGetTickCount
   \       0x46   0x2700             MOVS     R7,#+0
   \       0x48   0x4625             MOV      R5,R4
   \       0x4A   0x4682             MOV      R10,R0
   \       0x4C   0xF06F 0x0B02      MVN      R11,#+2
   \       0x50   0xE007             B.N      ??osThreadFlagsWait_3
   \                     ??osThreadFlagsWait_4: (+1)
   \       0x52   0x.... 0x....      BL       xTaskGetTickCount
   \       0x56   0xEBA0 0x000A      SUB      R0,R0,R10
   \       0x5A   0x4285             CMP      R5,R0
   \       0x5C   0xBF2C             ITE      CS
   \       0x5E   0x1A2D             SUBCS    R5,R5,R0
   \       0x60   0x2500             MOVCC    R5,#+0
   \                     ??osThreadFlagsWait_3: (+1)
   \       0x62   0x9500             STR      R5,[SP, #+0]
   \       0x64   0xAB01             ADD      R3,SP,#+4
   \       0x66   0x4642             MOV      R2,R8
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x.... 0x....      BL       xTaskGenericNotifyWait
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xD111             BNE.N    ??osThreadFlagsWait_5
   \       0x74   0xEA09 0x0007      AND      R0,R9,R7
   \       0x78   0x9F01             LDR      R7,[SP, #+4]
   \       0x7A   0x4307             ORRS     R7,R7,R0
   \       0x7C   0xEA07 0x0009      AND      R0,R7,R9
   \       0x80   0x07F1             LSLS     R1,R6,#+31
   \       0x82   0xD503             BPL.N    ??osThreadFlagsWait_6
   \       0x84   0x4548             CMP      R0,R9
   \       0x86   0xD103             BNE.N    ??osThreadFlagsWait_7
   \                     ??osThreadFlagsWait_8: (+1)
   \       0x88   0x4638             MOV      R0,R7
   \       0x8A   0xE7CC             B.N      ??osThreadFlagsWait_2
   \                     ??osThreadFlagsWait_6: (+1)
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD1FB             BNE.N    ??osThreadFlagsWait_8
   \                     ??osThreadFlagsWait_7: (+1)
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD1DE             BNE.N    ??osThreadFlagsWait_4
   \       0x94   0x465F             MOV      R7,R11
   \       0x96   0xE7F7             B.N      ??osThreadFlagsWait_8
   \                     ??osThreadFlagsWait_5: (+1)
   \       0x98   0x2C00             CMP      R4,#+0
   \       0x9A   0xBF0C             ITE      EQ
   \       0x9C   0x465F             MOVEQ    R7,R11
   \       0x9E   0xF06F 0x0701      MVNNE    R7,#+1
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD1DD             BNE.N    ??osThreadFlagsWait_3
   \       0xA6   0xE7EF             B.N      ??osThreadFlagsWait_8
    853          }
    854          #endif /* (configUSE_OS2_THREAD_FLAGS == 1) */
    855          

   \                                 In section .text, align 2, keep-with-next
    856          osStatus_t osDelay (uint32_t ticks) {
   \                     osDelay: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    857            osStatus_t stat;
    858          
    859            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB949             CBNZ.N   R1,??osDelay_0
   \        0x8   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_68: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD005             BEQ.N    ??osDelay_1
   \       0x16   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x1A   0xD102             BNE.N    ??osDelay_1
    860              stat = osErrorISR;
   \                     ??osDelay_0: (+1)
   \       0x1C   0xF06F 0x0405      MVN      R4,#+5
   \       0x20   0xE003             B.N      ??osDelay_2
    861            }
    862            else {
    863              stat = osOK;
   \                     ??osDelay_1: (+1)
   \       0x22   0x2400             MOVS     R4,#+0
    864          
    865              if (ticks != 0U) {
   \       0x24   0xB108             CBZ.N    R0,??osDelay_2
    866                vTaskDelay(ticks);
   \       0x26   0x.... 0x....      BL       vTaskDelay
    867              }
    868            }
    869          
    870            return (stat);
   \                     ??osDelay_2: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xBD10             POP      {R4,PC}
    871          }
    872          

   \                                 In section .text, align 2, keep-with-next
    873          osStatus_t osDelayUntil (uint32_t ticks) {
   \                     osDelayUntil: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
    874            TickType_t tcnt, delay;
    875            osStatus_t stat;
    876          
    877            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_56: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osDelayUntil_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_33: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osDelayUntil_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x1A   0xD102             BNE.N    ??osDelayUntil_1
    878              stat = osErrorISR;
   \                     ??osDelayUntil_0: (+1)
   \       0x1C   0xF06F 0x0505      MVN      R5,#+5
   \       0x20   0xE00E             B.N      ??osDelayUntil_2
    879            }
    880            else {
    881              stat = osOK;
   \                     ??osDelayUntil_1: (+1)
   \       0x22   0x2500             MOVS     R5,#+0
    882              tcnt = xTaskGetTickCount();
   \       0x24   0x.... 0x....      BL       xTaskGetTickCount
   \       0x28   0x9000             STR      R0,[SP, #+0]
    883          
    884              /* Determine remaining number of ticks to delay */
    885              delay = (TickType_t)ticks - tcnt;
   \       0x2A   0x1A24             SUBS     R4,R4,R0
    886          
    887              /* Check if target tick has not expired */
    888              if((delay != 0U) && (0 == (delay >> (8 * sizeof(TickType_t) - 1)))) {
   \       0x2C   0xD006             BEQ.N    ??osDelayUntil_3
   \       0x2E   0x0FE0             LSRS     R0,R4,#+31
   \       0x30   0xD104             BNE.N    ??osDelayUntil_3
    889                vTaskDelayUntil (&tcnt, delay);
   \       0x32   0x4621             MOV      R1,R4
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0x.... 0x....      BL       xTaskDelayUntil
   \       0x3A   0xE001             B.N      ??osDelayUntil_2
    890              }
    891              else
    892              {
    893                /* No delay or already expired */
    894                stat = osErrorParameter;
   \                     ??osDelayUntil_3: (+1)
   \       0x3C   0xF06F 0x0503      MVN      R5,#+3
    895              }
    896            }
    897          
    898            return (stat);
   \                     ??osDelayUntil_2: (+1)
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    899          }
    900          
    901          /*---------------------------------------------------------------------------*/
    902          #if (configUSE_OS2_TIMER == 1)
    903          

   \                                 In section .text, align 2, keep-with-next
    904          static void TimerCallback (TimerHandle_t hTimer) {
   \                     TimerCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    905            TimerCallback_t *callb;
    906          
    907            callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
   \        0x2   0x.... 0x....      BL       pvTimerGetTimerID
   \        0x6   0x0001             MOVS     R1,R0
    908          
    909            if (callb != NULL) {
   \        0x8   0xD004             BEQ.N    ??TimerCallback_0
    910              callb->func (callb->arg);
   \        0xA   0x6848             LDR      R0,[R1, #+4]
   \        0xC   0x6809             LDR      R1,[R1, #+0]
   \        0xE   0xE8BD 0x4004      POP      {R2,LR}
   \       0x12   0x4708             BX       R1
    911            }
    912          }
   \                     ??TimerCallback_0: (+1)
   \       0x14   0xBD01             POP      {R0,PC}
    913          

   \                                 In section .text, align 2, keep-with-next
    914          osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
   \                     osTimerNew: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461E             MOV      R6,R3
    915            const char *name;
    916            TimerHandle_t hTimer;
    917            TimerCallback_t *callb;
    918            UBaseType_t reload;
    919            int32_t mem;
    920          
    921            hTimer = NULL;
   \        0xC   0x2400             MOVS     R4,#+0
    922          
    923            if (!IS_IRQ() && (func != NULL)) {
   \        0xE   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x12   0xBB70             CBNZ.N   R0,??osTimerNew_0
   \       0x14   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x18   0xBF04             ITT      EQ
   \       0x1A   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x1E   0x2800             CMPEQ    R0,#+0
   \       0x20   0xD002             BEQ.N    ??osTimerNew_1
   \       0x22   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x26   0xD024             BEQ.N    ??osTimerNew_0
   \                     ??osTimerNew_1: (+1)
   \       0x28   0xB31D             CBZ.N    R5,??osTimerNew_0
    924              /* Allocate memory to store callback function and argument */
    925              callb = pvPortMalloc (sizeof(TimerCallback_t));
   \       0x2A   0x2008             MOVS     R0,#+8
   \       0x2C   0x.... 0x....      BL       pvPortMalloc
   \       0x30   0xEA5F 0x0900      MOVS     R9,R0
    926          
    927              if (callb != NULL) {
   \       0x34   0xD01D             BEQ.N    ??osTimerNew_0
    928                callb->func = func;
   \       0x36   0xF8C9 0x5000      STR      R5,[R9, #+0]
    929                callb->arg  = argument;
   \       0x3A   0xF8C9 0x8004      STR      R8,[R9, #+4]
    930          
    931                if (type == osTimerOnce) {
   \       0x3E   0x003A             MOVS     R2,R7
   \       0x40   0xBF18             IT       NE
   \       0x42   0x2201             MOVNE    R2,#+1
    932                  reload = pdFALSE;
    933                } else {
    934                  reload = pdTRUE;
    935                }
    936          
    937                mem  = -1;
    938                name = NULL;
   \       0x44   0x2000             MOVS     R0,#+0
    939          
    940                if (attr != NULL) {
   \       0x46   0x.... 0x....      LDR.W    R7,??DataTable34
   \       0x4A   0xB1BE             CBZ.N    R6,??osTimerNew_2
    941                  if (attr->name != NULL) {
   \       0x4C   0x6831             LDR      R1,[R6, #+0]
   \       0x4E   0xB101             CBZ.N    R1,??osTimerNew_3
    942                    name = attr->name;
   \       0x50   0x4608             MOV      R0,R1
    943                  }
    944          
    945                  if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticTimer_t))) {
   \                     ??osTimerNew_3: (+1)
   \       0x52   0x68B3             LDR      R3,[R6, #+8]
   \       0x54   0x68F1             LDR      R1,[R6, #+12]
   \       0x56   0xB17B             CBZ.N    R3,??osTimerNew_4
   \       0x58   0x292C             CMP      R1,#+44
   \       0x5A   0xD307             BCC.N    ??osTimerNew_5
    946                    mem = 1;
    947                  }
    948                  else {
    949                    if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
    950                      mem = 0;
    951                    }
    952                  }
    953                }
    954                else {
    955                  mem = 0;
    956                }
    957          
    958                if (mem == 1) {
    959                  #if (configSUPPORT_STATIC_ALLOCATION == 1)
    960                    hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
   \       0x5C   0x9301             STR      R3,[SP, #+4]
   \       0x5E   0x9700             STR      R7,[SP, #+0]
   \       0x60   0x464B             MOV      R3,R9
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0x.... 0x....      BL       xTimerCreateStatic
   \                     ??osTimerNew_6: (+1)
   \       0x68   0x0004             MOVS     R4,R0
    961                  #endif
    962                }
    963                else {
    964                  if (mem == 0) {
    965                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
    966                      hTimer = xTimerCreate (name, 1, reload, callb, TimerCallback);
    967                    #endif
    968                  }
    969                }
    970          
    971                if ((hTimer == NULL) && (callb != NULL)) {
   \       0x6A   0xD102             BNE.N    ??osTimerNew_0
    972                  vPortFree (callb);
   \                     ??osTimerNew_5: (+1)
   \       0x6C   0x4648             MOV      R0,R9
   \       0x6E   0x.... 0x....      BL       vPortFree
    973                }
    974              }
    975            }
    976          
    977            return ((osTimerId_t)hTimer);
   \                     ??osTimerNew_0: (+1)
   \       0x72   0x4620             MOV      R0,R4
   \       0x74   0xE8BD 0x83FE      POP      {R1-R9,PC}
   \                     ??osTimerNew_4: (+1)
   \       0x78   0x2900             CMP      R1,#+0
   \       0x7A   0xD1F7             BNE.N    ??osTimerNew_5
   \                     ??osTimerNew_2: (+1)
   \       0x7C   0x9700             STR      R7,[SP, #+0]
   \       0x7E   0x464B             MOV      R3,R9
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x.... 0x....      BL       xTimerCreate
   \       0x86   0xE7EF             B.N      ??osTimerNew_6
    978          }
    979          

   \                                 In section .text, align 2, keep-with-next
    980          const char *osTimerGetName (osTimerId_t timer_id) {
    981            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
    982            const char *p;
    983          
    984            if (IS_IRQ() || (hTimer == NULL)) {
   \                     osTimerGetName: (+1)
   \        0x0   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x4   0xB961             CBNZ.N   R1,??osTimerGetName_0
   \        0x6   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD003             BEQ.N    ??osTimerGetName_1
   \       0x16   0x....             LDR.N    R2,??DataTable22_1
   \       0x18   0x6811             LDR      R1,[R2, #+0]
   \       0x1A   0x2902             CMP      R1,#+2
   \       0x1C   0xD000             BEQ.N    ??osTimerGetName_0
   \                     ??osTimerGetName_1: (+1)
   \       0x1E   0xB908             CBNZ.N   R0,??osTimerGetName_2
    985              p = NULL;
   \                     ??osTimerGetName_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR
    986            } else {
    987              p = pcTimerGetName (hTimer);
   \                     ??osTimerGetName_2: (+1)
   \       0x24   0x.... 0x....      B.W      pcTimerGetName
    988            }
    989          
    990            return (p);
    991          }
    992          

   \                                 In section .text, align 2, keep-with-next
    993          osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
   \                     osTimerStart: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460A             MOV      R2,R1
    994            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
    995            osStatus_t stat;
    996          
    997            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x8   0xB951             CBNZ.N   R1,??osTimerStart_0
   \        0xA   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_69: (+1)
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD004             BEQ.N    ??osTimerStart_1
   \       0x18   0x....             LDR.N    R3,??DataTable22_1
   \       0x1A   0x6819             LDR      R1,[R3, #+0]
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD100             BNE.N    ??osTimerStart_1
    998              stat = osErrorISR;
   \                     ??osTimerStart_0: (+1)
   \       0x20   0x....             B.N      ?Subroutine5
    999            }
   1000            else if (hTimer == NULL) {
   \                     ??osTimerStart_1: (+1)
   \       0x22   0xB900             CBNZ.N   R0,??osTimerStart_2
   1001              stat = osErrorParameter;
   \       0x24   0x....             B.N      ?Subroutine4
   1002            }
   1003            else {
   1004              if (xTimerChangePeriod (hTimer, ticks, 0) == pdPASS) {
   \                     ??osTimerStart_2: (+1)
   \       0x26   0x2400             MOVS     R4,#+0
   \       0x28   0x9400             STR      R4,[SP, #+0]
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x.... 0x....      BL       xTimerGenericCommand
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD101             BNE.N    ??osTimerStart_3
   1005                stat = osOK;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD16             POP      {R1,R2,R4,PC}
   1006              } else {
   1007                stat = osErrorResource;
   \                     ??osTimerStart_3: (+1)
   \       0x3A                      REQUIRE ?Subroutine3
   \       0x3A                      ;; // Fall through to label ?Subroutine3
   1008              }
   1009            }
   1010          
   1011            return (stat);
   1012          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF06F 0x0002      MVN      R0,#+2
   \        0x4   0xBD16             POP      {R1,R2,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF06F 0x0005      MVN      R0,#+5
   \        0x4   0xBD16             POP      {R1,R2,R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xF06F 0x0003      MVN      R0,#+3
   \        0x4   0xBD16             POP      {R1,R2,R4,PC}
   1013          

   \                                 In section .text, align 2, keep-with-next
   1014          osStatus_t osTimerStop (osTimerId_t timer_id) {
   \                     osTimerStop: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1015            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1016            osStatus_t stat;
   1017          
   1018            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_57: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osTimerStop_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_35: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD003             BEQ.N    ??osTimerStop_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x1A   0xD100             BNE.N    ??osTimerStop_1
   1019              stat = osErrorISR;
   \                     ??osTimerStop_0: (+1)
   \       0x1C   0x....             B.N      ?Subroutine5
   1020            }
   1021            else if (hTimer == NULL) {
   \                     ??osTimerStop_1: (+1)
   \       0x1E   0xB904             CBNZ.N   R4,??osTimerStop_2
   1022              stat = osErrorParameter;
   \       0x20   0x....             B.N      ?Subroutine4
   1023            }
   1024            else {
   1025              if (xTimerIsTimerActive (hTimer) == pdFALSE) {
   \                     ??osTimerStop_2: (+1)
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       xTimerIsTimerActive
   \       0x28   0xB900             CBNZ.N   R0,??osTimerStop_3
   1026                stat = osErrorResource;
   \       0x2A   0x....             B.N      ?Subroutine3
   1027              }
   1028              else {
   1029                if (xTimerStop (hTimer, 0) == pdPASS) {
   \                     ??osTimerStop_3: (+1)
   \       0x2C   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_96: (+1)
   \       0x30   0x2103             MOVS     R1,#+3
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x.... 0x....      BL       xTimerGenericCommand
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD101             BNE.N    ??osTimerStop_4
   1030                  stat = osOK;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBD16             POP      {R1,R2,R4,PC}
   1031                } else {
   1032                  stat = osError;
   \                     ??osTimerStop_4: (+1)
   \       0x40   0xF04F 0x30FF      MOV      R0,#+4294967295
   1033                }
   1034              }
   1035            }
   1036          
   1037            return (stat);
   \       0x44   0xBD16             POP      {R1,R2,R4,PC}
   1038          }
   1039          

   \                                 In section .text, align 2, keep-with-next
   1040          uint32_t osTimerIsRunning (osTimerId_t timer_id) {
   1041            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1042            uint32_t running;
   1043          
   1044            if (IS_IRQ() || (hTimer == NULL)) {
   \                     osTimerIsRunning: (+1)
   \        0x0   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x4   0xB961             CBNZ.N   R1,??osTimerIsRunning_0
   \        0x6   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD003             BEQ.N    ??osTimerIsRunning_1
   \       0x16   0x....             LDR.N    R2,??DataTable22_1
   \       0x18   0x6811             LDR      R1,[R2, #+0]
   \       0x1A   0x2902             CMP      R1,#+2
   \       0x1C   0xD000             BEQ.N    ??osTimerIsRunning_0
   \                     ??osTimerIsRunning_1: (+1)
   \       0x1E   0xB908             CBNZ.N   R0,??osTimerIsRunning_2
   1045              running = 0U;
   \                     ??osTimerIsRunning_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR
   1046            } else {
   1047              running = (uint32_t)xTimerIsTimerActive (hTimer);
   \                     ??osTimerIsRunning_2: (+1)
   \       0x24   0x.... 0x....      B.W      xTimerIsTimerActive
   1048            }
   1049          
   1050            return (running);
   1051          }
   1052          

   \                                 In section .text, align 2, keep-with-next
   1053          osStatus_t osTimerDelete (osTimerId_t timer_id) {
   \                     osTimerDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1054            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1055            osStatus_t stat;
   1056          #ifndef USE_FreeRTOS_HEAP_1
   1057            TimerCallback_t *callb;
   1058          
   1059            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_58: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osTimerDelete_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_36: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osTimerDelete_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x1A   0xD102             BNE.N    ??osTimerDelete_1
   1060              stat = osErrorISR;
   \                     ??osTimerDelete_0: (+1)
   \       0x1C   0xF06F 0x0005      MVN      R0,#+5
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
   1061            }
   1062            else if (hTimer == NULL) {
   \                     ??osTimerDelete_1: (+1)
   \       0x22   0xB914             CBNZ.N   R4,??osTimerDelete_2
   1063              stat = osErrorParameter;
   \       0x24   0xF06F 0x0003      MVN      R0,#+3
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
   1064            }
   1065            else {
   1066              callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
   \                     ??osTimerDelete_2: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       pvTimerGetTimerID
   \       0x30   0x4605             MOV      R5,R0
   1067          
   1068              if (xTimerDelete (hTimer, 0) == pdPASS) {
   \       0x32   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_97: (+1)
   \       0x36   0x2105             MOVS     R1,#+5
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       xTimerGenericCommand
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD104             BNE.N    ??osTimerDelete_3
   1069                vPortFree (callb);
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x.... 0x....      BL       vPortFree
   1070                stat = osOK;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xBD32             POP      {R1,R4,R5,PC}
   1071              } else {
   1072                stat = osErrorResource;
   \                     ??osTimerDelete_3: (+1)
   \       0x4C   0xF06F 0x0002      MVN      R0,#+2
   1073              }
   1074            }
   1075          #else
   1076            stat = osError;
   1077          #endif
   1078          
   1079            return (stat);
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
   1080          }
   1081          #endif /* (configUSE_OS2_TIMER == 1) */
   1082          
   1083          /*---------------------------------------------------------------------------*/
   1084          

   \                                 In section .text, align 2, keep-with-next
   1085          osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
   \                     osEventFlagsNew: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1086            EventGroupHandle_t hEventGroup;
   1087            int32_t mem;
   1088          
   1089            hEventGroup = NULL;
   \        0x2   0x2000             MOVS     R0,#+0
   1090          
   1091            if (!IS_IRQ()) {
   \        0x4   0xF3EF 0x8205      MRS      R2,IPSR
   \        0x8   0xB9A2             CBNZ.N   R2,??osEventFlagsNew_0
   \        0xA   0xF3EF 0x8210      MRS      R2,PRIMASK
   \        0xE   0x2A00             CMP      R2,#+0
   \       0x10   0xBF04             ITT      EQ
   \       0x12   0xF3EF 0x8211      MRSEQ    R2,BASEPRI
   \       0x16   0x2A00             CMPEQ    R2,#+0
   \       0x18   0xD003             BEQ.N    ??osEventFlagsNew_1
   \       0x1A   0x....             LDR.N    R3,??DataTable22_1
   \       0x1C   0x681A             LDR      R2,[R3, #+0]
   \       0x1E   0x2A02             CMP      R2,#+2
   \       0x20   0xD008             BEQ.N    ??osEventFlagsNew_0
   1092              mem = -1;
   1093          
   1094              if (attr != NULL) {
   \                     ??osEventFlagsNew_1: (+1)
   \       0x22   0xB151             CBZ.N    R1,??osEventFlagsNew_2
   1095                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticEventGroup_t))) {
   \       0x24   0x68CA             LDR      R2,[R1, #+12]
   \       0x26   0x6889             LDR      R1,[R1, #+8]
   \       0x28   0xB129             CBZ.N    R1,??osEventFlagsNew_3
   \       0x2A   0x2A20             CMP      R2,#+32
   \       0x2C   0xBF24             ITT      CS
   1096                  mem = 1;
   1097                }
   1098                else {
   1099                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   1100                    mem = 0;
   1101                  }
   1102                }
   1103              }
   1104              else {
   1105                mem = 0;
   1106              }
   1107          
   1108              if (mem == 1) {
   1109                #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1110                hEventGroup = xEventGroupCreateStatic (attr->cb_mem);
   \       0x2E   0x4608             MOVCS    R0,R1
   \       0x30   0x.... 0x....      BCS.W    xEventGroupCreateStatic
   1111                #endif
   1112              }
   1113              else {
   1114                if (mem == 0) {
   1115                  #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1116                    hEventGroup = xEventGroupCreate();
   1117                  #endif
   1118                }
   1119              }
   1120            }
   1121          
   1122            return ((osEventFlagsId_t)hEventGroup);
   \                     ??osEventFlagsNew_0: (+1)
   \       0x34   0x4770             BX       LR
   \                     ??osEventFlagsNew_3: (+1)
   \       0x36   0x2A00             CMP      R2,#+0
   \       0x38   0xD1FC             BNE.N    ??osEventFlagsNew_0
   \                     ??osEventFlagsNew_2: (+1)
   \       0x3A   0x.... 0x....      B.W      xEventGroupCreate
   1123          }
   1124          

   \                                 In section .text, align 2, keep-with-next
   1125          uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     osEventFlagsSet: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   1126            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1127            uint32_t rflags;
   1128            BaseType_t yield;
   1129          
   1130            if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
   \        0x4   0xB110             CBZ.N    R0,??osEventFlagsSet_0
   \        0x6   0xF014 0x4F7F      TST      R4,#0xFF000000
   \        0xA   0xD002             BEQ.N    ??osEventFlagsSet_1
   1131              rflags = (uint32_t)osErrorParameter;
   \                     ??osEventFlagsSet_0: (+1)
   \        0xC   0xF06F 0x0403      MVN      R4,#+3
   \       0x10   0xE01F             B.N      ??osEventFlagsSet_2
   1132            }
   1133            else if (IS_IRQ()) {
   \                     ??osEventFlagsSet_1: (+1)
   \       0x12   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x16   0xB949             CBNZ.N   R1,??osEventFlagsSet_3
   \       0x18   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0x1C   0xBF04             ITT      EQ
   \       0x1E   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x22   0x2900             CMPEQ    R1,#+0
   \       0x24   0xD011             BEQ.N    ??osEventFlagsSet_4
   \       0x26   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x2A   0xD10E             BNE.N    ??osEventFlagsSet_4
   1134            #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
   1135              (void)yield;
   1136              /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
   1137              rflags = (uint32_t)osErrorResource;
   1138            #else
   1139              yield = pdFALSE;
   \                     ??osEventFlagsSet_3: (+1)
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x9300             STR      R3,[SP, #+0]
   1140          
   1141              if (xEventGroupSetBitsFromISR (hEventGroup, (EventBits_t)flags, &yield) == pdFAIL) {
   \       0x30   0x466A             MOV      R2,SP
   \       0x32   0x4621             MOV      R1,R4
   \       0x34   0x.... 0x....      BL       xEventGroupSetBitsFromISR
   \       0x38   0xB910             CBNZ.N   R0,??osEventFlagsSet_5
   1142                rflags = (uint32_t)osErrorResource;
   \       0x3A   0xF06F 0x0402      MVN      R4,#+2
   \       0x3E   0xE008             B.N      ??osEventFlagsSet_2
   1143              } else {
   1144                rflags = flags;
   1145                portYIELD_FROM_ISR (yield);
   \                     ??osEventFlagsSet_5: (+1)
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0xB130             CBZ.N    R0,??osEventFlagsSet_2
   \       0x44   0x.... 0x....      BL       ?Subroutine17
   1146              }
   1147            #endif
   1148            }
   \                     ??CrossCallReturnLabel_98: (+1)
   \       0x48   0xE003             B.N      ??osEventFlagsSet_2
   1149            else {
   1150              rflags = xEventGroupSetBits (hEventGroup, (EventBits_t)flags);
   \                     ??osEventFlagsSet_4: (+1)
   \       0x4A   0x4621             MOV      R1,R4
   \       0x4C   0x.... 0x....      BL       xEventGroupSetBits
   \       0x50   0x4604             MOV      R4,R0
   1151            }
   1152          
   1153            return (rflags);
   \                     ??osEventFlagsSet_2: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0xBD16             POP      {R1,R2,R4,PC}
   1154          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0xF04F 0x5180      MOV      R1,#+268435456
   \        0x4   0x....             LDR.N    R0,??DataTable30
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR
   1155          

   \                                 In section .text, align 2, keep-with-next
   1156          uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     osEventFlagsClear: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1157            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1158            uint32_t rflags;
   1159          
   1160            if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
   \        0x6   0xD002             BEQ.N    ??osEventFlagsClear_0
   \        0x8   0xF015 0x4F7F      TST      R5,#0xFF000000
   \        0xC   0xD002             BEQ.N    ??osEventFlagsClear_1
   1161              rflags = (uint32_t)osErrorParameter;
   \                     ??osEventFlagsClear_0: (+1)
   \        0xE   0xF06F 0x0603      MVN      R6,#+3
   \       0x12   0xE01D             B.N      ??osEventFlagsClear_2
   1162            }
   1163            else if (IS_IRQ()) {
   \                     ??osEventFlagsClear_1: (+1)
   \       0x14   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x18   0xB948             CBNZ.N   R0,??osEventFlagsClear_3
   \       0x1A   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x1E   0xBF04             ITT      EQ
   \       0x20   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x24   0x2800             CMPEQ    R0,#+0
   \       0x26   0xD00E             BEQ.N    ??osEventFlagsClear_4
   \       0x28   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x2C   0xD10B             BNE.N    ??osEventFlagsClear_4
   1164            #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
   1165              /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
   1166              rflags = (uint32_t)osErrorResource;
   1167            #else
   1168              rflags = xEventGroupGetBitsFromISR (hEventGroup);
   \                     ??osEventFlagsClear_3: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       xEventGroupGetBitsFromISR
   \       0x34   0x4606             MOV      R6,R0
   1169          
   1170              if (xEventGroupClearBitsFromISR (hEventGroup, (EventBits_t)flags) == pdFAIL) {
   \       0x36   0x4629             MOV      R1,R5
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       xEventGroupClearBitsFromISR
   \       0x3E   0xB938             CBNZ.N   R0,??osEventFlagsClear_2
   1171                rflags = (uint32_t)osErrorResource;
   \       0x40   0xF06F 0x0602      MVN      R6,#+2
   \       0x44   0xE004             B.N      ??osEventFlagsClear_2
   1172              }
   1173            #endif
   1174            }
   1175            else {
   1176              rflags = xEventGroupClearBits (hEventGroup, (EventBits_t)flags);
   \                     ??osEventFlagsClear_4: (+1)
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x.... 0x....      BL       xEventGroupClearBits
   \       0x4E   0x4606             MOV      R6,R0
   1177            }
   1178          
   1179            return (rflags);
   \                     ??osEventFlagsClear_2: (+1)
   \       0x50   0x4630             MOV      R0,R6
   \       0x52   0xBD70             POP      {R4-R6,PC}
   1180          }
   1181          

   \                                 In section .text, align 2, keep-with-next
   1182          uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
   1183            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1184            uint32_t rflags;
   1185          
   1186            if (ef_id == NULL) {
   \                     osEventFlagsGet: (+1)
   \        0x0   0xB198             CBZ.N    R0,??osEventFlagsGet_0
   1187              rflags = 0U;
   1188            }
   1189            else if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB959             CBNZ.N   R1,??osEventFlagsGet_1
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD005             BEQ.N    ??osEventFlagsGet_2
   \       0x18   0x....             LDR.N    R2,??DataTable22_1
   \       0x1A   0x6811             LDR      R1,[R2, #+0]
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD101             BNE.N    ??osEventFlagsGet_2
   1190              rflags = xEventGroupGetBitsFromISR (hEventGroup);
   \                     ??osEventFlagsGet_1: (+1)
   \       0x20   0x.... 0x....      B.W      xEventGroupGetBitsFromISR
   1191            }
   1192            else {
   1193              rflags = xEventGroupGetBits (hEventGroup);
   \                     ??osEventFlagsGet_2: (+1)
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x.... 0x....      B.W      xEventGroupClearBits
   1194            }
   1195          
   1196            return (rflags);
   \                     ??osEventFlagsGet_0: (+1)
   \       0x2A   0x4770             BX       LR
   1197          }
   1198          

   \                                 In section .text, align 2, keep-with-next
   1199          uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     osEventFlagsWait: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x461C             MOV      R4,R3
   1200            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1201            BaseType_t wait_all;
   1202            BaseType_t exit_clr;
   1203            uint32_t rflags;
   1204          
   1205            if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
   \        0x8   0xB110             CBZ.N    R0,??osEventFlagsWait_0
   \        0xA   0xF015 0x4F7F      TST      R5,#0xFF000000
   \        0xE   0xD002             BEQ.N    ??osEventFlagsWait_1
   1206              rflags = (uint32_t)osErrorParameter;
   \                     ??osEventFlagsWait_0: (+1)
   \       0x10   0xF06F 0x0003      MVN      R0,#+3
   \       0x14   0xBD76             POP      {R1,R2,R4-R6,PC}
   1207            }
   1208            else if (IS_IRQ()) {
   \                     ??osEventFlagsWait_1: (+1)
   \       0x16   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x1A   0xB949             CBNZ.N   R1,??osEventFlagsWait_2
   \       0x1C   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0x20   0xBF04             ITT      EQ
   \       0x22   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x26   0x2900             CMPEQ    R1,#+0
   \       0x28   0xD005             BEQ.N    ??osEventFlagsWait_3
   \       0x2A   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x2E   0xD102             BNE.N    ??osEventFlagsWait_3
   1209              rflags = (uint32_t)osErrorISR;
   \                     ??osEventFlagsWait_2: (+1)
   \       0x30   0xF06F 0x0005      MVN      R0,#+5
   \       0x34   0xBD76             POP      {R1,R2,R4-R6,PC}
   1210            }
   1211            else {
   1212              if (options & osFlagsWaitAll) {
   1213                wait_all = pdTRUE;
   1214              } else {
   1215                wait_all = pdFAIL;
   1216              }
   1217          
   1218              if (options & osFlagsNoClear) {
   1219                exit_clr = pdFAIL;
   1220              } else {
   1221                exit_clr = pdTRUE;
   1222              }
   1223          
   1224              rflags = xEventGroupWaitBits (hEventGroup, (EventBits_t)flags, exit_clr, wait_all, (TickType_t)timeout);
   \                     ??osEventFlagsWait_3: (+1)
   \       0x36   0x0872             LSRS     R2,R6,#+1
   \       0x38   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x3C   0x9400             STR      R4,[SP, #+0]
   \       0x3E   0xF006 0x0301      AND      R3,R6,#0x1
   \       0x42   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0x.... 0x....      BL       xEventGroupWaitBits
   1225          
   1226              if (options & osFlagsWaitAll) {
   \       0x4C   0xEA00 0x0105      AND      R1,R0,R5
   \       0x50   0xF06F 0x0202      MVN      R2,#+2
   \       0x54   0xF06F 0x0301      MVN      R3,#+1
   \       0x58   0x07F6             LSLS     R6,R6,#+31
   \       0x5A   0xD502             BPL.N    ??osEventFlagsWait_4
   1227                if ((flags & rflags) != flags) {
   \       0x5C   0x42A9             CMP      R1,R5
   \       0x5E   0xD005             BEQ.N    ??osEventFlagsWait_5
   1228                  if (timeout > 0U) {
   \       0x60   0xE000             B.N      ??osEventFlagsWait_6
   1229                    rflags = (uint32_t)osErrorTimeout;
   1230                  } else {
   1231                    rflags = (uint32_t)osErrorResource;
   1232                  }
   1233                }
   1234              }
   1235              else {
   1236                if ((flags & rflags) == 0U) {
   \                     ??osEventFlagsWait_4: (+1)
   \       0x62   0xB919             CBNZ.N   R1,??osEventFlagsWait_5
   1237                  if (timeout > 0U) {
   \                     ??osEventFlagsWait_6: (+1)
   \       0x64   0xB10C             CBZ.N    R4,??osEventFlagsWait_7
   1238                    rflags = (uint32_t)osErrorTimeout;
   \       0x66   0x4618             MOV      R0,R3
   \       0x68   0xBD76             POP      {R1,R2,R4-R6,PC}
   1239                  } else {
   1240                    rflags = (uint32_t)osErrorResource;
   \                     ??osEventFlagsWait_7: (+1)
   \       0x6A   0x4610             MOV      R0,R2
   1241                  }
   1242                }
   1243              }
   1244            }
   1245          
   1246            return (rflags);
   \                     ??osEventFlagsWait_5: (+1)
   \       0x6C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1247          }
   1248          

   \                                 In section .text, align 2, keep-with-next
   1249          osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
   \                     osEventFlagsDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1250            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1251            osStatus_t stat;
   1252          
   1253          #ifndef USE_FreeRTOS_HEAP_1
   1254            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB961             CBNZ.N   R1,??osEventFlagsDelete_0
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD007             BEQ.N    ??osEventFlagsDelete_1
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable39
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x2902             CMP      R1,#+2
   \       0x20   0xD102             BNE.N    ??osEventFlagsDelete_1
   1255              stat = osErrorISR;
   \                     ??osEventFlagsDelete_0: (+1)
   \       0x22   0xF06F 0x0405      MVN      R4,#+5
   \       0x26   0xE006             B.N      ??osEventFlagsDelete_2
   1256            }
   1257            else if (hEventGroup == NULL) {
   \                     ??osEventFlagsDelete_1: (+1)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xBF0E             ITEE     EQ
   1258              stat = osErrorParameter;
   \       0x2C   0xF06F 0x0403      MVNEQ    R4,#+3
   1259            }
   1260            else {
   1261              stat = osOK;
   \       0x30   0x2400             MOVNE    R4,#+0
   1262              vEventGroupDelete (hEventGroup);
   \       0x32   0x.... 0x....      BLNE     vEventGroupDelete
   1263            }
   1264          #else
   1265            stat = osError;
   1266          #endif
   1267          
   1268            return (stat);
   \                     ??osEventFlagsDelete_2: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD10             POP      {R4,PC}
   1269          }
   1270          
   1271          /*---------------------------------------------------------------------------*/
   1272          #if (configUSE_OS2_MUTEX == 1)
   1273          

   \                                 In section .text, align 2, keep-with-next
   1274          osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
   \                     osMutexNew: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1275            SemaphoreHandle_t hMutex;
   1276            uint32_t type;
   1277            uint32_t rmtx;
   1278            int32_t  mem;
   1279            #if (configQUEUE_REGISTRY_SIZE > 0)
   1280            const char *name;
   1281            #endif
   1282          
   1283            hMutex = NULL;
   \        0x4   0x2600             MOVS     R6,#+0
   1284          
   1285            if (!IS_IRQ()) {
   \        0x6   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD131             BNE.N    ??osMutexNew_0
   \        0xE   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x12   0xBF04             ITT      EQ
   \       0x14   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x18   0x2800             CMPEQ    R0,#+0
   \       0x1A   0xD002             BEQ.N    ??osMutexNew_1
   \       0x1C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x20   0xD027             BEQ.N    ??osMutexNew_0
   1286              if (attr != NULL) {
   \                     ??osMutexNew_1: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xBF14             ITE      NE
   \       0x26   0x6860             LDRNE    R0,[R4, #+4]
   \       0x28   0x2000             MOVEQ    R0,#+0
   1287                type = attr->attr_bits;
   1288              } else {
   1289                type = 0U;
   1290              }
   1291          
   1292              if ((type & osMutexRecursive) == osMutexRecursive) {
   1293                rmtx = 1U;
   1294              } else {
   1295                rmtx = 0U;
   \       0x2A   0xF000 0x0501      AND      R5,R0,#0x1
   1296              }
   1297          
   1298              if ((type & osMutexRobust) != osMutexRobust) {
   \       0x2E   0x0700             LSLS     R0,R0,#+28
   \       0x30   0xD41F             BMI.N    ??osMutexNew_0
   1299                mem = -1;
   1300          
   1301                if (attr != NULL) {
   \       0x32   0xB154             CBZ.N    R4,??osMutexNew_2
   1302                  if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
   \       0x34   0x68A1             LDR      R1,[R4, #+8]
   \       0x36   0x68E0             LDR      R0,[R4, #+12]
   \       0x38   0xB131             CBZ.N    R1,??osMutexNew_3
   \       0x3A   0x2850             CMP      R0,#+80
   \       0x3C   0xD319             BCC.N    ??osMutexNew_0
   1303                    mem = 1;
   1304                  }
   1305                  else {
   1306                    if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   1307                      mem = 0;
   1308                    }
   1309                  }
   1310                }
   1311                else {
   1312                  mem = 0;
   1313                }
   1314          
   1315                if (mem == 1) {
   1316                  #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1317                    if (rmtx != 0U) {
   \       0x3E   0xB18D             CBZ.N    R5,??osMutexNew_4
   1318                      #if (configUSE_RECURSIVE_MUTEXES == 1)
   1319                      hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
   \       0x40   0x2004             MOVS     R0,#+4
   \                     ??osMutexNew_5: (+1)
   \       0x42   0x.... 0x....      BL       xQueueCreateMutexStatic
   \       0x46   0xE006             B.N      ??osMutexNew_6
   1320                      #endif
   1321                    }
   \                     ??osMutexNew_3: (+1)
   \       0x48   0xB998             CBNZ.N   R0,??osMutexNew_0
   1322                    else {
   1323                      hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
   1324                    }
   1325                  #endif
   1326                }
   1327                else {
   1328                  if (mem == 0) {
   1329                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1330                      if (rmtx != 0U) {
   \                     ??osMutexNew_2: (+1)
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xBF14             ITE      NE
   \       0x4E   0x2004             MOVNE    R0,#+4
   \       0x50   0x2001             MOVEQ    R0,#+1
   1331                        #if (configUSE_RECURSIVE_MUTEXES == 1)
   1332                        hMutex = xSemaphoreCreateRecursiveMutex ();
   1333                        #endif
   1334                      } else {
   1335                        hMutex = xSemaphoreCreateMutex ();
   \       0x52   0x.... 0x....      BL       xQueueCreateMutex
   \                     ??osMutexNew_6: (+1)
   \       0x56   0x0006             MOVS     R6,R0
   1336                      }
   1337                    #endif
   1338                  }
   1339                }
   1340          
   1341                #if (configQUEUE_REGISTRY_SIZE > 0)
   1342                if (hMutex != NULL) {
   \       0x58   0xD00B             BEQ.N    ??osMutexNew_0
   1343                  if (attr != NULL) {
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xBF14             ITE      NE
   \       0x5E   0x6821             LDRNE    R1,[R4, #+0]
   \       0x60   0x2100             MOVEQ    R1,#+0
   1344                    name = attr->name;
   1345                  } else {
   1346                    name = NULL;
   \       0x62   0xE001             B.N      ??osMutexNew_7
   1347                  }
   \                     ??osMutexNew_4: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xE7EC             B.N      ??osMutexNew_5
   1348                  vQueueAddToRegistry (hMutex, name);
   \                     ??osMutexNew_7: (+1)
   \       0x68   0x.... 0x....      BL       vQueueAddToRegistry
   \       0x6C   0xB10D             CBZ.N    R5,??osMutexNew_0
   1349                }
   1350                #endif
   1351          
   1352                if ((hMutex != NULL) && (rmtx != 0U)) {
   1353                  hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
   \       0x6E   0xF046 0x0601      ORR      R6,R6,#0x1
   1354                }
   1355              }
   1356            }
   1357          
   1358            return ((osMutexId_t)hMutex);
   \                     ??osMutexNew_0: (+1)
   \       0x72   0x4630             MOV      R0,R6
   \       0x74   0xBD70             POP      {R4-R6,PC}
   1359          }
   1360          

   \                                 In section .text, align 2, keep-with-next
   1361          osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
   \                     osMutexAcquire: (+1)
   \        0x0   0x4602             MOV      R2,R0
   \        0x2   0xB5F8             PUSH     {R3-R7,LR}
   1362            SemaphoreHandle_t hMutex;
   1363            osStatus_t stat;
   1364            uint32_t rmtx;
   1365          
   1366            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x4   0x0850             LSRS     R0,R2,#+1
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x0040             LSLS     R0,R0,#+1
   1367          
   1368            rmtx = (uint32_t)mutex_id & 1U;
   1369          
   1370            stat = osOK;
   \        0xA   0x2500             MOVS     R5,#+0
   1371          
   1372            if (IS_IRQ()) {
   \        0xC   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x10   0xB959             CBNZ.N   R1,??osMutexAcquire_0
   \       0x12   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0x16   0xBF04             ITT      EQ
   \       0x18   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x1C   0x2900             CMPEQ    R1,#+0
   \       0x1E   0xD007             BEQ.N    ??osMutexAcquire_1
   \       0x20   0x.... 0x....      LDR.W    R3,??DataTable39
   \       0x24   0x6819             LDR      R1,[R3, #+0]
   \       0x26   0x2902             CMP      R1,#+2
   \       0x28   0xD102             BNE.N    ??osMutexAcquire_1
   1373              stat = osErrorISR;
   \                     ??osMutexAcquire_0: (+1)
   \       0x2A   0xF06F 0x0505      MVN      R5,#+5
   \       0x2E   0xE015             B.N      ??osMutexAcquire_2
   1374            }
   1375            else if (hMutex == NULL) {
   \                     ??osMutexAcquire_1: (+1)
   \       0x30   0xB910             CBNZ.N   R0,??osMutexAcquire_3
   1376              stat = osErrorParameter;
   \       0x32   0xF06F 0x0503      MVN      R5,#+3
   \       0x36   0xE011             B.N      ??osMutexAcquire_2
   1377            }
   1378            else {
   1379              if (rmtx != 0U) {
   \                     ??osMutexAcquire_3: (+1)
   \       0x38   0x07D1             LSLS     R1,R2,#+31
   \       0x3A   0xF06F 0x0602      MVN      R6,#+2
   \       0x3E   0xF06F 0x0701      MVN      R7,#+1
   \       0x42   0x4621             MOV      R1,R4
   \       0x44   0xD502             BPL.N    ??osMutexAcquire_4
   1380                #if (configUSE_RECURSIVE_MUTEXES == 1)
   1381                if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
   \       0x46   0x.... 0x....      BL       xQueueTakeMutexRecursive
   \       0x4A   0xE001             B.N      ??osMutexAcquire_5
   1382                  if (timeout != 0U) {
   1383                    stat = osErrorTimeout;
   1384                  } else {
   1385                    stat = osErrorResource;
   1386                  }
   1387                }
   1388                #endif
   1389              }
   1390              else {
   1391                if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
   \                     ??osMutexAcquire_4: (+1)
   \       0x4C   0x.... 0x....      BL       xQueueSemaphoreTake
   \                     ??osMutexAcquire_5: (+1)
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD003             BEQ.N    ??osMutexAcquire_2
   1392                  if (timeout != 0U) {
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xBF14             ITE      NE
   \       0x58   0x463D             MOVNE    R5,R7
   \       0x5A   0x4635             MOVEQ    R5,R6
   1393                    stat = osErrorTimeout;
   1394                  } else {
   1395                    stat = osErrorResource;
   1396                  }
   1397                }
   1398              }
   1399            }
   1400          
   1401            return (stat);
   \                     ??osMutexAcquire_2: (+1)
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}
   1402          }
   1403          

   \                                 In section .text, align 2, keep-with-next
   1404          osStatus_t osMutexRelease (osMutexId_t mutex_id) {
   \                     osMutexRelease: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xB538             PUSH     {R3-R5,LR}
   1405            SemaphoreHandle_t hMutex;
   1406            osStatus_t stat;
   1407            uint32_t rmtx;
   1408          
   1409            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x4   0x0848             LSRS     R0,R1,#+1
   \        0x6   0x0040             LSLS     R0,R0,#+1
   1410          
   1411            rmtx = (uint32_t)mutex_id & 1U;
   1412          
   1413            stat = osOK;
   \        0x8   0x2400             MOVS     R4,#+0
   1414          
   1415            if (IS_IRQ()) {
   \        0xA   0xF3EF 0x8205      MRS      R2,IPSR
   \        0xE   0xB94A             CBNZ.N   R2,??osMutexRelease_0
   \       0x10   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x14   0xBF04             ITT      EQ
   \       0x16   0xF3EF 0x8211      MRSEQ    R2,BASEPRI
   \       0x1A   0x2A00             CMPEQ    R2,#+0
   \       0x1C   0xD005             BEQ.N    ??osMutexRelease_1
   \       0x1E   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x22   0xD102             BNE.N    ??osMutexRelease_1
   1416              stat = osErrorISR;
   \                     ??osMutexRelease_0: (+1)
   \       0x24   0xF06F 0x0405      MVN      R4,#+5
   \       0x28   0xE00F             B.N      ??osMutexRelease_2
   1417            }
   1418            else if (hMutex == NULL) {
   \                     ??osMutexRelease_1: (+1)
   \       0x2A   0xB910             CBNZ.N   R0,??osMutexRelease_3
   1419              stat = osErrorParameter;
   \       0x2C   0xF06F 0x0403      MVN      R4,#+3
   \       0x30   0xE00B             B.N      ??osMutexRelease_2
   1420            }
   1421            else {
   1422              if (rmtx != 0U) {
   \                     ??osMutexRelease_3: (+1)
   \       0x32   0xF06F 0x0502      MVN      R5,#+2
   \       0x36   0x07C9             LSLS     R1,R1,#+31
   \       0x38   0xD502             BPL.N    ??osMutexRelease_4
   1423                #if (configUSE_RECURSIVE_MUTEXES == 1)
   1424                if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
   \       0x3A   0x.... 0x....      BL       xQueueGiveMutexRecursive
   \       0x3E   0xE001             B.N      ??CrossCallReturnLabel_50
   1425                  stat = osErrorResource;
   1426                }
   1427                #endif
   1428              }
   1429              else {
   1430                if (xSemaphoreGive (hMutex) != pdPASS) {
   \                     ??osMutexRelease_4: (+1)
   \       0x40   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xBF18             IT       NE
   \       0x48   0x462C             MOVNE    R4,R5
   1431                  stat = osErrorResource;
   1432                }
   1433              }
   1434            }
   1435          
   1436            return (stat);
   \                     ??osMutexRelease_2: (+1)
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
   1437          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x6860             LDR      R0,[R4, #+4]
   \                     ??Subroutine8_0: (+1)
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x.... 0x....      B.W      xQueueGenericSend
   1438          

   \                                 In section .text, align 2, keep-with-next
   1439          osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
   1440            SemaphoreHandle_t hMutex;
   1441            osThreadId_t owner;
   1442          
   1443            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \                     osMutexGetOwner: (+1)
   \        0x0   0x0840             LSRS     R0,R0,#+1
   \        0x2   0x0040             LSLS     R0,R0,#+1
   1444          
   1445            if (IS_IRQ() || (hMutex == NULL)) {
   \        0x4   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x8   0xB969             CBNZ.N   R1,??osMutexGetOwner_0
   \        0xA   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xBF04             ITT      EQ
   \       0x12   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x16   0x2900             CMPEQ    R1,#+0
   \       0x18   0xD004             BEQ.N    ??osMutexGetOwner_1
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable39
   \       0x1E   0x6811             LDR      R1,[R2, #+0]
   \       0x20   0x2902             CMP      R1,#+2
   \       0x22   0xD000             BEQ.N    ??osMutexGetOwner_0
   \                     ??osMutexGetOwner_1: (+1)
   \       0x24   0xB908             CBNZ.N   R0,??osMutexGetOwner_2
   1446              owner = NULL;
   \                     ??osMutexGetOwner_0: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x4770             BX       LR
   1447            } else {
   1448              owner = (osThreadId_t)xSemaphoreGetMutexHolder (hMutex);
   \                     ??osMutexGetOwner_2: (+1)
   \       0x2A   0x.... 0x....      B.W      xQueueGetMutexHolder
   1449            }
   1450          
   1451            return (owner);
   1452          }
   1453          

   \                                 In section .text, align 2, keep-with-next
   1454          osStatus_t osMutexDelete (osMutexId_t mutex_id) {
   \                     osMutexDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1455            osStatus_t stat;
   1456          #ifndef USE_FreeRTOS_HEAP_1
   1457            SemaphoreHandle_t hMutex;
   1458          
   1459            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x2   0x0844             LSRS     R4,R0,#+1
   \        0x4   0x0064             LSLS     R4,R4,#+1
   1460          
   1461            if (IS_IRQ()) {
   \        0x6   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xA   0xB948             CBNZ.N   R0,??osMutexDelete_0
   \        0xC   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x10   0xBF04             ITT      EQ
   \       0x12   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x16   0x2800             CMPEQ    R0,#+0
   \       0x18   0xD005             BEQ.N    ??osMutexDelete_1
   \       0x1A   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x1E   0xD102             BNE.N    ??osMutexDelete_1
   1462              stat = osErrorISR;
   \                     ??osMutexDelete_0: (+1)
   \       0x20   0xF06F 0x0505      MVN      R5,#+5
   \       0x24   0xE008             B.N      ??CrossCallReturnLabel_65
   1463            }
   1464            else if (hMutex == NULL) {
   \                     ??osMutexDelete_1: (+1)
   \       0x26   0xB914             CBNZ.N   R4,??osMutexDelete_2
   1465              stat = osErrorParameter;
   \       0x28   0xF06F 0x0503      MVN      R5,#+3
   \       0x2C   0xE004             B.N      ??CrossCallReturnLabel_65
   1466            }
   1467            else {
   1468              #if (configQUEUE_REGISTRY_SIZE > 0)
   1469              vQueueUnregisterQueue (hMutex);
   \                     ??osMutexDelete_2: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       vQueueUnregisterQueue
   1470              #endif
   1471              stat = osOK;
   1472              vSemaphoreDelete (hMutex);
   \       0x34   0x.... 0x....      BL       ?Subroutine11
   1473            }
   1474          #else
   1475            stat = osError;
   1476          #endif
   1477          
   1478            return (stat);
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   1479          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x.... 0x....      B.W      vQueueDelete
   1480          #endif /* (configUSE_OS2_MUTEX == 1) */
   1481          
   1482          /*---------------------------------------------------------------------------*/
   1483          

   \                                 In section .text, align 2, keep-with-next
   1484          osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
   \                     osSemaphoreNew: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4614             MOV      R4,R2
   1485            SemaphoreHandle_t hSemaphore;
   1486            int32_t mem;
   1487            #if (configQUEUE_REGISTRY_SIZE > 0)
   1488            const char *name;
   1489            #endif
   1490          
   1491            hSemaphore = NULL;
   \        0x6   0x2500             MOVS     R5,#+0
   1492          
   1493            if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
   \        0x8   0xF3EF 0x8105      MRS      R1,IPSR
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD147             BNE.N    ??osSemaphoreNew_0
   \       0x10   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0x14   0xBF04             ITT      EQ
   \       0x16   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x1A   0x2900             CMPEQ    R1,#+0
   \       0x1C   0xD002             BEQ.N    ??osSemaphoreNew_1
   \       0x1E   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x22   0xD03D             BEQ.N    ??osSemaphoreNew_0
   \                     ??osSemaphoreNew_1: (+1)
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD03B             BEQ.N    ??osSemaphoreNew_0
   \       0x28   0x42B0             CMP      R0,R6
   \       0x2A   0xD339             BCC.N    ??osSemaphoreNew_0
   1494              mem = -1;
   1495          
   1496              if (attr != NULL) {
   \       0x2C   0xB144             CBZ.N    R4,??osSemaphoreNew_2
   1497                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
   \       0x2E   0x68A1             LDR      R1,[R4, #+8]
   \       0x30   0x68E2             LDR      R2,[R4, #+12]
   \       0x32   0xB119             CBZ.N    R1,??osSemaphoreNew_3
   \       0x34   0x2A50             CMP      R2,#+80
   \       0x36   0xD333             BCC.N    ??osSemaphoreNew_0
   1498                  mem = 1;
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0xE002             B.N      ??osSemaphoreNew_4
   1499                }
   1500                else {
   1501                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   1502                    mem = 0;
   1503                  }
   1504                }
   1505              }
   \                     ??osSemaphoreNew_3: (+1)
   \       0x3C   0x2A00             CMP      R2,#+0
   \       0x3E   0xD12F             BNE.N    ??osSemaphoreNew_0
   1506              else {
   1507                mem = 0;
   \                     ??osSemaphoreNew_2: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   1508              }
   1509          
   1510              if (mem != -1) {
   1511                if (max_count == 1U) {
   \                     ??osSemaphoreNew_4: (+1)
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD119             BNE.N    ??osSemaphoreNew_5
   1512                  if (mem == 1) {
   \       0x46   0x2901             CMP      R1,#+1
   \       0x48   0xD108             BNE.N    ??osSemaphoreNew_6
   1513                    #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1514                      hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x68A3             LDR      R3,[R4, #+8]
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x.... 0x....      BL       xQueueGenericCreateStatic
   \       0x5A   0xE002             B.N      ??osSemaphoreNew_7
   1515                    #endif
   1516                  }
   1517                  else {
   1518                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1519                      hSemaphore = xSemaphoreCreateBinary();
   \                     ??osSemaphoreNew_6: (+1)
   \       0x5C   0x2203             MOVS     R2,#+3
   \       0x5E   0x.... 0x....      BL       xQueueGenericCreate
   \                     ??osSemaphoreNew_7: (+1)
   \       0x62   0x0005             MOVS     R5,R0
   1520                    #endif
   1521                  }
   1522          
   1523                  if ((hSemaphore != NULL) && (initial_count != 0U)) {
   \       0x64   0xD01C             BEQ.N    ??osSemaphoreNew_0
   \       0x66   0xB1A6             CBZ.N    R6,??osSemaphoreNew_8
   1524                    if (xSemaphoreGive (hSemaphore) != pdPASS) {
   \       0x68   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD010             BEQ.N    ??osSemaphoreNew_8
   1525                      vSemaphoreDelete (hSemaphore);
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x.... 0x....      BL       vQueueDelete
   1526                      hSemaphore = NULL;
   \       0x76   0x2500             MOVS     R5,#+0
   \       0x78   0xE012             B.N      ??osSemaphoreNew_0
   1527                    }
   1528                  }
   1529                }
   1530                else {
   1531                  if (mem == 1) {
   \                     ??osSemaphoreNew_5: (+1)
   \       0x7A   0x2901             CMP      R1,#+1
   \       0x7C   0xD104             BNE.N    ??osSemaphoreNew_9
   1532                    #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1533                      hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
   \       0x7E   0x68A2             LDR      R2,[R4, #+8]
   \       0x80   0x4631             MOV      R1,R6
   \       0x82   0x.... 0x....      BL       xQueueCreateCountingSemaphoreStatic
   \       0x86   0xE002             B.N      ??osSemaphoreNew_10
   1534                    #endif
   1535                  }
   1536                  else {
   1537                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1538                      hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
   \                     ??osSemaphoreNew_9: (+1)
   \       0x88   0x4631             MOV      R1,R6
   \       0x8A   0x.... 0x....      BL       xQueueCreateCountingSemaphore
   \                     ??osSemaphoreNew_10: (+1)
   \       0x8E   0x0005             MOVS     R5,R0
   1539                    #endif
   1540                  }
   1541                }
   1542                
   1543                #if (configQUEUE_REGISTRY_SIZE > 0)
   1544                if (hSemaphore != NULL) {
   \       0x90   0xD006             BEQ.N    ??osSemaphoreNew_0
   1545                  if (attr != NULL) {
   \                     ??osSemaphoreNew_8: (+1)
   \       0x92   0x2C00             CMP      R4,#+0
   \       0x94   0xBF14             ITE      NE
   \       0x96   0x6821             LDRNE    R1,[R4, #+0]
   \       0x98   0x2100             MOVEQ    R1,#+0
   1546                    name = attr->name;
   1547                  } else {
   1548                    name = NULL;
   1549                  }
   1550                  vQueueAddToRegistry (hSemaphore, name);
   \       0x9A   0x4628             MOV      R0,R5
   \       0x9C   0x.... 0x....      BL       vQueueAddToRegistry
   1551                }
   1552                #endif
   1553              }
   1554            }
   1555          
   1556            return ((osSemaphoreId_t)hSemaphore);
   \                     ??osSemaphoreNew_0: (+1)
   \       0xA0   0x4628             MOV      R0,R5
   \       0xA2   0xBD76             POP      {R1,R2,R4-R6,PC}
   1557          }
   1558          

   \                                 In section .text, align 2, keep-with-next
   1559          osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
   \                     osSemaphoreAcquire: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   1560            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1561            osStatus_t stat;
   1562            BaseType_t yield;
   1563          
   1564            stat = osOK;
   \        0x4   0x2500             MOVS     R5,#+0
   1565          
   1566            if (hSemaphore == NULL) {
   \        0x6   0xB178             CBZ.N    R0,??osSemaphoreAcquire_0
   1567              stat = osErrorParameter;
   1568            }
   1569            else if (IS_IRQ()) {
   \        0x8   0xF06F 0x0602      MVN      R6,#+2
   \        0xC   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x10   0xB949             CBNZ.N   R1,??osSemaphoreAcquire_1
   \       0x12   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0x16   0xBF04             ITT      EQ
   \       0x18   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x1C   0x2900             CMPEQ    R1,#+0
   \       0x1E   0xD012             BEQ.N    ??osSemaphoreAcquire_2
   \       0x20   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x24   0xD10F             BNE.N    ??osSemaphoreAcquire_2
   1570              if (timeout != 0U) {
   \                     ??osSemaphoreAcquire_1: (+1)
   \       0x26   0xB114             CBZ.N    R4,??osSemaphoreAcquire_3
   1571                stat = osErrorParameter;
   \                     ??osSemaphoreAcquire_0: (+1)
   \       0x28   0xF06F 0x0503      MVN      R5,#+3
   \       0x2C   0xE015             B.N      ??osSemaphoreAcquire_4
   1572              }
   1573              else {
   1574                yield = pdFALSE;
   \                     ??osSemaphoreAcquire_3: (+1)
   \       0x2E   0x9500             STR      R5,[SP, #+0]
   1575          
   1576                if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
   \       0x30   0x466A             MOV      R2,SP
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x.... 0x....      BL       xQueueReceiveFromISR
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD10D             BNE.N    ??osSemaphoreAcquire_5
   1577                  stat = osErrorResource;
   1578                } else {
   1579                  portYIELD_FROM_ISR (yield);
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0xB160             CBZ.N    R0,??osSemaphoreAcquire_4
   \       0x40   0x.... 0x....      BL       ?Subroutine17
   1580                }
   1581              }
   1582            }
   \                     ??CrossCallReturnLabel_99: (+1)
   \       0x44   0xE009             B.N      ??osSemaphoreAcquire_4
   1583            else {
   1584              if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
   \                     ??osSemaphoreAcquire_2: (+1)
   \       0x46   0x4621             MOV      R1,R4
   \       0x48   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD004             BEQ.N    ??osSemaphoreAcquire_4
   1585                if (timeout != 0U) {
   \       0x50   0xB114             CBZ.N    R4,??osSemaphoreAcquire_5
   1586                  stat = osErrorTimeout;
   \       0x52   0xF06F 0x0501      MVN      R5,#+1
   \       0x56   0xE000             B.N      ??osSemaphoreAcquire_4
   1587                } else {
   1588                  stat = osErrorResource;
   \                     ??osSemaphoreAcquire_5: (+1)
   \       0x58   0x4635             MOV      R5,R6
   1589                }
   1590              }
   1591            }
   1592          
   1593            return (stat);
   \                     ??osSemaphoreAcquire_4: (+1)
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1594          }
   1595          

   \                                 In section .text, align 2, keep-with-next
   1596          osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
   \                     osSemaphoreRelease: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1597            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1598            osStatus_t stat;
   1599            BaseType_t yield;
   1600          
   1601            stat = osOK;
   \        0x2   0x2400             MOVS     R4,#+0
   1602          
   1603            if (hSemaphore == NULL) {
   \        0x4   0xB910             CBNZ.N   R0,??osSemaphoreRelease_0
   1604              stat = osErrorParameter;
   \        0x6   0xF06F 0x0403      MVN      R4,#+3
   \        0xA   0xE01E             B.N      ??osSemaphoreRelease_1
   1605            }
   1606            else if (IS_IRQ()) {
   \                     ??osSemaphoreRelease_0: (+1)
   \        0xC   0xF06F 0x0502      MVN      R5,#+2
   \       0x10   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x14   0xB949             CBNZ.N   R1,??osSemaphoreRelease_2
   \       0x16   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x1A   0xBF04             ITT      EQ
   \       0x1C   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x20   0x2900             CMPEQ    R1,#+0
   \       0x22   0xD00D             BEQ.N    ??osSemaphoreRelease_3
   \       0x24   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x28   0xD10A             BNE.N    ??osSemaphoreRelease_3
   1607              yield = pdFALSE;
   \                     ??osSemaphoreRelease_2: (+1)
   \       0x2A   0x9400             STR      R4,[SP, #+0]
   1608          
   1609              if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
   \       0x2C   0x4669             MOV      R1,SP
   \       0x2E   0x.... 0x....      BL       xQueueGiveFromISR
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD108             BNE.N    ??osSemaphoreRelease_4
   1610                stat = osErrorResource;
   1611              } else {
   1612                portYIELD_FROM_ISR (yield);
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0xB138             CBZ.N    R0,??osSemaphoreRelease_1
   \       0x3A   0x.... 0x....      BL       ?Subroutine17
   1613              }
   1614            }
   \                     ??CrossCallReturnLabel_100: (+1)
   \       0x3E   0xE004             B.N      ??osSemaphoreRelease_1
   1615            else {
   1616              if (xSemaphoreGive (hSemaphore) != pdPASS) {
   \                     ??osSemaphoreRelease_3: (+1)
   \       0x40   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD000             BEQ.N    ??osSemaphoreRelease_1
   1617                stat = osErrorResource;
   \                     ??osSemaphoreRelease_4: (+1)
   \       0x48   0x462C             MOV      R4,R5
   1618              }
   1619            }
   1620          
   1621            return (stat);
   \                     ??osSemaphoreRelease_1: (+1)
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
   1622          }
   1623          

   \                                 In section .text, align 2, keep-with-next
   1624          uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
   1625            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1626            uint32_t count;
   1627          
   1628            if (hSemaphore == NULL) {
   \                     osSemaphoreGetCount: (+1)
   \        0x0   0xB198             CBZ.N    R0,??osSemaphoreGetCount_0
   1629              count = 0U;
   1630            }
   1631            else if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB961             CBNZ.N   R1,??osSemaphoreGetCount_1
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD006             BEQ.N    ??osSemaphoreGetCount_2
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable39
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x2902             CMP      R1,#+2
   \       0x20   0xD101             BNE.N    ??osSemaphoreGetCount_2
   1632              count = uxQueueMessagesWaitingFromISR (hSemaphore);
   \                     ??osSemaphoreGetCount_1: (+1)
   \       0x22   0x.... 0x....      B.W      uxQueueMessagesWaitingFromISR
   1633            } else {
   1634              count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
   \                     ??osSemaphoreGetCount_2: (+1)
   \       0x26   0x.... 0x....      B.W      uxQueueMessagesWaiting
   1635            }
   1636          
   1637            return (count);
   \                     ??osSemaphoreGetCount_0: (+1)
   \       0x2A   0x4770             BX       LR
   1638          }
   1639          

   \                                 In section .text, align 2, keep-with-next
   1640          osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
   \                     osSemaphoreDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1641            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1642            osStatus_t stat;
   1643          
   1644          #ifndef USE_FreeRTOS_HEAP_1
   1645            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_59: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osSemaphoreDelete_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_40: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osSemaphoreDelete_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x1A   0xD102             BNE.N    ??osSemaphoreDelete_1
   1646              stat = osErrorISR;
   \                     ??osSemaphoreDelete_0: (+1)
   \       0x1C   0xF06F 0x0505      MVN      R5,#+5
   \       0x20   0xE008             B.N      ??CrossCallReturnLabel_64
   1647            }
   1648            else if (hSemaphore == NULL) {
   \                     ??osSemaphoreDelete_1: (+1)
   \       0x22   0xB914             CBNZ.N   R4,??osSemaphoreDelete_2
   1649              stat = osErrorParameter;
   \       0x24   0xF06F 0x0503      MVN      R5,#+3
   \       0x28   0xE004             B.N      ??CrossCallReturnLabel_64
   1650            }
   1651            else {
   1652              #if (configQUEUE_REGISTRY_SIZE > 0)
   1653              vQueueUnregisterQueue (hSemaphore);
   \                     ??osSemaphoreDelete_2: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       vQueueUnregisterQueue
   1654              #endif
   1655          
   1656              stat = osOK;
   1657              vSemaphoreDelete (hSemaphore);
   \       0x30   0x.... 0x....      BL       ?Subroutine11
   1658            }
   1659          #else
   1660            stat = osError;
   1661          #endif
   1662          
   1663            return (stat);
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
   1664          }
   1665          
   1666          /*---------------------------------------------------------------------------*/
   1667          

   \                                 In section .text, align 2, keep-with-next
   1668          osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
   \                     osMessageQueueNew: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4614             MOV      R4,R2
   1669            QueueHandle_t hQueue;
   1670            int32_t mem;
   1671            #if (configQUEUE_REGISTRY_SIZE > 0)
   1672            const char *name;
   1673            #endif
   1674          
   1675            hQueue = NULL;
   \        0x4   0x2500             MOVS     R5,#+0
   1676          
   1677            if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
   \        0x6   0xF3EF 0x8205      MRS      R2,IPSR
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD131             BNE.N    ??osMessageQueueNew_0
   \        0xE   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0x12   0xBF04             ITT      EQ
   \       0x14   0xF3EF 0x8211      MRSEQ    R2,BASEPRI
   \       0x18   0x2A00             CMPEQ    R2,#+0
   \       0x1A   0xD002             BEQ.N    ??osMessageQueueNew_1
   \       0x1C   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x20   0xD027             BEQ.N    ??osMessageQueueNew_0
   \                     ??osMessageQueueNew_1: (+1)
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2900             CMPNE    R1,#+0
   \       0x28   0xD023             BEQ.N    ??osMessageQueueNew_0
   1678              mem = -1;
   1679          
   1680              if (attr != NULL) {
   \       0x2A   0xB1E4             CBZ.N    R4,??osMessageQueueNew_2
   1681                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
   1682                    (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
   \       0x2C   0x68A3             LDR      R3,[R4, #+8]
   \       0x2E   0x68E2             LDR      R2,[R4, #+12]
   \       0x30   0xB193             CBZ.N    R3,??osMessageQueueNew_3
   \       0x32   0x2A50             CMP      R2,#+80
   \       0x34   0xD31D             BCC.N    ??osMessageQueueNew_0
   \       0x36   0x6922             LDR      R2,[R4, #+16]
   \       0x38   0xB1DA             CBZ.N    R2,??osMessageQueueNew_0
   \       0x3A   0x6967             LDR      R7,[R4, #+20]
   \       0x3C   0xFB01 0xF600      MUL      R6,R1,R0
   \       0x40   0x42B7             CMP      R7,R6
   \       0x42   0xD316             BCC.N    ??osMessageQueueNew_0
   1683                  mem = 1;
   1684                }
   1685                else {
   1686                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
   1687                      (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
   1688                    mem = 0;
   1689                  }
   1690                }
   1691              }
   1692              else {
   1693                mem = 0;
   1694              }
   1695          
   1696              if (mem == 1) {
   1697                #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1698                  hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
   \       0x44   0x9500             STR      R5,[SP, #+0]
   \       0x46   0x.... 0x....      BL       xQueueGenericCreateStatic
   \                     ??osMessageQueueNew_4: (+1)
   \       0x4A   0x0005             MOVS     R5,R0
   1699                #endif
   1700              }
   1701              else {
   1702                if (mem == 0) {
   1703                  #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1704                    hQueue = xQueueCreate (msg_count, msg_size);
   1705                  #endif
   1706                }
   1707              }
   1708          
   1709              #if (configQUEUE_REGISTRY_SIZE > 0)
   1710              if (hQueue != NULL) {
   \       0x4C   0xD011             BEQ.N    ??osMessageQueueNew_0
   1711                if (attr != NULL) {
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xBF14             ITE      NE
   \       0x52   0x6821             LDRNE    R1,[R4, #+0]
   \       0x54   0x2100             MOVEQ    R1,#+0
   1712                  name = attr->name;
   1713                } else {
   1714                  name = NULL;
   \       0x56   0xE00A             B.N      ??osMessageQueueNew_5
   1715                }
   \                     ??osMessageQueueNew_3: (+1)
   \       0x58   0x2A00             CMP      R2,#+0
   \       0x5A   0xBF04             ITT      EQ
   \       0x5C   0x6922             LDREQ    R2,[R4, #+16]
   \       0x5E   0x2A00             CMPEQ    R2,#+0
   \       0x60   0xD107             BNE.N    ??osMessageQueueNew_0
   \       0x62   0x6962             LDR      R2,[R4, #+20]
   \       0x64   0xB92A             CBNZ.N   R2,??osMessageQueueNew_0
   \                     ??osMessageQueueNew_2: (+1)
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x.... 0x....      BL       xQueueGenericCreate
   \       0x6C   0xE7ED             B.N      ??osMessageQueueNew_4
   1716                vQueueAddToRegistry (hQueue, name);
   \                     ??osMessageQueueNew_5: (+1)
   \       0x6E   0x.... 0x....      BL       vQueueAddToRegistry
   1717              }
   1718              #endif
   1719          
   1720            }
   1721          
   1722            return ((osMessageQueueId_t)hQueue);
   \                     ??osMessageQueueNew_0: (+1)
   \       0x72   0x4628             MOV      R0,R5
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}
   1723          }
   1724          

   \                                 In section .text, align 2, keep-with-next
   1725          osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
   \                     osMessageQueuePut: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1726            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1727            osStatus_t stat;
   1728            BaseType_t yield;
   1729          
   1730            (void)msg_prio; /* Message priority is ignored */
   1731          
   1732            stat = osOK;
   1733          
   1734            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_61: (+1)
   \        0x6   0xB94A             CBNZ.N   R2,??osMessageQueuePut_0
   \        0x8   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_92: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8211      MRSEQ    R2,BASEPRI
   \       0x12   0x2A00             CMPEQ    R2,#+0
   \       0x14   0xD013             BEQ.N    ??osMessageQueuePut_1
   \       0x16   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_87: (+1)
   \       0x1A   0xD110             BNE.N    ??osMessageQueuePut_1
   1735              if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
   \                     ??osMessageQueuePut_0: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xBF18             IT       NE
   \       0x20   0x2900             CMPNE    R1,#+0
   \       0x22   0xD010             BEQ.N    ??osMessageQueuePut_2
   \       0x24   0xB97C             CBNZ.N   R4,??osMessageQueuePut_2
   1736                stat = osErrorParameter;
   1737              }
   1738              else {
   1739                yield = pdFALSE;
   \       0x26   0x9400             STR      R4,[SP, #+0]
   1740          
   1741                if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x466A             MOV      R2,SP
   \       0x2C   0x.... 0x....      BL       xQueueGenericSendFromISR
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD115             BNE.N    ??osMessageQueuePut_3
   1742                  stat = osErrorResource;
   1743                } else {
   1744                  portYIELD_FROM_ISR (yield);
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0xB1A0             CBZ.N    R0,??osMessageQueuePut_4
   \       0x38   0x.... 0x....      BL       ?Subroutine17
   1745                }
   1746              }
   1747            }
   \                     ??CrossCallReturnLabel_101: (+1)
   \       0x3C   0xE011             B.N      ??osMessageQueuePut_4
   1748            else {
   1749              if ((hQueue == NULL) || (msg_ptr == NULL)) {
   \                     ??osMessageQueuePut_1: (+1)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xBF18             IT       NE
   \       0x42   0x2900             CMPNE    R1,#+0
   \       0x44   0xD102             BNE.N    ??osMessageQueuePut_5
   1750                stat = osErrorParameter;
   \                     ??osMessageQueuePut_2: (+1)
   \       0x46   0xF06F 0x0503      MVN      R5,#+3
   \       0x4A   0xE00A             B.N      ??osMessageQueuePut_4
   1751              }
   1752              else {
   1753                if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
   \                     ??osMessageQueuePut_5: (+1)
   \       0x4C   0x2300             MOVS     R3,#+0
   \       0x4E   0x4622             MOV      R2,R4
   \       0x50   0x.... 0x....      BL       xQueueGenericSend
   \       0x54   0x2801             CMP      R0,#+1
   \       0x56   0xD004             BEQ.N    ??osMessageQueuePut_4
   1754                  if (timeout != 0U) {
   \       0x58   0xB114             CBZ.N    R4,??osMessageQueuePut_3
   1755                    stat = osErrorTimeout;
   \       0x5A   0xF06F 0x0501      MVN      R5,#+1
   \       0x5E   0xE000             B.N      ??osMessageQueuePut_4
   1756                  } else {
   1757                    stat = osErrorResource;
   \                     ??osMessageQueuePut_3: (+1)
   \       0x60   0x4635             MOV      R5,R6
   1758                  }
   1759                }
   1760              }
   1761            }
   1762          
   1763            return (stat);
   \                     ??osMessageQueuePut_4: (+1)
   \       0x62   0x4628             MOV      R0,R5
   \       0x64   0xBD76             POP      {R1,R2,R4-R6,PC}
   1764          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x461C             MOV      R4,R3
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0xF06F 0x0602      MVN      R6,#+2
   \        0x8   0xF3EF 0x8205      MRS      R2,IPSR
   \        0xC   0x4770             BX       LR
   1765          

   \                                 In section .text, align 2, keep-with-next
   1766          osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
   \                     osMessageQueueGet: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1767            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1768            osStatus_t stat;
   1769            BaseType_t yield;
   1770          
   1771            (void)msg_prio; /* Message priority is ignored */
   1772          
   1773            stat = osOK;
   1774          
   1775            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_62: (+1)
   \        0x6   0xB94A             CBNZ.N   R2,??osMessageQueueGet_0
   \        0x8   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_93: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8211      MRSEQ    R2,BASEPRI
   \       0x12   0x2A00             CMPEQ    R2,#+0
   \       0x14   0xD012             BEQ.N    ??osMessageQueueGet_1
   \       0x16   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x1A   0xD10F             BNE.N    ??osMessageQueueGet_1
   1776              if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
   \                     ??osMessageQueueGet_0: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xBF18             IT       NE
   \       0x20   0x2900             CMPNE    R1,#+0
   \       0x22   0xD00F             BEQ.N    ??osMessageQueueGet_2
   \       0x24   0xB974             CBNZ.N   R4,??osMessageQueueGet_2
   1777                stat = osErrorParameter;
   1778              }
   1779              else {
   1780                yield = pdFALSE;
   \       0x26   0x9500             STR      R5,[SP, #+0]
   1781          
   1782                if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
   \       0x28   0x466A             MOV      R2,SP
   \       0x2A   0x.... 0x....      BL       xQueueReceiveFromISR
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD114             BNE.N    ??osMessageQueueGet_3
   1783                  stat = osErrorResource;
   1784                } else {
   1785                  portYIELD_FROM_ISR (yield);
   \       0x32   0x9800             LDR      R0,[SP, #+0]
   \       0x34   0xB198             CBZ.N    R0,??osMessageQueueGet_4
   \       0x36   0x.... 0x....      BL       ?Subroutine17
   1786                }
   1787              }
   1788            }
   \                     ??CrossCallReturnLabel_102: (+1)
   \       0x3A   0xE010             B.N      ??osMessageQueueGet_4
   1789            else {
   1790              if ((hQueue == NULL) || (msg_ptr == NULL)) {
   \                     ??osMessageQueueGet_1: (+1)
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xBF18             IT       NE
   \       0x40   0x2900             CMPNE    R1,#+0
   \       0x42   0xD102             BNE.N    ??osMessageQueueGet_5
   1791                stat = osErrorParameter;
   \                     ??osMessageQueueGet_2: (+1)
   \       0x44   0xF06F 0x0503      MVN      R5,#+3
   \       0x48   0xE009             B.N      ??osMessageQueueGet_4
   1792              }
   1793              else {
   1794                if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
   \                     ??osMessageQueueGet_5: (+1)
   \       0x4A   0x4622             MOV      R2,R4
   \       0x4C   0x.... 0x....      BL       xQueueReceive
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD004             BEQ.N    ??osMessageQueueGet_4
   1795                  if (timeout != 0U) {
   \       0x54   0xB114             CBZ.N    R4,??osMessageQueueGet_3
   1796                    stat = osErrorTimeout;
   \       0x56   0xF06F 0x0501      MVN      R5,#+1
   \       0x5A   0xE000             B.N      ??osMessageQueueGet_4
   1797                  } else {
   1798                    stat = osErrorResource;
   \                     ??osMessageQueueGet_3: (+1)
   \       0x5C   0x4635             MOV      R5,R6
   1799                  }
   1800                }
   1801              }
   1802            }
   1803          
   1804            return (stat);
   \                     ??osMessageQueueGet_4: (+1)
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0xBD76             POP      {R1,R2,R4-R6,PC}
   1805          }
   1806          

   \                                 In section .text, align 2, keep-with-next
   1807          uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
   1808            StaticQueue_t *mq = (StaticQueue_t *)mq_id;
   1809            uint32_t capacity;
   1810          
   1811            if (mq == NULL) {
   \                     osMessageQueueGetCapacity: (+1)
   \        0x0   0xB100             CBZ.N    R0,??osMessageQueueGetCapacity_0
   1812              capacity = 0U;
   1813            } else {
   1814              /* capacity = pxQueue->uxLength */
   1815              capacity = mq->uxDummy4[1];
   \        0x2   0x6BC0             LDR      R0,[R0, #+60]
   1816            }
   1817          
   1818            return (capacity);
   \                     ??osMessageQueueGetCapacity_0: (+1)
   \        0x4   0x4770             BX       LR
   1819          }
   1820          

   \                                 In section .text, align 2, keep-with-next
   1821          uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
   1822            StaticQueue_t *mq = (StaticQueue_t *)mq_id;
   1823            uint32_t size;
   1824          
   1825            if (mq == NULL) {
   \                     osMessageQueueGetMsgSize: (+1)
   \        0x0   0xB100             CBZ.N    R0,??osMessageQueueGetMsgSize_0
   1826              size = 0U;
   1827            } else {
   1828              /* size = pxQueue->uxItemSize */
   1829              size = mq->uxDummy4[2];
   \        0x2   0x6C00             LDR      R0,[R0, #+64]
   1830            }
   1831          
   1832            return (size);
   \                     ??osMessageQueueGetMsgSize_0: (+1)
   \        0x4   0x4770             BX       LR
   1833          }
   1834          

   \                                 In section .text, align 2, keep-with-next
   1835          uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
   1836            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1837            UBaseType_t count;
   1838          
   1839            if (hQueue == NULL) {
   \                     osMessageQueueGetCount: (+1)
   \        0x0   0xB198             CBZ.N    R0,??osMessageQueueGetCount_0
   1840              count = 0U;
   1841            }
   1842            else if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB961             CBNZ.N   R1,??osMessageQueueGetCount_1
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD006             BEQ.N    ??osMessageQueueGetCount_2
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable39
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x2902             CMP      R1,#+2
   \       0x20   0xD101             BNE.N    ??osMessageQueueGetCount_2
   1843              count = uxQueueMessagesWaitingFromISR (hQueue);
   \                     ??osMessageQueueGetCount_1: (+1)
   \       0x22   0x.... 0x....      B.W      uxQueueMessagesWaitingFromISR
   1844            }
   1845            else {
   1846              count = uxQueueMessagesWaiting (hQueue);
   \                     ??osMessageQueueGetCount_2: (+1)
   \       0x26   0x.... 0x....      B.W      uxQueueMessagesWaiting
   1847            }
   1848          
   1849            return ((uint32_t)count);
   \                     ??osMessageQueueGetCount_0: (+1)
   \       0x2A   0x4770             BX       LR
   1850          }
   1851          

   \                                 In section .text, align 2, keep-with-next
   1852          uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetSpace: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1853            StaticQueue_t *mq = (StaticQueue_t *)mq_id;
   1854            uint32_t space;
   1855            uint32_t isrm;
   1856          
   1857            if (mq == NULL) {
   \        0x4   0xBF08             IT       EQ
   \        0x6   0x2500             MOVEQ    R5,#+0
   1858              space = 0U;
   \        0x8   0xD018             BEQ.N    ??osMessageQueueGetSpace_0
   1859            }
   1860            else if (IS_IRQ()) {
   \        0xA   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xE   0xB948             CBNZ.N   R0,??osMessageQueueGetSpace_1
   \       0x10   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x14   0xBF04             ITT      EQ
   \       0x16   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x1A   0x2800             CMPEQ    R0,#+0
   \       0x1C   0xD00A             BEQ.N    ??osMessageQueueGetSpace_2
   \       0x1E   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x22   0xD107             BNE.N    ??osMessageQueueGetSpace_2
   1861              isrm = taskENTER_CRITICAL_FROM_ISR();
   \                     ??osMessageQueueGetSpace_1: (+1)
   \       0x24   0x.... 0x....      BL       ulSetInterruptMask
   1862          
   1863              /* space = pxQueue->uxLength - pxQueue->uxMessagesWaiting; */
   1864              space = mq->uxDummy4[1] - mq->uxDummy4[0];
   \       0x28   0x6BE5             LDR      R5,[R4, #+60]
   \       0x2A   0x6BA1             LDR      R1,[R4, #+56]
   \       0x2C   0x1A6D             SUBS     R5,R5,R1
   1865          
   1866              taskEXIT_CRITICAL_FROM_ISR(isrm);
   \       0x2E   0x.... 0x....      BL       vClearInterruptMask
   \       0x32   0xE003             B.N      ??osMessageQueueGetSpace_0
   1867            }
   1868            else {
   1869              space = (uint32_t)uxQueueSpacesAvailable ((QueueHandle_t)mq);
   \                     ??osMessageQueueGetSpace_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x.... 0x....      BL       uxQueueSpacesAvailable
   \       0x3A   0x4605             MOV      R5,R0
   1870            }
   1871          
   1872            return (space);
   \                     ??osMessageQueueGetSpace_0: (+1)
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}
   1873          }
   1874          

   \                                 In section .text, align 2, keep-with-next
   1875          osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
   \                     osMessageQueueReset: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1876            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1877            osStatus_t stat;
   1878          
   1879            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0xB961             CBNZ.N   R1,??osMessageQueueReset_0
   \        0x8   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xBF04             ITT      EQ
   \       0x10   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x14   0x2900             CMPEQ    R1,#+0
   \       0x16   0xD007             BEQ.N    ??osMessageQueueReset_1
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable39
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0x2902             CMP      R1,#+2
   \       0x20   0xD102             BNE.N    ??osMessageQueueReset_1
   1880              stat = osErrorISR;
   \                     ??osMessageQueueReset_0: (+1)
   \       0x22   0xF06F 0x0405      MVN      R4,#+5
   \       0x26   0xE007             B.N      ??osMessageQueueReset_2
   1881            }
   1882            else if (hQueue == NULL) {
   \                     ??osMessageQueueReset_1: (+1)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xBF0F             ITEEE    EQ
   1883              stat = osErrorParameter;
   \       0x2C   0xF06F 0x0403      MVNEQ    R4,#+3
   1884            }
   1885            else {
   1886              stat = osOK;
   \       0x30   0x2400             MOVNE    R4,#+0
   1887              (void)xQueueReset (hQueue);
   \       0x32   0x2100             MOVNE    R1,#+0
   \       0x34   0x.... 0x....      BLNE     xQueueGenericReset
   1888            }
   1889          
   1890            return (stat);
   \                     ??osMessageQueueReset_2: (+1)
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0xBD10             POP      {R4,PC}
   1891          }
   1892          

   \                                 In section .text, align 2, keep-with-next
   1893          osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
   \                     osMessageQueueDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1894            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1895            osStatus_t stat;
   1896          
   1897          #ifndef USE_FreeRTOS_HEAP_1
   1898            if (IS_IRQ()) {
   \                     ??CrossCallReturnLabel_60: (+1)
   \        0x6   0xB948             CBNZ.N   R0,??osMessageQueueDelete_0
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_42: (+1)
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x12   0x2800             CMPEQ    R0,#+0
   \       0x14   0xD005             BEQ.N    ??osMessageQueueDelete_1
   \       0x16   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x1A   0xD102             BNE.N    ??osMessageQueueDelete_1
   1899              stat = osErrorISR;
   \                     ??osMessageQueueDelete_0: (+1)
   \       0x1C   0xF06F 0x0505      MVN      R5,#+5
   \       0x20   0xE008             B.N      ??CrossCallReturnLabel_63
   1900            }
   1901            else if (hQueue == NULL) {
   \                     ??osMessageQueueDelete_1: (+1)
   \       0x22   0xB914             CBNZ.N   R4,??osMessageQueueDelete_2
   1902              stat = osErrorParameter;
   \       0x24   0xF06F 0x0503      MVN      R5,#+3
   \       0x28   0xE004             B.N      ??CrossCallReturnLabel_63
   1903            }
   1904            else {
   1905              #if (configQUEUE_REGISTRY_SIZE > 0)
   1906              vQueueUnregisterQueue (hQueue);
   \                     ??osMessageQueueDelete_2: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       vQueueUnregisterQueue
   1907              #endif
   1908          
   1909              stat = osOK;
   1910              vQueueDelete (hQueue);
   \       0x30   0x.... 0x....      BL       ?Subroutine11
   1911            }
   1912          #else
   1913            stat = osError;
   1914          #endif
   1915          
   1916            return (stat);
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
   1917          }
   1918          
   1919          /*---------------------------------------------------------------------------*/
   1920          #ifdef FREERTOS_MPOOL_H_
   1921          
   1922          /* Static memory pool functions */
   1923          static void  FreeBlock   (MemPool_t *mp, void *block);
   1924          static void *AllocBlock  (MemPool_t *mp);
   1925          static void *CreateBlock (MemPool_t *mp);
   1926          

   \                                 In section .text, align 2, keep-with-next
   1927          osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr) {
   \                     osMemoryPoolNew: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4617             MOV      R7,R2
   1928            MemPool_t *mp;
   1929            const char *name;
   1930            int32_t mem_cb, mem_mp;
   1931            uint32_t sz;
   1932          
   1933            if (IS_IRQ()) {
   \        0xA   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD16C             BNE.N    ??osMemoryPoolNew_0
   \       0x12   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x16   0xBF04             ITT      EQ
   \       0x18   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x1C   0x2800             CMPEQ    R0,#+0
   \       0x1E   0xD002             BEQ.N    ??osMemoryPoolNew_1
   \       0x20   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x24   0xD062             BEQ.N    ??osMemoryPoolNew_0
   1934              mp = NULL;
   1935            }
   1936            else if ((block_count == 0U) || (block_size == 0U)) {
   \                     ??osMemoryPoolNew_1: (+1)
   \       0x26   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x2A   0xBF18             IT       NE
   \       0x2C   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x30   0xD05C             BEQ.N    ??osMemoryPoolNew_0
   1937              mp = NULL;
   1938            }
   1939            else {
   1940              mp = NULL;
   1941              sz = MEMPOOL_ARR_SIZE (block_count, block_size);
   \       0x32   0xF108 0x0003      ADD      R0,R8,#+3
   \       0x36   0x0880             LSRS     R0,R0,#+2
   \       0x38   0xFB09 0xF000      MUL      R0,R9,R0
   1942          
   1943              name = NULL;
   1944              mem_cb = -1;
   \       0x3C   0xF04F 0x34FF      MOV      R4,#+4294967295
   \       0x40   0xF04F 0x0A00      MOV      R10,#+0
   \       0x44   0xEA4F 0x0B80      LSL      R11,R0,#+2
   1945              mem_mp = -1;
   \       0x48   0x4626             MOV      R6,R4
   1946          
   1947              if (attr != NULL) {
   \       0x4A   0xB1F7             CBZ.N    R7,??osMemoryPoolNew_2
   1948                if (attr->name != NULL) {
   \       0x4C   0x6838             LDR      R0,[R7, #+0]
   \       0x4E   0xB100             CBZ.N    R0,??osMemoryPoolNew_3
   1949                  name = attr->name;
   \       0x50   0x4682             MOV      R10,R0
   1950                }
   1951          
   1952                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(MemPool_t))) {
   \                     ??osMemoryPoolNew_3: (+1)
   \       0x52   0x68BD             LDR      R5,[R7, #+8]
   \       0x54   0x68F8             LDR      R0,[R7, #+12]
   \       0x56   0xB11D             CBZ.N    R5,??osMemoryPoolNew_4
   \       0x58   0x2874             CMP      R0,#+116
   \       0x5A   0xD303             BCC.N    ??osMemoryPoolNew_5
   1953                  /* Static control block is provided */
   1954                  mem_cb = 1;
   \       0x5C   0x2401             MOVS     R4,#+1
   \       0x5E   0xE001             B.N      ??osMemoryPoolNew_5
   1955                }
   \                     ??osMemoryPoolNew_4: (+1)
   \       0x60   0xB900             CBNZ.N   R0,??osMemoryPoolNew_5
   1956                else if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   1957                  /* Allocate control block memory on heap */
   1958                  mem_cb = 0;
   \       0x62   0x2400             MOVS     R4,#+0
   1959                }
   1960          
   1961                if ((attr->mp_mem == NULL) && (attr->mp_size == 0U)) {
   \                     ??osMemoryPoolNew_5: (+1)
   \       0x64   0x6938             LDR      R0,[R7, #+16]
   \       0x66   0xB940             CBNZ.N   R0,??osMemoryPoolNew_6
   \       0x68   0x6978             LDR      R0,[R7, #+20]
   \       0x6A   0xB900             CBNZ.N   R0,??osMemoryPoolNew_7
   1962                  /* Allocate memory array on heap */
   1963                    mem_mp = 0;
   \       0x6C   0x2600             MOVS     R6,#+0
   1964                }
   1965                else {
   1966                  if (attr->mp_mem != NULL) {
   1967                    /* Check if array is 4-byte aligned */
   1968                    if (((uint32_t)attr->mp_mem & 3U) == 0U) {
   1969                      /* Check if array big enough */
   1970                      if (attr->mp_size >= sz) {
   1971                        /* Static memory pool array is provided */
   1972                        mem_mp = 1;
   1973                      }
   1974                    }
   1975                  }
   1976                }
   1977              }
   1978              else {
   1979                /* Attributes not provided, allocate memory on heap */
   1980                mem_cb = 0;
   1981                mem_mp = 0;
   1982              }
   1983          
   1984              if (mem_cb == 0) {
   \                     ??osMemoryPoolNew_7: (+1)
   \       0x6E   0xB97C             CBNZ.N   R4,??osMemoryPoolNew_8
   1985                mp = pvPortMalloc (sizeof(MemPool_t));
   \                     ??osMemoryPoolNew_9: (+1)
   \       0x70   0x2074             MOVS     R0,#+116
   \       0x72   0x.... 0x....      BL       pvPortMalloc
   \       0x76   0x4605             MOV      R5,R0
   \       0x78   0xE00A             B.N      ??osMemoryPoolNew_8
   1986              } else {
   \                     ??osMemoryPoolNew_6: (+1)
   \       0x7A   0xF010 0x0F03      TST      R0,#0x3
   \       0x7E   0xD1F6             BNE.N    ??osMemoryPoolNew_7
   \       0x80   0x6978             LDR      R0,[R7, #+20]
   \       0x82   0x4558             CMP      R0,R11
   \       0x84   0xD3F3             BCC.N    ??osMemoryPoolNew_7
   \       0x86   0x2601             MOVS     R6,#+1
   \       0x88   0xE7F1             B.N      ??osMemoryPoolNew_7
   \                     ??osMemoryPoolNew_2: (+1)
   \       0x8A   0x2400             MOVS     R4,#+0
   \       0x8C   0x2600             MOVS     R6,#+0
   \       0x8E   0xE7EF             B.N      ??osMemoryPoolNew_9
   1987                mp = attr->cb_mem;
   1988              }
   1989          
   1990              if (mp != NULL) {
   \                     ??osMemoryPoolNew_8: (+1)
   \       0x90   0xB365             CBZ.N    R5,??osMemoryPoolNew_0
   1991                /* Create a semaphore (max count == initial count == block_count) */
   1992                #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1993                  mp->sem = xSemaphoreCreateCountingStatic (block_count, block_count, &mp->mem_sem);
   \       0x92   0xF105 0x0224      ADD      R2,R5,#+36
   \       0x96   0x4649             MOV      R1,R9
   \       0x98   0x4648             MOV      R0,R9
   \       0x9A   0x.... 0x....      BL       xQueueCreateCountingSemaphoreStatic
   \       0x9E   0x6068             STR      R0,[R5, #+4]
   1994                #elif (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1995                  mp->sem = xSemaphoreCreateCounting (block_count, block_count);
   1996                #else
   1997                  mp->sem == NULL;
   1998                #endif
   1999          
   2000                if (mp->sem != NULL) {
   \       0xA0   0xB130             CBZ.N    R0,??osMemoryPoolNew_10
   2001                  /* Setup memory array */
   2002                  if (mem_mp == 0) {
   \       0xA2   0x2E00             CMP      R6,#+0
   \       0xA4   0xBF12             ITEE     NE
   \       0xA6   0x6938             LDRNE    R0,[R7, #+16]
   2003                    mp->mem_arr = pvPortMalloc (sz);
   \       0xA8   0x4658             MOVEQ    R0,R11
   \       0xAA   0x.... 0x....      BLEQ     pvPortMalloc
   \       0xAE   0x60A8             STR      R0,[R5, #+8]
   \                     ??osMemoryPoolNew_10: (+1)
   \       0xB0   0x68A8             LDR      R0,[R5, #+8]
   \       0xB2   0xB1B8             CBZ.N    R0,??osMemoryPoolNew_11
   2004                  } else {
   2005                    mp->mem_arr = attr->mp_mem;
   2006                  }
   2007                }
   2008              }
   2009          
   2010              if ((mp != NULL) && (mp->mem_arr != NULL)) {
   2011                /* Memory pool can be created */
   2012                mp->head    = NULL;
   \       0xB4   0x2100             MOVS     R1,#+0
   \       0xB6   0x6029             STR      R1,[R5, #+0]
   2013                mp->mem_sz  = sz;
   \       0xB8   0xF8C5 0xB00C      STR      R11,[R5, #+12]
   2014                mp->name    = name;
   \       0xBC   0xF8C5 0xA010      STR      R10,[R5, #+16]
   2015                mp->bl_sz   = block_size;
   \       0xC0   0xF8C5 0x8014      STR      R8,[R5, #+20]
   2016                mp->bl_cnt  = block_count;
   \       0xC4   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2017                mp->n       = 0U;
   \       0xC8   0x61E9             STR      R1,[R5, #+28]
   2018          
   2019                /* Set heap allocated memory flags */
   2020                mp->status = MPOOL_STATUS;
   \       0xCA   0x....             LDR.N    R0,??DataTable39_1
   \       0xCC   0x6228             STR      R0,[R5, #+32]
   2021          
   2022                if (mem_cb == 0) {
   \       0xCE   0xB91C             CBNZ.N   R4,??osMemoryPoolNew_12
   2023                  /* Control block on heap */
   2024                  mp->status |= 1U;
   \       0xD0   0x6A28             LDR      R0,[R5, #+32]
   \       0xD2   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xD6   0x6228             STR      R0,[R5, #+32]
   2025                }
   2026                if (mem_mp == 0) {
   \                     ??osMemoryPoolNew_12: (+1)
   \       0xD8   0xB94E             CBNZ.N   R6,??osMemoryPoolNew_13
   2027                  /* Memory array on heap */
   2028                  mp->status |= 2U;
   \       0xDA   0x6A28             LDR      R0,[R5, #+32]
   \       0xDC   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0xE0   0x6228             STR      R0,[R5, #+32]
   \       0xE2   0xE004             B.N      ??osMemoryPoolNew_13
   2029                }
   2030              }
   2031              else {
   2032                /* Memory pool cannot be created, release allocated resources */
   2033                if ((mem_cb == 0) && (mp != NULL)) {
   \                     ??osMemoryPoolNew_11: (+1)
   \       0xE4   0xB914             CBNZ.N   R4,??osMemoryPoolNew_0
   2034                  /* Free control block memory */
   2035                  vPortFree (mp);
   \       0xE6   0x4628             MOV      R0,R5
   \       0xE8   0x.... 0x....      BL       vPortFree
   2036                }
   2037                mp = NULL;
   \                     ??osMemoryPoolNew_0: (+1)
   \       0xEC   0x2500             MOVS     R5,#+0
   2038              }
   2039            }
   2040          
   2041            return (mp);
   \                     ??osMemoryPoolNew_13: (+1)
   \       0xEE   0x4628             MOV      R0,R5
   \       0xF0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2042          }
   2043          

   \                                 In section .text, align 2, keep-with-next
   2044          const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id) {
   2045            MemPool_t *mp = (osMemoryPoolId_t)mp_id;
   2046            const char *p;
   2047          
   2048            if (IS_IRQ()) {
   \                     osMemoryPoolGetName: (+1)
   \        0x0   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x4   0xB959             CBNZ.N   R1,??osMemoryPoolGetName_0
   \        0x6   0xF3EF 0x8110      MRS      R1,PRIMASK
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xBF04             ITT      EQ
   \        0xE   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x12   0x2900             CMPEQ    R1,#+0
   \       0x14   0xD005             BEQ.N    ??osMemoryPoolGetName_1
   \       0x16   0x....             LDR.N    R2,??DataTable39
   \       0x18   0x6811             LDR      R1,[R2, #+0]
   \       0x1A   0x2902             CMP      R1,#+2
   \       0x1C   0xD101             BNE.N    ??osMemoryPoolGetName_1
   2049              p = NULL;
   \                     ??osMemoryPoolGetName_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x4770             BX       LR
   2050            }
   2051            else if (mp_id == NULL) {
   \                     ??osMemoryPoolGetName_1: (+1)
   \       0x22   0xB100             CBZ.N    R0,??osMemoryPoolGetName_2
   2052              p = NULL;
   2053            }
   2054            else {
   2055              p = mp->name;
   \       0x24   0x6900             LDR      R0,[R0, #+16]
   2056            }
   2057          
   2058            return (p);
   \                     ??osMemoryPoolGetName_2: (+1)
   \       0x26   0x4770             BX       LR
   2059          }
   2060          

   \                                 In section .text, align 2, keep-with-next
   2061          void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout) {
   \                     osMemoryPoolAlloc: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   2062            MemPool_t *mp;
   2063            void *block;
   2064            uint32_t isrm;
   2065          
   2066            if (mp_id == NULL) {
   \        0x4   0xBF08             IT       EQ
   \        0x6   0x2400             MOVEQ    R4,#+0
   2067              /* Invalid input parameters */
   2068              block = NULL;
   \        0x8   0xD044             BEQ.N    ??osMemoryPoolAlloc_0
   2069            }
   2070            else {
   2071              block = NULL;
   2072          
   2073              mp = (MemPool_t *)mp_id;
   2074          
   2075              if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
   \        0xA   0x6A28             LDR      R0,[R5, #+32]
   \        0xC   0x....             LDR.N    R6,??DataTable39_1
   \        0xE   0x2400             MOVS     R4,#+0
   \       0x10   0x4030             ANDS     R0,R6,R0
   \       0x12   0x42B0             CMP      R0,R6
   \       0x14   0xD13E             BNE.N    ??osMemoryPoolAlloc_0
   2076                if (IS_IRQ()) {
   \       0x16   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x1A   0xB950             CBNZ.N   R0,??osMemoryPoolAlloc_1
   \       0x1C   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x20   0xBF04             ITT      EQ
   \       0x22   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x26   0x2800             CMPEQ    R0,#+0
   \       0x28   0xD01E             BEQ.N    ??osMemoryPoolAlloc_2
   \       0x2A   0x....             LDR.N    R2,??DataTable39
   \       0x2C   0x6810             LDR      R0,[R2, #+0]
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD11A             BNE.N    ??osMemoryPoolAlloc_2
   2077                  if (timeout == 0U) {
   \                     ??osMemoryPoolAlloc_1: (+1)
   \       0x32   0xBB79             CBNZ.N   R1,??osMemoryPoolAlloc_0
   2078                    if (xSemaphoreTakeFromISR (mp->sem, NULL) == pdTRUE) {
   \       0x34   0x6868             LDR      R0,[R5, #+4]
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x.... 0x....      BL       xQueueReceiveFromISR
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xBF02             ITTT     EQ
   \       0x40   0x6A28             LDREQ    R0,[R5, #+32]
   \       0x42   0x4030             ANDEQ    R0,R6,R0
   \       0x44   0x42B0             CMPEQ    R0,R6
   2079                      if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
   \       0x46   0xD125             BNE.N    ??osMemoryPoolAlloc_0
   2080                        isrm  = taskENTER_CRITICAL_FROM_ISR();
   \       0x48   0x.... 0x....      BL       ulSetInterruptMask
   \       0x4C   0x4606             MOV      R6,R0
   2081          
   2082                        /* Get a block from the free-list */
   2083                        block = AllocBlock(mp);
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x.... 0x....      BL       AllocBlock
   \       0x54   0x0004             MOVS     R4,R0
   2084          
   2085                        if (block == NULL) {
   \       0x56   0xD103             BNE.N    ??osMemoryPoolAlloc_3
   2086                          /* List of free blocks is empty, 'create' new block */
   2087                          block = CreateBlock(mp);
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x.... 0x....      BL       CreateBlock
   \       0x5E   0x4604             MOV      R4,R0
   2088                        }
   2089          
   2090                        taskEXIT_CRITICAL_FROM_ISR(isrm);
   \                     ??osMemoryPoolAlloc_3: (+1)
   \       0x60   0x4630             MOV      R0,R6
   \       0x62   0x.... 0x....      BL       vClearInterruptMask
   \       0x66   0xE015             B.N      ??osMemoryPoolAlloc_0
   2091                      }
   2092                    }
   2093                  }
   2094                }
   2095                else {
   2096                  if (xSemaphoreTake (mp->sem, (TickType_t)timeout) == pdTRUE) {
   \                     ??osMemoryPoolAlloc_2: (+1)
   \       0x68   0x6868             LDR      R0,[R5, #+4]
   \       0x6A   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x6E   0x2801             CMP      R0,#+1
   \       0x70   0xBF02             ITTT     EQ
   \       0x72   0x6A28             LDREQ    R0,[R5, #+32]
   \       0x74   0x4030             ANDEQ    R0,R6,R0
   \       0x76   0x42B0             CMPEQ    R0,R6
   2097                    if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
   \       0x78   0xD10C             BNE.N    ??osMemoryPoolAlloc_0
   2098                      taskENTER_CRITICAL();
   \       0x7A   0x.... 0x....      BL       vPortEnterCritical
   2099          
   2100                      /* Get a block from the free-list */
   2101                      block = AllocBlock(mp);
   \       0x7E   0x4628             MOV      R0,R5
   \       0x80   0x.... 0x....      BL       AllocBlock
   \       0x84   0x0004             MOVS     R4,R0
   2102          
   2103                      if (block == NULL) {
   \       0x86   0xD103             BNE.N    ??osMemoryPoolAlloc_4
   2104                        /* List of free blocks is empty, 'create' new block */
   2105                        block = CreateBlock(mp);
   \       0x88   0x4628             MOV      R0,R5
   \       0x8A   0x.... 0x....      BL       CreateBlock
   \       0x8E   0x4604             MOV      R4,R0
   2106                      }
   2107          
   2108                      taskEXIT_CRITICAL();
   \                     ??osMemoryPoolAlloc_4: (+1)
   \       0x90   0x.... 0x....      BL       vPortExitCritical
   2109                    }
   2110                  }
   2111                }
   2112              }
   2113            }
   2114          
   2115            return (block);
   \                     ??osMemoryPoolAlloc_0: (+1)
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0xBD70             POP      {R4-R6,PC}
   2116          }
   2117          

   \                                 In section .text, align 2, keep-with-next
   2118          osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block) {
   \                     osMemoryPoolFree: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   2119            MemPool_t *mp;
   2120            osStatus_t stat;
   2121            uint32_t isrm;
   2122            BaseType_t yield;
   2123          
   2124            if ((mp_id == NULL) || (block == NULL)) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2D00             CMPNE    R5,#+0
   \        0xA   0xD00E             BEQ.N    ??osMemoryPoolFree_0
   2125              /* Invalid input parameters */
   2126              stat = osErrorParameter;
   2127            }
   2128            else {
   2129              mp = (MemPool_t *)mp_id;
   2130          
   2131              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \        0xC   0x6A20             LDR      R0,[R4, #+32]
   \        0xE   0x....             LDR.N    R1,??DataTable39_1
   \       0x10   0xF06F 0x0702      MVN      R7,#+2
   \       0x14   0x4008             ANDS     R0,R1,R0
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD135             BNE.N    ??osMemoryPoolFree_1
   2132                /* Invalid object status */
   2133                stat = osErrorResource;
   2134              }
   2135              else if ((block < (void *)&mp->mem_arr[0]) || (block > (void*)&mp->mem_arr[mp->mem_sz-1])) {
   \       0x1A   0x68A2             LDR      R2,[R4, #+8]
   \       0x1C   0x4295             CMP      R5,R2
   \       0x1E   0xBF21             ITTTT    CS
   \       0x20   0x68E1             LDRCS    R1,[R4, #+12]
   \       0x22   0x1851             ADDCS    R1,R2,R1
   \       0x24   0x1E4A             SUBCS    R2,R1,#+1
   \       0x26   0x42AA             CMPCS    R2,R5
   \       0x28   0xD202             BCS.N    ??osMemoryPoolFree_2
   2136                /* Block pointer outside of memory array area */
   2137                stat = osErrorParameter;
   \                     ??osMemoryPoolFree_0: (+1)
   \       0x2A   0xF06F 0x0603      MVN      R6,#+3
   \       0x2E   0xE035             B.N      ??CrossCallReturnLabel_52
   2138              }
   2139              else {
   2140                stat = osOK;
   \                     ??osMemoryPoolFree_2: (+1)
   \       0x30   0x2600             MOVS     R6,#+0
   2141          
   2142                if (IS_IRQ()) {
   \       0x32   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x36   0xB948             CBNZ.N   R0,??osMemoryPoolFree_3
   \       0x38   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x3C   0xBF04             ITT      EQ
   \       0x3E   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x42   0x2800             CMPEQ    R0,#+0
   \       0x44   0xD019             BEQ.N    ??osMemoryPoolFree_4
   \       0x46   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x4A   0xD116             BNE.N    ??osMemoryPoolFree_4
   2143                  if (uxSemaphoreGetCountFromISR (mp->sem) == mp->bl_cnt) {
   \                     ??osMemoryPoolFree_3: (+1)
   \       0x4C   0x6860             LDR      R0,[R4, #+4]
   \       0x4E   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x52   0x69A1             LDR      R1,[R4, #+24]
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD016             BEQ.N    ??osMemoryPoolFree_1
   2144                    stat = osErrorResource;
   2145                  }
   2146                  else {
   2147                    isrm = taskENTER_CRITICAL_FROM_ISR();
   \       0x58   0x.... 0x....      BL       ulSetInterruptMask
   2148          
   2149                    /* Add block to the list of free blocks */
   2150                    FreeBlock(mp, block);
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6029             STR      R1,[R5, #+0]
   \       0x60   0x6025             STR      R5,[R4, #+0]
   2151          
   2152                    taskEXIT_CRITICAL_FROM_ISR(isrm);
   \       0x62   0x.... 0x....      BL       vClearInterruptMask
   2153          
   2154                    yield = pdFALSE;
   \       0x66   0x9600             STR      R6,[SP, #+0]
   2155                    xSemaphoreGiveFromISR (mp->sem, &yield);
   \       0x68   0x6860             LDR      R0,[R4, #+4]
   \       0x6A   0x4669             MOV      R1,SP
   \       0x6C   0x.... 0x....      BL       xQueueGiveFromISR
   2156                    portYIELD_FROM_ISR (yield);
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0xB198             CBZ.N    R0,??CrossCallReturnLabel_52
   \       0x74   0x.... 0x....      BL       ?Subroutine17
   2157                  }
   2158                }
   \                     ??CrossCallReturnLabel_103: (+1)
   \       0x78   0xE010             B.N      ??CrossCallReturnLabel_52
   2159                else {
   2160                  if (uxSemaphoreGetCount (mp->sem) == mp->bl_cnt) {
   \                     ??osMemoryPoolFree_4: (+1)
   \       0x7A   0x6860             LDR      R0,[R4, #+4]
   \       0x7C   0x.... 0x....      BL       uxQueueMessagesWaiting
   \       0x80   0x69A1             LDR      R1,[R4, #+24]
   \       0x82   0x4288             CMP      R0,R1
   \       0x84   0xD101             BNE.N    ??osMemoryPoolFree_5
   2161                    stat = osErrorResource;
   \                     ??osMemoryPoolFree_1: (+1)
   \       0x86   0x463E             MOV      R6,R7
   \       0x88   0xE008             B.N      ??CrossCallReturnLabel_52
   2162                  }
   2163                  else {
   2164                    taskENTER_CRITICAL();
   \                     ??osMemoryPoolFree_5: (+1)
   \       0x8A   0x.... 0x....      BL       vPortEnterCritical
   2165          
   2166                    /* Add block to the list of free blocks */
   2167                    FreeBlock(mp, block);
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6028             STR      R0,[R5, #+0]
   \       0x92   0x6025             STR      R5,[R4, #+0]
   2168          
   2169                    taskEXIT_CRITICAL();
   \       0x94   0x.... 0x....      BL       vPortExitCritical
   2170          
   2171                    xSemaphoreGive (mp->sem);
   \       0x98   0x.... 0x....      BL       ?Subroutine8
   2172                  }
   2173                }
   2174              }
   2175            }
   2176          
   2177            return (stat);
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x9C   0x4630             MOV      R0,R6
   \       0x9E   0xBDF2             POP      {R1,R4-R7,PC}
   2178          }
   2179          

   \                                 In section .text, align 2, keep-with-next
   2180          uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id) {
   2181            MemPool_t *mp;
   2182            uint32_t  n;
   2183          
   2184            if (mp_id == NULL) {
   \                     osMemoryPoolGetCapacity: (+1)
   \        0x0   0xB138             CBZ.N    R0,??osMemoryPoolGetCapacity_0
   2185              /* Invalid input parameters */
   2186              n = 0U;
   2187            }
   2188            else {
   2189              mp = (MemPool_t *)mp_id;
   2190          
   2191              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \        0x2   0x6A01             LDR      R1,[R0, #+32]
   \        0x4   0x....             LDR.N    R2,??DataTable39_1
   \        0x6   0x4011             ANDS     R1,R2,R1
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD001             BEQ.N    ??osMemoryPoolGetCapacity_1
   2192                /* Invalid object status */
   2193                n = 0U;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   2194              }
   2195              else {
   2196                n = mp->bl_cnt;
   \                     ??osMemoryPoolGetCapacity_1: (+1)
   \       0x10   0x6980             LDR      R0,[R0, #+24]
   2197              }
   2198            }
   2199          
   2200            /* Return maximum number of memory blocks */
   2201            return (n);
   \                     ??osMemoryPoolGetCapacity_0: (+1)
   \       0x12   0x4770             BX       LR
   2202          }
   2203          

   \                                 In section .text, align 2, keep-with-next
   2204          uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id) {
   2205            MemPool_t *mp;
   2206            uint32_t  sz;
   2207          
   2208            if (mp_id == NULL) {
   \                     osMemoryPoolGetBlockSize: (+1)
   \        0x0   0xB138             CBZ.N    R0,??osMemoryPoolGetBlockSize_0
   2209              /* Invalid input parameters */
   2210              sz = 0U;
   2211            }
   2212            else {
   2213              mp = (MemPool_t *)mp_id;
   2214          
   2215              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \        0x2   0x6A01             LDR      R1,[R0, #+32]
   \        0x4   0x....             LDR.N    R2,??DataTable39_1
   \        0x6   0x4011             ANDS     R1,R2,R1
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD001             BEQ.N    ??osMemoryPoolGetBlockSize_1
   2216                /* Invalid object status */
   2217                sz = 0U;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   2218              }
   2219              else {
   2220                sz = mp->bl_sz;
   \                     ??osMemoryPoolGetBlockSize_1: (+1)
   \       0x10   0x6940             LDR      R0,[R0, #+20]
   2221              }
   2222            }
   2223          
   2224            /* Return memory block size in bytes */
   2225            return (sz);
   \                     ??osMemoryPoolGetBlockSize_0: (+1)
   \       0x12   0x4770             BX       LR
   2226          }
   2227          

   \                                 In section .text, align 2, keep-with-next
   2228          uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id) {
   \                     osMemoryPoolGetCount: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2229            MemPool_t *mp;
   2230            uint32_t  n;
   2231          
   2232            if (mp_id == NULL) {
   \        0x4   0xD004             BEQ.N    ??osMemoryPoolGetCount_0
   2233              /* Invalid input parameters */
   2234              n = 0U;
   2235            }
   2236            else {
   2237              mp = (MemPool_t *)mp_id;
   2238          
   2239              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \        0x6   0x6A20             LDR      R0,[R4, #+32]
   \        0x8   0x....             LDR.N    R1,??DataTable39_1
   \        0xA   0x4008             ANDS     R0,R1,R0
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xD001             BEQ.N    ??osMemoryPoolGetCount_1
   2240                /* Invalid object status */
   2241                n = 0U;
   \                     ??osMemoryPoolGetCount_0: (+1)
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0xE015             B.N      ??osMemoryPoolGetCount_2
   2242              }
   2243              else {
   2244                if (IS_IRQ()) {
   \                     ??osMemoryPoolGetCount_1: (+1)
   \       0x14   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x18   0xB948             CBNZ.N   R0,??osMemoryPoolGetCount_3
   \       0x1A   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x1E   0xBF04             ITT      EQ
   \       0x20   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x24   0x2800             CMPEQ    R0,#+0
   \       0x26   0xD006             BEQ.N    ??osMemoryPoolGetCount_4
   \       0x28   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x2C   0xD103             BNE.N    ??osMemoryPoolGetCount_4
   2245                  n = uxSemaphoreGetCountFromISR (mp->sem);
   \                     ??osMemoryPoolGetCount_3: (+1)
   \       0x2E   0x6860             LDR      R0,[R4, #+4]
   \       0x30   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x34   0xE002             B.N      ??osMemoryPoolGetCount_5
   2246                } else {
   2247                  n = uxSemaphoreGetCount        (mp->sem);
   \                     ??osMemoryPoolGetCount_4: (+1)
   \       0x36   0x6860             LDR      R0,[R4, #+4]
   \       0x38   0x.... 0x....      BL       uxQueueMessagesWaiting
   2248                }
   2249          
   2250                n = mp->bl_cnt - n;
   \                     ??osMemoryPoolGetCount_5: (+1)
   \       0x3C   0x69A1             LDR      R1,[R4, #+24]
   \       0x3E   0x1A09             SUBS     R1,R1,R0
   2251              }
   2252            }
   2253          
   2254            /* Return number of memory blocks used */
   2255            return (n);
   \                     ??osMemoryPoolGetCount_2: (+1)
   \       0x40   0x4608             MOV      R0,R1
   \       0x42   0xBD10             POP      {R4,PC}
   2256          }
   2257          

   \                                 In section .text, align 2, keep-with-next
   2258          uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id) {
   2259            MemPool_t *mp;
   2260            uint32_t  n;
   2261          
   2262            if (mp_id == NULL) {
   \                     osMemoryPoolGetSpace: (+1)
   \        0x0   0xB120             CBZ.N    R0,??osMemoryPoolGetSpace_0
   2263              /* Invalid input parameters */
   2264              n = 0U;
   2265            }
   2266            else {
   2267              mp = (MemPool_t *)mp_id;
   2268          
   2269              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \        0x2   0x6A01             LDR      R1,[R0, #+32]
   \        0x4   0x....             LDR.N    R2,??DataTable39_1
   \        0x6   0x4011             ANDS     R1,R2,R1
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD001             BEQ.N    ??osMemoryPoolGetSpace_1
   2270                /* Invalid object status */
   2271                n = 0U;
   \                     ??osMemoryPoolGetSpace_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   2272              }
   2273              else {
   2274                if (IS_IRQ()) {
   \                     ??osMemoryPoolGetSpace_1: (+1)
   \       0x10   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x14   0xB959             CBNZ.N   R1,??osMemoryPoolGetSpace_2
   \       0x16   0xF3EF 0x8110      MRS      R1,PRIMASK
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xBF04             ITT      EQ
   \       0x1E   0xF3EF 0x8111      MRSEQ    R1,BASEPRI
   \       0x22   0x2900             CMPEQ    R1,#+0
   \       0x24   0xD006             BEQ.N    ??osMemoryPoolGetSpace_3
   \       0x26   0x....             LDR.N    R2,??DataTable39
   \       0x28   0x6811             LDR      R1,[R2, #+0]
   \       0x2A   0x2902             CMP      R1,#+2
   \       0x2C   0xD102             BNE.N    ??osMemoryPoolGetSpace_3
   2275                  n = uxSemaphoreGetCountFromISR (mp->sem);
   \                     ??osMemoryPoolGetSpace_2: (+1)
   \       0x2E   0x6840             LDR      R0,[R0, #+4]
   \       0x30   0x.... 0x....      B.W      uxQueueMessagesWaitingFromISR
   2276                } else {
   2277                  n = uxSemaphoreGetCount        (mp->sem);
   \                     ??osMemoryPoolGetSpace_3: (+1)
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0x.... 0x....      B.W      uxQueueMessagesWaiting
   2278                }
   2279              }
   2280            }
   2281          
   2282            /* Return number of memory blocks available */
   2283            return (n);
   2284          }
   2285          

   \                                 In section .text, align 2, keep-with-next
   2286          osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id) {
   \                     osMemoryPoolDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2287            MemPool_t *mp;
   2288            osStatus_t stat;
   2289          
   2290            if (mp_id == NULL) {
   \        0x4   0xD102             BNE.N    ??osMemoryPoolDelete_0
   2291              /* Invalid input parameters */
   2292              stat = osErrorParameter;
   \        0x6   0xF06F 0x0003      MVN      R0,#+3
   \        0xA   0xBD10             POP      {R4,PC}
   2293            }
   2294            else if (IS_IRQ()) {
   \                     ??osMemoryPoolDelete_0: (+1)
   \        0xC   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x10   0xB948             CBNZ.N   R0,??osMemoryPoolDelete_1
   \       0x12   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x16   0xBF04             ITT      EQ
   \       0x18   0xF3EF 0x8011      MRSEQ    R0,BASEPRI
   \       0x1C   0x2800             CMPEQ    R0,#+0
   \       0x1E   0xD005             BEQ.N    ??osMemoryPoolDelete_2
   \       0x20   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x24   0xD102             BNE.N    ??osMemoryPoolDelete_2
   2295              stat = osErrorISR;
   \                     ??osMemoryPoolDelete_1: (+1)
   \       0x26   0xF06F 0x0005      MVN      R0,#+5
   \       0x2A   0xBD10             POP      {R4,PC}
   2296            }
   2297            else {
   2298              mp = (MemPool_t *)mp_id;
   2299          
   2300              taskENTER_CRITICAL();
   \                     ??osMemoryPoolDelete_2: (+1)
   \       0x2C   0x.... 0x....      BL       vPortEnterCritical
   2301          
   2302              /* Invalidate control block status */
   2303              mp->status  = mp->status & 3U;
   \       0x30   0x6A20             LDR      R0,[R4, #+32]
   \       0x32   0xF000 0x0003      AND      R0,R0,#0x3
   \       0x36   0x6220             STR      R0,[R4, #+32]
   2304          
   2305              /* Wake-up tasks waiting for pool semaphore */
   2306              while (xSemaphoreGive (mp->sem) == pdTRUE);
   \                     ??osMemoryPoolDelete_3: (+1)
   \       0x38   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD0FB             BEQ.N    ??osMemoryPoolDelete_3
   2307          
   2308              mp->head    = NULL;
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x6022             STR      R2,[R4, #+0]
   2309              mp->bl_sz   = 0U;
   \       0x44   0x6162             STR      R2,[R4, #+20]
   2310              mp->bl_cnt  = 0U;
   \       0x46   0x61A2             STR      R2,[R4, #+24]
   2311          
   2312              if ((mp->status & 2U) != 0U) {
   \       0x48   0x6A21             LDR      R1,[R4, #+32]
   \       0x4A   0x0788             LSLS     R0,R1,#+30
   \       0x4C   0xBF44             ITT      MI
   2313                /* Memory pool array allocated on heap */
   2314                vPortFree (mp->mem_arr);
   \       0x4E   0x68A0             LDRMI    R0,[R4, #+8]
   \       0x50   0x.... 0x....      BLMI     vPortFree
   2315              }
   2316              if ((mp->status & 1U) != 0U) {
   \       0x54   0x6A21             LDR      R1,[R4, #+32]
   \       0x56   0x07C8             LSLS     R0,R1,#+31
   \       0x58   0xBF44             ITT      MI
   2317                /* Memory pool control block allocated on heap */
   2318                vPortFree (mp);
   \       0x5A   0x4620             MOVMI    R0,R4
   \       0x5C   0x.... 0x....      BLMI     vPortFree
   2319              }
   2320          
   2321              taskEXIT_CRITICAL();
   \       0x60   0x.... 0x....      BL       vPortExitCritical
   2322          
   2323              stat = osOK;
   \       0x64   0x2000             MOVS     R0,#+0
   2324            }
   2325          
   2326            return (stat);
   \       0x66   0xBD10             POP      {R4,PC}
   2327          }
   2328          
   2329          /*
   2330            Create new block given according to the current block index.
   2331          */

   \                                 In section .text, align 2, keep-with-next
   2332          static void *CreateBlock (MemPool_t *mp) {
   \                     CreateBlock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4601             MOV      R1,R0
   2333            MemPoolBlock_t *p = NULL;
   2334          
   2335            if (mp->n < mp->bl_cnt) {
   \        0x4   0x69CA             LDR      R2,[R1, #+28]
   \        0x6   0x698C             LDR      R4,[R1, #+24]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x42A2             CMP      R2,R4
   \        0xC   0xD205             BCS.N    ??CreateBlock_0
   2336              /* Unallocated blocks exist, set pointer to new block */
   2337              p = (void *)(mp->mem_arr + (mp->bl_sz * mp->n));
   \        0xE   0x6948             LDR      R0,[R1, #+20]
   \       0x10   0x688B             LDR      R3,[R1, #+8]
   \       0x12   0x4350             MULS     R0,R2,R0
   2338          
   2339              /* Increment block index */
   2340              mp->n += 1U;
   \       0x14   0x1C52             ADDS     R2,R2,#+1
   \       0x16   0x61CA             STR      R2,[R1, #+28]
   \       0x18   0x4418             ADD      R0,R3,R0
   2341            }
   2342          
   2343            return (p);
   \                     ??CreateBlock_0: (+1)
   \       0x1A   0xBD10             POP      {R4,PC}
   2344          }
   2345          
   2346          /*
   2347            Allocate a block by reading the list of free blocks.
   2348          */

   \                                 In section .text, align 2, keep-with-next
   2349          static void *AllocBlock (MemPool_t *mp) {
   \                     AllocBlock: (+1)
   \        0x0   0x4601             MOV      R1,R0
   2350            MemPoolBlock_t *p = NULL;
   2351          
   2352            if (mp->head != NULL) {
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xB112             CBZ.N    R2,??AllocBlock_0
   2353              /* List of free block exists, get head block */
   2354              p = mp->head;
   \        0x8   0x4610             MOV      R0,R2
   2355          
   2356              /* Head block is now next on the list */
   2357              mp->head = p->next;
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   \        0xC   0x600A             STR      R2,[R1, #+0]
   2358            }
   2359          
   2360            return (p);
   \                     ??AllocBlock_0: (+1)
   \        0xE   0x4770             BX       LR
   2361          }
   2362          
   2363          /*
   2364            Free block by putting it to the list of free blocks.
   2365          */
   2366          static void FreeBlock (MemPool_t *mp, void *block) {
   2367            MemPoolBlock_t *p = block;
   2368          
   2369            /* Store current head into block memory space */
   2370            p->next = mp->head;
   2371          
   2372            /* Store current block as new head */
   2373            mp->head = p;
   2374          }
   2375          #endif /* FREERTOS_MPOOL_H_ */
   2376          /*---------------------------------------------------------------------------*/
   2377          
   2378          /* Callback function prototypes */
   2379          extern void vApplicationIdleHook (void);
   2380          extern void vApplicationTickHook (void);
   2381          extern void vApplicationMallocFailedHook (void);
   2382          extern void vApplicationDaemonTaskStartupHook (void);
   2383          extern void vApplicationStackOverflowHook (TaskHandle_t xTask, char *pcTaskName);
   2384          
   2385          /**
   2386            Dummy implementation of the callback function vApplicationIdleHook().
   2387          */
   2388          #if (configUSE_IDLE_HOOK == 1)
   2389          __WEAK void vApplicationIdleHook (void){}
   2390          #endif
   2391          
   2392          /**
   2393            Dummy implementation of the callback function vApplicationTickHook().
   2394          */
   2395          #if (configUSE_TICK_HOOK == 1)
   2396           __WEAK void vApplicationTickHook (void){}
   2397          #endif
   2398          
   2399          /**
   2400            Dummy implementation of the callback function vApplicationMallocFailedHook().
   2401          */
   2402          #if (configUSE_MALLOC_FAILED_HOOK == 1)
   2403          __WEAK void vApplicationMallocFailedHook (void){}
   2404          #endif
   2405          
   2406          /**
   2407            Dummy implementation of the callback function vApplicationDaemonTaskStartupHook().
   2408          */
   2409          #if (configUSE_DAEMON_TASK_STARTUP_HOOK == 1)
   2410          __WEAK void vApplicationDaemonTaskStartupHook (void){}
   2411          #endif
   2412          
   2413          /**
   2414            Dummy implementation of the callback function vApplicationStackOverflowHook().
   2415          */
   2416          #if (configCHECK_FOR_STACK_OVERFLOW > 0)

   \                                 In section .text, align 4
   2417          __WEAK void vApplicationStackOverflowHook (TaskHandle_t xTask, char *pcTaskName) {
   2418            (void)xTask;
   2419            (void)pcTaskName;
   2420            configASSERT(0);
   \                     vApplicationStackOverflowHook: (+1)
   \        0x0   0xF640 0x1174      MOVW     R1,#+2420
   \        0x4   0x4801             LDR.N    R0,??vApplicationStackOverflowHook_0
   \        0x6   0x.... 0x....      B.W      assertEFM
   \        0xA   0xBF00             Nop
   \                     ??vApplicationStackOverflowHook_0:
   \        0xC   0x....'....        DC32     ?_0
   2421          }
   2422          #endif
   2423          
   2424          /*---------------------------------------------------------------------------*/
   2425          #if (configSUPPORT_STATIC_ALLOCATION == 1)
   2426          /* External Idle and Timer task static memory allocation functions */
   2427          extern void vApplicationGetIdleTaskMemory  (StaticTask_t **ppxIdleTaskTCBBuffer,  StackType_t **ppxIdleTaskStackBuffer,  uint32_t *pulIdleTaskStackSize);
   2428          extern void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize);
   2429          
   2430          /*
   2431            vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
   2432            equals to 1 and is required for static memory allocation support.
   2433          */

   \                                 In section .text, align 4
   2434          __WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
   2435            /* Idle task control block and stack */
   2436            static StaticTask_t Idle_TCB;
   2437            static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];
   2438          
   2439            *ppxIdleTaskTCBBuffer   = &Idle_TCB;
   \                     vApplicationGetIdleTaskMemory: (+1)
   \        0x0   0x4B03             LDR.N    R3,??vApplicationGetIdleTaskMemory_0
   \        0x2   0x6003             STR      R3,[R0, #+0]
   2440            *ppxIdleTaskStackBuffer = &Idle_Stack[0];
   \        0x4   0xF103 0x0060      ADD      R0,R3,#+96
   \        0x8   0x6008             STR      R0,[R1, #+0]
   2441            *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
   \        0xA   0x21A0             MOVS     R1,#+160
   \        0xC   0x6011             STR      R1,[R2, #+0]
   2442          }
   \        0xE   0x4770             BX       LR
   \                     ??vApplicationGetIdleTaskMemory_0:
   \       0x10   0x....'....        DC32     `vApplicationGetIdleTaskMemory::Idle_TCB`

   \                                 In section .bss, align 4
   \                     `vApplicationGetIdleTaskMemory::Idle_TCB`:
   \        0x0                      DS8 96
   \       0x60                      DS8 640
   2443          
   2444          /*
   2445            vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
   2446            equals to 1 and is required for static memory allocation support.
   2447          */

   \                                 In section .text, align 4
   2448          __WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
   2449            /* Timer task control block and stack */
   2450            static StaticTask_t Timer_TCB;
   2451            static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];
   2452          
   2453            *ppxTimerTaskTCBBuffer   = &Timer_TCB;
   \                     vApplicationGetTimerTaskMemory: (+1)
   \        0x0   0x4B03             LDR.N    R3,??vApplicationGetTimerTaskMemory_0
   \        0x2   0x6003             STR      R3,[R0, #+0]
   2454            *ppxTimerTaskStackBuffer = &Timer_Stack[0];
   \        0x4   0xF103 0x0060      ADD      R0,R3,#+96
   \        0x8   0x6008             STR      R0,[R1, #+0]
   2455            *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
   \        0xA   0x21A0             MOVS     R1,#+160
   \        0xC   0x6011             STR      R1,[R2, #+0]
   2456          }
   \        0xE   0x4770             BX       LR
   \                     ??vApplicationGetTimerTaskMemory_0:
   \       0x10   0x....'....        DC32     `vApplicationGetTimerTaskMemory::Timer_TCB`

   \                                 In section .bss, align 4
   \                     `vApplicationGetTimerTaskMemory::Timer_TCB`:
   \        0x0                      DS8 96
   \       0x60                      DS8 640

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x75 0x74          DC8 0x75, 0x74, 0x69, 0x6C, 0x5C, 0x74, 0x68, 0x69
   \              0x69 0x6C    
   \              0x5C 0x74    
   \              0x68 0x69
   \       0x50   0x72 0x64          DC8 0x72, 0x64, 0x5F, 0x70, 0x61, 0x72, 0x74, 0x79
   \              0x5F 0x70    
   \              0x61 0x72    
   \              0x74 0x79
   \       0x58   0x5C 0x66          DC8 0x5C, 0x66, 0x72, 0x65, 0x65, 0x72, 0x74, 0x6F
   \              0x72 0x65    
   \              0x65 0x72    
   \              0x74 0x6F
   \       0x60   0x73 0x5C          DC8 0x73, 0x5C, 0x63, 0x6D, 0x73, 0x69, 0x73, 0x5C
   \              0x63 0x6D    
   \              0x73 0x69    
   \              0x73 0x5C
   \       0x68   0x53 0x6F          DC8 0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x5C, 0x63
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x63
   \       0x70   0x6D 0x73          DC8 0x6D, 0x73, 0x69, 0x73, 0x5F, 0x6F, 0x73, 0x32
   \              0x69 0x73    
   \              0x5F 0x6F    
   \              0x73 0x32
   \       0x78   0x2E 0x63          DC8 0x2E, 0x63, 0
   \              0x00
   \       0x7B                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x46 0x72          DC8 "FreeRTOS V10.4.3"
   \              0x65 0x65    
   \              0x52 0x54    
   \              0x4F 0x53    
   \              0x20 0x56    
   \              0x31 0x30    
   \              0x2E 0x34    
   \              0x2E 0x33    
   \              0x00
   \       0x11                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x....'....        DC32     KernelState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x05F5'FD43        DC32     0x5f5fd43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0xE000'ED1F        DC32     0xe000ed1f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x....'....        DC32     TimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \        0x0   0x....'....        DC32     KernelState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \        0x0   0x5EED'0000        DC32     0x5eed0000
   2457          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AllocBlock
       8   CreateBlock
       8   SysTick_Handler
         0   -> xPortSysTickHandler
         8   -> xTaskGetSchedulerState
       8   TimerCallback
         0   -- Indirect call
         8   -> pvTimerGetTimerID
       8   osDelay
         8   -> vTaskDelay
      16   osDelayUntil
        16   -> xTaskDelayUntil
        16   -> xTaskGetTickCount
      16   osEventFlagsClear
        16   -> xEventGroupClearBits
        16   -> xEventGroupClearBitsFromISR
        16   -> xEventGroupGetBitsFromISR
       8   osEventFlagsDelete
         8   -> vEventGroupDelete
       0   osEventFlagsGet
         0   -> xEventGroupClearBits
         0   -> xEventGroupGetBitsFromISR
       0   osEventFlagsNew
         0   -> xEventGroupCreate
         0   -> xEventGroupCreateStatic
      16   osEventFlagsSet
        16   -> xEventGroupSetBits
        16   -> xEventGroupSetBitsFromISR
      24   osEventFlagsWait
        24   -> xEventGroupWaitBits
       8   osKernelGetInfo
         8   -> __aeabi_memcpy
       8   osKernelGetState
         8   -> xTaskGetSchedulerState
      16   osKernelGetSysTimerCount
        16   -> OS_Tick_GetCount
        16   -> OS_Tick_GetInterval
        16   -> OS_Tick_GetOverflow
        16   -> xTaskGetTickCount
       0   osKernelGetSysTimerFreq
       0   osKernelGetTickCount
         0   -> xTaskGetTickCount
         0   -> xTaskGetTickCountFromISR
       0   osKernelGetTickFreq
       0   osKernelInitialize
       8   osKernelLock
         8   -> vTaskSuspendAll
         8   -> xTaskGetSchedulerState
      16   osKernelRestoreLock
        16   -> vTaskSuspendAll
        16   -> xTaskGetSchedulerState
        16   -> xTaskResumeAll
       8   osKernelStart
         8   -> vTaskStartScheduler
      16   osKernelUnlock
        16   -> xTaskGetSchedulerState
        16   -> xTaskResumeAll
      16   osMemoryPoolAlloc
        16   -> AllocBlock
        16   -> CreateBlock
        16   -> ulSetInterruptMask
        16   -> vClearInterruptMask
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> xQueueReceiveFromISR
        16   -> xQueueSemaphoreTake
       8   osMemoryPoolDelete
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vPortFree
         8   -> xQueueGenericSend
      24   osMemoryPoolFree
        24   -> ulSetInterruptMask
        24   -> uxQueueMessagesWaiting
        24   -> uxQueueMessagesWaitingFromISR
        24   -> vClearInterruptMask
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> xQueueGenericSend
        24   -> xQueueGiveFromISR
       0   osMemoryPoolGetBlockSize
       0   osMemoryPoolGetCapacity
       8   osMemoryPoolGetCount
         8   -> uxQueueMessagesWaiting
         8   -> uxQueueMessagesWaitingFromISR
       0   osMemoryPoolGetName
       0   osMemoryPoolGetSpace
         0   -> uxQueueMessagesWaiting
         0   -> uxQueueMessagesWaitingFromISR
      40   osMemoryPoolNew
        40   -> pvPortMalloc
        40   -> vPortFree
        40   -> xQueueCreateCountingSemaphoreStatic
      16   osMessageQueueDelete
        16   -> vQueueDelete
        16   -> vQueueUnregisterQueue
      24   osMessageQueueGet
        24   -> xQueueReceive
        24   -> xQueueReceiveFromISR
       0   osMessageQueueGetCapacity
       0   osMessageQueueGetCount
         0   -> uxQueueMessagesWaiting
         0   -> uxQueueMessagesWaitingFromISR
       0   osMessageQueueGetMsgSize
      16   osMessageQueueGetSpace
        16   -> ulSetInterruptMask
        16   -> uxQueueSpacesAvailable
        16   -> vClearInterruptMask
      24   osMessageQueueNew
        24   -> vQueueAddToRegistry
        24   -> xQueueGenericCreate
        24   -> xQueueGenericCreateStatic
      24   osMessageQueuePut
        24   -> xQueueGenericSend
        24   -> xQueueGenericSendFromISR
       8   osMessageQueueReset
         8   -> xQueueGenericReset
      24   osMutexAcquire
        24   -> xQueueSemaphoreTake
        24   -> xQueueTakeMutexRecursive
      16   osMutexDelete
        16   -> vQueueDelete
        16   -> vQueueUnregisterQueue
       0   osMutexGetOwner
         0   -> xQueueGetMutexHolder
      16   osMutexNew
        16   -> vQueueAddToRegistry
        16   -> xQueueCreateMutex
        16   -> xQueueCreateMutexStatic
      16   osMutexRelease
        16   -> xQueueGenericSend
        16   -> xQueueGiveMutexRecursive
      24   osSemaphoreAcquire
        24   -> xQueueReceiveFromISR
        24   -> xQueueSemaphoreTake
      16   osSemaphoreDelete
        16   -> vQueueDelete
        16   -> vQueueUnregisterQueue
       0   osSemaphoreGetCount
         0   -> uxQueueMessagesWaiting
         0   -> uxQueueMessagesWaitingFromISR
      24   osSemaphoreNew
        24   -> vQueueAddToRegistry
        24   -> vQueueDelete
        24   -> xQueueCreateCountingSemaphore
        24   -> xQueueCreateCountingSemaphoreStatic
        24   -> xQueueGenericCreate
        24   -> xQueueGenericCreateStatic
        24   -> xQueueGenericSend
      16   osSemaphoreRelease
        16   -> xQueueGenericSend
        16   -> xQueueGiveFromISR
      24   osThreadEnumerate
        24   -> pvPortMalloc
        24   -> uxTaskGetNumberOfTasks
        24   -> uxTaskGetSystemState
        24   -> vPortFree
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
       0   osThreadExit
         0   -> vTaskDelete
      32   osThreadFlagsClear
        32   -> xTaskGenericNotify
        32   -> xTaskGetCurrentTaskHandle
      16   osThreadFlagsGet
        16   -> xTaskGenericNotify
        16   -> xTaskGetCurrentTaskHandle
      32   osThreadFlagsSet
        32   -> xTaskGenericNotify
        32   -> xTaskGenericNotifyFromISR
      48   osThreadFlagsWait
        48   -> xTaskGenericNotifyWait
        48   -> xTaskGetTickCount
       0   osThreadGetCount
         0   -> uxTaskGetNumberOfTasks
       0   osThreadGetId
         0   -> xTaskGetCurrentTaskHandle
       0   osThreadGetName
         0   -> pcTaskGetName
       0   osThreadGetPriority
         0   -> uxTaskPriorityGet
       8   osThreadGetStackSpace
         8   -> uxTaskGetStackHighWaterMark
       8   osThreadGetState
         8   -> eTaskGetState
      40   osThreadNew
        40   -> xTaskCreate
        40   -> xTaskCreateStatic
       8   osThreadResume
         8   -> vTaskResume
       8   osThreadSetPriority
         8   -> vTaskPrioritySet
       8   osThreadSuspend
         8   -> vTaskSuspend
      16   osThreadTerminate
        16   -> eTaskGetState
        16   -> vTaskDelete
       8   osThreadYield
         8   -> vPortYield
      16   osTimerDelete
        16   -> pvTimerGetTimerID
        16   -> vPortFree
        16   -> xTimerGenericCommand
       0   osTimerGetName
         0   -> pcTimerGetName
       0   osTimerIsRunning
         0   -> xTimerIsTimerActive
      40   osTimerNew
        40   -> pvPortMalloc
        40   -> vPortFree
        40   -> xTimerCreate
        40   -> xTimerCreateStatic
      16   osTimerStart
        16   -> xTimerGenericCommand
      16   osTimerStop
        16   -> xTimerGenericCommand
        16   -> xTimerIsTimerActive
       0   vApplicationGetIdleTaskMemory
       0   vApplicationGetTimerTaskMemory
       0   vApplicationStackOverflowHook
         0   -> assertEFM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable26
       4  ??DataTable30
       4  ??DataTable34
       4  ??DataTable39
       4  ??DataTable39_1
       6  ?Subroutine0
       6  ?Subroutine1
      14  ?Subroutine10
       8  ?Subroutine11
       8  ?Subroutine12
      10  ?Subroutine13
      10  ?Subroutine14
       8  ?Subroutine15
      10  ?Subroutine16
      10  ?Subroutine17
       6  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
      12  ?Subroutine8
       8  ?Subroutine9
     124  ?_0
      20  ?_1
      16  AllocBlock
      28  CreateBlock
     736  Idle_TCB
          Idle_Stack
       4  KernelState
      26  SysTick_Handler
      22  TimerCallback
     736  Timer_TCB
          Timer_Stack
      46  osDelay
      68  osDelayUntil
      84  osEventFlagsClear
      58  osEventFlagsDelete
      44  osEventFlagsGet
      62  osEventFlagsNew
      86  osEventFlagsSet
     110  osEventFlagsWait
      40  osKernelGetInfo
      32  osKernelGetState
      62  osKernelGetSysTimerCount
       8  osKernelGetSysTimerFreq
      40  osKernelGetTickCount
       6  osKernelGetTickFreq
      48  osKernelInitialize
      56  osKernelLock
      84  osKernelRestoreLock
      62  osKernelStart
      78  osKernelUnlock
     152  osMemoryPoolAlloc
     104  osMemoryPoolDelete
     160  osMemoryPoolFree
      20  osMemoryPoolGetBlockSize
      20  osMemoryPoolGetCapacity
      68  osMemoryPoolGetCount
      40  osMemoryPoolGetName
      58  osMemoryPoolGetSpace
     244  osMemoryPoolNew
      56  osMessageQueueDelete
      98  osMessageQueueGet
       6  osMessageQueueGetCapacity
      44  osMessageQueueGetCount
       6  osMessageQueueGetMsgSize
      64  osMessageQueueGetSpace
     118  osMessageQueueNew
     102  osMessageQueuePut
      60  osMessageQueueReset
      96  osMutexAcquire
      60  osMutexDelete
      46  osMutexGetOwner
     118  osMutexNew
      78  osMutexRelease
      94  osSemaphoreAcquire
      56  osSemaphoreDelete
      44  osSemaphoreGetCount
     164  osSemaphoreNew
      78  osSemaphoreRelease
     120  osThreadEnumerate
       8  osThreadExit
     104  osThreadFlagsClear
      70  osThreadFlagsGet
     146  osThreadFlagsSet
     168  osThreadFlagsWait
      40  osThreadGetCount
       4  osThreadGetId
      42  osThreadGetName
      40  osThreadGetPriority
      42  osThreadGetStackSpace
      66  osThreadGetState
     172  osThreadNew
      58  osThreadResume
      58  osThreadSetPriority
      58  osThreadSuspend
      70  osThreadTerminate
      44  osThreadYield
      82  osTimerDelete
      40  osTimerGetName
      40  osTimerIsRunning
     136  osTimerNew
      58  osTimerStart
      70  osTimerStop
      20  vApplicationGetIdleTaskMemory
      20  vApplicationGetTimerTaskMemory
      16  vApplicationStackOverflowHook

 
 1'476 bytes in section .bss
   124 bytes in section .rodata
 5'418 bytes in section .text
 
 5'362 bytes of CODE  memory (+ 56 bytes shared)
   124 bytes of CONST memory
 1'476 bytes of DATA  memory

Errors: none
Warnings: none
