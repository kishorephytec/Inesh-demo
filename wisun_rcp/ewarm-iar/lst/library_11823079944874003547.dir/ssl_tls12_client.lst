###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:46
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls12_client.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls12_client.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls12_client.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls12_client.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ssl_tls12_client.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls12_client.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls12_client.c
      1          /*
      2           *  TLS client-side functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \        0x8   0x7841             LDRB     R1,[R0, #+1]
   \        0xA   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \        0xE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \        0x6   0x7002             STRB     R2,[R0, #+0]
   \        0x8   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \        0xC   0x7042             STRB     R2,[R0, #+1]
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     21          
     22          #if defined(MBEDTLS_SSL_CLI_C) && defined(MBEDTLS_SSL_PROTO_TLS1_2)
     23          
     24          #include "mbedtls/platform.h"
     25          
     26          #include "mbedtls/ssl.h"

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
     27          #include "ssl_client.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_chk_buf_ptr(uint8_t const *, uint8_t const *, size_t)
   \                     mbedtls_ssl_chk_buf_ptr: (+1)
   \        0x0   0x4281             CMP      R1,R0
   \        0x2   0xD304             BCC.N    ??mbedtls_ssl_chk_buf_ptr_0
   \        0x4   0x1A08             SUBS     R0,R1,R0
   \        0x6   0x4290             CMP      R0,R2
   \        0x8   0x4180             SBCS     R0,R0,R0
   \        0xA   0x0FC0             LSRS     R0,R0,#+31
   \        0xC   0x4770             BX       LR
   \                     ??mbedtls_ssl_chk_buf_ptr_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_write_handshake_msg(mbedtls_ssl_context *)
   \                     mbedtls_ssl_write_handshake_msg: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x.... 0x....      B.W      mbedtls_ssl_write_handshake_msg_ext

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_pk_context *mbedtls_ssl_own_key(mbedtls_ssl_context *)
   \                     mbedtls_ssl_own_key: (+1)
   \        0x0   0x6B81             LDR      R1,[R0, #+56]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF1C             ITT      NE
   \        0x6   0xF8D1 0x10A4      LDRNE    R1,[R1, #+164]
   \        0xA   0x2900             CMPNE    R1,#+0
   \        0xC   0xD001             BEQ.N    ??mbedtls_ssl_own_key_0
   \                     ??mbedtls_ssl_own_key_1: (+1)
   \        0xE   0x6848             LDR      R0,[R1, #+4]
   \       0x10   0x4770             BX       LR
   \                     ??mbedtls_ssl_own_key_0: (+1)
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x6B81             LDR      R1,[R0, #+56]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD1F9             BNE.N    ??mbedtls_ssl_own_key_1
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4770             BX       LR

      return 0;
      ^
"C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_misc.h",2433  Warning[Pe111]: 
          statement is unreachable
     28          #include "ssl_misc.h"
     29          #include "mbedtls/debug.h"
     30          #include "mbedtls/error.h"
     31          #include "mbedtls/constant_time.h"
     32          
     33          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     34          #include "psa_util_internal.h"
     35          #include "psa/crypto.h"
     36          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
     37          /* Define a local translating function to save code size by not using too many
     38           * arguments in each translating place. */
     39          static int local_err_translation(psa_status_t status)
     40          {
     41              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     42                                           ARRAY_LENGTH(psa_to_ssl_errors),
     43                                           psa_generic_status_to_mbedtls);
     44          }
     45          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     46          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
     47          #endif /* MBEDTLS_USE_PSA_CRYPTO */
     48          
     49          #include <string.h>
     50          
     51          #include <stdint.h>
     52          
     53          #if defined(MBEDTLS_HAVE_TIME)
     54          #include "mbedtls/platform_time.h"
     55          #endif
     56          
     57          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
     58          #include "mbedtls/platform_util.h"
     59          #endif
     60          
     61          #if defined(MBEDTLS_SSL_RENEGOTIATION)
     62          MBEDTLS_CHECK_RETURN_CRITICAL
     63          static int ssl_write_renegotiation_ext(mbedtls_ssl_context *ssl,
     64                                                 unsigned char *buf,
     65                                                 const unsigned char *end,
     66                                                 size_t *olen)
     67          {
     68              unsigned char *p = buf;
     69          
     70              *olen = 0;
     71          
     72              /* We're always including a TLS_EMPTY_RENEGOTIATION_INFO_SCSV in the
     73               * initial ClientHello, in which case also adding the renegotiation
     74               * info extension is NOT RECOMMENDED as per RFC 5746 Section 3.4. */
     75              if (ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
     76                  return 0;
     77              }
     78          
     79              MBEDTLS_SSL_DEBUG_MSG(3,
     80                                    ("client hello, adding renegotiation extension"));
     81          
     82              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 5 + ssl->verify_data_len);
     83          
     84              /*
     85               * Secure renegotiation
     86               */
     87              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_RENEGOTIATION_INFO, p, 0);
     88              p += 2;
     89          
     90              *p++ = 0x00;
     91              *p++ = MBEDTLS_BYTE_0(ssl->verify_data_len + 1);
     92              *p++ = MBEDTLS_BYTE_0(ssl->verify_data_len);
     93          
     94              memcpy(p, ssl->own_verify_data, ssl->verify_data_len);
     95          
     96              *olen = 5 + ssl->verify_data_len;
     97          
     98              return 0;
     99          }
    100          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    101          
    102          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    103              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    104              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    105          
    106          MBEDTLS_CHECK_RETURN_CRITICAL
    107          static int ssl_write_supported_point_formats_ext(mbedtls_ssl_context *ssl,
    108                                                           unsigned char *buf,
    109                                                           const unsigned char *end,
    110                                                           size_t *olen)
    111          {
    112              unsigned char *p = buf;
    113              (void) ssl; /* ssl used for debugging only */
    114          
    115              *olen = 0;
    116          
    117              MBEDTLS_SSL_DEBUG_MSG(3,
    118                                    ("client hello, adding supported_point_formats extension"));
    119              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 6);
    120          
    121              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS, p, 0);
    122              p += 2;
    123          
    124              *p++ = 0x00;
    125              *p++ = 2;
    126          
    127              *p++ = 1;
    128              *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
    129          
    130              *olen = 6;
    131          
    132              return 0;
    133          }
    134          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
    135                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
    136                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    137          
    138          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    139          MBEDTLS_CHECK_RETURN_CRITICAL
    140          static int ssl_write_ecjpake_kkpp_ext(mbedtls_ssl_context *ssl,
    141                                                unsigned char *buf,
    142                                                const unsigned char *end,
    143                                                size_t *olen)
    144          {
    145              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    146              unsigned char *p = buf;
    147              size_t kkpp_len = 0;
    148          
    149              *olen = 0;
    150          
    151              /* Skip costly extension if we can't use EC J-PAKE anyway */
    152          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    153              if (ssl->handshake->psa_pake_ctx_is_ok != 1) {
    154                  return 0;
    155              }
    156          #else
    157              if (mbedtls_ecjpake_check(&ssl->handshake->ecjpake_ctx) != 0) {
    158                  return 0;
    159              }
    160          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    161          
    162              MBEDTLS_SSL_DEBUG_MSG(3,
    163                                    ("client hello, adding ecjpake_kkpp extension"));
    164          
    165              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4);
    166          
    167              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ECJPAKE_KKPP, p, 0);
    168              p += 2;
    169          
    170              /*
    171               * We may need to send ClientHello multiple times for Hello verification.
    172               * We don't want to compute fresh values every time (both for performance
    173               * and consistency reasons), so cache the extension content.
    174               */
    175              if (ssl->handshake->ecjpake_cache == NULL ||
    176                  ssl->handshake->ecjpake_cache_len == 0) {
    177                  MBEDTLS_SSL_DEBUG_MSG(3, ("generating new ecjpake parameters"));
    178          
    179          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    180                  ret = mbedtls_psa_ecjpake_write_round(&ssl->handshake->psa_pake_ctx,
    181                                                        p + 2, end - p - 2, &kkpp_len,
    182                                                        MBEDTLS_ECJPAKE_ROUND_ONE);
    183                  if (ret != 0) {
    184                      psa_destroy_key(ssl->handshake->psa_pake_password);
    185                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
    186                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_output", ret);
    187                      return ret;
    188                  }
    189          #else
    190                  ret = mbedtls_ecjpake_write_round_one(&ssl->handshake->ecjpake_ctx,
    191                                                        p + 2, end - p - 2, &kkpp_len,
    192                                                        ssl->conf->f_rng, ssl->conf->p_rng);
    193                  if (ret != 0) {
    194                      MBEDTLS_SSL_DEBUG_RET(1,
    195                                            "mbedtls_ecjpake_write_round_one", ret);
    196                      return ret;
    197                  }
    198          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    199          
    200                  ssl->handshake->ecjpake_cache = mbedtls_calloc(1, kkpp_len);
    201                  if (ssl->handshake->ecjpake_cache == NULL) {
    202                      MBEDTLS_SSL_DEBUG_MSG(1, ("allocation failed"));
    203                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
    204                  }
    205          
    206                  memcpy(ssl->handshake->ecjpake_cache, p + 2, kkpp_len);
    207                  ssl->handshake->ecjpake_cache_len = kkpp_len;
    208              } else {
    209                  MBEDTLS_SSL_DEBUG_MSG(3, ("re-using cached ecjpake parameters"));
    210          
    211                  kkpp_len = ssl->handshake->ecjpake_cache_len;
    212                  MBEDTLS_SSL_CHK_BUF_PTR(p + 2, end, kkpp_len);
    213          
    214                  memcpy(p + 2, ssl->handshake->ecjpake_cache, kkpp_len);
    215              }
    216          
    217              MBEDTLS_PUT_UINT16_BE(kkpp_len, p, 0);
    218              p += 2;
    219          
    220              *olen = kkpp_len + 4;
    221          
    222              return 0;
    223          }
    224          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    225          
    226          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    227          MBEDTLS_CHECK_RETURN_CRITICAL
    228          static int ssl_write_cid_ext(mbedtls_ssl_context *ssl,
    229                                       unsigned char *buf,
    230                                       const unsigned char *end,
    231                                       size_t *olen)
    232          {
    233              unsigned char *p = buf;
    234              size_t ext_len;
    235          
    236              /*
    237               *   struct {
    238               *      opaque cid<0..2^8-1>;
    239               *   } ConnectionId;
    240               */
    241          
    242              *olen = 0;
    243              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM ||
    244                  ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED) {
    245                  return 0;
    246              }
    247              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, adding CID extension"));
    248          
    249              /* ssl->own_cid_len is at most MBEDTLS_SSL_CID_IN_LEN_MAX
    250               * which is at most 255, so the increment cannot overflow. */
    251              MBEDTLS_SSL_CHK_BUF_PTR(p, end, (unsigned) (ssl->own_cid_len + 5));
    252          
    253              /* Add extension ID + size */
    254              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_CID, p, 0);
    255              p += 2;
    256              ext_len = (size_t) ssl->own_cid_len + 1;
    257              MBEDTLS_PUT_UINT16_BE(ext_len, p, 0);
    258              p += 2;
    259          
    260              *p++ = (uint8_t) ssl->own_cid_len;
    261              memcpy(p, ssl->own_cid, ssl->own_cid_len);
    262          
    263              *olen = ssl->own_cid_len + 5;
    264          
    265              return 0;
    266          }
    267          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    268          
    269          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    270          MBEDTLS_CHECK_RETURN_CRITICAL
    271          static int ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl,
    272                                                       unsigned char *buf,
    273                                                       const unsigned char *end,
    274                                                       size_t *olen)
    275          {
    276              unsigned char *p = buf;
    277          
    278              *olen = 0;
    279          
    280              if (ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE) {
    281                  return 0;
    282              }
    283          
    284              MBEDTLS_SSL_DEBUG_MSG(3,
    285                                    ("client hello, adding max_fragment_length extension"));
    286          
    287              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 5);
    288          
    289              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH, p, 0);
    290              p += 2;
    291          
    292              *p++ = 0x00;
    293              *p++ = 1;
    294          
    295              *p++ = ssl->conf->mfl_code;
    296          
    297              *olen = 5;
    298          
    299              return 0;
    300          }
    301          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    302          
    303          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    304          MBEDTLS_CHECK_RETURN_CRITICAL
    305          static int ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
    306                                                    unsigned char *buf,
    307                                                    const unsigned char *end,
    308                                                    size_t *olen)
    309          {
    310              unsigned char *p = buf;
    311          
    312              *olen = 0;
    313          
    314              if (ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED) {
    315                  return 0;
    316              }
    317          
    318              MBEDTLS_SSL_DEBUG_MSG(3,
    319                                    ("client hello, adding encrypt_then_mac extension"));
    320          
    321              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4);
    322          
    323              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC, p, 0);
    324              p += 2;
    325          
    326              *p++ = 0x00;
    327              *p++ = 0x00;
    328          
    329              *olen = 4;
    330          
    331              return 0;
    332          }
    333          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    334          
    335          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    336          MBEDTLS_CHECK_RETURN_CRITICAL
    337          static int ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl,
    338                                               unsigned char *buf,
    339                                               const unsigned char *end,
    340                                               size_t *olen)
    341          {
    342              unsigned char *p = buf;
    343          
    344              *olen = 0;
    345          
    346              if (ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED) {
    347                  return 0;
    348              }
    349          
    350              MBEDTLS_SSL_DEBUG_MSG(3,
    351                                    ("client hello, adding extended_master_secret extension"));
    352          
    353              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4);
    354          
    355              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET, p, 0);
    356              p += 2;
    357          
    358              *p++ = 0x00;
    359              *p++ = 0x00;
    360          
    361              *olen = 4;
    362          
    363              return 0;
    364          }
    365          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    366          
    367          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    368          MBEDTLS_CHECK_RETURN_CRITICAL
    369          static int ssl_write_session_ticket_ext(mbedtls_ssl_context *ssl,
    370                                                  unsigned char *buf,
    371                                                  const unsigned char *end,
    372                                                  size_t *olen)
    373          {
    374              unsigned char *p = buf;
    375              size_t tlen = ssl->session_negotiate->ticket_len;
    376          
    377              *olen = 0;
    378          
    379              if (ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED) {
    380                  return 0;
    381              }
    382          
    383              MBEDTLS_SSL_DEBUG_MSG(3,
    384                                    ("client hello, adding session ticket extension"));
    385          
    386              /* The addition is safe here since the ticket length is 16 bit. */
    387              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 4 + tlen);
    388          
    389              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0);
    390              p += 2;
    391          
    392              MBEDTLS_PUT_UINT16_BE(tlen, p, 0);
    393              p += 2;
    394          
    395              *olen = 4;
    396          
    397              if (ssl->session_negotiate->ticket == NULL || tlen == 0) {
    398                  return 0;
    399              }
    400          
    401              MBEDTLS_SSL_DEBUG_MSG(3,
    402                                    ("sending session ticket of length %" MBEDTLS_PRINTF_SIZET, tlen));
    403          
    404              memcpy(p, ssl->session_negotiate->ticket, tlen);
    405          
    406              *olen += tlen;
    407          
    408              return 0;
    409          }
    410          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    411          
    412          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    413          MBEDTLS_CHECK_RETURN_CRITICAL
    414          static int ssl_write_use_srtp_ext(mbedtls_ssl_context *ssl,
    415                                            unsigned char *buf,
    416                                            const unsigned char *end,
    417                                            size_t *olen)
    418          {
    419              unsigned char *p = buf;
    420              size_t protection_profiles_index = 0, ext_len = 0;
    421              uint16_t mki_len = 0, profile_value = 0;
    422          
    423              *olen = 0;
    424          
    425              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
    426                  (ssl->conf->dtls_srtp_profile_list == NULL) ||
    427                  (ssl->conf->dtls_srtp_profile_list_len == 0)) {
    428                  return 0;
    429              }
    430          
    431              /* RFC 5764 section 4.1.1
    432               * uint8 SRTPProtectionProfile[2];
    433               *
    434               * struct {
    435               *   SRTPProtectionProfiles SRTPProtectionProfiles;
    436               *   opaque srtp_mki<0..255>;
    437               * } UseSRTPData;
    438               * SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;
    439               */
    440              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED) {
    441                  mki_len = ssl->dtls_srtp_info.mki_len;
    442              }
    443              /* Extension length = 2 bytes for profiles length,
    444               *                    ssl->conf->dtls_srtp_profile_list_len * 2 (each profile is 2 bytes length ),
    445               *                    1 byte for srtp_mki vector length and the mki_len value
    446               */
    447              ext_len = 2 + 2 * (ssl->conf->dtls_srtp_profile_list_len) + 1 + mki_len;
    448          
    449              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, adding use_srtp extension"));
    450          
    451              /* Check there is room in the buffer for the extension + 4 bytes
    452               * - the extension tag (2 bytes)
    453               * - the extension length (2 bytes)
    454               */
    455              MBEDTLS_SSL_CHK_BUF_PTR(p, end, ext_len + 4);
    456          
    457              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_USE_SRTP, p, 0);
    458              p += 2;
    459          
    460              MBEDTLS_PUT_UINT16_BE(ext_len, p, 0);
    461              p += 2;
    462          
    463              /* protection profile length: 2*(ssl->conf->dtls_srtp_profile_list_len) */
    464              /* micro-optimization:
    465               * the list size is limited to MBEDTLS_TLS_SRTP_MAX_PROFILE_LIST_LENGTH
    466               * which is lower than 127, so the upper byte of the length is always 0
    467               * For the documentation, the more generic code is left in comments
    468               * *p++ = (unsigned char)( ( ( 2 * ssl->conf->dtls_srtp_profile_list_len )
    469               *                        >> 8 ) & 0xFF );
    470               */
    471              *p++ = 0;
    472              *p++ = MBEDTLS_BYTE_0(2 * ssl->conf->dtls_srtp_profile_list_len);
    473          
    474              for (protection_profiles_index = 0;
    475                   protection_profiles_index < ssl->conf->dtls_srtp_profile_list_len;
    476                   protection_profiles_index++) {
    477                  profile_value = mbedtls_ssl_check_srtp_profile_value
    478                                      (ssl->conf->dtls_srtp_profile_list[protection_profiles_index]);
    479                  if (profile_value != MBEDTLS_TLS_SRTP_UNSET) {
    480                      MBEDTLS_SSL_DEBUG_MSG(3, ("ssl_write_use_srtp_ext, add profile: %04x",
    481                                                profile_value));
    482                      MBEDTLS_PUT_UINT16_BE(profile_value, p, 0);
    483                      p += 2;
    484                  } else {
    485                      /*
    486                       * Note: we shall never arrive here as protection profiles
    487                       * is checked by mbedtls_ssl_conf_dtls_srtp_protection_profiles function
    488                       */
    489                      MBEDTLS_SSL_DEBUG_MSG(3,
    490                                            ("client hello, "
    491                                             "illegal DTLS-SRTP protection profile %d",
    492                                             ssl->conf->dtls_srtp_profile_list[protection_profiles_index]
    493                                            ));
    494                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    495                  }
    496              }
    497          
    498              *p++ = mki_len & 0xFF;
    499          
    500              if (mki_len != 0) {
    501                  memcpy(p, ssl->dtls_srtp_info.mki_value, mki_len);
    502                  /*
    503                   * Increment p to point to the current position.
    504                   */
    505                  p += mki_len;
    506                  MBEDTLS_SSL_DEBUG_BUF(3, "sending mki",  ssl->dtls_srtp_info.mki_value,
    507                                        ssl->dtls_srtp_info.mki_len);
    508              }
    509          
    510              /*
    511               * total extension length: extension type (2 bytes)
    512               *                         + extension length (2 bytes)
    513               *                         + protection profile length (2 bytes)
    514               *                         + 2 * number of protection profiles
    515               *                         + srtp_mki vector length(1 byte)
    516               *                         + mki value
    517               */
    518              *olen = p - buf;
    519          
    520              return 0;
    521          }
    522          #endif /* MBEDTLS_SSL_DTLS_SRTP */
    523          

   \                                 In section .text, align 2, keep-with-next
    524          int mbedtls_ssl_tls12_write_client_hello_exts(mbedtls_ssl_context *ssl,
    525                                                        unsigned char *buf,
    526                                                        const unsigned char *end,
    527                                                        int uses_ec,
    528                                                        size_t *out_len)
    529          {
   \                     mbedtls_ssl_tls12_write_client_hello_exts: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x9E08             LDR      R6,[SP, #+32]
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x4689             MOV      R9,R1
    530              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    531              unsigned char *p = buf;
    532              size_t ext_len = 0;
    533          
    534              (void) ssl;
    535              (void) end;
    536              (void) uses_ec;
    537              (void) ret;
    538              (void) ext_len;
    539          
    540              *out_len = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4690             MOV      R8,R2
   \        0xE   0x464D             MOV      R5,R9
   \       0x10   0x6030             STR      R0,[R6, #+0]
    541          
    542              /* Note that TLS_EMPTY_RENEGOTIATION_INFO_SCSV is always added
    543               * even if MBEDTLS_SSL_RENEGOTIATION is not defined. */
    544          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    545              if ((ret = ssl_write_renegotiation_ext(ssl, p, end, &ext_len)) != 0) {
    546                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_renegotiation_ext", ret);
    547                  return ret;
    548              }
    549              p += ext_len;
    550          #endif
    551          
    552          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    553              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    554              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    555              if (uses_ec) {
   \       0x12   0x.... 0x....      ADR.W    R7,mbedtls_byte_order_detector
   \       0x16   0xB1BB             CBZ.N    R3,??mbedtls_ssl_tls12_write_client_hello_exts_0
    556                  if ((ret = ssl_write_supported_point_formats_ext(ssl, p, end,
    557                                                                   &ext_len)) != 0) {
   \       0x18   0x2206             MOVS     R2,#+6
   \       0x1A   0x4641             MOV      R1,R8
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x22   0xB9D8             CBNZ.N   R0,??mbedtls_ssl_tls12_write_client_hello_exts_1
   \       0x24   0x7838             LDRB     R0,[R7, #+0]
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xBF0C             ITE      EQ
   \       0x2A   0x210B             MOVEQ    R1,#+11
   \       0x2C   0xF44F 0x6130      MOVNE    R1,#+2816
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x70A9             STRB     R1,[R5, #+2]
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0x70E8             STRB     R0,[R5, #+3]
   \       0x3E   0x2101             MOVS     R1,#+1
   \       0x40   0x7129             STRB     R1,[R5, #+4]
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x7168             STRB     R0,[R5, #+5]
    558                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_supported_point_formats_ext", ret);
    559                      return ret;
    560                  }
    561                  p += ext_len;
   \       0x46   0x1DAD             ADDS     R5,R5,#+6
    562              }
    563          #endif
    564          
    565          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    566              if ((ret = ssl_write_ecjpake_kkpp_ext(ssl, p, end, &ext_len)) != 0) {
    567                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_ecjpake_kkpp_ext", ret);
    568                  return ret;
    569              }
    570              p += ext_len;
    571          #endif
    572          
    573          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    574              if ((ret = ssl_write_cid_ext(ssl, p, end, &ext_len)) != 0) {
    575                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_cid_ext", ret);
    576                  return ret;
    577              }
    578              p += ext_len;
    579          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    580          
    581          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    582              if ((ret = ssl_write_max_fragment_length_ext(ssl, p, end,
    583                                                           &ext_len)) != 0) {
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_0: (+1)
   \       0x48   0x6822             LDR      R2,[R4, #+0]
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x7A10             LDRB     R0,[R2, #+8]
   \       0x4E   0xB1C8             CBZ.N    R0,??mbedtls_ssl_tls12_write_client_hello_exts_2
   \       0x50   0x2205             MOVS     R2,#+5
   \       0x52   0x4641             MOV      R1,R8
   \       0x54   0x4628             MOV      R0,R5
   \       0x56   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x5A   0xB110             CBZ.N    R0,??mbedtls_ssl_tls12_write_client_hello_exts_3
    584                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_max_fragment_length_ext", ret);
    585                  return ret;
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_1: (+1)
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable3
   \       0x60   0xE015             B.N      ??mbedtls_ssl_tls12_write_client_hello_exts_4
    586              }
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_3: (+1)
   \       0x62   0x7838             LDRB     R0,[R7, #+0]
   \       0x64   0x2801             CMP      R0,#+1
   \       0x66   0xBF0C             ITE      EQ
   \       0x68   0x2101             MOVEQ    R1,#+1
   \       0x6A   0xF44F 0x7180      MOVNE    R1,#+256
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x74   0x2100             MOVS     R1,#+0
   \       0x76   0x70A9             STRB     R1,[R5, #+2]
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0x70E8             STRB     R0,[R5, #+3]
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x7A08             LDRB     R0,[R1, #+8]
   \       0x80   0x2105             MOVS     R1,#+5
   \       0x82   0x7128             STRB     R0,[R5, #+4]
    587              p += ext_len;
    588          #endif
    589          
    590          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    591              if ((ret = ssl_write_encrypt_then_mac_ext(ssl, p, end, &ext_len)) != 0) {
    592                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_encrypt_then_mac_ext", ret);
    593                  return ret;
    594              }
    595              p += ext_len;
    596          #endif
    597          
    598          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    599              if ((ret = ssl_write_extended_ms_ext(ssl, p, end, &ext_len)) != 0) {
    600                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_extended_ms_ext", ret);
    601                  return ret;
    602              }
    603              p += ext_len;
    604          #endif
    605          
    606          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    607              if ((ret = ssl_write_use_srtp_ext(ssl, p, end, &ext_len)) != 0) {
    608                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_use_srtp_ext", ret);
    609                  return ret;
    610              }
    611              p += ext_len;
    612          #endif
    613          
    614          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    615              if ((ret = ssl_write_session_ticket_ext(ssl, p, end, &ext_len)) != 0) {
    616                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_write_session_ticket_ext", ret);
    617                  return ret;
    618              }
    619              p += ext_len;
    620          #endif
    621          
    622              *out_len = p - buf;
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_2: (+1)
   \       0x84   0x1868             ADDS     R0,R5,R1
   \       0x86   0xEBA0 0x0009      SUB      R0,R0,R9
   \       0x8A   0x6030             STR      R0,[R6, #+0]
    623          
    624              return 0;
   \       0x8C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_tls12_write_client_hello_exts_4: (+1)
   \       0x8E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    625          }
    626          
    627          MBEDTLS_CHECK_RETURN_CRITICAL
    628          static int ssl_parse_renegotiation_info(mbedtls_ssl_context *ssl,
    629                                                  const unsigned char *buf,
    630                                                  size_t len)
    631          {
    632          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    633              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
    634                  /* Check verify-data in constant-time. The length OTOH is no secret */
    635                  if (len    != 1 + ssl->verify_data_len * 2 ||
    636                      buf[0] !=     ssl->verify_data_len * 2 ||
    637                      mbedtls_ct_memcmp(buf + 1,
    638                                        ssl->own_verify_data, ssl->verify_data_len) != 0 ||
    639                      mbedtls_ct_memcmp(buf + 1 + ssl->verify_data_len,
    640                                        ssl->peer_verify_data, ssl->verify_data_len) != 0) {
    641                      MBEDTLS_SSL_DEBUG_MSG(1, ("non-matching renegotiation info"));
    642                      mbedtls_ssl_send_alert_message(
    643                          ssl,
    644                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    645                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    646                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    647                  }
    648              } else
    649          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    650              {
    651                  if (len != 1 || buf[0] != 0x00) {
    652                      MBEDTLS_SSL_DEBUG_MSG(1,
    653                                            ("non-zero length renegotiation info"));
    654                      mbedtls_ssl_send_alert_message(
    655                          ssl,
    656                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    657                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    658                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    659                  }
    660          
    661                  ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
    662              }
    663          
    664              return 0;
    665          }
    666          
    667          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    668          MBEDTLS_CHECK_RETURN_CRITICAL
    669          static int ssl_parse_max_fragment_length_ext(mbedtls_ssl_context *ssl,
    670                                                       const unsigned char *buf,
    671                                                       size_t len)
    672          {
    673              /*
    674               * server should use the extension only if we did,
    675               * and if so the server's value should match ours (and len is always 1)
    676               */
    677              if (ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ||
    678                  len != 1 ||
    679                  buf[0] != ssl->conf->mfl_code) {
    680                  MBEDTLS_SSL_DEBUG_MSG(1,
    681                                        ("non-matching max fragment length extension"));
    682                  mbedtls_ssl_send_alert_message(
    683                      ssl,
    684                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    685                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    686                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    687              }
    688          
    689              return 0;
    690          }
    691          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    692          
    693          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    694          MBEDTLS_CHECK_RETURN_CRITICAL
    695          static int ssl_parse_cid_ext(mbedtls_ssl_context *ssl,
    696                                       const unsigned char *buf,
    697                                       size_t len)
    698          {
    699              size_t peer_cid_len;
    700          
    701              if ( /* CID extension only makes sense in DTLS */
    702                  ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM ||
    703                  /* The server must only send the CID extension if we have offered it. */
    704                  ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED) {
    705                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension unexpected"));
    706                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    707                                                 MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    708                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    709              }
    710          
    711              if (len == 0) {
    712                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension invalid"));
    713                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    714                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    715                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    716              }
    717          
    718              peer_cid_len = *buf++;
    719              len--;
    720          
    721              if (peer_cid_len > MBEDTLS_SSL_CID_OUT_LEN_MAX) {
    722                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension invalid"));
    723                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    724                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    725                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    726              }
    727          
    728              if (len != peer_cid_len) {
    729                  MBEDTLS_SSL_DEBUG_MSG(1, ("CID extension invalid"));
    730                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    731                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    732                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    733              }
    734          
    735              ssl->handshake->cid_in_use = MBEDTLS_SSL_CID_ENABLED;
    736              ssl->handshake->peer_cid_len = (uint8_t) peer_cid_len;
    737              memcpy(ssl->handshake->peer_cid, buf, peer_cid_len);
    738          
    739              MBEDTLS_SSL_DEBUG_MSG(3, ("Use of CID extension negotiated"));
    740              MBEDTLS_SSL_DEBUG_BUF(3, "Server CID", buf, peer_cid_len);
    741          
    742              return 0;
    743          }
    744          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    745          
    746          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    747          MBEDTLS_CHECK_RETURN_CRITICAL
    748          static int ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
    749                                                    const unsigned char *buf,
    750                                                    size_t len)
    751          {
    752              if (ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||
    753                  len != 0) {
    754                  MBEDTLS_SSL_DEBUG_MSG(1,
    755                                        ("non-matching encrypt-then-MAC extension"));
    756                  mbedtls_ssl_send_alert_message(
    757                      ssl,
    758                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    759                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    760                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    761              }
    762          
    763              ((void) buf);
    764          
    765              ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
    766          
    767              return 0;
    768          }
    769          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    770          
    771          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    772          MBEDTLS_CHECK_RETURN_CRITICAL
    773          static int ssl_parse_extended_ms_ext(mbedtls_ssl_context *ssl,
    774                                               const unsigned char *buf,
    775                                               size_t len)
    776          {
    777              if (ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
    778                  len != 0) {
    779                  MBEDTLS_SSL_DEBUG_MSG(1,
    780                                        ("non-matching extended master secret extension"));
    781                  mbedtls_ssl_send_alert_message(
    782                      ssl,
    783                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    784                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    785                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    786              }
    787          
    788              ((void) buf);
    789          
    790              ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
    791          
    792              return 0;
    793          }
    794          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    795          
    796          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    797          MBEDTLS_CHECK_RETURN_CRITICAL
    798          static int ssl_parse_session_ticket_ext(mbedtls_ssl_context *ssl,
    799                                                  const unsigned char *buf,
    800                                                  size_t len)
    801          {
    802              if (ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED ||
    803                  len != 0) {
    804                  MBEDTLS_SSL_DEBUG_MSG(1,
    805                                        ("non-matching session ticket extension"));
    806                  mbedtls_ssl_send_alert_message(
    807                      ssl,
    808                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    809                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    810                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    811              }
    812          
    813              ((void) buf);
    814          
    815              ssl->handshake->new_session_ticket = 1;
    816          
    817              return 0;
    818          }
    819          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    820          
    821          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    822              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    823              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    824          MBEDTLS_CHECK_RETURN_CRITICAL
    825          static int ssl_parse_supported_point_formats_ext(mbedtls_ssl_context *ssl,
    826                                                           const unsigned char *buf,
    827                                                           size_t len)
    828          {
    829              size_t list_size;
    830              const unsigned char *p;
    831          
    832              if (len == 0 || (size_t) (buf[0] + 1) != len) {
    833                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
    834                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    835                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    836                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    837              }
    838              list_size = buf[0];
    839          
    840              p = buf + 1;
    841              while (list_size > 0) {
    842                  if (p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
    843                      p[0] == MBEDTLS_ECP_PF_COMPRESSED) {
    844          #if !defined(MBEDTLS_USE_PSA_CRYPTO) && \
    845                      defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED)
    846                      ssl->handshake->ecdh_ctx.point_format = p[0];
    847          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED */
    848          #if !defined(MBEDTLS_USE_PSA_CRYPTO) &&                             \
    849                      defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    850                      mbedtls_ecjpake_set_point_format(&ssl->handshake->ecjpake_ctx,
    851                                                       p[0]);
    852          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    853                      MBEDTLS_SSL_DEBUG_MSG(4, ("point format selected: %d", p[0]));
    854                      return 0;
    855                  }
    856          
    857                  list_size--;
    858                  p++;
    859              }
    860          
    861              MBEDTLS_SSL_DEBUG_MSG(1, ("no point format in common"));
    862              mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    863                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    864              return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    865          }
    866          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
    867                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
    868                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    869          
    870          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    871          MBEDTLS_CHECK_RETURN_CRITICAL
    872          static int ssl_parse_ecjpake_kkpp(mbedtls_ssl_context *ssl,
    873                                            const unsigned char *buf,
    874                                            size_t len)
    875          {
    876              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    877          
    878              if (ssl->handshake->ciphersuite_info->key_exchange !=
    879                  MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
    880                  MBEDTLS_SSL_DEBUG_MSG(3, ("skip ecjpake kkpp extension"));
    881                  return 0;
    882              }
    883          
    884              /* If we got here, we no longer need our cached extension */
    885              mbedtls_free(ssl->handshake->ecjpake_cache);
    886              ssl->handshake->ecjpake_cache = NULL;
    887              ssl->handshake->ecjpake_cache_len = 0;
    888          
    889          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    890              if ((ret = mbedtls_psa_ecjpake_read_round(
    891                       &ssl->handshake->psa_pake_ctx, buf, len,
    892                       MBEDTLS_ECJPAKE_ROUND_ONE)) != 0) {
    893                  psa_destroy_key(ssl->handshake->psa_pake_password);
    894                  psa_pake_abort(&ssl->handshake->psa_pake_ctx);
    895          
    896                  MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_input round one", ret);
    897                  mbedtls_ssl_send_alert_message(
    898                      ssl,
    899                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    900                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    901                  return ret;
    902              }
    903          
    904              return 0;
    905          #else
    906              if ((ret = mbedtls_ecjpake_read_round_one(&ssl->handshake->ecjpake_ctx,
    907                                                        buf, len)) != 0) {
    908                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_read_round_one", ret);
    909                  mbedtls_ssl_send_alert_message(
    910                      ssl,
    911                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    912                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    913                  return ret;
    914              }
    915          
    916              return 0;
    917          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    918          }
    919          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    920          
    921          #if defined(MBEDTLS_SSL_ALPN)
    922          MBEDTLS_CHECK_RETURN_CRITICAL
    923          static int ssl_parse_alpn_ext(mbedtls_ssl_context *ssl,
    924                                        const unsigned char *buf, size_t len)
    925          {
    926              size_t list_len, name_len;
    927              const char **p;
    928          
    929              /* If we didn't send it, the server shouldn't send it */
    930              if (ssl->conf->alpn_list == NULL) {
    931                  MBEDTLS_SSL_DEBUG_MSG(1, ("non-matching ALPN extension"));
    932                  mbedtls_ssl_send_alert_message(
    933                      ssl,
    934                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    935                      MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT);
    936                  return MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION;
    937              }
    938          
    939              /*
    940               * opaque ProtocolName<1..2^8-1>;
    941               *
    942               * struct {
    943               *     ProtocolName protocol_name_list<2..2^16-1>
    944               * } ProtocolNameList;
    945               *
    946               * the "ProtocolNameList" MUST contain exactly one "ProtocolName"
    947               */
    948          
    949              /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */
    950              if (len < 4) {
    951                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    952                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    953                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    954              }
    955          
    956              list_len = (buf[0] << 8) | buf[1];
    957              if (list_len != len - 2) {
    958                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    959                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    960                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    961              }
    962          
    963              name_len = buf[2];
    964              if (name_len != list_len - 1) {
    965                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    966                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    967                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    968              }
    969          
    970              /* Check that the server chosen protocol was in our list and save it */
    971              for (p = ssl->conf->alpn_list; *p != NULL; p++) {
    972                  if (name_len == strlen(*p) &&
    973                      memcmp(buf + 3, *p, name_len) == 0) {
    974                      ssl->alpn_chosen = *p;
    975                      return 0;
    976                  }
    977              }
    978          
    979              MBEDTLS_SSL_DEBUG_MSG(1, ("ALPN extension: no matching protocol"));
    980              mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    981                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    982              return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    983          }
    984          #endif /* MBEDTLS_SSL_ALPN */
    985          
    986          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    987          MBEDTLS_CHECK_RETURN_CRITICAL
    988          static int ssl_parse_use_srtp_ext(mbedtls_ssl_context *ssl,
    989                                            const unsigned char *buf,
    990                                            size_t len)
    991          {
    992              mbedtls_ssl_srtp_profile server_protection = MBEDTLS_TLS_SRTP_UNSET;
    993              size_t i, mki_len = 0;
    994              uint16_t server_protection_profile_value = 0;
    995          
    996              /* If use_srtp is not configured, just ignore the extension */
    997              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
    998                  (ssl->conf->dtls_srtp_profile_list == NULL) ||
    999                  (ssl->conf->dtls_srtp_profile_list_len == 0)) {
   1000                  return 0;
   1001              }
   1002          
   1003              /* RFC 5764 section 4.1.1
   1004               * uint8 SRTPProtectionProfile[2];
   1005               *
   1006               * struct {
   1007               *   SRTPProtectionProfiles SRTPProtectionProfiles;
   1008               *   opaque srtp_mki<0..255>;
   1009               * } UseSRTPData;
   1010          
   1011               * SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;
   1012               *
   1013               */
   1014              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED) {
   1015                  mki_len = ssl->dtls_srtp_info.mki_len;
   1016              }
   1017          
   1018              /*
   1019               * Length is 5 + optional mki_value : one protection profile length (2 bytes)
   1020               *                                      + protection profile (2 bytes)
   1021               *                                      + mki_len(1 byte)
   1022               *                                      and optional srtp_mki
   1023               */
   1024              if ((len < 5) || (len != (buf[4] + 5u))) {
   1025                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1026              }
   1027          
   1028              /*
   1029               * get the server protection profile
   1030               */
   1031          
   1032              /*
   1033               * protection profile length must be 0x0002 as we must have only
   1034               * one protection profile in server Hello
   1035               */
   1036              if ((buf[0] != 0) || (buf[1] != 2)) {
   1037                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1038              }
   1039          
   1040              server_protection_profile_value = (buf[2] << 8) | buf[3];
   1041              server_protection = mbedtls_ssl_check_srtp_profile_value(
   1042                  server_protection_profile_value);
   1043              if (server_protection != MBEDTLS_TLS_SRTP_UNSET) {
   1044                  MBEDTLS_SSL_DEBUG_MSG(3, ("found srtp profile: %s",
   1045                                            mbedtls_ssl_get_srtp_profile_as_string(
   1046                                                server_protection)));
   1047              }
   1048          
   1049              ssl->dtls_srtp_info.chosen_dtls_srtp_profile = MBEDTLS_TLS_SRTP_UNSET;
   1050          
   1051              /*
   1052               * Check we have the server profile in our list
   1053               */
   1054              for (i = 0; i < ssl->conf->dtls_srtp_profile_list_len; i++) {
   1055                  if (server_protection == ssl->conf->dtls_srtp_profile_list[i]) {
   1056                      ssl->dtls_srtp_info.chosen_dtls_srtp_profile = ssl->conf->dtls_srtp_profile_list[i];
   1057                      MBEDTLS_SSL_DEBUG_MSG(3, ("selected srtp profile: %s",
   1058                                                mbedtls_ssl_get_srtp_profile_as_string(
   1059                                                    server_protection)));
   1060                      break;
   1061                  }
   1062              }
   1063          
   1064              /* If no match was found : server problem, it shall never answer with incompatible profile */
   1065              if (ssl->dtls_srtp_info.chosen_dtls_srtp_profile == MBEDTLS_TLS_SRTP_UNSET) {
   1066                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1067                                                 MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1068                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1069              }
   1070          
   1071              /* If server does not use mki in its reply, make sure the client won't keep
   1072               * one as negotiated */
   1073              if (len == 5) {
   1074                  ssl->dtls_srtp_info.mki_len = 0;
   1075              }
   1076          
   1077              /*
   1078               * RFC5764:
   1079               *  If the client detects a nonzero-length MKI in the server's response
   1080               *  that is different than the one the client offered, then the client
   1081               *  MUST abort the handshake and SHOULD send an invalid_parameter alert.
   1082               */
   1083              if (len > 5  && (buf[4] != mki_len ||
   1084                               (memcmp(ssl->dtls_srtp_info.mki_value, &buf[5], mki_len)))) {
   1085                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1086                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   1087                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   1088              }
   1089          #if defined(MBEDTLS_DEBUG_C)
   1090              if (len > 5) {
   1091                  MBEDTLS_SSL_DEBUG_BUF(3, "received mki", ssl->dtls_srtp_info.mki_value,
   1092                                        ssl->dtls_srtp_info.mki_len);
   1093              }
   1094          #endif
   1095              return 0;
   1096          }
   1097          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   1098          
   1099          /*
   1100           * Parse HelloVerifyRequest.  Only called after verifying the HS type.
   1101           */
   1102          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1103          MBEDTLS_CHECK_RETURN_CRITICAL
   1104          static int ssl_parse_hello_verify_request(mbedtls_ssl_context *ssl)
   1105          {
   1106              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1107              const unsigned char *p = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   1108              uint16_t dtls_legacy_version;
   1109          
   1110          #if !defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1111              uint8_t cookie_len;
   1112          #else
   1113              uint16_t cookie_len;
   1114          #endif
   1115          
   1116              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse hello verify request"));
   1117          
   1118              /* Check that there is enough room for:
   1119               * - 2 bytes of version
   1120               * - 1 byte of cookie_len
   1121               */
   1122              if (mbedtls_ssl_hs_hdr_len(ssl) + 3 > ssl->in_msglen) {
   1123                  MBEDTLS_SSL_DEBUG_MSG(1,
   1124                                        ("incoming HelloVerifyRequest message is too short"));
   1125                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1126                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1127                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1128              }
   1129          
   1130              /*
   1131               * struct {
   1132               *   ProtocolVersion server_version;
   1133               *   opaque cookie<0..2^8-1>;
   1134               * } HelloVerifyRequest;
   1135               */
   1136              MBEDTLS_SSL_DEBUG_BUF(3, "server version", p, 2);
   1137              dtls_legacy_version = MBEDTLS_GET_UINT16_BE(p, 0);
   1138              p += 2;
   1139          
   1140              /*
   1141               * Since the RFC is not clear on this point, accept DTLS 1.0 (0xfeff)
   1142               * The DTLS 1.3 (current draft) renames ProtocolVersion server_version to
   1143               * legacy_version and locks the value of legacy_version to 0xfefd (DTLS 1.2)
   1144               */
   1145              if (dtls_legacy_version != 0xfefd && dtls_legacy_version != 0xfeff) {
   1146                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server version"));
   1147          
   1148                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1149                                                 MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION);
   1150          
   1151                  return MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION;
   1152              }
   1153          
   1154              cookie_len = *p++;
   1155              if ((ssl->in_msg + ssl->in_msglen) - p < cookie_len) {
   1156                  MBEDTLS_SSL_DEBUG_MSG(1,
   1157                                        ("cookie length does not match incoming message size"));
   1158                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1159                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1160                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1161              }
   1162              MBEDTLS_SSL_DEBUG_BUF(3, "cookie", p, cookie_len);
   1163          
   1164              mbedtls_free(ssl->handshake->cookie);
   1165          
   1166              ssl->handshake->cookie = mbedtls_calloc(1, cookie_len);
   1167              if (ssl->handshake->cookie  == NULL) {
   1168                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc failed (%d bytes)", cookie_len));
   1169                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   1170              }
   1171          
   1172              memcpy(ssl->handshake->cookie, p, cookie_len);
   1173              ssl->handshake->cookie_len = cookie_len;
   1174          
   1175              /* Start over at ClientHello */
   1176              ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   1177              ret = mbedtls_ssl_reset_checksum(ssl);
   1178              if (0 != ret) {
   1179                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ssl_reset_checksum"), ret);
   1180                  return ret;
   1181              }
   1182          
   1183              mbedtls_ssl_recv_flight_completed(ssl);
   1184          
   1185              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse hello verify request"));
   1186          
   1187              return 0;
   1188          }
   1189          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1190          
   1191          MBEDTLS_CHECK_RETURN_CRITICAL
   1192          static int ssl_parse_server_hello(mbedtls_ssl_context *ssl)
   1193          {
   1194              int ret, i;
   1195              size_t n;
   1196              size_t ext_len;
   1197              unsigned char *buf, *ext;
   1198              unsigned char comp;
   1199          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1200              int renegotiation_info_seen = 0;
   1201          #endif
   1202              int handshake_failure = 0;
   1203              const mbedtls_ssl_ciphersuite_t *suite_info;
   1204          
   1205              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse server hello"));
   1206          
   1207              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   1208                  /* No alert on a read error. */
   1209                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   1210                  return ret;
   1211              }
   1212          
   1213              buf = ssl->in_msg;
   1214          
   1215              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   1216          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1217                  if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   1218                      ssl->renego_records_seen++;
   1219          
   1220                      if (ssl->conf->renego_max_records >= 0 &&
   1221                          ssl->renego_records_seen > ssl->conf->renego_max_records) {
   1222                          MBEDTLS_SSL_DEBUG_MSG(1,
   1223                                                ("renegotiation requested, but not honored by server"));
   1224                          return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   1225                      }
   1226          
   1227                      MBEDTLS_SSL_DEBUG_MSG(1,
   1228                                            ("non-handshake message during renegotiation"));
   1229          
   1230                      ssl->keep_current_message = 1;
   1231                      return MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO;
   1232                  }
   1233          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1234          
   1235                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1236                  mbedtls_ssl_send_alert_message(
   1237                      ssl,
   1238                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1239                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   1240                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   1241              }
   1242          
   1243          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1244              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1245                  if (buf[0] == MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST) {
   1246                      MBEDTLS_SSL_DEBUG_MSG(2, ("received hello verify request"));
   1247                      MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server hello"));
   1248                      return ssl_parse_hello_verify_request(ssl);
   1249                  } else {
   1250                      /* We made it through the verification process */
   1251                      mbedtls_free(ssl->handshake->cookie);
   1252                      ssl->handshake->cookie = NULL;
   1253                      ssl->handshake->cookie_len = 0;
   1254                  }
   1255              }
   1256          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1257          
   1258              if (ssl->in_hslen < 38 + mbedtls_ssl_hs_hdr_len(ssl) ||
   1259                  buf[0] != MBEDTLS_SSL_HS_SERVER_HELLO) {
   1260                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1261                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1262                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1263                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1264              }
   1265          
   1266              /*
   1267               *  0   .  1    server_version
   1268               *  2   . 33    random (maybe including 4 bytes of Unix time)
   1269               * 34   . 34    session_id length = n
   1270               * 35   . 34+n  session_id
   1271               * 35+n . 36+n  cipher_suite
   1272               * 37+n . 37+n  compression_method
   1273               *
   1274               * 38+n . 39+n  extensions length (optional)
   1275               * 40+n .  ..   extensions
   1276               */
   1277              buf += mbedtls_ssl_hs_hdr_len(ssl);
   1278          
   1279              MBEDTLS_SSL_DEBUG_BUF(3, "server hello, version", buf, 2);
   1280              ssl->tls_version = (mbedtls_ssl_protocol_version) mbedtls_ssl_read_version(buf,
   1281                                                                                         ssl->conf->transport);
   1282              ssl->session_negotiate->tls_version = ssl->tls_version;
   1283          
   1284              if (ssl->tls_version < ssl->conf->min_tls_version ||
   1285                  ssl->tls_version > ssl->conf->max_tls_version) {
   1286                  MBEDTLS_SSL_DEBUG_MSG(1,
   1287                                        (
   1288                                            "server version out of bounds -  min: [0x%x], server: [0x%x], max: [0x%x]",
   1289                                            (unsigned) ssl->conf->min_tls_version,
   1290                                            (unsigned) ssl->tls_version,
   1291                                            (unsigned) ssl->conf->max_tls_version));
   1292          
   1293                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1294                                                 MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION);
   1295          
   1296                  return MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION;
   1297              }
   1298          
   1299              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, current time: %lu",
   1300                                        ((unsigned long) buf[2] << 24) |
   1301                                        ((unsigned long) buf[3] << 16) |
   1302                                        ((unsigned long) buf[4] <<  8) |
   1303                                        ((unsigned long) buf[5])));
   1304          
   1305              memcpy(ssl->handshake->randbytes + 32, buf + 2, 32);
   1306          
   1307              n = buf[34];
   1308          
   1309              MBEDTLS_SSL_DEBUG_BUF(3,   "server hello, random bytes", buf + 2, 32);
   1310          
   1311              if (n > 32) {
   1312                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1313                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1314                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1315                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1316              }
   1317          
   1318              if (ssl->in_hslen > mbedtls_ssl_hs_hdr_len(ssl) + 39 + n) {
   1319                  ext_len = ((buf[38 + n] <<  8)
   1320                             | (buf[39 + n]));
   1321          
   1322                  if ((ext_len > 0 && ext_len < 4) ||
   1323                      ssl->in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 40 + n + ext_len) {
   1324                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1325                      mbedtls_ssl_send_alert_message(
   1326                          ssl,
   1327                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1328                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1329                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1330                  }
   1331              } else if (ssl->in_hslen == mbedtls_ssl_hs_hdr_len(ssl) + 38 + n) {
   1332                  ext_len = 0;
   1333              } else {
   1334                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1335                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1336                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1337                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1338              }
   1339          
   1340              /* ciphersuite (used later) */
   1341              i = (buf[35 + n] << 8) | buf[36 + n];
   1342          
   1343              /*
   1344               * Read and check compression
   1345               */
   1346              comp = buf[37 + n];
   1347          
   1348              if (comp != MBEDTLS_SSL_COMPRESS_NULL) {
   1349                  MBEDTLS_SSL_DEBUG_MSG(1,
   1350                                        ("server hello, bad compression: %d", comp));
   1351                  mbedtls_ssl_send_alert_message(
   1352                      ssl,
   1353                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1354                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   1355                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1356              }
   1357          
   1358              /*
   1359               * Initialize update checksum functions
   1360               */
   1361              ssl->handshake->ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(i);
   1362              if (ssl->handshake->ciphersuite_info == NULL) {
   1363                  MBEDTLS_SSL_DEBUG_MSG(1,
   1364                                        ("ciphersuite info for %04x not found", (unsigned int) i));
   1365                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1366                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   1367                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   1368              }
   1369          
   1370              mbedtls_ssl_optimize_checksum(ssl, ssl->handshake->ciphersuite_info);
   1371          
   1372              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, session id len.: %" MBEDTLS_PRINTF_SIZET, n));
   1373              MBEDTLS_SSL_DEBUG_BUF(3,   "server hello, session id", buf + 35, n);
   1374          
   1375              /*
   1376               * Check if the session can be resumed
   1377               */
   1378              if (ssl->handshake->resume == 0 || n == 0 ||
   1379          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1380                  ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||
   1381          #endif
   1382                  ssl->session_negotiate->ciphersuite != i ||
   1383                  ssl->session_negotiate->id_len != n ||
   1384                  memcmp(ssl->session_negotiate->id, buf + 35, n) != 0) {
   1385                  ssl->state++;
   1386                  ssl->handshake->resume = 0;
   1387          #if defined(MBEDTLS_HAVE_TIME)
   1388                  ssl->session_negotiate->start = mbedtls_time(NULL);
   1389          #endif
   1390                  ssl->session_negotiate->ciphersuite = i;
   1391                  ssl->session_negotiate->id_len = n;
   1392                  memcpy(ssl->session_negotiate->id, buf + 35, n);
   1393              } else {
   1394                  ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   1395              }
   1396          
   1397              MBEDTLS_SSL_DEBUG_MSG(3, ("%s session has been resumed",
   1398                                        ssl->handshake->resume ? "a" : "no"));
   1399          
   1400              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, chosen ciphersuite: %04x", (unsigned) i));
   1401              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, compress alg.: %d",
   1402                                        buf[37 + n]));
   1403          
   1404              /*
   1405               * Perform cipher suite validation in same way as in ssl_write_client_hello.
   1406               */
   1407              i = 0;
   1408              while (1) {
   1409                  if (ssl->conf->ciphersuite_list[i] == 0) {
   1410                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1411                      mbedtls_ssl_send_alert_message(
   1412                          ssl,
   1413                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1414                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   1415                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   1416                  }
   1417          
   1418                  if (ssl->conf->ciphersuite_list[i++] ==
   1419                      ssl->session_negotiate->ciphersuite) {
   1420                      break;
   1421                  }
   1422              }
   1423          
   1424              suite_info = mbedtls_ssl_ciphersuite_from_id(
   1425                  ssl->session_negotiate->ciphersuite);
   1426              if (mbedtls_ssl_validate_ciphersuite(ssl, suite_info, ssl->tls_version,
   1427                                                   ssl->tls_version) != 0) {
   1428                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1429                  mbedtls_ssl_send_alert_message(
   1430                      ssl,
   1431                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1432                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1433                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1434              }
   1435          
   1436              MBEDTLS_SSL_DEBUG_MSG(3,
   1437                                    ("server hello, chosen ciphersuite: %s", suite_info->name));
   1438          
   1439          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   1440              if (suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA &&
   1441                  ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
   1442                  ssl->handshake->ecrs_enabled = 1;
   1443              }
   1444          #endif
   1445          
   1446              if (comp != MBEDTLS_SSL_COMPRESS_NULL) {
   1447                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1448                  mbedtls_ssl_send_alert_message(
   1449                      ssl,
   1450                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1451                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   1452                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   1453              }
   1454          
   1455              ext = buf + 40 + n;
   1456          
   1457              MBEDTLS_SSL_DEBUG_MSG(2,
   1458                                    ("server hello, total extension length: %" MBEDTLS_PRINTF_SIZET,
   1459                                     ext_len));
   1460          
   1461              while (ext_len) {
   1462                  unsigned int ext_id   = ((ext[0] <<  8)
   1463                                           | (ext[1]));
   1464                  unsigned int ext_size = ((ext[2] <<  8)
   1465                                           | (ext[3]));
   1466          
   1467                  if (ext_size + 4 > ext_len) {
   1468                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1469                      mbedtls_ssl_send_alert_message(
   1470                          ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1471                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1472                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1473                  }
   1474          
   1475                  switch (ext_id) {
   1476                      case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
   1477                          MBEDTLS_SSL_DEBUG_MSG(3, ("found renegotiation extension"));
   1478          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1479                          renegotiation_info_seen = 1;
   1480          #endif
   1481          
   1482                          if ((ret = ssl_parse_renegotiation_info(ssl, ext + 4,
   1483                                                                  ext_size)) != 0) {
   1484                              return ret;
   1485                          }
   1486          
   1487                          break;
   1488          
   1489          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   1490                      case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
   1491                          MBEDTLS_SSL_DEBUG_MSG(3,
   1492                                                ("found max_fragment_length extension"));
   1493          
   1494                          if ((ret = ssl_parse_max_fragment_length_ext(ssl,
   1495                                                                       ext + 4, ext_size)) != 0) {
   1496                              return ret;
   1497                          }
   1498          
   1499                          break;
   1500          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   1501          
   1502          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1503                      case MBEDTLS_TLS_EXT_CID:
   1504                          MBEDTLS_SSL_DEBUG_MSG(3, ("found CID extension"));
   1505          
   1506                          if ((ret = ssl_parse_cid_ext(ssl,
   1507                                                       ext + 4,
   1508                                                       ext_size)) != 0) {
   1509                              return ret;
   1510                          }
   1511          
   1512                          break;
   1513          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   1514          
   1515          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1516                      case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
   1517                          MBEDTLS_SSL_DEBUG_MSG(3, ("found encrypt_then_mac extension"));
   1518          
   1519                          if ((ret = ssl_parse_encrypt_then_mac_ext(ssl,
   1520                                                                    ext + 4, ext_size)) != 0) {
   1521                              return ret;
   1522                          }
   1523          
   1524                          break;
   1525          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1526          
   1527          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   1528                      case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
   1529                          MBEDTLS_SSL_DEBUG_MSG(3,
   1530                                                ("found extended_master_secret extension"));
   1531          
   1532                          if ((ret = ssl_parse_extended_ms_ext(ssl,
   1533                                                               ext + 4, ext_size)) != 0) {
   1534                              return ret;
   1535                          }
   1536          
   1537                          break;
   1538          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   1539          
   1540          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   1541                      case MBEDTLS_TLS_EXT_SESSION_TICKET:
   1542                          MBEDTLS_SSL_DEBUG_MSG(3, ("found session_ticket extension"));
   1543          
   1544                          if ((ret = ssl_parse_session_ticket_ext(ssl,
   1545                                                                  ext + 4, ext_size)) != 0) {
   1546                              return ret;
   1547                          }
   1548          
   1549                          break;
   1550          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1551          
   1552          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
   1553                          defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
   1554                          defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1555                      case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
   1556                          MBEDTLS_SSL_DEBUG_MSG(3,
   1557                                                ("found supported_point_formats extension"));
   1558          
   1559                          if ((ret = ssl_parse_supported_point_formats_ext(ssl,
   1560                                                                           ext + 4, ext_size)) != 0) {
   1561                              return ret;
   1562                          }
   1563          
   1564                          break;
   1565          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
   1566                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
   1567                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1568          
   1569          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1570                      case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
   1571                          MBEDTLS_SSL_DEBUG_MSG(3, ("found ecjpake_kkpp extension"));
   1572          
   1573                          if ((ret = ssl_parse_ecjpake_kkpp(ssl,
   1574                                                            ext + 4, ext_size)) != 0) {
   1575                              return ret;
   1576                          }
   1577          
   1578                          break;
   1579          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1580          
   1581          #if defined(MBEDTLS_SSL_ALPN)
   1582                      case MBEDTLS_TLS_EXT_ALPN:
   1583                          MBEDTLS_SSL_DEBUG_MSG(3, ("found alpn extension"));
   1584          
   1585                          if ((ret = ssl_parse_alpn_ext(ssl, ext + 4, ext_size)) != 0) {
   1586                              return ret;
   1587                          }
   1588          
   1589                          break;
   1590          #endif /* MBEDTLS_SSL_ALPN */
   1591          
   1592          #if defined(MBEDTLS_SSL_DTLS_SRTP)
   1593                      case MBEDTLS_TLS_EXT_USE_SRTP:
   1594                          MBEDTLS_SSL_DEBUG_MSG(3, ("found use_srtp extension"));
   1595          
   1596                          if ((ret = ssl_parse_use_srtp_ext(ssl, ext + 4, ext_size)) != 0) {
   1597                              return ret;
   1598                          }
   1599          
   1600                          break;
   1601          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   1602          
   1603                      default:
   1604                          MBEDTLS_SSL_DEBUG_MSG(3,
   1605                                                ("unknown extension found: %u (ignoring)", ext_id));
   1606                  }
   1607          
   1608                  ext_len -= 4 + ext_size;
   1609                  ext += 4 + ext_size;
   1610          
   1611                  if (ext_len > 0 && ext_len < 4) {
   1612                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
   1613                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1614                  }
   1615              }
   1616          
   1617              /*
   1618               * mbedtls_ssl_derive_keys() has to be called after the parsing of the
   1619               * extensions. It sets the transform data for the resumed session which in
   1620               * case of DTLS includes the server CID extracted from the CID extension.
   1621               */
   1622              if (ssl->handshake->resume) {
   1623                  if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   1624                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   1625                      mbedtls_ssl_send_alert_message(
   1626                          ssl,
   1627                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1628                          MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   1629                      return ret;
   1630                  }
   1631              }
   1632          
   1633              /*
   1634               * Renegotiation security checks
   1635               */
   1636              if (ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1637                  ssl->conf->allow_legacy_renegotiation ==
   1638                  MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE) {
   1639                  MBEDTLS_SSL_DEBUG_MSG(1,
   1640                                        ("legacy renegotiation, breaking off handshake"));
   1641                  handshake_failure = 1;
   1642              }
   1643          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1644              else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1645                       ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1646                       renegotiation_info_seen == 0) {
   1647                  MBEDTLS_SSL_DEBUG_MSG(1,
   1648                                        ("renegotiation_info extension missing (secure)"));
   1649                  handshake_failure = 1;
   1650              } else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1651                         ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1652                         ssl->conf->allow_legacy_renegotiation ==
   1653                         MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION) {
   1654                  MBEDTLS_SSL_DEBUG_MSG(1, ("legacy renegotiation not allowed"));
   1655                  handshake_failure = 1;
   1656              } else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1657                         ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1658                         renegotiation_info_seen == 1) {
   1659                  MBEDTLS_SSL_DEBUG_MSG(1,
   1660                                        ("renegotiation_info extension present (legacy)"));
   1661                  handshake_failure = 1;
   1662              }
   1663          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1664          
   1665              if (handshake_failure == 1) {
   1666                  mbedtls_ssl_send_alert_message(
   1667                      ssl,
   1668                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1669                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1670                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1671              }
   1672          
   1673              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server hello"));
   1674          
   1675              return 0;
   1676          }
   1677          
   1678          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   1679              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   1680          MBEDTLS_CHECK_RETURN_CRITICAL
   1681          static int ssl_parse_server_dh_params(mbedtls_ssl_context *ssl,
   1682                                                unsigned char **p,
   1683                                                unsigned char *end)
   1684          {
   1685              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1686              size_t dhm_actual_bitlen;
   1687          
   1688              /*
   1689               * Ephemeral DH parameters:
   1690               *
   1691               * struct {
   1692               *     opaque dh_p<1..2^16-1>;
   1693               *     opaque dh_g<1..2^16-1>;
   1694               *     opaque dh_Ys<1..2^16-1>;
   1695               * } ServerDHParams;
   1696               */
   1697              if ((ret = mbedtls_dhm_read_params(&ssl->handshake->dhm_ctx,
   1698                                                 p, end)) != 0) {
   1699                  MBEDTLS_SSL_DEBUG_RET(2, ("mbedtls_dhm_read_params"), ret);
   1700                  return ret;
   1701              }
   1702          
   1703              dhm_actual_bitlen = mbedtls_dhm_get_bitlen(&ssl->handshake->dhm_ctx);
   1704              if (dhm_actual_bitlen < ssl->conf->dhm_min_bitlen) {
   1705                  MBEDTLS_SSL_DEBUG_MSG(1, ("DHM prime too short: %" MBEDTLS_PRINTF_SIZET " < %u",
   1706                                            dhm_actual_bitlen,
   1707                                            ssl->conf->dhm_min_bitlen));
   1708                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1709              }
   1710          
   1711              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: P ", &ssl->handshake->dhm_ctx.P);
   1712              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: G ", &ssl->handshake->dhm_ctx.G);
   1713              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: GY", &ssl->handshake->dhm_ctx.GY);
   1714          
   1715              return ret;
   1716          }
   1717          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   1718                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   1719          
   1720          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1721          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)   ||   \
   1722              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)   ||   \
   1723              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   1724          MBEDTLS_CHECK_RETURN_CRITICAL
   1725          static int ssl_parse_server_ecdh_params(mbedtls_ssl_context *ssl,
   1726                                                  unsigned char **p,
   1727                                                  unsigned char *end)
   1728          {
   1729              uint16_t tls_id;
   1730              size_t ecpoint_len;
   1731              mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   1732              psa_key_type_t key_type = PSA_KEY_TYPE_NONE;
   1733              size_t ec_bits = 0;
   1734          
   1735              /*
   1736               * struct {
   1737               *     ECParameters curve_params;
   1738               *     ECPoint      public;
   1739               * } ServerECDHParams;
   1740               *
   1741               *  1       curve_type (must be "named_curve")
   1742               *  2..3    NamedCurve
   1743               *  4       ECPoint.len
   1744               *  5+      ECPoint contents
   1745               */
   1746              if (end - *p < 4) {
   1747                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1748              }
   1749          
   1750              /* First byte is curve_type; only named_curve is handled */
   1751              if (*(*p)++ != MBEDTLS_ECP_TLS_NAMED_CURVE) {
   1752                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1753              }
   1754          
   1755              /* Next two bytes are the namedcurve value */
   1756              tls_id = *(*p)++;
   1757              tls_id <<= 8;
   1758              tls_id |= *(*p)++;
   1759          
   1760              /* Check it's a curve we offered */
   1761              if (mbedtls_ssl_check_curve_tls_id(ssl, tls_id) != 0) {
   1762                  MBEDTLS_SSL_DEBUG_MSG(2,
   1763                                        ("bad server key exchange message (ECDHE curve): %u",
   1764                                         (unsigned) tls_id));
   1765                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1766              }
   1767          
   1768              /* Convert EC's TLS ID to PSA key type. */
   1769              if (mbedtls_ssl_get_psa_curve_info_from_tls_id(tls_id, &key_type,
   1770                                                             &ec_bits) == PSA_ERROR_NOT_SUPPORTED) {
   1771                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1772              }
   1773              handshake->xxdh_psa_type = key_type;
   1774              handshake->xxdh_psa_bits = ec_bits;
   1775          
   1776              /* Keep a copy of the peer's public key */
   1777              ecpoint_len = *(*p)++;
   1778              if ((size_t) (end - *p) < ecpoint_len) {
   1779                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1780              }
   1781          
   1782              if (ecpoint_len > sizeof(handshake->xxdh_psa_peerkey)) {
   1783                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1784              }
   1785          
   1786              memcpy(handshake->xxdh_psa_peerkey, *p, ecpoint_len);
   1787              handshake->xxdh_psa_peerkey_len = ecpoint_len;
   1788              *p += ecpoint_len;
   1789          
   1790              return 0;
   1791          }
   1792          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED   ||
   1793                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED   ||
   1794                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   1795          #else
   1796          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)   ||   \
   1797              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)    ||   \
   1798              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)   ||   \
   1799              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||   \
   1800              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   1801          MBEDTLS_CHECK_RETURN_CRITICAL
   1802          static int ssl_check_server_ecdh_params(const mbedtls_ssl_context *ssl)
   1803          {
   1804              uint16_t tls_id;
   1805              mbedtls_ecp_group_id grp_id;
   1806          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
   1807              grp_id = ssl->handshake->ecdh_ctx.grp.id;
   1808          #else
   1809              grp_id = ssl->handshake->ecdh_ctx.grp_id;
   1810          #endif
   1811          
   1812              tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(grp_id);
   1813              if (tls_id == 0) {
   1814                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1815                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   1816              }
   1817          
   1818              MBEDTLS_SSL_DEBUG_MSG(2, ("ECDH curve: %s",
   1819                                        mbedtls_ssl_get_curve_name_from_tls_id(tls_id)));
   1820          
   1821              if (mbedtls_ssl_check_curve(ssl, grp_id) != 0) {
   1822                  return -1;
   1823              }
   1824          
   1825              MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   1826                                     MBEDTLS_DEBUG_ECDH_QP);
   1827          
   1828              return 0;
   1829          }
   1830          
   1831          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED   ||
   1832                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED    ||
   1833                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED   ||
   1834                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   1835                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   1836          
   1837          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||     \
   1838              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||     \
   1839              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   1840          MBEDTLS_CHECK_RETURN_CRITICAL
   1841          static int ssl_parse_server_ecdh_params(mbedtls_ssl_context *ssl,
   1842                                                  unsigned char **p,
   1843                                                  unsigned char *end)
   1844          {
   1845              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1846          
   1847              /*
   1848               * Ephemeral ECDH parameters:
   1849               *
   1850               * struct {
   1851               *     ECParameters curve_params;
   1852               *     ECPoint      public;
   1853               * } ServerECDHParams;
   1854               */
   1855              if ((ret = mbedtls_ecdh_read_params(&ssl->handshake->ecdh_ctx,
   1856                                                  (const unsigned char **) p, end)) != 0) {
   1857                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecdh_read_params"), ret);
   1858          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   1859                  if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   1860                      ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   1861                  }
   1862          #endif
   1863                  return ret;
   1864              }
   1865          
   1866              if (ssl_check_server_ecdh_params(ssl) != 0) {
   1867                  MBEDTLS_SSL_DEBUG_MSG(1,
   1868                                        ("bad server key exchange message (ECDHE curve)"));
   1869                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1870              }
   1871          
   1872              return ret;
   1873          }
   1874          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED || \
   1875                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED || \
   1876                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   1877          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   1878          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   1879          MBEDTLS_CHECK_RETURN_CRITICAL
   1880          static int ssl_parse_server_psk_hint(mbedtls_ssl_context *ssl,
   1881                                               unsigned char **p,
   1882                                               unsigned char *end)
   1883          {
   1884              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1885              uint16_t  len;
   1886              ((void) ssl);
   1887          
   1888              /*
   1889               * PSK parameters:
   1890               *
   1891               * opaque psk_identity_hint<0..2^16-1>;
   1892               */
   1893              if (end - (*p) < 2) {
   1894                  MBEDTLS_SSL_DEBUG_MSG(1,
   1895                                        ("bad server key exchange message (psk_identity_hint length)"));
   1896                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1897              }
   1898              len = (*p)[0] << 8 | (*p)[1];
   1899              *p += 2;
   1900          
   1901              if (end - (*p) < len) {
   1902                  MBEDTLS_SSL_DEBUG_MSG(1,
   1903                                        ("bad server key exchange message (psk_identity_hint length)"));
   1904                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1905              }
   1906          
   1907              /*
   1908               * Note: we currently ignore the PSK identity hint, as we only allow one
   1909               * PSK to be provisioned on the client. This could be changed later if
   1910               * someone needs that feature.
   1911               */
   1912              *p += len;
   1913              ret = 0;
   1914          
   1915              return ret;
   1916          }
   1917          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   1918          
   1919          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
   1920              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   1921          /*
   1922           * Generate a pre-master secret and encrypt it with the server's RSA key
   1923           */
   1924          MBEDTLS_CHECK_RETURN_CRITICAL
   1925          static int ssl_write_encrypted_pms(mbedtls_ssl_context *ssl,
   1926                                             size_t offset, size_t *olen,
   1927                                             size_t pms_offset)
   1928          {
   1929              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1930              size_t len_bytes = 2;
   1931              unsigned char *p = ssl->handshake->premaster + pms_offset;
   1932              mbedtls_pk_context *peer_pk;
   1933          
   1934              if (offset + len_bytes > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   1935                  MBEDTLS_SSL_DEBUG_MSG(1, ("buffer too small for encrypted pms"));
   1936                  return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   1937              }
   1938          
   1939              /*
   1940               * Generate (part of) the pre-master as
   1941               *  struct {
   1942               *      ProtocolVersion client_version;
   1943               *      opaque random[46];
   1944               *  } PreMasterSecret;
   1945               */
   1946              mbedtls_ssl_write_version(p, ssl->conf->transport,
   1947                                        MBEDTLS_SSL_VERSION_TLS1_2);
   1948          
   1949              if ((ret = ssl->conf->f_rng(ssl->conf->p_rng, p + 2, 46)) != 0) {
   1950                  MBEDTLS_SSL_DEBUG_RET(1, "f_rng", ret);
   1951                  return ret;
   1952              }
   1953          
   1954              ssl->handshake->pmslen = 48;
   1955          
   1956          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   1957              peer_pk = &ssl->handshake->peer_pubkey;
   1958          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   1959              if (ssl->session_negotiate->peer_cert == NULL) {
   1960                  /* Should never happen */
   1961                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   1962                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   1963              }
   1964              peer_pk = &ssl->session_negotiate->peer_cert->pk;
   1965          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   1966          
   1967              /*
   1968               * Now write it out, encrypted
   1969               */
   1970              if (!mbedtls_pk_can_do(peer_pk, MBEDTLS_PK_RSA)) {
   1971                  MBEDTLS_SSL_DEBUG_MSG(1, ("certificate key type mismatch"));
   1972                  return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   1973              }
   1974          
   1975              if ((ret = mbedtls_pk_encrypt(peer_pk,
   1976                                            p, ssl->handshake->pmslen,
   1977                                            ssl->out_msg + offset + len_bytes, olen,
   1978                                            MBEDTLS_SSL_OUT_CONTENT_LEN - offset - len_bytes,
   1979                                            ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   1980                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_rsa_pkcs1_encrypt", ret);
   1981                  return ret;
   1982              }
   1983          
   1984              if (len_bytes == 2) {
   1985                  MBEDTLS_PUT_UINT16_BE(*olen, ssl->out_msg, offset);
   1986                  *olen += 2;
   1987              }
   1988          
   1989          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   1990              /* We don't need the peer's public key anymore. Free it. */
   1991              mbedtls_pk_free(peer_pk);
   1992          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   1993              return 0;
   1994          }
   1995          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
   1996                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   1997          
   1998          #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   1999              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2000          MBEDTLS_CHECK_RETURN_CRITICAL
   2001          static int ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
   2002          {
   2003              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2004              mbedtls_pk_context *peer_pk;
   2005          
   2006          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2007              peer_pk = &ssl->handshake->peer_pubkey;
   2008          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2009              if (ssl->session_negotiate->peer_cert == NULL) {
   2010                  /* Should never happen */
   2011                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2012                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2013              }
   2014              peer_pk = &ssl->session_negotiate->peer_cert->pk;
   2015          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2016          
   2017              /* This is a public key, so it can't be opaque, so can_do() is a good
   2018               * enough check to ensure pk_ec() is safe to use below. */
   2019              if (!mbedtls_pk_can_do(peer_pk, MBEDTLS_PK_ECKEY)) {
   2020                  MBEDTLS_SSL_DEBUG_MSG(1, ("server key not ECDH capable"));
   2021                  return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   2022              }
   2023          
   2024          #if defined(MBEDTLS_ECP_C)
   2025              const mbedtls_ecp_keypair *peer_key = mbedtls_pk_ec_ro(*peer_pk);
   2026          #endif /* MBEDTLS_ECP_C */
   2027          
   2028          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2029              uint16_t tls_id = 0;
   2030              psa_key_type_t key_type = PSA_KEY_TYPE_NONE;
   2031              mbedtls_ecp_group_id grp_id = mbedtls_pk_get_group_id(peer_pk);
   2032          
   2033              if (mbedtls_ssl_check_curve(ssl, grp_id) != 0) {
   2034                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server certificate (ECDH curve)"));
   2035                  return MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   2036              }
   2037          
   2038              tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(grp_id);
   2039              if (tls_id == 0) {
   2040                  MBEDTLS_SSL_DEBUG_MSG(1, ("ECC group %u not suported",
   2041                                            grp_id));
   2042                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2043              }
   2044          
   2045              /* If the above conversion to TLS ID was fine, then also this one will be,
   2046                 so there is no need to check the return value here */
   2047              mbedtls_ssl_get_psa_curve_info_from_tls_id(tls_id, &key_type,
   2048                                                         &ssl->handshake->xxdh_psa_bits);
   2049          
   2050              ssl->handshake->xxdh_psa_type = key_type;
   2051          
   2052              /* Store peer's public key in psa format. */
   2053          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   2054              memcpy(ssl->handshake->xxdh_psa_peerkey, peer_pk->pub_raw, peer_pk->pub_raw_len);
   2055              ssl->handshake->xxdh_psa_peerkey_len = peer_pk->pub_raw_len;
   2056              ret = 0;
   2057          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   2058              size_t olen = 0;
   2059              ret = mbedtls_ecp_point_write_binary(&peer_key->grp, &peer_key->Q,
   2060                                                   MBEDTLS_ECP_PF_UNCOMPRESSED, &olen,
   2061                                                   ssl->handshake->xxdh_psa_peerkey,
   2062                                                   sizeof(ssl->handshake->xxdh_psa_peerkey));
   2063          
   2064              if (ret != 0) {
   2065                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecp_point_write_binary"), ret);
   2066                  return ret;
   2067              }
   2068              ssl->handshake->xxdh_psa_peerkey_len = olen;
   2069          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   2070          #else /* MBEDTLS_USE_PSA_CRYPTO */
   2071              if ((ret = mbedtls_ecdh_get_params(&ssl->handshake->ecdh_ctx, peer_key,
   2072                                                 MBEDTLS_ECDH_THEIRS)) != 0) {
   2073                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecdh_get_params"), ret);
   2074                  return ret;
   2075              }
   2076          
   2077              if (ssl_check_server_ecdh_params(ssl) != 0) {
   2078                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server certificate (ECDH curve)"));
   2079                  return MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   2080              }
   2081          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2082          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2083              /* We don't need the peer's public key anymore. Free it,
   2084               * so that more RAM is available for upcoming expensive
   2085               * operations like ECDHE. */
   2086              mbedtls_pk_free(peer_pk);
   2087          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2088          
   2089              return ret;
   2090          }
   2091          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
   2092                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2093          
   2094          MBEDTLS_CHECK_RETURN_CRITICAL
   2095          static int ssl_parse_server_key_exchange(mbedtls_ssl_context *ssl)
   2096          {
   2097              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2098              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2099                  ssl->handshake->ciphersuite_info;
   2100              unsigned char *p = NULL, *end = NULL;
   2101          
   2102              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse server key exchange"));
   2103          
   2104          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   2105              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
   2106                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse server key exchange"));
   2107                  ssl->state++;
   2108                  return 0;
   2109              }
   2110              ((void) p);
   2111              ((void) end);
   2112          #endif
   2113          
   2114          #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   2115              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2116              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   2117                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA) {
   2118                  if ((ret = ssl_get_ecdh_params_from_cert(ssl)) != 0) {
   2119                      MBEDTLS_SSL_DEBUG_RET(1, "ssl_get_ecdh_params_from_cert", ret);
   2120                      mbedtls_ssl_send_alert_message(
   2121                          ssl,
   2122                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2123                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2124                      return ret;
   2125                  }
   2126          
   2127                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse server key exchange"));
   2128                  ssl->state++;
   2129                  return 0;
   2130              }
   2131              ((void) p);
   2132              ((void) end);
   2133          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   2134                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2135          
   2136          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2137              if (ssl->handshake->ecrs_enabled &&
   2138                  ssl->handshake->ecrs_state == ssl_ecrs_ske_start_processing) {
   2139                  goto start_processing;
   2140              }
   2141          #endif
   2142          
   2143              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   2144                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   2145                  return ret;
   2146              }
   2147          
   2148              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   2149                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2150                  mbedtls_ssl_send_alert_message(
   2151                      ssl,
   2152                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2153                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   2154                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   2155              }
   2156          
   2157              /*
   2158               * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server
   2159               * doesn't use a psk_identity_hint
   2160               */
   2161              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE) {
   2162                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2163                      ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   2164                      /* Current message is probably either
   2165                       * CertificateRequest or ServerHelloDone */
   2166                      ssl->keep_current_message = 1;
   2167                      goto exit;
   2168                  }
   2169          
   2170                  MBEDTLS_SSL_DEBUG_MSG(1,
   2171                                        ("server key exchange message must not be skipped"));
   2172                  mbedtls_ssl_send_alert_message(
   2173                      ssl,
   2174                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2175                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   2176          
   2177                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   2178              }
   2179          
   2180          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2181              if (ssl->handshake->ecrs_enabled) {
   2182                  ssl->handshake->ecrs_state = ssl_ecrs_ske_start_processing;
   2183              }
   2184          
   2185          start_processing:
   2186          #endif
   2187              p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   2188              end = ssl->in_msg + ssl->in_hslen;
   2189              MBEDTLS_SSL_DEBUG_BUF(3,   "server key exchange", p, end - p);
   2190          
   2191          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   2192              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2193                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   2194                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2195                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   2196                  if (ssl_parse_server_psk_hint(ssl, &p, end) != 0) {
   2197                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2198                      mbedtls_ssl_send_alert_message(
   2199                          ssl,
   2200                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2201                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2202                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2203                  }
   2204              } /* FALLTHROUGH */
   2205          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   2206          
   2207          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \
   2208              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   2209              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2210                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   2211                  ; /* nothing more to do */
   2212              } else
   2213          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||
   2214                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   2215          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   2216              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   2217              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||
   2218                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   2219                  if (ssl_parse_server_dh_params(ssl, &p, end) != 0) {
   2220                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2221                      mbedtls_ssl_send_alert_message(
   2222                          ssl,
   2223                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2224                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   2225                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2226                  }
   2227              } else
   2228          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   2229                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   2230          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||     \
   2231              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||     \
   2232              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   2233              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   2234                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   2235                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) {
   2236                  if (ssl_parse_server_ecdh_params(ssl, &p, end) != 0) {
   2237                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2238                      mbedtls_ssl_send_alert_message(
   2239                          ssl,
   2240                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2241                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   2242                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2243                  }
   2244              } else
   2245          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   2246                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||
   2247                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   2248          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2249              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   2250          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2251                  /*
   2252                   * The first 3 bytes are:
   2253                   * [0] MBEDTLS_ECP_TLS_NAMED_CURVE
   2254                   * [1, 2] elliptic curve's TLS ID
   2255                   *
   2256                   * However since we only support secp256r1 for now, we check only
   2257                   * that TLS ID here
   2258                   */
   2259                  uint16_t read_tls_id = MBEDTLS_GET_UINT16_BE(p, 1);
   2260                  uint16_t exp_tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(
   2261                      MBEDTLS_ECP_DP_SECP256R1);
   2262          
   2263                  if (exp_tls_id == 0) {
   2264                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2265                  }
   2266          
   2267                  if ((*p != MBEDTLS_ECP_TLS_NAMED_CURVE) ||
   2268                      (read_tls_id != exp_tls_id)) {
   2269                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2270                  }
   2271          
   2272                  p += 3;
   2273          
   2274                  if ((ret = mbedtls_psa_ecjpake_read_round(
   2275                           &ssl->handshake->psa_pake_ctx, p, end - p,
   2276                           MBEDTLS_ECJPAKE_ROUND_TWO)) != 0) {
   2277                      psa_destroy_key(ssl->handshake->psa_pake_password);
   2278                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   2279          
   2280                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_input round two", ret);
   2281                      mbedtls_ssl_send_alert_message(
   2282                          ssl,
   2283                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2284                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2285                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   2286                  }
   2287          #else
   2288                  ret = mbedtls_ecjpake_read_round_two(&ssl->handshake->ecjpake_ctx,
   2289                                                       p, end - p);
   2290                  if (ret != 0) {
   2291                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_read_round_two", ret);
   2292                      mbedtls_ssl_send_alert_message(
   2293                          ssl,
   2294                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2295                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2296                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   2297                  }
   2298          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2299              } else
   2300          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2301              {
   2302                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2303                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2304              }
   2305          
   2306          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   2307              if (mbedtls_ssl_ciphersuite_uses_server_signature(ciphersuite_info)) {
   2308                  size_t sig_len, hashlen;
   2309                  unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   2310          
   2311                  mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
   2312                  mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
   2313                  unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   2314                  size_t params_len = p - params;
   2315                  void *rs_ctx = NULL;
   2316                  uint16_t sig_alg;
   2317          
   2318                  mbedtls_pk_context *peer_pk;
   2319          
   2320          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2321                  peer_pk = &ssl->handshake->peer_pubkey;
   2322          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2323                  if (ssl->session_negotiate->peer_cert == NULL) {
   2324                      /* Should never happen */
   2325                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2326                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2327                  }
   2328                  peer_pk = &ssl->session_negotiate->peer_cert->pk;
   2329          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2330          
   2331                  /*
   2332                   * Handle the digitally-signed structure
   2333                   */
   2334                  MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 2);
   2335                  sig_alg = MBEDTLS_GET_UINT16_BE(p, 0);
   2336                  if (mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
   2337                          sig_alg, &pk_alg, &md_alg) != 0 &&
   2338                      !mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg) &&
   2339                      !mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg)) {
   2340                      MBEDTLS_SSL_DEBUG_MSG(1,
   2341                                            ("bad server key exchange message"));
   2342                      mbedtls_ssl_send_alert_message(
   2343                          ssl,
   2344                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2345                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   2346                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2347                  }
   2348                  p += 2;
   2349          
   2350                  if (!mbedtls_pk_can_do(peer_pk, pk_alg)) {
   2351                      MBEDTLS_SSL_DEBUG_MSG(1,
   2352                                            ("bad server key exchange message"));
   2353                      mbedtls_ssl_send_alert_message(
   2354                          ssl,
   2355                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2356                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
   2357                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2358                  }
   2359          
   2360                  /*
   2361                   * Read signature
   2362                   */
   2363          
   2364                  if (p > end - 2) {
   2365                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2366                      mbedtls_ssl_send_alert_message(
   2367                          ssl,
   2368                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2369                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2370                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2371                  }
   2372                  sig_len = (p[0] << 8) | p[1];
   2373                  p += 2;
   2374          
   2375                  if (p != end - sig_len) {
   2376                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2377                      mbedtls_ssl_send_alert_message(
   2378                          ssl,
   2379                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2380                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2381                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2382                  }
   2383          
   2384                  MBEDTLS_SSL_DEBUG_BUF(3, "signature", p, sig_len);
   2385          
   2386                  /*
   2387                   * Compute the hash that has been signed
   2388                   */
   2389                  if (md_alg != MBEDTLS_MD_NONE) {
   2390                      ret = mbedtls_ssl_get_key_exchange_md_tls1_2(ssl, hash, &hashlen,
   2391                                                                   params, params_len,
   2392                                                                   md_alg);
   2393                      if (ret != 0) {
   2394                          return ret;
   2395                      }
   2396                  } else {
   2397                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2398                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2399                  }
   2400          
   2401                  MBEDTLS_SSL_DEBUG_BUF(3, "parameters hash", hash, hashlen);
   2402          
   2403                  /*
   2404                   * Verify signature
   2405                   */
   2406                  if (!mbedtls_pk_can_do(peer_pk, pk_alg)) {
   2407                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad server key exchange message"));
   2408                      mbedtls_ssl_send_alert_message(
   2409                          ssl,
   2410                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2411                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   2412                      return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   2413                  }
   2414          
   2415          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2416                  if (ssl->handshake->ecrs_enabled) {
   2417                      rs_ctx = &ssl->handshake->ecrs_ctx.pk;
   2418                  }
   2419          #endif
   2420          
   2421          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   2422                  if (pk_alg == MBEDTLS_PK_RSASSA_PSS) {
   2423                      mbedtls_pk_rsassa_pss_options rsassa_pss_options;
   2424                      rsassa_pss_options.mgf1_hash_id = md_alg;
   2425                      rsassa_pss_options.expected_salt_len =
   2426                          mbedtls_md_get_size_from_type(md_alg);
   2427                      if (rsassa_pss_options.expected_salt_len == 0) {
   2428                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2429                      }
   2430          
   2431                      ret = mbedtls_pk_verify_ext(pk_alg, &rsassa_pss_options,
   2432                                                  peer_pk,
   2433                                                  md_alg, hash, hashlen,
   2434                                                  p, sig_len);
   2435                  } else
   2436          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
   2437                  ret = mbedtls_pk_verify_restartable(peer_pk,
   2438                                                      md_alg, hash, hashlen, p, sig_len, rs_ctx);
   2439          
   2440                  if (ret != 0) {
   2441                      int send_alert_msg = 1;
   2442          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2443                      send_alert_msg = (ret != MBEDTLS_ERR_ECP_IN_PROGRESS);
   2444          #endif
   2445                      if (send_alert_msg) {
   2446                          mbedtls_ssl_send_alert_message(
   2447                              ssl,
   2448                              MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2449                              MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR);
   2450                      }
   2451                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_pk_verify", ret);
   2452          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2453                      if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2454                          ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   2455                      }
   2456          #endif
   2457                      return ret;
   2458                  }
   2459          
   2460          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   2461                  /* We don't need the peer's public key anymore. Free it,
   2462                   * so that more RAM is available for upcoming expensive
   2463                   * operations like ECDHE. */
   2464                  mbedtls_pk_free(peer_pk);
   2465          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   2466              }
   2467          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
   2468          
   2469          exit:
   2470              ssl->state++;
   2471          
   2472              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server key exchange"));
   2473          
   2474              return 0;
   2475          }
   2476          
   2477          #if !defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   2478          MBEDTLS_CHECK_RETURN_CRITICAL
   2479          static int ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
   2480          {
   2481              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2482                  ssl->handshake->ciphersuite_info;
   2483          
   2484              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate request"));
   2485          
   2486              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   2487                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate request"));
   2488                  ssl->state++;
   2489                  return 0;
   2490              }
   2491          
   2492              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2493              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2494          }
   2495          #else /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   2496          MBEDTLS_CHECK_RETURN_CRITICAL
   2497          static int ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
   2498          {
   2499              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2500              unsigned char *buf;
   2501              size_t n = 0;
   2502              size_t cert_type_len = 0, dn_len = 0;
   2503              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2504                  ssl->handshake->ciphersuite_info;
   2505              size_t sig_alg_len;
   2506          #if defined(MBEDTLS_DEBUG_C)
   2507              unsigned char *sig_alg;
   2508              unsigned char *dn;
   2509          #endif
   2510          
   2511              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate request"));
   2512          
   2513              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   2514                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate request"));
   2515                  ssl->state++;
   2516                  return 0;
   2517              }
   2518          
   2519              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   2520                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   2521                  return ret;
   2522              }
   2523          
   2524              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   2525                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2526                  mbedtls_ssl_send_alert_message(
   2527                      ssl,
   2528                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2529                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   2530                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   2531              }
   2532          
   2533              ssl->state++;
   2534              ssl->handshake->client_auth =
   2535                  (ssl->in_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST);
   2536          
   2537              MBEDTLS_SSL_DEBUG_MSG(3, ("got %s certificate request",
   2538                                        ssl->handshake->client_auth ? "a" : "no"));
   2539          
   2540              if (ssl->handshake->client_auth == 0) {
   2541                  /* Current message is probably the ServerHelloDone */
   2542                  ssl->keep_current_message = 1;
   2543                  goto exit;
   2544              }
   2545          
   2546              /*
   2547               *  struct {
   2548               *      ClientCertificateType certificate_types<1..2^8-1>;
   2549               *      SignatureAndHashAlgorithm
   2550               *        supported_signature_algorithms<2^16-1>; -- TLS 1.2 only
   2551               *      DistinguishedName certificate_authorities<0..2^16-1>;
   2552               *  } CertificateRequest;
   2553               *
   2554               *  Since we only support a single certificate on clients, let's just
   2555               *  ignore all the information that's supposed to help us pick a
   2556               *  certificate.
   2557               *
   2558               *  We could check that our certificate matches the request, and bail out
   2559               *  if it doesn't, but it's simpler to just send the certificate anyway,
   2560               *  and give the server the opportunity to decide if it should terminate
   2561               *  the connection when it doesn't like our certificate.
   2562               *
   2563               *  Same goes for the hash in TLS 1.2's signature_algorithms: at this
   2564               *  point we only have one hash available (see comments in
   2565               *  write_certificate_verify), so let's just use what we have.
   2566               *
   2567               *  However, we still minimally parse the message to check it is at least
   2568               *  superficially sane.
   2569               */
   2570              buf = ssl->in_msg;
   2571          
   2572              /* certificate_types */
   2573              if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl)) {
   2574                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2575                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2576                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2577                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2578              }
   2579              cert_type_len = buf[mbedtls_ssl_hs_hdr_len(ssl)];
   2580              n = cert_type_len;
   2581          
   2582              /*
   2583               * In the subsequent code there are two paths that read from buf:
   2584               *     * the length of the signature algorithms field (if minor version of
   2585               *       SSL is 3),
   2586               *     * distinguished name length otherwise.
   2587               * Both reach at most the index:
   2588               *    ...hdr_len + 2 + n,
   2589               * therefore the buffer length at this point must be greater than that
   2590               * regardless of the actual code path.
   2591               */
   2592              if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl) + 2 + n) {
   2593                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2594                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2595                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2596                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2597              }
   2598          
   2599              /* supported_signature_algorithms */
   2600              sig_alg_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
   2601                             | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
   2602          
   2603              /*
   2604               * The furthest access in buf is in the loop few lines below:
   2605               *     sig_alg[i + 1],
   2606               * where:
   2607               *     sig_alg = buf + ...hdr_len + 3 + n,
   2608               *     max(i) = sig_alg_len - 1.
   2609               * Therefore the furthest access is:
   2610               *     buf[...hdr_len + 3 + n + sig_alg_len - 1 + 1],
   2611               * which reduces to:
   2612               *     buf[...hdr_len + 3 + n + sig_alg_len],
   2613               * which is one less than we need the buf to be.
   2614               */
   2615              if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl) + 3 + n + sig_alg_len) {
   2616                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2617                  mbedtls_ssl_send_alert_message(
   2618                      ssl,
   2619                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2620                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2621                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2622              }
   2623          
   2624          #if defined(MBEDTLS_DEBUG_C)
   2625              sig_alg = buf + mbedtls_ssl_hs_hdr_len(ssl) + 3 + n;
   2626              for (size_t i = 0; i < sig_alg_len; i += 2) {
   2627                  MBEDTLS_SSL_DEBUG_MSG(3,
   2628                                        ("Supported Signature Algorithm found: %02x %02x",
   2629                                         sig_alg[i], sig_alg[i + 1]));
   2630              }
   2631          #endif
   2632          
   2633              n += 2 + sig_alg_len;
   2634          
   2635              /* certificate_authorities */
   2636              dn_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
   2637                        | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
   2638          
   2639              n += dn_len;
   2640              if (ssl->in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 3 + n) {
   2641                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2642                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2643                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2644                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2645              }
   2646          
   2647          #if defined(MBEDTLS_DEBUG_C)
   2648              dn = buf + mbedtls_ssl_hs_hdr_len(ssl) + 3 + n - dn_len;
   2649              for (size_t i = 0, dni_len = 0; i < dn_len; i += 2 + dni_len) {
   2650                  unsigned char *p = dn + i + 2;
   2651                  mbedtls_x509_name name;
   2652                  size_t asn1_len;
   2653                  char s[MBEDTLS_X509_MAX_DN_NAME_SIZE];
   2654                  memset(&name, 0, sizeof(name));
   2655                  dni_len = MBEDTLS_GET_UINT16_BE(dn + i, 0);
   2656                  if (dni_len > dn_len - i - 2 ||
   2657                      mbedtls_asn1_get_tag(&p, p + dni_len, &asn1_len,
   2658                                           MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE) != 0 ||
   2659                      mbedtls_x509_get_name(&p, p + asn1_len, &name) != 0) {
   2660                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
   2661                      mbedtls_ssl_send_alert_message(
   2662                          ssl,
   2663                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2664                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2665                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2666                  }
   2667                  MBEDTLS_SSL_DEBUG_MSG(3,
   2668                                        ("DN hint: %.*s",
   2669                                         mbedtls_x509_dn_gets(s, sizeof(s), &name), s));
   2670                  mbedtls_asn1_free_named_data_list_shallow(name.next);
   2671              }
   2672          #endif
   2673          
   2674          exit:
   2675              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse certificate request"));
   2676          
   2677              return 0;
   2678          }
   2679          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   2680          
   2681          MBEDTLS_CHECK_RETURN_CRITICAL
   2682          static int ssl_parse_server_hello_done(mbedtls_ssl_context *ssl)
   2683          {
   2684              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2685          
   2686              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse server hello done"));
   2687          
   2688              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   2689                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   2690                  return ret;
   2691              }
   2692          
   2693              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   2694                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello done message"));
   2695                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   2696              }
   2697          
   2698              if (ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl) ||
   2699                  ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE) {
   2700                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello done message"));
   2701                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2702                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   2703                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   2704              }
   2705          
   2706              ssl->state++;
   2707          
   2708          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2709              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   2710                  mbedtls_ssl_recv_flight_completed(ssl);
   2711              }
   2712          #endif
   2713          
   2714              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse server hello done"));
   2715          
   2716              return 0;
   2717          }
   2718          
   2719          MBEDTLS_CHECK_RETURN_CRITICAL
   2720          static int ssl_write_client_key_exchange(mbedtls_ssl_context *ssl)
   2721          {
   2722              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2723          
   2724              size_t header_len;
   2725              size_t content_len;
   2726              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2727                  ssl->handshake->ciphersuite_info;
   2728          
   2729              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write client key exchange"));
   2730          
   2731          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
   2732              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA) {
   2733                  /*
   2734                   * DHM key exchange -- send G^X mod P
   2735                   */
   2736                  content_len = mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx);
   2737          
   2738                  MBEDTLS_PUT_UINT16_BE(content_len, ssl->out_msg, 4);
   2739                  header_len = 6;
   2740          
   2741                  ret = mbedtls_dhm_make_public(&ssl->handshake->dhm_ctx,
   2742                                                (int) mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx),
   2743                                                &ssl->out_msg[header_len], content_len,
   2744                                                ssl->conf->f_rng, ssl->conf->p_rng);
   2745                  if (ret != 0) {
   2746                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_make_public", ret);
   2747                      return ret;
   2748                  }
   2749          
   2750                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: X ", &ssl->handshake->dhm_ctx.X);
   2751                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: GX", &ssl->handshake->dhm_ctx.GX);
   2752          
   2753                  if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   2754                                                     ssl->handshake->premaster,
   2755                                                     MBEDTLS_PREMASTER_SIZE,
   2756                                                     &ssl->handshake->pmslen,
   2757                                                     ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   2758                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   2759                      return ret;
   2760                  }
   2761          
   2762                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   2763              } else
   2764          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
   2765          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
   2766              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
   2767              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
   2768              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2769              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   2770                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
   2771                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   2772                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA) {
   2773          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2774                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2775                  psa_status_t destruction_status = PSA_ERROR_CORRUPTION_DETECTED;
   2776                  psa_key_attributes_t key_attributes;
   2777          
   2778                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   2779          
   2780                  header_len = 4;
   2781          
   2782                  MBEDTLS_SSL_DEBUG_MSG(1, ("Perform PSA-based ECDH computation."));
   2783          
   2784                  /*
   2785                   * Generate EC private key for ECDHE exchange.
   2786                   */
   2787          
   2788                  /* The master secret is obtained from the shared ECDH secret by
   2789                   * applying the TLS 1.2 PRF with a specific salt and label. While
   2790                   * the PSA Crypto API encourages combining key agreement schemes
   2791                   * such as ECDH with fixed KDFs such as TLS 1.2 PRF, it does not
   2792                   * yet support the provisioning of salt + label to the KDF.
   2793                   * For the time being, we therefore need to split the computation
   2794                   * of the ECDH secret and the application of the TLS 1.2 PRF. */
   2795                  key_attributes = psa_key_attributes_init();
   2796                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   2797                  psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
   2798                  psa_set_key_type(&key_attributes, handshake->xxdh_psa_type);
   2799                  psa_set_key_bits(&key_attributes, handshake->xxdh_psa_bits);
   2800          
   2801                  /* Generate ECDH private key. */
   2802                  status = psa_generate_key(&key_attributes,
   2803                                            &handshake->xxdh_psa_privkey);
   2804                  if (status != PSA_SUCCESS) {
   2805                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2806                  }
   2807          
   2808                  /* Export the public part of the ECDH private key from PSA.
   2809                   * The export format is an ECPoint structure as expected by TLS,
   2810                   * but we just need to add a length byte before that. */
   2811                  unsigned char *own_pubkey = ssl->out_msg + header_len + 1;
   2812                  unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   2813                  size_t own_pubkey_max_len = (size_t) (end - own_pubkey);
   2814                  size_t own_pubkey_len;
   2815          
   2816                  status = psa_export_public_key(handshake->xxdh_psa_privkey,
   2817                                                 own_pubkey, own_pubkey_max_len,
   2818                                                 &own_pubkey_len);
   2819                  if (status != PSA_SUCCESS) {
   2820                      psa_destroy_key(handshake->xxdh_psa_privkey);
   2821                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   2822                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2823                  }
   2824          
   2825                  ssl->out_msg[header_len] = (unsigned char) own_pubkey_len;
   2826                  content_len = own_pubkey_len + 1;
   2827          
   2828                  /* The ECDH secret is the premaster secret used for key derivation. */
   2829          
   2830                  /* Compute ECDH shared secret. */
   2831                  status = psa_raw_key_agreement(PSA_ALG_ECDH,
   2832                                                 handshake->xxdh_psa_privkey,
   2833                                                 handshake->xxdh_psa_peerkey,
   2834                                                 handshake->xxdh_psa_peerkey_len,
   2835                                                 ssl->handshake->premaster,
   2836                                                 sizeof(ssl->handshake->premaster),
   2837                                                 &ssl->handshake->pmslen);
   2838          
   2839                  destruction_status = psa_destroy_key(handshake->xxdh_psa_privkey);
   2840                  handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   2841          
   2842                  if (status != PSA_SUCCESS || destruction_status != PSA_SUCCESS) {
   2843                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2844                  }
   2845          #else
   2846                  /*
   2847                   * ECDH key exchange -- send client public value
   2848                   */
   2849                  header_len = 4;
   2850          
   2851          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2852                  if (ssl->handshake->ecrs_enabled) {
   2853                      if (ssl->handshake->ecrs_state == ssl_ecrs_cke_ecdh_calc_secret) {
   2854                          goto ecdh_calc_secret;
   2855                      }
   2856          
   2857                      mbedtls_ecdh_enable_restart(&ssl->handshake->ecdh_ctx);
   2858                  }
   2859          #endif
   2860          
   2861                  ret = mbedtls_ecdh_make_public(&ssl->handshake->ecdh_ctx,
   2862                                                 &content_len,
   2863                                                 &ssl->out_msg[header_len], 1000,
   2864                                                 ssl->conf->f_rng, ssl->conf->p_rng);
   2865                  if (ret != 0) {
   2866                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_make_public", ret);
   2867          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2868                      if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2869                          ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   2870                      }
   2871          #endif
   2872                      return ret;
   2873                  }
   2874          
   2875                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   2876                                         MBEDTLS_DEBUG_ECDH_Q);
   2877          
   2878          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2879                  if (ssl->handshake->ecrs_enabled) {
   2880                      ssl->handshake->ecrs_n = content_len;
   2881                      ssl->handshake->ecrs_state = ssl_ecrs_cke_ecdh_calc_secret;
   2882                  }
   2883          
   2884          ecdh_calc_secret:
   2885                  if (ssl->handshake->ecrs_enabled) {
   2886                      content_len = ssl->handshake->ecrs_n;
   2887                  }
   2888          #endif
   2889                  if ((ret = mbedtls_ecdh_calc_secret(&ssl->handshake->ecdh_ctx,
   2890                                                      &ssl->handshake->pmslen,
   2891                                                      ssl->handshake->premaster,
   2892                                                      MBEDTLS_MPI_MAX_SIZE,
   2893                                                      ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   2894                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_calc_secret", ret);
   2895          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   2896                      if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2897                          ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   2898                      }
   2899          #endif
   2900                      return ret;
   2901                  }
   2902          
   2903                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   2904                                         MBEDTLS_DEBUG_ECDH_Z);
   2905          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2906              } else
   2907          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   2908                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   2909                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   2910                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2911          #if defined(MBEDTLS_USE_PSA_CRYPTO) &&                           \
   2912              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   2913              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   2914                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2915                  psa_status_t destruction_status = PSA_ERROR_CORRUPTION_DETECTED;
   2916                  psa_key_attributes_t key_attributes;
   2917          
   2918                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   2919          
   2920                  /*
   2921                   * opaque psk_identity<0..2^16-1>;
   2922                   */
   2923                  if (mbedtls_ssl_conf_has_static_psk(ssl->conf) == 0) {
   2924                      /* We don't offer PSK suites if we don't have a PSK,
   2925                       * and we check that the server's choice is among the
   2926                       * ciphersuites we offered, so this should never happen. */
   2927                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2928                  }
   2929          
   2930                  /* uint16 to store content length */
   2931                  const size_t content_len_size = 2;
   2932          
   2933                  header_len = 4;
   2934          
   2935                  if (header_len + content_len_size + ssl->conf->psk_identity_len
   2936                      > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   2937                      MBEDTLS_SSL_DEBUG_MSG(1,
   2938                                            ("psk identity too long or SSL buffer too short"));
   2939                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   2940                  }
   2941          
   2942                  unsigned char *p = ssl->out_msg + header_len;
   2943          
   2944                  *p++ = MBEDTLS_BYTE_1(ssl->conf->psk_identity_len);
   2945                  *p++ = MBEDTLS_BYTE_0(ssl->conf->psk_identity_len);
   2946                  header_len += content_len_size;
   2947          
   2948                  memcpy(p, ssl->conf->psk_identity,
   2949                         ssl->conf->psk_identity_len);
   2950                  p += ssl->conf->psk_identity_len;
   2951          
   2952                  header_len += ssl->conf->psk_identity_len;
   2953          
   2954                  MBEDTLS_SSL_DEBUG_MSG(1, ("Perform PSA-based ECDH computation."));
   2955          
   2956                  /*
   2957                   * Generate EC private key for ECDHE exchange.
   2958                   */
   2959          
   2960                  /* The master secret is obtained from the shared ECDH secret by
   2961                   * applying the TLS 1.2 PRF with a specific salt and label. While
   2962                   * the PSA Crypto API encourages combining key agreement schemes
   2963                   * such as ECDH with fixed KDFs such as TLS 1.2 PRF, it does not
   2964                   * yet support the provisioning of salt + label to the KDF.
   2965                   * For the time being, we therefore need to split the computation
   2966                   * of the ECDH secret and the application of the TLS 1.2 PRF. */
   2967                  key_attributes = psa_key_attributes_init();
   2968                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   2969                  psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
   2970                  psa_set_key_type(&key_attributes, handshake->xxdh_psa_type);
   2971                  psa_set_key_bits(&key_attributes, handshake->xxdh_psa_bits);
   2972          
   2973                  /* Generate ECDH private key. */
   2974                  status = psa_generate_key(&key_attributes,
   2975                                            &handshake->xxdh_psa_privkey);
   2976                  if (status != PSA_SUCCESS) {
   2977                      return PSA_TO_MBEDTLS_ERR(status);
   2978                  }
   2979          
   2980                  /* Export the public part of the ECDH private key from PSA.
   2981                   * The export format is an ECPoint structure as expected by TLS,
   2982                   * but we just need to add a length byte before that. */
   2983                  unsigned char *own_pubkey = p + 1;
   2984                  unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   2985                  size_t own_pubkey_max_len = (size_t) (end - own_pubkey);
   2986                  size_t own_pubkey_len = 0;
   2987          
   2988                  status = psa_export_public_key(handshake->xxdh_psa_privkey,
   2989                                                 own_pubkey, own_pubkey_max_len,
   2990                                                 &own_pubkey_len);
   2991                  if (status != PSA_SUCCESS) {
   2992                      psa_destroy_key(handshake->xxdh_psa_privkey);
   2993                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   2994                      return PSA_TO_MBEDTLS_ERR(status);
   2995                  }
   2996          
   2997                  *p = (unsigned char) own_pubkey_len;
   2998                  content_len = own_pubkey_len + 1;
   2999          
   3000                  /* As RFC 5489 section 2, the premaster secret is formed as follows:
   3001                   * - a uint16 containing the length (in octets) of the ECDH computation
   3002                   * - the octet string produced by the ECDH computation
   3003                   * - a uint16 containing the length (in octets) of the PSK
   3004                   * - the PSK itself
   3005                   */
   3006                  unsigned char *pms = ssl->handshake->premaster;
   3007                  const unsigned char * const pms_end = pms +
   3008                                                        sizeof(ssl->handshake->premaster);
   3009                  /* uint16 to store length (in octets) of the ECDH computation */
   3010                  const size_t zlen_size = 2;
   3011                  size_t zlen = 0;
   3012          
   3013                  /* Perform ECDH computation after the uint16 reserved for the length */
   3014                  status = psa_raw_key_agreement(PSA_ALG_ECDH,
   3015                                                 handshake->xxdh_psa_privkey,
   3016                                                 handshake->xxdh_psa_peerkey,
   3017                                                 handshake->xxdh_psa_peerkey_len,
   3018                                                 pms + zlen_size,
   3019                                                 pms_end - (pms + zlen_size),
   3020                                                 &zlen);
   3021          
   3022                  destruction_status = psa_destroy_key(handshake->xxdh_psa_privkey);
   3023                  handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3024          
   3025                  if (status != PSA_SUCCESS) {
   3026                      return PSA_TO_MBEDTLS_ERR(status);
   3027                  } else if (destruction_status != PSA_SUCCESS) {
   3028                      return PSA_TO_MBEDTLS_ERR(destruction_status);
   3029                  }
   3030          
   3031                  /* Write the ECDH computation length before the ECDH computation */
   3032                  MBEDTLS_PUT_UINT16_BE(zlen, pms, 0);
   3033                  pms += zlen_size + zlen;
   3034              } else
   3035          #endif /* MBEDTLS_USE_PSA_CRYPTO &&
   3036                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   3037          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   3038              if (mbedtls_ssl_ciphersuite_uses_psk(ciphersuite_info)) {
   3039                  /*
   3040                   * opaque psk_identity<0..2^16-1>;
   3041                   */
   3042                  if (mbedtls_ssl_conf_has_static_psk(ssl->conf) == 0) {
   3043                      /* We don't offer PSK suites if we don't have a PSK,
   3044                       * and we check that the server's choice is among the
   3045                       * ciphersuites we offered, so this should never happen. */
   3046                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3047                  }
   3048          
   3049                  header_len = 4;
   3050                  content_len = ssl->conf->psk_identity_len;
   3051          
   3052                  if (header_len + 2 + content_len > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   3053                      MBEDTLS_SSL_DEBUG_MSG(1,
   3054                                            ("psk identity too long or SSL buffer too short"));
   3055                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   3056                  }
   3057          
   3058                  ssl->out_msg[header_len++] = MBEDTLS_BYTE_1(content_len);
   3059                  ssl->out_msg[header_len++] = MBEDTLS_BYTE_0(content_len);
   3060          
   3061                  memcpy(ssl->out_msg + header_len,
   3062                         ssl->conf->psk_identity,
   3063                         ssl->conf->psk_identity_len);
   3064                  header_len += ssl->conf->psk_identity_len;
   3065          
   3066          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   3067                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK) {
   3068                      content_len = 0;
   3069                  } else
   3070          #endif
   3071          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3072                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   3073                      if ((ret = ssl_write_encrypted_pms(ssl, header_len,
   3074                                                         &content_len, 2)) != 0) {
   3075                          return ret;
   3076                      }
   3077                  } else
   3078          #endif
   3079          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3080                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   3081                      /*
   3082                       * ClientDiffieHellmanPublic public (DHM send G^X mod P)
   3083                       */
   3084                      content_len = mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx);
   3085          
   3086                      if (header_len + 2 + content_len >
   3087                          MBEDTLS_SSL_OUT_CONTENT_LEN) {
   3088                          MBEDTLS_SSL_DEBUG_MSG(1,
   3089                                                ("psk identity or DHM size too long or SSL buffer too short"));
   3090                          return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   3091                      }
   3092          
   3093                      ssl->out_msg[header_len++] = MBEDTLS_BYTE_1(content_len);
   3094                      ssl->out_msg[header_len++] = MBEDTLS_BYTE_0(content_len);
   3095          
   3096                      ret = mbedtls_dhm_make_public(&ssl->handshake->dhm_ctx,
   3097                                                    (int) mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx),
   3098                                                    &ssl->out_msg[header_len], content_len,
   3099                                                    ssl->conf->f_rng, ssl->conf->p_rng);
   3100                      if (ret != 0) {
   3101                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_make_public", ret);
   3102                          return ret;
   3103                      }
   3104          
   3105          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3106                      unsigned char *pms = ssl->handshake->premaster;
   3107                      unsigned char *pms_end = pms + sizeof(ssl->handshake->premaster);
   3108                      size_t pms_len;
   3109          
   3110                      /* Write length only when we know the actual value */
   3111                      if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   3112                                                         pms + 2, pms_end - (pms + 2), &pms_len,
   3113                                                         ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   3114                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   3115                          return ret;
   3116                      }
   3117                      MBEDTLS_PUT_UINT16_BE(pms_len, pms, 0);
   3118                      pms += 2 + pms_len;
   3119          
   3120                      MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   3121          #endif
   3122                  } else
   3123          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3124          #if !defined(MBEDTLS_USE_PSA_CRYPTO) &&                             \
   3125                  defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   3126                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   3127                      /*
   3128                       * ClientECDiffieHellmanPublic public;
   3129                       */
   3130                      ret = mbedtls_ecdh_make_public(&ssl->handshake->ecdh_ctx,
   3131                                                     &content_len,
   3132                                                     &ssl->out_msg[header_len],
   3133                                                     MBEDTLS_SSL_OUT_CONTENT_LEN - header_len,
   3134                                                     ssl->conf->f_rng, ssl->conf->p_rng);
   3135                      if (ret != 0) {
   3136                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_make_public", ret);
   3137                          return ret;
   3138                      }
   3139          
   3140                      MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   3141                                             MBEDTLS_DEBUG_ECDH_Q);
   3142                  } else
   3143          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   3144                  {
   3145                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3146                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3147                  }
   3148          
   3149          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   3150                  if ((ret = mbedtls_ssl_psk_derive_premaster(ssl,
   3151                                                              (mbedtls_key_exchange_type_t) ciphersuite_info->
   3152                                                              key_exchange)) != 0) {
   3153                      MBEDTLS_SSL_DEBUG_RET(1,
   3154                                            "mbedtls_ssl_psk_derive_premaster", ret);
   3155                      return ret;
   3156                  }
   3157          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   3158              } else
   3159          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   3160          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   3161              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
   3162                  header_len = 4;
   3163                  if ((ret = ssl_write_encrypted_pms(ssl, header_len,
   3164                                                     &content_len, 0)) != 0) {
   3165                      return ret;
   3166                  }
   3167              } else
   3168          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   3169          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   3170              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   3171                  header_len = 4;
   3172          
   3173          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3174                  unsigned char *out_p = ssl->out_msg + header_len;
   3175                  unsigned char *end_p = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN -
   3176                                         header_len;
   3177                  ret = mbedtls_psa_ecjpake_write_round(&ssl->handshake->psa_pake_ctx,
   3178                                                        out_p, end_p - out_p, &content_len,
   3179                                                        MBEDTLS_ECJPAKE_ROUND_TWO);
   3180                  if (ret != 0) {
   3181                      psa_destroy_key(ssl->handshake->psa_pake_password);
   3182                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   3183                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_output", ret);
   3184                      return ret;
   3185                  }
   3186          #else
   3187                  ret = mbedtls_ecjpake_write_round_two(&ssl->handshake->ecjpake_ctx,
   3188                                                        ssl->out_msg + header_len,
   3189                                                        MBEDTLS_SSL_OUT_CONTENT_LEN - header_len,
   3190                                                        &content_len,
   3191                                                        ssl->conf->f_rng, ssl->conf->p_rng);
   3192                  if (ret != 0) {
   3193                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_write_round_two", ret);
   3194                      return ret;
   3195                  }
   3196          
   3197                  ret = mbedtls_ecjpake_derive_secret(&ssl->handshake->ecjpake_ctx,
   3198                                                      ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
   3199                                                      ssl->conf->f_rng, ssl->conf->p_rng);
   3200                  if (ret != 0) {
   3201                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_derive_secret", ret);
   3202                      return ret;
   3203                  }
   3204          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   3205              } else
   3206          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   3207              {
   3208                  ((void) ciphersuite_info);
   3209                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3210                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3211              }
   3212          
   3213              ssl->out_msglen  = header_len + content_len;
   3214              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3215              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;
   3216          
   3217              ssl->state++;
   3218          
   3219              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   3220                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3221                  return ret;
   3222              }
   3223          
   3224              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write client key exchange"));
   3225          
   3226              return 0;
   3227          }
   3228          
   3229          #if !defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   3230          MBEDTLS_CHECK_RETURN_CRITICAL
   3231          static int ssl_write_certificate_verify(mbedtls_ssl_context *ssl)
   3232          {
   3233              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3234                  ssl->handshake->ciphersuite_info;
   3235              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3236          
   3237              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate verify"));
   3238          
   3239              if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   3240                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   3241                  return ret;
   3242              }
   3243          
   3244              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   3245                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
   3246                  ssl->state++;
   3247                  return 0;
   3248              }
   3249          
   3250              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3251              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3252          }
   3253          #else /* !MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   3254          MBEDTLS_CHECK_RETURN_CRITICAL
   3255          static int ssl_write_certificate_verify(mbedtls_ssl_context *ssl)
   3256          {
   3257              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3258              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3259                  ssl->handshake->ciphersuite_info;
   3260              size_t n = 0, offset = 0;
   3261              unsigned char hash[48];
   3262              unsigned char *hash_start = hash;
   3263              mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
   3264              size_t hashlen;
   3265              void *rs_ctx = NULL;
   3266          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   3267              size_t out_buf_len = ssl->out_buf_len - (ssl->out_msg - ssl->out_buf);
   3268          #else
   3269              size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN - (ssl->out_msg - ssl->out_buf);
   3270          #endif
   3271          
   3272              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate verify"));
   3273          
   3274          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3275              if (ssl->handshake->ecrs_enabled &&
   3276                  ssl->handshake->ecrs_state == ssl_ecrs_crt_vrfy_sign) {
   3277                  goto sign;
   3278              }
   3279          #endif
   3280          
   3281              if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   3282                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   3283                  return ret;
   3284              }
   3285          
   3286              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   3287                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
   3288                  ssl->state++;
   3289                  return 0;
   3290              }
   3291          
   3292              if (ssl->handshake->client_auth == 0 ||
   3293                  mbedtls_ssl_own_cert(ssl) == NULL) {
   3294                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
   3295                  ssl->state++;
   3296                  return 0;
   3297              }
   3298          
   3299              if (mbedtls_ssl_own_key(ssl) == NULL) {
   3300                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no private key for certificate"));
   3301                  return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
   3302              }
   3303          
   3304              /*
   3305               * Make a signature of the handshake digests
   3306               */
   3307          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3308              if (ssl->handshake->ecrs_enabled) {
   3309                  ssl->handshake->ecrs_state = ssl_ecrs_crt_vrfy_sign;
   3310              }
   3311          
   3312          sign:
   3313          #endif
   3314          
   3315              ret = ssl->handshake->calc_verify(ssl, hash, &hashlen);
   3316              if (0 != ret) {
   3317                  MBEDTLS_SSL_DEBUG_RET(1, ("calc_verify"), ret);
   3318                  return ret;
   3319              }
   3320          
   3321              /*
   3322               * digitally-signed struct {
   3323               *     opaque handshake_messages[handshake_messages_length];
   3324               * };
   3325               *
   3326               * Taking shortcut here. We assume that the server always allows the
   3327               * PRF Hash function and has sent it in the allowed signature
   3328               * algorithms list received in the Certificate Request message.
   3329               *
   3330               * Until we encounter a server that does not, we will take this
   3331               * shortcut.
   3332               *
   3333               * Reason: Otherwise we should have running hashes for SHA512 and
   3334               *         SHA224 in order to satisfy 'weird' needs from the server
   3335               *         side.
   3336               */
   3337              if (ssl->handshake->ciphersuite_info->mac == MBEDTLS_MD_SHA384) {
   3338                  md_alg = MBEDTLS_MD_SHA384;
   3339                  ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;
   3340              } else {
   3341                  md_alg = MBEDTLS_MD_SHA256;
   3342                  ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;
   3343              }
   3344              ssl->out_msg[5] = mbedtls_ssl_sig_from_pk(mbedtls_ssl_own_key(ssl));
   3345          
   3346              /* Info from md_alg will be used instead */
   3347              hashlen = 0;
   3348              offset = 2;
   3349          
   3350          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3351              if (ssl->handshake->ecrs_enabled) {
   3352                  rs_ctx = &ssl->handshake->ecrs_ctx.pk;
   3353              }
   3354          #endif
   3355          
   3356              if ((ret = mbedtls_pk_sign_restartable(mbedtls_ssl_own_key(ssl),
   3357                                                     md_alg, hash_start, hashlen,
   3358                                                     ssl->out_msg + 6 + offset,
   3359                                                     out_buf_len - 6 - offset,
   3360                                                     &n,
   3361                                                     ssl->conf->f_rng, ssl->conf->p_rng, rs_ctx)) != 0) {
   3362                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_pk_sign", ret);
   3363          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   3364                  if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   3365                      ret = MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   3366                  }
   3367          #endif
   3368                  return ret;
   3369              }
   3370          
   3371              MBEDTLS_PUT_UINT16_BE(n, ssl->out_msg, offset + 4);
   3372          
   3373              ssl->out_msglen  = 6 + n + offset;
   3374              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3375              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;
   3376          
   3377              ssl->state++;
   3378          
   3379              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   3380                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3381                  return ret;
   3382              }
   3383          
   3384              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write certificate verify"));
   3385          
   3386              return ret;
   3387          }
   3388          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   3389          
   3390          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3391          MBEDTLS_CHECK_RETURN_CRITICAL
   3392          static int ssl_parse_new_session_ticket(mbedtls_ssl_context *ssl)
   3393          {
   3394              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3395              uint32_t lifetime;
   3396              size_t ticket_len;
   3397              unsigned char *ticket;
   3398              const unsigned char *msg;
   3399          
   3400              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse new session ticket"));
   3401          
   3402              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   3403                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   3404                  return ret;
   3405              }
   3406          
   3407              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   3408                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
   3409                  mbedtls_ssl_send_alert_message(
   3410                      ssl,
   3411                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3412                      MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   3413                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   3414              }
   3415          
   3416              /*
   3417               * struct {
   3418               *     uint32 ticket_lifetime_hint;
   3419               *     opaque ticket<0..2^16-1>;
   3420               * } NewSessionTicket;
   3421               *
   3422               * 0  .  3   ticket_lifetime_hint
   3423               * 4  .  5   ticket_len (n)
   3424               * 6  .  5+n ticket content
   3425               */
   3426              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
   3427                  ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len(ssl)) {
   3428                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
   3429                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3430                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   3431                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3432              }
   3433          
   3434              msg = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   3435          
   3436              lifetime = (((uint32_t) msg[0]) << 24) | (msg[1] << 16) |
   3437                         (msg[2] << 8) | (msg[3]);
   3438          
   3439              ticket_len = (msg[4] << 8) | (msg[5]);
   3440          
   3441              if (ticket_len + 6 + mbedtls_ssl_hs_hdr_len(ssl) != ssl->in_hslen) {
   3442                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
   3443                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3444                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   3445                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3446              }
   3447          
   3448              MBEDTLS_SSL_DEBUG_MSG(3, ("ticket length: %" MBEDTLS_PRINTF_SIZET, ticket_len));
   3449          
   3450              /* We're not waiting for a NewSessionTicket message any more */
   3451              ssl->handshake->new_session_ticket = 0;
   3452              ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   3453          
   3454              /*
   3455               * Zero-length ticket means the server changed his mind and doesn't want
   3456               * to send a ticket after all, so just forget it
   3457               */
   3458              if (ticket_len == 0) {
   3459                  return 0;
   3460              }
   3461          
   3462              if (ssl->session != NULL && ssl->session->ticket != NULL) {
   3463                  mbedtls_zeroize_and_free(ssl->session->ticket,
   3464                                           ssl->session->ticket_len);
   3465                  ssl->session->ticket = NULL;
   3466                  ssl->session->ticket_len = 0;
   3467              }
   3468          
   3469              mbedtls_zeroize_and_free(ssl->session_negotiate->ticket,
   3470                                       ssl->session_negotiate->ticket_len);
   3471              ssl->session_negotiate->ticket = NULL;
   3472              ssl->session_negotiate->ticket_len = 0;
   3473          
   3474              if ((ticket = mbedtls_calloc(1, ticket_len)) == NULL) {
   3475                  MBEDTLS_SSL_DEBUG_MSG(1, ("ticket alloc failed"));
   3476                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3477                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   3478                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   3479              }
   3480          
   3481              memcpy(ticket, msg + 6, ticket_len);
   3482          
   3483              ssl->session_negotiate->ticket = ticket;
   3484              ssl->session_negotiate->ticket_len = ticket_len;
   3485              ssl->session_negotiate->ticket_lifetime = lifetime;
   3486          
   3487              /*
   3488               * RFC 5077 section 3.4:
   3489               * "If the client receives a session ticket from the server, then it
   3490               * discards any Session ID that was sent in the ServerHello."
   3491               */
   3492              MBEDTLS_SSL_DEBUG_MSG(3, ("ticket in use, discarding session id"));
   3493              ssl->session_negotiate->id_len = 0;
   3494          
   3495              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse new session ticket"));
   3496          
   3497              return 0;
   3498          }
   3499          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   3500          
   3501          /*
   3502           * SSL handshake -- client side -- single step
   3503           */

   \                                 In section .text, align 4, keep-with-next
   3504          int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl)
   3505          {
   \                     mbedtls_ssl_handshake_client_step: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x4606             MOV      R6,R0
   3506              int ret = 0;
   3507          
   3508              /* Change state now, so that it is right in mbedtls_ssl_read_record(), used
   3509               * by DTLS for dropping out-of-sequence ChangeCipherSpec records */
   3510          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3511              if (ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC &&
   3512                  ssl->handshake->new_session_ticket != 0) {
   3513                  ssl->state = MBEDTLS_SSL_NEW_SESSION_TICKET;
   3514              }
   3515          #endif
   3516          
   3517              switch (ssl->state) {
   \        0x8   0x6870             LDR      R0,[R6, #+4]
   \        0xA   0xF04F 0x0800      MOV      R8,#+0
   \        0xE   0xF106 0x0788      ADD      R7,R6,#+136
   \       0x12   0x.... 0x....      LDR.W    R4,??DataTable3_1
   \       0x16   0x.... 0x....      ADR.W    R5,mbedtls_byte_order_detector
   \       0x1A   0x280F             CMP      R0,#+15
   \       0x1C   0xF200 0x83AE      BHI.W    ??mbedtls_ssl_handshake_client_step_1
   \       0x20   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??mbedtls_ssl_handshake_client_step_0:
   \       0x24   0x0010 0x0016      DC16     0x10,0x16,0x1B,0x134
   \               0x001B 0x013
   \              4
   \       0x2C   0x0138 0x023D      DC16     0x138,0x23D,0x284,0x297
   \               0x0284 0x029
   \              7
   \       0x34   0x029B 0x0313      DC16     0x29B,0x313,0x396,0x39A
   \               0x0396 0x039
   \              A
   \       0x3C   0x039E 0x03A2      DC16     0x39E,0x3A2,0x3A6,0x3A8
   \               0x03A6 0x03A
   \              8
   3518                  case MBEDTLS_SSL_HELLO_REQUEST:
   3519                      ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   \                     ??mbedtls_ssl_handshake_client_step_2: (+1)
   \       0x44   0x2101             MOVS     R1,#+1
   \                     ??mbedtls_ssl_handshake_client_step_3: (+1)
   \       0x46   0x6071             STR      R1,[R6, #+4]
   3520                      break;
   3521          
   3522                  /*
   3523                   *  ==>   ClientHello
   3524                   */
   3525                  case MBEDTLS_SSL_CLIENT_HELLO:
   3526                      ret = mbedtls_ssl_write_client_hello(ssl);
   3527                      break;
   3528          
   3529                  /*
   3530                   *  <==   ServerHello
   3531                   *        Certificate
   3532                   *      ( ServerKeyExchange  )
   3533                   *      ( CertificateRequest )
   3534                   *        ServerHelloDone
   3535                   */
   3536                  case MBEDTLS_SSL_SERVER_HELLO:
   3537                      ret = ssl_parse_server_hello(ssl);
   3538                      break;
   3539          
   3540                  case MBEDTLS_SSL_SERVER_CERTIFICATE:
   3541                      ret = mbedtls_ssl_parse_certificate(ssl);
   3542                      break;
   3543          
   3544                  case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
   3545                      ret = ssl_parse_server_key_exchange(ssl);
   3546                      break;
   3547          
   3548                  case MBEDTLS_SSL_CERTIFICATE_REQUEST:
   3549                      ret = ssl_parse_certificate_request(ssl);
   3550                      break;
   3551          
   3552                  case MBEDTLS_SSL_SERVER_HELLO_DONE:
   3553                      ret = ssl_parse_server_hello_done(ssl);
   3554                      break;
   3555          
   3556                  /*
   3557                   *  ==> ( Certificate/Alert  )
   3558                   *        ClientKeyExchange
   3559                   *      ( CertificateVerify  )
   3560                   *        ChangeCipherSpec
   3561                   *        Finished
   3562                   */
   3563                  case MBEDTLS_SSL_CLIENT_CERTIFICATE:
   3564                      ret = mbedtls_ssl_write_certificate(ssl);
   3565                      break;
   3566          
   3567                  case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
   3568                      ret = ssl_write_client_key_exchange(ssl);
   3569                      break;
   3570          
   3571                  case MBEDTLS_SSL_CERTIFICATE_VERIFY:
   3572                      ret = ssl_write_certificate_verify(ssl);
   3573                      break;
   3574          
   3575                  case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
   3576                      ret = mbedtls_ssl_write_change_cipher_spec(ssl);
   3577                      break;
   3578          
   3579                  case MBEDTLS_SSL_CLIENT_FINISHED:
   3580                      ret = mbedtls_ssl_write_finished(ssl);
   3581                      break;
   3582          
   3583                      /*
   3584                       *  <==   ( NewSessionTicket )
   3585                       *        ChangeCipherSpec
   3586                       *        Finished
   3587                       */
   3588          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3589                  case MBEDTLS_SSL_NEW_SESSION_TICKET:
   3590                      ret = ssl_parse_new_session_ticket(ssl);
   3591                      break;
   3592          #endif
   3593          
   3594                  case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
   3595                      ret = mbedtls_ssl_parse_change_cipher_spec(ssl);
   3596                      break;
   3597          
   3598                  case MBEDTLS_SSL_SERVER_FINISHED:
   3599                      ret = mbedtls_ssl_parse_finished(ssl);
   3600                      break;
   3601          
   3602                  case MBEDTLS_SSL_FLUSH_BUFFERS:
   3603                      MBEDTLS_SSL_DEBUG_MSG(2, ("handshake: done"));
   3604                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   3605                      break;
   3606          
   3607                  case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
   3608                      mbedtls_ssl_handshake_wrapup(ssl);
   3609                      break;
   3610          
   3611                  default:
   3612                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid state %d", ssl->state));
   3613                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3614              }
   3615          
   3616              return ret;
   \                     ??mbedtls_ssl_handshake_client_step_4: (+1)
   \       0x48   0x4640             MOV      R0,R8
   \                     ??mbedtls_ssl_handshake_client_step_5: (+1)
   \       0x4A   0xB015             ADD      SP,SP,#+84
   \       0x4C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??mbedtls_ssl_handshake_client_step_6: (+1)
   \       0x50   0x4630             MOV      R0,R6
   \       0x52   0x.... 0x....      BL       mbedtls_ssl_write_client_hello
   \                     ??mbedtls_ssl_handshake_client_step_7: (+1)
   \       0x56   0x4680             MOV      R8,R0
   \       0x58   0xE7F6             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_8: (+1)
   \       0x5A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD1F9             BNE.N    ??mbedtls_ssl_handshake_client_step_7
   \       0x62   0x6F70             LDR      R0,[R6, #+116]
   \       0x64   0xF8D6 0xA06C      LDR      R10,[R6, #+108]
   \       0x68   0x2816             CMP      R0,#+22
   \       0x6A   0xF040 0x8228      BNE.W    ??mbedtls_ssl_handshake_client_step_9
   \       0x6E   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \       0x72   0x282A             CMP      R0,#+42
   \       0x74   0xD339             BCC.N    ??mbedtls_ssl_handshake_client_step_10
   \       0x76   0xF81A 0x1B04      LDRB     R1,[R10], #+4
   \       0x7A   0x2902             CMP      R1,#+2
   \       0x7C   0xD135             BNE.N    ??mbedtls_ssl_handshake_client_step_10
   \       0x7E   0x6830             LDR      R0,[R6, #+0]
   \       0x80   0x7941             LDRB     R1,[R0, #+5]
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0x.... 0x....      BL       mbedtls_ssl_read_version
   \       0x88   0x8130             STRH     R0,[R6, #+8]
   \       0x8A   0x4601             MOV      R1,R0
   \       0x8C   0x6B70             LDR      R0,[R6, #+52]
   \       0x8E   0x8041             STRH     R1,[R0, #+2]
   \       0x90   0x6832             LDR      R2,[R6, #+0]
   \       0x92   0xF9B6 0x0008      LDRSH    R0,[R6, #+8]
   \       0x96   0xF9B2 0x1002      LDRSH    R1,[R2, #+2]
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xBFA4             ITT      GE
   \       0x9E   0xF932 0x2008      LDRSHGE  R2,[R2, R8]
   \       0xA2   0x4282             CMPGE    R2,R0
   \       0xA4   0xF2C0 0x80EC      BLT.W    ??mbedtls_ssl_handshake_client_step_11
   \       0xA8   0x6BB0             LDR      R0,[R6, #+56]
   \       0xAA   0x2220             MOVS     R2,#+32
   \       0xAC   0xF10A 0x0102      ADD      R1,R10,#+2
   \       0xB0   0xF500 0x7006      ADD      R0,R0,#+536
   \       0xB4   0x.... 0x....      BL       __aeabi_memcpy
   \       0xB8   0xF89A 0x5022      LDRB     R5,[R10, #+34]
   \       0xBC   0x2D20             CMP      R5,#+32
   \       0xBE   0xD814             BHI.N    ??mbedtls_ssl_handshake_client_step_10
   \       0xC0   0xF8D6 0x1080      LDR      R1,[R6, #+128]
   \       0xC4   0xEB0A 0x0905      ADD      R9,R10,R5
   \       0xC8   0xF105 0x032B      ADD      R3,R5,#+43
   \       0xCC   0xF109 0x0023      ADD      R0,R9,#+35
   \       0xD0   0x428B             CMP      R3,R1
   \       0xD2   0xD210             BCS.N    ??mbedtls_ssl_handshake_client_step_12
   \       0xD4   0x78C2             LDRB     R2,[R0, #+3]
   \       0xD6   0x7904             LDRB     R4,[R0, #+4]
   \       0xD8   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   \       0xDC   0xD001             BEQ.N    ??mbedtls_ssl_handshake_client_step_13
   \       0xDE   0x2C04             CMP      R4,#+4
   \       0xE0   0xD303             BCC.N    ??mbedtls_ssl_handshake_client_step_10
   \                     ??mbedtls_ssl_handshake_client_step_13: (+1)
   \       0xE2   0x392C             SUBS     R1,R1,#+44
   \       0xE4   0x1962             ADDS     R2,R4,R5
   \       0xE6   0x4291             CMP      R1,R2
   \       0xE8   0xD009             BEQ.N    ??mbedtls_ssl_handshake_client_step_14
   \                     ??mbedtls_ssl_handshake_client_step_10: (+1)
   \       0xEA   0x2232             MOVS     R2,#+50
   \       0xEC   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xF0   0x.... 0x....      LDR.W    R8,??DataTable3_2
   \       0xF4   0xE7A8             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_12: (+1)
   \       0xF6   0x392A             SUBS     R1,R1,#+42
   \       0xF8   0x42A9             CMP      R1,R5
   \                     ??mbedtls_ssl_handshake_client_step_15: (+1)
   \       0xFA   0xD1F6             BNE.N    ??mbedtls_ssl_handshake_client_step_10
   \       0xFC   0x2400             MOVS     R4,#+0
   \                     ??mbedtls_ssl_handshake_client_step_14: (+1)
   \       0xFE   0x7801             LDRB     R1,[R0, #+0]
   \      0x100   0x7842             LDRB     R2,[R0, #+1]
   \      0x102   0x7880             LDRB     R0,[R0, #+2]
   \      0x104   0xEA42 0x2B01      ORR      R11,R2,R1, LSL #+8
   \      0x108   0xB120             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_16
   \      0x10A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x10E   0x.... 0x....      LDR.W    R8,??DataTable3_3
   \      0x112   0xE799             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_16: (+1)
   \      0x114   0x4658             MOV      R0,R11
   \      0x116   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_from_id
   \      0x11A   0x6BB1             LDR      R1,[R6, #+56]
   \      0x11C   0x6088             STR      R0,[R1, #+8]
   \      0x11E   0x0001             MOVS     R1,R0
   \      0x120   0xD105             BNE.N    ??mbedtls_ssl_handshake_client_step_17
   \      0x122   0x2250             MOVS     R2,#+80
   \      0x124   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x128   0x.... 0x....      LDR.W    R8,??DataTable3_4
   \      0x12C   0xE78C             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_17: (+1)
   \      0x12E   0x4630             MOV      R0,R6
   \      0x130   0x.... 0x....      BL       mbedtls_ssl_optimize_checksum
   \      0x134   0x6BB0             LDR      R0,[R6, #+56]
   \      0x136   0x9000             STR      R0,[SP, #+0]
   \      0x138   0x7800             LDRB     R0,[R0, #+0]
   \      0x13A   0x2800             CMP      R0,#+0
   \      0x13C   0xBF18             IT       NE
   \      0x13E   0x2D00             CMPNE    R5,#+0
   \      0x140   0xD010             BEQ.N    ??mbedtls_ssl_handshake_client_step_18
   \      0x142   0x6B70             LDR      R0,[R6, #+52]
   \      0x144   0x6841             LDR      R1,[R0, #+4]
   \      0x146   0x4559             CMP      R1,R11
   \      0x148   0xBF04             ITT      EQ
   \      0x14A   0x6882             LDREQ    R2,[R0, #+8]
   \      0x14C   0x42AA             CMPEQ    R2,R5
   \      0x14E   0xD109             BNE.N    ??mbedtls_ssl_handshake_client_step_18
   \      0x150   0x462A             MOV      R2,R5
   \      0x152   0xF10A 0x0123      ADD      R1,R10,#+35
   \      0x156   0x300C             ADDS     R0,R0,#+12
   \      0x158   0x.... 0x....      BL       memcmp
   \      0x15C   0xB910             CBNZ.N   R0,??mbedtls_ssl_handshake_client_step_18
   \      0x15E   0x200C             MOVS     R0,#+12
   \      0x160   0x6070             STR      R0,[R6, #+4]
   \      0x162   0xE00F             B.N      ??mbedtls_ssl_handshake_client_step_19
   \                     ??mbedtls_ssl_handshake_client_step_18: (+1)
   \      0x164   0x6871             LDR      R1,[R6, #+4]
   \      0x166   0x462A             MOV      R2,R5
   \      0x168   0x1C49             ADDS     R1,R1,#+1
   \      0x16A   0x6071             STR      R1,[R6, #+4]
   \      0x16C   0x9900             LDR      R1,[SP, #+0]
   \      0x16E   0xF881 0x8000      STRB     R8,[R1, #+0]
   \      0x172   0x6B70             LDR      R0,[R6, #+52]
   \      0x174   0xF10A 0x0123      ADD      R1,R10,#+35
   \      0x178   0xF8C0 0xB004      STR      R11,[R0, #+4]
   \      0x17C   0x6085             STR      R5,[R0, #+8]
   \      0x17E   0x300C             ADDS     R0,R0,#+12
   \      0x180   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??mbedtls_ssl_handshake_client_step_19: (+1)
   \      0x184   0x6B72             LDR      R2,[R6, #+52]
   \      0x186   0x46C4             MOV      R12,R8
   \      0x188   0x6833             LDR      R3,[R6, #+0]
   \      0x18A   0x6851             LDR      R1,[R2, #+4]
   \                     ??mbedtls_ssl_handshake_client_step_20: (+1)
   \      0x18C   0x68D8             LDR      R0,[R3, #+12]
   \      0x18E   0xF850 0x002C      LDR      R0,[R0, R12, LSL #+2]
   \      0x192   0x2800             CMP      R0,#+0
   \      0x194   0xD04D             BEQ.N    ??mbedtls_ssl_handshake_client_step_21
   \      0x196   0xF10C 0x0C01      ADD      R12,R12,#+1
   \      0x19A   0x4288             CMP      R0,R1
   \      0x19C   0xD1F6             BNE.N    ??mbedtls_ssl_handshake_client_step_20
   \      0x19E   0x4608             MOV      R0,R1
   \      0x1A0   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_from_id
   \      0x1A4   0xF9B6 0x2008      LDRSH    R2,[R6, #+8]
   \      0x1A8   0x4601             MOV      R1,R0
   \      0x1AA   0x4630             MOV      R0,R6
   \      0x1AC   0x4613             MOV      R3,R2
   \      0x1AE   0x.... 0x....      BL       mbedtls_ssl_validate_ciphersuite
   \      0x1B2   0x2800             CMP      R0,#+0
   \      0x1B4   0xD15E             BNE.N    ??mbedtls_ssl_handshake_client_step_22
   \      0x1B6   0xF109 0x0328      ADD      R3,R9,#+40
   \      0x1BA   0x2C00             CMP      R4,#+0
   \      0x1BC   0xD046             BEQ.N    ??mbedtls_ssl_handshake_client_step_23
   \                     ??mbedtls_ssl_handshake_client_step_24: (+1)
   \      0x1BE   0x7898             LDRB     R0,[R3, #+2]
   \      0x1C0   0x78DA             LDRB     R2,[R3, #+3]
   \      0x1C2   0xEA42 0x2200      ORR      R2,R2,R0, LSL #+8
   \      0x1C6   0x1D10             ADDS     R0,R2,#+4
   \      0x1C8   0x4284             CMP      R4,R0
   \      0x1CA   0xD38E             BCC.N    ??mbedtls_ssl_handshake_client_step_10
   \      0x1CC   0x7819             LDRB     R1,[R3, #+0]
   \      0x1CE   0x7858             LDRB     R0,[R3, #+1]
   \      0x1D0   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \      0x1D4   0x2801             CMP      R0,#+1
   \      0x1D6   0xD01C             BEQ.N    ??mbedtls_ssl_handshake_client_step_25
   \      0x1D8   0x280B             CMP      R0,#+11
   \      0x1DA   0xD004             BEQ.N    ??mbedtls_ssl_handshake_client_step_26
   \      0x1DC   0xF64F 0x7101      MOVW     R1,#+65281
   \      0x1E0   0x4288             CMP      R0,R1
   \      0x1E2   0xD02B             BEQ.N    ??mbedtls_ssl_handshake_client_step_27
   \      0x1E4   0xE01D             B.N      ??mbedtls_ssl_handshake_client_step_28
   \                     ??mbedtls_ssl_handshake_client_step_26: (+1)
   \      0x1E6   0x2A00             CMP      R2,#+0
   \      0x1E8   0xF43F 0xAF7F      BEQ.W    ??mbedtls_ssl_handshake_client_step_10
   \      0x1EC   0x7918             LDRB     R0,[R3, #+4]
   \      0x1EE   0x1C41             ADDS     R1,R0,#+1
   \      0x1F0   0x4291             CMP      R1,R2
   \      0x1F2   0xD182             BNE.N    ??mbedtls_ssl_handshake_client_step_15
   \      0x1F4   0xF103 0x0C05      ADD      R12,R3,#+5
   \                     ??mbedtls_ssl_handshake_client_step_29: (+1)
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD03B             BEQ.N    ??mbedtls_ssl_handshake_client_step_22
   \      0x1FC   0xF89C 0x1000      LDRB     R1,[R12, #+0]
   \      0x200   0xB179             CBZ.N    R1,??mbedtls_ssl_handshake_client_step_28
   \      0x202   0xF81C 0xEB01      LDRB     LR,[R12], #+1
   \      0x206   0xF1BE 0x0F01      CMP      LR,#+1
   \      0x20A   0xBF18             IT       NE
   \      0x20C   0x1E40             SUBNE    R0,R0,#+1
   \      0x20E   0xD1F3             BNE.N    ??mbedtls_ssl_handshake_client_step_29
   \      0x210   0xE007             B.N      ??mbedtls_ssl_handshake_client_step_28
   \                     ??mbedtls_ssl_handshake_client_step_25: (+1)
   \      0x212   0x6830             LDR      R0,[R6, #+0]
   \      0x214   0x7A00             LDRB     R0,[R0, #+8]
   \      0x216   0xB160             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_21
   \      0x218   0x2A01             CMP      R2,#+1
   \      0x21A   0xBF04             ITT      EQ
   \      0x21C   0x7919             LDRBEQ   R1,[R3, #+4]
   \      0x21E   0x4281             CMPEQ    R1,R0
   \      0x220   0xD107             BNE.N    ??mbedtls_ssl_handshake_client_step_21
   \                     ??mbedtls_ssl_handshake_client_step_28: (+1)
   \      0x222   0x1AA4             SUBS     R4,R4,R2
   \      0x224   0x1D18             ADDS     R0,R3,#+4
   \      0x226   0x1F24             SUBS     R4,R4,#+4
   \      0x228   0x1883             ADDS     R3,R0,R2
   \      0x22A   0xB17C             CBZ.N    R4,??mbedtls_ssl_handshake_client_step_23
   \      0x22C   0x2C04             CMP      R4,#+4
   \      0x22E   0xD2C6             BCS.N    ??mbedtls_ssl_handshake_client_step_24
   \      0x230   0xE75E             B.N      ??CrossCallReturnLabel_3
   \                     ??mbedtls_ssl_handshake_client_step_21: (+1)
   \      0x232   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6: (+1)
   \      0x236   0x.... 0x....      LDR.W    R8,??DataTable3_5
   \      0x23A   0xE705             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_27: (+1)
   \      0x23C   0x2A01             CMP      R2,#+1
   \      0x23E   0xBF04             ITT      EQ
   \      0x240   0x7918             LDRBEQ   R0,[R3, #+4]
   \      0x242   0x2800             CMPEQ    R0,#+0
   \      0x244   0xD116             BNE.N    ??mbedtls_ssl_handshake_client_step_22
   \      0x246   0x2101             MOVS     R1,#+1
   \      0x248   0x63F9             STR      R1,[R7, #+60]
   \      0x24A   0xE7EA             B.N      ??mbedtls_ssl_handshake_client_step_28
   \                     ??mbedtls_ssl_handshake_client_step_23: (+1)
   \      0x24C   0x6BB1             LDR      R1,[R6, #+56]
   \      0x24E   0x7808             LDRB     R0,[R1, #+0]
   \      0x250   0xB148             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_30
   \      0x252   0x4630             MOV      R0,R6
   \      0x254   0x.... 0x....      BL       mbedtls_ssl_derive_keys
   \      0x258   0x0004             MOVS     R4,R0
   \      0x25A   0xD004             BEQ.N    ??mbedtls_ssl_handshake_client_step_30
   \      0x25C   0x2250             MOVS     R2,#+80
   \                     ??mbedtls_ssl_handshake_client_step_31: (+1)
   \      0x25E   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \      0x262   0x46A0             MOV      R8,R4
   \                     ??mbedtls_ssl_handshake_client_step_32: (+1)
   \      0x264   0xE6F0             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_30: (+1)
   \      0x266   0x6BF8             LDR      R0,[R7, #+60]
   \      0x268   0x2800             CMP      R0,#+0
   \      0x26A   0xBF02             ITTT     EQ
   \      0x26C   0x6831             LDREQ    R1,[R6, #+0]
   \      0x26E   0x79C8             LDRBEQ   R0,[R1, #+7]
   \      0x270   0x2802             CMPEQ    R0,#+2
   \      0x272   0xD1F7             BNE.N    ??mbedtls_ssl_handshake_client_step_32
   \                     ??mbedtls_ssl_handshake_client_step_22: (+1)
   \      0x274   0x2228             MOVS     R2,#+40
   \      0x276   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x27A   0x.... 0x....      LDR.W    R8,??DataTable3_6
   \      0x27E   0xE6E3             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_11: (+1)
   \      0x280   0x2246             MOVS     R2,#+70
   \      0x282   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \      0x286   0x.... 0x....      LDR.W    R8,??DataTable3_7
   \      0x28A   0xE6DD             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_33: (+1)
   \      0x28C   0x4630             MOV      R0,R6
   \      0x28E   0x.... 0x....      BL       mbedtls_ssl_parse_certificate
   \                     ??mbedtls_ssl_handshake_client_step_34: (+1)
   \      0x292   0xE6E0             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_35: (+1)
   \      0x294   0x6BB1             LDR      R1,[R6, #+56]
   \      0x296   0x6888             LDR      R0,[R1, #+8]
   \      0x298   0x2101             MOVS     R1,#+1
   \      0x29A   0x9003             STR      R0,[SP, #+12]
   \      0x29C   0x4630             MOV      R0,R6
   \      0x29E   0x.... 0x....      BL       mbedtls_ssl_read_record
   \      0x2A2   0x2800             CMP      R0,#+0
   \      0x2A4   0xD1F5             BNE.N    ??mbedtls_ssl_handshake_client_step_34
   \      0x2A6   0x6F70             LDR      R0,[R6, #+116]
   \      0x2A8   0x2816             CMP      R0,#+22
   \      0x2AA   0xD108             BNE.N    ??mbedtls_ssl_handshake_client_step_36
   \      0x2AC   0x6EF2             LDR      R2,[R6, #+108]
   \      0x2AE   0x9803             LDR      R0,[SP, #+12]
   \      0x2B0   0x7811             LDRB     R1,[R2, #+0]
   \      0x2B2   0x7A80             LDRB     R0,[R0, #+10]
   \      0x2B4   0x290C             CMP      R1,#+12
   \      0x2B6   0xD009             BEQ.N    ??mbedtls_ssl_handshake_client_step_37
   \      0x2B8   0x2805             CMP      R0,#+5
   \      0x2BA   0xBF18             IT       NE
   \      0x2BC   0x2807             CMPNE    R0,#+7
   \                     ??mbedtls_ssl_handshake_client_step_36: (+1)
   \      0x2BE   0xF040 0x80FE      BNE.W    ??mbedtls_ssl_handshake_client_step_9
   \      0x2C2   0x2001             MOVS     R0,#+1
   \      0x2C4   0x6038             STR      R0,[R7, #+0]
   \                     ??mbedtls_ssl_handshake_client_step_38: (+1)
   \      0x2C6   0x6871             LDR      R1,[R6, #+4]
   \      0x2C8   0x1C49             ADDS     R1,R1,#+1
   \      0x2CA   0xE6BC             B.N      ??mbedtls_ssl_handshake_client_step_3
   \                     ??mbedtls_ssl_handshake_client_step_37: (+1)
   \      0x2CC   0xF8D6 0x3080      LDR      R3,[R6, #+128]
   \      0x2D0   0x1D11             ADDS     R1,R2,#+4
   \      0x2D2   0x18D4             ADDS     R4,R2,R3
   \      0x2D4   0x2803             CMP      R0,#+3
   \      0x2D6   0xBF1C             ITT      NE
   \      0x2D8   0x2808             CMPNE    R0,#+8
   \      0x2DA   0x2804             CMPNE    R0,#+4
   \      0x2DC   0xF040 0x8148      BNE.W    ??mbedtls_ssl_handshake_client_step_39
   \      0x2E0   0xF8D6 0xB038      LDR      R11,[R6, #+56]
   \      0x2E4   0x1A60             SUBS     R0,R4,R1
   \      0x2E6   0xF8AD 0x8004      STRH     R8,[SP, #+4]
   \      0x2EA   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x2EE   0x2804             CMP      R0,#+4
   \      0x2F0   0xDB9F             BLT.N    ??mbedtls_ssl_handshake_client_step_21
   \      0x2F2   0xF811 0x2B01      LDRB     R2,[R1], #+1
   \      0x2F6   0x2A03             CMP      R2,#+3
   \      0x2F8   0xD19B             BNE.N    ??mbedtls_ssl_handshake_client_step_21
   \      0x2FA   0x7808             LDRB     R0,[R1, #+0]
   \      0x2FC   0x784A             LDRB     R2,[R1, #+1]
   \      0x2FE   0xF101 0x0902      ADD      R9,R1,#+2
   \      0x302   0xEA42 0x2700      ORR      R7,R2,R0, LSL #+8
   \      0x306   0x4630             MOV      R0,R6
   \      0x308   0x4639             MOV      R1,R7
   \      0x30A   0x.... 0x....      BL       mbedtls_ssl_check_curve_tls_id
   \      0x30E   0x2800             CMP      R0,#+0
   \                     ??mbedtls_ssl_handshake_client_step_40: (+1)
   \      0x310   0xD18F             BNE.N    ??mbedtls_ssl_handshake_client_step_21
   \      0x312   0xAA02             ADD      R2,SP,#+8
   \      0x314   0xA901             ADD      R1,SP,#+4
   \      0x316   0x4638             MOV      R0,R7
   \      0x318   0x.... 0x....      BL       mbedtls_ssl_get_psa_curve_info_from_tls_id
   \      0x31C   0xF110 0x0F86      CMN      R0,#+134
   \      0x320   0xD087             BEQ.N    ??mbedtls_ssl_handshake_client_step_21
   \      0x322   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \      0x326   0xF10B 0x0A4C      ADD      R10,R11,#+76
   \      0x32A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x32E   0x9902             LDR      R1,[SP, #+8]
   \      0x330   0xF8CA 0x1004      STR      R1,[R10, #+4]
   \      0x334   0xF819 0x0B01      LDRB     R0,[R9], #+1
   \      0x338   0xEBA4 0x0709      SUB      R7,R4,R9
   \      0x33C   0x4287             CMP      R7,R0
   \      0x33E   0x9000             STR      R0,[SP, #+0]
   \      0x340   0xF4FF 0xAF77      BCC.W    ??mbedtls_ssl_handshake_client_step_21
   \      0x344   0x2842             CMP      R0,#+66
   \      0x346   0xF4BF 0xAF74      BCS.W    ??mbedtls_ssl_handshake_client_step_21
   \      0x34A   0x4602             MOV      R2,R0
   \      0x34C   0x4649             MOV      R1,R9
   \      0x34E   0xF10B 0x0059      ADD      R0,R11,#+89
   \      0x352   0x.... 0x....      BL       __aeabi_memcpy
   \      0x356   0x9800             LDR      R0,[SP, #+0]
   \      0x358   0xF8CA 0x0050      STR      R0,[R10, #+80]
   \      0x35C   0x9A03             LDR      R2,[SP, #+12]
   \      0x35E   0x9900             LDR      R1,[SP, #+0]
   \      0x360   0x7A90             LDRB     R0,[R2, #+10]
   \      0x362   0x1E80             SUBS     R0,R0,#+2
   \      0x364   0xEB09 0x0B01      ADD      R11,R9,R1
   \      0x368   0x2802             CMP      R0,#+2
   \      0x36A   0xD8AC             BHI.N    ??mbedtls_ssl_handshake_client_step_38
   \      0x36C   0x6EF2             LDR      R2,[R6, #+108]
   \      0x36E   0x1D10             ADDS     R0,R2,#+4
   \      0x370   0xEBAB 0x0100      SUB      R1,R11,R0
   \      0x374   0x9002             STR      R0,[SP, #+8]
   \      0x376   0x9105             STR      R1,[SP, #+20]
   \      0x378   0x6B72             LDR      R2,[R6, #+52]
   \      0x37A   0x6DD0             LDR      R0,[R2, #+92]
   \      0x37C   0x2800             CMP      R0,#+0
   \      0x37E   0xD064             BEQ.N    ??mbedtls_ssl_handshake_client_step_41
   \      0x380   0x30CC             ADDS     R0,R0,#+204
   \      0x382   0x9003             STR      R0,[SP, #+12]
   \      0x384   0x2202             MOVS     R2,#+2
   \      0x386   0x4621             MOV      R1,R4
   \      0x388   0x4658             MOV      R0,R11
   \      0x38A   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \      0x38E   0xB130             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_42
   \      0x390   0x.... 0x....      LDR.W    R2,??DataTable3_2
   \      0x394   0x2132             MOVS     R1,#+50
   \      0x396   0x4630             MOV      R0,R6
   \      0x398   0x.... 0x....      BL       mbedtls_ssl_pend_fatal_alert
   \      0x39C   0xE6A8             B.N      ??CrossCallReturnLabel_3
   \                     ??mbedtls_ssl_handshake_client_step_42: (+1)
   \      0x39E   0x7828             LDRB     R0,[R5, #+0]
   \      0x3A0   0x2801             CMP      R0,#+1
   \      0x3A2   0x4658             MOV      R0,R11
   \      0x3A4   0xD103             BNE.N    ??mbedtls_ssl_handshake_client_step_43
   \      0x3A6   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \      0x3AA   0x4607             MOV      R7,R0
   \      0x3AC   0xE004             B.N      ??mbedtls_ssl_handshake_client_step_44
   \                     ??mbedtls_ssl_handshake_client_step_43: (+1)
   \      0x3AE   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \      0x3B2   0x0A07             LSRS     R7,R0,#+8
   \      0x3B4   0xEA47 0x2700      ORR      R7,R7,R0, LSL #+8
   \                     ??mbedtls_ssl_handshake_client_step_44: (+1)
   \      0x3B8   0xB2F8             UXTB     R0,R7
   \      0x3BA   0x.... 0x....      BL       mbedtls_ssl_pk_alg_from_sig
   \      0x3BE   0x4605             MOV      R5,R0
   \      0x3C0   0x0438             LSLS     R0,R7,#+16
   \      0x3C2   0xEA4F 0x6910      LSR      R9,R0,#+24
   \      0x3C6   0x4648             MOV      R0,R9
   \      0x3C8   0x.... 0x....      BL       mbedtls_ssl_md_alg_from_hash
   \      0x3CC   0x4682             MOV      R10,R0
   \      0x3CE   0x2D00             CMP      R5,#+0
   \      0x3D0   0xBF18             IT       NE
   \      0x3D2   0xF1BA 0x0F00      CMPNE    R10,#+0
   \      0x3D6   0xD11F             BNE.N    ??mbedtls_ssl_handshake_client_step_45
   \      0x3D8   0x6BB0             LDR      R0,[R6, #+56]
   \      0x3DA   0xB120             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_46
   \      0x3DC   0x7941             LDRB     R1,[R0, #+5]
   \      0x3DE   0x2901             CMP      R1,#+1
   \      0x3E0   0xD101             BNE.N    ??mbedtls_ssl_handshake_client_step_46
   \      0x3E2   0x6C80             LDR      R0,[R0, #+72]
   \      0x3E4   0xB908             CBNZ.N   R0,??mbedtls_ssl_handshake_client_step_47
   \                     ??mbedtls_ssl_handshake_client_step_46: (+1)
   \      0x3E6   0x6830             LDR      R0,[R6, #+0]
   \      0x3E8   0x6C80             LDR      R0,[R0, #+72]
   \                     ??mbedtls_ssl_handshake_client_step_47: (+1)
   \      0x3EA   0xB138             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_48
   \                     ??mbedtls_ssl_handshake_client_step_49: (+1)
   \      0x3EC   0x8801             LDRH     R1,[R0, #+0]
   \      0x3EE   0xB129             CBZ.N    R1,??mbedtls_ssl_handshake_client_step_48
   \      0x3F0   0xF830 0x2B02      LDRH     R2,[R0], #+2
   \      0x3F4   0xB2BB             UXTH     R3,R7
   \      0x3F6   0x429A             CMP      R2,R3
   \      0x3F8   0xD1F8             BNE.N    ??mbedtls_ssl_handshake_client_step_49
   \      0x3FA   0xE00D             B.N      ??mbedtls_ssl_handshake_client_step_45
   \                     ??mbedtls_ssl_handshake_client_step_48: (+1)
   \      0x3FC   0xF9B6 0x1008      LDRSH    R1,[R6, #+8]
   \      0x400   0xF240 0x3003      MOVW     R0,#+771
   \      0x404   0x4281             CMP      R1,R0
   \      0x406   0xD183             BNE.N    ??mbedtls_ssl_handshake_client_step_40
   \      0x408   0xF1A9 0x0002      SUB      R0,R9,#+2
   \      0x40C   0x2802             CMP      R0,#+2
   \      0x40E   0xD801             BHI.N    ??mbedtls_ssl_handshake_client_step_50
   \      0x410   0xB2FF             UXTB     R7,R7
   \      0x412   0x2F03             CMP      R7,#+3
   \                     ??mbedtls_ssl_handshake_client_step_50: (+1)
   \      0x414   0xF47F 0xAF0D      BNE.W    ??mbedtls_ssl_handshake_client_step_21
   \                     ??mbedtls_ssl_handshake_client_step_45: (+1)
   \      0x418   0x9803             LDR      R0,[SP, #+12]
   \      0x41A   0x4629             MOV      R1,R5
   \      0x41C   0xF10B 0x0702      ADD      R7,R11,#+2
   \      0x420   0x.... 0x....      BL       mbedtls_pk_can_do
   \      0x424   0x2800             CMP      R0,#+0
   \      0x426   0xF43F 0xAF04      BEQ.W    ??mbedtls_ssl_handshake_client_step_21
   \      0x42A   0x1EA1             SUBS     R1,R4,#+2
   \      0x42C   0x42B9             CMP      R1,R7
   \      0x42E   0xF4FF 0xAE5C      BCC.W    ??mbedtls_ssl_handshake_client_step_10
   \      0x432   0x7838             LDRB     R0,[R7, #+0]
   \      0x434   0x7879             LDRB     R1,[R7, #+1]
   \      0x436   0x1CBF             ADDS     R7,R7,#+2
   \      0x438   0xEA41 0x2900      ORR      R9,R1,R0, LSL #+8
   \      0x43C   0xF1C9 0x0000      RSB      R0,R9,#+0
   \      0x440   0x4420             ADD      R0,R4,R0
   \      0x442   0x4287             CMP      R7,R0
   \      0x444   0xD171             BNE.N    ??mbedtls_ssl_handshake_client_step_51
   \      0x446   0xF1BA 0x0F00      CMP      R10,#+0
   \                     ??mbedtls_ssl_handshake_client_step_41: (+1)
   \      0x44A   0xF000 0x8091      BEQ.W    ??mbedtls_ssl_handshake_client_step_39
   \      0x44E   0x9805             LDR      R0,[SP, #+20]
   \      0x450   0x9B02             LDR      R3,[SP, #+8]
   \      0x452   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \      0x456   0x9000             STR      R0,[SP, #+0]
   \      0x458   0xAA04             ADD      R2,SP,#+16
   \      0x45A   0xA906             ADD      R1,SP,#+24
   \      0x45C   0x4630             MOV      R0,R6
   \      0x45E   0x.... 0x....      BL       mbedtls_ssl_get_key_exchange_md_tls1_2
   \      0x462   0x2800             CMP      R0,#+0
   \      0x464   0xF47F 0xADF7      BNE.W    ??mbedtls_ssl_handshake_client_step_7
   \      0x468   0x9803             LDR      R0,[SP, #+12]
   \      0x46A   0x4629             MOV      R1,R5
   \      0x46C   0x.... 0x....      BL       mbedtls_pk_can_do
   \      0x470   0xB178             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_52
   \      0x472   0x9B04             LDR      R3,[SP, #+16]
   \      0x474   0x9803             LDR      R0,[SP, #+12]
   \      0x476   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x47A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \      0x47E   0x9700             STR      R7,[SP, #+0]
   \      0x480   0xAA06             ADD      R2,SP,#+24
   \      0x482   0x4651             MOV      R1,R10
   \      0x484   0x.... 0x....      BL       mbedtls_pk_verify_restartable
   \      0x488   0x0004             MOVS     R4,R0
   \      0x48A   0xF43F 0xAF1C      BEQ.W    ??mbedtls_ssl_handshake_client_step_38
   \      0x48E   0x2233             MOVS     R2,#+51
   \      0x490   0xE6E5             B.N      ??mbedtls_ssl_handshake_client_step_31
   \                     ??mbedtls_ssl_handshake_client_step_52: (+1)
   \      0x492   0x2228             MOVS     R2,#+40
   \      0x494   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_10: (+1)
   \      0x498   0x.... 0x....      LDR.W    R8,??DataTable3_8
   \      0x49C   0xE5D4             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_53: (+1)
   \      0x49E   0x6BB0             LDR      R0,[R6, #+56]
   \      0x4A0   0x6882             LDR      R2,[R0, #+8]
   \      0x4A2   0x7A90             LDRB     R0,[R2, #+10]
   \      0x4A4   0x1E40             SUBS     R0,R0,#+1
   \      0x4A6   0x2803             CMP      R0,#+3
   \      0x4A8   0xBF84             ITT      HI
   \      0x4AA   0x3808             SUBHI    R0,R0,#+8
   \      0x4AC   0x2801             CMPHI    R0,#+1
   \      0x4AE   0xD808             BHI.N    ??mbedtls_ssl_handshake_client_step_54
   \      0x4B0   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \      0x4B4   0x2800             CMP      R0,#+0
   \      0x4B6   0xD14F             BNE.N    ??mbedtls_ssl_handshake_client_step_55
   \      0x4B8   0x6F70             LDR      R0,[R6, #+116]
   \      0x4BA   0x2816             CMP      R0,#+22
   \      0x4BC   0xD004             BEQ.N    ??mbedtls_ssl_handshake_client_step_56
   \                     ??mbedtls_ssl_handshake_client_step_9: (+1)
   \      0x4BE   0x220A             MOVS     R2,#+10
   \      0x4C0   0xE6CD             B.N      ??mbedtls_ssl_handshake_client_step_31
   \                     ??mbedtls_ssl_handshake_client_step_54: (+1)
   \      0x4C2   0x2006             MOVS     R0,#+6
   \                     ??mbedtls_ssl_handshake_client_step_57: (+1)
   \      0x4C4   0x6070             STR      R0,[R6, #+4]
   \      0x4C6   0xE5BF             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_56: (+1)
   \      0x4C8   0x6870             LDR      R0,[R6, #+4]
   \      0x4CA   0x6EF1             LDR      R1,[R6, #+108]
   \      0x4CC   0x1C40             ADDS     R0,R0,#+1
   \      0x4CE   0x6070             STR      R0,[R6, #+4]
   \      0x4D0   0x7808             LDRB     R0,[R1, #+0]
   \      0x4D2   0x280D             CMP      R0,#+13
   \      0x4D4   0xBF0C             ITE      EQ
   \      0x4D6   0x2001             MOVEQ    R0,#+1
   \      0x4D8   0x2000             MOVNE    R0,#+0
   \      0x4DA   0x6BB1             LDR      R1,[R6, #+56]
   \      0x4DC   0xF881 0x01CC      STRB     R0,[R1, #+460]
   \      0x4E0   0x6BB2             LDR      R2,[R6, #+56]
   \      0x4E2   0xF892 0x01CC      LDRB     R0,[R2, #+460]
   \      0x4E6   0xB910             CBNZ.N   R0,??mbedtls_ssl_handshake_client_step_58
   \      0x4E8   0x2101             MOVS     R1,#+1
   \      0x4EA   0x6039             STR      R1,[R7, #+0]
   \                     ??mbedtls_ssl_handshake_client_step_59: (+1)
   \      0x4EC   0xE5AC             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_58: (+1)
   \      0x4EE   0xF8D6 0x1080      LDR      R1,[R6, #+128]
   \      0x4F2   0x6EF0             LDR      R0,[R6, #+108]
   \      0x4F4   0x2904             CMP      R1,#+4
   \      0x4F6   0xD918             BLS.N    ??mbedtls_ssl_handshake_client_step_51
   \      0x4F8   0x7902             LDRB     R2,[R0, #+4]
   \      0x4FA   0x1D94             ADDS     R4,R2,#+6
   \      0x4FC   0x428C             CMP      R4,R1
   \      0x4FE   0xD214             BCS.N    ??mbedtls_ssl_handshake_client_step_51
   \      0x500   0x1D47             ADDS     R7,R0,#+5
   \      0x502   0x1D84             ADDS     R4,R0,#+6
   \      0x504   0x5CBB             LDRB     R3,[R7, R2]
   \      0x506   0x5CA4             LDRB     R4,[R4, R2]
   \      0x508   0xEA44 0x2403      ORR      R4,R4,R3, LSL #+8
   \      0x50C   0x18A2             ADDS     R2,R4,R2
   \      0x50E   0x1DD3             ADDS     R3,R2,#+7
   \      0x510   0x428B             CMP      R3,R1
   \      0x512   0xD20A             BCS.N    ??mbedtls_ssl_handshake_client_step_51
   \      0x514   0x1C92             ADDS     R2,R2,#+2
   \      0x516   0x1D44             ADDS     R4,R0,#+5
   \      0x518   0x5CA3             LDRB     R3,[R4, R2]
   \      0x51A   0x1D80             ADDS     R0,R0,#+6
   \      0x51C   0x5C84             LDRB     R4,[R0, R2]
   \      0x51E   0x1FC9             SUBS     R1,R1,#+7
   \      0x520   0xEA44 0x2403      ORR      R4,R4,R3, LSL #+8
   \      0x524   0x18A2             ADDS     R2,R4,R2
   \      0x526   0x4291             CMP      R1,R2
   \      0x528   0xD0E0             BEQ.N    ??mbedtls_ssl_handshake_client_step_59
   \                     ??mbedtls_ssl_handshake_client_step_51: (+1)
   \      0x52A   0xE5DE             B.N      ??mbedtls_ssl_handshake_client_step_10
   \                     ??mbedtls_ssl_handshake_client_step_60: (+1)
   \      0x52C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x530   0x2800             CMP      R0,#+0
   \      0x532   0xD111             BNE.N    ??mbedtls_ssl_handshake_client_step_55
   \      0x534   0x6F70             LDR      R0,[R6, #+116]
   \      0x536   0x2816             CMP      R0,#+22
   \      0x538   0xF47F 0xAE93      BNE.W    ??CrossCallReturnLabel_7
   \      0x53C   0xF8D6 0x0080      LDR      R0,[R6, #+128]
   \      0x540   0x2804             CMP      R0,#+4
   \      0x542   0xBF02             ITTT     EQ
   \      0x544   0x6EF0             LDREQ    R0,[R6, #+108]
   \      0x546   0x7801             LDRBEQ   R1,[R0, #+0]
   \      0x548   0x290E             CMPEQ    R1,#+14
   \      0x54A   0xD1EE             BNE.N    ??mbedtls_ssl_handshake_client_step_51
   \                     ??mbedtls_ssl_handshake_client_step_61: (+1)
   \      0x54C   0x6870             LDR      R0,[R6, #+4]
   \      0x54E   0x1C40             ADDS     R0,R0,#+1
   \      0x550   0xE7B8             B.N      ??mbedtls_ssl_handshake_client_step_57
   \                     ??mbedtls_ssl_handshake_client_step_62: (+1)
   \      0x552   0x4630             MOV      R0,R6
   \      0x554   0x.... 0x....      BL       mbedtls_ssl_write_certificate
   \                     ??mbedtls_ssl_handshake_client_step_55: (+1)
   \      0x558   0xE57D             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_63: (+1)
   \      0x55A   0x6BB4             LDR      R4,[R6, #+56]
   \      0x55C   0x68A0             LDR      R0,[R4, #+8]
   \      0x55E   0x7A80             LDRB     R0,[R0, #+10]
   \      0x560   0x2803             CMP      R0,#+3
   \      0x562   0xBF18             IT       NE
   \      0x564   0x2804             CMPNE    R0,#+4
   \      0x566   0xD006             BEQ.N    ??mbedtls_ssl_handshake_client_step_64
   \      0x568   0x2809             CMP      R0,#+9
   \      0x56A   0xBF18             IT       NE
   \      0x56C   0x280A             CMPNE    R0,#+10
   \      0x56E   0xD002             BEQ.N    ??mbedtls_ssl_handshake_client_step_64
   \                     ??mbedtls_ssl_handshake_client_step_39: (+1)
   \      0x570   0x.... 0x....      LDR.W    R8,??DataTable3_9
   \      0x574   0xE568             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_64: (+1)
   \      0x576   0xA804             ADD      R0,SP,#+16
   \      0x578   0x2124             MOVS     R1,#+36
   \      0x57A   0x.... 0x....      BL       __aeabi_memclr4
   \      0x57E   0xF44F 0x4180      MOV      R1,#+16384
   \      0x582   0x.... 0x....      LDR.W    R9,??DataTable3_10
   \      0x586   0x980B             LDR      R0,[SP, #+44]
   \      0x588   0x9107             STR      R1,[SP, #+28]
   \      0x58A   0xF8CD 0x9020      STR      R9,[SP, #+32]
   \      0x58E   0xF104 0x054C      ADD      R5,R4,#+76
   \      0x592   0x8829             LDRH     R1,[R5, #+0]
   \      0x594   0xB910             CBNZ.N   R0,??mbedtls_ssl_handshake_client_step_65
   \      0x596   0xF8AD 0x1010      STRH     R1,[SP, #+16]
   \      0x59A   0xE004             B.N      ??mbedtls_ssl_handshake_client_step_66
   \                     ??mbedtls_ssl_handshake_client_step_65: (+1)
   \      0x59C   0x2300             MOVS     R3,#+0
   \      0x59E   0x2200             MOVS     R2,#+0
   \      0x5A0   0xA804             ADD      R0,SP,#+16
   \      0x5A2   0x.... 0x....      BL       psa_set_key_domain_parameters
   \                     ??mbedtls_ssl_handshake_client_step_66: (+1)
   \      0x5A6   0x6868             LDR      R0,[R5, #+4]
   \      0x5A8   0xF64F 0x72F9      MOVW     R2,#+65529
   \      0x5AC   0x4290             CMP      R0,R2
   \      0x5AE   0xBF26             ITTE     CS
   \      0x5B0   0xF64F 0x71FF      MOVWCS   R1,#+65535
   \      0x5B4   0xF8AD 0x1012      STRHCS   R1,[SP, #+18]
   \      0x5B8   0xF8AD 0x0012      STRHCC   R0,[SP, #+18]
   \      0x5BC   0xF104 0x0154      ADD      R1,R4,#+84
   \      0x5C0   0xA804             ADD      R0,SP,#+16
   \      0x5C2   0x.... 0x....      BL       psa_generate_key
   \      0x5C6   0xB970             CBNZ.N   R0,??mbedtls_ssl_handshake_client_step_67
   \      0x5C8   0x6A38             LDR      R0,[R7, #+32]
   \      0x5CA   0x1D41             ADDS     R1,R0,#+5
   \      0x5CC   0xAB03             ADD      R3,SP,#+12
   \      0x5CE   0xF500 0x7240      ADD      R2,R0,#+768
   \      0x5D2   0x68A8             LDR      R0,[R5, #+8]
   \      0x5D4   0x1A52             SUBS     R2,R2,R1
   \      0x5D6   0x.... 0x....      BL       psa_export_public_key
   \      0x5DA   0xB138             CBZ.N    R0,??mbedtls_ssl_handshake_client_step_68
   \      0x5DC   0x68A8             LDR      R0,[R5, #+8]
   \      0x5DE   0x.... 0x....      BL       psa_destroy_key
   \      0x5E2   0xF8C5 0x8008      STR      R8,[R5, #+8]
   \                     ??mbedtls_ssl_handshake_client_step_67: (+1)
   \      0x5E6   0x.... 0x....      LDR.W    R8,??DataTable3_11
   \                     ??mbedtls_ssl_handshake_client_step_69: (+1)
   \      0x5EA   0xE52D             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_68: (+1)
   \      0x5EC   0x9903             LDR      R1,[SP, #+12]
   \      0x5EE   0x6A38             LDR      R0,[R7, #+32]
   \      0x5F0   0x2220             MOVS     R2,#+32
   \      0x5F2   0x7101             STRB     R1,[R0, #+4]
   \      0x5F4   0x9803             LDR      R0,[SP, #+12]
   \      0x5F6   0xF100 0x0A01      ADD      R10,R0,#+1
   \      0x5FA   0x6BB0             LDR      R0,[R6, #+56]
   \      0x5FC   0x9201             STR      R2,[SP, #+4]
   \      0x5FE   0xF104 0x0259      ADD      R2,R4,#+89
   \      0x602   0xF500 0x7116      ADD      R1,R0,#+600
   \      0x606   0xF500 0x700E      ADD      R0,R0,#+568
   \      0x60A   0x9102             STR      R1,[SP, #+8]
   \      0x60C   0x9000             STR      R0,[SP, #+0]
   \      0x60E   0x6D2B             LDR      R3,[R5, #+80]
   \      0x610   0x68A9             LDR      R1,[R5, #+8]
   \      0x612   0x4648             MOV      R0,R9
   \      0x614   0x.... 0x....      BL       psa_raw_key_agreement
   \      0x618   0x4604             MOV      R4,R0
   \      0x61A   0x68A8             LDR      R0,[R5, #+8]
   \      0x61C   0x.... 0x....      BL       psa_destroy_key
   \      0x620   0xF8C5 0x8008      STR      R8,[R5, #+8]
   \      0x624   0x4304             ORRS     R4,R0,R4
   \      0x626   0xD1DE             BNE.N    ??mbedtls_ssl_handshake_client_step_67
   \      0x628   0xF10A 0x0004      ADD      R0,R10,#+4
   \      0x62C   0x62B8             STR      R0,[R7, #+40]
   \      0x62E   0x2116             MOVS     R1,#+22
   \      0x630   0x6279             STR      R1,[R7, #+36]
   \      0x632   0x6A39             LDR      R1,[R7, #+32]
   \      0x634   0x2010             MOVS     R0,#+16
   \                     ??mbedtls_ssl_handshake_client_step_70: (+1)
   \      0x636   0x7008             STRB     R0,[R1, #+0]
   \      0x638   0x6870             LDR      R0,[R6, #+4]
   \      0x63A   0x1C40             ADDS     R0,R0,#+1
   \      0x63C   0x6070             STR      R0,[R6, #+4]
   \      0x63E   0x4630             MOV      R0,R6
   \      0x640   0x.... 0x....      BL       mbedtls_ssl_write_handshake_msg
   \      0x644   0x2800             CMP      R0,#+0
   \      0x646   0xD0D0             BEQ.N    ??mbedtls_ssl_handshake_client_step_69
   \                     ??mbedtls_ssl_handshake_client_step_71: (+1)
   \      0x648   0xE505             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_72: (+1)
   \      0x64A   0x6BB1             LDR      R1,[R6, #+56]
   \      0x64C   0xF8D1 0x9008      LDR      R9,[R1, #+8]
   \      0x650   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x654   0x6A38             LDR      R0,[R7, #+32]
   \      0x656   0x68FC             LDR      R4,[R7, #+12]
   \      0x658   0xF240 0x413D      MOVW     R1,#+1085
   \      0x65C   0x1A09             SUBS     R1,R1,R0
   \      0x65E   0x1864             ADDS     R4,R4,R1
   \      0x660   0x4630             MOV      R0,R6
   \      0x662   0x.... 0x....      BL       mbedtls_ssl_derive_keys
   \      0x666   0x2800             CMP      R0,#+0
   \      0x668   0xD1EE             BNE.N    ??mbedtls_ssl_handshake_client_step_71
   \      0x66A   0xF899 0x000A      LDRB     R0,[R9, #+10]
   \      0x66E   0x1E40             SUBS     R0,R0,#+1
   \      0x670   0x2803             CMP      R0,#+3
   \      0x672   0xBF84             ITT      HI
   \      0x674   0x3808             SUBHI    R0,R0,#+8
   \      0x676   0x2801             CMPHI    R0,#+1
   \      0x678   0xF63F 0xAF68      BHI.W    ??mbedtls_ssl_handshake_client_step_61
   \      0x67C   0x6BB0             LDR      R0,[R6, #+56]
   \      0x67E   0xF890 0x11CC      LDRB     R1,[R0, #+460]
   \      0x682   0x2900             CMP      R1,#+0
   \      0x684   0xD00B             BEQ.N    ??mbedtls_ssl_handshake_client_step_73
   \      0x686   0x2800             CMP      R0,#+0
   \      0x688   0xBF1C             ITT      NE
   \      0x68A   0xF8D0 0x00A4      LDRNE    R0,[R0, #+164]
   \      0x68E   0x2800             CMPNE    R0,#+0
   \      0x690   0xBF02             ITTT     EQ
   \      0x692   0x6830             LDREQ    R0,[R6, #+0]
   \      0x694   0x6B80             LDREQ    R0,[R0, #+56]
   \      0x696   0x2800             CMPEQ    R0,#+0
   \      0x698   0xD001             BEQ.N    ??mbedtls_ssl_handshake_client_step_73
   \      0x69A   0x6800             LDR      R0,[R0, #+0]
   \      0x69C   0x2800             CMP      R0,#+0
   \                     ??mbedtls_ssl_handshake_client_step_73: (+1)
   \      0x69E   0xF43F 0xAF55      BEQ.W    ??mbedtls_ssl_handshake_client_step_61
   \      0x6A2   0x4630             MOV      R0,R6
   \      0x6A4   0x.... 0x....      BL       mbedtls_ssl_own_key
   \      0x6A8   0xB910             CBNZ.N   R0,??mbedtls_ssl_handshake_client_step_74
   \      0x6AA   0x.... 0x....      LDR.W    R8,??DataTable3_12
   \      0x6AE   0xE4CB             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_74: (+1)
   \      0x6B0   0xF8D6 0xC038      LDR      R12,[R6, #+56]
   \      0x6B4   0xAA07             ADD      R2,SP,#+28
   \      0x6B6   0xA908             ADD      R1,SP,#+32
   \      0x6B8   0xF8DC 0x3010      LDR      R3,[R12, #+16]
   \      0x6BC   0x4630             MOV      R0,R6
   \      0x6BE   0x4798             BLX      R3
   \      0x6C0   0x2800             CMP      R0,#+0
   \      0x6C2   0xD1C1             BNE.N    ??mbedtls_ssl_handshake_client_step_71
   \      0x6C4   0x6BB1             LDR      R1,[R6, #+56]
   \      0x6C6   0x6A38             LDR      R0,[R7, #+32]
   \      0x6C8   0x688A             LDR      R2,[R1, #+8]
   \      0x6CA   0x7A51             LDRB     R1,[R2, #+9]
   \      0x6CC   0x290A             CMP      R1,#+10
   \      0x6CE   0xBF07             ITTEE    EQ
   \      0x6D0   0xF04F 0x090A      MOVEQ    R9,#+10
   \      0x6D4   0x2105             MOVEQ    R1,#+5
   \      0x6D6   0xF04F 0x0909      MOVNE    R9,#+9
   \      0x6DA   0x2104             MOVNE    R1,#+4
   \      0x6DC   0x7101             STRB     R1,[R0, #+4]
   \      0x6DE   0x4630             MOV      R0,R6
   \      0x6E0   0x.... 0x....      BL       mbedtls_ssl_own_key
   \      0x6E4   0x.... 0x....      BL       mbedtls_ssl_sig_from_pk
   \      0x6E8   0x6A39             LDR      R1,[R7, #+32]
   \      0x6EA   0x3C08             SUBS     R4,R4,#+8
   \      0x6EC   0x7148             STRB     R0,[R1, #+5]
   \      0x6EE   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \      0x6F2   0x4630             MOV      R0,R6
   \      0x6F4   0x.... 0x....      BL       mbedtls_ssl_own_key
   \      0x6F8   0x6831             LDR      R1,[R6, #+0]
   \      0x6FA   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \      0x6FE   0x69CB             LDR      R3,[R1, #+28]
   \      0x700   0x9304             STR      R3,[SP, #+16]
   \      0x702   0x698A             LDR      R2,[R1, #+24]
   \      0x704   0xA906             ADD      R1,SP,#+24
   \      0x706   0x9102             STR      R1,[SP, #+8]
   \      0x708   0x9203             STR      R2,[SP, #+12]
   \      0x70A   0x9401             STR      R4,[SP, #+4]
   \      0x70C   0x6A3A             LDR      R2,[R7, #+32]
   \      0x70E   0x2300             MOVS     R3,#+0
   \      0x710   0xF102 0x0108      ADD      R1,R2,#+8
   \      0x714   0x9100             STR      R1,[SP, #+0]
   \      0x716   0xAA08             ADD      R2,SP,#+32
   \      0x718   0x4649             MOV      R1,R9
   \      0x71A   0x.... 0x....      BL       mbedtls_pk_sign_restartable
   \      0x71E   0x2800             CMP      R0,#+0
   \      0x720   0xD119             BNE.N    ??mbedtls_ssl_handshake_client_step_75
   \      0x722   0x7829             LDRB     R1,[R5, #+0]
   \      0x724   0x6A38             LDR      R0,[R7, #+32]
   \      0x726   0x2901             CMP      R1,#+1
   \      0x728   0xBF08             IT       EQ
   \      0x72A   0x9906             LDREQ    R1,[SP, #+24]
   \      0x72C   0xD004             BEQ.N    ??mbedtls_ssl_handshake_client_step_76
   \      0x72E   0x9A06             LDR      R2,[SP, #+24]
   \      0x730   0x0411             LSLS     R1,R2,#+16
   \      0x732   0x0E09             LSRS     R1,R1,#+24
   \      0x734   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??mbedtls_ssl_handshake_client_step_76: (+1)
   \      0x738   0xB289             UXTH     R1,R1
   \      0x73A   0x1D80             ADDS     R0,R0,#+6
   \      0x73C   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \      0x740   0x9806             LDR      R0,[SP, #+24]
   \      0x742   0x2116             MOVS     R1,#+22
   \      0x744   0x6279             STR      R1,[R7, #+36]
   \      0x746   0x3008             ADDS     R0,R0,#+8
   \      0x748   0x6A39             LDR      R1,[R7, #+32]
   \      0x74A   0x62B8             STR      R0,[R7, #+40]
   \      0x74C   0x200F             MOVS     R0,#+15
   \      0x74E   0xE772             B.N      ??mbedtls_ssl_handshake_client_step_70
   \                     ??mbedtls_ssl_handshake_client_step_77: (+1)
   \      0x750   0x4630             MOV      R0,R6
   \      0x752   0x.... 0x....      BL       mbedtls_ssl_write_change_cipher_spec
   \                     ??mbedtls_ssl_handshake_client_step_75: (+1)
   \      0x756   0xE47E             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_78: (+1)
   \      0x758   0x4630             MOV      R0,R6
   \      0x75A   0x.... 0x....      BL       mbedtls_ssl_write_finished
   \      0x75E   0xE47A             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_79: (+1)
   \      0x760   0x4630             MOV      R0,R6
   \      0x762   0x.... 0x....      BL       mbedtls_ssl_parse_change_cipher_spec
   \      0x766   0xE476             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_80: (+1)
   \      0x768   0x4630             MOV      R0,R6
   \      0x76A   0x.... 0x....      BL       mbedtls_ssl_parse_finished
   \      0x76E   0xE472             B.N      ??mbedtls_ssl_handshake_client_step_7
   \                     ??mbedtls_ssl_handshake_client_step_81: (+1)
   \      0x770   0x200F             MOVS     R0,#+15
   \      0x772   0xE6A7             B.N      ??mbedtls_ssl_handshake_client_step_57
   \                     ??mbedtls_ssl_handshake_client_step_82: (+1)
   \      0x774   0x4630             MOV      R0,R6
   \      0x776   0x.... 0x....      BL       mbedtls_ssl_handshake_wrapup
   \      0x77A   0xE465             B.N      ??mbedtls_ssl_handshake_client_step_4
   \                     ??mbedtls_ssl_handshake_client_step_1: (+1)
   \      0x77C   0x....             LDR.N    R0,??DataTable3_4
   \      0x77E   0xE464             B.N      ??mbedtls_ssl_handshake_client_step_5
   3617          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x222F             MOVS     R2,#+47
   \                     ??Subroutine1_0: (+1)
   \        0x2   0x2102             MOVS     R1,#+2
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x.... 0x....      B.W      mbedtls_ssl_send_alert_message

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      mbedtls_ssl_read_record

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0xFFFF'8900        DC32     0xffff8900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0xFFFF'8D00        DC32     0xffff8d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0xFFFF'8F80        DC32     0xffff8f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0xFFFF'9A00        DC32     0xffff9a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0xFFFF'9200        DC32     0xffff9200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0xFFFF'9180        DC32     0xffff9180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0xFFFF'9300        DC32     0xffff9300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \        0x0   0x0902'0000        DC32     0x9020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \        0x0   0xFFFF'8080        DC32     0xffff8080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \        0x0   0xFFFF'8A00        DC32     0xffff8a00
   3618          
   3619          #endif /* MBEDTLS_SSL_CLI_C && MBEDTLS_SSL_PROTO_TLS1_2 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   mbedtls_get_unaligned_uint16
       4   mbedtls_put_unaligned_uint16
       0   mbedtls_ssl_chk_buf_ptr
     120   mbedtls_ssl_handshake_client_step
       120   -- Indirect call
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy
       120   -> mbedtls_get_unaligned_uint16
       120   -> mbedtls_pk_can_do
       120   -> mbedtls_pk_sign_restartable
       120   -> mbedtls_pk_verify_restartable
       120   -> mbedtls_put_unaligned_uint16
       120   -> mbedtls_ssl_check_curve_tls_id
       120   -> mbedtls_ssl_chk_buf_ptr
       120   -> mbedtls_ssl_ciphersuite_from_id
       120   -> mbedtls_ssl_derive_keys
       120   -> mbedtls_ssl_get_key_exchange_md_tls1_2
       120   -> mbedtls_ssl_get_psa_curve_info_from_tls_id
       120   -> mbedtls_ssl_handshake_wrapup
       120   -> mbedtls_ssl_md_alg_from_hash
       120   -> mbedtls_ssl_optimize_checksum
       120   -> mbedtls_ssl_own_key
       120   -> mbedtls_ssl_parse_certificate
       120   -> mbedtls_ssl_parse_change_cipher_spec
       120   -> mbedtls_ssl_parse_finished
       120   -> mbedtls_ssl_pend_fatal_alert
       120   -> mbedtls_ssl_pk_alg_from_sig
       120   -> mbedtls_ssl_read_record
       120   -> mbedtls_ssl_read_version
       120   -> mbedtls_ssl_send_alert_message
       120   -> mbedtls_ssl_sig_from_pk
       120   -> mbedtls_ssl_validate_ciphersuite
       120   -> mbedtls_ssl_write_certificate
       120   -> mbedtls_ssl_write_change_cipher_spec
       120   -> mbedtls_ssl_write_client_hello
       120   -> mbedtls_ssl_write_finished
       120   -> mbedtls_ssl_write_handshake_msg
       120   -> memcmp
       120   -> psa_destroy_key
       120   -> psa_export_public_key
       120   -> psa_generate_key
       120   -> psa_raw_key_agreement
       120   -> psa_set_key_domain_parameters
       0   mbedtls_ssl_own_key
      32   mbedtls_ssl_tls12_write_client_hello_exts
        32   -> mbedtls_put_unaligned_uint16
        32   -> mbedtls_ssl_chk_buf_ptr
       0   mbedtls_ssl_write_handshake_msg
         0   -> mbedtls_ssl_write_handshake_msg_ext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       8  ?Subroutine0
      10  ?Subroutine1
       2  mbedtls_byte_order_detector
      22  mbedtls_get_unaligned_uint16
      18  mbedtls_put_unaligned_uint16
      18  mbedtls_ssl_chk_buf_ptr
   1'920  mbedtls_ssl_handshake_client_step
      30  mbedtls_ssl_own_key
     146  mbedtls_ssl_tls12_write_client_hello_exts
       8  mbedtls_ssl_write_handshake_msg
      36  v

 
    36 bytes in section .rodata
 2'234 bytes in section .text
 
 2'194 bytes of CODE  memory (+ 40 bytes shared)
    36 bytes of CONST memory

Errors: none
Warnings: 1
