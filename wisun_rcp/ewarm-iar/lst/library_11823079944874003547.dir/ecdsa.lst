###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:25
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecdsa.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecdsa.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecdsa.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecdsa.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ecdsa.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecdsa.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecdsa.c
      1          /*
      2           *  Elliptic curve DSA
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * References:
     22           *
     23           * SEC1 https://www.secg.org/sec1-v2.pdf
     24           */
     25          
     26          #include "common.h"
     27          
     28          #if defined(MBEDTLS_ECDSA_C)
     29          
     30          #include "mbedtls/ecdsa.h"
     31          #include "mbedtls/asn1write.h"
     32          
     33          #include <string.h>
     34          
     35          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
     36          #include "mbedtls/hmac_drbg.h"
     37          #endif
     38          
     39          #include "mbedtls/platform.h"
     40          
     41          #include "mbedtls/platform_util.h"
     42          #include "mbedtls/error.h"
     43          
     44          #if defined(MBEDTLS_ECP_RESTARTABLE)
     45          
     46          /*
     47           * Sub-context for ecdsa_verify()
     48           */
     49          struct mbedtls_ecdsa_restart_ver {
     50              mbedtls_mpi u1, u2;     /* intermediate values  */
     51              enum {                  /* what to do next?     */
     52                  ecdsa_ver_init = 0, /* getting started      */
     53                  ecdsa_ver_muladd,   /* muladd step          */
     54              } state;
     55          };
     56          
     57          /*
     58           * Init verify restart sub-context
     59           */
     60          static void ecdsa_restart_ver_init(mbedtls_ecdsa_restart_ver_ctx *ctx)
     61          {
     62              mbedtls_mpi_init(&ctx->u1);
     63              mbedtls_mpi_init(&ctx->u2);
     64              ctx->state = ecdsa_ver_init;
     65          }
     66          
     67          /*
     68           * Free the components of a verify restart sub-context
     69           */
     70          static void ecdsa_restart_ver_free(mbedtls_ecdsa_restart_ver_ctx *ctx)
     71          {
     72              if (ctx == NULL) {
     73                  return;
     74              }
     75          
     76              mbedtls_mpi_free(&ctx->u1);
     77              mbedtls_mpi_free(&ctx->u2);
     78          
     79              ecdsa_restart_ver_init(ctx);
     80          }
     81          
     82          /*
     83           * Sub-context for ecdsa_sign()
     84           */
     85          struct mbedtls_ecdsa_restart_sig {
     86              int sign_tries;
     87              int key_tries;
     88              mbedtls_mpi k;          /* per-signature random */
     89              mbedtls_mpi r;          /* r value              */
     90              enum {                  /* what to do next?     */
     91                  ecdsa_sig_init = 0, /* getting started      */
     92                  ecdsa_sig_mul,      /* doing ecp_mul()      */
     93                  ecdsa_sig_modn,     /* mod N computations   */
     94              } state;
     95          };
     96          
     97          /*
     98           * Init verify sign sub-context
     99           */
    100          static void ecdsa_restart_sig_init(mbedtls_ecdsa_restart_sig_ctx *ctx)
    101          {
    102              ctx->sign_tries = 0;
    103              ctx->key_tries = 0;
    104              mbedtls_mpi_init(&ctx->k);
    105              mbedtls_mpi_init(&ctx->r);
    106              ctx->state = ecdsa_sig_init;
    107          }
    108          
    109          /*
    110           * Free the components of a sign restart sub-context
    111           */
    112          static void ecdsa_restart_sig_free(mbedtls_ecdsa_restart_sig_ctx *ctx)
    113          {
    114              if (ctx == NULL) {
    115                  return;
    116              }
    117          
    118              mbedtls_mpi_free(&ctx->k);
    119              mbedtls_mpi_free(&ctx->r);
    120          }
    121          
    122          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    123          /*
    124           * Sub-context for ecdsa_sign_det()
    125           */
    126          struct mbedtls_ecdsa_restart_det {
    127              mbedtls_hmac_drbg_context rng_ctx;  /* DRBG state   */
    128              enum {                      /* what to do next?     */
    129                  ecdsa_det_init = 0,     /* getting started      */
    130                  ecdsa_det_sign,         /* make signature       */
    131              } state;
    132          };
    133          
    134          /*
    135           * Init verify sign_det sub-context
    136           */
    137          static void ecdsa_restart_det_init(mbedtls_ecdsa_restart_det_ctx *ctx)
    138          {
    139              mbedtls_hmac_drbg_init(&ctx->rng_ctx);
    140              ctx->state = ecdsa_det_init;
    141          }
    142          
    143          /*
    144           * Free the components of a sign_det restart sub-context
    145           */
    146          static void ecdsa_restart_det_free(mbedtls_ecdsa_restart_det_ctx *ctx)
    147          {
    148              if (ctx == NULL) {
    149                  return;
    150              }
    151          
    152              mbedtls_hmac_drbg_free(&ctx->rng_ctx);
    153          
    154              ecdsa_restart_det_init(ctx);
    155          }
    156          #endif /* MBEDTLS_ECDSA_DETERMINISTIC */
    157          
    158          #define ECDSA_RS_ECP    (rs_ctx == NULL ? NULL : &rs_ctx->ecp)
    159          
    160          /* Utility macro for checking and updating ops budget */
    161          #define ECDSA_BUDGET(ops)   \
    162              MBEDTLS_MPI_CHK(mbedtls_ecp_check_budget(grp, ECDSA_RS_ECP, ops));
    163          
    164          /* Call this when entering a function that needs its own sub-context */
    165          #define ECDSA_RS_ENTER(SUB)   do {                                 \
    166                  /* reset ops count for this call if top-level */                 \
    167                  if (rs_ctx != NULL && rs_ctx->ecp.depth++ == 0)                 \
    168                  rs_ctx->ecp.ops_done = 0;                                    \
    169                                                                               \
    170                  /* set up our own sub-context if needed */                       \
    171                  if (mbedtls_ecp_restart_is_enabled() &&                          \
    172                      rs_ctx != NULL && rs_ctx->SUB == NULL)                      \
    173                  {                                                                \
    174                      rs_ctx->SUB = mbedtls_calloc(1, sizeof(*rs_ctx->SUB));   \
    175                      if (rs_ctx->SUB == NULL)                                    \
    176                      return MBEDTLS_ERR_ECP_ALLOC_FAILED;                  \
    177                                                                             \
    178                      ecdsa_restart_## SUB ##_init(rs_ctx->SUB);                 \
    179                  }                                                                \
    180          } while (0)
    181          
    182          /* Call this when leaving a function that needs its own sub-context */
    183          #define ECDSA_RS_LEAVE(SUB)   do {                                 \
    184                  /* clear our sub-context when not in progress (done or error) */ \
    185                  if (rs_ctx != NULL && rs_ctx->SUB != NULL &&                     \
    186                      ret != MBEDTLS_ERR_ECP_IN_PROGRESS)                         \
    187                  {                                                                \
    188                      ecdsa_restart_## SUB ##_free(rs_ctx->SUB);                 \
    189                      mbedtls_free(rs_ctx->SUB);                                 \
    190                      rs_ctx->SUB = NULL;                                          \
    191                  }                                                                \
    192                                                                               \
    193                  if (rs_ctx != NULL)                                             \
    194                  rs_ctx->ecp.depth--;                                         \
    195          } while (0)
    196          
    197          #else /* MBEDTLS_ECP_RESTARTABLE */
    198          
    199          #define ECDSA_RS_ECP    NULL
    200          
    201          #define ECDSA_BUDGET(ops)     /* no-op; for compatibility */
    202          
    203          #define ECDSA_RS_ENTER(SUB)   (void) rs_ctx
    204          #define ECDSA_RS_LEAVE(SUB)   (void) rs_ctx
    205          
    206          #endif /* MBEDTLS_ECP_RESTARTABLE */
    207          
    208          #if defined(MBEDTLS_ECDSA_DETERMINISTIC) || \
    209              !defined(MBEDTLS_ECDSA_SIGN_ALT)     || \
    210              !defined(MBEDTLS_ECDSA_VERIFY_ALT)
    211          /*
    212           * Derive a suitable integer for group grp from a buffer of length len
    213           * SEC1 4.1.3 step 5 aka SEC1 4.1.4 step 3
    214           */
    215          static int derive_mpi(const mbedtls_ecp_group *grp, mbedtls_mpi *x,
    216                                const unsigned char *buf, size_t blen)
    217          {
    218              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    219              size_t n_size = (grp->nbits + 7) / 8;
    220              size_t use_size = blen > n_size ? n_size : blen;
    221          
    222              MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(x, buf, use_size));
    223              if (use_size * 8 > grp->nbits) {
    224                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(x, use_size * 8 - grp->nbits));
    225              }
    226          
    227              /* While at it, reduce modulo N */
    228              if (mbedtls_mpi_cmp_mpi(x, &grp->N) >= 0) {
    229                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(x, x, &grp->N));
    230              }
    231          
    232          cleanup:
    233              return ret;
    234          }
    235          #endif /* ECDSA_DETERMINISTIC || !ECDSA_SIGN_ALT || !ECDSA_VERIFY_ALT */
    236          

   \                                 In section .text, align 2, keep-with-next
    237          int mbedtls_ecdsa_can_do(mbedtls_ecp_group_id gid)
    238          {
    239              switch (gid) {
    240          #ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
    241                  case MBEDTLS_ECP_DP_CURVE25519: return 0;
    242          #endif
    243          #ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
    244                  case MBEDTLS_ECP_DP_CURVE448: return 0;
    245          #endif
    246                  default: return 1;
   \                     mbedtls_ecdsa_can_do: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR
    247              }
    248          }
    249          
    250          #if !defined(MBEDTLS_ECDSA_SIGN_ALT)
    251          /*
    252           * Compute ECDSA signature of a hashed message (SEC1 4.1.3)
    253           * Obviously, compared to SEC1 4.1.3, we skip step 4 (hash message)
    254           */
    255          int mbedtls_ecdsa_sign_restartable(mbedtls_ecp_group *grp,
    256                                             mbedtls_mpi *r, mbedtls_mpi *s,
    257                                             const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
    258                                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
    259                                             int (*f_rng_blind)(void *, unsigned char *, size_t),
    260                                             void *p_rng_blind,
    261                                             mbedtls_ecdsa_restart_ctx *rs_ctx)
    262          {
    263              int ret, key_tries, sign_tries;
    264              int *p_sign_tries = &sign_tries, *p_key_tries = &key_tries;
    265              mbedtls_ecp_point R;
    266              mbedtls_mpi k, e, t;
    267              mbedtls_mpi *pk = &k, *pr = r;
    268          
    269              /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    270              if (!mbedtls_ecdsa_can_do(grp->id) || grp->N.p == NULL) {
    271                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    272              }
    273          
    274              /* Make sure d is in range 1..n-1 */
    275              if (mbedtls_mpi_cmp_int(d, 1) < 0 || mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0) {
    276                  return MBEDTLS_ERR_ECP_INVALID_KEY;
    277              }
    278          
    279              mbedtls_ecp_point_init(&R);
    280              mbedtls_mpi_init(&k); mbedtls_mpi_init(&e); mbedtls_mpi_init(&t);
    281          
    282              ECDSA_RS_ENTER(sig);
    283          
    284          #if defined(MBEDTLS_ECP_RESTARTABLE)
    285              if (rs_ctx != NULL && rs_ctx->sig != NULL) {
    286                  /* redirect to our context */
    287                  p_sign_tries = &rs_ctx->sig->sign_tries;
    288                  p_key_tries = &rs_ctx->sig->key_tries;
    289                  pk = &rs_ctx->sig->k;
    290                  pr = &rs_ctx->sig->r;
    291          
    292                  /* jump to current step */
    293                  if (rs_ctx->sig->state == ecdsa_sig_mul) {
    294                      goto mul;
    295                  }
    296                  if (rs_ctx->sig->state == ecdsa_sig_modn) {
    297                      goto modn;
    298                  }
    299              }
    300          #endif /* MBEDTLS_ECP_RESTARTABLE */
    301          
    302              *p_sign_tries = 0;
    303              do {
    304                  if ((*p_sign_tries)++ > 10) {
    305                      ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
    306                      goto cleanup;
    307                  }
    308          
    309                  /*
    310                   * Steps 1-3: generate a suitable ephemeral keypair
    311                   * and set r = xR mod n
    312                   */
    313                  *p_key_tries = 0;
    314                  do {
    315                      if ((*p_key_tries)++ > 10) {
    316                          ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
    317                          goto cleanup;
    318                      }
    319          
    320                      MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, pk, f_rng, p_rng));
    321          
    322          #if defined(MBEDTLS_ECP_RESTARTABLE)
    323                      if (rs_ctx != NULL && rs_ctx->sig != NULL) {
    324                          rs_ctx->sig->state = ecdsa_sig_mul;
    325                      }
    326          
    327          mul:
    328          #endif
    329                      MBEDTLS_MPI_CHK(mbedtls_ecp_mul_restartable(grp, &R, pk, &grp->G,
    330                                                                  f_rng_blind,
    331                                                                  p_rng_blind,
    332                                                                  ECDSA_RS_ECP));
    333                      MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pr, &R.X, &grp->N));
    334                  } while (mbedtls_mpi_cmp_int(pr, 0) == 0);
    335          
    336          #if defined(MBEDTLS_ECP_RESTARTABLE)
    337                  if (rs_ctx != NULL && rs_ctx->sig != NULL) {
    338                      rs_ctx->sig->state = ecdsa_sig_modn;
    339                  }
    340          
    341          modn:
    342          #endif
    343                  /*
    344                   * Accounting for everything up to the end of the loop
    345                   * (step 6, but checking now avoids saving e and t)
    346                   */
    347                  ECDSA_BUDGET(MBEDTLS_ECP_OPS_INV + 4);
    348          
    349                  /*
    350                   * Step 5: derive MPI from hashed message
    351                   */
    352                  MBEDTLS_MPI_CHK(derive_mpi(grp, &e, buf, blen));
    353          
    354                  /*
    355                   * Generate a random value to blind inv_mod in next step,
    356                   * avoiding a potential timing leak.
    357                   */
    358                  MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, &t, f_rng_blind,
    359                                                          p_rng_blind));
    360          
    361                  /*
    362                   * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n
    363                   */
    364                  MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(s, pr, d));
    365                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&e, &e, s));
    366                  MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&e, &e, &t));
    367                  MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(pk, pk, &t));
    368                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pk, pk, &grp->N));
    369                  MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(s, pk, &grp->N));
    370                  MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(s, s, &e));
    371                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(s, s, &grp->N));
    372              } while (mbedtls_mpi_cmp_int(s, 0) == 0);
    373          
    374          #if defined(MBEDTLS_ECP_RESTARTABLE)
    375              if (rs_ctx != NULL && rs_ctx->sig != NULL) {
    376                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(r, pr));
    377              }
    378          #endif
    379          
    380          cleanup:
    381              mbedtls_ecp_point_free(&R);
    382              mbedtls_mpi_free(&k); mbedtls_mpi_free(&e); mbedtls_mpi_free(&t);
    383          
    384              ECDSA_RS_LEAVE(sig);
    385          
    386              return ret;
    387          }
    388          
    389          /*
    390           * Compute ECDSA signature of a hashed message
    391           */
    392          int mbedtls_ecdsa_sign(mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
    393                                 const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
    394                                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    395          {
    396              /* Use the same RNG for both blinding and ephemeral key generation */
    397              return mbedtls_ecdsa_sign_restartable(grp, r, s, d, buf, blen,
    398                                                    f_rng, p_rng, f_rng, p_rng, NULL);
    399          }
    400          #endif /* !MBEDTLS_ECDSA_SIGN_ALT */
    401          
    402          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    403          /*
    404           * Deterministic signature wrapper
    405           *
    406           * note:    The f_rng_blind parameter must not be NULL.
    407           *
    408           */
    409          int mbedtls_ecdsa_sign_det_restartable(mbedtls_ecp_group *grp,
    410                                                 mbedtls_mpi *r, mbedtls_mpi *s,
    411                                                 const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
    412                                                 mbedtls_md_type_t md_alg,
    413                                                 int (*f_rng_blind)(void *, unsigned char *, size_t),
    414                                                 void *p_rng_blind,
    415                                                 mbedtls_ecdsa_restart_ctx *rs_ctx)
    416          {
    417              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    418              mbedtls_hmac_drbg_context rng_ctx;
    419              mbedtls_hmac_drbg_context *p_rng = &rng_ctx;
    420              unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];
    421              size_t grp_len = (grp->nbits + 7) / 8;
    422              const mbedtls_md_info_t *md_info;
    423              mbedtls_mpi h;
    424          
    425              if ((md_info = mbedtls_md_info_from_type(md_alg)) == NULL) {
    426                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    427              }
    428          
    429              mbedtls_mpi_init(&h);
    430              mbedtls_hmac_drbg_init(&rng_ctx);
    431          
    432              ECDSA_RS_ENTER(det);
    433          
    434          #if defined(MBEDTLS_ECP_RESTARTABLE)
    435              if (rs_ctx != NULL && rs_ctx->det != NULL) {
    436                  /* redirect to our context */
    437                  p_rng = &rs_ctx->det->rng_ctx;
    438          
    439                  /* jump to current step */
    440                  if (rs_ctx->det->state == ecdsa_det_sign) {
    441                      goto sign;
    442                  }
    443              }
    444          #endif /* MBEDTLS_ECP_RESTARTABLE */
    445          
    446              /* Use private key and message hash (reduced) to initialize HMAC_DRBG */
    447              MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(d, data, grp_len));
    448              MBEDTLS_MPI_CHK(derive_mpi(grp, &h, buf, blen));
    449              MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&h, data + grp_len, grp_len));
    450              MBEDTLS_MPI_CHK(mbedtls_hmac_drbg_seed_buf(p_rng, md_info, data, 2 * grp_len));
    451          
    452          #if defined(MBEDTLS_ECP_RESTARTABLE)
    453              if (rs_ctx != NULL && rs_ctx->det != NULL) {
    454                  rs_ctx->det->state = ecdsa_det_sign;
    455              }
    456          
    457          sign:
    458          #endif
    459          #if defined(MBEDTLS_ECDSA_SIGN_ALT)
    460              (void) f_rng_blind;
    461              (void) p_rng_blind;
    462              ret = mbedtls_ecdsa_sign(grp, r, s, d, buf, blen,
    463                                       mbedtls_hmac_drbg_random, p_rng);
    464          #else
    465              ret = mbedtls_ecdsa_sign_restartable(grp, r, s, d, buf, blen,
    466                                                   mbedtls_hmac_drbg_random, p_rng,
    467                                                   f_rng_blind, p_rng_blind, rs_ctx);
    468          #endif /* MBEDTLS_ECDSA_SIGN_ALT */
    469          
    470          cleanup:
    471              mbedtls_hmac_drbg_free(&rng_ctx);
    472              mbedtls_mpi_free(&h);
    473          
    474              ECDSA_RS_LEAVE(det);
    475          
    476              return ret;
    477          }
    478          
    479          /*
    480           * Deterministic signature wrapper
    481           */
    482          int mbedtls_ecdsa_sign_det_ext(mbedtls_ecp_group *grp, mbedtls_mpi *r,
    483                                         mbedtls_mpi *s, const mbedtls_mpi *d,
    484                                         const unsigned char *buf, size_t blen,
    485                                         mbedtls_md_type_t md_alg,
    486                                         int (*f_rng_blind)(void *, unsigned char *,
    487                                                            size_t),
    488                                         void *p_rng_blind)
    489          {
    490              return mbedtls_ecdsa_sign_det_restartable(grp, r, s, d, buf, blen, md_alg,
    491                                                        f_rng_blind, p_rng_blind, NULL);
    492          }
    493          #endif /* MBEDTLS_ECDSA_DETERMINISTIC */
    494          
    495          #if !defined(MBEDTLS_ECDSA_VERIFY_ALT)
    496          /*
    497           * Verify ECDSA signature of hashed message (SEC1 4.1.4)
    498           * Obviously, compared to SEC1 4.1.3, we skip step 2 (hash message)
    499           */
    500          int mbedtls_ecdsa_verify_restartable(mbedtls_ecp_group *grp,
    501                                               const unsigned char *buf, size_t blen,
    502                                               const mbedtls_ecp_point *Q,
    503                                               const mbedtls_mpi *r,
    504                                               const mbedtls_mpi *s,
    505                                               mbedtls_ecdsa_restart_ctx *rs_ctx)
    506          {
    507              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    508              mbedtls_mpi e, s_inv, u1, u2;
    509              mbedtls_ecp_point R;
    510              mbedtls_mpi *pu1 = &u1, *pu2 = &u2;
    511          
    512              mbedtls_ecp_point_init(&R);
    513              mbedtls_mpi_init(&e); mbedtls_mpi_init(&s_inv);
    514              mbedtls_mpi_init(&u1); mbedtls_mpi_init(&u2);
    515          
    516              /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    517              if (!mbedtls_ecdsa_can_do(grp->id) || grp->N.p == NULL) {
    518                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    519              }
    520          
    521              ECDSA_RS_ENTER(ver);
    522          
    523          #if defined(MBEDTLS_ECP_RESTARTABLE)
    524              if (rs_ctx != NULL && rs_ctx->ver != NULL) {
    525                  /* redirect to our context */
    526                  pu1 = &rs_ctx->ver->u1;
    527                  pu2 = &rs_ctx->ver->u2;
    528          
    529                  /* jump to current step */
    530                  if (rs_ctx->ver->state == ecdsa_ver_muladd) {
    531                      goto muladd;
    532                  }
    533              }
    534          #endif /* MBEDTLS_ECP_RESTARTABLE */
    535          
    536              /*
    537               * Step 1: make sure r and s are in range 1..n-1
    538               */
    539              if (mbedtls_mpi_cmp_int(r, 1) < 0 || mbedtls_mpi_cmp_mpi(r, &grp->N) >= 0 ||
    540                  mbedtls_mpi_cmp_int(s, 1) < 0 || mbedtls_mpi_cmp_mpi(s, &grp->N) >= 0) {
    541                  ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
    542                  goto cleanup;
    543              }
    544          
    545              /*
    546               * Step 3: derive MPI from hashed message
    547               */
    548              MBEDTLS_MPI_CHK(derive_mpi(grp, &e, buf, blen));
    549          
    550              /*
    551               * Step 4: u1 = e / s mod n, u2 = r / s mod n
    552               */
    553              ECDSA_BUDGET(MBEDTLS_ECP_OPS_CHK + MBEDTLS_ECP_OPS_INV + 2);
    554          
    555              MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(&s_inv, s, &grp->N));
    556          
    557              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(pu1, &e, &s_inv));
    558              MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pu1, pu1, &grp->N));
    559          
    560              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(pu2, r, &s_inv));
    561              MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(pu2, pu2, &grp->N));
    562          
    563          #if defined(MBEDTLS_ECP_RESTARTABLE)
    564              if (rs_ctx != NULL && rs_ctx->ver != NULL) {
    565                  rs_ctx->ver->state = ecdsa_ver_muladd;
    566              }
    567          
    568          muladd:
    569          #endif
    570              /*
    571               * Step 5: R = u1 G + u2 Q
    572               */
    573              MBEDTLS_MPI_CHK(mbedtls_ecp_muladd_restartable(grp,
    574                                                             &R, pu1, &grp->G, pu2, Q, ECDSA_RS_ECP));
    575          
    576              if (mbedtls_ecp_is_zero(&R)) {
    577                  ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
    578                  goto cleanup;
    579              }
    580          
    581              /*
    582               * Step 6: convert xR to an integer (no-op)
    583               * Step 7: reduce xR mod n (gives v)
    584               */
    585              MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&R.X, &R.X, &grp->N));
    586          
    587              /*
    588               * Step 8: check if v (that is, R.X) is equal to r
    589               */
    590              if (mbedtls_mpi_cmp_mpi(&R.X, r) != 0) {
    591                  ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
    592                  goto cleanup;
    593              }
    594          
    595          cleanup:
    596              mbedtls_ecp_point_free(&R);
    597              mbedtls_mpi_free(&e); mbedtls_mpi_free(&s_inv);
    598              mbedtls_mpi_free(&u1); mbedtls_mpi_free(&u2);
    599          
    600              ECDSA_RS_LEAVE(ver);
    601          
    602              return ret;
    603          }
    604          
    605          /*
    606           * Verify ECDSA signature of hashed message
    607           */
    608          int mbedtls_ecdsa_verify(mbedtls_ecp_group *grp,
    609                                   const unsigned char *buf, size_t blen,
    610                                   const mbedtls_ecp_point *Q,
    611                                   const mbedtls_mpi *r,
    612                                   const mbedtls_mpi *s)
    613          {
    614              return mbedtls_ecdsa_verify_restartable(grp, buf, blen, Q, r, s, NULL);
    615          }
    616          #endif /* !MBEDTLS_ECDSA_VERIFY_ALT */
    617          
    618          /*
    619           * Convert a signature (given by context) to ASN.1
    620           */
    621          static int ecdsa_signature_to_asn1(const mbedtls_mpi *r, const mbedtls_mpi *s,
    622                                             unsigned char *sig, size_t sig_size,
    623                                             size_t *slen)
    624          {
    625              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    626              unsigned char buf[MBEDTLS_ECDSA_MAX_LEN] = { 0 };
    627              unsigned char *p = buf + sizeof(buf);
    628              size_t len = 0;
    629          
    630              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_mpi(&p, buf, s));
    631              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_mpi(&p, buf, r));
    632          
    633              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&p, buf, len));
    634              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&p, buf,
    635                                                               MBEDTLS_ASN1_CONSTRUCTED |
    636                                                               MBEDTLS_ASN1_SEQUENCE));
    637          
    638              if (len > sig_size) {
    639                  return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
    640              }
    641          
    642              memcpy(sig, p, len);
    643              *slen = len;
    644          
    645              return 0;
    646          }
    647          
    648          /*
    649           * Compute and write signature
    650           */

   \                                 In section .text, align 2, keep-with-next
    651          int mbedtls_ecdsa_write_signature_restartable(mbedtls_ecdsa_context *ctx,
    652                                                        mbedtls_md_type_t md_alg,
    653                                                        const unsigned char *hash, size_t hlen,
    654                                                        unsigned char *sig, size_t sig_size, size_t *slen,
    655                                                        int (*f_rng)(void *, unsigned char *, size_t),
    656                                                        void *p_rng,
    657                                                        mbedtls_ecdsa_restart_ctx *rs_ctx)
    658          {
   \                     mbedtls_ecdsa_write_signature_restartable: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB09A             SUB      SP,SP,#+104
   \        0x4   0x9E23             LDR      R6,[SP, #+140]
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461F             MOV      R7,R3
    659              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    660              mbedtls_mpi r, s;
    661              if (f_rng == NULL) {
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0xBF08             IT       EQ
   \       0x10   0x....             LDREQ.N  R0,??DataTable2
    662                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x12   0xD04E             BEQ.N    ??mbedtls_ecdsa_write_signature_restartable_0
    663              }
    664          
    665              mbedtls_mpi_init(&r);
   \       0x14   0xA806             ADD      R0,SP,#+24
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_init
    666              mbedtls_mpi_init(&s);
   \       0x1A   0xA804             ADD      R0,SP,#+16
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_init
    667          
    668          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    669              MBEDTLS_MPI_CHK(mbedtls_ecdsa_sign_det_restartable(&ctx->grp, &r, &s, &ctx->d,
    670                                                                 hash, hlen, md_alg, f_rng,
    671                                                                 p_rng, rs_ctx));
    672          #else
    673              (void) md_alg;
    674          
    675          #if defined(MBEDTLS_ECDSA_SIGN_ALT)
    676              (void) rs_ctx;
    677          
    678              MBEDTLS_MPI_CHK(mbedtls_ecdsa_sign(&ctx->grp, &r, &s, &ctx->d,
    679                                                 hash, hlen, f_rng, p_rng));
   \       0x20   0x9824             LDR      R0,[SP, #+144]
   \       0x22   0x9602             STR      R6,[SP, #+8]
   \       0x24   0x9701             STR      R7,[SP, #+4]
   \       0x26   0x9003             STR      R0,[SP, #+12]
   \       0x28   0x9500             STR      R5,[SP, #+0]
   \       0x2A   0xF104 0x0360      ADD      R3,R4,#+96
   \       0x2E   0xAA04             ADD      R2,SP,#+16
   \       0x30   0xA906             ADD      R1,SP,#+24
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x.... 0x....      BL       mbedtls_ecdsa_sign
   \       0x38   0x0004             MOVS     R4,R0
   \       0x3A   0xD133             BNE.N    ??mbedtls_ecdsa_write_signature_restartable_1
    680          #else
    681              /* Use the same RNG for both blinding and ephemeral key generation */
    682              MBEDTLS_MPI_CHK(mbedtls_ecdsa_sign_restartable(&ctx->grp, &r, &s, &ctx->d,
    683                                                             hash, hlen, f_rng, p_rng, f_rng,
    684                                                             p_rng, rs_ctx));
    685          #endif /* MBEDTLS_ECDSA_SIGN_ALT */
    686          #endif /* MBEDTLS_ECDSA_DETERMINISTIC */
    687          
    688              MBEDTLS_MPI_CHK(ecdsa_signature_to_asn1(&r, &s, sig, sig_size, slen));
   \       0x3C   0x2148             MOVS     R1,#+72
   \       0x3E   0xA808             ADD      R0,SP,#+32
   \       0x40   0x.... 0x....      BL       __aeabi_memclr4
   \       0x44   0xA81A             ADD      R0,SP,#+104
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0xAA04             ADD      R2,SP,#+16
   \       0x4A   0xA908             ADD      R1,SP,#+32
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       mbedtls_asn1_write_mpi
   \       0x52   0x0004             MOVS     R4,R0
   \       0x54   0xD426             BMI.N    ??mbedtls_ecdsa_write_signature_restartable_1
   \       0x56   0xAA06             ADD      R2,SP,#+24
   \       0x58   0xA908             ADD      R1,SP,#+32
   \       0x5A   0x4668             MOV      R0,SP
   \       0x5C   0x.... 0x....      BL       mbedtls_asn1_write_mpi
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD40E             BMI.N    ??mbedtls_ecdsa_write_signature_restartable_2
   \       0x64   0x1905             ADDS     R5,R0,R4
   \       0x66   0x462A             MOV      R2,R5
   \       0x68   0xA908             ADD      R1,SP,#+32
   \       0x6A   0x4668             MOV      R0,SP
   \       0x6C   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0x70   0x0004             MOVS     R4,R0
   \       0x72   0xD417             BMI.N    ??mbedtls_ecdsa_write_signature_restartable_1
   \       0x74   0x2230             MOVS     R2,#+48
   \       0x76   0xA908             ADD      R1,SP,#+32
   \       0x78   0x4668             MOV      R0,SP
   \       0x7A   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD501             BPL.N    ??mbedtls_ecdsa_write_signature_restartable_3
   \                     ??mbedtls_ecdsa_write_signature_restartable_2: (+1)
   \       0x82   0x4604             MOV      R4,R0
   \       0x84   0xE00E             B.N      ??mbedtls_ecdsa_write_signature_restartable_1
   \                     ??mbedtls_ecdsa_write_signature_restartable_3: (+1)
   \       0x86   0x9921             LDR      R1,[SP, #+132]
   \       0x88   0x1964             ADDS     R4,R4,R5
   \       0x8A   0x1904             ADDS     R4,R0,R4
   \       0x8C   0x42A1             CMP      R1,R4
   \       0x8E   0xBF38             IT       CC
   \       0x90   0x....             LDRCC.N  R4,??DataTable2_1
   \       0x92   0xD307             BCC.N    ??mbedtls_ecdsa_write_signature_restartable_1
   \       0x94   0x9900             LDR      R1,[SP, #+0]
   \       0x96   0x9820             LDR      R0,[SP, #+128]
   \       0x98   0x9D22             LDR      R5,[SP, #+136]
   \       0x9A   0x4622             MOV      R2,R4
   \       0x9C   0x.... 0x....      BL       __aeabi_memcpy
   \       0xA0   0x602C             STR      R4,[R5, #+0]
   \       0xA2   0x2400             MOVS     R4,#+0
    689          
    690          cleanup:
    691              mbedtls_mpi_free(&r);
   \                     ??mbedtls_ecdsa_write_signature_restartable_1: (+1)
   \       0xA4   0xA806             ADD      R0,SP,#+24
   \       0xA6   0x.... 0x....      BL       mbedtls_mpi_free
    692              mbedtls_mpi_free(&s);
   \       0xAA   0xA804             ADD      R0,SP,#+16
   \       0xAC   0x.... 0x....      BL       mbedtls_mpi_free
    693          
    694              return ret;
   \       0xB0   0x4620             MOV      R0,R4
   \                     ??mbedtls_ecdsa_write_signature_restartable_0: (+1)
   \       0xB2   0xB01B             ADD      SP,SP,#+108
   \       0xB4   0xBDF0             POP      {R4-R7,PC}
    695          }
    696          
    697          /*
    698           * Compute and write signature
    699           */

   \                                 In section .text, align 2, keep-with-next
    700          int mbedtls_ecdsa_write_signature(mbedtls_ecdsa_context *ctx,
    701                                            mbedtls_md_type_t md_alg,
    702                                            const unsigned char *hash, size_t hlen,
    703                                            unsigned char *sig, size_t sig_size, size_t *slen,
    704                                            int (*f_rng)(void *, unsigned char *, size_t),
    705                                            void *p_rng)
    706          {
   \                     mbedtls_ecdsa_write_signature: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    707              return mbedtls_ecdsa_write_signature_restartable(
    708                  ctx, md_alg, hash, hlen, sig, sig_size, slen,
    709                  f_rng, p_rng, NULL);
   \        0x4   0x9C0E             LDR      R4,[SP, #+56]
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x9505             STR      R5,[SP, #+20]
   \        0xA   0x9404             STR      R4,[SP, #+16]
   \        0xC   0x9D0D             LDR      R5,[SP, #+52]
   \        0xE   0x9C0C             LDR      R4,[SP, #+48]
   \       0x10   0x9503             STR      R5,[SP, #+12]
   \       0x12   0x9D0B             LDR      R5,[SP, #+44]
   \       0x14   0x9402             STR      R4,[SP, #+8]
   \       0x16   0x9C0A             LDR      R4,[SP, #+40]
   \       0x18   0x9501             STR      R5,[SP, #+4]
   \       0x1A   0x9400             STR      R4,[SP, #+0]
   \       0x1C   0x.... 0x....      BL       mbedtls_ecdsa_write_signature_restartable
   \       0x20   0xB007             ADD      SP,SP,#+28
   \       0x22   0xBD30             POP      {R4,R5,PC}
    710          }
    711          
    712          /*
    713           * Read and check signature
    714           */

   \                                 In section .text, align 2, keep-with-next
    715          int mbedtls_ecdsa_read_signature(mbedtls_ecdsa_context *ctx,
    716                                           const unsigned char *hash, size_t hlen,
    717                                           const unsigned char *sig, size_t slen)
    718          {
   \                     mbedtls_ecdsa_read_signature: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    719              return mbedtls_ecdsa_read_signature_restartable(
    720                  ctx, hash, hlen, sig, slen, NULL);
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x9501             STR      R5,[SP, #+4]
   \        0x8   0x9400             STR      R4,[SP, #+0]
   \        0xA   0x.... 0x....      BL       mbedtls_ecdsa_read_signature_restartable
   \        0xE   0xBD3E             POP      {R1-R5,PC}
    721          }
    722          
    723          /*
    724           * Restartable read and check signature
    725           */

   \                                 In section .text, align 2, keep-with-next
    726          int mbedtls_ecdsa_read_signature_restartable(mbedtls_ecdsa_context *ctx,
    727                                                       const unsigned char *hash, size_t hlen,
    728                                                       const unsigned char *sig, size_t slen,
    729                                                       mbedtls_ecdsa_restart_ctx *rs_ctx)
    730          {
   \                     mbedtls_ecdsa_read_signature_restartable: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x461F             MOV      R7,R3
   \        0xA   0x9C0E             LDR      R4,[SP, #+56]
   \        0xC   0x460E             MOV      R6,R1
   \        0xE   0x4690             MOV      R8,R2
    731              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    732              unsigned char *p = (unsigned char *) sig;
   \       0x10   0x9702             STR      R7,[SP, #+8]
    733              const unsigned char *end = sig + slen;
    734              size_t len;
    735              mbedtls_mpi r, s;
    736              mbedtls_mpi_init(&r);
   \       0x12   0xA806             ADD      R0,SP,#+24
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_init
    737              mbedtls_mpi_init(&s);
   \       0x18   0xA804             ADD      R0,SP,#+16
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_init
    738          
    739              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
    740                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x1E   0x193F             ADDS     R7,R7,R4
   \       0x20   0x2330             MOVS     R3,#+48
   \       0x22   0xAA03             ADD      R2,SP,#+12
   \       0x24   0x4639             MOV      R1,R7
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x2C   0x0004             MOVS     R4,R0
   \       0x2E   0xBF18             IT       NE
   \       0x30   0xF5A0 0x449F      SUBNE    R4,R0,#+20352
    741                  ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    742                  goto cleanup;
   \       0x34   0xD128             BNE.N    ??mbedtls_ecdsa_read_signature_restartable_0
    743              }
    744          
    745              if (p + len != end) {
   \       0x36   0x9902             LDR      R1,[SP, #+8]
   \       0x38   0x9803             LDR      R0,[SP, #+12]
   \       0x3A   0x4408             ADD      R0,R1,R0
   \       0x3C   0x42B8             CMP      R0,R7
   \       0x3E   0xBF18             IT       NE
   \       0x40   0x....             LDRNE.N  R4,??DataTable2_2
    746                  ret = MBEDTLS_ERROR_ADD(MBEDTLS_ERR_ECP_BAD_INPUT_DATA,
    747                                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    748                  goto cleanup;
   \       0x42   0xD121             BNE.N    ??mbedtls_ecdsa_read_signature_restartable_0
    749              }
    750          
    751              if ((ret = mbedtls_asn1_get_mpi(&p, end, &r)) != 0 ||
    752                  (ret = mbedtls_asn1_get_mpi(&p, end, &s)) != 0) {
   \       0x44   0xAA06             ADD      R2,SP,#+24
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0xA802             ADD      R0,SP,#+8
   \       0x4A   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \       0x4E   0x0004             MOVS     R4,R0
   \       0x50   0xD106             BNE.N    ??mbedtls_ecdsa_read_signature_restartable_1
   \       0x52   0xAA04             ADD      R2,SP,#+16
   \       0x54   0x4639             MOV      R1,R7
   \       0x56   0xA802             ADD      R0,SP,#+8
   \       0x58   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0xD002             BEQ.N    ??mbedtls_ecdsa_read_signature_restartable_2
    753                  ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdsa_read_signature_restartable_1: (+1)
   \       0x60   0xF5A4 0x449F      SUB      R4,R4,#+20352
    754                  goto cleanup;
   \       0x64   0xE010             B.N      ??mbedtls_ecdsa_read_signature_restartable_0
    755              }
    756          #if defined(MBEDTLS_ECDSA_VERIFY_ALT)
    757              (void) rs_ctx;
    758          
    759              if ((ret = mbedtls_ecdsa_verify(&ctx->grp, hash, hlen,
    760                                              &ctx->Q, &r, &s)) != 0) {
   \                     ??mbedtls_ecdsa_read_signature_restartable_2: (+1)
   \       0x66   0xA904             ADD      R1,SP,#+16
   \       0x68   0xA806             ADD      R0,SP,#+24
   \       0x6A   0x9101             STR      R1,[SP, #+4]
   \       0x6C   0x9000             STR      R0,[SP, #+0]
   \       0x6E   0xF105 0x0368      ADD      R3,R5,#+104
   \       0x72   0x4642             MOV      R2,R8
   \       0x74   0x4631             MOV      R1,R6
   \       0x76   0x4628             MOV      R0,R5
   \       0x78   0x.... 0x....      BL       mbedtls_ecdsa_verify
   \       0x7C   0x0004             MOVS     R4,R0
   \       0x7E   0xD103             BNE.N    ??mbedtls_ecdsa_read_signature_restartable_0
    761                  goto cleanup;
    762              }
    763          #else
    764              if ((ret = mbedtls_ecdsa_verify_restartable(&ctx->grp, hash, hlen,
    765                                                          &ctx->Q, &r, &s, rs_ctx)) != 0) {
    766                  goto cleanup;
    767              }
    768          #endif /* MBEDTLS_ECDSA_VERIFY_ALT */
    769          
    770              /* At this point we know that the buffer starts with a valid signature.
    771               * Return 0 if the buffer just contains the signature, and a specific
    772               * error code if the valid signature is followed by more data. */
    773              if (p != end) {
   \       0x80   0x9802             LDR      R0,[SP, #+8]
   \       0x82   0x42B8             CMP      R0,R7
   \       0x84   0xBF18             IT       NE
   \       0x86   0x....             LDRNE.N  R4,??DataTable2_3
    774                  ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;
    775              }
    776          
    777          cleanup:
    778              mbedtls_mpi_free(&r);
   \                     ??mbedtls_ecdsa_read_signature_restartable_0: (+1)
   \       0x88   0xA806             ADD      R0,SP,#+24
   \       0x8A   0x.... 0x....      BL       mbedtls_mpi_free
    779              mbedtls_mpi_free(&s);
   \       0x8E   0xA804             ADD      R0,SP,#+16
   \       0x90   0x.... 0x....      BL       mbedtls_mpi_free
    780          
    781              return ret;
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0xB008             ADD      SP,SP,#+32
   \       0x98   0xE8BD 0x81F0      POP      {R4-R8,PC}
    782          }
    783          
    784          #if !defined(MBEDTLS_ECDSA_GENKEY_ALT)
    785          /*
    786           * Generate key pair
    787           */
    788          int mbedtls_ecdsa_genkey(mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid,
    789                                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    790          {
    791              int ret = 0;
    792              ret = mbedtls_ecp_group_load(&ctx->grp, gid);
    793              if (ret != 0) {
    794                  return ret;
    795              }
    796          
    797              return mbedtls_ecp_gen_keypair(&ctx->grp, &ctx->d,
    798                                             &ctx->Q, f_rng, p_rng);
    799          }
    800          #endif /* !MBEDTLS_ECDSA_GENKEY_ALT */
    801          
    802          /*
    803           * Set context from an mbedtls_ecp_keypair
    804           */

   \                                 In section .text, align 2, keep-with-next
    805          int mbedtls_ecdsa_from_keypair(mbedtls_ecdsa_context *ctx, const mbedtls_ecp_keypair *key)
    806          {
   \                     mbedtls_ecdsa_from_keypair: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    807              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    808              if ((ret = mbedtls_ecp_group_copy(&ctx->grp, &key->grp)) != 0 ||
    809                  (ret = mbedtls_mpi_copy(&ctx->d, &key->d)) != 0 ||
    810                  (ret = mbedtls_ecp_copy(&ctx->Q, &key->Q)) != 0) {
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_group_copy
   \        0xA   0x0004             MOVS     R4,R0
   \        0xC   0xD10F             BNE.N    ??mbedtls_ecdsa_from_keypair_0
   \        0xE   0xF106 0x0160      ADD      R1,R6,#+96
   \       0x12   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x1A   0x0004             MOVS     R4,R0
   \       0x1C   0xD107             BNE.N    ??mbedtls_ecdsa_from_keypair_0
   \       0x1E   0xF106 0x0168      ADD      R1,R6,#+104
   \       0x22   0xF105 0x0068      ADD      R0,R5,#+104
   \       0x26   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x2A   0x0004             MOVS     R4,R0
   \       0x2C   0xD003             BEQ.N    ??mbedtls_ecdsa_from_keypair_1
    811                  mbedtls_ecdsa_free(ctx);
   \                     ??mbedtls_ecdsa_from_keypair_0: (+1)
   \       0x2E   0xB115             CBZ.N    R5,??mbedtls_ecdsa_from_keypair_1
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x.... 0x....      BL       mbedtls_ecp_keypair_free
    812              }
    813          
    814              return ret;
   \                     ??mbedtls_ecdsa_from_keypair_1: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD70             POP      {R4-R6,PC}
    815          }
    816          
    817          /*
    818           * Initialize context
    819           */

   \                                 In section .text, align 2, keep-with-next
    820          void mbedtls_ecdsa_init(mbedtls_ecdsa_context *ctx)
    821          {
    822              mbedtls_ecp_keypair_init(ctx);
   \                     mbedtls_ecdsa_init: (+1)
   \        0x0   0x.... 0x....      B.W      mbedtls_ecp_keypair_init
    823          }
    824          
    825          /*
    826           * Free context
    827           */

   \                                 In section .text, align 2, keep-with-next
    828          void mbedtls_ecdsa_free(mbedtls_ecdsa_context *ctx)
    829          {
    830              if (ctx == NULL) {
   \                     mbedtls_ecdsa_free: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF18             IT       NE
    831                  return;
    832              }
    833          
    834              mbedtls_ecp_keypair_free(ctx);
   \        0x4   0x.... 0x....      BNE.W    mbedtls_ecp_keypair_free
    835          }
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0xFFFF'B100        DC32     0xffffb100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0xFFFF'B01A        DC32     0xffffb01a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0xFFFF'B400        DC32     0xffffb400
    836          
    837          #if defined(MBEDTLS_ECP_RESTARTABLE)
    838          /*
    839           * Initialize a restart context
    840           */
    841          void mbedtls_ecdsa_restart_init(mbedtls_ecdsa_restart_ctx *ctx)
    842          {
    843              mbedtls_ecp_restart_init(&ctx->ecp);
    844          
    845              ctx->ver = NULL;
    846              ctx->sig = NULL;
    847          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    848              ctx->det = NULL;
    849          #endif
    850          }
    851          
    852          /*
    853           * Free the components of a restart context
    854           */
    855          void mbedtls_ecdsa_restart_free(mbedtls_ecdsa_restart_ctx *ctx)
    856          {
    857              if (ctx == NULL) {
    858                  return;
    859              }
    860          
    861              mbedtls_ecp_restart_free(&ctx->ecp);
    862          
    863              ecdsa_restart_ver_free(ctx->ver);
    864              mbedtls_free(ctx->ver);
    865              ctx->ver = NULL;
    866          
    867              ecdsa_restart_sig_free(ctx->sig);
    868              mbedtls_free(ctx->sig);
    869              ctx->sig = NULL;
    870          
    871          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    872              ecdsa_restart_det_free(ctx->det);
    873              mbedtls_free(ctx->det);
    874              ctx->det = NULL;
    875          #endif
    876          }
    877          #endif /* MBEDTLS_ECP_RESTARTABLE */
    878          
    879          #endif /* MBEDTLS_ECDSA_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_ecdsa_can_do
       0   mbedtls_ecdsa_free
         0   -> mbedtls_ecp_keypair_free
      16   mbedtls_ecdsa_from_keypair
        16   -> mbedtls_ecp_copy
        16   -> mbedtls_ecp_group_copy
        16   -> mbedtls_ecp_keypair_free
        16   -> mbedtls_mpi_copy
       0   mbedtls_ecdsa_init
         0   -> mbedtls_ecp_keypair_init
      24   mbedtls_ecdsa_read_signature
        24   -> mbedtls_ecdsa_read_signature_restartable
      56   mbedtls_ecdsa_read_signature_restartable
        56   -> mbedtls_asn1_get_mpi
        56   -> mbedtls_asn1_get_tag
        56   -> mbedtls_ecdsa_verify
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_init
      40   mbedtls_ecdsa_write_signature
        40   -> mbedtls_ecdsa_write_signature_restartable
     128   mbedtls_ecdsa_write_signature_restartable
       128   -> __aeabi_memclr4
       128   -> __aeabi_memcpy
       128   -> mbedtls_asn1_write_len
       128   -> mbedtls_asn1_write_mpi
       128   -> mbedtls_asn1_write_tag
       128   -> mbedtls_ecdsa_sign
       128   -> mbedtls_mpi_free
       128   -> mbedtls_mpi_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  mbedtls_ecdsa_can_do
      10  mbedtls_ecdsa_free
      58  mbedtls_ecdsa_from_keypair
       4  mbedtls_ecdsa_init
      16  mbedtls_ecdsa_read_signature
     156  mbedtls_ecdsa_read_signature_restartable
      36  mbedtls_ecdsa_write_signature
     182  mbedtls_ecdsa_write_signature_restartable

 
 482 bytes in section .text
 
 482 bytes of CODE memory

Errors: none
Warnings: none
