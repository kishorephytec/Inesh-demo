###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:41
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_ticket.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_ticket.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_ticket.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_ticket.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ssl_ticket.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_ticket.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_ticket.c
      1          /*
      2           *  TLS server tickets callbacks implementation
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #if defined(MBEDTLS_SSL_TICKET_C)
     23          
     24          #include "mbedtls/platform.h"
     25          
     26          #include "ssl_misc.h"
     27          #include "mbedtls/ssl_ticket.h"
     28          #include "mbedtls/error.h"
     29          #include "mbedtls/platform_util.h"
     30          
     31          #include <string.h>
     32          
     33          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     34          /* Define a local translating function to save code size by not using too many
     35           * arguments in each translating place. */
     36          static int local_err_translation(psa_status_t status)
     37          {
     38              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     39                                           ARRAY_LENGTH(psa_to_ssl_errors),
     40                                           psa_generic_status_to_mbedtls);
     41          }
     42          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     43          #endif
     44          
     45          /*
     46           * Initialize context
     47           */
     48          void mbedtls_ssl_ticket_init(mbedtls_ssl_ticket_context *ctx)
     49          {
     50              memset(ctx, 0, sizeof(mbedtls_ssl_ticket_context));
     51          
     52          #if defined(MBEDTLS_THREADING_C)
     53              mbedtls_mutex_init(&ctx->mutex);
     54          #endif
     55          }
     56          
     57          #define MAX_KEY_BYTES           MBEDTLS_SSL_TICKET_MAX_KEY_BYTES
     58          
     59          #define TICKET_KEY_NAME_BYTES   MBEDTLS_SSL_TICKET_KEY_NAME_BYTES
     60          #define TICKET_IV_BYTES         12
     61          #define TICKET_CRYPT_LEN_BYTES   2
     62          #define TICKET_AUTH_TAG_BYTES   16
     63          
     64          #define TICKET_MIN_LEN (TICKET_KEY_NAME_BYTES  +        \
     65                                  TICKET_IV_BYTES        +        \
     66                                  TICKET_CRYPT_LEN_BYTES +        \
     67                                  TICKET_AUTH_TAG_BYTES)
     68          #define TICKET_ADD_DATA_LEN (TICKET_KEY_NAME_BYTES  +        \
     69                                       TICKET_IV_BYTES        +        \
     70                                       TICKET_CRYPT_LEN_BYTES)
     71          
     72          /*
     73           * Generate/update a key
     74           */
     75          MBEDTLS_CHECK_RETURN_CRITICAL
     76          static int ssl_ticket_gen_key(mbedtls_ssl_ticket_context *ctx,
     77                                        unsigned char index)
     78          {
     79              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     80              unsigned char buf[MAX_KEY_BYTES] = { 0 };
     81              mbedtls_ssl_ticket_key *key = ctx->keys + index;
     82          
     83          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     84              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
     85          #endif
     86          
     87          #if defined(MBEDTLS_HAVE_TIME)
     88              key->generation_time = mbedtls_time(NULL);
     89          #endif
     90          
     91              if ((ret = ctx->f_rng(ctx->p_rng, key->name, sizeof(key->name))) != 0) {
     92                  return ret;
     93              }
     94          
     95              if ((ret = ctx->f_rng(ctx->p_rng, buf, sizeof(buf))) != 0) {
     96                  return ret;
     97              }
     98          
     99          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    100              psa_set_key_usage_flags(&attributes,
    101                                      PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
    102              psa_set_key_algorithm(&attributes, key->alg);
    103              psa_set_key_type(&attributes, key->key_type);
    104              psa_set_key_bits(&attributes, key->key_bits);
    105          
    106              ret = PSA_TO_MBEDTLS_ERR(
    107                  psa_import_key(&attributes, buf,
    108                                 PSA_BITS_TO_BYTES(key->key_bits),
    109                                 &key->key));
    110          #else
    111              /* With GCM and CCM, same context can encrypt & decrypt */
    112              ret = mbedtls_cipher_setkey(&key->ctx, buf,
    113                                          mbedtls_cipher_get_key_bitlen(&key->ctx),
    114                                          MBEDTLS_ENCRYPT);
    115          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    116          
    117              mbedtls_platform_zeroize(buf, sizeof(buf));
    118          
    119              return ret;
    120          }
    121          
    122          /*
    123           * Rotate/generate keys if necessary
    124           */
    125          MBEDTLS_CHECK_RETURN_CRITICAL
    126          static int ssl_ticket_update_keys(mbedtls_ssl_ticket_context *ctx)
    127          {
    128          #if !defined(MBEDTLS_HAVE_TIME)
    129              ((void) ctx);
    130          #else
    131              if (ctx->ticket_lifetime != 0) {
    132                  mbedtls_time_t current_time = mbedtls_time(NULL);
    133                  mbedtls_time_t key_time = ctx->keys[ctx->active].generation_time;
    134          
    135          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    136                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    137          #endif
    138          
    139                  if (current_time >= key_time &&
    140                      (uint64_t) (current_time - key_time) < ctx->ticket_lifetime) {
    141                      return 0;
    142                  }
    143          
    144                  ctx->active = 1 - ctx->active;
    145          
    146          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    147                  if ((status = psa_destroy_key(ctx->keys[ctx->active].key)) != PSA_SUCCESS) {
    148                      return PSA_TO_MBEDTLS_ERR(status);
    149                  }
    150          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    151          
    152                  return ssl_ticket_gen_key(ctx, ctx->active);
    153              } else
    154          #endif /* MBEDTLS_HAVE_TIME */
    155              return 0;
    156          }
    157          
    158          /*
    159           * Rotate active session ticket encryption key
    160           */
    161          int mbedtls_ssl_ticket_rotate(mbedtls_ssl_ticket_context *ctx,
    162                                        const unsigned char *name, size_t nlength,
    163                                        const unsigned char *k, size_t klength,
    164                                        uint32_t lifetime)
    165          {
    166              const unsigned char idx = 1 - ctx->active;
    167              mbedtls_ssl_ticket_key * const key = ctx->keys + idx;
    168              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    169          
    170          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    171              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    172              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    173              const size_t bitlen = key->key_bits;
    174          #else
    175              const int bitlen = mbedtls_cipher_get_key_bitlen(&key->ctx);
    176          #endif
    177          
    178              if (nlength < TICKET_KEY_NAME_BYTES || klength * 8 < (size_t) bitlen) {
    179                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    180              }
    181          
    182          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    183              if ((status = psa_destroy_key(key->key)) != PSA_SUCCESS) {
    184                  ret = PSA_TO_MBEDTLS_ERR(status);
    185                  return ret;
    186              }
    187          
    188              psa_set_key_usage_flags(&attributes,
    189                                      PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
    190              psa_set_key_algorithm(&attributes, key->alg);
    191              psa_set_key_type(&attributes, key->key_type);
    192              psa_set_key_bits(&attributes, key->key_bits);
    193          
    194              if ((status = psa_import_key(&attributes, k,
    195                                           PSA_BITS_TO_BYTES(key->key_bits),
    196                                           &key->key)) != PSA_SUCCESS) {
    197                  ret = PSA_TO_MBEDTLS_ERR(status);
    198                  return ret;
    199              }
    200          #else
    201              ret = mbedtls_cipher_setkey(&key->ctx, k, bitlen, MBEDTLS_ENCRYPT);
    202              if (ret != 0) {
    203                  return ret;
    204              }
    205          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    206          
    207              ctx->active = idx;
    208              ctx->ticket_lifetime = lifetime;
    209              memcpy(key->name, name, TICKET_KEY_NAME_BYTES);
    210          #if defined(MBEDTLS_HAVE_TIME)
    211              key->generation_time = mbedtls_time(NULL);
    212          #endif
    213              return 0;
    214          }
    215          
    216          /*
    217           * Setup context for actual use
    218           */
    219          int mbedtls_ssl_ticket_setup(mbedtls_ssl_ticket_context *ctx,
    220                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
    221                                       mbedtls_cipher_type_t cipher,
    222                                       uint32_t lifetime)
    223          {
    224              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    225              size_t key_bits;
    226          
    227          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    228              psa_algorithm_t alg;
    229              psa_key_type_t key_type;
    230          #else
    231              const mbedtls_cipher_info_t *cipher_info;
    232          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    233          
    234          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    235              if (mbedtls_ssl_cipher_to_psa(cipher, TICKET_AUTH_TAG_BYTES,
    236                                            &alg, &key_type, &key_bits) != PSA_SUCCESS) {
    237                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    238              }
    239          
    240              if (PSA_ALG_IS_AEAD(alg) == 0) {
    241                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    242              }
    243          #else
    244              cipher_info = mbedtls_cipher_info_from_type(cipher);
    245          
    246              if (mbedtls_cipher_info_get_mode(cipher_info) != MBEDTLS_MODE_GCM &&
    247                  mbedtls_cipher_info_get_mode(cipher_info) != MBEDTLS_MODE_CCM &&
    248                  mbedtls_cipher_info_get_mode(cipher_info) != MBEDTLS_MODE_CHACHAPOLY) {
    249                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    250              }
    251          
    252              key_bits = mbedtls_cipher_info_get_key_bitlen(cipher_info);
    253          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    254          
    255              if (key_bits > 8 * MAX_KEY_BYTES) {
    256                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    257              }
    258          
    259              ctx->f_rng = f_rng;
    260              ctx->p_rng = p_rng;
    261          
    262              ctx->ticket_lifetime = lifetime;
    263          
    264          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    265              ctx->keys[0].alg = alg;
    266              ctx->keys[0].key_type = key_type;
    267              ctx->keys[0].key_bits = key_bits;
    268          
    269              ctx->keys[1].alg = alg;
    270              ctx->keys[1].key_type = key_type;
    271              ctx->keys[1].key_bits = key_bits;
    272          #else
    273              if ((ret = mbedtls_cipher_setup(&ctx->keys[0].ctx, cipher_info)) != 0) {
    274                  return ret;
    275              }
    276          
    277              if ((ret = mbedtls_cipher_setup(&ctx->keys[1].ctx, cipher_info)) != 0) {
    278                  return ret;
    279              }
    280          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    281          
    282              if ((ret = ssl_ticket_gen_key(ctx, 0)) != 0 ||
    283                  (ret = ssl_ticket_gen_key(ctx, 1)) != 0) {
    284                  return ret;
    285              }
    286          
    287              return 0;
    288          }
    289          
    290          /*
    291           * Create session ticket, with the following structure:
    292           *
    293           *    struct {
    294           *        opaque key_name[4];
    295           *        opaque iv[12];
    296           *        opaque encrypted_state<0..2^16-1>;
    297           *        opaque tag[16];
    298           *    } ticket;
    299           *
    300           * The key_name, iv, and length of encrypted_state are the additional
    301           * authenticated data.
    302           */
    303          
    304          int mbedtls_ssl_ticket_write(void *p_ticket,
    305                                       const mbedtls_ssl_session *session,
    306                                       unsigned char *start,
    307                                       const unsigned char *end,
    308                                       size_t *tlen,
    309                                       uint32_t *ticket_lifetime)
    310          {
    311              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    312              mbedtls_ssl_ticket_context *ctx = p_ticket;
    313              mbedtls_ssl_ticket_key *key;
    314              unsigned char *key_name = start;
    315              unsigned char *iv = start + TICKET_KEY_NAME_BYTES;
    316              unsigned char *state_len_bytes = iv + TICKET_IV_BYTES;
    317              unsigned char *state = state_len_bytes + TICKET_CRYPT_LEN_BYTES;
    318              size_t clear_len, ciph_len;
    319          
    320          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    321              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    322          #endif
    323          
    324              *tlen = 0;
    325          
    326              if (ctx == NULL || ctx->f_rng == NULL) {
    327                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    328              }
    329          
    330              /* We need at least 4 bytes for key_name, 12 for IV, 2 for len 16 for tag,
    331               * in addition to session itself, that will be checked when writing it. */
    332              MBEDTLS_SSL_CHK_BUF_PTR(start, end, TICKET_MIN_LEN);
    333          
    334          #if defined(MBEDTLS_THREADING_C)
    335              if ((ret = mbedtls_mutex_lock(&ctx->mutex)) != 0) {
    336                  return ret;
    337              }
    338          #endif
    339          
    340              if ((ret = ssl_ticket_update_keys(ctx)) != 0) {
    341                  goto cleanup;
    342              }
    343          
    344              key = &ctx->keys[ctx->active];
    345          
    346              *ticket_lifetime = ctx->ticket_lifetime;
    347          
    348              memcpy(key_name, key->name, TICKET_KEY_NAME_BYTES);
    349          
    350              if ((ret = ctx->f_rng(ctx->p_rng, iv, TICKET_IV_BYTES)) != 0) {
    351                  goto cleanup;
    352              }
    353          
    354              /* Dump session state */
    355              if ((ret = mbedtls_ssl_session_save(session,
    356                                                  state, end - state,
    357                                                  &clear_len)) != 0 ||
    358                  (unsigned long) clear_len > 65535) {
    359                  goto cleanup;
    360              }
    361              MBEDTLS_PUT_UINT16_BE(clear_len, state_len_bytes, 0);
    362          
    363              /* Encrypt and authenticate */
    364          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    365              if ((status = psa_aead_encrypt(key->key, key->alg, iv, TICKET_IV_BYTES,
    366                                             key_name, TICKET_ADD_DATA_LEN,
    367                                             state, clear_len,
    368                                             state, end - state,
    369                                             &ciph_len)) != PSA_SUCCESS) {
    370                  ret = PSA_TO_MBEDTLS_ERR(status);
    371                  goto cleanup;
    372              }
    373          #else
    374              if ((ret = mbedtls_cipher_auth_encrypt_ext(&key->ctx,
    375                                                         iv, TICKET_IV_BYTES,
    376                                                         /* Additional data: key name, IV and length */
    377                                                         key_name, TICKET_ADD_DATA_LEN,
    378                                                         state, clear_len,
    379                                                         state, end - state, &ciph_len,
    380                                                         TICKET_AUTH_TAG_BYTES)) != 0) {
    381                  goto cleanup;
    382              }
    383          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    384          
    385              if (ciph_len != clear_len + TICKET_AUTH_TAG_BYTES) {
    386                  ret = MBEDTLS_ERR_SSL_INTERNAL_ERROR;
    387                  goto cleanup;
    388              }
    389          
    390              *tlen = TICKET_MIN_LEN + ciph_len - TICKET_AUTH_TAG_BYTES;
    391          
    392          cleanup:
    393          #if defined(MBEDTLS_THREADING_C)
    394              if (mbedtls_mutex_unlock(&ctx->mutex) != 0) {
    395                  return MBEDTLS_ERR_THREADING_MUTEX_ERROR;
    396              }
    397          #endif
    398          
    399              return ret;
    400          }
    401          
    402          /*
    403           * Select key based on name
    404           */
    405          static mbedtls_ssl_ticket_key *ssl_ticket_select_key(
    406              mbedtls_ssl_ticket_context *ctx,
    407              const unsigned char name[4])
    408          {
    409              unsigned char i;
    410          
    411              for (i = 0; i < sizeof(ctx->keys) / sizeof(*ctx->keys); i++) {
    412                  if (memcmp(name, ctx->keys[i].name, 4) == 0) {
    413                      return &ctx->keys[i];
    414                  }
    415              }
    416          
    417              return NULL;
    418          }
    419          
    420          /*
    421           * Load session ticket (see mbedtls_ssl_ticket_write for structure)
    422           */
    423          int mbedtls_ssl_ticket_parse(void *p_ticket,
    424                                       mbedtls_ssl_session *session,
    425                                       unsigned char *buf,
    426                                       size_t len)
    427          {
    428              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    429              mbedtls_ssl_ticket_context *ctx = p_ticket;
    430              mbedtls_ssl_ticket_key *key;
    431              unsigned char *key_name = buf;
    432              unsigned char *iv = buf + TICKET_KEY_NAME_BYTES;
    433              unsigned char *enc_len_p = iv + TICKET_IV_BYTES;
    434              unsigned char *ticket = enc_len_p + TICKET_CRYPT_LEN_BYTES;
    435              size_t enc_len, clear_len;
    436          
    437          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    438              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    439          #endif
    440          
    441              if (ctx == NULL || ctx->f_rng == NULL) {
    442                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    443              }
    444          
    445              if (len < TICKET_MIN_LEN) {
    446                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    447              }
    448          
    449          #if defined(MBEDTLS_THREADING_C)
    450              if ((ret = mbedtls_mutex_lock(&ctx->mutex)) != 0) {
    451                  return ret;
    452              }
    453          #endif
    454          
    455              if ((ret = ssl_ticket_update_keys(ctx)) != 0) {
    456                  goto cleanup;
    457              }
    458          
    459              enc_len = (enc_len_p[0] << 8) | enc_len_p[1];
    460          
    461              if (len != TICKET_MIN_LEN + enc_len) {
    462                  ret = MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    463                  goto cleanup;
    464              }
    465          
    466              /* Select key */
    467              if ((key = ssl_ticket_select_key(ctx, key_name)) == NULL) {
    468                  /* We can't know for sure but this is a likely option unless we're
    469                   * under attack - this is only informative anyway */
    470                  ret = MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED;
    471                  goto cleanup;
    472              }
    473          
    474              /* Decrypt and authenticate */
    475          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    476              if ((status = psa_aead_decrypt(key->key, key->alg, iv, TICKET_IV_BYTES,
    477                                             key_name, TICKET_ADD_DATA_LEN,
    478                                             ticket, enc_len + TICKET_AUTH_TAG_BYTES,
    479                                             ticket, enc_len, &clear_len)) != PSA_SUCCESS) {
    480                  ret = PSA_TO_MBEDTLS_ERR(status);
    481                  goto cleanup;
    482              }
    483          #else
    484              if ((ret = mbedtls_cipher_auth_decrypt_ext(&key->ctx,
    485                                                         iv, TICKET_IV_BYTES,
    486                                                         /* Additional data: key name, IV and length */
    487                                                         key_name, TICKET_ADD_DATA_LEN,
    488                                                         ticket, enc_len + TICKET_AUTH_TAG_BYTES,
    489                                                         ticket, enc_len, &clear_len,
    490                                                         TICKET_AUTH_TAG_BYTES)) != 0) {
    491                  if (ret == MBEDTLS_ERR_CIPHER_AUTH_FAILED) {
    492                      ret = MBEDTLS_ERR_SSL_INVALID_MAC;
    493                  }
    494          
    495                  goto cleanup;
    496              }
    497          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    498          
    499              if (clear_len != enc_len) {
    500                  ret = MBEDTLS_ERR_SSL_INTERNAL_ERROR;
    501                  goto cleanup;
    502              }
    503          
    504              /* Actually load session */
    505              if ((ret = mbedtls_ssl_session_load(session, ticket, clear_len)) != 0) {
    506                  goto cleanup;
    507              }
    508          
    509          #if defined(MBEDTLS_HAVE_TIME)
    510              {
    511                  /* Check for expiration */
    512                  mbedtls_time_t current_time = mbedtls_time(NULL);
    513          
    514                  if (current_time < session->start ||
    515                      (uint32_t) (current_time - session->start) > ctx->ticket_lifetime) {
    516                      ret = MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED;
    517                      goto cleanup;
    518                  }
    519              }
    520          #endif
    521          
    522          cleanup:
    523          #if defined(MBEDTLS_THREADING_C)
    524              if (mbedtls_mutex_unlock(&ctx->mutex) != 0) {
    525                  return MBEDTLS_ERR_THREADING_MUTEX_ERROR;
    526              }
    527          #endif
    528          
    529              return ret;
    530          }
    531          
    532          /*
    533           * Free context
    534           */
    535          void mbedtls_ssl_ticket_free(mbedtls_ssl_ticket_context *ctx)
    536          {
    537          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    538              psa_destroy_key(ctx->keys[0].key);
    539              psa_destroy_key(ctx->keys[1].key);
    540          #else
    541              mbedtls_cipher_free(&ctx->keys[0].ctx);
    542              mbedtls_cipher_free(&ctx->keys[1].ctx);
    543          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    544          
    545          #if defined(MBEDTLS_THREADING_C)
    546              mbedtls_mutex_free(&ctx->mutex);
    547          #endif
    548          
    549              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_ssl_ticket_context));
    550          }
    551          
    552          #endif /* MBEDTLS_SSL_TICKET_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
