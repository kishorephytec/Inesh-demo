###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:22
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\bignum.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\bignum.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\bignum.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\bignum.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\bignum.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\bignum.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\bignum.c
      1          /*
      2           *  Multi-precision integer library
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           *  The following sources were referenced in the design of this Multi-precision
     22           *  Integer library:
     23           *
     24           *  [1] Handbook of Applied Cryptography - 1997
     25           *      Menezes, van Oorschot and Vanstone
     26           *
     27           *  [2] Multi-Precision Math
     28           *      Tom St Denis
     29           *      https://github.com/libtom/libtommath/blob/develop/tommath.pdf
     30           *
     31           *  [3] GNU Multi-Precision Arithmetic Library
     32           *      https://gmplib.org/manual/index.html
     33           *
     34           */
     35          
     36          #include "common.h"
     37          
     38          #if defined(MBEDTLS_BIGNUM_C)
     39          
     40          #include "mbedtls/bignum.h"
     41          #include "bignum_core.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_compiler_opaque(uint32_t)
   \                     mbedtls_ct_compiler_opaque: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable3
   \        0x2   0x6811             LDR      R1,[R2, #+0]
   \        0x4   0x4048             EORS     R0,R1,R0
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool(uint32_t)
   \                     mbedtls_ct_bool: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable3
   \        0x2   0x6811             LDR      R1,[R2, #+0]
   \        0x4   0x4048             EORS     R0,R1,R0
   \        0x6   0x4241             RSBS     R1,R0,#+0
   \        0x8   0x0840             LSRS     R0,R0,#+1
   \        0xA   0x4240             RSBS     R0,R0,#+0
   \        0xC   0x4308             ORRS     R0,R0,R1
   \        0xE   0x0FC0             LSRS     R0,R0,#+31
   \       0x10   0x4240             RSBS     R0,R0,#+0
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned int mbedtls_ct_uint_if(uint32_t, unsigned int, unsigned int)
   \                     mbedtls_ct_uint_if: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable3
   \        0x4   0x6823             LDR      R3,[R4, #+0]
   \        0x6   0x4001             ANDS     R1,R1,R0
   \        0x8   0x4058             EORS     R0,R3,R0
   \        0xA   0xEA22 0x0000      BIC      R0,R2,R0
   \        0xE   0x4308             ORRS     R0,R0,R1
   \       0x10   0xBD10             POP      {R4,PC}
     42          #include "bn_mul.h"
     43          #include "mbedtls/platform_util.h"
     44          #include "mbedtls/error.h"
     45          #include "constant_time_internal.h"
     46          
     47          #include <limits.h>
     48          #include <string.h>
     49          
     50          #include "mbedtls/platform.h"
     51          
     52          #define MPI_VALIDATE_RET(cond)                                       \
     53              MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_MPI_BAD_INPUT_DATA)
     54          #define MPI_VALIDATE(cond)                                           \
     55              MBEDTLS_INTERNAL_VALIDATE(cond)
     56          
     57          /*
     58           * Compare signed values in constant time
     59           */

   \                                 In section .text, align 2, keep-with-next
     60          int mbedtls_mpi_lt_mpi_ct(const mbedtls_mpi *X,
     61                                    const mbedtls_mpi *Y,
     62                                    unsigned *ret)
     63          {
   \                     mbedtls_mpi_lt_mpi_ct: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
     64              mbedtls_ct_condition_t different_sign, X_is_negative, Y_is_negative, result;
     65          
     66              MPI_VALIDATE_RET(X != NULL);
     67              MPI_VALIDATE_RET(Y != NULL);
     68              MPI_VALIDATE_RET(ret != NULL);
     69          
     70              if (X->n != Y->n) {
   \        0x8   0x88E1             LDRH     R1,[R4, #+6]
   \        0xA   0x88F0             LDRH     R0,[R6, #+6]
   \        0xC   0x4690             MOV      R8,R2
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xBF18             IT       NE
   \       0x12   0xF06F 0x0003      MVNNE    R0,#+3
     71                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x16   0xD126             BNE.N    ??mbedtls_mpi_lt_mpi_ct_0
     72              }
     73          
     74              /*
     75               * Set N_is_negative to MBEDTLS_CT_FALSE if N >= 0, MBEDTLS_CT_TRUE if N < 0.
     76               * We know that N->s == 1 if N >= 0 and N->s == -1 if N < 0.
     77               */
     78              X_is_negative = mbedtls_ct_bool((X->s & 2) >> 1);
   \       0x18   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \       0x1C   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x20   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x24   0x4607             MOV      R7,R0
     79              Y_is_negative = mbedtls_ct_bool((Y->s & 2) >> 1);
     80          
     81              /*
     82               * If the signs are different, then the positive operand is the bigger.
     83               * That is if X is negative (X_is_negative == 1), then X < Y is true and it
     84               * is false if X is positive (X_is_negative == 0).
     85               */
     86              different_sign = mbedtls_ct_bool_ne(X_is_negative, Y_is_negative); // true if different sign
   \       0x26   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \       0x2A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x2E   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x32   0xEA80 0x0507      EOR      R5,R0,R7
     87              result = mbedtls_ct_bool_and(different_sign, X_is_negative);
     88          
     89              /*
     90               * Assuming signs are the same, compare X and Y. We switch the comparison
     91               * order if they are negative so that we get the right result, regardles of
     92               * sign.
     93               */
     94          
     95              /* This array is used to conditionally swap the pointers in const time */
     96              void * const p[2] = { X->p, Y->p };
   \       0x36   0x6820             LDR      R0,[R4, #+0]
     97              size_t i = mbedtls_ct_size_if_else_0(X_is_negative, 1);
   \       0x38   0xF007 0x0301      AND      R3,R7,#0x1
     98              mbedtls_ct_condition_t lt = mbedtls_mpi_core_lt_ct(p[i], p[i ^ 1], X->n);
     99          
    100              /*
    101               * Store in result iff the signs are the same (i.e., iff different_sign == false). If
    102               * the signs differ, result has already been set, so we don't change it.
    103               */
    104              result = mbedtls_ct_bool_or(result,
    105                                          mbedtls_ct_bool_and(mbedtls_ct_bool_not(different_sign), lt));
    106          
    107              *ret = mbedtls_ct_uint_if_else_0(result, 1);
   \       0x3C   0x402F             ANDS     R7,R7,R5
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x6831             LDR      R1,[R6, #+0]
   \       0x42   0x9101             STR      R1,[SP, #+4]
   \       0x44   0xF083 0x0101      EOR      R1,R3,#0x1
   \       0x48   0x88E2             LDRH     R2,[R4, #+6]
   \       0x4A   0xF85D 0x1021      LDR      R1,[SP, R1, LSL #+2]
   \       0x4E   0xF85D 0x0023      LDR      R0,[SP, R3, LSL #+2]
   \       0x52   0x.... 0x....      BL       mbedtls_mpi_core_lt_ct
   \       0x56   0xEA20 0x0505      BIC      R5,R0,R5
   \       0x5A   0x432F             ORRS     R7,R5,R7
   \       0x5C   0xF007 0x0701      AND      R7,R7,#0x1
   \       0x60   0xF8C8 0x7000      STR      R7,[R8, #+0]
    108          
    109              return 0;
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_lt_mpi_ct_0: (+1)
   \       0x66   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    110          }
    111          
    112          /*
    113           * Conditionally assign X = Y, without leaking information
    114           * about whether the assignment was made or not.
    115           * (Leaking information about the respective sizes of X and Y is ok however.)
    116           */
    117          #if defined(_MSC_VER) && defined(_M_ARM64) && (_MSC_FULL_VER < 193131103)
    118          /*
    119           * MSVC miscompiles this function if it's inlined prior to Visual Studio 2022 version 17.1. See:
    120           * https://developercommunity.visualstudio.com/t/c-compiler-miscompiles-part-of-mbedtls-library-on/1646989
    121           */
    122          __declspec(noinline)
    123          #endif

   \                                 In section .text, align 2, keep-with-next
    124          int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X,
    125                                           const mbedtls_mpi *Y,
    126                                           unsigned char assign)
    127          {
   \                     mbedtls_mpi_safe_cond_assign: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460E             MOV      R6,R1
    128              int ret = 0;
    129              MPI_VALIDATE_RET(X != NULL);
    130              MPI_VALIDATE_RET(Y != NULL);
    131          
    132              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, Y->n));
   \        0x4   0x88F1             LDRH     R1,[R6, #+6]
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_grow
   \        0xE   0x0004             MOVS     R4,R0
   \       0x10   0xD11D             BNE.N    ??mbedtls_mpi_safe_cond_assign_0
    133          
    134              {
    135                  mbedtls_ct_condition_t do_assign = mbedtls_ct_bool(assign);
   \       0x12   0x4638             MOV      R0,R7
   \       0x14   0x.... 0x....      BL       mbedtls_ct_bool
    136          
    137                  X->s = (int) mbedtls_ct_uint_if(do_assign, Y->s, X->s);
   \       0x18   0xF9B5 0x2004      LDRSH    R2,[R5, #+4]
   \       0x1C   0xF9B6 0x1004      LDRSH    R1,[R6, #+4]
   \       0x20   0x4607             MOV      R7,R0
   \       0x22   0x.... 0x....      BL       mbedtls_ct_uint_if
   \       0x26   0x80A8             STRH     R0,[R5, #+4]
    138          
    139                  mbedtls_mpi_core_cond_assign(X->p, Y->p, Y->n, do_assign);
   \       0x28   0x88F2             LDRH     R2,[R6, #+6]
   \       0x2A   0x6831             LDR      R1,[R6, #+0]
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x463B             MOV      R3,R7
   \       0x30   0x43FF             MVNS     R7,R7
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_core_cond_assign
    140          
    141                  mbedtls_ct_condition_t do_not_assign = mbedtls_ct_bool_not(do_assign);
    142                  for (size_t i = Y->n; i < X->n; i++) {
   \       0x36   0x88F1             LDRH     R1,[R6, #+6]
   \       0x38   0xE006             B.N      ??mbedtls_mpi_safe_cond_assign_1
    143                      X->p[i] = mbedtls_ct_mpi_uint_if_else_0(do_not_assign, X->p[i]);
   \                     ??mbedtls_mpi_safe_cond_assign_2: (+1)
   \       0x3A   0x682A             LDR      R2,[R5, #+0]
   \       0x3C   0xF852 0x0021      LDR      R0,[R2, R1, LSL #+2]
   \       0x40   0x4038             ANDS     R0,R0,R7
   \       0x42   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \       0x46   0x1C49             ADDS     R1,R1,#+1
   \                     ??mbedtls_mpi_safe_cond_assign_1: (+1)
   \       0x48   0x88E8             LDRH     R0,[R5, #+6]
   \       0x4A   0x4281             CMP      R1,R0
   \       0x4C   0xD3F5             BCC.N    ??mbedtls_mpi_safe_cond_assign_2
    144                  }
    145              }
    146          
    147          cleanup:
    148              return ret;
   \                     ??mbedtls_mpi_safe_cond_assign_0: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0xBDF2             POP      {R1,R4-R7,PC}
    149          }
    150          
    151          /*
    152           * Conditionally swap X and Y, without leaking information
    153           * about whether the swap was made or not.
    154           * Here it is not ok to simply swap the pointers, which would lead to
    155           * different memory access patterns when X and Y are used afterwards.
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          int mbedtls_mpi_safe_cond_swap(mbedtls_mpi *X,
    158                                         mbedtls_mpi *Y,
    159                                         unsigned char swap)
    160          {
   \                     mbedtls_mpi_safe_cond_swap: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    161              int ret = 0;
    162              int s;
    163              MPI_VALIDATE_RET(X != NULL);
    164              MPI_VALIDATE_RET(Y != NULL);
    165          
    166              if (X == Y) {
   \        0x8   0x42B5             CMP      R5,R6
   \        0xA   0xBF08             IT       EQ
   \        0xC   0x2000             MOVEQ    R0,#+0
    167                  return 0;
   \        0xE   0xD026             BEQ.N    ??mbedtls_mpi_safe_cond_swap_0
    168              }
    169          
    170              mbedtls_ct_condition_t do_swap = mbedtls_ct_bool(swap);
   \       0x10   0x4610             MOV      R0,R2
   \       0x12   0x.... 0x....      BL       mbedtls_ct_bool
    171          
    172              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, Y->n));
   \       0x16   0x88F1             LDRH     R1,[R6, #+6]
   \       0x18   0x4680             MOV      R8,R0
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x20   0x0004             MOVS     R4,R0
   \       0x22   0xD11B             BNE.N    ??mbedtls_mpi_safe_cond_swap_1
    173              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(Y, X->n));
   \       0x24   0x88E9             LDRH     R1,[R5, #+6]
   \       0x26   0x4630             MOV      R0,R6
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x2C   0x0004             MOVS     R4,R0
   \       0x2E   0xD115             BNE.N    ??mbedtls_mpi_safe_cond_swap_1
    174          
    175              s = X->s;
   \       0x30   0xF9B5 0x2004      LDRSH    R2,[R5, #+4]
    176              X->s = (int) mbedtls_ct_uint_if(do_swap, Y->s, X->s);
   \       0x34   0xF9B6 0x1004      LDRSH    R1,[R6, #+4]
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0x4617             MOV      R7,R2
   \       0x3C   0x.... 0x....      BL       mbedtls_ct_uint_if
   \       0x40   0x80A8             STRH     R0,[R5, #+4]
    177              Y->s = (int) mbedtls_ct_uint_if(do_swap, s, Y->s);
   \       0x42   0xF9B6 0x2004      LDRSH    R2,[R6, #+4]
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0x4640             MOV      R0,R8
   \       0x4A   0x.... 0x....      BL       mbedtls_ct_uint_if
   \       0x4E   0x80B0             STRH     R0,[R6, #+4]
    178          
    179              mbedtls_mpi_core_cond_swap(X->p, Y->p, X->n, do_swap);
   \       0x50   0x88EA             LDRH     R2,[R5, #+6]
   \       0x52   0x6831             LDR      R1,[R6, #+0]
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0x4643             MOV      R3,R8
   \       0x58   0x.... 0x....      BL       mbedtls_mpi_core_cond_swap
    180          
    181          cleanup:
    182              return ret;
   \                     ??mbedtls_mpi_safe_cond_swap_1: (+1)
   \       0x5C   0x4620             MOV      R0,R4
   \                     ??mbedtls_mpi_safe_cond_swap_0: (+1)
   \       0x5E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    183          }
    184          
    185          /* Implementation that should never be optimized out by the compiler */
    186          #define mbedtls_mpi_zeroize_and_free(v, n) mbedtls_zeroize_and_free(v, ciL * (n))
    187          
    188          /*
    189           * Initialize one MPI
    190           */

   \                                 In section .text, align 2, keep-with-next
    191          void mbedtls_mpi_init(mbedtls_mpi *X)
    192          {
    193              MPI_VALIDATE(X != NULL);
    194          
    195              X->s = 1;
   \                     mbedtls_mpi_init: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
    196              X->n = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x8081             STRH     R1,[R0, #+4]
   \        0x6   0x80C2             STRH     R2,[R0, #+6]
    197              X->p = NULL;
   \        0x8   0x6002             STR      R2,[R0, #+0]
    198          }
   \        0xA   0x4770             BX       LR
    199          
    200          /*
    201           * Unallocate one MPI
    202           */

   \                                 In section .text, align 2, keep-with-next
    203          void mbedtls_mpi_free(mbedtls_mpi *X)
    204          {
   \                     mbedtls_mpi_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    205              if (X == NULL) {
   \        0x4   0xD00A             BEQ.N    ??mbedtls_mpi_free_0
    206                  return;
    207              }
    208          
    209              if (X->p != NULL) {
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xB118             CBZ.N    R0,??mbedtls_mpi_free_1
    210                  mbedtls_mpi_zeroize_and_free(X->p, X->n);
   \        0xA   0x88E1             LDRH     R1,[R4, #+6]
   \        0xC   0x0089             LSLS     R1,R1,#+2
   \        0xE   0x.... 0x....      BL       mbedtls_zeroize_and_free
    211              }
    212          
    213              X->s = 1;
   \                     ??mbedtls_mpi_free_1: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
    214              X->n = 0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x80A2             STRH     R2,[R4, #+4]
   \       0x18   0x80E1             STRH     R1,[R4, #+6]
    215              X->p = NULL;
   \       0x1A   0x6021             STR      R1,[R4, #+0]
    216          }
   \                     ??mbedtls_mpi_free_0: (+1)
   \       0x1C   0xBD10             POP      {R4,PC}
    217          
    218          /*
    219           * Enlarge to the specified number of limbs
    220           */

   \                                 In section .text, align 2, keep-with-next
    221          int mbedtls_mpi_grow(mbedtls_mpi *X, size_t nblimbs)
    222          {
   \                     mbedtls_mpi_grow: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
    223              mbedtls_mpi_uint *p;
    224              MPI_VALIDATE_RET(X != NULL);
    225          
    226              if (nblimbs > MBEDTLS_MPI_MAX_LIMBS) {
   \                     ??CrossCallReturnLabel_19: (+1)
   \        0x6   0xD208             BCS.N    ??mbedtls_mpi_grow_0
    227                  return MBEDTLS_ERR_MPI_ALLOC_FAILED;
    228              }
    229          
    230              if (X->n < nblimbs) {
   \        0x8   0x88F2             LDRH     R2,[R6, #+6]
   \        0xA   0x42AA             CMP      R2,R5
   \        0xC   0xD210             BCS.N    ??mbedtls_mpi_grow_1
    231                  if ((p = (mbedtls_mpi_uint *) mbedtls_calloc(nblimbs, ciL)) == NULL) {
   \        0xE   0x2104             MOVS     R1,#+4
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x.... 0x....      BL       sl_calloc
   \       0x16   0x0004             MOVS     R4,R0
   \       0x18   0xD100             BNE.N    ??mbedtls_mpi_grow_2
    232                      return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   \                     ??mbedtls_mpi_grow_0: (+1)
   \       0x1A   0x....             B.N      ?Subroutine0
    233                  }
    234          
    235                  if (X->p != NULL) {
   \                     ??mbedtls_mpi_grow_2: (+1)
   \       0x1C   0x6831             LDR      R1,[R6, #+0]
   \       0x1E   0xB129             CBZ.N    R1,??CrossCallReturnLabel_5
    236                      memcpy(p, X->p, X->n * ciL);
   \       0x20   0x88F2             LDRH     R2,[R6, #+6]
   \       0x22   0x0092             LSLS     R2,R2,#+2
   \       0x24   0x.... 0x....      BL       __aeabi_memcpy
    237                      mbedtls_mpi_zeroize_and_free(X->p, X->n);
   \       0x28   0x.... 0x....      BL       ?Subroutine3
    238                  }
    239          
    240                  /* nblimbs fits in n because we ensure that MBEDTLS_MPI_MAX_LIMBS
    241                   * fits, and we've checked that nblimbs <= MBEDTLS_MPI_MAX_LIMBS. */
    242                  X->n = (unsigned short) nblimbs;
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x2C   0x80F5             STRH     R5,[R6, #+6]
    243                  X->p = p;
   \       0x2E   0x6034             STR      R4,[R6, #+0]
    244              }
    245          
    246              return 0;
   \                     ??mbedtls_mpi_grow_1: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD70             POP      {R4-R6,PC}
    247          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0xF242 0x7011      MOVW     R0,#+10001
   \        0x8   0x4285             CMP      R5,R0
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x88F1             LDRH     R1,[R6, #+6]
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \        0x4   0x0089             LSLS     R1,R1,#+2
   \        0x6   0x.... 0x....      B.W      mbedtls_zeroize_and_free

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x000F      MVN      R0,#+15
   \        0x4   0xBD70             POP      {R4-R6,PC}
    248          
    249          /*
    250           * Resize down as much as possible,
    251           * while keeping at least the specified number of limbs
    252           */

   \                                 In section .text, align 2, keep-with-next
    253          int mbedtls_mpi_shrink(mbedtls_mpi *X, size_t nblimbs)
    254          {
   \                     mbedtls_mpi_shrink: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine8
    255              mbedtls_mpi_uint *p;
    256              size_t i;
    257              MPI_VALIDATE_RET(X != NULL);
    258          
    259              if (nblimbs > MBEDTLS_MPI_MAX_LIMBS) {
   \                     ??CrossCallReturnLabel_20: (+1)
   \        0x6   0xD217             BCS.N    ??mbedtls_mpi_shrink_0
    260                  return MBEDTLS_ERR_MPI_ALLOC_FAILED;
    261              }
    262          
    263              /* Actually resize up if there are currently fewer than nblimbs limbs. */
    264              if (X->n <= nblimbs) {
   \        0x8   0x88F0             LDRH     R0,[R6, #+6]
   \        0xA   0x4285             CMP      R5,R0
   \        0xC   0xD303             BCC.N    ??mbedtls_mpi_shrink_1
    265                  return mbedtls_mpi_grow(X, nblimbs);
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x14   0x....             B.N      mbedtls_mpi_grow
    266              }
    267              /* After this point, then X->n > nblimbs and in particular X->n > 0. */
    268          
    269              for (i = X->n - 1; i > 0; i--) {
   \                     ??mbedtls_mpi_shrink_1: (+1)
   \       0x16   0x1E40             SUBS     R0,R0,#+1
   \       0x18   0xD004             BEQ.N    ??mbedtls_mpi_shrink_2
    270                  if (X->p[i] != 0) {
   \       0x1A   0x6832             LDR      R2,[R6, #+0]
   \       0x1C   0xF852 0x1020      LDR      R1,[R2, R0, LSL #+2]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD0F8             BEQ.N    ??mbedtls_mpi_shrink_1
    271                      break;
    272                  }
    273              }
    274              i++;
   \                     ??mbedtls_mpi_shrink_2: (+1)
   \       0x24   0x1C40             ADDS     R0,R0,#+1
    275          
    276              if (i < nblimbs) {
   \       0x26   0x4285             CMP      R5,R0
   \       0x28   0xBF38             IT       CC
   \       0x2A   0x4605             MOVCC    R5,R0
    277                  i = nblimbs;
    278              }
    279          
    280              if ((p = (mbedtls_mpi_uint *) mbedtls_calloc(i, ciL)) == NULL) {
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x.... 0x....      BL       sl_calloc
   \       0x34   0x0004             MOVS     R4,R0
   \       0x36   0xD100             BNE.N    ??mbedtls_mpi_shrink_3
    281                  return MBEDTLS_ERR_MPI_ALLOC_FAILED;
   \                     ??mbedtls_mpi_shrink_0: (+1)
   \       0x38   0x....             B.N      ?Subroutine0
    282              }
    283          
    284              if (X->p != NULL) {
   \                     ??mbedtls_mpi_shrink_3: (+1)
   \       0x3A   0x6831             LDR      R1,[R6, #+0]
   \       0x3C   0xB121             CBZ.N    R1,??CrossCallReturnLabel_4
    285                  memcpy(p, X->p, i * ciL);
   \       0x3E   0x00AA             LSLS     R2,R5,#+2
   \       0x40   0x.... 0x....      BL       __aeabi_memcpy
    286                  mbedtls_mpi_zeroize_and_free(X->p, X->n);
   \       0x44   0x.... 0x....      BL       ?Subroutine3
    287              }
    288          
    289              /* i fits in n because we ensure that MBEDTLS_MPI_MAX_LIMBS
    290               * fits, and we've checked that i <= nblimbs <= MBEDTLS_MPI_MAX_LIMBS. */
    291              X->n = (unsigned short) i;
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x48   0x80F5             STRH     R5,[R6, #+6]
    292              X->p = p;
   \       0x4A   0x6034             STR      R4,[R6, #+0]
    293          
    294              return 0;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD70             POP      {R4-R6,PC}
    295          }
    296          
    297          /* Resize X to have exactly n limbs and set it to 0. */

   \                                 In section .text, align 2, keep-with-next
    298          static int mbedtls_mpi_resize_clear(mbedtls_mpi *X, size_t limbs)
    299          {
   \                     mbedtls_mpi_resize_clear: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    300              if (limbs == 0) {
   \        0x6   0xD102             BNE.N    ??mbedtls_mpi_resize_clear_0
    301                  mbedtls_mpi_free(X);
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_free
    302                  return 0;
   \        0xC   0xE008             B.N      ??mbedtls_mpi_resize_clear_1
    303              } else if (X->n == limbs) {
   \                     ??mbedtls_mpi_resize_clear_0: (+1)
   \        0xE   0x88E8             LDRH     R0,[R5, #+6]
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD107             BNE.N    ??mbedtls_mpi_resize_clear_2
    304                  memset(X->p, 0, limbs * ciL);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x00A1             LSLS     R1,R4,#+2
   \       0x18   0x.... 0x....      BL       __aeabi_memclr4
    305                  X->s = 1;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x80A8             STRH     R0,[R5, #+4]
    306                  return 0;
   \                     ??mbedtls_mpi_resize_clear_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
    307              } else {
    308                  mbedtls_mpi_free(X);
   \                     ??mbedtls_mpi_resize_clear_2: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_free
    309                  return mbedtls_mpi_grow(X, limbs);
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x32   0x....             B.N      mbedtls_mpi_grow
    310              }
    311          }
    312          
    313          /*
    314           * Copy the contents of Y into X.
    315           *
    316           * This function is not constant-time. Leading zeros in Y may be removed.
    317           *
    318           * Ensure that X does not shrink. This is not guaranteed by the public API,
    319           * but some code in the bignum module relies on this property, for example
    320           * in mbedtls_mpi_exp_mod().
    321           */

   \                                 In section .text, align 2, keep-with-next
    322          int mbedtls_mpi_copy(mbedtls_mpi *X, const mbedtls_mpi *Y)
    323          {
   \                     mbedtls_mpi_copy: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
    324              int ret = 0;
   \        0x6   0x2500             MOVS     R5,#+0
    325              size_t i;
    326              MPI_VALIDATE_RET(X != NULL);
    327              MPI_VALIDATE_RET(Y != NULL);
    328          
    329              if (X == Y) {
   \        0x8   0x42BE             CMP      R6,R7
   \        0xA   0xD009             BEQ.N    ??mbedtls_mpi_copy_0
    330                  return 0;
    331              }
    332          
    333              if (Y->n == 0) {
   \        0xC   0x88FC             LDRH     R4,[R7, #+6]
   \        0xE   0xB94C             CBNZ.N   R4,??mbedtls_mpi_copy_1
    334                  if (X->n != 0) {
   \       0x10   0x88F1             LDRH     R1,[R6, #+6]
   \       0x12   0xB129             CBZ.N    R1,??mbedtls_mpi_copy_0
    335                      X->s = 1;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x80B0             STRH     R0,[R6, #+4]
    336                      memset(X->p, 0, X->n * ciL);
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x0089             LSLS     R1,R1,#+2
   \       0x1C   0x.... 0x....      BL       __aeabi_memclr4
    337                  }
    338                  return 0;
   \                     ??mbedtls_mpi_copy_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}
    339              }
    340          
    341              for (i = Y->n - 1; i > 0; i--) {
   \                     ??mbedtls_mpi_copy_1: (+1)
   \       0x24   0x1E64             SUBS     R4,R4,#+1
   \       0x26   0xD004             BEQ.N    ??mbedtls_mpi_copy_2
    342                  if (Y->p[i] != 0) {
   \       0x28   0x6839             LDR      R1,[R7, #+0]
   \       0x2A   0xF851 0x0024      LDR      R0,[R1, R4, LSL #+2]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0F8             BEQ.N    ??mbedtls_mpi_copy_1
    343                      break;
    344                  }
    345              }
    346              i++;
    347          
    348              X->s = Y->s;
   \                     ??mbedtls_mpi_copy_2: (+1)
   \       0x32   0x88B8             LDRH     R0,[R7, #+4]
    349          
    350              if (X->n < i) {
   \       0x34   0x88F1             LDRH     R1,[R6, #+6]
   \       0x36   0x1C64             ADDS     R4,R4,#+1
   \       0x38   0x80B0             STRH     R0,[R6, #+4]
   \       0x3A   0x42A1             CMP      R1,R4
   \       0x3C   0xD206             BCS.N    ??mbedtls_mpi_copy_3
    351                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i));
   \       0x3E   0x4621             MOV      R1,R4
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x46   0x0005             MOVS     R5,R0
   \       0x48   0xD10C             BNE.N    ??mbedtls_mpi_copy_4
   \       0x4A   0xE006             B.N      ??mbedtls_mpi_copy_5
    352              } else {
    353                  memset(X->p + i, 0, (X->n - i) * ciL);
   \                     ??mbedtls_mpi_copy_3: (+1)
   \       0x4C   0x6830             LDR      R0,[R6, #+0]
   \       0x4E   0x1B09             SUBS     R1,R1,R4
   \       0x50   0x0089             LSLS     R1,R1,#+2
   \       0x52   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x56   0x.... 0x....      BL       __aeabi_memclr
    354              }
    355          
    356              memcpy(X->p, Y->p, i * ciL);
   \                     ??mbedtls_mpi_copy_5: (+1)
   \       0x5A   0x6839             LDR      R1,[R7, #+0]
   \       0x5C   0x6830             LDR      R0,[R6, #+0]
   \       0x5E   0x00A2             LSLS     R2,R4,#+2
   \       0x60   0x.... 0x....      BL       __aeabi_memcpy4
    357          
    358          cleanup:
    359          
    360              return ret;
   \                     ??mbedtls_mpi_copy_4: (+1)
   \       0x64   0x4628             MOV      R0,R5
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}
    361          }
    362          
    363          /*
    364           * Swap the contents of X and Y
    365           */

   \                                 In section .text, align 2, keep-with-next
    366          void mbedtls_mpi_swap(mbedtls_mpi *X, mbedtls_mpi *Y)
    367          {
   \                     mbedtls_mpi_swap: (+1)
   \        0x0   0xB082             SUB      SP,SP,#+8
    368              mbedtls_mpi T;
    369              MPI_VALIDATE(X != NULL);
    370              MPI_VALIDATE(Y != NULL);
    371          
    372              memcpy(&T,  X, sizeof(mbedtls_mpi));
   \        0x2   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \        0x6   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
    373              memcpy(X,  Y, sizeof(mbedtls_mpi));
   \        0xA   0xE9D1 0x3200      LDRD     R3,R2,[R1, #+0]
   \        0xE   0xE9C0 0x3200      STRD     R3,R2,[R0, #+0]
    374              memcpy(Y, &T, sizeof(mbedtls_mpi));
   \       0x12   0xE9DD 0x2000      LDRD     R2,R0,[SP, #+0]
   \       0x16   0xE9C1 0x2000      STRD     R2,R0,[R1, #+0]
    375          }
   \       0x1A   0xB002             ADD      SP,SP,#+8
   \       0x1C   0x4770             BX       LR
    376          
    377          static inline mbedtls_mpi_uint mpi_sint_abs(mbedtls_mpi_sint z)
    378          {
    379              if (z >= 0) {
    380                  return z;
    381              }
    382              /* Take care to handle the most negative value (-2^(biL-1)) correctly.
    383               * A naive -z would have undefined behavior.
    384               * Write this in a way that makes popular compilers happy (GCC, Clang,
    385               * MSVC). */
    386              return (mbedtls_mpi_uint) 0 - (mbedtls_mpi_uint) z;
    387          }
    388          
    389          /* Convert x to a sign, i.e. to 1, if x is positive, or -1, if x is negative.
    390           * This looks awkward but generates smaller code than (x < 0 ? -1 : 1) */
    391          #define TO_SIGN(x) ((mbedtls_mpi_sint) (((mbedtls_mpi_uint) x) >> (biL - 1)) * -2 + 1)
    392          
    393          /*
    394           * Set value from integer
    395           */

   \                                 In section .text, align 2, keep-with-next
    396          int mbedtls_mpi_lset(mbedtls_mpi *X, mbedtls_mpi_sint z)
    397          {
   \                     mbedtls_mpi_lset: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4605             MOV      R5,R0
    398              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    399              MPI_VALIDATE_RET(X != NULL);
    400          
    401              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, 1));
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_grow
   \        0xC   0x0004             MOVS     R4,R0
   \        0xE   0xD10F             BNE.N    ??mbedtls_mpi_lset_0
    402              memset(X->p, 0, X->n * ciL);
   \       0x10   0x88E9             LDRH     R1,[R5, #+6]
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x0089             LSLS     R1,R1,#+2
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
    403          
    404              X->p[0] = mpi_sint_abs(z);
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xBF54             ITE      PL
   \       0x1E   0x4631             MOVPL    R1,R6
   \       0x20   0x4271             RSBMI    R1,R6,#+0
   \       0x22   0x6828             LDR      R0,[R5, #+0]
    405              X->s    = TO_SIGN(z);
   \       0x24   0x0FF6             LSRS     R6,R6,#+31
   \       0x26   0x0076             LSLS     R6,R6,#+1
   \       0x28   0x6001             STR      R1,[R0, #+0]
   \       0x2A   0xF1C6 0x0601      RSB      R6,R6,#+1
   \       0x2E   0x80AE             STRH     R6,[R5, #+4]
    406          
    407          cleanup:
    408          
    409              return ret;
   \                     ??mbedtls_mpi_lset_0: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0xBD70             POP      {R4-R6,PC}
    410          }
    411          
    412          /*
    413           * Get a specific bit
    414           */

   \                                 In section .text, align 2, keep-with-next
    415          int mbedtls_mpi_get_bit(const mbedtls_mpi *X, size_t pos)
    416          {
    417              MPI_VALIDATE_RET(X != NULL);
    418          
    419              if (X->n * biL <= pos) {
   \                     mbedtls_mpi_get_bit: (+1)
   \        0x0   0x88C2             LDRH     R2,[R0, #+6]
   \        0x2   0xEBB1 0x1F42      CMP      R1,R2, LSL #+5
   \        0x6   0xD301             BCC.N    ??mbedtls_mpi_get_bit_0
    420                  return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
    421              }
    422          
    423              return (X->p[pos / biL] >> (pos % biL)) & 0x01;
   \                     ??mbedtls_mpi_get_bit_0: (+1)
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0x0948             LSRS     R0,R1,#+5
   \       0x10   0xF001 0x011F      AND      R1,R1,#0x1F
   \       0x14   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \       0x18   0x40C8             LSRS     R0,R0,R1
   \       0x1A   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x1E   0x4770             BX       LR
    424          }
    425          
    426          /*
    427           * Set a bit to a specific value of 0 or 1
    428           */

   \                                 In section .text, align 2, keep-with-next
    429          int mbedtls_mpi_set_bit(mbedtls_mpi *X, size_t pos, unsigned char val)
    430          {
   \                     mbedtls_mpi_set_bit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x4614             MOV      R4,R2
    431              int ret = 0;
   \        0x6   0x2000             MOVS     R0,#+0
    432              size_t off = pos / biL;
   \        0x8   0x094D             LSRS     R5,R1,#+5
    433              size_t idx = pos % biL;
   \        0xA   0xF001 0x061F      AND      R6,R1,#0x1F
    434              MPI_VALIDATE_RET(X != NULL);
    435          
    436              if (val != 0 && val != 1) {
   \        0xE   0x0022             MOVS     R2,R4
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2C01             CMPNE    R4,#+1
   \       0x14   0xD002             BEQ.N    ??mbedtls_mpi_set_bit_0
    437                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x16   0xF06F 0x0003      MVN      R0,#+3
   \       0x1A   0xBDF2             POP      {R1,R4-R7,PC}
    438              }
    439          
    440              if (X->n * biL <= pos) {
   \                     ??mbedtls_mpi_set_bit_0: (+1)
   \       0x1C   0x88FA             LDRH     R2,[R7, #+6]
   \       0x1E   0xEBB1 0x1F42      CMP      R1,R2, LSL #+5
   \       0x22   0xD307             BCC.N    ??mbedtls_mpi_set_bit_1
    441                  if (val == 0) {
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xD101             BNE.N    ??mbedtls_mpi_set_bit_2
    442                      return 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBDF2             POP      {R1,R4-R7,PC}
    443                  }
    444          
    445                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, off + 1));
   \                     ??mbedtls_mpi_set_bit_2: (+1)
   \       0x2C   0x1C69             ADDS     R1,R5,#+1
   \       0x2E   0x.... 0x....      BL       ?Subroutine4
    446              }
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x32   0xB958             CBNZ.N   R0,??mbedtls_mpi_set_bit_3
    447          
    448              X->p[off] &= ~((mbedtls_mpi_uint) 0x01 << idx);
   \                     ??mbedtls_mpi_set_bit_1: (+1)
   \       0x34   0x683B             LDR      R3,[R7, #+0]
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x40B1             LSLS     R1,R1,R6
   \       0x3A   0xF853 0x2025      LDR      R2,[R3, R5, LSL #+2]
    449              X->p[off] |= (mbedtls_mpi_uint) val << idx;
   \       0x3E   0x40B4             LSLS     R4,R4,R6
   \       0x40   0x438A             BICS     R2,R2,R1
   \       0x42   0xF843 0x2025      STR      R2,[R3, R5, LSL #+2]
   \       0x46   0x4314             ORRS     R4,R4,R2
   \       0x48   0xF843 0x4025      STR      R4,[R3, R5, LSL #+2]
    450          
    451          cleanup:
    452          
    453              return ret;
   \                     ??mbedtls_mpi_set_bit_3: (+1)
   \       0x4C   0xBDF2             POP      {R1,R4-R7,PC}
    454          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4638             MOV      R0,R7
   \        0x2   0x.... 0x....      B.W      mbedtls_mpi_grow
    455          
    456          /*
    457           * Return the number of less significant zero-bits
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          size_t mbedtls_mpi_lsb(const mbedtls_mpi *X)
    460          {
    461              size_t i;
    462              MBEDTLS_INTERNAL_VALIDATE_RET(X != NULL, 0);
    463          
    464          #if defined(__has_builtin)
    465          #if (MBEDTLS_MPI_UINT_MAX == UINT_MAX) && __has_builtin(__builtin_ctz)
    466              #define mbedtls_mpi_uint_ctz __builtin_ctz
    467          #elif (MBEDTLS_MPI_UINT_MAX == ULONG_MAX) && __has_builtin(__builtin_ctzl)
    468              #define mbedtls_mpi_uint_ctz __builtin_ctzl
    469          #elif (MBEDTLS_MPI_UINT_MAX == ULLONG_MAX) && __has_builtin(__builtin_ctzll)
    470              #define mbedtls_mpi_uint_ctz __builtin_ctzll
    471          #endif
    472          #endif
    473          
    474          #if defined(mbedtls_mpi_uint_ctz)
    475              for (i = 0; i < X->n; i++) {
   \                     mbedtls_mpi_lsb: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xE000             B.N      ??mbedtls_mpi_lsb_0
   \                     ??mbedtls_mpi_lsb_1: (+1)
   \        0x6   0x1C5B             ADDS     R3,R3,#+1
   \                     ??mbedtls_mpi_lsb_0: (+1)
   \        0x8   0x88C1             LDRH     R1,[R0, #+6]
   \        0xA   0x428B             CMP      R3,R1
   \        0xC   0xD20A             BCS.N    ??mbedtls_mpi_lsb_2
    476                  if (X->p[i] != 0) {
   \        0xE   0xF852 0x1023      LDR      R1,[R2, R3, LSL #+2]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD0F7             BEQ.N    ??mbedtls_mpi_lsb_1
    477                      return i * biL + mbedtls_mpi_uint_ctz(X->p[i]);
   \       0x16   0xFA91 0xF1A1      RBIT     R1,R1
   \       0x1A   0xFAB1 0xF081      CLZ      R0,R1
   \       0x1E   0xEB00 0x1043      ADD      R0,R0,R3, LSL #+5
   \       0x22   0x4770             BX       LR
    478                  }
    479              }
    480          #else
    481              size_t count = 0;
    482              for (i = 0; i < X->n; i++) {
    483                  for (size_t j = 0; j < biL; j++, count++) {
    484                      if (((X->p[i] >> j) & 1) != 0) {
    485                          return count;
    486                      }
    487                  }
    488              }
    489          #endif
    490          
    491              return 0;
   \                     ??mbedtls_mpi_lsb_2: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR
    492          }
    493          
    494          /*
    495           * Return the number of bits
    496           */

   \                                 In section .text, align 2, keep-with-next
    497          size_t mbedtls_mpi_bitlen(const mbedtls_mpi *X)
    498          {
    499              return mbedtls_mpi_core_bitlen(X->p, X->n);
   \                     mbedtls_mpi_bitlen: (+1)
   \        0x0   0x88C1             LDRH     R1,[R0, #+6]
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x.... 0x....      B.W      mbedtls_mpi_core_bitlen
    500          }
    501          
    502          /*
    503           * Return the total size in bytes
    504           */

   \                                 In section .text, align 2, keep-with-next
    505          size_t mbedtls_mpi_size(const mbedtls_mpi *X)
    506          {
   \                     mbedtls_mpi_size: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    507              return (mbedtls_mpi_bitlen(X) + 7) >> 3;
   \        0x2   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \        0x6   0x1DC0             ADDS     R0,R0,#+7
   \        0x8   0x08C0             LSRS     R0,R0,#+3
   \        0xA   0xBD02             POP      {R1,PC}
    508          }
    509          
    510          /*
    511           * Convert an ASCII character to digit value
    512           */

   \                                 In section .text, align 2, keep-with-next
    513          static int mpi_get_digit(mbedtls_mpi_uint *d, int radix, char c)
    514          {
   \                     mpi_get_digit: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    515              *d = 255;
   \        0x2   0x24FF             MOVS     R4,#+255
    516          
    517              if (c >= 0x30 && c <= 0x39) {
   \        0x4   0xF1A2 0x0530      SUB      R5,R2,#+48
   \        0x8   0x4613             MOV      R3,R2
   \        0xA   0x2D0A             CMP      R5,#+10
   \        0xC   0xBF38             IT       CC
   \        0xE   0xF1A3 0x0430      SUBCC    R4,R3,#+48
    518                  *d = c - 0x30;
    519              }
    520              if (c >= 0x41 && c <= 0x46) {
   \       0x12   0xF1A2 0x0541      SUB      R5,R2,#+65
   \       0x16   0x2D06             CMP      R5,#+6
   \       0x18   0xBF38             IT       CC
   \       0x1A   0xF1A3 0x0437      SUBCC    R4,R3,#+55
    521                  *d = c - 0x37;
    522              }
    523              if (c >= 0x61 && c <= 0x66) {
   \       0x1E   0x3A61             SUBS     R2,R2,#+97
   \       0x20   0x2A06             CMP      R2,#+6
   \       0x22   0xBF38             IT       CC
   \       0x24   0xF1A3 0x0457      SUBCC    R4,R3,#+87
    524                  *d = c - 0x57;
    525              }
    526          
    527              if (*d >= (mbedtls_mpi_uint) radix) {
   \       0x28   0x428C             CMP      R4,R1
   \       0x2A   0x6004             STR      R4,[R0, #+0]
   \       0x2C   0xD302             BCC.N    ??mpi_get_digit_0
    528                  return MBEDTLS_ERR_MPI_INVALID_CHARACTER;
   \       0x2E   0xF06F 0x0005      MVN      R0,#+5
   \       0x32   0xBD30             POP      {R4,R5,PC}
    529              }
    530          
    531              return 0;
   \                     ??mpi_get_digit_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD30             POP      {R4,R5,PC}
    532          }
    533          
    534          /*
    535           * Import from an ASCII string
    536           */

   \                                 In section .text, align 2, keep-with-next
    537          int mbedtls_mpi_read_string(mbedtls_mpi *X, int radix, const char *s)
    538          {
   \                     mbedtls_mpi_read_string: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4689             MOV      R9,R1
    539              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    540              size_t i, j, slen, n;
    541              int sign = 1;
   \        0x6   0x2501             MOVS     R5,#+1
    542              mbedtls_mpi_uint d;
    543              mbedtls_mpi T;
    544              MPI_VALIDATE_RET(X != NULL);
    545              MPI_VALIDATE_RET(s != NULL);
    546          
    547              if (radix < 2 || radix > 16) {
   \        0x8   0xF1A9 0x0102      SUB      R1,R9,#+2
   \        0xC   0x4606             MOV      R6,R0
   \        0xE   0x4617             MOV      R7,R2
   \       0x10   0x290F             CMP      R1,#+15
   \       0x12   0xD218             BCS.N    ??mbedtls_mpi_read_string_0
    548                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    549              }
    550          
    551              mbedtls_mpi_init(&T);
   \       0x14   0xA801             ADD      R0,SP,#+4
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_init
    552          
    553              if (s[0] == 0) {
   \       0x1A   0x7838             LDRB     R0,[R7, #+0]
   \       0x1C   0xB920             CBNZ.N   R0,??mbedtls_mpi_read_string_1
    554                  mbedtls_mpi_free(X);
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_free
    555                  return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE072             B.N      ??mbedtls_mpi_read_string_2
    556              }
    557          
    558              if (s[0] == '-') {
   \                     ??mbedtls_mpi_read_string_1: (+1)
   \       0x28   0x282D             CMP      R0,#+45
   \       0x2A   0xBF04             ITT      EQ
   \       0x2C   0x1C7F             ADDEQ    R7,R7,#+1
   \       0x2E   0xF04F 0x35FF      MOVEQ    R5,#+4294967295
    559                  ++s;
    560                  sign = -1;
    561              }
    562          
    563              slen = strlen(s);
   \       0x32   0x4638             MOV      R0,R7
   \       0x34   0x.... 0x....      BL       strlen
   \       0x38   0x4680             MOV      R8,R0
    564          
    565              if (radix == 16) {
   \       0x3A   0xF1B9 0x0F10      CMP      R9,#+16
   \       0x3E   0xD139             BNE.N    ??mbedtls_mpi_read_string_3
    566                  if (slen > SIZE_MAX >> 2) {
   \       0x40   0xF1B8 0x4F80      CMP      R8,#+1073741824
   \       0x44   0xD302             BCC.N    ??mbedtls_mpi_read_string_4
    567                      return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_read_string_0: (+1)
   \       0x46   0xF06F 0x0003      MVN      R0,#+3
   \       0x4A   0xE060             B.N      ??mbedtls_mpi_read_string_2
    568                  }
    569          
    570                  n = BITS_TO_LIMBS(slen << 2);
   \                     ??mbedtls_mpi_read_string_4: (+1)
   \       0x4C   0xEA4F 0x0088      LSL      R0,R8,#+2
   \       0x50   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \       0x54   0xBF18             IT       NE
   \       0x56   0x2101             MOVNE    R1,#+1
    571          
    572                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, n));
   \       0x58   0xEB01 0x1150      ADD      R1,R1,R0, LSR #+5
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x62   0x0004             MOVS     R4,R0
   \       0x64   0xD14F             BNE.N    ??mbedtls_mpi_read_string_5
    573                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x6E   0x0004             MOVS     R4,R0
   \       0x70   0xD149             BNE.N    ??mbedtls_mpi_read_string_5
    574          
    575                  for (i = slen, j = 0; i > 0; i--, j++) {
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0x4644             MOV      R4,R8
   \       0x76   0x4688             MOV      R8,R1
   \                     ??mbedtls_mpi_read_string_6: (+1)
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD038             BEQ.N    ??mbedtls_mpi_read_string_7
    576                      MBEDTLS_MPI_CHK(mpi_get_digit(&d, radix, s[i - 1]));
   \       0x7C   0x1938             ADDS     R0,R7,R4
   \       0x7E   0xF810 0x2C01      LDRB     R2,[R0, #-1]
   \       0x82   0x2110             MOVS     R1,#+16
   \       0x84   0x4668             MOV      R0,SP
   \       0x86   0x.... 0x....      BL       mpi_get_digit
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD13A             BNE.N    ??mbedtls_mpi_read_string_8
    577                      X->p[j / (2 * ciL)] |= d << ((j % (2 * ciL)) << 2);
   \       0x8E   0x6831             LDR      R1,[R6, #+0]
   \       0x90   0xEA4F 0x0ED8      LSR      LR,R8,#+3
   \       0x94   0x9B00             LDR      R3,[SP, #+0]
   \       0x96   0xF851 0x202E      LDR      R2,[R1, LR, LSL #+2]
   \       0x9A   0xEA4F 0x0C88      LSL      R12,R8,#+2
   \       0x9E   0xF00C 0x0C1C      AND      R12,R12,#0x1C
   \       0xA2   0xFA03 0xF30C      LSL      R3,R3,R12
   \       0xA6   0x431A             ORRS     R2,R3,R2
   \       0xA8   0xF841 0x202E      STR      R2,[R1, LR, LSL #+2]
    578                  }
   \       0xAC   0x1E64             SUBS     R4,R4,#+1
   \       0xAE   0xF108 0x0801      ADD      R8,R8,#+1
   \       0xB2   0xE7E1             B.N      ??mbedtls_mpi_read_string_6
    579              } else {
    580                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   \                     ??mbedtls_mpi_read_string_3: (+1)
   \       0xB4   0x2100             MOVS     R1,#+0
   \       0xB6   0x4630             MOV      R0,R6
   \       0xB8   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xBC   0x0004             MOVS     R4,R0
   \       0xBE   0xD122             BNE.N    ??mbedtls_mpi_read_string_5
    581          
    582                  for (i = 0; i < slen; i++) {
   \       0xC0   0x2400             MOVS     R4,#+0
   \       0xC2   0xE012             B.N      ??mbedtls_mpi_read_string_9
    583                      MBEDTLS_MPI_CHK(mpi_get_digit(&d, radix, s[i]));
   \                     ??mbedtls_mpi_read_string_10: (+1)
   \       0xC4   0x5D3A             LDRB     R2,[R7, R4]
   \       0xC6   0x4649             MOV      R1,R9
   \       0xC8   0x4668             MOV      R0,SP
   \       0xCA   0x.... 0x....      BL       mpi_get_digit
   \       0xCE   0xB9C8             CBNZ.N   R0,??mbedtls_mpi_read_string_8
    584                      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T, X, radix));
   \       0xD0   0x464A             MOV      R2,R9
   \       0xD2   0x4631             MOV      R1,R6
   \       0xD4   0xA801             ADD      R0,SP,#+4
   \       0xD6   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \       0xDA   0xB998             CBNZ.N   R0,??mbedtls_mpi_read_string_8
    585                      MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X, &T, d));
   \       0xDC   0x9A00             LDR      R2,[SP, #+0]
   \       0xDE   0xA901             ADD      R1,SP,#+4
   \       0xE0   0x4630             MOV      R0,R6
   \       0xE2   0x.... 0x....      BL       mbedtls_mpi_add_int
   \       0xE6   0xB968             CBNZ.N   R0,??mbedtls_mpi_read_string_8
    586                  }
   \       0xE8   0x1C64             ADDS     R4,R4,#+1
   \                     ??mbedtls_mpi_read_string_9: (+1)
   \       0xEA   0x4544             CMP      R4,R8
   \       0xEC   0xD3EA             BCC.N    ??mbedtls_mpi_read_string_10
   \                     ??mbedtls_mpi_read_string_7: (+1)
   \       0xEE   0x4604             MOV      R4,R0
    587              }
    588          
    589              if (sign < 0 && mbedtls_mpi_bitlen(X) != 0) {
   \       0xF0   0x2D00             CMP      R5,#+0
   \       0xF2   0xD508             BPL.N    ??mbedtls_mpi_read_string_5
   \       0xF4   0x4630             MOV      R0,R6
   \       0xF6   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0xFA   0xB120             CBZ.N    R0,??mbedtls_mpi_read_string_5
    590                  X->s = -1;
   \       0xFC   0xF04F 0x30FF      MOV      R0,#+4294967295
   \      0x100   0x80B0             STRH     R0,[R6, #+4]
   \      0x102   0xE000             B.N      ??mbedtls_mpi_read_string_5
    591              }
   \                     ??mbedtls_mpi_read_string_8: (+1)
   \      0x104   0x4604             MOV      R4,R0
    592          
    593          cleanup:
    594          
    595              mbedtls_mpi_free(&T);
   \                     ??mbedtls_mpi_read_string_5: (+1)
   \      0x106   0xA801             ADD      R0,SP,#+4
   \      0x108   0x.... 0x....      BL       mbedtls_mpi_free
    596          
    597              return ret;
   \      0x10C   0x4620             MOV      R0,R4
   \                     ??mbedtls_mpi_read_string_2: (+1)
   \      0x10E   0xE8BD 0x83FE      POP      {R1-R9,PC}
    598          }
    599          
    600          /*
    601           * Helper to write the digits high-order first.
    602           */
    603          static int mpi_write_hlp(mbedtls_mpi *X, int radix,
    604                                   char **p, const size_t buflen)
    605          {
    606              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    607              mbedtls_mpi_uint r;
    608              size_t length = 0;
    609              char *p_end = *p + buflen;
    610          
    611              do {
    612                  if (length >= buflen) {
    613                      return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
    614                  }
    615          
    616                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_int(&r, X, radix));
    617                  MBEDTLS_MPI_CHK(mbedtls_mpi_div_int(X, NULL, X, radix));
    618                  /*
    619                   * Write the residue in the current position, as an ASCII character.
    620                   */
    621                  if (r < 0xA) {
    622                      *(--p_end) = (char) ('0' + r);
    623                  } else {
    624                      *(--p_end) = (char) ('A' + (r - 0xA));
    625                  }
    626          
    627                  length++;
    628              } while (mbedtls_mpi_cmp_int(X, 0) != 0);
    629          
    630              memmove(*p, p_end, length);
    631              *p += length;
    632          
    633          cleanup:
    634          
    635              return ret;
    636          }
    637          
    638          /*
    639           * Export into an ASCII string
    640           */

   \                                 In section .text, align 4, keep-with-next
    641          int mbedtls_mpi_write_string(const mbedtls_mpi *X, int radix,
    642                                       char *buf, size_t buflen, size_t *olen)
    643          {
   \                     mbedtls_mpi_write_string: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x460E             MOV      R6,R1
    644              int ret = 0;
    645              size_t n;
    646              char *p;
    647              mbedtls_mpi T;
    648              MPI_VALIDATE_RET(X    != NULL);
    649              MPI_VALIDATE_RET(olen != NULL);
    650              MPI_VALIDATE_RET(buflen == 0 || buf != NULL);
    651          
    652              if (radix < 2 || radix > 16) {
   \        0x6   0x1EB1             SUBS     R1,R6,#+2
   \        0x8   0xB084             SUB      SP,SP,#+16
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x461D             MOV      R5,R3
   \        0xE   0xF04F 0x0800      MOV      R8,#+0
   \       0x12   0x290F             CMP      R1,#+15
   \       0x14   0xBF28             IT       CS
   \       0x16   0xF06F 0x0003      MVNCS    R0,#+3
    653                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x1A   0xD213             BCS.N    ??mbedtls_mpi_write_string_0
   \       0x1C   0x4681             MOV      R9,R0
    654              }
    655          
    656              n = mbedtls_mpi_bitlen(X);   /* Number of bits necessary to present `n`. */
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_bitlen
    657              if (radix >=  4) {
   \       0x22   0x2E04             CMP      R6,#+4
   \       0x24   0xBFA8             IT       GE
   \       0x26   0x0840             LSRGE    R0,R0,#+1
    658                  n >>= 1;                 /* Number of 4-adic digits necessary to present
    659                                            * `n`. If radix > 4, this might be a strict
    660                                            * overapproximation of the number of
    661                                            * radix-adic digits needed to present `n`. */
    662              }
    663              if (radix >= 16) {
   \       0x28   0x2E10             CMP      R6,#+16
   \       0x2A   0xBFA8             IT       GE
   \       0x2C   0x0840             LSRGE    R0,R0,#+1
    664                  n >>= 1;                 /* Number of hexadecimal digits necessary to
    665                                            * present `n`. */
    666          
    667              }
    668              n += 1; /* Terminating null byte */
    669              n += 1; /* Compensate for the divisions above, which round down `n`
    670                       * in case it's not even. */
    671              n += 1; /* Potential '-'-sign. */
   \       0x2E   0x1CC0             ADDS     R0,R0,#+3
    672              n += (n & 1);   /* Make n even to have enough space for hexadecimal writing,
   \       0x30   0xF000 0x0101      AND      R1,R0,#0x1
   \       0x34   0x1808             ADDS     R0,R1,R0
    673                               * which always uses an even number of hex-digits. */
    674          
    675              if (buflen < n) {
   \       0x36   0xF06F 0x0A07      MVN      R10,#+7
   \       0x3A   0x9C0E             LDR      R4,[SP, #+56]
   \       0x3C   0x4285             CMP      R5,R0
   \       0x3E   0xD202             BCS.N    ??mbedtls_mpi_write_string_1
    676                  *olen = n;
   \       0x40   0x6020             STR      R0,[R4, #+0]
    677                  return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   \       0x42   0x4650             MOV      R0,R10
   \                     ??mbedtls_mpi_write_string_0: (+1)
   \       0x44   0xE082             B.N      ??mbedtls_mpi_write_string_2
    678              }
   \                     ??mbedtls_mpi_write_string_1: (+1)
   \       0x46   0x9703             STR      R7,[SP, #+12]
    679          
    680              p = buf;
    681              mbedtls_mpi_init(&T);
   \       0x48   0x.... 0x....      BL       ?Subroutine11
    682          
    683              if (X->s == -1) {
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x4C   0xF9B9 0x0004      LDRSH    R0,[R9, #+4]
   \       0x50   0xF110 0x0F01      CMN      R0,#+1
   \       0x54   0xD103             BNE.N    ??mbedtls_mpi_write_string_3
    684                  *p++ = '-';
   \       0x56   0x212D             MOVS     R1,#+45
   \       0x58   0xF807 0x1B01      STRB     R1,[R7], #+1
    685                  buflen--;
   \       0x5C   0x1E6D             SUBS     R5,R5,#+1
    686              }
    687          
    688              if (radix == 16) {
   \                     ??mbedtls_mpi_write_string_3: (+1)
   \       0x5E   0x2E10             CMP      R6,#+16
   \       0x60   0xD12C             BNE.N    ??mbedtls_mpi_write_string_4
    689                  int c;
    690                  size_t i, j, k;
    691          
    692                  for (i = X->n, k = 0; i > 0; i--) {
   \       0x62   0xF8B9 0x3006      LDRH     R3,[R9, #+6]
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x....             ADR.N    R6,?_0
   \                     ??mbedtls_mpi_write_string_5: (+1)
   \       0x6A   0x2B00             CMP      R3,#+0
   \       0x6C   0xD065             BEQ.N    ??mbedtls_mpi_write_string_6
    693                      for (j = ciL; j > 0; j--) {
   \       0x6E   0x2104             MOVS     R1,#+4
    694                          c = (X->p[i - 1] >> ((j - 1) << 3)) & 0xFF;
   \                     ??mbedtls_mpi_write_string_7: (+1)
   \       0x70   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0x74   0xEB02 0x0583      ADD      R5,R2,R3, LSL #+2
   \       0x78   0xF855 0x2C04      LDR      R2,[R5, #-4]
   \       0x7C   0xF101 0x05FF      ADD      R5,R1,#+255
   \       0x80   0x00ED             LSLS     R5,R5,#+3
   \       0x82   0x40EA             LSRS     R2,R2,R5
   \       0x84   0xF012 0x02FF      ANDS     R2,R2,#0xFF
    695          
    696                          if (c == 0 && k == 0 && (i + j) != 2) {
   \       0x88   0xBF08             IT       EQ
   \       0x8A   0x2800             CMPEQ    R0,#+0
   \       0x8C   0xD102             BNE.N    ??mbedtls_mpi_write_string_8
   \       0x8E   0x18CD             ADDS     R5,R1,R3
   \       0x90   0x2D02             CMP      R5,#+2
   \       0x92   0xD10F             BNE.N    ??mbedtls_mpi_write_string_9
    697                              continue;
    698                          }
    699          
    700                          *(p++) = "0123456789ABCDEF" [c / 16];
   \                     ??mbedtls_mpi_write_string_8: (+1)
   \       0x94   0x08D0             LSRS     R0,R2,#+3
   \       0x96   0xEB02 0x7010      ADD      R0,R2,R0, LSR #+28
   \       0x9A   0xEA4F 0x1E10      LSR      LR,R0,#+4
   \       0x9E   0xF816 0x500E      LDRB     R5,[R6, LR]
    701                          *(p++) = "0123456789ABCDEF" [c % 16];
   \       0xA2   0xF020 0x000F      BIC      R0,R0,#0xF
   \       0xA6   0x1A12             SUBS     R2,R2,R0
   \       0xA8   0xF807 0x5B01      STRB     R5,[R7], #+1
   \       0xAC   0x5CB0             LDRB     R0,[R6, R2]
   \       0xAE   0xF807 0x0B01      STRB     R0,[R7], #+1
    702                          k = 1;
   \       0xB2   0x2001             MOVS     R0,#+1
    703                      }
   \                     ??mbedtls_mpi_write_string_9: (+1)
   \       0xB4   0x1E49             SUBS     R1,R1,#+1
   \       0xB6   0xD1DB             BNE.N    ??mbedtls_mpi_write_string_7
    704                  }
   \       0xB8   0x1E5B             SUBS     R3,R3,#+1
   \       0xBA   0xE7D6             B.N      ??mbedtls_mpi_write_string_5
    705              } else {
    706                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&T, X));
   \                     ??mbedtls_mpi_write_string_4: (+1)
   \       0xBC   0x4649             MOV      R1,R9
   \       0xBE   0x4668             MOV      R0,SP
   \       0xC0   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0xC4   0xEA5F 0x0800      MOVS     R8,R0
   \       0xC8   0xD13D             BNE.N    ??mbedtls_mpi_write_string_10
    707          
    708                  if (T.s == -1) {
   \       0xCA   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \       0xCE   0xF111 0x0F01      CMN      R1,#+1
   \       0xD2   0xBF04             ITT      EQ
   \       0xD4   0x2001             MOVEQ    R0,#+1
   \       0xD6   0xF8AD 0x0004      STRHEQ   R0,[SP, #+4]
    709                      T.s = 1;
    710                  }
    711          
    712                  MBEDTLS_MPI_CHK(mpi_write_hlp(&T, radix, &p, buflen));
   \       0xDA   0x1978             ADDS     R0,R7,R5
   \       0xDC   0x46B0             MOV      R8,R6
   \       0xDE   0x46A9             MOV      R9,R5
   \       0xE0   0x2500             MOVS     R5,#+0
   \       0xE2   0x4606             MOV      R6,R0
   \                     ??mbedtls_mpi_write_string_11: (+1)
   \       0xE4   0x454D             CMP      R5,R9
   \       0xE6   0xD214             BCS.N    ??mbedtls_mpi_write_string_12
   \       0xE8   0x4642             MOV      R2,R8
   \       0xEA   0x4669             MOV      R1,SP
   \       0xEC   0xA802             ADD      R0,SP,#+8
   \       0xEE   0x.... 0x....      BL       mbedtls_mpi_mod_int
   \       0xF2   0x4683             MOV      R11,R0
   \       0xF4   0xB9F0             CBNZ.N   R0,??mbedtls_mpi_write_string_13
   \       0xF6   0x4643             MOV      R3,R8
   \       0xF8   0x466A             MOV      R2,SP
   \       0xFA   0x2100             MOVS     R1,#+0
   \       0xFC   0x4668             MOV      R0,SP
   \       0xFE   0x.... 0x....      BL       mbedtls_mpi_div_int
   \      0x102   0x4683             MOV      R11,R0
   \      0x104   0xB9B0             CBNZ.N   R0,??mbedtls_mpi_write_string_13
   \      0x106   0x9802             LDR      R0,[SP, #+8]
   \      0x108   0x280A             CMP      R0,#+10
   \      0x10A   0xBF34             ITE      CC
   \      0x10C   0x3030             ADDCC    R0,R0,#+48
   \      0x10E   0x3037             ADDCS    R0,R0,#+55
   \      0x110   0xE001             B.N      ??mbedtls_mpi_write_string_14
   \                     ??mbedtls_mpi_write_string_12: (+1)
   \      0x112   0x46D0             MOV      R8,R10
   \      0x114   0xE017             B.N      ??mbedtls_mpi_write_string_10
   \                     ??mbedtls_mpi_write_string_14: (+1)
   \      0x116   0xF806 0x0D01      STRB     R0,[R6, #-1]!
   \      0x11A   0x2100             MOVS     R1,#+0
   \      0x11C   0x4668             MOV      R0,SP
   \      0x11E   0x1C6D             ADDS     R5,R5,#+1
   \      0x120   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x124   0x2800             CMP      R0,#+0
   \      0x126   0xD1DD             BNE.N    ??mbedtls_mpi_write_string_11
   \      0x128   0x462A             MOV      R2,R5
   \      0x12A   0x4631             MOV      R1,R6
   \      0x12C   0x4638             MOV      R0,R7
   \      0x12E   0x.... 0x....      BL       __aeabi_memmove
   \      0x132   0x197F             ADDS     R7,R7,R5
   \                     ??mbedtls_mpi_write_string_13: (+1)
   \      0x134   0xEA5F 0x080B      MOVS     R8,R11
   \      0x138   0xD105             BNE.N    ??mbedtls_mpi_write_string_10
    713              }
    714          
    715              *p++ = '\0';
   \                     ??mbedtls_mpi_write_string_6: (+1)
   \      0x13A   0x2100             MOVS     R1,#+0
   \      0x13C   0xF807 0x1B01      STRB     R1,[R7], #+1
    716              *olen = p - buf;
   \      0x140   0x9803             LDR      R0,[SP, #+12]
   \      0x142   0x1A3F             SUBS     R7,R7,R0
   \      0x144   0x6027             STR      R7,[R4, #+0]
    717          
    718          cleanup:
    719          
    720              mbedtls_mpi_free(&T);
   \                     ??mbedtls_mpi_write_string_10: (+1)
   \      0x146   0x.... 0x....      BL       ?Subroutine12
    721          
    722              return ret;
   \                     ??CrossCallReturnLabel_32: (+1)
   \      0x14A   0x4640             MOV      R0,R8
   \                     ??mbedtls_mpi_write_string_2: (+1)
   \      0x14C   0xB005             ADD      SP,SP,#+20
   \      0x14E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    723          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4668             MOV      R0,SP
   \        0x2   0x.... 0x....      B.W      mbedtls_mpi_free

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x4668             MOV      R0,SP
   \        0x2   0x.... 0x....      B.W      mbedtls_mpi_init
    724          
    725          #if defined(MBEDTLS_FS_IO)
    726          /*
    727           * Read X from an opened file
    728           */
    729          int mbedtls_mpi_read_file(mbedtls_mpi *X, int radix, FILE *fin)
    730          {
    731              mbedtls_mpi_uint d;
    732              size_t slen;
    733              char *p;
    734              /*
    735               * Buffer should have space for (short) label and decimal formatted MPI,
    736               * newline characters and '\0'
    737               */
    738              char s[MBEDTLS_MPI_RW_BUFFER_SIZE];
    739          
    740              MPI_VALIDATE_RET(X   != NULL);
    741              MPI_VALIDATE_RET(fin != NULL);
    742          
    743              if (radix < 2 || radix > 16) {
    744                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    745              }
    746          
    747              memset(s, 0, sizeof(s));
    748              if (fgets(s, sizeof(s) - 1, fin) == NULL) {
    749                  return MBEDTLS_ERR_MPI_FILE_IO_ERROR;
    750              }
    751          
    752              slen = strlen(s);
    753              if (slen == sizeof(s) - 2) {
    754                  return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
    755              }
    756          
    757              if (slen > 0 && s[slen - 1] == '\n') {
    758                  slen--; s[slen] = '\0';
    759              }
    760              if (slen > 0 && s[slen - 1] == '\r') {
    761                  slen--; s[slen] = '\0';
    762              }
    763          
    764              p = s + slen;
    765              while (p-- > s) {
    766                  if (mpi_get_digit(&d, radix, *p) != 0) {
    767                      break;
    768                  }
    769              }
    770          
    771              return mbedtls_mpi_read_string(X, radix, p + 1);
    772          }
    773          
    774          /*
    775           * Write X into an opened file (or stdout if fout == NULL)
    776           */
    777          int mbedtls_mpi_write_file(const char *p, const mbedtls_mpi *X, int radix, FILE *fout)
    778          {
    779              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    780              size_t n, slen, plen;
    781              /*
    782               * Buffer should have space for (short) label and decimal formatted MPI,
    783               * newline characters and '\0'
    784               */
    785              char s[MBEDTLS_MPI_RW_BUFFER_SIZE];
    786              MPI_VALIDATE_RET(X != NULL);
    787          
    788              if (radix < 2 || radix > 16) {
    789                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    790              }
    791          
    792              memset(s, 0, sizeof(s));
    793          
    794              MBEDTLS_MPI_CHK(mbedtls_mpi_write_string(X, radix, s, sizeof(s) - 2, &n));
    795          
    796              if (p == NULL) {
    797                  p = "";
    798              }
    799          
    800              plen = strlen(p);
    801              slen = strlen(s);
    802              s[slen++] = '\r';
    803              s[slen++] = '\n';
    804          
    805              if (fout != NULL) {
    806                  if (fwrite(p, 1, plen, fout) != plen ||
    807                      fwrite(s, 1, slen, fout) != slen) {
    808                      return MBEDTLS_ERR_MPI_FILE_IO_ERROR;
    809                  }
    810              } else {
    811                  mbedtls_printf("%s%s", p, s);
    812              }
    813          
    814          cleanup:
    815          
    816              return ret;
    817          }
    818          #endif /* MBEDTLS_FS_IO */
    819          
    820          /*
    821           * Import X from unsigned binary data, little endian
    822           *
    823           * This function is guaranteed to return an MPI with exactly the necessary
    824           * number of limbs (in particular, it does not skip 0s in the input).
    825           */

   \                                 In section .text, align 2, keep-with-next
    826          int mbedtls_mpi_read_binary_le(mbedtls_mpi *X,
    827                                         const unsigned char *buf, size_t buflen)
    828          {
   \                     mbedtls_mpi_read_binary_le: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
    829              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    830              const size_t limbs = CHARS_TO_LIMBS(buflen);
   \                     ??CrossCallReturnLabel_21: (+1)
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2101             MOVNE    R1,#+1
    831          
    832              /* Ensure that target MPI has exactly the necessary number of limbs */
    833              MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   \        0xA   0xEB01 0x0196      ADD      R1,R1,R6, LSR #+2
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x12   0xB938             CBNZ.N   R0,??mbedtls_mpi_read_binary_le_0
    834          
    835              MBEDTLS_MPI_CHK(mbedtls_mpi_core_read_le(X->p, X->n, buf, buflen));
   \       0x14   0x4633             MOV      R3,R6
   \       0x16   0x462A             MOV      R2,R5
   \       0x18   0x88E1             LDRH     R1,[R4, #+6]
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x20   0x.... 0x....      B.W      mbedtls_mpi_core_read_le
    836          
    837          cleanup:
    838          
    839              /*
    840               * This function is also used to import keys. However, wiping the buffers
    841               * upon failure is not necessary because failure only can happen before any
    842               * input is copied.
    843               */
    844              return ret;
   \                     ??mbedtls_mpi_read_binary_le_0: (+1)
   \       0x24   0xBD70             POP      {R4-R6,PC}
    845          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x460D             MOV      R5,R1
   \        0x2   0x4616             MOV      R6,R2
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0xF016 0x0103      ANDS     R1,R6,#0x3
   \        0xA   0x4770             BX       LR
    846          
    847          /*
    848           * Import X from unsigned binary data, big endian
    849           *
    850           * This function is guaranteed to return an MPI with exactly the necessary
    851           * number of limbs (in particular, it does not skip 0s in the input).
    852           */

   \                                 In section .text, align 2, keep-with-next
    853          int mbedtls_mpi_read_binary(mbedtls_mpi *X, const unsigned char *buf, size_t buflen)
    854          {
   \                     mbedtls_mpi_read_binary: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
    855              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    856              const size_t limbs = CHARS_TO_LIMBS(buflen);
   \                     ??CrossCallReturnLabel_22: (+1)
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2101             MOVNE    R1,#+1
    857          
    858              MPI_VALIDATE_RET(X != NULL);
    859              MPI_VALIDATE_RET(buflen == 0 || buf != NULL);
    860          
    861              /* Ensure that target MPI has exactly the necessary number of limbs */
    862              MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   \        0xA   0xEB01 0x0196      ADD      R1,R1,R6, LSR #+2
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x12   0xB938             CBNZ.N   R0,??mbedtls_mpi_read_binary_0
    863          
    864              MBEDTLS_MPI_CHK(mbedtls_mpi_core_read_be(X->p, X->n, buf, buflen));
   \       0x14   0x4633             MOV      R3,R6
   \       0x16   0x462A             MOV      R2,R5
   \       0x18   0x88E1             LDRH     R1,[R4, #+6]
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x20   0x.... 0x....      B.W      mbedtls_mpi_core_read_be
    865          
    866          cleanup:
    867          
    868              /*
    869               * This function is also used to import keys. However, wiping the buffers
    870               * upon failure is not necessary because failure only can happen before any
    871               * input is copied.
    872               */
    873              return ret;
   \                     ??mbedtls_mpi_read_binary_0: (+1)
   \       0x24   0xBD70             POP      {R4-R6,PC}
    874          }
    875          
    876          /*
    877           * Export X into unsigned binary data, little endian
    878           */

   \                                 In section .text, align 2, keep-with-next
    879          int mbedtls_mpi_write_binary_le(const mbedtls_mpi *X,
    880                                          unsigned char *buf, size_t buflen)
    881          {
   \                     mbedtls_mpi_write_binary_le: (+1)
   \        0x0   0x4613             MOV      R3,R2
    882              return mbedtls_mpi_core_write_le(X->p, X->n, buf, buflen);
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x88C1             LDRH     R1,[R0, #+6]
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      B.W      mbedtls_mpi_core_write_le
    883          }
    884          
    885          /*
    886           * Export X into unsigned binary data, big endian
    887           */

   \                                 In section .text, align 2, keep-with-next
    888          int mbedtls_mpi_write_binary(const mbedtls_mpi *X,
    889                                       unsigned char *buf, size_t buflen)
    890          {
   \                     mbedtls_mpi_write_binary: (+1)
   \        0x0   0x4613             MOV      R3,R2
    891              return mbedtls_mpi_core_write_be(X->p, X->n, buf, buflen);
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x88C1             LDRH     R1,[R0, #+6]
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x.... 0x....      B.W      mbedtls_mpi_core_write_be
    892          }
    893          
    894          /*
    895           * Left-shift: X <<= count
    896           */

   \                                 In section .text, align 2, keep-with-next
    897          int mbedtls_mpi_shift_l(mbedtls_mpi *X, size_t count)
    898          {
   \                     mbedtls_mpi_shift_l: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    899              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    900              size_t i;
    901              MPI_VALIDATE_RET(X != NULL);
    902          
    903              i = mbedtls_mpi_bitlen(X) + count;
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_bitlen
    904          
    905              if (X->n * biL < i) {
   \        0xA   0x88EA             LDRH     R2,[R5, #+6]
   \        0xC   0x1830             ADDS     R0,R6,R0
   \        0xE   0x0152             LSLS     R2,R2,#+5
   \       0x10   0x4282             CMP      R2,R0
   \       0x12   0xD20A             BCS.N    ??mbedtls_mpi_shift_l_0
    906                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, BITS_TO_LIMBS(i)));
   \       0x14   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \       0x18   0xBF18             IT       NE
   \       0x1A   0x2101             MOVNE    R1,#+1
   \       0x1C   0xEB01 0x1150      ADD      R1,R1,R0, LSR #+5
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x26   0x0004             MOVS     R4,R0
   \       0x28   0xD105             BNE.N    ??mbedtls_mpi_shift_l_1
    907              }
    908          
    909              ret = 0;
    910          
    911              mbedtls_mpi_core_shift_l(X->p, X->n, count);
   \                     ??mbedtls_mpi_shift_l_0: (+1)
   \       0x2A   0x88E9             LDRH     R1,[R5, #+6]
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x4632             MOV      R2,R6
   \       0x30   0x2400             MOVS     R4,#+0
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_core_shift_l
    912          cleanup:
    913          
    914              return ret;
   \                     ??mbedtls_mpi_shift_l_1: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xBD70             POP      {R4-R6,PC}
    915          }
    916          
    917          /*
    918           * Right-shift: X >>= count
    919           */

   \                                 In section .text, align 2, keep-with-next
    920          int mbedtls_mpi_shift_r(mbedtls_mpi *X, size_t count)
    921          {
   \                     mbedtls_mpi_shift_r: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x460A             MOV      R2,R1
    922              MPI_VALIDATE_RET(X != NULL);
    923              if (X->n != 0) {
   \        0x4   0x88C1             LDRH     R1,[R0, #+6]
   \        0x6   0xB111             CBZ.N    R1,??mbedtls_mpi_shift_r_0
    924                  mbedtls_mpi_core_shift_r(X->p, X->n, count);
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_core_shift_r
    925              }
    926              return 0;
   \                     ??mbedtls_mpi_shift_r_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD02             POP      {R1,PC}
    927          }
    928          
    929          /*
    930           * Compare unsigned values
    931           */

   \                                 In section .text, align 2, keep-with-next
    932          int mbedtls_mpi_cmp_abs(const mbedtls_mpi *X, const mbedtls_mpi *Y)
    933          {
   \                     mbedtls_mpi_cmp_abs: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine5
    934              size_t i, j;
    935              MPI_VALIDATE_RET(X != NULL);
    936              MPI_VALIDATE_RET(Y != NULL);
    937          
    938              for (i = X->n; i > 0; i--) {
    939                  if (X->p[i - 1] != 0) {
    940                      break;
    941                  }
    942              }
    943          
    944              for (j = Y->n; j > 0; j--) {
   \                     ??CrossCallReturnLabel_11: (+1)
   \        0x6   0x.... 0x....      BL       ?Subroutine1
    945                  if (Y->p[j - 1] != 0) {
    946                      break;
    947                  }
    948              }
    949          
    950              /* If i == j == 0, i.e. abs(X) == abs(Y),
    951               * we end up returning 0 at the end of the function. */
    952          
    953              if (i > j) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xA   0x4281             CMP      R1,R0
   \        0xC   0xD30F             BCC.N    ??mbedtls_mpi_cmp_abs_0
    954                  return 1;
    955              }
    956              if (j > i) {
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD203             BCS.N    ??mbedtls_mpi_cmp_abs_1
   \       0x12   0xE00E             B.N      ??mbedtls_mpi_cmp_abs_2
    957                  return -1;
    958              }
    959          
    960              for (; i > 0; i--) {
    961                  if (X->p[i - 1] > Y->p[i - 1]) {
    962                      return 1;
    963                  }
    964                  if (X->p[i - 1] < Y->p[i - 1]) {
   \                     ??mbedtls_mpi_cmp_abs_3: (+1)
   \       0x14   0x4291             CMP      R1,R2
   \       0x16   0xD30C             BCC.N    ??mbedtls_mpi_cmp_abs_2
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \                     ??mbedtls_mpi_cmp_abs_1: (+1)
   \       0x1A   0xB160             CBZ.N    R0,??mbedtls_mpi_cmp_abs_4
   \       0x1C   0x681A             LDR      R2,[R3, #+0]
   \       0x1E   0x1F11             SUBS     R1,R2,#+4
   \       0x20   0x1F32             SUBS     R2,R6,#+4
   \       0x22   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \       0x26   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \       0x2A   0x428A             CMP      R2,R1
   \       0x2C   0xD2F2             BCS.N    ??mbedtls_mpi_cmp_abs_3
   \                     ??mbedtls_mpi_cmp_abs_0: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xBD70             POP      {R4-R6,PC}
    965                      return -1;
   \                     ??mbedtls_mpi_cmp_abs_2: (+1)
   \       0x32   0xF04F 0x30FF      MOV      R0,#+4294967295
    966                  }
    967              }
    968          
    969              return 0;
   \                     ??mbedtls_mpi_cmp_abs_4: (+1)
   \       0x36   0xBD70             POP      {R4-R6,PC}
    970          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4603             MOV      R3,R0
   \        0x2   0x681D             LDR      R5,[R3, #+0]
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x88D8             LDRH     R0,[R3, #+6]
   \        0x8   0x1F2A             SUBS     R2,R5,#+4
   \        0xA   0xE000             B.N      ??Subroutine5_0
   \                     ??Subroutine5_1: (+1)
   \        0xC   0x1E40             SUBS     R0,R0,#+1
   \                     ??Subroutine5_0: (+1)
   \        0xE   0xB118             CBZ.N    R0,??Subroutine5_2
   \       0x10   0xF852 0x1020      LDR      R1,[R2, R0, LSL #+2]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD0F9             BEQ.N    ??Subroutine5_1
   \                     ??Subroutine5_2: (+1)
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6826             LDR      R6,[R4, #+0]
   \        0x2   0x88E1             LDRH     R1,[R4, #+6]
   \        0x4   0x1F35             SUBS     R5,R6,#+4
   \        0x6   0xE000             B.N      ??Subroutine1_0
   \                     ??Subroutine1_1: (+1)
   \        0x8   0x1E49             SUBS     R1,R1,#+1
   \                     ??Subroutine1_0: (+1)
   \        0xA   0xB119             CBZ.N    R1,??Subroutine1_2
   \        0xC   0xF855 0x2021      LDR      R2,[R5, R1, LSL #+2]
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xD0F9             BEQ.N    ??Subroutine1_1
   \                     ??Subroutine1_2: (+1)
   \       0x14   0x4770             BX       LR
    971          
    972          /*
    973           * Compare signed values
    974           */

   \                                 In section .text, align 2, keep-with-next
    975          int mbedtls_mpi_cmp_mpi(const mbedtls_mpi *X, const mbedtls_mpi *Y)
    976          {
   \                     mbedtls_mpi_cmp_mpi: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine5
    977              size_t i, j;
    978              MPI_VALIDATE_RET(X != NULL);
    979              MPI_VALIDATE_RET(Y != NULL);
    980          
    981              for (i = X->n; i > 0; i--) {
    982                  if (X->p[i - 1] != 0) {
    983                      break;
    984                  }
    985              }
    986          
    987              for (j = Y->n; j > 0; j--) {
   \                     ??CrossCallReturnLabel_12: (+1)
   \        0x6   0x.... 0x....      BL       ?Subroutine1
    988                  if (Y->p[j - 1] != 0) {
    989                      break;
    990                  }
    991              }
    992          
    993              if (i == 0 && j == 0) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xA   0xEA51 0x0200      ORRS     R2,R1,R0
   \        0xE   0xD02B             BEQ.N    ??mbedtls_mpi_cmp_mpi_0
    994                  return 0;
    995              }
    996          
    997              if (i > j) {
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD202             BCS.N    ??mbedtls_mpi_cmp_mpi_1
    998                  return X->s;
   \       0x14   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \       0x18   0xBD70             POP      {R4-R6,PC}
    999              }
   1000              if (j > i) {
   \                     ??mbedtls_mpi_cmp_mpi_1: (+1)
   \       0x1A   0xF9B4 0x2004      LDRSH    R2,[R4, #+4]
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD202             BCS.N    ??mbedtls_mpi_cmp_mpi_2
   1001                  return -Y->s;
   \       0x22   0x4252             RSBS     R2,R2,#+0
   \       0x24   0x4610             MOV      R0,R2
   \       0x26   0xBD70             POP      {R4-R6,PC}
   1002              }
   1003          
   1004              if (X->s > 0 && Y->s < 0) {
   \                     ??mbedtls_mpi_cmp_mpi_2: (+1)
   \       0x28   0xF9B3 0x1004      LDRSH    R1,[R3, #+4]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xDD03             BLE.N    ??mbedtls_mpi_cmp_mpi_3
   \       0x30   0x2A00             CMP      R2,#+0
   \       0x32   0xD50B             BPL.N    ??mbedtls_mpi_cmp_mpi_4
   1005                  return 1;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD70             POP      {R4-R6,PC}
   1006              }
   1007              if (Y->s > 0 && X->s < 0) {
   \                     ??mbedtls_mpi_cmp_mpi_3: (+1)
   \       0x38   0x2A00             CMP      R2,#+0
   \       0x3A   0xDD07             BLE.N    ??mbedtls_mpi_cmp_mpi_4
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD505             BPL.N    ??mbedtls_mpi_cmp_mpi_4
   1008                  return -1;
   \       0x40   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x44   0xBD70             POP      {R4-R6,PC}
   1009              }
   1010          
   1011              for (; i > 0; i--) {
   1012                  if (X->p[i - 1] > Y->p[i - 1]) {
   1013                      return X->s;
   1014                  }
   1015                  if (X->p[i - 1] < Y->p[i - 1]) {
   \                     ??mbedtls_mpi_cmp_mpi_5: (+1)
   \       0x46   0x42AA             CMP      R2,R5
   \       0x48   0xD30B             BCC.N    ??mbedtls_mpi_cmp_mpi_6
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \                     ??mbedtls_mpi_cmp_mpi_4: (+1)
   \       0x4C   0xB160             CBZ.N    R0,??mbedtls_mpi_cmp_mpi_0
   \       0x4E   0x681D             LDR      R5,[R3, #+0]
   \       0x50   0x1F2A             SUBS     R2,R5,#+4
   \       0x52   0x1F35             SUBS     R5,R6,#+4
   \       0x54   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \       0x58   0xF855 0x5020      LDR      R5,[R5, R0, LSL #+2]
   \       0x5C   0x4295             CMP      R5,R2
   \       0x5E   0xD2F2             BCS.N    ??mbedtls_mpi_cmp_mpi_5
   \       0x60   0xE000             B.N      ??mbedtls_mpi_cmp_mpi_7
   1016                      return -X->s;
   \                     ??mbedtls_mpi_cmp_mpi_6: (+1)
   \       0x62   0x4249             RSBS     R1,R1,#+0
   \                     ??mbedtls_mpi_cmp_mpi_7: (+1)
   \       0x64   0x4608             MOV      R0,R1
   \       0x66   0xBD70             POP      {R4-R6,PC}
   1017                  }
   1018              }
   1019          
   1020              return 0;
   \                     ??mbedtls_mpi_cmp_mpi_0: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   1021          }
   1022          
   1023          /*
   1024           * Compare signed values
   1025           */

   \                                 In section .text, align 2, keep-with-next
   1026          int mbedtls_mpi_cmp_int(const mbedtls_mpi *X, mbedtls_mpi_sint z)
   1027          {
   \                     mbedtls_mpi_cmp_int: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
   1028              mbedtls_mpi Y;
   1029              mbedtls_mpi_uint p[1];
   1030              MPI_VALIDATE_RET(X != NULL);
   1031          
   1032              *p  = mpi_sint_abs(z);
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF52             ITEE     PL
   \        0x6   0x9100             STRPL    R1,[SP, #+0]
   \        0x8   0x424A             RSBMI    R2,R1,#+0
   \        0xA   0x9200             STRMI    R2,[SP, #+0]
   1033              Y.s = TO_SIGN(z);
   \        0xC   0x0FC9             LSRS     R1,R1,#+31
   \        0xE   0x0049             LSLS     R1,R1,#+1
   \       0x10   0xF1C1 0x0101      RSB      R1,R1,#+1
   \       0x14   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   1034              Y.n = 1;
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0xF8AD 0x100A      STRH     R1,[SP, #+10]
   1035              Y.p = p;
   \       0x1E   0xF8CD 0xD004      STR      SP,[SP, #+4]
   1036          
   1037              return mbedtls_mpi_cmp_mpi(X, &Y);
   \       0x22   0xA901             ADD      R1,SP,#+4
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x28   0xBD0E             POP      {R1-R3,PC}
   1038          }
   1039          
   1040          /*
   1041           * Unsigned addition: X = |A| + |B|  (HAC 14.7)
   1042           */

   \                                 In section .text, align 2, keep-with-next
   1043          int mbedtls_mpi_add_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1044          {
   \                     mbedtls_mpi_add_abs: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4616             MOV      R6,R2
   1045              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1046              size_t j;
   1047              mbedtls_mpi_uint *p;
   1048              mbedtls_mpi_uint c;
   1049              MPI_VALIDATE_RET(X != NULL);
   1050              MPI_VALIDATE_RET(A != NULL);
   1051              MPI_VALIDATE_RET(B != NULL);
   1052          
   1053              if (X == B) {
   \        0x8   0x42B7             CMP      R7,R6
   \        0xA   0xBF04             ITT      EQ
   \        0xC   0x460E             MOVEQ    R6,R1
   \        0xE   0x4639             MOVEQ    R1,R7
   1054                  const mbedtls_mpi *T = A; A = X; B = T;
   1055              }
   1056          
   1057              if (X != A) {
   \       0x10   0x428F             CMP      R7,R1
   \       0x12   0xD004             BEQ.N    ??mbedtls_mpi_add_abs_0
   1058                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x18   0xEA5F 0x0800      MOVS     R8,R0
   \       0x1C   0xD135             BNE.N    ??mbedtls_mpi_add_abs_1
   1059              }
   1060          
   1061              /*
   1062               * X must always be positive as a result of unsigned additions.
   1063               */
   1064              X->s = 1;
   \                     ??mbedtls_mpi_add_abs_0: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x80B8             STRH     R0,[R7, #+4]
   1065          
   1066              for (j = B->n; j > 0; j--) {
   \       0x22   0x88F5             LDRH     R5,[R6, #+6]
   \       0x24   0xE006             B.N      ??mbedtls_mpi_add_abs_2
   1067                  if (B->p[j - 1] != 0) {
   \                     ??mbedtls_mpi_add_abs_3: (+1)
   \       0x26   0x6832             LDR      R2,[R6, #+0]
   \       0x28   0xEB02 0x0185      ADD      R1,R2,R5, LSL #+2
   \       0x2C   0xF851 0x0C04      LDR      R0,[R1, #-4]
   \       0x30   0xB920             CBNZ.N   R0,??mbedtls_mpi_add_abs_4
   1068                      break;
   1069                  }
   1070              }
   \       0x32   0x1E6D             SUBS     R5,R5,#+1
   \                     ??mbedtls_mpi_add_abs_2: (+1)
   \       0x34   0x2D00             CMP      R5,#+0
   \       0x36   0xD1F6             BNE.N    ??mbedtls_mpi_add_abs_3
   1071          
   1072              /* Exit early to avoid undefined behavior on NULL+0 when X->n == 0
   1073               * and B is 0 (of any size). */
   1074              if (j == 0) {
   1075                  return 0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE027             B.N      ??mbedtls_mpi_add_abs_5
   1076              }
   1077          
   1078              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j));
   \                     ??mbedtls_mpi_add_abs_4: (+1)
   \       0x3C   0x4629             MOV      R1,R5
   \       0x3E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x42   0xEA5F 0x0800      MOVS     R8,R0
   \       0x46   0xD120             BNE.N    ??mbedtls_mpi_add_abs_1
   1079          
   1080              /* j is the number of non-zero limbs of B. Add those to X. */
   1081          
   1082              p = X->p;
   \       0x48   0x683C             LDR      R4,[R7, #+0]
   1083          
   1084              c = mbedtls_mpi_core_add(p, p, B->p, j);
   \       0x4A   0x6832             LDR      R2,[R6, #+0]
   \       0x4C   0x462B             MOV      R3,R5
   \       0x4E   0x4621             MOV      R1,R4
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x.... 0x....      BL       mbedtls_mpi_core_add
   \       0x56   0x4606             MOV      R6,R0
   1085          
   1086              p += j;
   \       0x58   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \       0x5C   0xE00A             B.N      ??mbedtls_mpi_add_abs_6
   1087          
   1088              /* Now propagate any carry */
   1089          
   1090              while (c != 0) {
   1091                  if (j >= X->n) {
   1092                      MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, j + 1));
   1093                      p = X->p + j;
   \                     ??mbedtls_mpi_add_abs_7: (+1)
   \       0x5E   0x6838             LDR      R0,[R7, #+0]
   \       0x60   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   1094                  }
   1095          
   1096                  *p += c; c = (*p < c); j++; p++;
   \                     ??mbedtls_mpi_add_abs_8: (+1)
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0x4625             MOV      R5,R4
   \       0x68   0x1871             ADDS     R1,R6,R1
   \       0x6A   0x42B1             CMP      R1,R6
   \       0x6C   0x41B6             SBCS     R6,R6,R6
   \       0x6E   0x0FF6             LSRS     R6,R6,#+31
   \       0x70   0xF840 0x1B04      STR      R1,[R0], #+4
   \                     ??mbedtls_mpi_add_abs_6: (+1)
   \       0x74   0xB14E             CBZ.N    R6,??mbedtls_mpi_add_abs_1
   \       0x76   0x88F9             LDRH     R1,[R7, #+6]
   \       0x78   0x1C6C             ADDS     R4,R5,#+1
   \       0x7A   0x428D             CMP      R5,R1
   \       0x7C   0xD3F2             BCC.N    ??mbedtls_mpi_add_abs_8
   \       0x7E   0x4621             MOV      R1,R4
   \       0x80   0x.... 0x....      BL       ?Subroutine4
   1097              }
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x84   0xEA5F 0x0800      MOVS     R8,R0
   \       0x88   0xD0E9             BEQ.N    ??mbedtls_mpi_add_abs_7
   1098          
   1099          cleanup:
   1100          
   1101              return ret;
   \                     ??mbedtls_mpi_add_abs_1: (+1)
   \       0x8A   0x4640             MOV      R0,R8
   \                     ??mbedtls_mpi_add_abs_5: (+1)
   \       0x8C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1102          }
   1103          
   1104          /*
   1105           * Unsigned subtraction: X = |A| - |B|  (HAC 14.9, 14.10)
   1106           */

   \                                 In section .text, align 2, keep-with-next
   1107          int mbedtls_mpi_sub_abs(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1108          {
   \                     mbedtls_mpi_sub_abs: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4617             MOV      R7,R2
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460D             MOV      R5,R1
   1109              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1110              size_t n;
   1111              mbedtls_mpi_uint carry;
   1112              MPI_VALIDATE_RET(X != NULL);
   1113              MPI_VALIDATE_RET(A != NULL);
   1114              MPI_VALIDATE_RET(B != NULL);
   1115          
   1116              for (n = B->n; n > 0; n--) {
   \        0xA   0x88FC             LDRH     R4,[R7, #+6]
   \        0xC   0x683A             LDR      R2,[R7, #+0]
   \        0xE   0xE000             B.N      ??mbedtls_mpi_sub_abs_0
   \                     ??mbedtls_mpi_sub_abs_1: (+1)
   \       0x10   0x1E64             SUBS     R4,R4,#+1
   \                     ??mbedtls_mpi_sub_abs_0: (+1)
   \       0x12   0xB114             CBZ.N    R4,??mbedtls_mpi_sub_abs_2
   1117                  if (B->p[n - 1] != 0) {
   \       0x14   0x.... 0x....      BL       ?Subroutine15
   1118                      break;
   1119                  }
   1120              }
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x18   0xD0FA             BEQ.N    ??mbedtls_mpi_sub_abs_1
   1121              if (n > A->n) {
   \                     ??mbedtls_mpi_sub_abs_2: (+1)
   \       0x1A   0x88E9             LDRH     R1,[R5, #+6]
   \       0x1C   0x42A1             CMP      R1,R4
   \       0x1E   0xD330             BCC.N    ??mbedtls_mpi_sub_abs_3
   1122                  /* B >= (2^ciL)^n > A */
   1123                  ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   1124                  goto cleanup;
   1125              }
   1126          
   1127              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, A->n));
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x26   0xEA5F 0x0800      MOVS     R8,R0
   \       0x2A   0xD12F             BNE.N    ??mbedtls_mpi_sub_abs_4
   1128          
   1129              /* Set the high limbs of X to match A. Don't touch the lower limbs
   1130               * because X might be aliased to B, and we must not overwrite the
   1131               * significant digits of B. */
   1132              if (A->n > n && A != X) {
   \       0x2C   0x88EA             LDRH     R2,[R5, #+6]
   \       0x2E   0x4294             CMP      R4,R2
   \       0x30   0xD20B             BCS.N    ??mbedtls_mpi_sub_abs_5
   \       0x32   0x42B5             CMP      R5,R6
   \       0x34   0xD009             BEQ.N    ??mbedtls_mpi_sub_abs_5
   1133                  memcpy(X->p + n, A->p + n, (A->n - n) * ciL);
   \       0x36   0x6829             LDR      R1,[R5, #+0]
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0x1B12             SUBS     R2,R2,R4
   \       0x3C   0x0092             LSLS     R2,R2,#+2
   \       0x3E   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \       0x42   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x46   0x.... 0x....      BL       __aeabi_memcpy
   1134              }
   1135              if (X->n > A->n) {
   \                     ??mbedtls_mpi_sub_abs_5: (+1)
   \       0x4A   0x88F1             LDRH     R1,[R6, #+6]
   \       0x4C   0x88E8             LDRH     R0,[R5, #+6]
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD206             BCS.N    ??mbedtls_mpi_sub_abs_6
   1136                  memset(X->p + A->n, 0, (X->n - A->n) * ciL);
   \       0x52   0x6832             LDR      R2,[R6, #+0]
   \       0x54   0x1A09             SUBS     R1,R1,R0
   \       0x56   0x0089             LSLS     R1,R1,#+2
   \       0x58   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \       0x5C   0x.... 0x....      BL       __aeabi_memclr
   1137              }
   1138          
   1139              carry = mbedtls_mpi_core_sub(X->p, A->p, B->p, n);
   \                     ??mbedtls_mpi_sub_abs_6: (+1)
   \       0x60   0x683A             LDR      R2,[R7, #+0]
   \       0x62   0x6829             LDR      R1,[R5, #+0]
   \       0x64   0x6830             LDR      R0,[R6, #+0]
   \       0x66   0x4623             MOV      R3,R4
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_core_sub
   1140              if (carry != 0) {
   \       0x6C   0xB160             CBZ.N    R0,??mbedtls_mpi_sub_abs_7
   1141                  /* Propagate the carry through the rest of X. */
   1142                  carry = mbedtls_mpi_core_sub_int(X->p + n, X->p + n, carry, X->n - n);
   1143          
   1144                  /* If we have further carry/borrow, the result is negative. */
   1145                  if (carry != 0) {
   \       0x6E   0x88F2             LDRH     R2,[R6, #+6]
   \       0x70   0x6831             LDR      R1,[R6, #+0]
   \       0x72   0x1B13             SUBS     R3,R2,R4
   \       0x74   0x4602             MOV      R2,R0
   \       0x76   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \       0x7A   0x4608             MOV      R0,R1
   \       0x7C   0x.... 0x....      BL       mbedtls_mpi_core_sub_int
   \       0x80   0xB110             CBZ.N    R0,??mbedtls_mpi_sub_abs_7
   1146                      ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \                     ??mbedtls_mpi_sub_abs_3: (+1)
   \       0x82   0xF06F 0x0809      MVN      R8,#+9
   1147                      goto cleanup;
   \       0x86   0xE001             B.N      ??mbedtls_mpi_sub_abs_4
   1148                  }
   1149              }
   1150          
   1151              /* X should always be positive as a result of unsigned subtractions. */
   1152              X->s = 1;
   \                     ??mbedtls_mpi_sub_abs_7: (+1)
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0x80B0             STRH     R0,[R6, #+4]
   1153          
   1154          cleanup:
   1155              return ret;
   \                     ??mbedtls_mpi_sub_abs_4: (+1)
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1156          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0xEB02 0x0184      ADD      R1,R2,R4, LSL #+2
   \        0x4   0xF851 0x0C04      LDR      R0,[R1, #-4]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0x4770             BX       LR
   1157          
   1158          /* Common function for signed addition and subtraction.
   1159           * Calculate A + B * flip_B where flip_B is 1 or -1.
   1160           */

   \                                 In section .text, align 2, keep-with-next
   1161          static int add_sub_mpi(mbedtls_mpi *X,
   1162                                 const mbedtls_mpi *A, const mbedtls_mpi *B,
   1163                                 int flip_B)
   1164          {
   \                     add_sub_mpi: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   1165              int ret, s;
   1166              MPI_VALIDATE_RET(X != NULL);
   1167              MPI_VALIDATE_RET(A != NULL);
   1168              MPI_VALIDATE_RET(B != NULL);
   1169          
   1170              s = A->s;
   \        0xA   0xF9B7 0x6004      LDRSH    R6,[R7, #+4]
   1171              if (A->s * B->s * flip_B < 0) {
   \        0xE   0xF9B8 0x0004      LDRSH    R0,[R8, #+4]
   \       0x12   0xFB16 0xF000      SMULBB   R0,R6,R0
   \       0x16   0x4343             MULS     R3,R3,R0
   \       0x18   0xD516             BPL.N    ??add_sub_mpi_0
   1172                  int cmp = mbedtls_mpi_cmp_abs(A, B);
   \       0x1A   0x4641             MOV      R1,R8
   \       0x1C   0x4638             MOV      R0,R7
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_cmp_abs
   \       0x22   0x0004             MOVS     R4,R0
   1173                  if (cmp >= 0) {
   \       0x24   0xD408             BMI.N    ??add_sub_mpi_1
   1174                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, A, B));
   \       0x26   0x4642             MOV      R2,R8
   \       0x28   0x4639             MOV      R1,R7
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x30   0xB978             CBNZ.N   R0,??add_sub_mpi_2
   1175                      /* If |A| = |B|, the result is 0 and we must set the sign bit
   1176                       * to +1 regardless of which of A or B was negative. Otherwise,
   1177                       * since |A| > |B|, the sign is the sign of A. */
   1178                      X->s = cmp == 0 ? 1 : s;
   \       0x32   0xB96C             CBNZ.N   R4,??add_sub_mpi_3
   \       0x34   0x2601             MOVS     R6,#+1
   \       0x36   0xE00B             B.N      ??add_sub_mpi_3
   1179                  } else {
   1180                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(X, B, A));
   \                     ??add_sub_mpi_1: (+1)
   \       0x38   0x463A             MOV      R2,R7
   \       0x3A   0x4641             MOV      R1,R8
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x42   0xB930             CBNZ.N   R0,??add_sub_mpi_2
   1181                      /* Since |A| < |B|, the sign is the opposite of A. */
   1182                      X->s = -s;
   \       0x44   0x4276             RSBS     R6,R6,#+0
   \       0x46   0xE003             B.N      ??add_sub_mpi_3
   1183                  }
   1184              } else {
   1185                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_abs(X, A, B));
   \                     ??add_sub_mpi_0: (+1)
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_add_abs
   \       0x4E   0xB900             CBNZ.N   R0,??add_sub_mpi_2
   1186                  X->s = s;
   \                     ??add_sub_mpi_3: (+1)
   \       0x50   0x80AE             STRH     R6,[R5, #+4]
   1187              }
   1188          
   1189          cleanup:
   1190          
   1191              return ret;
   \                     ??add_sub_mpi_2: (+1)
   \       0x52   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1192          }
   1193          
   1194          /*
   1195           * Signed addition: X = A + B
   1196           */

   \                                 In section .text, align 2, keep-with-next
   1197          int mbedtls_mpi_add_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1198          {
   1199              return add_sub_mpi(X, A, B, 1);
   \                     mbedtls_mpi_add_mpi: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0x....             B.N      add_sub_mpi
   1200          }
   1201          
   1202          /*
   1203           * Signed subtraction: X = A - B
   1204           */

   \                                 In section .text, align 2, keep-with-next
   1205          int mbedtls_mpi_sub_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1206          {
   1207              return add_sub_mpi(X, A, B, -1);
   \                     mbedtls_mpi_sub_mpi: (+1)
   \        0x0   0xF04F 0x33FF      MOV      R3,#+4294967295
   \        0x4   0x....             B.N      add_sub_mpi
   1208          }
   1209          
   1210          /*
   1211           * Signed addition: X = A + b
   1212           */

   \                                 In section .text, align 2, keep-with-next
   1213          int mbedtls_mpi_add_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
   1214          {
   \                     mbedtls_mpi_add_int: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
   1215              mbedtls_mpi B;
   1216              mbedtls_mpi_uint p[1];
   1217              MPI_VALIDATE_RET(X != NULL);
   1218              MPI_VALIDATE_RET(A != NULL);
   1219          
   1220              p[0] = mpi_sint_abs(b);
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xBF52             ITEE     PL
   \        0x6   0x9200             STRPL    R2,[SP, #+0]
   \        0x8   0x4253             RSBMI    R3,R2,#+0
   \        0xA   0x9300             STRMI    R3,[SP, #+0]
   1221              B.s = TO_SIGN(b);
   \        0xC   0x.... 0x....      BL       ?Subroutine6
   1222              B.n = 1;
   1223              B.p = p;
   1224          
   1225              return mbedtls_mpi_add_mpi(X, A, &B);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x14   0xBD0E             POP      {R1-R3,PC}
   1226          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x0FD2             LSRS     R2,R2,#+31
   \        0x2   0x0052             LSLS     R2,R2,#+1
   \        0x4   0xF1C2 0x0201      RSB      R2,R2,#+1
   \        0x8   0xF8AD 0x2008      STRH     R2,[SP, #+8]
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0xF8AD 0x200A      STRH     R2,[SP, #+10]
   \       0x12   0xF8CD 0xD004      STR      SP,[SP, #+4]
   \       0x16   0xAA01             ADD      R2,SP,#+4
   \       0x18   0x4770             BX       LR
   1227          
   1228          /*
   1229           * Signed subtraction: X = A - b
   1230           */

   \                                 In section .text, align 2, keep-with-next
   1231          int mbedtls_mpi_sub_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b)
   1232          {
   \                     mbedtls_mpi_sub_int: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
   1233              mbedtls_mpi B;
   1234              mbedtls_mpi_uint p[1];
   1235              MPI_VALIDATE_RET(X != NULL);
   1236              MPI_VALIDATE_RET(A != NULL);
   1237          
   1238              p[0] = mpi_sint_abs(b);
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xBF52             ITEE     PL
   \        0x6   0x9200             STRPL    R2,[SP, #+0]
   \        0x8   0x4253             RSBMI    R3,R2,#+0
   \        0xA   0x9300             STRMI    R3,[SP, #+0]
   1239              B.s = TO_SIGN(b);
   \        0xC   0x.... 0x....      BL       ?Subroutine6
   1240              B.n = 1;
   1241              B.p = p;
   1242          
   1243              return mbedtls_mpi_sub_mpi(X, A, &B);
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x14   0xBD0E             POP      {R1-R3,PC}
   1244          }
   1245          
   1246          /*
   1247           * Baseline multiplication: X = A * B  (HAC 14.12)
   1248           */

   \                                 In section .text, align 2, keep-with-next
   1249          int mbedtls_mpi_mul_mpi(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1250          {
   \                     mbedtls_mpi_mul_mpi: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4617             MOV      R7,R2
   1251              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1252              size_t i, j;
   1253              mbedtls_mpi TA, TB;
   1254              int result_is_zero = 0;
   1255              MPI_VALIDATE_RET(X != NULL);
   1256              MPI_VALIDATE_RET(A != NULL);
   1257              MPI_VALIDATE_RET(B != NULL);
   1258          
   1259              mbedtls_mpi_init(&TA);
   \        0xC   0xA803             ADD      R0,SP,#+12
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_init
   1260              mbedtls_mpi_init(&TB);
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x2600             MOVS     R6,#+0
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_init
   1261          
   1262              if (X == A) {
   \       0x1A   0x45C8             CMP      R8,R9
   \       0x1C   0xD108             BNE.N    ??mbedtls_mpi_mul_mpi_0
   1263                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A)); A = &TA;
   \       0x1E   0x4649             MOV      R1,R9
   \       0x20   0xA803             ADD      R0,SP,#+12
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x26   0x4682             MOV      R10,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD144             BNE.N    ??mbedtls_mpi_mul_mpi_1
   \       0x2C   0xF10D 0x090C      ADD      R9,SP,#+12
   1264              }
   1265              if (X == B) {
   \                     ??mbedtls_mpi_mul_mpi_0: (+1)
   \       0x30   0x45B8             CMP      R8,R7
   \       0x32   0xD107             BNE.N    ??mbedtls_mpi_mul_mpi_2
   1266                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B)); B = &TB;
   \       0x34   0x4639             MOV      R1,R7
   \       0x36   0xA801             ADD      R0,SP,#+4
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x3C   0x4682             MOV      R10,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD139             BNE.N    ??mbedtls_mpi_mul_mpi_1
   \       0x42   0xAF01             ADD      R7,SP,#+4
   1267              }
   1268          
   1269              for (i = A->n; i > 0; i--) {
   \                     ??mbedtls_mpi_mul_mpi_2: (+1)
   \       0x44   0xF8B9 0x5006      LDRH     R5,[R9, #+6]
   \       0x48   0xE007             B.N      ??mbedtls_mpi_mul_mpi_3
   1270                  if (A->p[i - 1] != 0) {
   \                     ??mbedtls_mpi_mul_mpi_4: (+1)
   \       0x4A   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0x4E   0xEB02 0x0185      ADD      R1,R2,R5, LSL #+2
   \       0x52   0xF851 0x0C04      LDR      R0,[R1, #-4]
   \       0x56   0xB918             CBNZ.N   R0,??mbedtls_mpi_mul_mpi_5
   1271                      break;
   1272                  }
   1273              }
   \       0x58   0x1E6D             SUBS     R5,R5,#+1
   \                     ??mbedtls_mpi_mul_mpi_3: (+1)
   \       0x5A   0x2D00             CMP      R5,#+0
   \       0x5C   0xD1F5             BNE.N    ??mbedtls_mpi_mul_mpi_4
   1274              if (i == 0) {
   1275                  result_is_zero = 1;
   \       0x5E   0x2601             MOVS     R6,#+1
   1276              }
   1277          
   1278              for (j = B->n; j > 0; j--) {
   \                     ??mbedtls_mpi_mul_mpi_5: (+1)
   \       0x60   0x88FC             LDRH     R4,[R7, #+6]
   \       0x62   0xE006             B.N      ??mbedtls_mpi_mul_mpi_6
   1279                  if (B->p[j - 1] != 0) {
   \                     ??mbedtls_mpi_mul_mpi_7: (+1)
   \       0x64   0x683A             LDR      R2,[R7, #+0]
   \       0x66   0xEB02 0x0184      ADD      R1,R2,R4, LSL #+2
   \       0x6A   0xF851 0x0C04      LDR      R0,[R1, #-4]
   \       0x6E   0xB918             CBNZ.N   R0,??mbedtls_mpi_mul_mpi_8
   1280                      break;
   1281                  }
   1282              }
   \       0x70   0x1E64             SUBS     R4,R4,#+1
   \                     ??mbedtls_mpi_mul_mpi_6: (+1)
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD1F6             BNE.N    ??mbedtls_mpi_mul_mpi_7
   1283              if (j == 0) {
   1284                  result_is_zero = 1;
   \       0x76   0x2601             MOVS     R6,#+1
   1285              }
   1286          
   1287              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, i + j));
   \                     ??mbedtls_mpi_mul_mpi_8: (+1)
   \       0x78   0x1961             ADDS     R1,R4,R5
   \       0x7A   0x4640             MOV      R0,R8
   \       0x7C   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0x80   0x4682             MOV      R10,R0
   \       0x82   0xB9C0             CBNZ.N   R0,??mbedtls_mpi_mul_mpi_1
   1288              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 0));
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0x4640             MOV      R0,R8
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x8C   0x4682             MOV      R10,R0
   \       0x8E   0xB990             CBNZ.N   R0,??mbedtls_mpi_mul_mpi_1
   1289          
   1290              mbedtls_mpi_core_mul(X->p, A->p, i, B->p, j);
   \       0x90   0x9400             STR      R4,[SP, #+0]
   \       0x92   0x683B             LDR      R3,[R7, #+0]
   \       0x94   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x98   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x9C   0x462A             MOV      R2,R5
   \       0x9E   0x.... 0x....      BL       mbedtls_mpi_core_mul
   1291          
   1292              /* If the result is 0, we don't shortcut the operation, which reduces
   1293               * but does not eliminate side channels leaking the zero-ness. We do
   1294               * need to take care to set the sign bit properly since the library does
   1295               * not fully support an MPI object with a value of 0 and s == -1. */
   1296              if (result_is_zero) {
   \       0xA2   0x2E00             CMP      R6,#+0
   \       0xA4   0xBF11             ITEEE    NE
   \       0xA6   0x2001             MOVNE    R0,#+1
   \       0xA8   0xF8B9 0x0004      LDRHEQ   R0,[R9, #+4]
   \       0xAC   0x88B9             LDRHEQ   R1,[R7, #+4]
   \       0xAE   0xFB10 0xF001      SMULBBEQ R0,R0,R1
   1297                  X->s = 1;
   1298              } else {
   1299                  X->s = A->s * B->s;
   \       0xB2   0xF8A8 0x0004      STRH     R0,[R8, #+4]
   1300              }
   1301          
   1302          cleanup:
   1303          
   1304              mbedtls_mpi_free(&TB); mbedtls_mpi_free(&TA);
   \                     ??mbedtls_mpi_mul_mpi_1: (+1)
   \       0xB6   0xA801             ADD      R0,SP,#+4
   \       0xB8   0x.... 0x....      BL       mbedtls_mpi_free
   \       0xBC   0xA803             ADD      R0,SP,#+12
   \       0xBE   0x.... 0x....      BL       mbedtls_mpi_free
   1305          
   1306              return ret;
   \       0xC2   0x4650             MOV      R0,R10
   \       0xC4   0xB006             ADD      SP,SP,#+24
   \       0xC6   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1307          }
   1308          
   1309          /*
   1310           * Baseline multiplication: X = A * b
   1311           */

   \                                 In section .text, align 2, keep-with-next
   1312          int mbedtls_mpi_mul_int(mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b)
   1313          {
   \                     mbedtls_mpi_mul_int: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x4607             MOV      R7,R0
   1314              MPI_VALIDATE_RET(X != NULL);
   1315              MPI_VALIDATE_RET(A != NULL);
   1316          
   1317              size_t n = A->n;
   \        0xA   0x88EC             LDRH     R4,[R5, #+6]
   \        0xC   0x682A             LDR      R2,[R5, #+0]
   \        0xE   0xE000             B.N      ??mbedtls_mpi_mul_int_0
   1318              while (n > 0 && A->p[n - 1] == 0) {
   1319                  --n;
   \                     ??mbedtls_mpi_mul_int_1: (+1)
   \       0x10   0x1E64             SUBS     R4,R4,#+1
   1320              }
   \                     ??mbedtls_mpi_mul_int_0: (+1)
   \       0x12   0xB1DC             CBZ.N    R4,??mbedtls_mpi_mul_int_2
   \       0x14   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x18   0xD0FA             BEQ.N    ??mbedtls_mpi_mul_int_1
   1321          
   1322              /* The general method below doesn't work if b==0. */
   1323              if (b == 0 || n == 0) {
   \       0x1A   0xB1BE             CBZ.N    R6,??mbedtls_mpi_mul_int_2
   1324                  return mbedtls_mpi_lset(X, 0);
   1325              }
   1326          
   1327              /* Calculate A*b as A + A*(b-1) to take advantage of mbedtls_mpi_core_mla */
   1328              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1329              /* In general, A * b requires 1 limb more than b. If
   1330               * A->p[n - 1] * b / b == A->p[n - 1], then A * b fits in the same
   1331               * number of limbs as A and the call to grow() is not required since
   1332               * copy() will take care of the growth if needed. However, experimentally,
   1333               * making the call to grow() unconditional causes slightly fewer
   1334               * calls to calloc() in ECP code, presumably because it reuses the
   1335               * same mpi for a while and this way the mpi is more likely to directly
   1336               * grow to its final size.
   1337               *
   1338               * Note that calculating A*b as 0 + A*b doesn't work as-is because
   1339               * A,X can be the same. */
   1340              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(X, n + 1));
   \       0x1C   0x1C61             ADDS     R1,R4,#+1
   \       0x1E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x22   0xEA5F 0x0800      MOVS     R8,R0
   \       0x26   0xD10E             BNE.N    ??mbedtls_mpi_mul_int_3
   1341              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A));
   \       0x28   0x4629             MOV      R1,R5
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x30   0xEA5F 0x0800      MOVS     R8,R0
   \       0x34   0xD107             BNE.N    ??mbedtls_mpi_mul_int_3
   1342              mbedtls_mpi_core_mla(X->p, X->n, A->p, n, b - 1);
   \       0x36   0x1E76             SUBS     R6,R6,#+1
   \       0x38   0x9600             STR      R6,[SP, #+0]
   \       0x3A   0x682A             LDR      R2,[R5, #+0]
   \       0x3C   0x88F9             LDRH     R1,[R7, #+6]
   \       0x3E   0x6838             LDR      R0,[R7, #+0]
   \       0x40   0x4623             MOV      R3,R4
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_core_mla
   1343          
   1344          cleanup:
   1345              return ret;
   \                     ??mbedtls_mpi_mul_int_3: (+1)
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   \                     ??mbedtls_mpi_mul_int_2: (+1)
   \       0x4C   0x4638             MOV      R0,R7
   \       0x4E   0x2100             MOVS     R1,#+0
   \       0x50   0xE8BD 0x41FC      POP      {R2-R8,LR}
   \       0x54   0x.... 0x....      B.W      mbedtls_mpi_lset
   1346          }
   1347          
   1348          /*
   1349           * Unsigned integer divide - double mbedtls_mpi_uint dividend, u1/u0, and
   1350           * mbedtls_mpi_uint divisor, d
   1351           */
   1352          static mbedtls_mpi_uint mbedtls_int_div_int(mbedtls_mpi_uint u1,
   1353                                                      mbedtls_mpi_uint u0,
   1354                                                      mbedtls_mpi_uint d,
   1355                                                      mbedtls_mpi_uint *r)
   1356          {
   1357          #if defined(MBEDTLS_HAVE_UDBL)
   1358              mbedtls_t_udbl dividend, quotient;
   1359          #else
   1360              const mbedtls_mpi_uint radix = (mbedtls_mpi_uint) 1 << biH;
   1361              const mbedtls_mpi_uint uint_halfword_mask = ((mbedtls_mpi_uint) 1 << biH) - 1;
   1362              mbedtls_mpi_uint d0, d1, q0, q1, rAX, r0, quotient;
   1363              mbedtls_mpi_uint u0_msw, u0_lsw;
   1364              size_t s;
   1365          #endif
   1366          
   1367              /*
   1368               * Check for overflow
   1369               */
   1370              if (0 == d || u1 >= d) {
   1371                  if (r != NULL) {
   1372                      *r = ~(mbedtls_mpi_uint) 0u;
   1373                  }
   1374          
   1375                  return ~(mbedtls_mpi_uint) 0u;
   1376              }
   1377          
   1378          #if defined(MBEDTLS_HAVE_UDBL)
   1379              dividend  = (mbedtls_t_udbl) u1 << biL;
   1380              dividend |= (mbedtls_t_udbl) u0;
   1381              quotient = dividend / d;
   1382              if (quotient > ((mbedtls_t_udbl) 1 << biL) - 1) {
   1383                  quotient = ((mbedtls_t_udbl) 1 << biL) - 1;
   1384              }
   1385          
   1386              if (r != NULL) {
   1387                  *r = (mbedtls_mpi_uint) (dividend - (quotient * d));
   1388              }
   1389          
   1390              return (mbedtls_mpi_uint) quotient;
   1391          #else
   1392          
   1393              /*
   1394               * Algorithm D, Section 4.3.1 - The Art of Computer Programming
   1395               *   Vol. 2 - Seminumerical Algorithms, Knuth
   1396               */
   1397          
   1398              /*
   1399               * Normalize the divisor, d, and dividend, u0, u1
   1400               */
   1401              s = mbedtls_mpi_core_clz(d);
   1402              d = d << s;
   1403          
   1404              u1 = u1 << s;
   1405              u1 |= (u0 >> (biL - s)) & (-(mbedtls_mpi_sint) s >> (biL - 1));
   1406              u0 =  u0 << s;
   1407          
   1408              d1 = d >> biH;
   1409              d0 = d & uint_halfword_mask;
   1410          
   1411              u0_msw = u0 >> biH;
   1412              u0_lsw = u0 & uint_halfword_mask;
   1413          
   1414              /*
   1415               * Find the first quotient and remainder
   1416               */
   1417              q1 = u1 / d1;
   1418              r0 = u1 - d1 * q1;
   1419          
   1420              while (q1 >= radix || (q1 * d0 > radix * r0 + u0_msw)) {
   1421                  q1 -= 1;
   1422                  r0 += d1;
   1423          
   1424                  if (r0 >= radix) {
   1425                      break;
   1426                  }
   1427              }
   1428          
   1429              rAX = (u1 * radix) + (u0_msw - q1 * d);
   1430              q0 = rAX / d1;
   1431              r0 = rAX - q0 * d1;
   1432          
   1433              while (q0 >= radix || (q0 * d0 > radix * r0 + u0_lsw)) {
   1434                  q0 -= 1;
   1435                  r0 += d1;
   1436          
   1437                  if (r0 >= radix) {
   1438                      break;
   1439                  }
   1440              }
   1441          
   1442              if (r != NULL) {
   1443                  *r = (rAX * radix + u0_lsw - q0 * d) >> s;
   1444              }
   1445          
   1446              quotient = q1 * radix + q0;
   1447          
   1448              return quotient;
   1449          #endif
   1450          }
   1451          
   1452          /*
   1453           * Division by mbedtls_mpi: A = Q * B + R  (HAC 14.20)
   1454           */

   \                                 In section .text, align 2, keep-with-next
   1455          int mbedtls_mpi_div_mpi(mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A,
   1456                                  const mbedtls_mpi *B)
   1457          {
   \                     mbedtls_mpi_div_mpi: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x469B             MOV      R11,R3
   \        0xA   0xB08F             SUB      SP,SP,#+60
   \        0xC   0x4616             MOV      R6,R2
   1458              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1459              size_t i, n, t, k;
   1460              mbedtls_mpi X, Y, Z, T1, T2;
   1461              mbedtls_mpi_uint TP2[3];
   1462              MPI_VALIDATE_RET(A != NULL);
   1463              MPI_VALIDATE_RET(B != NULL);
   1464          
   1465              if (mbedtls_mpi_cmp_int(B, 0) == 0) {
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x4658             MOV      R0,R11
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x16   0xB910             CBNZ.N   R0,??mbedtls_mpi_div_mpi_0
   1466                  return MBEDTLS_ERR_MPI_DIVISION_BY_ZERO;
   \       0x18   0xF06F 0x000B      MVN      R0,#+11
   \       0x1C   0xE177             B.N      ??mbedtls_mpi_div_mpi_1
   1467              }
   1468          
   1469              mbedtls_mpi_init(&X); mbedtls_mpi_init(&Y); mbedtls_mpi_init(&Z);
   \                     ??mbedtls_mpi_div_mpi_0: (+1)
   \       0x1E   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x22   0xA802             ADD      R0,SP,#+8
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x28   0xA806             ADD      R0,SP,#+24
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_init
   1470              mbedtls_mpi_init(&T1);
   \       0x2E   0xA804             ADD      R0,SP,#+16
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_init
   1471              /*
   1472               * Avoid dynamic memory allocations for constant-size T2.
   1473               *
   1474               * T2 is used for comparison only and the 3 limbs are assigned explicitly,
   1475               * so nobody increase the size of the MPI and we're safe to use an on-stack
   1476               * buffer.
   1477               */
   1478              T2.s = 1;
   \       0x34   0x2001             MOVS     R0,#+1
   1479              T2.n = sizeof(TP2) / sizeof(*TP2);
   \       0x36   0x2103             MOVS     R1,#+3
   \       0x38   0xF8AD 0x0024      STRH     R0,[SP, #+36]
   \       0x3C   0xF8AD 0x1026      STRH     R1,[SP, #+38]
   1480              T2.p = TP2;
   \       0x40   0xAA0C             ADD      R2,SP,#+48
   \       0x42   0x9208             STR      R2,[SP, #+32]
   \       0x44   0x940A             STR      R4,[SP, #+40]
   1481          
   1482              if (mbedtls_mpi_cmp_abs(A, B) < 0) {
   \       0x46   0x4659             MOV      R1,R11
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_cmp_abs
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD511             BPL.N    ??mbedtls_mpi_div_mpi_2
   1483                  if (Q != NULL) {
   \       0x52   0x980A             LDR      R0,[SP, #+40]
   \       0x54   0xB128             CBZ.N    R0,??mbedtls_mpi_div_mpi_3
   1484                      MBEDTLS_MPI_CHK(mbedtls_mpi_lset(Q, 0));
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x5C   0x4680             MOV      R8,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD170             BNE.N    ??mbedtls_mpi_div_mpi_4
   1485                  }
   1486                  if (R != NULL) {
   \                     ??mbedtls_mpi_div_mpi_3: (+1)
   \       0x62   0xB137             CBZ.N    R7,??mbedtls_mpi_div_mpi_5
   1487                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, A));
   \       0x64   0x4631             MOV      R1,R6
   \       0x66   0x4638             MOV      R0,R7
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x6C   0x4680             MOV      R8,R0
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD168             BNE.N    ??mbedtls_mpi_div_mpi_4
   1488                  }
   1489                  return 0;
   \                     ??mbedtls_mpi_div_mpi_5: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xE14B             B.N      ??mbedtls_mpi_div_mpi_1
   1490              }
   1491          
   1492              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&X, A));
   \                     ??mbedtls_mpi_div_mpi_2: (+1)
   \       0x76   0x4631             MOV      R1,R6
   \       0x78   0x4668             MOV      R0,SP
   \       0x7A   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x7E   0x4680             MOV      R8,R0
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD15F             BNE.N    ??mbedtls_mpi_div_mpi_4
   1493              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Y, B));
   \       0x84   0x4659             MOV      R1,R11
   \       0x86   0xA802             ADD      R0,SP,#+8
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x8C   0x4680             MOV      R8,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD158             BNE.N    ??mbedtls_mpi_div_mpi_4
   1494              X.s = Y.s = 1;
   \       0x92   0x2201             MOVS     R2,#+1
   \       0x94   0xF8AD 0x200C      STRH     R2,[SP, #+12]
   \       0x98   0xF8AD 0x2004      STRH     R2,[SP, #+4]
   1495          
   1496              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&Z, A->n + 2));
   \       0x9C   0x88F1             LDRH     R1,[R6, #+6]
   \       0x9E   0xA806             ADD      R0,SP,#+24
   \       0xA0   0x1C89             ADDS     R1,R1,#+2
   \       0xA2   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xA6   0x4680             MOV      R8,R0
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD14B             BNE.N    ??mbedtls_mpi_div_mpi_4
   1497              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&Z,  0));
   \       0xAC   0x2100             MOVS     R1,#+0
   \       0xAE   0xA806             ADD      R0,SP,#+24
   \       0xB0   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xB4   0x4680             MOV      R8,R0
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD144             BNE.N    ??mbedtls_mpi_div_mpi_4
   1498              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T1, A->n + 2));
   \       0xBA   0x88F1             LDRH     R1,[R6, #+6]
   \       0xBC   0xA804             ADD      R0,SP,#+16
   \       0xBE   0x1C89             ADDS     R1,R1,#+2
   \       0xC0   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xC4   0x4680             MOV      R8,R0
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD13C             BNE.N    ??mbedtls_mpi_div_mpi_4
   1499          
   1500              k = mbedtls_mpi_bitlen(&Y) % biL;
   \       0xCA   0xA802             ADD      R0,SP,#+8
   \       0xCC   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0xD0   0xF000 0x001F      AND      R0,R0,#0x1F
   1501              if (k < biL - 1) {
   \       0xD4   0x281F             CMP      R0,#+31
   \       0xD6   0xD211             BCS.N    ??mbedtls_mpi_div_mpi_6
   1502                  k = biL - 1 - k;
   \       0xD8   0xF1C0 0x001F      RSB      R0,R0,#+31
   \       0xDC   0x900B             STR      R0,[SP, #+44]
   1503                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&X, k));
   \       0xDE   0x4601             MOV      R1,R0
   \       0xE0   0x4668             MOV      R0,SP
   \       0xE2   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \       0xE6   0x4680             MOV      R8,R0
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD12B             BNE.N    ??mbedtls_mpi_div_mpi_4
   1504                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, k));
   \       0xEC   0x990B             LDR      R1,[SP, #+44]
   \       0xEE   0xA802             ADD      R0,SP,#+8
   \       0xF0   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \       0xF4   0x4680             MOV      R8,R0
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xD124             BNE.N    ??mbedtls_mpi_div_mpi_4
   \       0xFA   0xE001             B.N      ??mbedtls_mpi_div_mpi_7
   1505              } else {
   1506                  k = 0;
   \                     ??mbedtls_mpi_div_mpi_6: (+1)
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0x900B             STR      R0,[SP, #+44]
   1507              }
   1508          
   1509              n = X.n - 1;
   \                     ??mbedtls_mpi_div_mpi_7: (+1)
   \      0x100   0xF8BD 0x4006      LDRH     R4,[SP, #+6]
   1510              t = Y.n - 1;
   \      0x104   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \      0x108   0x1E64             SUBS     R4,R4,#+1
   \      0x10A   0xF1A0 0x0901      SUB      R9,R0,#+1
   1511              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&Y, biL * (n - t)));
   \      0x10E   0xEBA4 0x0509      SUB      R5,R4,R9
   \      0x112   0x0169             LSLS     R1,R5,#+5
   \      0x114   0xA802             ADD      R0,SP,#+8
   \      0x116   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x11A   0x4680             MOV      R8,R0
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD111             BNE.N    ??mbedtls_mpi_div_mpi_4
   1512          
   1513              while (mbedtls_mpi_cmp_mpi(&X, &Y) >= 0) {
   \                     ??mbedtls_mpi_div_mpi_8: (+1)
   \      0x120   0xA902             ADD      R1,SP,#+8
   \      0x122   0x4668             MOV      R0,SP
   \      0x124   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD40C             BMI.N    ??mbedtls_mpi_div_mpi_9
   1514                  Z.p[n - t]++;
   \      0x12C   0x9806             LDR      R0,[SP, #+24]
   1515                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &Y));
   \      0x12E   0xAA02             ADD      R2,SP,#+8
   \      0x130   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \      0x134   0x1C49             ADDS     R1,R1,#+1
   \      0x136   0xF840 0x1025      STR      R1,[R0, R5, LSL #+2]
   \      0x13A   0x.... 0x....      BL       ?Subroutine13
   1516              }
   \                     ??CrossCallReturnLabel_36: (+1)
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xD0EE             BEQ.N    ??mbedtls_mpi_div_mpi_8
   \                     ??mbedtls_mpi_div_mpi_10: (+1)
   \      0x142   0x4680             MOV      R8,R0
   \                     ??mbedtls_mpi_div_mpi_4: (+1)
   \      0x144   0xE0D3             B.N      ??mbedtls_mpi_div_mpi_11
   1517              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&Y, biL * (n - t)));
   \                     ??mbedtls_mpi_div_mpi_9: (+1)
   \      0x146   0x0169             LSLS     R1,R5,#+5
   \      0x148   0xA802             ADD      R0,SP,#+8
   \      0x14A   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x14E   0x4680             MOV      R8,R0
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD1F7             BNE.N    ??mbedtls_mpi_div_mpi_4
   1518          
   1519              for (i = n; i > t; i--) {
   \      0x154   0xE03B             B.N      ??mbedtls_mpi_div_mpi_12
   1520                  if (X.p[i] >= Y.p[t]) {
   1521                      Z.p[i - t - 1] = ~(mbedtls_mpi_uint) 0u;
   1522                  } else {
   1523                      Z.p[i - t - 1] = mbedtls_int_div_int(X.p[i], X.p[i - 1],
   1524                                                           Y.p[t], NULL);
   1525                  }
   1526          
   1527                  T2.p[0] = (i < 2) ? 0 : X.p[i - 2];
   1528                  T2.p[1] = (i < 1) ? 0 : X.p[i - 1];
   1529                  T2.p[2] = X.p[i];
   1530          
   1531                  Z.p[i - t - 1]++;
   1532                  do {
   1533                      Z.p[i - t - 1]--;
   1534          
   1535                      MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&T1, 0));
   1536                      T1.p[0] = (t < 1) ? 0 : Y.p[t - 1];
   \                     ??mbedtls_mpi_div_mpi_13: (+1)
   \      0x156   0x9902             LDR      R1,[SP, #+8]
   \      0x158   0x1F08             SUBS     R0,R1,#+4
   \      0x15A   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \      0x15E   0xE088             B.N      ??mbedtls_mpi_div_mpi_14
   1537                      T1.p[1] = Y.p[t];
   1538                      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &T1, Z.p[i - t - 1]));
   1539                  } while (mbedtls_mpi_cmp_mpi(&T1, &T2) > 0);
   1540          
   1541                  MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(&T1, &Y, Z.p[i - t - 1]));
   \                     ??mbedtls_mpi_div_mpi_15: (+1)
   \      0x160   0x9806             LDR      R0,[SP, #+24]
   \      0x162   0x1F01             SUBS     R1,R0,#+4
   \      0x164   0xF851 0x202A      LDR      R2,[R1, R10, LSL #+2]
   \      0x168   0xA902             ADD      R1,SP,#+8
   \      0x16A   0xA804             ADD      R0,SP,#+16
   \      0x16C   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \      0x170   0x4680             MOV      R8,R0
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD1E6             BNE.N    ??mbedtls_mpi_div_mpi_4
   1542                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1,  biL * (i - t - 1)));
   \      0x176   0xF1AA 0x0501      SUB      R5,R10,#+1
   \      0x17A   0x0169             LSLS     R1,R5,#+5
   \      0x17C   0xA804             ADD      R0,SP,#+16
   \      0x17E   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x182   0x4680             MOV      R8,R0
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD1DD             BNE.N    ??mbedtls_mpi_div_mpi_4
   1543                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&X, &X, &T1));
   \      0x188   0xAA04             ADD      R2,SP,#+16
   \      0x18A   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_35: (+1)
   \      0x18E   0x4680             MOV      R8,R0
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD1D7             BNE.N    ??mbedtls_mpi_div_mpi_4
   1544          
   1545                  if (mbedtls_mpi_cmp_int(&X, 0) < 0) {
   \      0x194   0x2100             MOVS     R1,#+0
   \      0x196   0x4668             MOV      R0,SP
   \      0x198   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD515             BPL.N    ??CrossCallReturnLabel_47
   1546                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&T1, &Y));
   \      0x1A0   0xA902             ADD      R1,SP,#+8
   \      0x1A2   0xA804             ADD      R0,SP,#+16
   \      0x1A4   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x1A8   0x4680             MOV      R8,R0
   \      0x1AA   0x2800             CMP      R0,#+0
   \      0x1AC   0xD1CA             BNE.N    ??mbedtls_mpi_div_mpi_4
   1547                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&T1, biL * (i - t - 1)));
   \      0x1AE   0x0169             LSLS     R1,R5,#+5
   \      0x1B0   0xA804             ADD      R0,SP,#+16
   \      0x1B2   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x1B6   0x4680             MOV      R8,R0
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD1C3             BNE.N    ??mbedtls_mpi_div_mpi_4
   1548                      MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&X, &X, &T1));
   \      0x1BC   0xAA04             ADD      R2,SP,#+16
   \      0x1BE   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_39: (+1)
   \      0x1C2   0x4680             MOV      R8,R0
   \      0x1C4   0x2800             CMP      R0,#+0
   \      0x1C6   0xD1BD             BNE.N    ??mbedtls_mpi_div_mpi_4
   1549                      Z.p[i - t - 1]--;
   \      0x1C8   0x.... 0x....      BL       ?Subroutine17
   1550                  }
   \                     ??CrossCallReturnLabel_47: (+1)
   \      0x1CC   0x1E64             SUBS     R4,R4,#+1
   \                     ??mbedtls_mpi_div_mpi_12: (+1)
   \      0x1CE   0x45A1             CMP      R9,R4
   \      0x1D0   0xD268             BCS.N    ??mbedtls_mpi_div_mpi_16
   \      0x1D2   0x9802             LDR      R0,[SP, #+8]
   \      0x1D4   0xEBA4 0x0A09      SUB      R10,R4,R9
   \      0x1D8   0xF850 0x2029      LDR      R2,[R0, R9, LSL #+2]
   \      0x1DC   0x9800             LDR      R0,[SP, #+0]
   \      0x1DE   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \      0x1E2   0xF04F 0x30FF      MOV      R0,#+4294967295
   \      0x1E6   0x4291             CMP      R1,R2
   \      0x1E8   0xD211             BCS.N    ??mbedtls_mpi_div_mpi_17
   \      0x1EA   0xB182             CBZ.N    R2,??mbedtls_mpi_div_mpi_17
   \      0x1EC   0x9800             LDR      R0,[SP, #+0]
   \      0x1EE   0x2501             MOVS     R5,#+1
   \      0x1F0   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \      0x1F4   0xF1A0 0x0308      SUB      R3,R0,#+8
   \      0x1F8   0x6858             LDR      R0,[R3, #+4]
   \      0x1FA   0x2300             MOVS     R3,#+0
   \      0x1FC   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x200   0x42A9             CMP      R1,R5
   \      0x202   0xD304             BCC.N    ??mbedtls_mpi_div_mpi_17
   \      0x204   0xD801             BHI.N    ??mbedtls_mpi_div_mpi_18
   \      0x206   0x4540             CMP      R0,R8
   \      0x208   0xD301             BCC.N    ??mbedtls_mpi_div_mpi_17
   \                     ??mbedtls_mpi_div_mpi_18: (+1)
   \      0x20A   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??mbedtls_mpi_div_mpi_17: (+1)
   \      0x20E   0x9A06             LDR      R2,[SP, #+24]
   \      0x210   0x1F11             SUBS     R1,R2,#+4
   \      0x212   0xF841 0x002A      STR      R0,[R1, R10, LSL #+2]
   \      0x216   0x2C02             CMP      R4,#+2
   \      0x218   0xBF31             ITEEE    CC
   \      0x21A   0x2100             MOVCC    R1,#+0
   \      0x21C   0x9800             LDRCS    R0,[SP, #+0]
   \      0x21E   0xEB00 0x0184      ADDCS    R1,R0,R4, LSL #+2
   \      0x222   0xF851 0x1C08      LDRCS    R1,[R1, #-8]
   \      0x226   0x9808             LDR      R0,[SP, #+32]
   \      0x228   0x6001             STR      R1,[R0, #+0]
   \      0x22A   0xB90C             CBNZ.N   R4,??mbedtls_mpi_div_mpi_19
   \      0x22C   0x2100             MOVS     R1,#+0
   \      0x22E   0xE005             B.N      ??mbedtls_mpi_div_mpi_20
   \                     ??mbedtls_mpi_div_mpi_19: (+1)
   \      0x230   0x9800             LDR      R0,[SP, #+0]
   \      0x232   0xEB00 0x0184      ADD      R1,R0,R4, LSL #+2
   \      0x236   0xF1A1 0x0208      SUB      R2,R1,#+8
   \      0x23A   0x6851             LDR      R1,[R2, #+4]
   \                     ??mbedtls_mpi_div_mpi_20: (+1)
   \      0x23C   0x9808             LDR      R0,[SP, #+32]
   \      0x23E   0x46C8             MOV      R8,R9
   \      0x240   0x6041             STR      R1,[R0, #+4]
   \      0x242   0x9A00             LDR      R2,[SP, #+0]
   \      0x244   0x9808             LDR      R0,[SP, #+32]
   \      0x246   0xF852 0x1024      LDR      R1,[R2, R4, LSL #+2]
   \      0x24A   0x6081             STR      R1,[R0, #+8]
   \      0x24C   0x9906             LDR      R1,[SP, #+24]
   \      0x24E   0x1F09             SUBS     R1,R1,#+4
   \      0x250   0xF851 0x002A      LDR      R0,[R1, R10, LSL #+2]
   \      0x254   0x1C40             ADDS     R0,R0,#+1
   \      0x256   0xF841 0x002A      STR      R0,[R1, R10, LSL #+2]
   \                     ??mbedtls_mpi_div_mpi_21: (+1)
   \      0x25A   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_48: (+1)
   \      0x25E   0x2100             MOVS     R1,#+0
   \      0x260   0xA804             ADD      R0,SP,#+16
   \      0x262   0x.... 0x....      BL       mbedtls_mpi_lset
   \      0x266   0x2800             CMP      R0,#+0
   \      0x268   0xD113             BNE.N    ??mbedtls_mpi_div_mpi_22
   \      0x26A   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x26E   0xF47F 0xAF72      BNE.W    ??mbedtls_mpi_div_mpi_13
   \                     ??mbedtls_mpi_div_mpi_14: (+1)
   \      0x272   0x9904             LDR      R1,[SP, #+16]
   \      0x274   0x6008             STR      R0,[R1, #+0]
   \      0x276   0x9802             LDR      R0,[SP, #+8]
   \      0x278   0xF850 0x1028      LDR      R1,[R0, R8, LSL #+2]
   \      0x27C   0x9804             LDR      R0,[SP, #+16]
   \      0x27E   0x6041             STR      R1,[R0, #+4]
   \      0x280   0x9906             LDR      R1,[SP, #+24]
   \      0x282   0x1F08             SUBS     R0,R1,#+4
   \      0x284   0xF850 0x202A      LDR      R2,[R0, R10, LSL #+2]
   \      0x288   0xA904             ADD      R1,SP,#+16
   \      0x28A   0xA804             ADD      R0,SP,#+16
   \      0x28C   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \      0x290   0x2800             CMP      R0,#+0
   \                     ??mbedtls_mpi_div_mpi_22: (+1)
   \      0x292   0xF47F 0xAF56      BNE.W    ??mbedtls_mpi_div_mpi_10
   \      0x296   0xA908             ADD      R1,SP,#+32
   \      0x298   0xA804             ADD      R0,SP,#+16
   \      0x29A   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x29E   0x2800             CMP      R0,#+0
   \      0x2A0   0xDCDB             BGT.N    ??mbedtls_mpi_div_mpi_21
   \      0x2A2   0xE75D             B.N      ??mbedtls_mpi_div_mpi_15
   1551              }
   1552          
   1553              if (Q != NULL) {
   \                     ??mbedtls_mpi_div_mpi_16: (+1)
   \      0x2A4   0x980A             LDR      R0,[SP, #+40]
   \      0x2A6   0xB158             CBZ.N    R0,??mbedtls_mpi_div_mpi_23
   1554                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(Q, &Z));
   \      0x2A8   0xA906             ADD      R1,SP,#+24
   \      0x2AA   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x2AE   0x4680             MOV      R8,R0
   \      0x2B0   0xB9E8             CBNZ.N   R0,??mbedtls_mpi_div_mpi_11
   1555                  Q->s = A->s * B->s;
   \      0x2B2   0x88B0             LDRH     R0,[R6, #+4]
   \      0x2B4   0xF8BB 0x1004      LDRH     R1,[R11, #+4]
   \      0x2B8   0xFB10 0xF101      SMULBB   R1,R0,R1
   \      0x2BC   0x980A             LDR      R0,[SP, #+40]
   \      0x2BE   0x8081             STRH     R1,[R0, #+4]
   1556              }
   1557          
   1558              if (R != NULL) {
   \                     ??mbedtls_mpi_div_mpi_23: (+1)
   \      0x2C0   0xB1AF             CBZ.N    R7,??mbedtls_mpi_div_mpi_11
   1559                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&X, k));
   \      0x2C2   0x990B             LDR      R1,[SP, #+44]
   \      0x2C4   0x4668             MOV      R0,SP
   \      0x2C6   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x2CA   0x4680             MOV      R8,R0
   \      0x2CC   0xB978             CBNZ.N   R0,??mbedtls_mpi_div_mpi_11
   1560                  X.s = A->s;
   \      0x2CE   0x88B0             LDRH     R0,[R6, #+4]
   1561                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(R, &X));
   \      0x2D0   0x4669             MOV      R1,SP
   \      0x2D2   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \      0x2D6   0x4638             MOV      R0,R7
   \      0x2D8   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x2DC   0x4680             MOV      R8,R0
   \      0x2DE   0xB930             CBNZ.N   R0,??mbedtls_mpi_div_mpi_11
   1562          
   1563                  if (mbedtls_mpi_cmp_int(R, 0) == 0) {
   \      0x2E0   0x2100             MOVS     R1,#+0
   \      0x2E2   0x4638             MOV      R0,R7
   \      0x2E4   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x2E8   0xB908             CBNZ.N   R0,??mbedtls_mpi_div_mpi_11
   1564                      R->s = 1;
   \      0x2EA   0x2001             MOVS     R0,#+1
   \      0x2EC   0x80B8             STRH     R0,[R7, #+4]
   1565                  }
   1566              }
   1567          
   1568          cleanup:
   1569          
   1570              mbedtls_mpi_free(&X); mbedtls_mpi_free(&Y); mbedtls_mpi_free(&Z);
   \                     ??mbedtls_mpi_div_mpi_11: (+1)
   \      0x2EE   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_31: (+1)
   \      0x2F2   0xA802             ADD      R0,SP,#+8
   \      0x2F4   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x2F8   0xA806             ADD      R0,SP,#+24
   \      0x2FA   0x.... 0x....      BL       mbedtls_mpi_free
   1571              mbedtls_mpi_free(&T1);
   \      0x2FE   0xA804             ADD      R0,SP,#+16
   \      0x300   0x.... 0x....      BL       mbedtls_mpi_free
   1572              mbedtls_platform_zeroize(TP2, sizeof(TP2));
   \      0x304   0x210C             MOVS     R1,#+12
   \      0x306   0xA80C             ADD      R0,SP,#+48
   \      0x308   0x.... 0x....      BL       mbedtls_platform_zeroize
   1573          
   1574              return ret;
   \      0x30C   0x4640             MOV      R0,R8
   \                     ??mbedtls_mpi_div_mpi_1: (+1)
   \      0x30E   0xB00F             ADD      SP,SP,#+60
   \      0x310   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1575          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x9806             LDR      R0,[SP, #+24]
   \        0x2   0x1F00             SUBS     R0,R0,#+4
   \        0x4   0xF850 0x102A      LDR      R1,[R0, R10, LSL #+2]
   \        0x8   0x1E49             SUBS     R1,R1,#+1
   \        0xA   0xF840 0x102A      STR      R1,[R0, R10, LSL #+2]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      B.W      mbedtls_mpi_add_mpi

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      B.W      mbedtls_mpi_sub_mpi
   1576          
   1577          /*
   1578           * Division by int: A = Q * b + R
   1579           */

   \                                 In section .text, align 2, keep-with-next
   1580          int mbedtls_mpi_div_int(mbedtls_mpi *Q, mbedtls_mpi *R,
   1581                                  const mbedtls_mpi *A,
   1582                                  mbedtls_mpi_sint b)
   1583          {
   \                     mbedtls_mpi_div_int: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   1584              mbedtls_mpi B;
   1585              mbedtls_mpi_uint p[1];
   1586              MPI_VALIDATE_RET(A != NULL);
   1587          
   1588              p[0] = mpi_sint_abs(b);
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xBF52             ITEE     PL
   \        0x6   0x9300             STRPL    R3,[SP, #+0]
   \        0x8   0x425C             RSBMI    R4,R3,#+0
   \        0xA   0x9400             STRMI    R4,[SP, #+0]
   1589              B.s = TO_SIGN(b);
   \        0xC   0x0FDB             LSRS     R3,R3,#+31
   \        0xE   0x005B             LSLS     R3,R3,#+1
   \       0x10   0xF1C3 0x0301      RSB      R3,R3,#+1
   \       0x14   0xF8AD 0x3008      STRH     R3,[SP, #+8]
   1590              B.n = 1;
   \       0x18   0x2301             MOVS     R3,#+1
   \       0x1A   0xF8AD 0x300A      STRH     R3,[SP, #+10]
   1591              B.p = p;
   \       0x1E   0xF8CD 0xD004      STR      SP,[SP, #+4]
   1592          
   1593              return mbedtls_mpi_div_mpi(Q, R, A, &B);
   \       0x22   0xAB01             ADD      R3,SP,#+4
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_div_mpi
   \       0x28   0xB004             ADD      SP,SP,#+16
   \       0x2A   0xBD10             POP      {R4,PC}
   1594          }
   1595          
   1596          /*
   1597           * Modulo: R = A mod B
   1598           */

   \                                 In section .text, align 2, keep-with-next
   1599          int mbedtls_mpi_mod_mpi(mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B)
   1600          {
   \                     mbedtls_mpi_mod_mpi: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   1601              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1602              MPI_VALIDATE_RET(R != NULL);
   1603              MPI_VALIDATE_RET(A != NULL);
   1604              MPI_VALIDATE_RET(B != NULL);
   1605          
   1606              if (mbedtls_mpi_cmp_int(B, 0) < 0) {
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_18: (+1)
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD502             BPL.N    ??mbedtls_mpi_mod_mpi_0
   1607                  return MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \       0x10   0xF06F 0x0009      MVN      R0,#+9
   \       0x14   0xBD70             POP      {R4-R6,PC}
   1608              }
   1609          
   1610              MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(NULL, R, A, B));
   \                     ??mbedtls_mpi_mod_mpi_0: (+1)
   \       0x16   0x4633             MOV      R3,R6
   \       0x18   0x4622             MOV      R2,R4
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_div_mpi
   \       0x22   0x0004             MOVS     R4,R0
   \       0x24   0xD10C             BNE.N    ??mbedtls_mpi_mod_mpi_1
   1611          
   1612              while (mbedtls_mpi_cmp_int(R, 0) < 0) {
   \                     ??mbedtls_mpi_mod_mpi_2: (+1)
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD508             BPL.N    ??mbedtls_mpi_mod_mpi_3
   1613                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(R, R, B));
   \       0x32   0x4632             MOV      R2,R6
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x3C   0x0004             MOVS     R4,R0
   \       0x3E   0xD0F2             BEQ.N    ??mbedtls_mpi_mod_mpi_2
   1614              }
   1615          
   1616              while (mbedtls_mpi_cmp_mpi(R, B) >= 0) {
   1617                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(R, R, B));
   1618              }
   1619          
   1620          cleanup:
   1621          
   1622              return ret;
   \                     ??mbedtls_mpi_mod_mpi_1: (+1)
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_mpi_mod_mpi_3: (+1)
   \       0x44   0x4631             MOV      R1,R6
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD4F7             BMI.N    ??mbedtls_mpi_mod_mpi_1
   \       0x50   0x4632             MOV      R2,R6
   \       0x52   0x4629             MOV      R1,R5
   \       0x54   0x4628             MOV      R0,R5
   \       0x56   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x5A   0x0004             MOVS     R4,R0
   \       0x5C   0xD0F2             BEQ.N    ??mbedtls_mpi_mod_mpi_3
   \       0x5E   0xE7EF             B.N      ??mbedtls_mpi_mod_mpi_1
   1623          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x....             B.N      mbedtls_mpi_cmp_int
   1624          
   1625          /*
   1626           * Modulo: r = A mod b
   1627           */

   \                                 In section .text, align 2, keep-with-next
   1628          int mbedtls_mpi_mod_int(mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b)
   1629          {
   \                     mbedtls_mpi_mod_int: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x460B             MOV      R3,R1
   1630              size_t i;
   1631              mbedtls_mpi_uint x, y, z;
   1632              MPI_VALIDATE_RET(r != NULL);
   1633              MPI_VALIDATE_RET(A != NULL);
   1634          
   1635              if (b == 0) {
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD102             BNE.N    ??mbedtls_mpi_mod_int_0
   1636                  return MBEDTLS_ERR_MPI_DIVISION_BY_ZERO;
   \        0x8   0xF06F 0x000B      MVN      R0,#+11
   \        0xC   0xBDF0             POP      {R4-R7,PC}
   1637              }
   1638          
   1639              if (b < 0) {
   \                     ??mbedtls_mpi_mod_int_0: (+1)
   \        0xE   0xD502             BPL.N    ??mbedtls_mpi_mod_int_1
   1640                  return MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
   \       0x10   0xF06F 0x0009      MVN      R0,#+9
   \       0x14   0xBDF0             POP      {R4-R7,PC}
   1641              }
   1642          
   1643              /*
   1644               * handle trivial cases
   1645               */
   1646              if (b == 1 || A->n == 0) {
   \                     ??mbedtls_mpi_mod_int_1: (+1)
   \       0x16   0x2A01             CMP      R2,#+1
   \       0x18   0xBF1C             ITT      NE
   \       0x1A   0x88D9             LDRHNE   R1,[R3, #+6]
   \       0x1C   0x2900             CMPNE    R1,#+0
   \       0x1E   0xD102             BNE.N    ??mbedtls_mpi_mod_int_2
   1647                  *r = 0;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6001             STR      R1,[R0, #+0]
   1648                  return 0;
   \       0x24   0xE025             B.N      ??mbedtls_mpi_mod_int_3
   1649              }
   1650          
   1651              if (b == 2) {
   \                     ??mbedtls_mpi_mod_int_2: (+1)
   \       0x26   0x681D             LDR      R5,[R3, #+0]
   \       0x28   0x2A02             CMP      R2,#+2
   \       0x2A   0xD104             BNE.N    ??mbedtls_mpi_mod_int_4
   1652                  *r = A->p[0] & 1;
   \       0x2C   0x7829             LDRB     R1,[R5, #+0]
   \       0x2E   0xF001 0x0101      AND      R1,R1,#0x1
   \       0x32   0x6001             STR      R1,[R0, #+0]
   1653                  return 0;
   \       0x34   0xE01D             B.N      ??mbedtls_mpi_mod_int_3
   1654              }
   1655          
   1656              /*
   1657               * general case
   1658               */
   1659              for (i = A->n, y = 0; i > 0; i--) {
   \                     ??mbedtls_mpi_mod_int_4: (+1)
   \       0x36   0x2400             MOVS     R4,#+0
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xE012             B.N      ??mbedtls_mpi_mod_int_5
   1660                  x  = A->p[i - 1];
   \                     ??mbedtls_mpi_mod_int_6: (+1)
   \       0x3C   0xEB05 0x0681      ADD      R6,R5,R1, LSL #+2
   \       0x40   0xF856 0x6C04      LDR      R6,[R6, #-4]
   1661                  y  = (y << biH) | (x >> biH);
   \       0x44   0x0C37             LSRS     R7,R6,#+16
   \       0x46   0xEA47 0x4704      ORR      R7,R7,R4, LSL #+16
   1662                  z  = y / b;
   1663                  y -= z * b;
   1664          
   1665                  x <<= biH;
   1666                  y  = (y << biH) | (x >> biH);
   1667                  z  = y / b;
   1668                  y -= z * b;
   1669              }
   \       0x4A   0x1E49             SUBS     R1,R1,#+1
   \       0x4C   0xFBB7 0xF4F2      UDIV     R4,R7,R2
   \       0x50   0xFB02 0x7714      MLS      R7,R2,R4,R7
   \       0x54   0x4634             MOV      R4,R6
   \       0x56   0xF367 0x441F      BFI      R4,R7,#+16,#+16
   \       0x5A   0xFBB4 0xF6F2      UDIV     R6,R4,R2
   \       0x5E   0xFB02 0x4416      MLS      R4,R2,R6,R4
   \                     ??mbedtls_mpi_mod_int_5: (+1)
   \       0x62   0xD1EB             BNE.N    ??mbedtls_mpi_mod_int_6
   1670          
   1671              /*
   1672               * If A is negative, then the current y represents a negative value.
   1673               * Flipping it to the positive side.
   1674               */
   1675              if (A->s < 0 && y != 0) {
   \       0x64   0xF9B3 0x1004      LDRSH    R1,[R3, #+4]
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD501             BPL.N    ??mbedtls_mpi_mod_int_7
   \       0x6C   0xB104             CBZ.N    R4,??mbedtls_mpi_mod_int_7
   1676                  y = b - y;
   \       0x6E   0x1B14             SUBS     R4,R2,R4
   1677              }
   1678          
   1679              *r = y;
   \                     ??mbedtls_mpi_mod_int_7: (+1)
   \       0x70   0x6004             STR      R4,[R0, #+0]
   1680          
   1681              return 0;
   \                     ??mbedtls_mpi_mod_int_3: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xBDF0             POP      {R4-R7,PC}
   1682          }
   1683          
   1684          static void mpi_montg_init(mbedtls_mpi_uint *mm, const mbedtls_mpi *N)
   1685          {
   1686              *mm = mbedtls_mpi_core_montmul_init(N->p);
   1687          }
   1688          
   1689          /** Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
   1690           *
   1691           * \param[in,out]   A   One of the numbers to multiply.
   1692           *                      It must have at least as many limbs as N
   1693           *                      (A->n >= N->n), and any limbs beyond n are ignored.
   1694           *                      On successful completion, A contains the result of
   1695           *                      the multiplication A * B * R^-1 mod N where
   1696           *                      R = (2^ciL)^n.
   1697           * \param[in]       B   One of the numbers to multiply.
   1698           *                      It must be nonzero and must not have more limbs than N
   1699           *                      (B->n <= N->n).
   1700           * \param[in]       N   The modulus. \p N must be odd.
   1701           * \param           mm  The value calculated by `mpi_montg_init(&mm, N)`.
   1702           *                      This is -N^-1 mod 2^ciL.
   1703           * \param[in,out]   T   A bignum for temporary storage.
   1704           *                      It must be at least twice the limb size of N plus 1
   1705           *                      (T->n >= 2 * N->n + 1).
   1706           *                      Its initial content is unused and
   1707           *                      its final content is indeterminate.
   1708           *                      It does not get reallocated.
   1709           */

   \                                 In section .text, align 2, keep-with-next
   1710          static void mpi_montmul(mbedtls_mpi *A, const mbedtls_mpi *B,
   1711                                  const mbedtls_mpi *N, mbedtls_mpi_uint mm,
   1712                                  mbedtls_mpi *T)
   1713          {
   \                     mpi_montmul: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x9C08             LDR      R4,[SP, #+32]
   1714              mbedtls_mpi_core_montmul(A->p, A->p, B->p, B->n, N->p, N->n, mm, T->p);
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x6824             LDR      R4,[R4, #+0]
   \        0x8   0x9302             STR      R3,[SP, #+8]
   \        0xA   0x9403             STR      R4,[SP, #+12]
   \        0xC   0x88D5             LDRH     R5,[R2, #+6]
   \        0xE   0x9501             STR      R5,[SP, #+4]
   \       0x10   0x6816             LDR      R6,[R2, #+0]
   \       0x12   0x9600             STR      R6,[SP, #+0]
   \       0x14   0x88CB             LDRH     R3,[R1, #+6]
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0x4601             MOV      R1,R0
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_core_montmul
   1715          }
   \       0x1E   0xBD7F             POP      {R0-R6,PC}
   1716          
   1717          /*
   1718           * Montgomery reduction: A = A * R^-1 mod N
   1719           *
   1720           * See mpi_montmul() regarding constraints and guarantees on the parameters.
   1721           */

   \                                 In section .text, align 2, keep-with-next
   1722          static void mpi_montred(mbedtls_mpi *A, const mbedtls_mpi *N,
   1723                                  mbedtls_mpi_uint mm, mbedtls_mpi *T)
   1724          {
   \                     mpi_montred: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   1725              mbedtls_mpi_uint z = 1;
   1726              mbedtls_mpi U;
   1727              U.n = 1;
   1728              U.s = 1;
   1729              U.p = &z;
   1730          
   1731              mpi_montmul(A, &U, N, mm, T);
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x2601             MOVS     R6,#+1
   \        0x8   0xAD03             ADD      R5,SP,#+12
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0x9603             STR      R6,[SP, #+12]
   \        0xE   0xF8AD 0x600A      STRH     R6,[SP, #+10]
   \       0x12   0xF8AD 0x6008      STRH     R6,[SP, #+8]
   \       0x16   0x9501             STR      R5,[SP, #+4]
   \       0x18   0xA901             ADD      R1,SP,#+4
   \       0x1A   0x.... 0x....      BL       mpi_montmul
   1732          }
   \       0x1E   0xB005             ADD      SP,SP,#+20
   \       0x20   0xBD60             POP      {R5,R6,PC}
   1733          
   1734          /**
   1735           * Select an MPI from a table without leaking the index.
   1736           *
   1737           * This is functionally equivalent to mbedtls_mpi_copy(R, T[idx]) except it
   1738           * reads the entire table in order to avoid leaking the value of idx to an
   1739           * attacker able to observe memory access patterns.
   1740           *
   1741           * \param[out] R        Where to write the selected MPI.
   1742           * \param[in] T         The table to read from.
   1743           * \param[in] T_size    The number of elements in the table.
   1744           * \param[in] idx       The index of the element to select;
   1745           *                      this must satisfy 0 <= idx < T_size.
   1746           *
   1747           * \return \c 0 on success, or a negative error code.
   1748           */

   \                                 In section .text, align 2, keep-with-next
   1749          static int mpi_select(mbedtls_mpi *R, const mbedtls_mpi *T, size_t T_size, size_t idx)
   1750          {
   \                     mpi_select: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x4699             MOV      R9,R3
   1751              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \        0xC   0xF06F 0x006D      MVN      R0,#+109
   1752          
   1753              for (size_t i = 0; i < T_size; i++) {
   \       0x10   0x2700             MOVS     R7,#+0
   \       0x12   0xE000             B.N      ??mpi_select_0
   1754                  MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(R, &T[i],
   1755                                                               (unsigned char) mbedtls_ct_uint_eq(i, idx)));
   \                     ??mpi_select_1: (+1)
   \       0x14   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mpi_select_0: (+1)
   \       0x16   0x42AF             CMP      R7,R5
   \       0x18   0xD212             BCS.N    ??mpi_select_2
   \       0x1A   0x4638             MOV      R0,R7
   \       0x1C   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x20   0x4606             MOV      R6,R0
   \       0x22   0x4648             MOV      R0,R9
   \       0x24   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x28   0x4070             EORS     R0,R0,R6
   \       0x2A   0x.... 0x....      BL       mbedtls_ct_bool
   1756              }
   \       0x2E   0x43C0             MVNS     R0,R0
   \       0x30   0xB2C2             UXTB     R2,R0
   \       0x32   0xEB04 0x01C7      ADD      R1,R4,R7, LSL #+3
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD0E9             BEQ.N    ??mpi_select_1
   1757          cleanup:
   1758              return ret;
   \                     ??mpi_select_2: (+1)
   \       0x40   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1759          }
   1760          
   1761          /*
   1762           * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
   1763           */

   \                                 In section .text, align 2, keep-with-next
   1764          int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A,
   1765                                  const mbedtls_mpi *E, const mbedtls_mpi *N,
   1766                                  mbedtls_mpi *prec_RR)
   1767          {
   \                     mbedtls_mpi_exp_mod: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0x4688             MOV      R8,R1
   \        0x6   0x461E             MOV      R6,R3
   \        0x8   0xB096             SUB      SP,SP,#+88
   \        0xA   0x4614             MOV      R4,R2
   1768              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1769              size_t window_bitsize;
   1770              size_t i, j, nblimbs;
   1771              size_t bufsize, nbits;
   1772              size_t exponent_bits_in_window = 0;
   1773              mbedtls_mpi_uint ei, mm, state;
   1774              mbedtls_mpi RR, T, W[(size_t) 1 << MBEDTLS_MPI_WINDOW_SIZE], WW, Apos;
   1775              int neg;
   1776          
   1777              MPI_VALIDATE_RET(X != NULL);
   1778              MPI_VALIDATE_RET(A != NULL);
   1779              MPI_VALIDATE_RET(E != NULL);
   1780              MPI_VALIDATE_RET(N != NULL);
   1781          
   1782              if (mbedtls_mpi_cmp_int(N, 0) <= 0 || (N->p[0] & 1) == 0) {
   \        0xC   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x10   0xF04F 0x0A00      MOV      R10,#+0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xDD16             BLE.N    ??mbedtls_mpi_exp_mod_0
   \       0x18   0x6831             LDR      R1,[R6, #+0]
   \       0x1A   0x780A             LDRB     R2,[R1, #+0]
   \       0x1C   0x07D0             LSLS     R0,R2,#+31
   \       0x1E   0xD512             BPL.N    ??mbedtls_mpi_exp_mod_0
   \       0x20   0x940A             STR      R4,[SP, #+40]
   1783                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   1784              }
   1785          
   1786              if (mbedtls_mpi_cmp_int(E, 0) < 0) {
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD40B             BMI.N    ??mbedtls_mpi_exp_mod_0
   1787                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   1788              }
   1789          
   1790              if (mbedtls_mpi_bitlen(E) > MBEDTLS_MPI_MAX_BITS ||
   1791                  mbedtls_mpi_bitlen(N) > MBEDTLS_MPI_MAX_BITS) {
   \       0x2E   0x980A             LDR      R0,[SP, #+40]
   \       0x30   0xF240 0x1401      MOVW     R4,#+257
   \       0x34   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x38   0x42A0             CMP      R0,R4
   \       0x3A   0xD204             BCS.N    ??mbedtls_mpi_exp_mod_0
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x42   0x42A0             CMP      R0,R4
   \       0x44   0xD302             BCC.N    ??mbedtls_mpi_exp_mod_1
   1792                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_exp_mod_0: (+1)
   \       0x46   0xF06F 0x0003      MVN      R0,#+3
   \       0x4A   0xE1AA             B.N      ??mbedtls_mpi_exp_mod_2
   1793              }
   1794          
   1795              /*
   1796               * Init temps and window size
   1797               */
   1798              mpi_montg_init(&mm, N);
   \                     ??mbedtls_mpi_exp_mod_1: (+1)
   \       0x4C   0x6830             LDR      R0,[R6, #+0]
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_core_montmul_init
   \       0x52   0x9009             STR      R0,[SP, #+36]
   1799              mbedtls_mpi_init(&RR); mbedtls_mpi_init(&T);
   \       0x54   0xA805             ADD      R0,SP,#+20
   \       0x56   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x5A   0xA801             ADD      R0,SP,#+4
   \       0x5C   0x.... 0x....      BL       mbedtls_mpi_init
   1800              mbedtls_mpi_init(&Apos);
   \       0x60   0xA807             ADD      R0,SP,#+28
   \       0x62   0x.... 0x....      BL       mbedtls_mpi_init
   1801              mbedtls_mpi_init(&WW);
   \       0x66   0xA803             ADD      R0,SP,#+12
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_init
   1802              memset(W, 0, sizeof(W));
   \       0x6C   0x2120             MOVS     R1,#+32
   \       0x6E   0xA80B             ADD      R0,SP,#+44
   \       0x70   0x.... 0x....      BL       __aeabi_memclr4
   1803          
   1804              i = mbedtls_mpi_bitlen(E);
   \       0x74   0x980A             LDR      R0,[SP, #+40]
   \       0x76   0x.... 0x....      BL       mbedtls_mpi_bitlen
   1805          
   1806              window_bitsize = (i > 671) ? 6 : (i > 239) ? 5 :
   1807                               (i >  79) ? 4 : (i >  23) ? 3 : 1;
   \       0x7A   0xF5B0 0x7F28      CMP      R0,#+672
   \       0x7E   0xBF38             IT       CC
   \       0x80   0x28F0             CMPCC    R0,#+240
   \       0x82   0xD205             BCS.N    ??mbedtls_mpi_exp_mod_3
   \       0x84   0x2850             CMP      R0,#+80
   \       0x86   0xBF3C             ITT      CC
   \       0x88   0x2818             CMPCC    R0,#+24
   \       0x8A   0xF04F 0x0901      MOVCC    R9,#+1
   \       0x8E   0xD301             BCC.N    ??mbedtls_mpi_exp_mod_4
   1808          
   1809          #if (MBEDTLS_MPI_WINDOW_SIZE < 6)
   1810              if (window_bitsize > MBEDTLS_MPI_WINDOW_SIZE) {
   1811                  window_bitsize = MBEDTLS_MPI_WINDOW_SIZE;
   \                     ??mbedtls_mpi_exp_mod_3: (+1)
   \       0x90   0xF04F 0x0902      MOV      R9,#+2
   1812              }
   1813          #endif
   1814          
   1815              const size_t w_table_used_size = (size_t) 1 << window_bitsize;
   1816          
   1817              /*
   1818               * This function is not constant-trace: its memory accesses depend on the
   1819               * exponent value. To defend against timing attacks, callers (such as RSA
   1820               * and DHM) should use exponent blinding. However this is not enough if the
   1821               * adversary can find the exponent in a single trace, so this function
   1822               * takes extra precautions against adversaries who can observe memory
   1823               * access patterns.
   1824               *
   1825               * This function performs a series of multiplications by table elements and
   1826               * squarings, and we want the prevent the adversary from finding out which
   1827               * table element was used, and from distinguishing between multiplications
   1828               * and squarings. Firstly, when multiplying by an element of the window
   1829               * W[i], we do a constant-trace table lookup to obfuscate i. This leaves
   1830               * squarings as having a different memory access patterns from other
   1831               * multiplications. So secondly, we put the accumulator in the table as
   1832               * well, and also do a constant-trace table lookup to multiply by the
   1833               * accumulator which is W[x_index].
   1834               *
   1835               * This way, all multiplications take the form of a lookup-and-multiply.
   1836               * The number of lookup-and-multiply operations inside each iteration of
   1837               * the main loop still depends on the bits of the exponent, but since the
   1838               * other operations in the loop don't have an easily recognizable memory
   1839               * trace, an adversary is unlikely to be able to observe the exact
   1840               * patterns.
   1841               *
   1842               * An adversary may still be able to recover the exponent if they can
   1843               * observe both memory accesses and branches. However, branch prediction
   1844               * exploitation typically requires many traces of execution over the same
   1845               * data, which is defeated by randomized blinding.
   1846               */
   1847              const size_t x_index = 0;
   1848              mbedtls_mpi_init(&W[x_index]);
   \                     ??mbedtls_mpi_exp_mod_4: (+1)
   \       0x94   0xA80B             ADD      R0,SP,#+44
   \       0x96   0x.... 0x....      BL       mbedtls_mpi_init
   1849          
   1850              j = N->n + 1;
   \       0x9A   0x88F5             LDRH     R5,[R6, #+6]
   1851              /* All W[i] including the accumulator must have at least N->n limbs for
   1852               * the mpi_montmul() and mpi_montred() calls later. Here we ensure that
   1853               * W[1] and the accumulator W[x_index] are large enough. later we'll grow
   1854               * other W[i] to the same length. They must not be shrunk midway through
   1855               * this function!
   1856               */
   1857              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[x_index], j));
   \       0x9C   0xA80B             ADD      R0,SP,#+44
   \       0x9E   0x2401             MOVS     R4,#+1
   \       0xA0   0x1C6D             ADDS     R5,R5,#+1
   \       0xA2   0x4629             MOV      R1,R5
   \       0xA4   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xA8   0xFA04 0xF409      LSL      R4,R4,R9
   \       0xAC   0x4683             MOV      R11,R0
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD169             BNE.N    ??mbedtls_mpi_exp_mod_5
   1858              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1],  j));
   \       0xB2   0x4629             MOV      R1,R5
   \       0xB4   0xA80D             ADD      R0,SP,#+52
   \       0xB6   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xBA   0x4683             MOV      R11,R0
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD162             BNE.N    ??mbedtls_mpi_exp_mod_5
   1859              MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&T, j * 2));
   \       0xC0   0x0069             LSLS     R1,R5,#+1
   \       0xC2   0xA801             ADD      R0,SP,#+4
   \       0xC4   0x.... 0x....      BL       mbedtls_mpi_grow
   \       0xC8   0x4683             MOV      R11,R0
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD15B             BNE.N    ??mbedtls_mpi_exp_mod_5
   1860          
   1861              /*
   1862               * Compensate for negative A (and correct at the end)
   1863               */
   1864              neg = (A->s == -1);
   \       0xCE   0xF9B8 0x1004      LDRSH    R1,[R8, #+4]
   \       0xD2   0xF111 0x0F01      CMN      R1,#+1
   \       0xD6   0xD131             BNE.N    ??mbedtls_mpi_exp_mod_6
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0x9014             STR      R0,[SP, #+80]
   1865              if (neg) {
   1866                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Apos, A));
   \       0xDC   0x4641             MOV      R1,R8
   \       0xDE   0xA807             ADD      R0,SP,#+28
   \       0xE0   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0xE4   0x4683             MOV      R11,R0
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD14D             BNE.N    ??mbedtls_mpi_exp_mod_5
   1867                  Apos.s = 1;
   \       0xEA   0x2001             MOVS     R0,#+1
   \       0xEC   0xF8AD 0x0020      STRH     R0,[SP, #+32]
   1868                  A = &Apos;
   \       0xF0   0xF10D 0x081C      ADD      R8,SP,#+28
   1869              }
   1870          
   1871              /*
   1872               * If 1st call, pre-compute R^2 mod N
   1873               */
   1874              if (prec_RR == NULL || prec_RR->p == NULL) {
   \                     ??mbedtls_mpi_exp_mod_7: (+1)
   \       0xF4   0x9820             LDR      R0,[SP, #+128]
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xBF1E             ITTT     NE
   \       0xFA   0x4601             MOVNE    R1,R0
   \       0xFC   0x6808             LDRNE    R0,[R1, #+0]
   \       0xFE   0x2800             CMPNE    R0,#+0
   \      0x100   0xD11F             BNE.N    ??mbedtls_mpi_exp_mod_8
   1875                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&RR, 1));
   \      0x102   0x2101             MOVS     R1,#+1
   \      0x104   0xA805             ADD      R0,SP,#+20
   \      0x106   0x.... 0x....      BL       mbedtls_mpi_lset
   \      0x10A   0x4683             MOV      R11,R0
   \      0x10C   0x2800             CMP      R0,#+0
   \      0x10E   0xD13A             BNE.N    ??mbedtls_mpi_exp_mod_5
   1876                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&RR, N->n * 2 * biL));
   \      0x110   0x88F1             LDRH     R1,[R6, #+6]
   \      0x112   0xA805             ADD      R0,SP,#+20
   \      0x114   0x0189             LSLS     R1,R1,#+6
   \      0x116   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \      0x11A   0x4683             MOV      R11,R0
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD132             BNE.N    ??mbedtls_mpi_exp_mod_5
   1877                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&RR, &RR, N));
   \      0x120   0x4632             MOV      R2,R6
   \      0x122   0xA905             ADD      R1,SP,#+20
   \      0x124   0xA805             ADD      R0,SP,#+20
   \      0x126   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \      0x12A   0x4683             MOV      R11,R0
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD12A             BNE.N    ??mbedtls_mpi_exp_mod_5
   1878          
   1879                  if (prec_RR != NULL) {
   \      0x130   0x9820             LDR      R0,[SP, #+128]
   \      0x132   0xB158             CBZ.N    R0,??mbedtls_mpi_exp_mod_9
   1880                      memcpy(prec_RR, &RR, sizeof(mbedtls_mpi));
   \      0x134   0xAA05             ADD      R2,SP,#+20
   \      0x136   0xE9D2 0x3100      LDRD     R3,R1,[R2, #+0]
   \      0x13A   0xE005             B.N      ??mbedtls_mpi_exp_mod_10
   1881                  }
   1882              } else {
   \                     ??mbedtls_mpi_exp_mod_6: (+1)
   \      0x13C   0xF8CD 0xA050      STR      R10,[SP, #+80]
   \      0x140   0xE7D8             B.N      ??mbedtls_mpi_exp_mod_7
   1883                  memcpy(&RR, prec_RR, sizeof(mbedtls_mpi));
   \                     ??mbedtls_mpi_exp_mod_8: (+1)
   \      0x142   0xA805             ADD      R0,SP,#+20
   \      0x144   0xE9D1 0x3100      LDRD     R3,R1,[R1, #+0]
   \                     ??mbedtls_mpi_exp_mod_10: (+1)
   \      0x148   0xE9C0 0x3100      STRD     R3,R1,[R0, #+0]
   1884              }
   1885          
   1886              /*
   1887               * W[1] = A * R^2 * R^-1 mod N = A * R mod N
   1888               */
   1889              if (mbedtls_mpi_cmp_mpi(A, N) >= 0) {
   \                     ??mbedtls_mpi_exp_mod_9: (+1)
   \      0x14C   0x4631             MOV      R1,R6
   \      0x14E   0x4640             MOV      R0,R8
   \      0x150   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD410             BMI.N    ??mbedtls_mpi_exp_mod_11
   1890                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&W[1], A, N));
   \      0x158   0x4632             MOV      R2,R6
   \      0x15A   0x4641             MOV      R1,R8
   \      0x15C   0xA80D             ADD      R0,SP,#+52
   \      0x15E   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \      0x162   0x4683             MOV      R11,R0
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD10E             BNE.N    ??mbedtls_mpi_exp_mod_5
   1891                  /* This should be a no-op because W[1] is already that large before
   1892                   * mbedtls_mpi_mod_mpi(), but it's necessary to avoid an overflow
   1893                   * in mpi_montmul() below, so let's make sure. */
   1894                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[1], N->n + 1));
   \      0x168   0x88F1             LDRH     R1,[R6, #+6]
   \      0x16A   0xA80D             ADD      R0,SP,#+52
   \      0x16C   0x1C49             ADDS     R1,R1,#+1
   \      0x16E   0x.... 0x....      BL       mbedtls_mpi_grow
   \      0x172   0x4683             MOV      R11,R0
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD106             BNE.N    ??mbedtls_mpi_exp_mod_5
   \      0x178   0xE007             B.N      ??mbedtls_mpi_exp_mod_12
   1895              } else {
   1896                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[1], A));
   \                     ??mbedtls_mpi_exp_mod_11: (+1)
   \      0x17A   0x4641             MOV      R1,R8
   \      0x17C   0xA80D             ADD      R0,SP,#+52
   \      0x17E   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x182   0x4683             MOV      R11,R0
   \      0x184   0x2800             CMP      R0,#+0
   \                     ??mbedtls_mpi_exp_mod_5: (+1)
   \      0x186   0xF040 0x80EB      BNE.W    ??mbedtls_mpi_exp_mod_13
   1897              }
   1898          
   1899              /* Note that this is safe because W[1] always has at least N->n limbs
   1900               * (it grew above and was preserved by mbedtls_mpi_copy()). */
   1901              mpi_montmul(&W[1], &RR, N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_12: (+1)
   \      0x18A   0xA801             ADD      R0,SP,#+4
   \      0x18C   0x9B09             LDR      R3,[SP, #+36]
   \      0x18E   0x9000             STR      R0,[SP, #+0]
   \      0x190   0x4632             MOV      R2,R6
   \      0x192   0xA905             ADD      R1,SP,#+20
   \      0x194   0xA80D             ADD      R0,SP,#+52
   \      0x196   0x.... 0x....      BL       mpi_montmul
   1902          
   1903              /*
   1904               * W[x_index] = R^2 * R^-1 mod N = R mod N
   1905               */
   1906              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[x_index], &RR));
   \      0x19A   0xA905             ADD      R1,SP,#+20
   \      0x19C   0xA80B             ADD      R0,SP,#+44
   \      0x19E   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x1A2   0x4683             MOV      R11,R0
   \      0x1A4   0x2800             CMP      R0,#+0
   \      0x1A6   0xD1EE             BNE.N    ??mbedtls_mpi_exp_mod_5
   1907              mpi_montred(&W[x_index], N, mm, &T);
   \      0x1A8   0x9A09             LDR      R2,[SP, #+36]
   \      0x1AA   0xAB01             ADD      R3,SP,#+4
   \      0x1AC   0x4631             MOV      R1,R6
   \      0x1AE   0xA80B             ADD      R0,SP,#+44
   \      0x1B0   0x.... 0x....      BL       mpi_montred
   1908          
   1909          
   1910              if (window_bitsize > 1) {
   \      0x1B4   0xF1B9 0x0F01      CMP      R9,#+1
   \      0x1B8   0xD946             BLS.N    ??mbedtls_mpi_exp_mod_14
   1911                  /*
   1912                   * W[i] = W[1] ^ i
   1913                   *
   1914                   * The first bit of the sliding window is always 1 and therefore we
   1915                   * only need to store the second half of the table.
   1916                   *
   1917                   * (There are two special elements in the table: W[0] for the
   1918                   * accumulator/result and W[1] for A in Montgomery form. Both of these
   1919                   * are already set at this point.)
   1920                   */
   1921                  j = w_table_used_size / 2;
   \      0x1BA   0x0860             LSRS     R0,R4,#+1
   1922          
   1923                  MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[j], N->n + 1));
   \      0x1BC   0xA90B             ADD      R1,SP,#+44
   \      0x1BE   0x9013             STR      R0,[SP, #+76]
   \      0x1C0   0xEB01 0x05C0      ADD      R5,R1,R0, LSL #+3
   \      0x1C4   0x88F1             LDRH     R1,[R6, #+6]
   \      0x1C6   0x4628             MOV      R0,R5
   \      0x1C8   0x1C49             ADDS     R1,R1,#+1
   \      0x1CA   0x.... 0x....      BL       mbedtls_mpi_grow
   \      0x1CE   0x4683             MOV      R11,R0
   \      0x1D0   0x2800             CMP      R0,#+0
   \      0x1D2   0xD16C             BNE.N    ??mbedtls_mpi_exp_mod_15
   1924                  MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[j], &W[1]));
   \      0x1D4   0xA90D             ADD      R1,SP,#+52
   \      0x1D6   0x4628             MOV      R0,R5
   \      0x1D8   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x1DC   0x4683             MOV      R11,R0
   \      0x1DE   0x2800             CMP      R0,#+0
   \      0x1E0   0xD165             BNE.N    ??mbedtls_mpi_exp_mod_15
   1925          
   1926                  for (i = 0; i < window_bitsize - 1; i++) {
   \      0x1E2   0x2700             MOVS     R7,#+0
   \      0x1E4   0xF8DD 0x8024      LDR      R8,[SP, #+36]
   \      0x1E8   0xE008             B.N      ??mbedtls_mpi_exp_mod_16
   1927                      mpi_montmul(&W[j], &W[j], N, mm, &T);
   \                     ??mbedtls_mpi_exp_mod_17: (+1)
   \      0x1EA   0xA801             ADD      R0,SP,#+4
   \      0x1EC   0x9000             STR      R0,[SP, #+0]
   \      0x1EE   0x4643             MOV      R3,R8
   \      0x1F0   0x4632             MOV      R2,R6
   \      0x1F2   0x4629             MOV      R1,R5
   \      0x1F4   0x4628             MOV      R0,R5
   \      0x1F6   0x.... 0x....      BL       mpi_montmul
   1928                  }
   \      0x1FA   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_exp_mod_16: (+1)
   \      0x1FC   0xF1A9 0x0001      SUB      R0,R9,#+1
   \      0x200   0x4287             CMP      R7,R0
   \      0x202   0xD3F2             BCC.N    ??mbedtls_mpi_exp_mod_17
   1929          
   1930                  /*
   1931                   * W[i] = W[i - 1] * W[1]
   1932                   */
   1933                  for (i = j + 1; i < w_table_used_size; i++) {
   \      0x204   0x9813             LDR      R0,[SP, #+76]
   \      0x206   0x4645             MOV      R5,R8
   \      0x208   0x1C40             ADDS     R0,R0,#+1
   \      0x20A   0x4680             MOV      R8,R0
   \      0x20C   0xE019             B.N      ??mbedtls_mpi_exp_mod_18
   1934                      MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&W[i], N->n + 1));
   \                     ??mbedtls_mpi_exp_mod_19: (+1)
   \      0x20E   0x88F1             LDRH     R1,[R6, #+6]
   \      0x210   0xA80B             ADD      R0,SP,#+44
   \      0x212   0xEB00 0x07C8      ADD      R7,R0,R8, LSL #+3
   \      0x216   0x1C49             ADDS     R1,R1,#+1
   \      0x218   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \      0x21C   0x2800             CMP      R0,#+0
   \      0x21E   0xD133             BNE.N    ??mbedtls_mpi_exp_mod_20
   1935                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&W[i], &W[i - 1]));
   \      0x220   0xF1A7 0x0108      SUB      R1,R7,#+8
   \      0x224   0x4638             MOV      R0,R7
   \      0x226   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x22A   0x2800             CMP      R0,#+0
   \      0x22C   0xD12C             BNE.N    ??mbedtls_mpi_exp_mod_20
   1936          
   1937                      mpi_montmul(&W[i], &W[1], N, mm, &T);
   \      0x22E   0xA801             ADD      R0,SP,#+4
   \      0x230   0x9000             STR      R0,[SP, #+0]
   \      0x232   0x462B             MOV      R3,R5
   \      0x234   0x4632             MOV      R2,R6
   \      0x236   0xA90D             ADD      R1,SP,#+52
   \      0x238   0x4638             MOV      R0,R7
   \      0x23A   0x.... 0x....      BL       mpi_montmul
   1938                  }
   \      0x23E   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??mbedtls_mpi_exp_mod_18: (+1)
   \      0x242   0x45A0             CMP      R8,R4
   \      0x244   0xD3E3             BCC.N    ??mbedtls_mpi_exp_mod_19
   \      0x246   0x9509             STR      R5,[SP, #+36]
   1939              }
   1940          
   1941              nblimbs = E->n;
   \                     ??mbedtls_mpi_exp_mod_14: (+1)
   \      0x248   0x990A             LDR      R1,[SP, #+40]
   1942              bufsize = 0;
   1943              nbits   = 0;
   \      0x24A   0x46D0             MOV      R8,R10
   1944              state   = 0;
   \      0x24C   0x2700             MOVS     R7,#+0
   \      0x24E   0x88C8             LDRH     R0,[R1, #+6]
   \      0x250   0x9013             STR      R0,[SP, #+76]
   1945          
   1946              while (1) {
   1947                  if (bufsize == 0) {
   1948                      if (nblimbs == 0) {
   \                     ??mbedtls_mpi_exp_mod_21: (+1)
   \      0x252   0x9813             LDR      R0,[SP, #+76]
   \      0x254   0xB118             CBZ.N    R0,??mbedtls_mpi_exp_mod_22
   1949                          break;
   1950                      }
   1951          
   1952                      nblimbs--;
   \      0x256   0x1E40             SUBS     R0,R0,#+1
   \      0x258   0x9013             STR      R0,[SP, #+76]
   1953          
   1954                      bufsize = sizeof(mbedtls_mpi_uint) << 3;
   \      0x25A   0x2520             MOVS     R5,#+32
   \      0x25C   0xE032             B.N      ??mbedtls_mpi_exp_mod_23
   1955                  }
   1956          
   1957                  bufsize--;
   1958          
   1959                  ei = (E->p[nblimbs] >> bufsize) & 1;
   1960          
   1961                  /*
   1962                   * skip leading 0s
   1963                   */
   1964                  if (ei == 0 && state == 0) {
   1965                      continue;
   1966                  }
   1967          
   1968                  if (ei == 0 && state == 1) {
   1969                      /*
   1970                       * out of window, square W[x_index]
   1971                       */
   1972                      MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   1973                      mpi_montmul(&W[x_index], &WW, N, mm, &T);
   1974                      continue;
   1975                  }
   1976          
   1977                  /*
   1978                   * add ei to current window
   1979                   */
   1980                  state = 2;
   1981          
   1982                  nbits++;
   1983                  exponent_bits_in_window |= (ei << (window_bitsize - nbits));
   1984          
   1985                  if (nbits == window_bitsize) {
   1986                      /*
   1987                       * W[x_index] = W[x_index]^window_bitsize R^-1 mod N
   1988                       */
   1989                      for (i = 0; i < window_bitsize; i++) {
   1990                          MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   1991                                                     x_index));
   1992                          mpi_montmul(&W[x_index], &WW, N, mm, &T);
   1993                      }
   1994          
   1995                      /*
   1996                       * W[x_index] = W[x_index] * W[exponent_bits_in_window] R^-1 mod N
   1997                       */
   1998                      MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size,
   1999                                                 exponent_bits_in_window));
   2000                      mpi_montmul(&W[x_index], &WW, N, mm, &T);
   2001          
   2002                      state--;
   2003                      nbits = 0;
   2004                      exponent_bits_in_window = 0;
   2005                  }
   2006              }
   2007          
   2008              /*
   2009               * process the remaining bits
   2010               */
   2011              for (i = 0; i < nbits; i++) {
   \                     ??mbedtls_mpi_exp_mod_22: (+1)
   \      0x25E   0x4635             MOV      R5,R6
   \      0x260   0x2700             MOVS     R7,#+0
   \      0x262   0x9E09             LDR      R6,[SP, #+36]
   \      0x264   0xE059             B.N      ??mbedtls_mpi_exp_mod_24
   \                     ??mbedtls_mpi_exp_mod_25: (+1)
   \      0x266   0xF108 0x0801      ADD      R8,R8,#+1
   \      0x26A   0xEBA9 0x0108      SUB      R1,R9,R8
   \      0x26E   0x2702             MOVS     R7,#+2
   \      0x270   0x4088             LSLS     R0,R0,R1
   \      0x272   0xEA40 0x0A0A      ORR      R10,R0,R10
   \      0x276   0x45C8             CMP      R8,R9
   \      0x278   0xD122             BNE.N    ??mbedtls_mpi_exp_mod_26
   \      0x27A   0x46B0             MOV      R8,R6
   \      0x27C   0x9F09             LDR      R7,[SP, #+36]
   \      0x27E   0x2600             MOVS     R6,#+0
   \      0x280   0xE00C             B.N      ??mbedtls_mpi_exp_mod_27
   \                     ??mbedtls_mpi_exp_mod_28: (+1)
   \      0x282   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_46: (+1)
   \      0x286   0x2800             CMP      R0,#+0
   \                     ??mbedtls_mpi_exp_mod_20: (+1)
   \      0x288   0xD169             BNE.N    ??mbedtls_mpi_exp_mod_29
   \      0x28A   0xA801             ADD      R0,SP,#+4
   \      0x28C   0x9000             STR      R0,[SP, #+0]
   \      0x28E   0x463B             MOV      R3,R7
   \      0x290   0x4642             MOV      R2,R8
   \      0x292   0xA903             ADD      R1,SP,#+12
   \      0x294   0xA80B             ADD      R0,SP,#+44
   \      0x296   0x.... 0x....      BL       mpi_montmul
   \      0x29A   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_mpi_exp_mod_27: (+1)
   \      0x29C   0x454E             CMP      R6,R9
   \      0x29E   0xD3F0             BCC.N    ??mbedtls_mpi_exp_mod_28
   \      0x2A0   0x9709             STR      R7,[SP, #+36]
   \      0x2A2   0x4653             MOV      R3,R10
   \      0x2A4   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_43: (+1)
   \      0x2A8   0x4646             MOV      R6,R8
   \      0x2AA   0x4683             MOV      R11,R0
   \      0x2AC   0x2800             CMP      R0,#+0
   \                     ??mbedtls_mpi_exp_mod_15: (+1)
   \      0x2AE   0xD157             BNE.N    ??mbedtls_mpi_exp_mod_13
   \      0x2B0   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_23: (+1)
   \      0x2B4   0xF04F 0x0800      MOV      R8,#+0
   \      0x2B8   0x.... 0x....      BL       mpi_montmul
   \      0x2BC   0x2701             MOVS     R7,#+1
   \      0x2BE   0x46C2             MOV      R10,R8
   \                     ??mbedtls_mpi_exp_mod_26: (+1)
   \      0x2C0   0x2D00             CMP      R5,#+0
   \      0x2C2   0xD0C6             BEQ.N    ??mbedtls_mpi_exp_mod_21
   \                     ??mbedtls_mpi_exp_mod_23: (+1)
   \      0x2C4   0x9A0A             LDR      R2,[SP, #+40]
   \      0x2C6   0x9913             LDR      R1,[SP, #+76]
   \      0x2C8   0x1E6D             SUBS     R5,R5,#+1
   \      0x2CA   0x6810             LDR      R0,[R2, #+0]
   \      0x2CC   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0x2D0   0x40E8             LSRS     R0,R0,R5
   \      0x2D2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x2D6   0xD1C6             BNE.N    ??mbedtls_mpi_exp_mod_25
   \      0x2D8   0x2F00             CMP      R7,#+0
   \      0x2DA   0xD0F1             BEQ.N    ??mbedtls_mpi_exp_mod_26
   \      0x2DC   0x2F01             CMP      R7,#+1
   \      0x2DE   0xD1C2             BNE.N    ??mbedtls_mpi_exp_mod_25
   \      0x2E0   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_45: (+1)
   \      0x2E4   0x4683             MOV      R11,R0
   \      0x2E6   0x2800             CMP      R0,#+0
   \      0x2E8   0xD13A             BNE.N    ??mbedtls_mpi_exp_mod_13
   \      0x2EA   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_24: (+1)
   \      0x2EE   0x.... 0x....      BL       mpi_montmul
   \      0x2F2   0xE7E5             B.N      ??mbedtls_mpi_exp_mod_26
   2012                  MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, x_index));
   \                     ??mbedtls_mpi_exp_mod_30: (+1)
   \      0x2F4   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_44: (+1)
   \      0x2F8   0x2800             CMP      R0,#+0
   \      0x2FA   0xD130             BNE.N    ??mbedtls_mpi_exp_mod_29
   2013                  mpi_montmul(&W[x_index], &WW, N, mm, &T);
   \      0x2FC   0x.... 0x....      BL       ?Subroutine2
   2014          
   2015                  exponent_bits_in_window <<= 1;
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x300   0xEA4F 0x0A4A      LSL      R10,R10,#+1
   2016          
   2017                  if ((exponent_bits_in_window & ((size_t) 1 << window_bitsize)) != 0) {
   \      0x304   0xFA2A 0xF109      LSR      R1,R10,R9
   \      0x308   0x07C8             LSLS     R0,R1,#+31
   \      0x30A   0xD505             BPL.N    ??CrossCallReturnLabel_2
   2018                      MBEDTLS_MPI_CHK(mpi_select(&WW, W, w_table_used_size, 1));
   \      0x30C   0x2301             MOVS     R3,#+1
   \      0x30E   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_42: (+1)
   \      0x312   0xBB20             CBNZ.N   R0,??mbedtls_mpi_exp_mod_29
   2019                      mpi_montmul(&W[x_index], &WW, N, mm, &T);
   \      0x314   0x.... 0x....      BL       ?Subroutine2
   2020                  }
   2021              }
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x318   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_exp_mod_24: (+1)
   \      0x31A   0x4547             CMP      R7,R8
   \      0x31C   0xD3EA             BCC.N    ??mbedtls_mpi_exp_mod_30
   \      0x31E   0x4632             MOV      R2,R6
   2022          
   2023              /*
   2024               * W[x_index] = A^E * R * R^-1 mod N = A^E mod N
   2025               */
   2026              mpi_montred(&W[x_index], N, mm, &T);
   \      0x320   0xAB01             ADD      R3,SP,#+4
   \      0x322   0x4629             MOV      R1,R5
   \      0x324   0xA80B             ADD      R0,SP,#+44
   \      0x326   0x.... 0x....      BL       mpi_montred
   2027          
   2028              if (neg && E->n != 0 && (E->p[0] & 1) != 0) {
   \      0x32A   0x9814             LDR      R0,[SP, #+80]
   \      0x32C   0x2800             CMP      R0,#+0
   \      0x32E   0xBF1E             ITTT     NE
   \      0x330   0x990A             LDRNE    R1,[SP, #+40]
   \      0x332   0x88C8             LDRHNE   R0,[R1, #+6]
   \      0x334   0x2800             CMPNE    R0,#+0
   \      0x336   0xD00E             BEQ.N    ??mbedtls_mpi_exp_mod_31
   \      0x338   0x680A             LDR      R2,[R1, #+0]
   \      0x33A   0x7810             LDRB     R0,[R2, #+0]
   \      0x33C   0x07C1             LSLS     R1,R0,#+31
   \      0x33E   0xD50A             BPL.N    ??mbedtls_mpi_exp_mod_31
   2029                  W[x_index].s = -1;
   \      0x340   0xF04F 0x30FF      MOV      R0,#+4294967295
   \      0x344   0xF8AD 0x0030      STRH     R0,[SP, #+48]
   2030                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&W[x_index], N, &W[x_index]));
   \      0x348   0xAA0B             ADD      R2,SP,#+44
   \      0x34A   0x4629             MOV      R1,R5
   \      0x34C   0xA80B             ADD      R0,SP,#+44
   \      0x34E   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \      0x352   0x4683             MOV      R11,R0
   \      0x354   0xB920             CBNZ.N   R0,??mbedtls_mpi_exp_mod_13
   \                     ??mbedtls_mpi_exp_mod_31: (+1)
   \      0x356   0x9816             LDR      R0,[SP, #+88]
   2031              }
   2032          
   2033              /*
   2034               * Load the result in the output variable.
   2035               */
   2036              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, &W[x_index]));
   \      0x358   0xA90B             ADD      R1,SP,#+44
   \      0x35A   0x.... 0x....      BL       mbedtls_mpi_copy
   \                     ??mbedtls_mpi_exp_mod_29: (+1)
   \      0x35E   0x4683             MOV      R11,R0
   2037          
   2038          cleanup:
   2039          
   2040              /* The first bit of the sliding window is always 1 and therefore the first
   2041               * half of the table was unused. */
   2042              for (i = w_table_used_size/2; i < w_table_used_size; i++) {
   \                     ??mbedtls_mpi_exp_mod_13: (+1)
   \      0x360   0x0865             LSRS     R5,R4,#+1
   \      0x362   0xE004             B.N      ??mbedtls_mpi_exp_mod_32
   2043                  mbedtls_mpi_free(&W[i]);
   \                     ??mbedtls_mpi_exp_mod_33: (+1)
   \      0x364   0xEB00 0x00C5      ADD      R0,R0,R5, LSL #+3
   \      0x368   0x.... 0x....      BL       mbedtls_mpi_free
   2044              }
   \      0x36C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mbedtls_mpi_exp_mod_32: (+1)
   \      0x36E   0x42A5             CMP      R5,R4
   \      0x370   0xA80B             ADD      R0,SP,#+44
   \      0x372   0xD3F7             BCC.N    ??mbedtls_mpi_exp_mod_33
   2045          
   2046              mbedtls_mpi_free(&W[x_index]);
   \      0x374   0x.... 0x....      BL       mbedtls_mpi_free
   2047              mbedtls_mpi_free(&W[1]);
   \      0x378   0xA80D             ADD      R0,SP,#+52
   \      0x37A   0x.... 0x....      BL       mbedtls_mpi_free
   2048              mbedtls_mpi_free(&T);
   \      0x37E   0xA801             ADD      R0,SP,#+4
   \      0x380   0x.... 0x....      BL       mbedtls_mpi_free
   2049              mbedtls_mpi_free(&Apos);
   \      0x384   0xA807             ADD      R0,SP,#+28
   \      0x386   0x.... 0x....      BL       mbedtls_mpi_free
   2050              mbedtls_mpi_free(&WW);
   \      0x38A   0xA803             ADD      R0,SP,#+12
   \      0x38C   0x.... 0x....      BL       mbedtls_mpi_free
   2051          
   2052              if (prec_RR == NULL || prec_RR->p == NULL) {
   \      0x390   0x9820             LDR      R0,[SP, #+128]
   \      0x392   0x2800             CMP      R0,#+0
   \      0x394   0xBF19             ITTEE    NE
   \      0x396   0x6800             LDRNE    R0,[R0, #+0]
   \      0x398   0x2800             CMPNE    R0,#+0
   2053                  mbedtls_mpi_free(&RR);
   \      0x39A   0xA805             ADDEQ    R0,SP,#+20
   \      0x39C   0x.... 0x....      BLEQ     mbedtls_mpi_free
   2054              }
   2055          
   2056              return ret;
   \      0x3A0   0x4658             MOV      R0,R11
   \                     ??mbedtls_mpi_exp_mod_2: (+1)
   \      0x3A2   0xB017             ADD      SP,SP,#+92
   \      0x3A4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2057          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \                     ??Subroutine16_0: (+1)
   \        0x2   0x4622             MOV      R2,R4
   \        0x4   0xA90B             ADD      R1,SP,#+44
   \        0x6   0xA803             ADD      R0,SP,#+12
   \        0x8   0x....             B.N      mpi_select

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xA801             ADD      R0,SP,#+4
   \        0x2   0x9B09             LDR      R3,[SP, #+36]
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x4632             MOV      R2,R6
   \        0x8   0xA903             ADD      R1,SP,#+12
   \        0xA   0xA80B             ADD      R0,SP,#+44
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xA801             ADD      R0,SP,#+4
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0x4633             MOV      R3,R6
   \        0x6   0x462A             MOV      R2,R5
   \        0x8   0xA903             ADD      R1,SP,#+12
   \        0xA   0xA80B             ADD      R0,SP,#+44
   \        0xC   0x....             B.N      mpi_montmul
   2058          
   2059          /*
   2060           * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
   2061           */

   \                                 In section .text, align 2, keep-with-next
   2062          int mbedtls_mpi_gcd(mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B)
   2063          {
   \                     mbedtls_mpi_gcd: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4615             MOV      R5,R2
   2064              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2065              size_t lz, lzt;
   2066              mbedtls_mpi TA, TB;
   2067          
   2068              MPI_VALIDATE_RET(G != NULL);
   2069              MPI_VALIDATE_RET(A != NULL);
   2070              MPI_VALIDATE_RET(B != NULL);
   2071          
   2072              mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TB);
   \        0xA   0xA802             ADD      R0,SP,#+8
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x10   0x.... 0x....      BL       ?Subroutine11
   2073          
   2074              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TA, A));
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x14   0x4639             MOV      R1,R7
   \       0x16   0xA802             ADD      R0,SP,#+8
   \       0x18   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x1C   0x0004             MOVS     R4,R0
   \       0x1E   0xD161             BNE.N    ??mbedtls_mpi_gcd_0
   2075              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, B));
   \       0x20   0x4629             MOV      R1,R5
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x28   0x0004             MOVS     R4,R0
   \       0x2A   0xD15B             BNE.N    ??mbedtls_mpi_gcd_0
   2076          
   2077              lz = mbedtls_mpi_lsb(&TA);
   \       0x2C   0xA802             ADD      R0,SP,#+8
   \       0x2E   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x32   0x4604             MOV      R4,R0
   2078              lzt = mbedtls_mpi_lsb(&TB);
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x3A   0x0005             MOVS     R5,R0
   2079          
   2080              /* The loop below gives the correct result when A==0 but not when B==0.
   2081               * So have a special case for B==0. Leverage the fact that we just
   2082               * calculated the lsb and lsb(B)==0 iff B is odd or 0 to make the test
   2083               * slightly more efficient than cmp_int(). */
   2084              if (lzt == 0 && mbedtls_mpi_get_bit(&TB, 0) == 0) {
   \       0x3C   0xD109             BNE.N    ??mbedtls_mpi_gcd_1
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x4668             MOV      R0,SP
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0x46   0xB920             CBNZ.N   R0,??mbedtls_mpi_gcd_1
   2085                  ret = mbedtls_mpi_copy(G, A);
   \       0x48   0x4639             MOV      R1,R7
   \       0x4A   0x4630             MOV      R0,R6
   \       0x4C   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x50   0xE047             B.N      ??mbedtls_mpi_gcd_2
   2086                  goto cleanup;
   2087              }
   2088          
   2089              if (lzt < lz) {
   \                     ??mbedtls_mpi_gcd_1: (+1)
   \       0x52   0x42A5             CMP      R5,R4
   \       0x54   0xBF88             IT       HI
   \       0x56   0x4625             MOVHI    R5,R4
   2090                  lz = lzt;
   2091              }
   2092          
   2093              TA.s = TB.s = 1;
   \       0x58   0x2201             MOVS     R2,#+1
   \       0x5A   0xF8AD 0x2004      STRH     R2,[SP, #+4]
   \       0x5E   0xF8AD 0x200C      STRH     R2,[SP, #+12]
   2094          
   2095              /* We mostly follow the procedure described in HAC 14.54, but with some
   2096               * minor differences:
   2097               * - Sequences of multiplications or divisions by 2 are grouped into a
   2098               *   single shift operation.
   2099               * - The procedure in HAC assumes that 0 < TB <= TA.
   2100               *     - The condition TB <= TA is not actually necessary for correctness.
   2101               *       TA and TB have symmetric roles except for the loop termination
   2102               *       condition, and the shifts at the beginning of the loop body
   2103               *       remove any significance from the ordering of TA vs TB before
   2104               *       the shifts.
   2105               *     - If TA = 0, the loop goes through 0 iterations and the result is
   2106               *       correctly TB.
   2107               *     - The case TB = 0 was short-circuited above.
   2108               *
   2109               * For the correctness proof below, decompose the original values of
   2110               * A and B as
   2111               *   A = sa * 2^a * A' with A'=0 or A' odd, and sa = +-1
   2112               *   B = sb * 2^b * B' with B'=0 or B' odd, and sb = +-1
   2113               * Then gcd(A, B) = 2^{min(a,b)} * gcd(A',B'),
   2114               * and gcd(A',B') is odd or 0.
   2115               *
   2116               * At the beginning, we have TA = |A| and TB = |B| so gcd(A,B) = gcd(TA,TB).
   2117               * The code maintains the following invariant:
   2118               *     gcd(A,B) = 2^k * gcd(TA,TB) for some k   (I)
   2119               */
   2120          
   2121              /* Proof that the loop terminates:
   2122               * At each iteration, either the right-shift by 1 is made on a nonzero
   2123               * value and the nonnegative integer bitlen(TA) + bitlen(TB) decreases
   2124               * by at least 1, or the right-shift by 1 is made on zero and then
   2125               * TA becomes 0 which ends the loop (TB cannot be 0 if it is right-shifted
   2126               * since in that case TB is calculated from TB-TA with the condition TB>TA).
   2127               */
   2128              while (mbedtls_mpi_cmp_int(&TA, 0) != 0) {
   \                     ??mbedtls_mpi_gcd_3: (+1)
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0xA802             ADD      R0,SP,#+8
   \       0x66   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x6A   0xB380             CBZ.N    R0,??mbedtls_mpi_gcd_4
   2129                  /* Divisions by 2 preserve the invariant (I). */
   2130                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, mbedtls_mpi_lsb(&TA)));
   \       0x6C   0xA802             ADD      R0,SP,#+8
   \       0x6E   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x72   0x4601             MOV      R1,R0
   \       0x74   0xA802             ADD      R0,SP,#+8
   \       0x76   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0x7A   0x0004             MOVS     R4,R0
   \       0x7C   0xD132             BNE.N    ??mbedtls_mpi_gcd_0
   2131                  MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, mbedtls_mpi_lsb(&TB)));
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0x.... 0x....      BL       mbedtls_mpi_lsb
   \       0x84   0x4601             MOV      R1,R0
   \       0x86   0x4668             MOV      R0,SP
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0x8C   0x0004             MOVS     R4,R0
   \       0x8E   0xD129             BNE.N    ??mbedtls_mpi_gcd_0
   2132          
   2133                  /* Set either TA or TB to |TA-TB|/2. Since TA and TB are both odd,
   2134                   * TA-TB is even so the division by 2 has an integer result.
   2135                   * Invariant (I) is preserved since any odd divisor of both TA and TB
   2136                   * also divides |TA-TB|/2, and any odd divisor of both TA and |TA-TB|/2
   2137                   * also divides TB, and any odd divisor of both TB and |TA-TB|/2 also
   2138                   * divides TA.
   2139                   */
   2140                  if (mbedtls_mpi_cmp_mpi(&TA, &TB) >= 0) {
   \       0x90   0x4669             MOV      R1,SP
   \       0x92   0xA802             ADD      R0,SP,#+8
   \       0x94   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD40A             BMI.N    ??mbedtls_mpi_gcd_5
   2141                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TA, &TA, &TB));
   \       0x9C   0x466A             MOV      R2,SP
   \       0x9E   0xA902             ADD      R1,SP,#+8
   \       0xA0   0xA802             ADD      R0,SP,#+8
   \       0xA2   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0xA6   0x0004             MOVS     R4,R0
   \       0xA8   0xBF04             ITT      EQ
   \       0xAA   0x2101             MOVEQ    R1,#+1
   \       0xAC   0xA802             ADDEQ    R0,SP,#+8
   2142                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TA, 1));
   \       0xAE   0xD009             BEQ.N    ??mbedtls_mpi_gcd_6
   \       0xB0   0xE018             B.N      ??mbedtls_mpi_gcd_0
   2143                  } else {
   2144                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(&TB, &TB, &TA));
   \                     ??mbedtls_mpi_gcd_5: (+1)
   \       0xB2   0xAA02             ADD      R2,SP,#+8
   \       0xB4   0x4669             MOV      R1,SP
   \       0xB6   0x4668             MOV      R0,SP
   \       0xB8   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0xBC   0x0004             MOVS     R4,R0
   \       0xBE   0xD111             BNE.N    ??mbedtls_mpi_gcd_0
   2145                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TB, 1));
   \       0xC0   0x2101             MOVS     R1,#+1
   \       0xC2   0x4668             MOV      R0,SP
   \                     ??mbedtls_mpi_gcd_6: (+1)
   \       0xC4   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0xC8   0x0004             MOVS     R4,R0
   \       0xCA   0xD0CA             BEQ.N    ??mbedtls_mpi_gcd_3
   \       0xCC   0xE00A             B.N      ??mbedtls_mpi_gcd_0
   2146                  }
   2147                  /* Note that one of TA or TB is still odd. */
   2148              }
   2149          
   2150              /* By invariant (I), gcd(A,B) = 2^k * gcd(TA,TB) for some k.
   2151               * At the loop exit, TA = 0, so gcd(TA,TB) = TB.
   2152               * - If there was at least one loop iteration, then one of TA or TB is odd,
   2153               *   and TA = 0, so TB is odd and gcd(TA,TB) = gcd(A',B'). In this case,
   2154               *   lz = min(a,b) so gcd(A,B) = 2^lz * TB.
   2155               * - If there was no loop iteration, then A was 0, and gcd(A,B) = B.
   2156               *   In this case, lz = 0 and B = TB so gcd(A,B) = B = 2^lz * TB as well.
   2157               */
   2158          
   2159              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(&TB, lz));
   \                     ??mbedtls_mpi_gcd_4: (+1)
   \       0xCE   0x4629             MOV      R1,R5
   \       0xD0   0x4668             MOV      R0,SP
   \       0xD2   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \       0xD6   0x0004             MOVS     R4,R0
   \       0xD8   0xD104             BNE.N    ??mbedtls_mpi_gcd_0
   2160              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(G, &TB));
   \       0xDA   0x4669             MOV      R1,SP
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0x.... 0x....      BL       mbedtls_mpi_copy
   \                     ??mbedtls_mpi_gcd_2: (+1)
   \       0xE2   0x4604             MOV      R4,R0
   2161          
   2162          cleanup:
   2163          
   2164              mbedtls_mpi_free(&TA); mbedtls_mpi_free(&TB);
   \                     ??mbedtls_mpi_gcd_0: (+1)
   \       0xE4   0xA802             ADD      R0,SP,#+8
   \       0xE6   0x.... 0x....      BL       mbedtls_mpi_free
   \       0xEA   0x.... 0x....      BL       ?Subroutine12
   2165          
   2166              return ret;
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0xEE   0x4620             MOV      R0,R4
   \       0xF0   0xB005             ADD      SP,SP,#+20
   \       0xF2   0xBDF0             POP      {R4-R7,PC}
   2167          }
   2168          
   2169          /*
   2170           * Fill X with size bytes of random.
   2171           * The bytes returned from the RNG are used in a specific order which
   2172           * is suitable for deterministic ECDSA (see the specification of
   2173           * mbedtls_mpi_random() and the implementation in mbedtls_mpi_fill_random()).
   2174           */

   \                                 In section .text, align 2, keep-with-next
   2175          int mbedtls_mpi_fill_random(mbedtls_mpi *X, size_t size,
   2176                                      int (*f_rng)(void *, unsigned char *, size_t),
   2177                                      void *p_rng)
   2178          {
   \                     mbedtls_mpi_fill_random: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
   2179              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2180              const size_t limbs = CHARS_TO_LIMBS(size);
   \        0xA   0xF014 0x0103      ANDS     R1,R4,#0x3
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2101             MOVNE    R1,#+1
   2181          
   2182              MPI_VALIDATE_RET(X     != NULL);
   2183              MPI_VALIDATE_RET(f_rng != NULL);
   2184          
   2185              /* Ensure that target MPI has exactly the necessary number of limbs */
   2186              MBEDTLS_MPI_CHK(mbedtls_mpi_resize_clear(X, limbs));
   \       0x12   0xEB01 0x0194      ADD      R1,R1,R4, LSR #+2
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   \       0x1A   0xB938             CBNZ.N   R0,??mbedtls_mpi_fill_random_0
   2187              if (size == 0) {
   \       0x1C   0xB134             CBZ.N    R4,??mbedtls_mpi_fill_random_0
   2188                  return 0;
   2189              }
   2190          
   2191              ret = mbedtls_mpi_core_fill_random(X->p, X->n, size, f_rng, p_rng);
   \       0x1E   0x9700             STR      R7,[SP, #+0]
   \       0x20   0x88E9             LDRH     R1,[R5, #+6]
   \       0x22   0x6828             LDR      R0,[R5, #+0]
   \       0x24   0x4633             MOV      R3,R6
   \       0x26   0x4622             MOV      R2,R4
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_core_fill_random
   2192          
   2193          cleanup:
   2194              return ret;
   \                     ??mbedtls_mpi_fill_random_0: (+1)
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}
   2195          }
   2196          

   \                                 In section .text, align 2, keep-with-next
   2197          int mbedtls_mpi_random(mbedtls_mpi *X,
   2198                                 mbedtls_mpi_sint min,
   2199                                 const mbedtls_mpi *N,
   2200                                 int (*f_rng)(void *, unsigned char *, size_t),
   2201                                 void *p_rng)
   2202          {
   \                     mbedtls_mpi_random: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
   2203              if (min < 0) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD403             BMI.N    ??mbedtls_mpi_random_0
   2204                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   2205              }
   2206              if (mbedtls_mpi_cmp_int(N, min) <= 0) {
   \        0xE   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xDC02             BGT.N    ??mbedtls_mpi_random_1
   2207                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \                     ??mbedtls_mpi_random_0: (+1)
   \       0x16   0xF06F 0x0003      MVN      R0,#+3
   \       0x1A   0xBDFE             POP      {R1-R7,PC}
   2208              }
   2209          
   2210              /* Ensure that target MPI has exactly the same number of limbs
   2211               * as the upper bound, even if the upper bound has leading zeros.
   2212               * This is necessary for mbedtls_mpi_core_random. */
   2213              int ret = mbedtls_mpi_resize_clear(X, N->n);
   \                     ??mbedtls_mpi_random_1: (+1)
   \       0x1C   0x88F1             LDRH     R1,[R6, #+6]
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_resize_clear
   2214              if (ret != 0) {
   \       0x24   0xB940             CBNZ.N   R0,??mbedtls_mpi_random_2
   2215                  return ret;
   2216              }
   2217          
   2218              return mbedtls_mpi_core_random(X->p, min, N->p, X->n, f_rng, p_rng);
   \       0x26   0x9808             LDR      R0,[SP, #+32]
   \       0x28   0x9700             STR      R7,[SP, #+0]
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   \       0x2E   0x88E3             LDRH     R3,[R4, #+6]
   \       0x30   0x6832             LDR      R2,[R6, #+0]
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x.... 0x....      BL       mbedtls_mpi_core_random
   \                     ??mbedtls_mpi_random_2: (+1)
   \       0x38   0xBDFE             POP      {R1-R7,PC}
   2219          }
   2220          
   2221          /*
   2222           * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
   2223           */

   \                                 In section .text, align 2, keep-with-next
   2224          int mbedtls_mpi_inv_mod(mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N)
   2225          {
   \                     mbedtls_mpi_inv_mod: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0xB092             SUB      SP,SP,#+72
   2226              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2227              mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
   2228              MPI_VALIDATE_RET(X != NULL);
   2229              MPI_VALIDATE_RET(A != NULL);
   2230              MPI_VALIDATE_RET(N != NULL);
   2231          
   2232              if (mbedtls_mpi_cmp_int(N, 1) <= 0) {
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xBFD8             IT       LE
   \       0x14   0xF06F 0x0003      MVNLE    R0,#+3
   2233                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x18   0xF340 0x811F      BLE.W    ??mbedtls_mpi_inv_mod_0
   2234              }
   2235          
   2236              mbedtls_mpi_init(&TA); mbedtls_mpi_init(&TU); mbedtls_mpi_init(&U1); mbedtls_mpi_init(&U2);
   \       0x1C   0xA80C             ADD      R0,SP,#+48
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x22   0xA808             ADD      R0,SP,#+32
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x28   0xA806             ADD      R0,SP,#+24
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x2E   0xA804             ADD      R0,SP,#+16
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_init
   2237              mbedtls_mpi_init(&G); mbedtls_mpi_init(&TB); mbedtls_mpi_init(&TV);
   \       0x34   0xA810             ADD      R0,SP,#+64
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x3A   0xA80E             ADD      R0,SP,#+56
   \       0x3C   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x40   0xA80A             ADD      R0,SP,#+40
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_init
   2238              mbedtls_mpi_init(&V1); mbedtls_mpi_init(&V2);
   \       0x46   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x4A   0xA802             ADD      R0,SP,#+8
   \       0x4C   0x.... 0x....      BL       mbedtls_mpi_init
   2239          
   2240              MBEDTLS_MPI_CHK(mbedtls_mpi_gcd(&G, A, N));
   \       0x50   0x4632             MOV      R2,R6
   \       0x52   0x4639             MOV      R1,R7
   \       0x54   0xA810             ADD      R0,SP,#+64
   \       0x56   0x.... 0x....      BL       mbedtls_mpi_gcd
   \       0x5A   0x0004             MOVS     R4,R0
   \       0x5C   0xD106             BNE.N    ??mbedtls_mpi_inv_mod_1
   2241          
   2242              if (mbedtls_mpi_cmp_int(&G, 1) != 0) {
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0xA810             ADD      R0,SP,#+64
   \       0x62   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x66   0xB110             CBZ.N    R0,??mbedtls_mpi_inv_mod_2
   2243                  ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   \       0x68   0xF06F 0x040D      MVN      R4,#+13
   2244                  goto cleanup;
   \                     ??mbedtls_mpi_inv_mod_1: (+1)
   \       0x6C   0xE0DA             B.N      ??mbedtls_mpi_inv_mod_3
   2245              }
   2246          
   2247              MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&TA, A, N));
   \                     ??mbedtls_mpi_inv_mod_2: (+1)
   \       0x6E   0x4632             MOV      R2,R6
   \       0x70   0x4639             MOV      R1,R7
   \       0x72   0xA80C             ADD      R0,SP,#+48
   \       0x74   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \       0x78   0x0004             MOVS     R4,R0
   \       0x7A   0xD1F7             BNE.N    ??mbedtls_mpi_inv_mod_1
   2248              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TU, &TA));
   \       0x7C   0xA90C             ADD      R1,SP,#+48
   \       0x7E   0xA808             ADD      R0,SP,#+32
   \       0x80   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x84   0x0004             MOVS     R4,R0
   \       0x86   0xD1F1             BNE.N    ??mbedtls_mpi_inv_mod_1
   2249              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TB, N));
   \       0x88   0x4631             MOV      R1,R6
   \       0x8A   0xA80E             ADD      R0,SP,#+56
   \       0x8C   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x90   0x0004             MOVS     R4,R0
   \       0x92   0xD1EB             BNE.N    ??mbedtls_mpi_inv_mod_1
   2250              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&TV, N));
   \       0x94   0x4631             MOV      R1,R6
   \       0x96   0xA80A             ADD      R0,SP,#+40
   \       0x98   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x9C   0x0004             MOVS     R4,R0
   \       0x9E   0xD1E5             BNE.N    ??mbedtls_mpi_inv_mod_1
   2251          
   2252              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U1, 1));
   \       0xA0   0x2101             MOVS     R1,#+1
   \       0xA2   0xA806             ADD      R0,SP,#+24
   \       0xA4   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xA8   0x0004             MOVS     R4,R0
   \       0xAA   0xD1DF             BNE.N    ??mbedtls_mpi_inv_mod_1
   2253              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&U2, 0));
   \       0xAC   0x2100             MOVS     R1,#+0
   \       0xAE   0xA804             ADD      R0,SP,#+16
   \       0xB0   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xB4   0x0004             MOVS     R4,R0
   \       0xB6   0xD1D9             BNE.N    ??mbedtls_mpi_inv_mod_1
   2254              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V1, 0));
   \       0xB8   0x2100             MOVS     R1,#+0
   \       0xBA   0x4668             MOV      R0,SP
   \       0xBC   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xC0   0x0004             MOVS     R4,R0
   \       0xC2   0xD1D3             BNE.N    ??mbedtls_mpi_inv_mod_1
   2255              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&V2, 1));
   \       0xC4   0x2101             MOVS     R1,#+1
   \       0xC6   0xA802             ADD      R0,SP,#+8
   \       0xC8   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xCC   0x0004             MOVS     R4,R0
   \       0xCE   0xD12B             BNE.N    ??mbedtls_mpi_inv_mod_4
   2256          
   2257              do {
   2258                  while ((TU.p[0] & 1) == 0) {
   \                     ??mbedtls_mpi_inv_mod_5: (+1)
   \       0xD0   0x9A08             LDR      R2,[SP, #+32]
   \       0xD2   0x7811             LDRB     R1,[R2, #+0]
   \       0xD4   0x07C8             LSLS     R0,R1,#+31
   \       0xD6   0xD428             BMI.N    ??mbedtls_mpi_inv_mod_6
   2259                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TU, 1));
   \       0xD8   0x2101             MOVS     R1,#+1
   \       0xDA   0xA808             ADD      R0,SP,#+32
   \       0xDC   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \       0xE0   0x0004             MOVS     R4,R0
   \       0xE2   0xD121             BNE.N    ??mbedtls_mpi_inv_mod_4
   2260          
   2261                      if ((U1.p[0] & 1) != 0 || (U2.p[0] & 1) != 0) {
   \       0xE4   0x9A06             LDR      R2,[SP, #+24]
   \       0xE6   0x7811             LDRB     R1,[R2, #+0]
   \       0xE8   0x07C8             LSLS     R0,R1,#+31
   \       0xEA   0xD403             BMI.N    ??mbedtls_mpi_inv_mod_7
   \       0xEC   0x9A04             LDR      R2,[SP, #+16]
   \       0xEE   0x7811             LDRB     R1,[R2, #+0]
   \       0xF0   0x07C8             LSLS     R0,R1,#+31
   \       0xF2   0xD50D             BPL.N    ??mbedtls_mpi_inv_mod_8
   2262                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&U1, &U1, &TB));
   \                     ??mbedtls_mpi_inv_mod_7: (+1)
   \       0xF4   0xAA0E             ADD      R2,SP,#+56
   \       0xF6   0xA906             ADD      R1,SP,#+24
   \       0xF8   0xA806             ADD      R0,SP,#+24
   \       0xFA   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0xFE   0x0004             MOVS     R4,R0
   \      0x100   0xD112             BNE.N    ??mbedtls_mpi_inv_mod_4
   2263                          MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &TA));
   \      0x102   0xAA0C             ADD      R2,SP,#+48
   \      0x104   0xA904             ADD      R1,SP,#+16
   \      0x106   0xA804             ADD      R0,SP,#+16
   \      0x108   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x10C   0x0004             MOVS     R4,R0
   \      0x10E   0xD10B             BNE.N    ??mbedtls_mpi_inv_mod_4
   2264                      }
   2265          
   2266                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U1, 1));
   \                     ??mbedtls_mpi_inv_mod_8: (+1)
   \      0x110   0x2101             MOVS     R1,#+1
   \      0x112   0xA806             ADD      R0,SP,#+24
   \      0x114   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x118   0x0004             MOVS     R4,R0
   \      0x11A   0xD105             BNE.N    ??mbedtls_mpi_inv_mod_4
   2267                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&U2, 1));
   \      0x11C   0x2101             MOVS     R1,#+1
   \      0x11E   0xA804             ADD      R0,SP,#+16
   \      0x120   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x124   0x0004             MOVS     R4,R0
   \      0x126   0xD0D3             BEQ.N    ??mbedtls_mpi_inv_mod_5
   \                     ??mbedtls_mpi_inv_mod_4: (+1)
   \      0x128   0xE07C             B.N      ??mbedtls_mpi_inv_mod_3
   2268                  }
   2269          
   2270                  while ((TV.p[0] & 1) == 0) {
   \                     ??mbedtls_mpi_inv_mod_6: (+1)
   \      0x12A   0x9A0A             LDR      R2,[SP, #+40]
   \      0x12C   0x7811             LDRB     R1,[R2, #+0]
   \      0x12E   0x07C8             LSLS     R0,R1,#+31
   \      0x130   0xD426             BMI.N    ??mbedtls_mpi_inv_mod_9
   2271                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&TV, 1));
   \      0x132   0x2101             MOVS     R1,#+1
   \      0x134   0xA80A             ADD      R0,SP,#+40
   \      0x136   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x13A   0x0004             MOVS     R4,R0
   \      0x13C   0xD172             BNE.N    ??mbedtls_mpi_inv_mod_3
   2272          
   2273                      if ((V1.p[0] & 1) != 0 || (V2.p[0] & 1) != 0) {
   \      0x13E   0x9A00             LDR      R2,[SP, #+0]
   \      0x140   0x7811             LDRB     R1,[R2, #+0]
   \      0x142   0x07C8             LSLS     R0,R1,#+31
   \      0x144   0xD403             BMI.N    ??mbedtls_mpi_inv_mod_10
   \      0x146   0x9A02             LDR      R2,[SP, #+8]
   \      0x148   0x7811             LDRB     R1,[R2, #+0]
   \      0x14A   0x07C8             LSLS     R0,R1,#+31
   \      0x14C   0xD50B             BPL.N    ??mbedtls_mpi_inv_mod_11
   2274                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, &TB));
   \                     ??mbedtls_mpi_inv_mod_10: (+1)
   \      0x14E   0xAA0E             ADD      R2,SP,#+56
   \      0x150   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_38: (+1)
   \      0x154   0x0004             MOVS     R4,R0
   \      0x156   0xD165             BNE.N    ??mbedtls_mpi_inv_mod_3
   2275                          MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &TA));
   \      0x158   0xAA0C             ADD      R2,SP,#+48
   \      0x15A   0xA902             ADD      R1,SP,#+8
   \      0x15C   0xA802             ADD      R0,SP,#+8
   \      0x15E   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x162   0x0004             MOVS     R4,R0
   \      0x164   0xD15E             BNE.N    ??mbedtls_mpi_inv_mod_3
   2276                      }
   2277          
   2278                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V1, 1));
   \                     ??mbedtls_mpi_inv_mod_11: (+1)
   \      0x166   0x2101             MOVS     R1,#+1
   \      0x168   0x4668             MOV      R0,SP
   \      0x16A   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x16E   0x0004             MOVS     R4,R0
   \      0x170   0xD158             BNE.N    ??mbedtls_mpi_inv_mod_3
   2279                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&V2, 1));
   \      0x172   0x2101             MOVS     R1,#+1
   \      0x174   0xA802             ADD      R0,SP,#+8
   \      0x176   0x.... 0x....      BL       mbedtls_mpi_shift_r
   \      0x17A   0x0004             MOVS     R4,R0
   \      0x17C   0xD0D5             BEQ.N    ??mbedtls_mpi_inv_mod_6
   \      0x17E   0xE051             B.N      ??mbedtls_mpi_inv_mod_3
   2280                  }
   2281          
   2282                  if (mbedtls_mpi_cmp_mpi(&TU, &TV) >= 0) {
   \                     ??mbedtls_mpi_inv_mod_9: (+1)
   \      0x180   0xA90A             ADD      R1,SP,#+40
   \      0x182   0xA808             ADD      R0,SP,#+32
   \      0x184   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x188   0x2800             CMP      R0,#+0
   \      0x18A   0xD415             BMI.N    ??mbedtls_mpi_inv_mod_12
   2283                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TU, &TU, &TV));
   \      0x18C   0xAA0A             ADD      R2,SP,#+40
   \      0x18E   0xA908             ADD      R1,SP,#+32
   \      0x190   0xA808             ADD      R0,SP,#+32
   \      0x192   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x196   0x0004             MOVS     R4,R0
   \      0x198   0xD144             BNE.N    ??mbedtls_mpi_inv_mod_3
   2284                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U1, &U1, &V1));
   \      0x19A   0x466A             MOV      R2,SP
   \      0x19C   0xA906             ADD      R1,SP,#+24
   \      0x19E   0xA806             ADD      R0,SP,#+24
   \      0x1A0   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1A4   0x0004             MOVS     R4,R0
   \      0x1A6   0xD13D             BNE.N    ??mbedtls_mpi_inv_mod_3
   2285                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&U2, &U2, &V2));
   \      0x1A8   0xAA02             ADD      R2,SP,#+8
   \      0x1AA   0xA904             ADD      R1,SP,#+16
   \      0x1AC   0xA804             ADD      R0,SP,#+16
   \      0x1AE   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1B2   0x0004             MOVS     R4,R0
   \      0x1B4   0xD136             BNE.N    ??mbedtls_mpi_inv_mod_3
   \      0x1B6   0xE012             B.N      ??mbedtls_mpi_inv_mod_13
   2286                  } else {
   2287                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&TV, &TV, &TU));
   \                     ??mbedtls_mpi_inv_mod_12: (+1)
   \      0x1B8   0xAA08             ADD      R2,SP,#+32
   \      0x1BA   0xA90A             ADD      R1,SP,#+40
   \      0x1BC   0xA80A             ADD      R0,SP,#+40
   \      0x1BE   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1C2   0x0004             MOVS     R4,R0
   \      0x1C4   0xD12E             BNE.N    ??mbedtls_mpi_inv_mod_3
   2288                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, &U1));
   \      0x1C6   0xAA06             ADD      R2,SP,#+24
   \      0x1C8   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_34: (+1)
   \      0x1CC   0x0004             MOVS     R4,R0
   \      0x1CE   0xD129             BNE.N    ??mbedtls_mpi_inv_mod_3
   2289                      MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V2, &V2, &U2));
   \      0x1D0   0xAA04             ADD      R2,SP,#+16
   \      0x1D2   0xA902             ADD      R1,SP,#+8
   \      0x1D4   0xA802             ADD      R0,SP,#+8
   \      0x1D6   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1DA   0x0004             MOVS     R4,R0
   \      0x1DC   0xD122             BNE.N    ??mbedtls_mpi_inv_mod_3
   2290                  }
   2291              } while (mbedtls_mpi_cmp_int(&TU, 0) != 0);
   \                     ??mbedtls_mpi_inv_mod_13: (+1)
   \      0x1DE   0x2100             MOVS     R1,#+0
   \      0x1E0   0xA808             ADD      R0,SP,#+32
   \      0x1E2   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x1E6   0x2800             CMP      R0,#+0
   \      0x1E8   0xF47F 0xAF72      BNE.W    ??mbedtls_mpi_inv_mod_5
   2292          
   2293              while (mbedtls_mpi_cmp_int(&V1, 0) < 0) {
   \                     ??mbedtls_mpi_inv_mod_14: (+1)
   \      0x1EC   0x2100             MOVS     R1,#+0
   \      0x1EE   0x4668             MOV      R0,SP
   \      0x1F0   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \      0x1F4   0x2800             CMP      R0,#+0
   \      0x1F6   0xD50A             BPL.N    ??mbedtls_mpi_inv_mod_15
   2294                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&V1, &V1, N));
   \      0x1F8   0x4632             MOV      R2,R6
   \      0x1FA   0x.... 0x....      BL       ?Subroutine14
   2295              }
   \                     ??CrossCallReturnLabel_37: (+1)
   \      0x1FE   0x0004             MOVS     R4,R0
   \      0x200   0xD0F4             BEQ.N    ??mbedtls_mpi_inv_mod_14
   \      0x202   0xE00F             B.N      ??mbedtls_mpi_inv_mod_3
   2296          
   2297              while (mbedtls_mpi_cmp_mpi(&V1, N) >= 0) {
   2298                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&V1, &V1, N));
   \                     ??mbedtls_mpi_inv_mod_16: (+1)
   \      0x204   0x4632             MOV      R2,R6
   \      0x206   0x.... 0x....      BL       ?Subroutine13
   2299              }
   \                     ??CrossCallReturnLabel_33: (+1)
   \      0x20A   0x0004             MOVS     R4,R0
   \      0x20C   0xD10A             BNE.N    ??mbedtls_mpi_inv_mod_3
   \                     ??mbedtls_mpi_inv_mod_15: (+1)
   \      0x20E   0x4631             MOV      R1,R6
   \      0x210   0x4668             MOV      R0,SP
   \      0x212   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \      0x216   0x2800             CMP      R0,#+0
   \      0x218   0xD5F4             BPL.N    ??mbedtls_mpi_inv_mod_16
   2300          
   2301              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, &V1));
   \      0x21A   0x4669             MOV      R1,SP
   \      0x21C   0x4628             MOV      R0,R5
   \      0x21E   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x222   0x4604             MOV      R4,R0
   2302          
   2303          cleanup:
   2304          
   2305              mbedtls_mpi_free(&TA); mbedtls_mpi_free(&TU); mbedtls_mpi_free(&U1); mbedtls_mpi_free(&U2);
   \                     ??mbedtls_mpi_inv_mod_3: (+1)
   \      0x224   0xA80C             ADD      R0,SP,#+48
   \      0x226   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x22A   0xA808             ADD      R0,SP,#+32
   \      0x22C   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x230   0xA806             ADD      R0,SP,#+24
   \      0x232   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x236   0xA804             ADD      R0,SP,#+16
   \      0x238   0x.... 0x....      BL       mbedtls_mpi_free
   2306              mbedtls_mpi_free(&G); mbedtls_mpi_free(&TB); mbedtls_mpi_free(&TV);
   \      0x23C   0xA810             ADD      R0,SP,#+64
   \      0x23E   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x242   0xA80E             ADD      R0,SP,#+56
   \      0x244   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x248   0xA80A             ADD      R0,SP,#+40
   \      0x24A   0x.... 0x....      BL       mbedtls_mpi_free
   2307              mbedtls_mpi_free(&V1); mbedtls_mpi_free(&V2);
   \      0x24E   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_29: (+1)
   \      0x252   0xA802             ADD      R0,SP,#+8
   \      0x254   0x.... 0x....      BL       mbedtls_mpi_free
   2308          
   2309              return ret;
   \      0x258   0x4620             MOV      R0,R4
   \                     ??mbedtls_mpi_inv_mod_0: (+1)
   \      0x25A   0xB013             ADD      SP,SP,#+76
   \      0x25C   0xBDF0             POP      {R4-R7,PC}
   2310          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     mbedtls_ct_zero

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00
   \       0x11                      DS8 3
   2311          
   2312          #if defined(MBEDTLS_GENPRIME)
   2313          
   2314          /* Gaps between primes, starting at 3. https://oeis.org/A001223 */
   2315          static const unsigned char small_prime_gaps[] = {
   2316              2, 2, 4, 2, 4, 2, 4, 6,
   2317              2, 6, 4, 2, 4, 6, 6, 2,
   2318              6, 4, 2, 6, 4, 6, 8, 4,
   2319              2, 4, 2, 4, 14, 4, 6, 2,
   2320              10, 2, 6, 6, 4, 6, 6, 2,
   2321              10, 2, 4, 2, 12, 12, 4, 2,
   2322              4, 6, 2, 10, 6, 6, 6, 2,
   2323              6, 4, 2, 10, 14, 4, 2, 4,
   2324              14, 6, 10, 2, 4, 6, 8, 6,
   2325              6, 4, 6, 8, 4, 8, 10, 2,
   2326              10, 2, 6, 4, 6, 8, 4, 2,
   2327              4, 12, 8, 4, 8, 4, 6, 12,
   2328              2, 18, 6, 10, 6, 6, 2, 6,
   2329              10, 6, 6, 2, 6, 6, 4, 2,
   2330              12, 10, 2, 4, 6, 6, 2, 12,
   2331              4, 6, 8, 10, 8, 10, 8, 6,
   2332              6, 4, 8, 6, 4, 8, 4, 14,
   2333              10, 12, 2, 10, 2, 4, 2, 10,
   2334              14, 4, 2, 4, 14, 4, 2, 4,
   2335              20, 4, 8, 10, 8, 4, 6, 6,
   2336              14, 4, 6, 6, 8, 6, /*reaches 997*/
   2337              0 /* the last entry is effectively unused */
   2338          };
   2339          
   2340          /*
   2341           * Small divisors test (X must be positive)
   2342           *
   2343           * Return values:
   2344           * 0: no small factor (possible prime, more tests needed)
   2345           * 1: certain prime
   2346           * MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: certain non-prime
   2347           * other negative: error
   2348           */
   2349          static int mpi_check_small_factors(const mbedtls_mpi *X)
   2350          {
   2351              int ret = 0;
   2352              size_t i;
   2353              mbedtls_mpi_uint r;
   2354              unsigned p = 3; /* The first odd prime */
   2355          
   2356              if ((X->p[0] & 1) == 0) {
   2357                  return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2358              }
   2359          
   2360              for (i = 0; i < sizeof(small_prime_gaps); p += small_prime_gaps[i], i++) {
   2361                  MBEDTLS_MPI_CHK(mbedtls_mpi_mod_int(&r, X, p));
   2362                  if (r == 0) {
   2363                      if (mbedtls_mpi_cmp_int(X, p) == 0) {
   2364                          return 1;
   2365                      } else {
   2366                          return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2367                      }
   2368                  }
   2369              }
   2370          
   2371          cleanup:
   2372              return ret;
   2373          }
   2374          
   2375          /*
   2376           * Miller-Rabin pseudo-primality test  (HAC 4.24)
   2377           */
   2378          static int mpi_miller_rabin(const mbedtls_mpi *X, size_t rounds,
   2379                                      int (*f_rng)(void *, unsigned char *, size_t),
   2380                                      void *p_rng)
   2381          {
   2382              int ret, count;
   2383              size_t i, j, k, s;
   2384              mbedtls_mpi W, R, T, A, RR;
   2385          
   2386              MPI_VALIDATE_RET(X     != NULL);
   2387              MPI_VALIDATE_RET(f_rng != NULL);
   2388          
   2389              mbedtls_mpi_init(&W); mbedtls_mpi_init(&R);
   2390              mbedtls_mpi_init(&T); mbedtls_mpi_init(&A);
   2391              mbedtls_mpi_init(&RR);
   2392          
   2393              /*
   2394               * W = |X| - 1
   2395               * R = W >> lsb( W )
   2396               */
   2397              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(&W, X, 1));
   2398              s = mbedtls_mpi_lsb(&W);
   2399              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&R, &W));
   2400              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&R, s));
   2401          
   2402              for (i = 0; i < rounds; i++) {
   2403                  /*
   2404                   * pick a random A, 1 < A < |X| - 1
   2405                   */
   2406                  count = 0;
   2407                  do {
   2408                      MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(&A, X->n * ciL, f_rng, p_rng));
   2409          
   2410                      j = mbedtls_mpi_bitlen(&A);
   2411                      k = mbedtls_mpi_bitlen(&W);
   2412                      if (j > k) {
   2413                          A.p[A.n - 1] &= ((mbedtls_mpi_uint) 1 << (k - (A.n - 1) * biL - 1)) - 1;
   2414                      }
   2415          
   2416                      if (count++ > 30) {
   2417                          ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2418                          goto cleanup;
   2419                      }
   2420          
   2421                  } while (mbedtls_mpi_cmp_mpi(&A, &W) >= 0 ||
   2422                           mbedtls_mpi_cmp_int(&A, 1)  <= 0);
   2423          
   2424                  /*
   2425                   * A = A^R mod |X|
   2426                   */
   2427                  MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&A, &A, &R, X, &RR));
   2428          
   2429                  if (mbedtls_mpi_cmp_mpi(&A, &W) == 0 ||
   2430                      mbedtls_mpi_cmp_int(&A,  1) == 0) {
   2431                      continue;
   2432                  }
   2433          
   2434                  j = 1;
   2435                  while (j < s && mbedtls_mpi_cmp_mpi(&A, &W) != 0) {
   2436                      /*
   2437                       * A = A * A mod |X|
   2438                       */
   2439                      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&T, &A, &A));
   2440                      MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&A, &T, X));
   2441          
   2442                      if (mbedtls_mpi_cmp_int(&A, 1) == 0) {
   2443                          break;
   2444                      }
   2445          
   2446                      j++;
   2447                  }
   2448          
   2449                  /*
   2450                   * not prime if A != |X| - 1 or A == 1
   2451                   */
   2452                  if (mbedtls_mpi_cmp_mpi(&A, &W) != 0 ||
   2453                      mbedtls_mpi_cmp_int(&A,  1) == 0) {
   2454                      ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2455                      break;
   2456                  }
   2457              }
   2458          
   2459          cleanup:
   2460              mbedtls_mpi_free(&W); mbedtls_mpi_free(&R);
   2461              mbedtls_mpi_free(&T); mbedtls_mpi_free(&A);
   2462              mbedtls_mpi_free(&RR);
   2463          
   2464              return ret;
   2465          }
   2466          
   2467          /*
   2468           * Pseudo-primality test: small factors, then Miller-Rabin
   2469           */
   2470          int mbedtls_mpi_is_prime_ext(const mbedtls_mpi *X, int rounds,
   2471                                       int (*f_rng)(void *, unsigned char *, size_t),
   2472                                       void *p_rng)
   2473          {
   2474              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2475              mbedtls_mpi XX;
   2476              MPI_VALIDATE_RET(X     != NULL);
   2477              MPI_VALIDATE_RET(f_rng != NULL);
   2478          
   2479              XX.s = 1;
   2480              XX.n = X->n;
   2481              XX.p = X->p;
   2482          
   2483              if (mbedtls_mpi_cmp_int(&XX, 0) == 0 ||
   2484                  mbedtls_mpi_cmp_int(&XX, 1) == 0) {
   2485                  return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2486              }
   2487          
   2488              if (mbedtls_mpi_cmp_int(&XX, 2) == 0) {
   2489                  return 0;
   2490              }
   2491          
   2492              if ((ret = mpi_check_small_factors(&XX)) != 0) {
   2493                  if (ret == 1) {
   2494                      return 0;
   2495                  }
   2496          
   2497                  return ret;
   2498              }
   2499          
   2500              return mpi_miller_rabin(&XX, rounds, f_rng, p_rng);
   2501          }
   2502          
   2503          /*
   2504           * Prime number generation
   2505           *
   2506           * To generate an RSA key in a way recommended by FIPS 186-4, both primes must
   2507           * be either 1024 bits or 1536 bits long, and flags must contain
   2508           * MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR.
   2509           */
   2510          int mbedtls_mpi_gen_prime(mbedtls_mpi *X, size_t nbits, int flags,
   2511                                    int (*f_rng)(void *, unsigned char *, size_t),
   2512                                    void *p_rng)
   2513          {
   2514          #ifdef MBEDTLS_HAVE_INT64
   2515          // ceil(2^63.5)
   2516          #define CEIL_MAXUINT_DIV_SQRT2 0xb504f333f9de6485ULL
   2517          #else
   2518          // ceil(2^31.5)
   2519          #define CEIL_MAXUINT_DIV_SQRT2 0xb504f334U
   2520          #endif
   2521              int ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
   2522              size_t k, n;
   2523              int rounds;
   2524              mbedtls_mpi_uint r;
   2525              mbedtls_mpi Y;
   2526          
   2527              MPI_VALIDATE_RET(X     != NULL);
   2528              MPI_VALIDATE_RET(f_rng != NULL);
   2529          
   2530              if (nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS) {
   2531                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   2532              }
   2533          
   2534              mbedtls_mpi_init(&Y);
   2535          
   2536              n = BITS_TO_LIMBS(nbits);
   2537          
   2538              if ((flags & MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR) == 0) {
   2539                  /*
   2540                   * 2^-80 error probability, number of rounds chosen per HAC, table 4.4
   2541                   */
   2542                  rounds = ((nbits >= 1300) ?  2 : (nbits >=  850) ?  3 :
   2543                            (nbits >=  650) ?  4 : (nbits >=  350) ?  8 :
   2544                            (nbits >=  250) ? 12 : (nbits >=  150) ? 18 : 27);
   2545              } else {
   2546                  /*
   2547                   * 2^-100 error probability, number of rounds computed based on HAC,
   2548                   * fact 4.48
   2549                   */
   2550                  rounds = ((nbits >= 1450) ?  4 : (nbits >=  1150) ?  5 :
   2551                            (nbits >= 1000) ?  6 : (nbits >=   850) ?  7 :
   2552                            (nbits >=  750) ?  8 : (nbits >=   500) ? 13 :
   2553                            (nbits >=  250) ? 28 : (nbits >=   150) ? 40 : 51);
   2554              }
   2555          
   2556              while (1) {
   2557                  MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(X, n * ciL, f_rng, p_rng));
   2558                  /* make sure generated number is at least (nbits-1)+0.5 bits (FIPS 186-4 B.3.3 steps 4.4, 5.5) */
   2559                  if (X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2) {
   2560                      continue;
   2561                  }
   2562          
   2563                  k = n * biL;
   2564                  if (k > nbits) {
   2565                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(X, k - nbits));
   2566                  }
   2567                  X->p[0] |= 1;
   2568          
   2569                  if ((flags & MBEDTLS_MPI_GEN_PRIME_FLAG_DH) == 0) {
   2570                      ret = mbedtls_mpi_is_prime_ext(X, rounds, f_rng, p_rng);
   2571          
   2572                      if (ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   2573                          goto cleanup;
   2574                      }
   2575                  } else {
   2576                      /*
   2577                       * A necessary condition for Y and X = 2Y + 1 to be prime
   2578                       * is X = 2 mod 3 (which is equivalent to Y = 2 mod 3).
   2579                       * Make sure it is satisfied, while keeping X = 3 mod 4
   2580                       */
   2581          
   2582                      X->p[0] |= 2;
   2583          
   2584                      MBEDTLS_MPI_CHK(mbedtls_mpi_mod_int(&r, X, 3));
   2585                      if (r == 0) {
   2586                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X, X, 8));
   2587                      } else if (r == 1) {
   2588                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X, X, 4));
   2589                      }
   2590          
   2591                      /* Set Y = (X-1) / 2, which is X / 2 because X is odd */
   2592                      MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&Y, X));
   2593                      MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&Y, 1));
   2594          
   2595                      while (1) {
   2596                          /*
   2597                           * First, check small factors for X and Y
   2598                           * before doing Miller-Rabin on any of them
   2599                           */
   2600                          if ((ret = mpi_check_small_factors(X)) == 0 &&
   2601                              (ret = mpi_check_small_factors(&Y)) == 0 &&
   2602                              (ret = mpi_miller_rabin(X, rounds, f_rng, p_rng))
   2603                              == 0 &&
   2604                              (ret = mpi_miller_rabin(&Y, rounds, f_rng, p_rng))
   2605                              == 0) {
   2606                              goto cleanup;
   2607                          }
   2608          
   2609                          if (ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   2610                              goto cleanup;
   2611                          }
   2612          
   2613                          /*
   2614                           * Next candidates. We want to preserve Y = (X-1) / 2 and
   2615                           * Y = 1 mod 2 and Y = 2 mod 3 (eq X = 3 mod 4 and X = 2 mod 3)
   2616                           * so up Y by 6 and X by 12.
   2617                           */
   2618                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(X,  X, 12));
   2619                          MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&Y, &Y, 6));
   2620                      }
   2621                  }
   2622              }
   2623          
   2624          cleanup:
   2625          
   2626              mbedtls_mpi_free(&Y);
   2627          
   2628              return ret;
   2629          }
   2630          
   2631          #endif /* MBEDTLS_GENPRIME */
   2632          
   2633          #if defined(MBEDTLS_SELF_TEST)
   2634          
   2635          #define GCD_PAIR_COUNT  3
   2636          
   2637          static const int gcd_pairs[GCD_PAIR_COUNT][3] =
   2638          {
   2639              { 693, 609, 21 },
   2640              { 1764, 868, 28 },
   2641              { 768454923, 542167814, 1 }
   2642          };
   2643          
   2644          /*
   2645           * Checkup routine
   2646           */
   2647          int mbedtls_mpi_self_test(int verbose)
   2648          {
   2649              int ret, i;
   2650              mbedtls_mpi A, E, N, X, Y, U, V;
   2651          
   2652              mbedtls_mpi_init(&A); mbedtls_mpi_init(&E); mbedtls_mpi_init(&N); mbedtls_mpi_init(&X);
   2653              mbedtls_mpi_init(&Y); mbedtls_mpi_init(&U); mbedtls_mpi_init(&V);
   2654          
   2655              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&A, 16,
   2656                                                      "EFE021C2645FD1DC586E69184AF4A31E" \
   2657                                                      "D5F53E93B5F123FA41680867BA110131" \
   2658                                                      "944FE7952E2517337780CB0DB80E61AA" \
   2659                                                      "E7C8DDC6C5C6AADEB34EB38A2F40D5E6"));
   2660          
   2661              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&E, 16,
   2662                                                      "B2E7EFD37075B9F03FF989C7C5051C20" \
   2663                                                      "34D2A323810251127E7BF8625A4F49A5" \
   2664                                                      "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
   2665                                                      "5B5C25763222FEFCCFC38B832366C29E"));
   2666          
   2667              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&N, 16,
   2668                                                      "0066A198186C18C10B2F5ED9B522752A" \
   2669                                                      "9830B69916E535C8F047518A889A43A5" \
   2670                                                      "94B6BED27A168D31D4A52F88925AA8F5"));
   2671          
   2672              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&X, &A, &N));
   2673          
   2674              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2675                                                      "602AB7ECA597A3D6B56FF9829A5E8B85" \
   2676                                                      "9E857EA95A03512E2BAE7391688D264A" \
   2677                                                      "A5663B0341DB9CCFD2C4C5F421FEC814" \
   2678                                                      "8001B72E848A38CAE1C65F78E56ABDEF" \
   2679                                                      "E12D3C039B8A02D6BE593F0BBBDA56F1" \
   2680                                                      "ECF677152EF804370C1A305CAF3B5BF1" \
   2681                                                      "30879B56C61DE584A0F53A2447A51E"));
   2682          
   2683              if (verbose != 0) {
   2684                  mbedtls_printf("  MPI test #1 (mul_mpi): ");
   2685              }
   2686          
   2687              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0) {
   2688                  if (verbose != 0) {
   2689                      mbedtls_printf("failed\n");
   2690                  }
   2691          
   2692                  ret = 1;
   2693                  goto cleanup;
   2694              }
   2695          
   2696              if (verbose != 0) {
   2697                  mbedtls_printf("passed\n");
   2698              }
   2699          
   2700              MBEDTLS_MPI_CHK(mbedtls_mpi_div_mpi(&X, &Y, &A, &N));
   2701          
   2702              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2703                                                      "256567336059E52CAE22925474705F39A94"));
   2704          
   2705              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&V, 16,
   2706                                                      "6613F26162223DF488E9CD48CC132C7A" \
   2707                                                      "0AC93C701B001B092E4E5B9F73BCD27B" \
   2708                                                      "9EE50D0657C77F374E903CDFA4C642"));
   2709          
   2710              if (verbose != 0) {
   2711                  mbedtls_printf("  MPI test #2 (div_mpi): ");
   2712              }
   2713          
   2714              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0 ||
   2715                  mbedtls_mpi_cmp_mpi(&Y, &V) != 0) {
   2716                  if (verbose != 0) {
   2717                      mbedtls_printf("failed\n");
   2718                  }
   2719          
   2720                  ret = 1;
   2721                  goto cleanup;
   2722              }
   2723          
   2724              if (verbose != 0) {
   2725                  mbedtls_printf("passed\n");
   2726              }
   2727          
   2728              MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&X, &A, &E, &N, NULL));
   2729          
   2730              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2731                                                      "36E139AEA55215609D2816998ED020BB" \
   2732                                                      "BD96C37890F65171D948E9BC7CBAA4D9" \
   2733                                                      "325D24D6A3C12710F10A09FA08AB87"));
   2734          
   2735              if (verbose != 0) {
   2736                  mbedtls_printf("  MPI test #3 (exp_mod): ");
   2737              }
   2738          
   2739              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0) {
   2740                  if (verbose != 0) {
   2741                      mbedtls_printf("failed\n");
   2742                  }
   2743          
   2744                  ret = 1;
   2745                  goto cleanup;
   2746              }
   2747          
   2748              if (verbose != 0) {
   2749                  mbedtls_printf("passed\n");
   2750              }
   2751          
   2752              MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(&X, &A, &N));
   2753          
   2754              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&U, 16,
   2755                                                      "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
   2756                                                      "C3DBA76456363A10869622EAC2DD84EC" \
   2757                                                      "C5B8A74DAC4D09E03B5E0BE779F2DF61"));
   2758          
   2759              if (verbose != 0) {
   2760                  mbedtls_printf("  MPI test #4 (inv_mod): ");
   2761              }
   2762          
   2763              if (mbedtls_mpi_cmp_mpi(&X, &U) != 0) {
   2764                  if (verbose != 0) {
   2765                      mbedtls_printf("failed\n");
   2766                  }
   2767          
   2768                  ret = 1;
   2769                  goto cleanup;
   2770              }
   2771          
   2772              if (verbose != 0) {
   2773                  mbedtls_printf("passed\n");
   2774              }
   2775          
   2776              if (verbose != 0) {
   2777                  mbedtls_printf("  MPI test #5 (simple gcd): ");
   2778              }
   2779          
   2780              for (i = 0; i < GCD_PAIR_COUNT; i++) {
   2781                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&X, gcd_pairs[i][0]));
   2782                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&Y, gcd_pairs[i][1]));
   2783          
   2784                  MBEDTLS_MPI_CHK(mbedtls_mpi_gcd(&A, &X, &Y));
   2785          
   2786                  if (mbedtls_mpi_cmp_int(&A, gcd_pairs[i][2]) != 0) {
   2787                      if (verbose != 0) {
   2788                          mbedtls_printf("failed at %d\n", i);
   2789                      }
   2790          
   2791                      ret = 1;
   2792                      goto cleanup;
   2793                  }
   2794              }
   2795          
   2796              if (verbose != 0) {
   2797                  mbedtls_printf("passed\n");
   2798              }
   2799          
   2800          cleanup:
   2801          
   2802              if (ret != 0 && verbose != 0) {
   2803                  mbedtls_printf("Unexpected error, return code = %08X\n", (unsigned int) ret);
   2804              }
   2805          
   2806              mbedtls_mpi_free(&A); mbedtls_mpi_free(&E); mbedtls_mpi_free(&N); mbedtls_mpi_free(&X);
   2807              mbedtls_mpi_free(&Y); mbedtls_mpi_free(&U); mbedtls_mpi_free(&V);
   2808          
   2809              if (verbose != 0) {
   2810                  mbedtls_printf("\n");
   2811              }
   2812          
   2813              return ret;
   2814          }
   2815          
   2816          #endif /* MBEDTLS_SELF_TEST */
   2817          
   2818          #endif /* MBEDTLS_BIGNUM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   add_sub_mpi
        24   -> mbedtls_mpi_add_abs
        24   -> mbedtls_mpi_cmp_abs
        24   -> mbedtls_mpi_sub_abs
       0   mbedtls_ct_bool
       0   mbedtls_ct_compiler_opaque
       8   mbedtls_ct_uint_if
      24   mbedtls_mpi_add_abs
        24   -> mbedtls_mpi_copy
        24   -> mbedtls_mpi_core_add
        24   -> mbedtls_mpi_grow
      16   mbedtls_mpi_add_int
        16   -> mbedtls_mpi_add_mpi
       0   mbedtls_mpi_add_mpi
         0   -> add_sub_mpi
       0   mbedtls_mpi_bitlen
         0   -> mbedtls_mpi_core_bitlen
      16   mbedtls_mpi_cmp_abs
      16   mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_cmp_mpi
      16   mbedtls_mpi_cmp_mpi
      24   mbedtls_mpi_copy
        24   -> __aeabi_memclr
        24   -> __aeabi_memclr4
        24   -> __aeabi_memcpy4
        24   -> mbedtls_mpi_grow
      24   mbedtls_mpi_div_int
        24   -> mbedtls_mpi_div_mpi
      96   mbedtls_mpi_div_mpi
        96   -> mbedtls_mpi_add_mpi
        96   -> mbedtls_mpi_bitlen
        96   -> mbedtls_mpi_cmp_abs
        96   -> mbedtls_mpi_cmp_int
        96   -> mbedtls_mpi_cmp_mpi
        96   -> mbedtls_mpi_copy
        96   -> mbedtls_mpi_free
        96   -> mbedtls_mpi_grow
        96   -> mbedtls_mpi_init
        96   -> mbedtls_mpi_lset
        96   -> mbedtls_mpi_mul_int
        96   -> mbedtls_mpi_shift_l
        96   -> mbedtls_mpi_shift_r
        96   -> mbedtls_mpi_sub_mpi
        96   -> mbedtls_platform_zeroize
        96 __aeabi_uldivmod
     128   mbedtls_mpi_exp_mod
       128   -> __aeabi_memclr4
       128   -> mbedtls_mpi_add_mpi
       128   -> mbedtls_mpi_bitlen
       128   -> mbedtls_mpi_cmp_int
       128   -> mbedtls_mpi_cmp_mpi
       128   -> mbedtls_mpi_copy
       128   -> mbedtls_mpi_core_montmul_init
       128   -> mbedtls_mpi_free
       128   -> mbedtls_mpi_grow
       128   -> mbedtls_mpi_init
       128   -> mbedtls_mpi_lset
       128   -> mbedtls_mpi_mod_mpi
       128   -> mbedtls_mpi_shift_l
       128   -> mpi_montmul
       128   -> mpi_montred
       128   -> mpi_select
      24   mbedtls_mpi_fill_random
        24   -> mbedtls_mpi_core_fill_random
        24   -> mbedtls_mpi_resize_clear
       8   mbedtls_mpi_free
         8   -> mbedtls_zeroize_and_free
      40   mbedtls_mpi_gcd
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_cmp_mpi
        40   -> mbedtls_mpi_copy
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_get_bit
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_lsb
        40   -> mbedtls_mpi_shift_l
        40   -> mbedtls_mpi_shift_r
        40   -> mbedtls_mpi_sub_abs
       0   mbedtls_mpi_get_bit
      16   mbedtls_mpi_grow
        16   -> __aeabi_memcpy
        16   -> mbedtls_zeroize_and_free
        16   -> sl_calloc
       0   mbedtls_mpi_init
      96   mbedtls_mpi_inv_mod
        96   -> mbedtls_mpi_add_mpi
        96   -> mbedtls_mpi_cmp_int
        96   -> mbedtls_mpi_cmp_mpi
        96   -> mbedtls_mpi_copy
        96   -> mbedtls_mpi_free
        96   -> mbedtls_mpi_gcd
        96   -> mbedtls_mpi_init
        96   -> mbedtls_mpi_lset
        96   -> mbedtls_mpi_mod_mpi
        96   -> mbedtls_mpi_shift_r
        96   -> mbedtls_mpi_sub_mpi
       0   mbedtls_mpi_lsb
      16   mbedtls_mpi_lset
        16   -> __aeabi_memclr4
        16   -> mbedtls_mpi_grow
      32   mbedtls_mpi_lt_mpi_ct
        32   -> mbedtls_ct_bool
        32   -> mbedtls_mpi_core_lt_ct
      20   mbedtls_mpi_mod_int
      16   mbedtls_mpi_mod_mpi
        16   -> mbedtls_mpi_add_mpi
        16   -> mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_cmp_mpi
        16   -> mbedtls_mpi_div_mpi
        16   -> mbedtls_mpi_sub_mpi
      32   mbedtls_mpi_mul_int
        32   -> mbedtls_mpi_copy
        32   -> mbedtls_mpi_core_mla
        32   -> mbedtls_mpi_grow
         0   -> mbedtls_mpi_lset
      56   mbedtls_mpi_mul_mpi
        56   -> mbedtls_mpi_copy
        56   -> mbedtls_mpi_core_mul
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_grow
        56   -> mbedtls_mpi_init
        56   -> mbedtls_mpi_lset
      32   mbedtls_mpi_random
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_core_random
        32   -> mbedtls_mpi_resize_clear
      16   mbedtls_mpi_read_binary
         0   -> mbedtls_mpi_core_read_be
        16   -> mbedtls_mpi_resize_clear
      16   mbedtls_mpi_read_binary_le
         0   -> mbedtls_mpi_core_read_le
        16   -> mbedtls_mpi_resize_clear
      40   mbedtls_mpi_read_string
        40   -> mbedtls_mpi_add_int
        40   -> mbedtls_mpi_bitlen
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_grow
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_lset
        40   -> mbedtls_mpi_mul_int
        40   -> mpi_get_digit
        40   -> strlen
      16   mbedtls_mpi_resize_clear
        16   -> __aeabi_memclr4
        16   -> mbedtls_mpi_free
         0   -> mbedtls_mpi_grow
      24   mbedtls_mpi_safe_cond_assign
        24   -> mbedtls_ct_bool
        24   -> mbedtls_ct_uint_if
        24   -> mbedtls_mpi_core_cond_assign
        24   -> mbedtls_mpi_grow
      24   mbedtls_mpi_safe_cond_swap
        24   -> mbedtls_ct_bool
        24   -> mbedtls_ct_uint_if
        24   -> mbedtls_mpi_core_cond_swap
        24   -> mbedtls_mpi_grow
      24   mbedtls_mpi_set_bit
        24   -> mbedtls_mpi_grow
      16   mbedtls_mpi_shift_l
        16   -> mbedtls_mpi_bitlen
        16   -> mbedtls_mpi_core_shift_l
        16   -> mbedtls_mpi_grow
       8   mbedtls_mpi_shift_r
         8   -> mbedtls_mpi_core_shift_r
      16   mbedtls_mpi_shrink
        16   -> __aeabi_memcpy
         0   -> mbedtls_mpi_grow
        16   -> mbedtls_zeroize_and_free
        16   -> sl_calloc
       8   mbedtls_mpi_size
         8   -> mbedtls_mpi_bitlen
      24   mbedtls_mpi_sub_abs
        24   -> __aeabi_memclr
        24   -> __aeabi_memcpy
        24   -> mbedtls_mpi_core_sub
        24   -> mbedtls_mpi_core_sub_int
        24   -> mbedtls_mpi_grow
      16   mbedtls_mpi_sub_int
        16   -> mbedtls_mpi_sub_mpi
       0   mbedtls_mpi_sub_mpi
         0   -> add_sub_mpi
       8   mbedtls_mpi_swap
       0   mbedtls_mpi_write_binary
         0   -> mbedtls_mpi_core_write_be
       0   mbedtls_mpi_write_binary_le
         0   -> mbedtls_mpi_core_write_le
      56   mbedtls_mpi_write_string
        56   -> __aeabi_memmove
        56   -> mbedtls_mpi_bitlen
        56   -> mbedtls_mpi_cmp_int
        56   -> mbedtls_mpi_copy
        56   -> mbedtls_mpi_div_int
        56   -> mbedtls_mpi_free
        56   -> mbedtls_mpi_init
        56   -> mbedtls_mpi_mod_int
      12   mpi_get_digit
      32   mpi_montmul
        32   -> mbedtls_mpi_core_montmul
      32   mpi_montred
        32   -> mpi_montmul
      32   mpi_select
        32   -> mbedtls_ct_bool
        32   -> mbedtls_ct_compiler_opaque
        32   -> mbedtls_mpi_safe_cond_assign


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       6  ?Subroutine0
      22  ?Subroutine1
      14  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
       8  ?Subroutine13
       8  ?Subroutine14
      12  ?Subroutine15
      10  ?Subroutine16
      16  ?Subroutine17
      14  ?Subroutine2
      10  ?Subroutine3
       6  ?Subroutine4
      26  ?Subroutine5
      26  ?Subroutine6
       6  ?Subroutine7
      12  ?Subroutine8
      12  ?Subroutine9
      20  ?_0
      86  add_sub_mpi
      20  mbedtls_ct_bool
       8  mbedtls_ct_compiler_opaque
      18  mbedtls_ct_uint_if
     144  mbedtls_mpi_add_abs
      22  mbedtls_mpi_add_int
       4  mbedtls_mpi_add_mpi
       8  mbedtls_mpi_bitlen
      56  mbedtls_mpi_cmp_abs
      42  mbedtls_mpi_cmp_int
     108  mbedtls_mpi_cmp_mpi
     104  mbedtls_mpi_copy
      44  mbedtls_mpi_div_int
     788  mbedtls_mpi_div_mpi
     936  mbedtls_mpi_exp_mod
      46  mbedtls_mpi_fill_random
      30  mbedtls_mpi_free
     244  mbedtls_mpi_gcd
      32  mbedtls_mpi_get_bit
      52  mbedtls_mpi_grow
      12  mbedtls_mpi_init
     606  mbedtls_mpi_inv_mod
      40  mbedtls_mpi_lsb
      52  mbedtls_mpi_lset
     106  mbedtls_mpi_lt_mpi_ct
     118  mbedtls_mpi_mod_int
      96  mbedtls_mpi_mod_mpi
      88  mbedtls_mpi_mul_int
     202  mbedtls_mpi_mul_mpi
      58  mbedtls_mpi_random
      38  mbedtls_mpi_read_binary
      38  mbedtls_mpi_read_binary_le
     274  mbedtls_mpi_read_string
      52  mbedtls_mpi_resize_clear
      82  mbedtls_mpi_safe_cond_assign
      98  mbedtls_mpi_safe_cond_swap
      78  mbedtls_mpi_set_bit
      58  mbedtls_mpi_shift_l
      18  mbedtls_mpi_shift_r
      80  mbedtls_mpi_shrink
      12  mbedtls_mpi_size
     146  mbedtls_mpi_sub_abs
      22  mbedtls_mpi_sub_int
       6  mbedtls_mpi_sub_mpi
      30  mbedtls_mpi_swap
      12  mbedtls_mpi_write_binary
      12  mbedtls_mpi_write_binary_le
     338  mbedtls_mpi_write_string
      56  mpi_get_digit
      32  mpi_montmul
      34  mpi_montred
      68  mpi_select

 
 5'998 bytes in section .text
 
 5'998 bytes of CODE memory

Errors: none
Warnings: none
