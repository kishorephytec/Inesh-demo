###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:40
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_storage.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_storage.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_storage.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_storage.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\psa_crypto_storage.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_storage.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_storage.c
      1          /*
      2           *  PSA persistent key storage
      3           */
      4          /*
      5           *  Copyright The Mbed TLS Contributors
      6           *  SPDX-License-Identifier: Apache-2.0
      7           *
      8           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      9           *  not use this file except in compliance with the License.
     10           *  You may obtain a copy of the License at
     11           *
     12           *  http://www.apache.org/licenses/LICENSE-2.0
     13           *
     14           *  Unless required by applicable law or agreed to in writing, software
     15           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     16           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     17           *  See the License for the specific language governing permissions and
     18           *  limitations under the License.
     19           */
     20          
     21          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \        0x8   0x7841             LDRB     R1,[R0, #+1]
   \        0xA   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \        0xE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \        0x6   0x7002             STRB     R2,[R0, #+0]
   \        0x8   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \        0xC   0x7042             STRB     R2,[R0, #+1]
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xB001             ADD      SP,SP,#+4
   \        0x8   0x4608             MOV      R0,R1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0xB001             ADD      SP,SP,#+4
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_bswap32(uint32_t)
   \                     mbedtls_bswap32: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x0208             LSLS     R0,R1,#+8
   \        0x4   0xF400 0x007F      AND      R0,R0,#0xFF0000
   \        0x8   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \        0xC   0x0A0A             LSRS     R2,R1,#+8
   \        0xE   0xF402 0x427F      AND      R2,R2,#0xFF00
   \       0x12   0x4310             ORRS     R0,R2,R0
   \       0x14   0xEA40 0x6011      ORR      R0,R0,R1, LSR #+24
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     22          
     23          #if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C)
     24          
     25          #include <stdlib.h>
     26          #include <string.h>
     27          
     28          #include "psa/crypto.h"
     29          #include "psa_crypto_storage.h"
     30          #include "mbedtls/platform_util.h"
     31          
     32          #if defined(MBEDTLS_PSA_ITS_FILE_C)
     33          #include "psa_crypto_its.h"
     34          #else /* Native ITS implementation */
     35          #include "psa/error.h"
     36          #include "psa/internal_trusted_storage.h"
     37          #endif
     38          
     39          #include "mbedtls/platform.h"
     40          
     41          
     42          
     43          /****************************************************************/
     44          /* Key storage */
     45          /****************************************************************/
     46          
     47          /* Determine a file name (ITS file identifier) for the given key identifier.
     48           * The file name must be distinct from any file that is used for a purpose
     49           * other than storing a key. Currently, the only such file is the random seed
     50           * file whose name is PSA_CRYPTO_ITS_RANDOM_SEED_UID and whose value is
     51           * 0xFFFFFF52. */
     52          static psa_storage_uid_t psa_its_identifier_of_slot(mbedtls_svc_key_id_t key)
     53          {
     54          #if defined(MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER)
     55              /* Encode the owner in the upper 32 bits. This means that if
     56               * owner values are nonzero (as they are on a PSA platform),
     57               * no key file will ever have a value less than 0x100000000, so
     58               * the whole range 0..0xffffffff is available for non-key files. */
     59              uint32_t unsigned_owner_id = MBEDTLS_SVC_KEY_ID_GET_OWNER_ID(key);
     60              return ((uint64_t) unsigned_owner_id << 32) |
     61                     MBEDTLS_SVC_KEY_ID_GET_KEY_ID(key);
     62          #else
     63              /* Use the key id directly as a file name.
     64               * psa_is_key_id_valid() in psa_crypto_slot_management.c
     65               * is responsible for ensuring that key identifiers do not have a
     66               * value that is reserved for non-key files. */
     67              return key;
     68          #endif
     69          }
     70          
     71          /**
     72           * \brief Load persistent data for the given key slot number.
     73           *
     74           * This function reads data from a storage backend and returns the data in a
     75           * buffer.
     76           *
     77           * \param key               Persistent identifier of the key to be loaded. This
     78           *                          should be an occupied storage location.
     79           * \param[out] data         Buffer where the data is to be written.
     80           * \param data_size         Size of the \c data buffer in bytes.
     81           *
     82           * \retval #PSA_SUCCESS \emptydescription
     83           * \retval #PSA_ERROR_DATA_INVALID \emptydescription
     84           * \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
     85           * \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
     86           * \retval #PSA_ERROR_DOES_NOT_EXIST \emptydescription
     87           */
     88          static psa_status_t psa_crypto_storage_load(
     89              const mbedtls_svc_key_id_t key, uint8_t *data, size_t data_size)
     90          {
     91              psa_status_t status;
     92              psa_storage_uid_t data_identifier = psa_its_identifier_of_slot(key);
     93              struct psa_storage_info_t data_identifier_info;
     94              size_t data_length = 0;
     95          
     96              status = psa_its_get_info(data_identifier, &data_identifier_info);
     97              if (status  != PSA_SUCCESS) {
     98                  return status;
     99              }
    100          
    101              status = psa_its_get(data_identifier, 0, (uint32_t) data_size, data, &data_length);
    102              if (data_size  != data_length) {
    103                  return PSA_ERROR_DATA_INVALID;
    104              }
    105          
    106              return status;
    107          }
    108          

   \                                 In section .text, align 2, keep-with-next
    109          int psa_is_key_present_in_storage(const mbedtls_svc_key_id_t key)
    110          {
   \                     psa_is_key_present_in_storage: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    111              psa_status_t ret;
    112              psa_storage_uid_t data_identifier = psa_its_identifier_of_slot(key);
    113              struct psa_storage_info_t data_identifier_info;
    114          
    115              ret = psa_its_get_info(data_identifier, &data_identifier_info);
    116          
    117              if (ret == PSA_ERROR_DOES_NOT_EXIST) {
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x.... 0x....      BL       psa_its_get_info
   \        0xA   0xF110 0x0F8C      CMN      R0,#+140
   \        0xE   0xD101             BNE.N    ??psa_is_key_present_in_storage_0
    118                  return 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD0E             POP      {R1-R3,PC}
    119              }
    120              return 1;
   \                     ??psa_is_key_present_in_storage_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD0E             POP      {R1-R3,PC}
    121          }
    122          
    123          /**
    124           * \brief Store persistent data for the given key slot number.
    125           *
    126           * This function stores the given data buffer to a persistent storage.
    127           *
    128           * \param key           Persistent identifier of the key to be stored. This
    129           *                      should be an unoccupied storage location.
    130           * \param[in] data      Buffer containing the data to be stored.
    131           * \param data_length   The number of bytes
    132           *                      that make up the data.
    133           *
    134           * \retval #PSA_SUCCESS \emptydescription
    135           * \retval #PSA_ERROR_INSUFFICIENT_STORAGE \emptydescription
    136           * \retval #PSA_ERROR_ALREADY_EXISTS \emptydescription
    137           * \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    138           * \retval #PSA_ERROR_DATA_INVALID \emptydescription
    139           */
    140          static psa_status_t psa_crypto_storage_store(const mbedtls_svc_key_id_t key,
    141                                                       const uint8_t *data,
    142                                                       size_t data_length)
    143          {
    144              psa_status_t status;
    145              psa_storage_uid_t data_identifier = psa_its_identifier_of_slot(key);
    146              struct psa_storage_info_t data_identifier_info;
    147          
    148              if (psa_is_key_present_in_storage(key) == 1) {
    149                  return PSA_ERROR_ALREADY_EXISTS;
    150              }
    151          
    152              status = psa_its_set(data_identifier, (uint32_t) data_length, data, 0);
    153              if (status != PSA_SUCCESS) {
    154                  return PSA_ERROR_DATA_INVALID;
    155              }
    156          
    157              status = psa_its_get_info(data_identifier, &data_identifier_info);
    158              if (status != PSA_SUCCESS) {
    159                  goto exit;
    160              }
    161          
    162              if (data_identifier_info.size != data_length) {
    163                  status = PSA_ERROR_DATA_INVALID;
    164                  goto exit;
    165              }
    166          
    167          exit:
    168              if (status != PSA_SUCCESS) {
    169                  /* Remove the file in case we managed to create it but something
    170                   * went wrong. It's ok if the file doesn't exist. If the file exists
    171                   * but the removal fails, we're already reporting an error so there's
    172                   * nothing else we can do. */
    173                  (void) psa_its_remove(data_identifier);
    174              }
    175              return status;
    176          }
    177          

   \                                 In section .text, align 2, keep-with-next
    178          psa_status_t psa_destroy_persistent_key(const mbedtls_svc_key_id_t key)
    179          {
   \                     psa_destroy_persistent_key: (+1)
   \        0x0   0xB5DC             PUSH     {R2-R4,R6,R7,LR}
    180              psa_status_t ret;
    181              psa_storage_uid_t data_identifier = psa_its_identifier_of_slot(key);
   \        0x2   0x4604             MOV      R4,R0
    182              struct psa_storage_info_t data_identifier_info;
    183          
    184              ret = psa_its_get_info(data_identifier, &data_identifier_info);
    185              if (ret == PSA_ERROR_DOES_NOT_EXIST) {
   \        0x4   0x466A             MOV      R2,SP
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xF06F 0x078B      MVN      R7,#+139
   \        0xC   0x.... 0x....      BL       psa_its_get_info
   \       0x10   0x42B8             CMP      R0,R7
   \       0x12   0xD00C             BEQ.N    ??psa_destroy_persistent_key_0
    186                  return PSA_SUCCESS;
    187              }
    188          
    189              if (psa_its_remove(data_identifier) != PSA_SUCCESS) {
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0xF06F 0x0698      MVN      R6,#+152
   \       0x1C   0x.... 0x....      BL       psa_its_remove
   \       0x20   0xB918             CBNZ.N   R0,??psa_destroy_persistent_key_1
    190                  return PSA_ERROR_DATA_INVALID;
    191              }
    192          
    193              ret = psa_its_get_info(data_identifier, &data_identifier_info);
    194              if (ret != PSA_ERROR_DOES_NOT_EXIST) {
   \       0x22   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x26   0x42B8             CMP      R0,R7
   \       0x28   0xD001             BEQ.N    ??psa_destroy_persistent_key_0
    195                  return PSA_ERROR_DATA_INVALID;
   \                     ??psa_destroy_persistent_key_1: (+1)
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0xBDD6             POP      {R1,R2,R4,R6,R7,PC}
    196              }
    197          
    198              return PSA_SUCCESS;
   \                     ??psa_destroy_persistent_key_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBDD6             POP      {R1,R2,R4,R6,R7,PC}
    199          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x466A             MOV      R2,SP
   \                     ??Subroutine0_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x.... 0x....      B.W      psa_its_get_info
    200          
    201          /**
    202           * \brief Get data length for given key slot number.
    203           *
    204           * \param key               Persistent identifier whose stored data length
    205           *                          is to be obtained.
    206           * \param[out] data_length  The number of bytes that make up the data.
    207           *
    208           * \retval #PSA_SUCCESS \emptydescription
    209           * \retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
    210           * \retval #PSA_ERROR_DOES_NOT_EXIST \emptydescription
    211           * \retval #PSA_ERROR_DATA_CORRUPT \emptydescription
    212           */
    213          static psa_status_t psa_crypto_storage_get_data_length(
    214              const mbedtls_svc_key_id_t key,
    215              size_t *data_length)
    216          {
    217              psa_status_t status;
    218              psa_storage_uid_t data_identifier = psa_its_identifier_of_slot(key);
    219              struct psa_storage_info_t data_identifier_info;
    220          
    221              status = psa_its_get_info(data_identifier, &data_identifier_info);
    222              if (status != PSA_SUCCESS) {
    223                  return status;
    224              }
    225          
    226              *data_length = (size_t) data_identifier_info.size;
    227          
    228              return PSA_SUCCESS;
    229          }
    230          
    231          /**
    232           * Persistent key storage magic header.
    233           */
    234          #define PSA_KEY_STORAGE_MAGIC_HEADER "PSA\0KEY"
    235          #define PSA_KEY_STORAGE_MAGIC_HEADER_LENGTH (sizeof(PSA_KEY_STORAGE_MAGIC_HEADER))
    236          
    237          typedef struct {
    238              uint8_t magic[PSA_KEY_STORAGE_MAGIC_HEADER_LENGTH];
    239              uint8_t version[4];
    240              uint8_t lifetime[sizeof(psa_key_lifetime_t)];
    241              uint8_t type[2];
    242              uint8_t bits[2];
    243              uint8_t policy[sizeof(psa_key_policy_t)];
    244              uint8_t data_len[4];
    245              uint8_t key_data[];
    246          } psa_persistent_key_storage_format;
    247          

   \                                 In section .text, align 2, keep-with-next
    248          void psa_format_key_data_for_storage(const uint8_t *data,
    249                                               const size_t data_length,
    250                                               const psa_core_key_attributes_t *attr,
    251                                               uint8_t *storage_data)
    252          {
   \                     psa_format_key_data_for_storage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x460C             MOV      R4,R1
    253              psa_persistent_key_storage_format *storage_format =
    254                  (psa_persistent_key_storage_format *) storage_data;
    255          
    256              memcpy(storage_format->magic, PSA_KEY_STORAGE_MAGIC_HEADER,
    257                     PSA_KEY_STORAGE_MAGIC_HEADER_LENGTH);
   \        0x8   0x.... 0x....      ADR.W    R2,?_0
   \        0xC   0x6811             LDR      R1,[R2, #+0]
   \        0xE   0x461E             MOV      R6,R3
    258              MBEDTLS_PUT_UINT32_LE(0, storage_format->version, 0);
   \       0x10   0x.... 0x....      ADR.W    R7,mbedtls_byte_order_detector
   \       0x14   0x6031             STR      R1,[R6, #+0]
   \       0x16   0x6851             LDR      R1,[R2, #+4]
   \       0x18   0x4680             MOV      R8,R0
   \       0x1A   0x6071             STR      R1,[R6, #+4]
   \       0x1C   0x7839             LDRB     R1,[R7, #+0]
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xD104             BNE.N    ??psa_format_key_data_for_storage_0
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x.... 0x....      BL       mbedtls_bswap32
   \       0x28   0x4601             MOV      R1,R0
   \       0x2A   0xE000             B.N      ??psa_format_key_data_for_storage_1
   \                     ??psa_format_key_data_for_storage_0: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
   \                     ??psa_format_key_data_for_storage_1: (+1)
   \       0x2E   0xF106 0x0008      ADD      R0,R6,#+8
   \       0x32   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    259              MBEDTLS_PUT_UINT32_LE(attr->lifetime, storage_format->lifetime, 0);
   \       0x36   0x7839             LDRB     R1,[R7, #+0]
   \       0x38   0x6868             LDR      R0,[R5, #+4]
   \       0x3A   0x2901             CMP      R1,#+1
   \       0x3C   0xBF08             IT       EQ
   \       0x3E   0x.... 0x....      BLEQ     mbedtls_bswap32
   \       0x42   0x4601             MOV      R1,R0
   \       0x44   0xF106 0x000C      ADD      R0,R6,#+12
   \       0x48   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    260              MBEDTLS_PUT_UINT16_LE((uint16_t) attr->type, storage_format->type, 0);
   \       0x4C   0x7839             LDRB     R1,[R7, #+0]
   \       0x4E   0x8828             LDRH     R0,[R5, #+0]
   \       0x50   0x2901             CMP      R1,#+1
   \       0x52   0xBF03             ITTTE    EQ
   \       0x54   0x0A01             LSREQ    R1,R0,#+8
   \       0x56   0xEA41 0x2100      ORREQ    R1,R1,R0, LSL #+8
   \       0x5A   0xB289             UXTHEQ   R1,R1
   \       0x5C   0x4601             MOVNE    R1,R0
   \       0x5E   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x62   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    261              MBEDTLS_PUT_UINT16_LE((uint16_t) attr->bits, storage_format->bits, 0);
   \       0x66   0x7839             LDRB     R1,[R7, #+0]
   \       0x68   0x8868             LDRH     R0,[R5, #+2]
   \       0x6A   0x2901             CMP      R1,#+1
   \       0x6C   0xBF03             ITTTE    EQ
   \       0x6E   0x0A01             LSREQ    R1,R0,#+8
   \       0x70   0xEA41 0x2100      ORREQ    R1,R1,R0, LSL #+8
   \       0x74   0xB289             UXTHEQ   R1,R1
   \       0x76   0x4601             MOVNE    R1,R0
   \       0x78   0xF106 0x0012      ADD      R0,R6,#+18
   \       0x7C   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
    262              MBEDTLS_PUT_UINT32_LE(attr->policy.usage, storage_format->policy, 0);
   \       0x80   0x7839             LDRB     R1,[R7, #+0]
   \       0x82   0x68E8             LDR      R0,[R5, #+12]
   \       0x84   0x2901             CMP      R1,#+1
   \       0x86   0xBF08             IT       EQ
   \       0x88   0x.... 0x....      BLEQ     mbedtls_bswap32
   \       0x8C   0x4601             MOV      R1,R0
   \       0x8E   0xF106 0x0014      ADD      R0,R6,#+20
   \       0x92   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    263              MBEDTLS_PUT_UINT32_LE(attr->policy.alg, storage_format->policy, sizeof(uint32_t));
   \       0x96   0x7839             LDRB     R1,[R7, #+0]
   \       0x98   0x6928             LDR      R0,[R5, #+16]
   \       0x9A   0x2901             CMP      R1,#+1
   \       0x9C   0xBF08             IT       EQ
   \       0x9E   0x.... 0x....      BLEQ     mbedtls_bswap32
   \       0xA2   0x4601             MOV      R1,R0
   \       0xA4   0xF106 0x0018      ADD      R0,R6,#+24
   \       0xA8   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    264              MBEDTLS_PUT_UINT32_LE(attr->policy.alg2, storage_format->policy, 2 * sizeof(uint32_t));
   \       0xAC   0x7839             LDRB     R1,[R7, #+0]
   \       0xAE   0x6968             LDR      R0,[R5, #+20]
   \       0xB0   0x2901             CMP      R1,#+1
   \       0xB2   0xBF08             IT       EQ
   \       0xB4   0x.... 0x....      BLEQ     mbedtls_bswap32
   \       0xB8   0x4601             MOV      R1,R0
   \       0xBA   0xF106 0x001C      ADD      R0,R6,#+28
   \       0xBE   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    265              MBEDTLS_PUT_UINT32_LE(data_length, storage_format->data_len, 0);
   \       0xC2   0x7838             LDRB     R0,[R7, #+0]
   \       0xC4   0x2801             CMP      R0,#+1
   \       0xC6   0xD104             BNE.N    ??psa_format_key_data_for_storage_2
   \       0xC8   0x4620             MOV      R0,R4
   \       0xCA   0x.... 0x....      BL       mbedtls_bswap32
   \       0xCE   0x4601             MOV      R1,R0
   \       0xD0   0xE000             B.N      ??psa_format_key_data_for_storage_3
   \                     ??psa_format_key_data_for_storage_2: (+1)
   \       0xD2   0x4621             MOV      R1,R4
   \                     ??psa_format_key_data_for_storage_3: (+1)
   \       0xD4   0xF106 0x0020      ADD      R0,R6,#+32
   \       0xD8   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    266              memcpy(storage_format->key_data, data, data_length);
   \       0xDC   0x4622             MOV      R2,R4
   \       0xDE   0x4641             MOV      R1,R8
   \       0xE0   0xF106 0x0024      ADD      R0,R6,#+36
   \       0xE4   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xE8   0x.... 0x....      B.W      __aeabi_memcpy
    267          }
    268          
    269          static psa_status_t check_magic_header(const uint8_t *data)
    270          {
    271              if (memcmp(data, PSA_KEY_STORAGE_MAGIC_HEADER,
    272                         PSA_KEY_STORAGE_MAGIC_HEADER_LENGTH) != 0) {
    273                  return PSA_ERROR_DATA_INVALID;
    274              }
    275              return PSA_SUCCESS;
    276          }
    277          

   \                                 In section .text, align 4, keep-with-next
    278          psa_status_t psa_parse_key_data_from_storage(const uint8_t *storage_data,
    279                                                       size_t storage_data_length,
    280                                                       uint8_t **key_data,
    281                                                       size_t *key_data_length,
    282                                                       psa_core_key_attributes_t *attr)
    283          {
   \                     psa_parse_key_data_from_storage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461C             MOV      R4,R3
    284              psa_status_t status;
    285              const psa_persistent_key_storage_format *storage_format =
    286                  (const psa_persistent_key_storage_format *) storage_data;
    287              uint32_t version;
    288          
    289              if (storage_data_length < sizeof(*storage_format)) {
   \        0xC   0x2D24             CMP      R5,#+36
   \        0xE   0xD305             BCC.N    ??psa_parse_key_data_from_storage_0
    290                  return PSA_ERROR_DATA_INVALID;
    291              }
    292          
    293              status = check_magic_header(storage_data);
   \       0x10   0xF05F 0x0208      MOVS.W   R2,#+8
   \       0x14   0x....             ADR.N    R1,?_0
   \       0x16   0x.... 0x....      BL       memcmp
   \       0x1A   0xB110             CBZ.N    R0,??psa_parse_key_data_from_storage_1
    294              if (status != PSA_SUCCESS) {
    295                  return status;
   \                     ??psa_parse_key_data_from_storage_0: (+1)
   \       0x1C   0xF06F 0x0098      MVN      R0,#+152
   \       0x20   0xE088             B.N      ??psa_parse_key_data_from_storage_2
    296              }
    297          
    298              version = MBEDTLS_GET_UINT32_LE(storage_format->version, 0);
   \                     ??psa_parse_key_data_from_storage_1: (+1)
   \       0x22   0xBF00             Nop
   \       0x24   0x....             ADR.N    R6,mbedtls_byte_order_detector
   \       0x26   0x7830             LDRB     R0,[R6, #+0]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xF108 0x0008      ADD      R0,R8,#+8
   \       0x2E   0xD104             BNE.N    ??psa_parse_key_data_from_storage_3
   \       0x30   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x34   0x.... 0x....      BL       mbedtls_bswap32
   \       0x38   0xE001             B.N      ??psa_parse_key_data_from_storage_4
   \                     ??psa_parse_key_data_from_storage_3: (+1)
   \       0x3A   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
    299              if (version != 0) {
   \                     ??psa_parse_key_data_from_storage_4: (+1)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1EC             BNE.N    ??psa_parse_key_data_from_storage_0
    300                  return PSA_ERROR_DATA_INVALID;
    301              }
    302          
    303              *key_data_length = MBEDTLS_GET_UINT32_LE(storage_format->data_len, 0);
   \       0x42   0x7830             LDRB     R0,[R6, #+0]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xF108 0x0020      ADD      R0,R8,#+32
   \       0x4A   0xD104             BNE.N    ??psa_parse_key_data_from_storage_5
   \       0x4C   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x50   0x.... 0x....      BL       mbedtls_bswap32
   \       0x54   0xE001             B.N      ??psa_parse_key_data_from_storage_6
   \                     ??psa_parse_key_data_from_storage_5: (+1)
   \       0x56   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
    304              if (*key_data_length > (storage_data_length - sizeof(*storage_format)) ||
    305                  *key_data_length > PSA_CRYPTO_MAX_STORAGE_SIZE) {
   \                     ??psa_parse_key_data_from_storage_6: (+1)
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x3D24             SUBS     R5,R5,#+36
   \       0x5E   0x6020             STR      R0,[R4, #+0]
   \       0x60   0x428D             CMP      R5,R1
   \       0x62   0xD3DB             BCC.N    ??psa_parse_key_data_from_storage_0
   \       0x64   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0x68   0xD2D8             BCS.N    ??psa_parse_key_data_from_storage_0
    306                  return PSA_ERROR_DATA_INVALID;
    307              }
    308          
    309              if (*key_data_length == 0) {
   \       0x6A   0xB911             CBNZ.N   R1,??psa_parse_key_data_from_storage_7
    310                  *key_data = NULL;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x6038             STR      R0,[R7, #+0]
   \       0x70   0xE00C             B.N      ??psa_parse_key_data_from_storage_8
    311              } else {
    312                  *key_data = mbedtls_calloc(1, *key_data_length);
   \                     ??psa_parse_key_data_from_storage_7: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x.... 0x....      BL       sl_calloc
   \       0x78   0x6038             STR      R0,[R7, #+0]
    313                  if (*key_data == NULL) {
   \       0x7A   0xB910             CBNZ.N   R0,??psa_parse_key_data_from_storage_9
    314                      return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x7C   0xF06F 0x008C      MVN      R0,#+140
   \       0x80   0xE058             B.N      ??psa_parse_key_data_from_storage_2
    315                  }
    316                  memcpy(*key_data, storage_format->key_data, *key_data_length);
   \                     ??psa_parse_key_data_from_storage_9: (+1)
   \       0x82   0x6822             LDR      R2,[R4, #+0]
   \       0x84   0xF108 0x0124      ADD      R1,R8,#+36
   \       0x88   0x.... 0x....      BL       __aeabi_memcpy
    317              }
    318          
    319              attr->lifetime = MBEDTLS_GET_UINT32_LE(storage_format->lifetime, 0);
   \                     ??psa_parse_key_data_from_storage_8: (+1)
   \       0x8C   0x7830             LDRB     R0,[R6, #+0]
   \       0x8E   0x2801             CMP      R0,#+1
   \       0x90   0xF108 0x000C      ADD      R0,R8,#+12
   \       0x94   0xD104             BNE.N    ??psa_parse_key_data_from_storage_10
   \       0x96   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x9A   0x.... 0x....      BL       mbedtls_bswap32
   \       0x9E   0xE001             B.N      ??psa_parse_key_data_from_storage_11
   \                     ??psa_parse_key_data_from_storage_10: (+1)
   \       0xA0   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \                     ??psa_parse_key_data_from_storage_11: (+1)
   \       0xA4   0x9C06             LDR      R4,[SP, #+24]
   \       0xA6   0x6060             STR      R0,[R4, #+4]
    320              attr->type = MBEDTLS_GET_UINT16_LE(storage_format->type, 0);
   \       0xA8   0x7830             LDRB     R0,[R6, #+0]
   \       0xAA   0x2801             CMP      R0,#+1
   \       0xAC   0xF108 0x0010      ADD      R0,R8,#+16
   \       0xB0   0xD105             BNE.N    ??psa_parse_key_data_from_storage_12
   \       0xB2   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0xB6   0x0A01             LSRS     R1,R0,#+8
   \       0xB8   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \       0xBC   0xE002             B.N      ??psa_parse_key_data_from_storage_13
   \                     ??psa_parse_key_data_from_storage_12: (+1)
   \       0xBE   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0xC2   0x4601             MOV      R1,R0
   \                     ??psa_parse_key_data_from_storage_13: (+1)
   \       0xC4   0x8021             STRH     R1,[R4, #+0]
    321              attr->bits = MBEDTLS_GET_UINT16_LE(storage_format->bits, 0);
   \       0xC6   0x7830             LDRB     R0,[R6, #+0]
   \       0xC8   0x2801             CMP      R0,#+1
   \       0xCA   0xF108 0x0012      ADD      R0,R8,#+18
   \       0xCE   0xD105             BNE.N    ??psa_parse_key_data_from_storage_14
   \       0xD0   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0xD4   0x0A01             LSRS     R1,R0,#+8
   \       0xD6   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \       0xDA   0xE002             B.N      ??psa_parse_key_data_from_storage_15
   \                     ??psa_parse_key_data_from_storage_14: (+1)
   \       0xDC   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0xE0   0x4601             MOV      R1,R0
   \                     ??psa_parse_key_data_from_storage_15: (+1)
   \       0xE2   0x8061             STRH     R1,[R4, #+2]
    322              attr->policy.usage = MBEDTLS_GET_UINT32_LE(storage_format->policy, 0);
   \       0xE4   0x7830             LDRB     R0,[R6, #+0]
   \       0xE6   0x2801             CMP      R0,#+1
   \       0xE8   0xF108 0x0014      ADD      R0,R8,#+20
   \       0xEC   0xD104             BNE.N    ??psa_parse_key_data_from_storage_16
   \       0xEE   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0xF2   0x.... 0x....      BL       mbedtls_bswap32
   \       0xF6   0xE001             B.N      ??psa_parse_key_data_from_storage_17
   \                     ??psa_parse_key_data_from_storage_16: (+1)
   \       0xF8   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \                     ??psa_parse_key_data_from_storage_17: (+1)
   \       0xFC   0x60E0             STR      R0,[R4, #+12]
    323              attr->policy.alg = MBEDTLS_GET_UINT32_LE(storage_format->policy, sizeof(uint32_t));
   \       0xFE   0x7830             LDRB     R0,[R6, #+0]
   \      0x100   0x2801             CMP      R0,#+1
   \      0x102   0xF108 0x0018      ADD      R0,R8,#+24
   \      0x106   0xD104             BNE.N    ??psa_parse_key_data_from_storage_18
   \      0x108   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \      0x10C   0x.... 0x....      BL       mbedtls_bswap32
   \      0x110   0xE001             B.N      ??psa_parse_key_data_from_storage_19
   \                     ??psa_parse_key_data_from_storage_18: (+1)
   \      0x112   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \                     ??psa_parse_key_data_from_storage_19: (+1)
   \      0x116   0x6120             STR      R0,[R4, #+16]
    324              attr->policy.alg2 = MBEDTLS_GET_UINT32_LE(storage_format->policy, 2 * sizeof(uint32_t));
   \      0x118   0x7830             LDRB     R0,[R6, #+0]
   \      0x11A   0x2801             CMP      R0,#+1
   \      0x11C   0xF108 0x001C      ADD      R0,R8,#+28
   \      0x120   0xD104             BNE.N    ??psa_parse_key_data_from_storage_20
   \      0x122   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \      0x126   0x.... 0x....      BL       mbedtls_bswap32
   \      0x12A   0xE001             B.N      ??psa_parse_key_data_from_storage_21
   \                     ??psa_parse_key_data_from_storage_20: (+1)
   \      0x12C   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \                     ??psa_parse_key_data_from_storage_21: (+1)
   \      0x130   0x6160             STR      R0,[R4, #+20]
    325          
    326              return PSA_SUCCESS;
   \      0x132   0x2000             MOVS     R0,#+0
   \                     ??psa_parse_key_data_from_storage_2: (+1)
   \      0x134   0xE8BD 0x81F0      POP      {R4-R8,PC}
    327          }
    328          

   \                                 In section .text, align 2, keep-with-next
    329          psa_status_t psa_save_persistent_key(const psa_core_key_attributes_t *attr,
    330                                               const uint8_t *data,
    331                                               const size_t data_length)
    332          {
   \                     psa_save_persistent_key: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4615             MOV      R5,R2
    333              size_t storage_data_length;
    334              uint8_t *storage_data;
    335              psa_status_t status;
    336          
    337              /* All keys saved to persistent storage always have a key context */
    338              if (data == NULL || data_length == 0) {
   \        0xA   0xBF14             ITE      NE
   \        0xC   0x2D00             CMPNE    R5,#+0
   \        0xE   0xF06F 0x0086      MVNEQ    R0,#+134
    339                  return PSA_ERROR_INVALID_ARGUMENT;
   \       0x12   0xD03E             BEQ.N    ??psa_save_persistent_key_0
    340              }
    341          
    342              if (data_length > PSA_CRYPTO_MAX_STORAGE_SIZE) {
   \       0x14   0xF5B5 0x5F00      CMP      R5,#+8192
   \       0x18   0xBF28             IT       CS
   \       0x1A   0xF06F 0x008D      MVNCS    R0,#+141
    343                  return PSA_ERROR_INSUFFICIENT_STORAGE;
   \       0x1E   0xD238             BCS.N    ??psa_save_persistent_key_0
    344              }
    345              storage_data_length = data_length + sizeof(psa_persistent_key_storage_format);
   \       0x20   0xF105 0x0824      ADD      R8,R5,#+36
    346          
    347              storage_data = mbedtls_calloc(1, storage_data_length);
   \       0x24   0x4641             MOV      R1,R8
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x.... 0x....      BL       sl_calloc
   \       0x2C   0x0006             MOVS     R6,R0
    348              if (storage_data == NULL) {
   \       0x2E   0xBF08             IT       EQ
   \       0x30   0xF06F 0x008C      MVNEQ    R0,#+140
    349                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x34   0xD02D             BEQ.N    ??psa_save_persistent_key_0
    350              }
    351          
    352              psa_format_key_data_for_storage(data, data_length, attr, storage_data);
   \       0x36   0x4633             MOV      R3,R6
   \       0x38   0x463A             MOV      R2,R7
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       psa_format_key_data_for_storage
    353          
    354              status = psa_crypto_storage_store(attr->id,
    355                                                storage_data, storage_data_length);
   \       0x42   0x68BC             LDR      R4,[R7, #+8]
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       psa_is_key_present_in_storage
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xBF08             IT       EQ
   \       0x4E   0xF06F 0x078A      MVNEQ    R7,#+138
   \       0x52   0xD019             BEQ.N    ??psa_save_persistent_key_1
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \       0x58   0x4633             MOV      R3,R6
   \       0x5A   0x4642             MOV      R2,R8
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0xF06F 0x0598      MVN      R5,#+152
   \       0x64   0x.... 0x....      BL       psa_its_set
   \       0x68   0xB108             CBZ.N    R0,??psa_save_persistent_key_2
   \       0x6A   0x462F             MOV      R7,R5
   \       0x6C   0xE00C             B.N      ??psa_save_persistent_key_1
   \                     ??psa_save_persistent_key_2: (+1)
   \       0x6E   0xAA01             ADD      R2,SP,#+4
   \       0x70   0x.... 0x....      BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x74   0x0007             MOVS     R7,R0
   \       0x76   0xD103             BNE.N    ??psa_save_persistent_key_3
   \       0x78   0x9801             LDR      R0,[SP, #+4]
   \       0x7A   0x4540             CMP      R0,R8
   \       0x7C   0xD004             BEQ.N    ??psa_save_persistent_key_1
   \       0x7E   0x462F             MOV      R7,R5
   \                     ??psa_save_persistent_key_3: (+1)
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0x2100             MOVS     R1,#+0
   \       0x84   0x.... 0x....      BL       psa_its_remove
    356          
    357              mbedtls_zeroize_and_free(storage_data, storage_data_length);
   \                     ??psa_save_persistent_key_1: (+1)
   \       0x88   0x4641             MOV      R1,R8
   \       0x8A   0x4630             MOV      R0,R6
   \       0x8C   0x.... 0x....      BL       mbedtls_zeroize_and_free
    358          
    359              return status;
   \       0x90   0x4638             MOV      R0,R7
   \                     ??psa_save_persistent_key_0: (+1)
   \       0x92   0xB004             ADD      SP,SP,#+16
   \       0x94   0xE8BD 0x81F0      POP      {R4-R8,PC}
    360          }
    361          

   \                                 In section .text, align 2, keep-with-next
    362          void psa_free_persistent_key_data(uint8_t *key_data, size_t key_data_length)
    363          {
    364              mbedtls_zeroize_and_free(key_data, key_data_length);
   \                     psa_free_persistent_key_data: (+1)
   \        0x0   0x.... 0x....      B.W      mbedtls_zeroize_and_free
    365          }
    366          

   \                                 In section .text, align 2, keep-with-next
    367          psa_status_t psa_load_persistent_key(psa_core_key_attributes_t *attr,
    368                                               uint8_t **data,
    369                                               size_t *data_length)
    370          {
   \                     psa_load_persistent_key: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4605             MOV      R5,R0
    371              psa_status_t status = PSA_SUCCESS;
    372              uint8_t *loaded_data;
    373              size_t storage_data_length = 0;
    374              mbedtls_svc_key_id_t key = attr->id;
   \        0x8   0x68AC             LDR      R4,[R5, #+8]
   \        0xA   0x4689             MOV      R9,R1
   \        0xC   0x4617             MOV      R7,R2
    375          
    376              status = psa_crypto_storage_get_data_length(key, &storage_data_length);
   \        0xE   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD139             BNE.N    ??psa_load_persistent_key_0
   \       0x16   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    377              if (status != PSA_SUCCESS) {
    378                  return status;
    379              }
    380          
    381              loaded_data = mbedtls_calloc(1, storage_data_length);
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x4641             MOV      R1,R8
   \       0x1E   0x.... 0x....      BL       sl_calloc
   \       0x22   0x0006             MOVS     R6,R0
    382          
    383              if (loaded_data == NULL) {
   \       0x24   0xBF08             IT       EQ
   \       0x26   0xF06F 0x008C      MVNEQ    R0,#+140
    384                  return PSA_ERROR_INSUFFICIENT_MEMORY;
   \       0x2A   0xD02E             BEQ.N    ??psa_load_persistent_key_0
    385              }
    386          
    387              status = psa_crypto_storage_load(key, loaded_data, storage_data_length);
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   \       0x30   0xAA03             ADD      R2,SP,#+12
   \       0x32   0x.... 0x....      BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x36   0xB108             CBZ.N    R0,??psa_load_persistent_key_1
   \       0x38   0x4604             MOV      R4,R0
   \       0x3A   0xE021             B.N      ??psa_load_persistent_key_2
   \                     ??psa_load_persistent_key_1: (+1)
   \       0x3C   0xA802             ADD      R0,SP,#+8
   \       0x3E   0x9001             STR      R0,[SP, #+4]
   \       0x40   0x9600             STR      R6,[SP, #+0]
   \       0x42   0x4643             MOV      R3,R8
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x.... 0x....      BL       psa_its_get
   \       0x4E   0x4604             MOV      R4,R0
   \       0x50   0x9802             LDR      R0,[SP, #+8]
   \       0x52   0x4580             CMP      R8,R0
   \       0x54   0xBF18             IT       NE
   \       0x56   0xF06F 0x0498      MVNNE    R4,#+152
   \       0x5A   0xD111             BNE.N    ??psa_load_persistent_key_2
    388              if (status != PSA_SUCCESS) {
   \       0x5C   0xB984             CBNZ.N   R4,??psa_load_persistent_key_2
    389                  goto exit;
    390              }
    391          
    392              status = psa_parse_key_data_from_storage(loaded_data, storage_data_length,
    393                                                       data, data_length, attr);
   \       0x5E   0x9500             STR      R5,[SP, #+0]
   \       0x60   0x463B             MOV      R3,R7
   \       0x62   0x464A             MOV      R2,R9
   \       0x64   0x4641             MOV      R1,R8
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0x.... 0x....      BL       psa_parse_key_data_from_storage
   \       0x6C   0x0004             MOVS     R4,R0
    394          
    395              /* All keys saved to persistent storage always have a key context */
    396              if (status == PSA_SUCCESS &&
    397                  (*data == NULL || *data_length == 0)) {
   \       0x6E   0xD107             BNE.N    ??psa_load_persistent_key_2
   \       0x70   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xBF1A             ITTE     NE
   \       0x78   0x6839             LDRNE    R1,[R7, #+0]
   \       0x7A   0x2900             CMPNE    R1,#+0
   \       0x7C   0xF06F 0x0491      MVNEQ    R4,#+145
    398                  status = PSA_ERROR_STORAGE_FAILURE;
    399              }
    400          
    401          exit:
    402              mbedtls_zeroize_and_free(loaded_data, storage_data_length);
   \                     ??psa_load_persistent_key_2: (+1)
   \       0x80   0x4641             MOV      R1,R8
   \       0x82   0x4630             MOV      R0,R6
   \       0x84   0x.... 0x....      BL       mbedtls_zeroize_and_free
    403              return status;
   \       0x88   0x4620             MOV      R0,R4
   \                     ??psa_load_persistent_key_0: (+1)
   \       0x8A   0xB005             ADD      SP,SP,#+20
   \       0x8C   0xE8BD 0x83F0      POP      {R4-R9,PC}
    404          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x50 0x53          DC8 0x50, 0x53, 0x41, 0, 0x4B, 0x45, 0x59, 0
   \              0x41 0x00    
   \              0x4B 0x45    
   \              0x59 0x00
    405          
    406          
    407          
    408          /****************************************************************/
    409          /* Transactions */
    410          /****************************************************************/
    411          
    412          #if defined(PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS)
    413          
    414          psa_crypto_transaction_t psa_crypto_transaction;
    415          
    416          psa_status_t psa_crypto_save_transaction(void)
    417          {
    418              struct psa_storage_info_t p_info;
    419              psa_status_t status;
    420              status = psa_its_get_info(PSA_CRYPTO_ITS_TRANSACTION_UID, &p_info);
    421              if (status == PSA_SUCCESS) {
    422                  /* This shouldn't happen: we're trying to start a transaction while
    423                   * there is still a transaction that hasn't been replayed. */
    424                  return PSA_ERROR_CORRUPTION_DETECTED;
    425              } else if (status != PSA_ERROR_DOES_NOT_EXIST) {
    426                  return status;
    427              }
    428              return psa_its_set(PSA_CRYPTO_ITS_TRANSACTION_UID,
    429                                 sizeof(psa_crypto_transaction),
    430                                 &psa_crypto_transaction,
    431                                 0);
    432          }
    433          
    434          psa_status_t psa_crypto_load_transaction(void)
    435          {
    436              psa_status_t status;
    437              size_t length;
    438              status = psa_its_get(PSA_CRYPTO_ITS_TRANSACTION_UID, 0,
    439                                   sizeof(psa_crypto_transaction),
    440                                   &psa_crypto_transaction, &length);
    441              if (status != PSA_SUCCESS) {
    442                  return status;
    443              }
    444              if (length != sizeof(psa_crypto_transaction)) {
    445                  return PSA_ERROR_DATA_INVALID;
    446              }
    447              return PSA_SUCCESS;
    448          }
    449          
    450          psa_status_t psa_crypto_stop_transaction(void)
    451          {
    452              psa_status_t status = psa_its_remove(PSA_CRYPTO_ITS_TRANSACTION_UID);
    453              /* Whether or not updating the storage succeeded, the transaction is
    454               * finished now. It's too late to go back, so zero out the in-memory
    455               * data. */
    456              memset(&psa_crypto_transaction, 0, sizeof(psa_crypto_transaction));
    457              return status;
    458          }
    459          
    460          #endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */
    461          
    462          
    463          
    464          /****************************************************************/
    465          /* Random generator state */
    466          /****************************************************************/
    467          
    468          #if defined(MBEDTLS_PSA_INJECT_ENTROPY)
    469          psa_status_t mbedtls_psa_storage_inject_entropy(const unsigned char *seed,
    470                                                          size_t seed_size)
    471          {
    472              psa_status_t status;
    473              struct psa_storage_info_t p_info;
    474          
    475              status = psa_its_get_info(PSA_CRYPTO_ITS_RANDOM_SEED_UID, &p_info);
    476          
    477              if (PSA_ERROR_DOES_NOT_EXIST == status) { /* No seed exists */
    478                  status = psa_its_set(PSA_CRYPTO_ITS_RANDOM_SEED_UID, seed_size, seed, 0);
    479              } else if (PSA_SUCCESS == status) {
    480                  /* You should not be here. Seed needs to be injected only once */
    481                  status = PSA_ERROR_NOT_PERMITTED;
    482              }
    483              return status;
    484          }
    485          #endif /* MBEDTLS_PSA_INJECT_ENTROPY */
    486          
    487          
    488          
    489          /****************************************************************/
    490          /* The end */
    491          /****************************************************************/
    492          
    493          #endif /* MBEDTLS_PSA_CRYPTO_STORAGE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_bswap32
       4   mbedtls_get_unaligned_uint16
       4   mbedtls_get_unaligned_uint32
       4   mbedtls_put_unaligned_uint16
       4   mbedtls_put_unaligned_uint32
      24   psa_destroy_persistent_key
        24   -> psa_its_get_info
        24   -> psa_its_remove
      24   psa_format_key_data_for_storage
         0   -> __aeabi_memcpy
        24   -> mbedtls_bswap32
        24   -> mbedtls_put_unaligned_uint16
        24   -> mbedtls_put_unaligned_uint32
       0   psa_free_persistent_key_data
         0   -> mbedtls_zeroize_and_free
      16   psa_is_key_present_in_storage
        16   -> psa_its_get_info
      48   psa_load_persistent_key
        48   -> mbedtls_zeroize_and_free
        48   -> psa_its_get
        48   -> psa_its_get_info
        48   -> psa_parse_key_data_from_storage
        48   -> sl_calloc
      24   psa_parse_key_data_from_storage
        24   -> __aeabi_memcpy
        24   -> mbedtls_bswap32
        24   -> mbedtls_get_unaligned_uint16
        24   -> mbedtls_get_unaligned_uint32
        24   -> memcmp
        24   -> sl_calloc
      40   psa_save_persistent_key
        40   -> mbedtls_zeroize_and_free
        40   -> psa_format_key_data_for_storage
        40   -> psa_is_key_present_in_storage
        40   -> psa_its_get_info
        40   -> psa_its_remove
        40   -> psa_its_set
        40   -> sl_calloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?Subroutine0
       8  ?_0
      26  mbedtls_bswap32
       2  mbedtls_byte_order_detector
      22  mbedtls_get_unaligned_uint16
      12  mbedtls_get_unaligned_uint32
      18  mbedtls_put_unaligned_uint16
       8  mbedtls_put_unaligned_uint32
      50  psa_destroy_persistent_key
     236  psa_format_key_data_for_storage
       4  psa_free_persistent_key_data
      24  psa_is_key_present_in_storage
     144  psa_load_persistent_key
     312  psa_parse_key_data_from_storage
     152  psa_save_persistent_key

 
 1'028 bytes in section .text
 
 968 bytes of CODE memory (+ 60 bytes shared)

Errors: none
Warnings: none
