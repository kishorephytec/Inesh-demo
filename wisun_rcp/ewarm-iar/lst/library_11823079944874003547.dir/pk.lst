###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:32
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pk.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pk.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pk.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pk.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\pk.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pk.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pk.c
      1          /*
      2           *  Public Key abstraction layer
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #if defined(MBEDTLS_PK_C)
     23          #include "mbedtls/pk.h"
     24          #include "pk_wrap.h"
     25          #include "pkwrite.h"
     26          #include "pk_internal.h"
     27          
     28          #include "mbedtls/platform_util.h"
     29          #include "mbedtls/error.h"
     30          
     31          #if defined(MBEDTLS_RSA_C)
     32          #include "mbedtls/rsa.h"
     33          #endif
     34          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
     35          #include "mbedtls/ecp.h"
     36          #endif
     37          #if defined(MBEDTLS_ECDSA_C)
     38          #include "mbedtls/ecdsa.h"
     39          #endif
     40          
     41          #if defined(MBEDTLS_PSA_CRYPTO_C)
     42          #include "psa_util_internal.h"
     43          #include "md_psa.h"
     44          #endif
     45          
     46          #include <limits.h>
     47          #include <stdint.h>
     48          
     49          /*
     50           * Initialise a mbedtls_pk_context
     51           */

   \                                 In section .text, align 2, keep-with-next
     52          void mbedtls_pk_init(mbedtls_pk_context *ctx)
     53          {
     54              ctx->pk_info = NULL;
   \                     mbedtls_pk_init: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x6003             STR      R3,[R0, #+0]
     55              ctx->pk_ctx = NULL;
   \        0x4   0x6043             STR      R3,[R0, #+4]
     56          #if defined(MBEDTLS_PSA_CRYPTO_C)
     57              ctx->priv_id = MBEDTLS_SVC_KEY_ID_INIT;
   \        0x6   0x6083             STR      R3,[R0, #+8]
     58          #endif /* MBEDTLS_PSA_CRYPTO_C */
     59          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
     60              memset(ctx->pub_raw, 0, sizeof(ctx->pub_raw));
     61              ctx->pub_raw_len = 0;
     62              ctx->ec_family = 0;
     63              ctx->ec_bits = 0;
     64          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
     65          }
   \        0x8   0x4770             BX       LR
     66          
     67          /*
     68           * Free (the components of) a mbedtls_pk_context
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          void mbedtls_pk_free(mbedtls_pk_context *ctx)
     71          {
   \                     mbedtls_pk_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     72              if (ctx == NULL) {
   \        0x4   0xD00C             BEQ.N    ??mbedtls_pk_free_0
     73                  return;
     74              }
     75          
     76              if ((ctx->pk_info != NULL) && (ctx->pk_info->ctx_free_func != NULL)) {
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xBF1F             ITTTT    NE
   \        0xC   0x6A81             LDRNE    R1,[R0, #+40]
   \        0xE   0x2900             CMPNE    R1,#+0
     77                  ctx->pk_info->ctx_free_func(ctx->pk_ctx);
   \       0x10   0x6860             LDRNE    R0,[R4, #+4]
   \       0x12   0x4788             BLXNE    R1
     78              }
     79          
     80          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
     81              /* The ownership of the priv_id key for opaque keys is external of the PK
     82               * module. It's the user responsibility to clear it after use. */
     83              if ((ctx->pk_info != NULL) && (ctx->pk_info->type != MBEDTLS_PK_OPAQUE)) {
     84                  psa_destroy_key(ctx->priv_id);
     85              }
     86          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
     87          
     88              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_pk_context));
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x21A0             MOVS     R1,#+160
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x.... 0x....      B.W      mbedtls_platform_zeroize
   \                     ??mbedtls_pk_free_0: (+1)
   \       0x20   0xBD10             POP      {R4,PC}
     89          }
     90          
     91          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
     92          /*
     93           * Initialize a restart context
     94           */
     95          void mbedtls_pk_restart_init(mbedtls_pk_restart_ctx *ctx)
     96          {
     97              ctx->pk_info = NULL;
     98              ctx->rs_ctx = NULL;
     99          }
    100          
    101          /*
    102           * Free the components of a restart context
    103           */
    104          void mbedtls_pk_restart_free(mbedtls_pk_restart_ctx *ctx)
    105          {
    106              if (ctx == NULL || ctx->pk_info == NULL ||
    107                  ctx->pk_info->rs_free_func == NULL) {
    108                  return;
    109              }
    110          
    111              ctx->pk_info->rs_free_func(ctx->rs_ctx);
    112          
    113              ctx->pk_info = NULL;
    114              ctx->rs_ctx = NULL;
    115          }
    116          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    117          
    118          /*
    119           * Get pk_info structure from type
    120           */

   \                                 In section .text, align 2, keep-with-next
    121          const mbedtls_pk_info_t *mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type)
    122          {
    123              switch (pk_type) {
   \                     mbedtls_pk_info_from_type: (+1)
   \        0x0   0x2802             CMP      R0,#+2
   \        0x2   0xD004             BEQ.N    ??mbedtls_pk_info_from_type_0
   \        0x4   0xD30C             BCC.N    ??mbedtls_pk_info_from_type_1
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD007             BEQ.N    ??mbedtls_pk_info_from_type_2
   \        0xA   0xD303             BCC.N    ??mbedtls_pk_info_from_type_3
   \        0xC   0xE008             B.N      ??mbedtls_pk_info_from_type_1
    124          #if defined(MBEDTLS_RSA_C)
    125                  case MBEDTLS_PK_RSA:
    126                      return &mbedtls_rsa_info;
    127          #endif /* MBEDTLS_RSA_C */
    128          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    129                  case MBEDTLS_PK_ECKEY:
    130                      return &mbedtls_eckey_info;
   \                     ??mbedtls_pk_info_from_type_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x12   0x4770             BX       LR
    131                  case MBEDTLS_PK_ECKEY_DH:
    132                      return &mbedtls_eckeydh_info;
   \                     ??mbedtls_pk_info_from_type_3: (+1)
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x18   0x4770             BX       LR
    133          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    134          #if defined(MBEDTLS_PK_CAN_ECDSA_SOME)
    135                  case MBEDTLS_PK_ECDSA:
    136                      return &mbedtls_ecdsa_info;
   \                     ??mbedtls_pk_info_from_type_2: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \       0x1E   0x4770             BX       LR
    137          #endif /* MBEDTLS_PK_CAN_ECDSA_SOME */
    138                  /* MBEDTLS_PK_RSA_ALT omitted on purpose */
    139                  default:
    140                      return NULL;
   \                     ??mbedtls_pk_info_from_type_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR
    141              }
    142          }
    143          
    144          /*
    145           * Initialise context
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          int mbedtls_pk_setup(mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info)
    148          {
   \                     mbedtls_pk_setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    149              if (info == NULL || ctx->pk_info != NULL) {
   \        0x6   0xD001             BEQ.N    ??mbedtls_pk_setup_0
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0xB110             CBZ.N    R0,??mbedtls_pk_setup_1
    150                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_setup_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
    151              }
    152          
    153              if ((info->ctx_alloc_func != NULL) &&
    154                  ((ctx->pk_ctx = info->ctx_alloc_func()) == NULL)) {
   \                     ??mbedtls_pk_setup_1: (+1)
   \       0x12   0x6A60             LDR      R0,[R4, #+36]
   \       0x14   0xB128             CBZ.N    R0,??mbedtls_pk_setup_2
   \       0x16   0x4780             BLX      R0
   \       0x18   0x6068             STR      R0,[R5, #+4]
   \       0x1A   0xB910             CBNZ.N   R0,??mbedtls_pk_setup_2
    155                  return MBEDTLS_ERR_PK_ALLOC_FAILED;
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
    156              }
    157          
    158              ctx->pk_info = info;
   \                     ??mbedtls_pk_setup_2: (+1)
   \       0x22   0x602C             STR      R4,[R5, #+0]
    159          
    160              return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    161          }
    162          
    163          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    164          /*
    165           * Initialise a PSA-wrapping context
    166           */

   \                                 In section .text, align 2, keep-with-next
    167          int mbedtls_pk_setup_opaque(mbedtls_pk_context *ctx,
    168                                      const mbedtls_svc_key_id_t key)
    169          {
   \                     mbedtls_pk_setup_opaque: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    170              const mbedtls_pk_info_t *info = NULL;
    171              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       ??Subroutine0_0
    172              psa_key_type_t type;
    173          
    174              if (ctx == NULL || ctx->pk_info != NULL) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xE   0xB134             CBZ.N    R4,??mbedtls_pk_setup_opaque_0
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0xB920             CBNZ.N   R0,??mbedtls_pk_setup_opaque_0
    175                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    176              }
    177          
    178              if (PSA_SUCCESS != psa_get_key_attributes(key, &attributes)) {
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       psa_get_key_attributes
   \       0x1C   0xB110             CBZ.N    R0,??mbedtls_pk_setup_opaque_1
    179                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_setup_opaque_0: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0x22   0xE00E             B.N      ??mbedtls_pk_setup_opaque_2
    180              }
    181              type = psa_get_key_type(&attributes);
   \                     ??mbedtls_pk_setup_opaque_1: (+1)
   \       0x24   0xF8BD 0x6000      LDRH     R6,[SP, #+0]
    182              psa_reset_key_attributes(&attributes);
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x.... 0x....      BL       psa_reset_key_attributes
    183          
    184          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    185              if (PSA_KEY_TYPE_IS_ECC_KEY_PAIR(type)) {
   \       0x2E   0xF026 0x00FF      BIC      R0,R6,#0xFF
   \       0x32   0xF5B0 0x4FE2      CMP      R0,#+28928
   \       0x36   0xD106             BNE.N    ??mbedtls_pk_setup_opaque_3
    186                  info = &mbedtls_ecdsa_opaque_info;
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable14_5
    187              } else
    188          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    189              if (type == PSA_KEY_TYPE_RSA_KEY_PAIR) {
    190                  info = &mbedtls_rsa_opaque_info;
    191              } else {
    192                  return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
    193              }
    194          
    195              ctx->pk_info = info;
   \                     ??mbedtls_pk_setup_opaque_4: (+1)
   \       0x3C   0x6020             STR      R0,[R4, #+0]
    196              ctx->priv_id = key;
   \       0x3E   0x60A5             STR      R5,[R4, #+8]
    197          
    198              return 0;
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_setup_opaque_2: (+1)
   \       0x42   0xB00A             ADD      SP,SP,#+40
   \       0x44   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_pk_setup_opaque_3: (+1)
   \       0x46   0xF247 0x0001      MOVW     R0,#+28673
   \       0x4A   0x4286             CMP      R6,R0
   \       0x4C   0xBF08             IT       EQ
   \       0x4E   0x.... 0x....      LDREQ.W  R0,??DataTable14_6
   \       0x52   0xD0F3             BEQ.N    ??mbedtls_pk_setup_opaque_4
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \       0x58   0xE7F3             B.N      ??mbedtls_pk_setup_opaque_2
    199          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xA801             ADD      R0,SP,#+4
   \                     ??Subroutine0_0: (+1)
   \        0x2   0x2124             MOVS     R1,#+36
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    200          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    201          
    202          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
    203          /*
    204           * Initialize an RSA-alt context
    205           */
    206          int mbedtls_pk_setup_rsa_alt(mbedtls_pk_context *ctx, void *key,
    207                                       mbedtls_pk_rsa_alt_decrypt_func decrypt_func,
    208                                       mbedtls_pk_rsa_alt_sign_func sign_func,
    209                                       mbedtls_pk_rsa_alt_key_len_func key_len_func)
    210          {
    211              mbedtls_rsa_alt_context *rsa_alt;
    212              const mbedtls_pk_info_t *info = &mbedtls_rsa_alt_info;
    213          
    214              if (ctx->pk_info != NULL) {
    215                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    216              }
    217          
    218              if ((ctx->pk_ctx = info->ctx_alloc_func()) == NULL) {
    219                  return MBEDTLS_ERR_PK_ALLOC_FAILED;
    220              }
    221          
    222              ctx->pk_info = info;
    223          
    224              rsa_alt = (mbedtls_rsa_alt_context *) ctx->pk_ctx;
    225          
    226              rsa_alt->key = key;
    227              rsa_alt->decrypt_func = decrypt_func;
    228              rsa_alt->sign_func = sign_func;
    229              rsa_alt->key_len_func = key_len_func;
    230          
    231              return 0;
    232          }
    233          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
    234          
    235          /*
    236           * Tell if a PK can do the operations of the given type
    237           */

   \                                 In section .text, align 2, keep-with-next
    238          int mbedtls_pk_can_do(const mbedtls_pk_context *ctx, mbedtls_pk_type_t type)
    239          {
    240              /* A context with null pk_info is not set up yet and can't do anything.
    241               * For backward compatibility, also accept NULL instead of a context
    242               * pointer. */
    243              if (ctx == NULL || ctx->pk_info == NULL) {
   \                     mbedtls_pk_can_do: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x6802             LDRNE    R2,[R0, #+0]
   \        0x6   0x2A00             CMPNE    R2,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_pk_can_do_0
    244                  return 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    245              }
    246          
    247              return ctx->pk_info->can_do(type);
   \                     ??mbedtls_pk_can_do_0: (+1)
   \        0xE   0x4608             MOV      R0,R1
   \       0x10   0x68D1             LDR      R1,[R2, #+12]
   \       0x12   0x4708             BX       R1
    248          }
    249          
    250          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    251          /*
    252           * Tell if a PK can do the operations of the given PSA algorithm
    253           */

   \                                 In section .text, align 2, keep-with-next
    254          int mbedtls_pk_can_do_ext(const mbedtls_pk_context *ctx, psa_algorithm_t alg,
    255                                    psa_key_usage_t usage)
    256          {
   \                     mbedtls_pk_can_do_ext: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x0004             MOVS     R4,R0
    257              psa_key_usage_t key_usage;
    258          
    259              /* A context with null pk_info is not set up yet and can't do anything.
    260               * For backward compatibility, also accept NULL instead of a context
    261               * pointer. */
    262              if (ctx == NULL || ctx->pk_info == NULL) {
   \        0x8   0xBF1C             ITT      NE
   \        0xA   0x6820             LDRNE    R0,[R4, #+0]
   \        0xC   0x2800             CMPNE    R0,#+0
   \        0xE   0xF000 0x810C      BEQ.W    ??mbedtls_pk_can_do_ext_0
   \       0x12   0x460D             MOV      R5,R1
    263                  return 0;
    264              }
    265          
    266              /* Filter out non allowed algorithms */
    267              if (PSA_ALG_IS_ECDSA(alg) == 0 &&
    268                  PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg) == 0 &&
    269                  PSA_ALG_IS_RSA_PSS(alg) == 0 &&
    270                  alg != PSA_ALG_RSA_PKCS1V15_CRYPT &&
    271                  PSA_ALG_IS_ECDH(alg) == 0) {
   \       0x14   0x0C2F             LSRS     R7,R5,#+16
   \       0x16   0x0A69             LSRS     R1,R5,#+9
   \       0x18   0x043F             LSLS     R7,R7,#+16
   \       0x1A   0x0249             LSLS     R1,R1,#+9
   \       0x1C   0xF047 0x6710      ORR      R7,R7,#0x9000000
   \       0x20   0x.... 0x....      LDR.W    R6,??DataTable14_8
   \       0x24   0x.... 0x....      LDR.W    R9,??DataTable14_9
   \       0x28   0x.... 0x....      LDR.W    R10,??DataTable14_10
   \       0x2C   0x.... 0x....      LDR.W    R11,??DataTable14_11
   \       0x30   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0x34   0xBF1E             ITTT     NE
   \       0x36   0x0A28             LSRNE    R0,R5,#+8
   \       0x38   0x0200             LSLNE    R0,R0,#+8
   \       0x3A   0x4558             CMPNE    R0,R11
   \       0x3C   0xD00D             BEQ.N    ??mbedtls_pk_can_do_ext_1
   \       0x3E   0x0A2B             LSRS     R3,R5,#+8
   \       0x40   0x021B             LSLS     R3,R3,#+8
   \       0x42   0x4553             CMP      R3,R10
   \       0x44   0xBF1E             ITTT     NE
   \       0x46   0x0A29             LSRNE    R1,R5,#+8
   \       0x48   0x0209             LSLNE    R1,R1,#+8
   \       0x4A   0x4549             CMPNE    R1,R9
   \       0x4C   0xD005             BEQ.N    ??mbedtls_pk_can_do_ext_1
   \       0x4E   0x42B5             CMP      R5,R6
   \       0x50   0xBF1C             ITT      NE
   \       0x52   0x.... 0x....      LDRNE.W  R0,??DataTable14_12
   \       0x56   0x4287             CMPNE    R7,R0
   \       0x58   0xD157             BNE.N    ??mbedtls_pk_can_do_ext_2
   \                     ??mbedtls_pk_can_do_ext_1: (+1)
   \       0x5A   0x9200             STR      R2,[SP, #+0]
    272                  return 0;
    273              }
    274          
    275              /* Filter out non allowed usage flags */
    276              if (usage == 0 ||
    277                  (usage & ~(PSA_KEY_USAGE_SIGN_HASH |
    278                             PSA_KEY_USAGE_DECRYPT |
    279                             PSA_KEY_USAGE_DERIVE)) != 0) {
   \       0x5C   0x2A00             CMP      R2,#+0
   \       0x5E   0xD054             BEQ.N    ??mbedtls_pk_can_do_ext_2
   \       0x60   0xF432 0x40A4      BICS     R0,R2,#0x5200
   \       0x64   0xD151             BNE.N    ??mbedtls_pk_can_do_ext_2
    280                  return 0;
    281              }
    282          
    283              /* Wildcard hash is not allowed */
    284              if (PSA_ALG_IS_SIGN_HASH(alg) &&
    285                  PSA_ALG_SIGN_GET_HASH(alg) == PSA_ALG_ANY_HASH) {
   \       0x66   0x0A29             LSRS     R1,R5,#+8
   \       0x68   0x0209             LSLS     R1,R1,#+8
   \       0x6A   0x.... 0x....      LDR.W    R8,??DataTable14_13
   \       0x6E   0x4551             CMP      R1,R10
   \       0x70   0xBF1E             ITTT     NE
   \       0x72   0x0A28             LSRNE    R0,R5,#+8
   \       0x74   0x0200             LSLNE    R0,R0,#+8
   \       0x76   0x4548             CMPNE    R0,R9
   \       0x78   0xD012             BEQ.N    ??mbedtls_pk_can_do_ext_3
   \       0x7A   0x0A29             LSRS     R1,R5,#+8
   \       0x7C   0x0209             LSLS     R1,R1,#+8
   \       0x7E   0x4559             CMP      R1,R11
   \       0x80   0xBF1E             ITTT     NE
   \       0x82   0x0A68             LSRNE    R0,R5,#+9
   \       0x84   0x0240             LSLNE    R0,R0,#+9
   \       0x86   0xF1B0 0x2F06      CMPNE    R0,#+100664832
   \       0x8A   0xD009             BEQ.N    ??mbedtls_pk_can_do_ext_3
   \       0x8C   0x0A2A             LSRS     R2,R5,#+8
   \       0x8E   0x0212             LSLS     R2,R2,#+8
   \       0x90   0x4542             CMP      R2,R8
   \       0x92   0xBF1F             ITTTT    NE
   \       0x94   0x0A68             LSRNE    R0,R5,#+9
   \       0x96   0x0240             LSLNE    R0,R0,#+9
   \       0x98   0x.... 0x....      LDRNE.W  R1,??DataTable14_14
   \       0x9C   0x4288             CMPNE    R0,R1
   \       0x9E   0xD109             BNE.N    ??mbedtls_pk_can_do_ext_4
   \                     ??mbedtls_pk_can_do_ext_3: (+1)
   \       0xA0   0x062A             LSLS     R2,R5,#+24
   \       0xA2   0xD007             BEQ.N    ??mbedtls_pk_can_do_ext_4
   \       0xA4   0xF005 0x00FF      AND      R0,R5,#0xFF
   \       0xA8   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \       0xAC   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \       0xB0   0x4288             CMP      R0,R1
   \       0xB2   0xD02A             BEQ.N    ??mbedtls_pk_can_do_ext_2
    286                  return 0;
    287              }
    288          
    289              if (mbedtls_pk_get_type(ctx) != MBEDTLS_PK_OPAQUE) {
   \                     ??mbedtls_pk_can_do_ext_4: (+1)
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0x.... 0x....      BL       mbedtls_pk_get_type
   \       0xBA   0x2807             CMP      R0,#+7
   \       0xBC   0xD030             BEQ.N    ??mbedtls_pk_can_do_ext_5
    290                  mbedtls_pk_type_t type;
    291          
    292                  if (PSA_ALG_IS_ECDSA(alg) || PSA_ALG_IS_ECDH(alg)) {
   \       0xBE   0x0A69             LSRS     R1,R5,#+9
   \       0xC0   0x0249             LSLS     R1,R1,#+9
   \       0xC2   0xF1B1 0x2F06      CMP      R1,#+100664832
   \       0xC6   0xBF1A             ITTE     NE
   \       0xC8   0x.... 0x....      LDRNE.W  R0,??DataTable14_12
   \       0xCC   0x4287             CMPNE    R7,R0
   \       0xCE   0x2502             MOVEQ    R5,#+2
    293                      type = MBEDTLS_PK_ECKEY;
   \       0xD0   0xD00F             BEQ.N    ??mbedtls_pk_can_do_ext_6
    294                  } else if (PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg) ||
    295                             alg == PSA_ALG_RSA_PKCS1V15_CRYPT) {
   \       0xD2   0x0A28             LSRS     R0,R5,#+8
   \       0xD4   0x0200             LSLS     R0,R0,#+8
   \       0xD6   0x4558             CMP      R0,R11
   \       0xD8   0xBF14             ITE      NE
   \       0xDA   0x42B5             CMPNE    R5,R6
   \       0xDC   0x2501             MOVEQ    R5,#+1
    296                      type = MBEDTLS_PK_RSA;
   \       0xDE   0xD008             BEQ.N    ??mbedtls_pk_can_do_ext_6
    297                  } else if (PSA_ALG_IS_RSA_PSS(alg)) {
   \       0xE0   0x0A28             LSRS     R0,R5,#+8
   \       0xE2   0x0200             LSLS     R0,R0,#+8
   \       0xE4   0x4550             CMP      R0,R10
   \       0xE6   0xBF1E             ITTT     NE
   \       0xE8   0x0A2D             LSRNE    R5,R5,#+8
   \       0xEA   0x022D             LSLNE    R5,R5,#+8
   \       0xEC   0x454D             CMPNE    R5,R9
   \       0xEE   0xD10C             BNE.N    ??mbedtls_pk_can_do_ext_2
    298                      type = MBEDTLS_PK_RSASSA_PSS;
   \       0xF0   0x2506             MOVS     R5,#+6
    299                  } else {
    300                      return 0;
    301                  }
    302          
    303                  if (ctx->pk_info->can_do(type) == 0) {
   \                     ??mbedtls_pk_can_do_ext_6: (+1)
   \       0xF2   0x6822             LDR      R2,[R4, #+0]
   \       0xF4   0x4628             MOV      R0,R5
   \       0xF6   0x68D1             LDR      R1,[R2, #+12]
   \       0xF8   0x4788             BLX      R1
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD005             BEQ.N    ??mbedtls_pk_can_do_ext_2
    304                      return 0;
    305                  }
    306          
    307                  switch (type) {
   \       0xFE   0x2D01             CMP      R5,#+1
   \      0x100   0xD007             BEQ.N    ??mbedtls_pk_can_do_ext_7
   \      0x102   0x2D02             CMP      R5,#+2
   \      0x104   0xD002             BEQ.N    ??mbedtls_pk_can_do_ext_8
   \      0x106   0x2D06             CMP      R5,#+6
   \      0x108   0xD003             BEQ.N    ??mbedtls_pk_can_do_ext_7
   \                     ??mbedtls_pk_can_do_ext_2: (+1)
   \      0x10A   0xE08E             B.N      ??mbedtls_pk_can_do_ext_0
    308                      case MBEDTLS_PK_ECKEY:
    309                          key_usage = PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_DERIVE;
   \                     ??mbedtls_pk_can_do_ext_8: (+1)
   \      0x10C   0xF44F 0x41A0      MOV      R1,#+20480
    310                          break;
   \      0x110   0xE001             B.N      ??mbedtls_pk_can_do_ext_9
    311                      case MBEDTLS_PK_RSA:
    312                      case MBEDTLS_PK_RSASSA_PSS:
    313                          key_usage = PSA_KEY_USAGE_SIGN_HASH |
    314                                      PSA_KEY_USAGE_SIGN_MESSAGE |
    315                                      PSA_KEY_USAGE_DECRYPT;
   \                     ??mbedtls_pk_can_do_ext_7: (+1)
   \      0x112   0xF44F 0x51B0      MOV      R1,#+5632
    316                          break;
    317                      default:
    318                          /* Should never happen */
    319                          return 0;
    320                  }
    321          
    322                  return (key_usage & usage) == usage;
   \                     ??mbedtls_pk_can_do_ext_9: (+1)
   \      0x116   0x9800             LDR      R0,[SP, #+0]
   \      0x118   0x4001             ANDS     R1,R0,R1
   \      0x11A   0x4281             CMP      R1,R0
   \      0x11C   0xD1F5             BNE.N    ??mbedtls_pk_can_do_ext_2
   \      0x11E   0xE082             B.N      ??mbedtls_pk_can_do_ext_10
    323              }
    324          
    325              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \                     ??mbedtls_pk_can_do_ext_5: (+1)
   \      0x120   0x.... 0x....      BL       ?Subroutine0
    326              psa_algorithm_t key_alg, key_alg2;
    327              psa_status_t status;
    328          
    329              status = psa_get_key_attributes(ctx->priv_id, &attributes);
    330              if (status != PSA_SUCCESS) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \      0x124   0x68A0             LDR      R0,[R4, #+8]
   \      0x126   0xA901             ADD      R1,SP,#+4
   \      0x128   0x.... 0x....      BL       psa_get_key_attributes
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD17C             BNE.N    ??mbedtls_pk_can_do_ext_0
    331                  return 0;
    332              }
    333          
    334              key_alg = psa_get_key_algorithm(&attributes);
   \      0x130   0x9C05             LDR      R4,[SP, #+20]
    335              key_alg2 = psa_get_key_enrollment_algorithm(&attributes);
   \      0x132   0x9E06             LDR      R6,[SP, #+24]
    336              key_usage = psa_get_key_usage_flags(&attributes);
   \      0x134   0x9F04             LDR      R7,[SP, #+16]
    337              psa_reset_key_attributes(&attributes);
   \      0x136   0xA801             ADD      R0,SP,#+4
   \      0x138   0x.... 0x....      BL       psa_reset_key_attributes
    338          
    339              if ((key_usage & usage) != usage) {
   \      0x13C   0x9800             LDR      R0,[SP, #+0]
   \      0x13E   0x4007             ANDS     R7,R0,R7
   \      0x140   0x4287             CMP      R7,R0
   \      0x142   0xD172             BNE.N    ??mbedtls_pk_can_do_ext_0
    340                  return 0;
    341              }
    342          
    343              /*
    344               * Common case: the key alg or alg2 only allows alg.
    345               * This will match PSA_ALG_RSA_PKCS1V15_CRYPT & PSA_ALG_IS_ECDH
    346               * directly.
    347               * This would also match ECDSA/RSA_PKCS1V15_SIGN/RSA_PSS with
    348               * a fixed hash on key_alg/key_alg2.
    349               */
    350              if (alg == key_alg || alg == key_alg2) {
   \      0x144   0x42A5             CMP      R5,R4
   \      0x146   0xBF18             IT       NE
   \      0x148   0x42B5             CMPNE    R5,R6
   \      0x14A   0xD06C             BEQ.N    ??mbedtls_pk_can_do_ext_10
    351                  return 1;
    352              }
    353          
    354              /*
    355               * If key_alg or key_alg2 is a hash-and-sign with a wildcard for the hash,
    356               * and alg is the same hash-and-sign family with any hash,
    357               * then alg is compliant with this key alg
    358               */
    359              if (PSA_ALG_IS_SIGN_HASH(alg)) {
   \      0x14C   0x0A28             LSRS     R0,R5,#+8
   \      0x14E   0x0200             LSLS     R0,R0,#+8
   \      0x150   0x4550             CMP      R0,R10
   \      0x152   0xBF1E             ITTT     NE
   \      0x154   0x0A29             LSRNE    R1,R5,#+8
   \      0x156   0x0209             LSLNE    R1,R1,#+8
   \      0x158   0x4549             CMPNE    R1,R9
   \      0x15A   0xD012             BEQ.N    ??mbedtls_pk_can_do_ext_11
   \      0x15C   0x0A28             LSRS     R0,R5,#+8
   \      0x15E   0x0200             LSLS     R0,R0,#+8
   \      0x160   0x4558             CMP      R0,R11
   \      0x162   0xBF1E             ITTT     NE
   \      0x164   0x0A69             LSRNE    R1,R5,#+9
   \      0x166   0x0249             LSLNE    R1,R1,#+9
   \      0x168   0xF1B1 0x2F06      CMPNE    R1,#+100664832
   \      0x16C   0xD009             BEQ.N    ??mbedtls_pk_can_do_ext_11
   \      0x16E   0x0A2A             LSRS     R2,R5,#+8
   \      0x170   0x0212             LSLS     R2,R2,#+8
   \      0x172   0x4542             CMP      R2,R8
   \      0x174   0xBF1F             ITTTT    NE
   \      0x176   0x0A69             LSRNE    R1,R5,#+9
   \      0x178   0x0249             LSLNE    R1,R1,#+9
   \      0x17A   0x.... 0x....      LDRNE.W  R0,??DataTable14_14
   \      0x17E   0x4281             CMPNE    R1,R0
   \      0x180   0xD153             BNE.N    ??mbedtls_pk_can_do_ext_0
    360          
    361                  if (PSA_ALG_IS_SIGN_HASH(key_alg) &&
    362                      PSA_ALG_SIGN_GET_HASH(key_alg) == PSA_ALG_ANY_HASH &&
    363                      (alg & ~PSA_ALG_HASH_MASK) == (key_alg & ~PSA_ALG_HASH_MASK)) {
   \                     ??mbedtls_pk_can_do_ext_11: (+1)
   \      0x182   0x0A22             LSRS     R2,R4,#+8
   \      0x184   0x0212             LSLS     R2,R2,#+8
   \      0x186   0x.... 0x....      LDR.W    R0,??DataTable14_15
   \      0x18A   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \      0x18E   0x4552             CMP      R2,R10
   \      0x190   0xBF1E             ITTT     NE
   \      0x192   0x0A23             LSRNE    R3,R4,#+8
   \      0x194   0x021B             LSLNE    R3,R3,#+8
   \      0x196   0x454B             CMPNE    R3,R9
   \      0x198   0xD010             BEQ.N    ??mbedtls_pk_can_do_ext_12
   \      0x19A   0x0A22             LSRS     R2,R4,#+8
   \      0x19C   0x0212             LSLS     R2,R2,#+8
   \      0x19E   0x455A             CMP      R2,R11
   \      0x1A0   0xBF1E             ITTT     NE
   \      0x1A2   0x0A63             LSRNE    R3,R4,#+9
   \      0x1A4   0x025B             LSLNE    R3,R3,#+9
   \      0x1A6   0xF1B3 0x2F06      CMPNE    R3,#+100664832
   \      0x1AA   0xD007             BEQ.N    ??mbedtls_pk_can_do_ext_12
   \      0x1AC   0x0A22             LSRS     R2,R4,#+8
   \      0x1AE   0x0212             LSLS     R2,R2,#+8
   \      0x1B0   0x4542             CMP      R2,R8
   \      0x1B2   0xBF1E             ITTT     NE
   \      0x1B4   0x0A63             LSRNE    R3,R4,#+9
   \      0x1B6   0x025B             LSLNE    R3,R3,#+9
   \      0x1B8   0x428B             CMPNE    R3,R1
   \      0x1BA   0xD10D             BNE.N    ??mbedtls_pk_can_do_ext_13
   \                     ??mbedtls_pk_can_do_ext_12: (+1)
   \      0x1BC   0x0622             LSLS     R2,R4,#+24
   \      0x1BE   0xD00B             BEQ.N    ??mbedtls_pk_can_do_ext_13
   \      0x1C0   0xF004 0x03FF      AND      R3,R4,#0xFF
   \      0x1C4   0xF043 0x7300      ORR      R3,R3,#0x2000000
   \      0x1C8   0x4283             CMP      R3,R0
   \      0x1CA   0xBF01             ITTTT    EQ
   \      0x1CC   0x0A2A             LSREQ    R2,R5,#+8
   \      0x1CE   0x0212             LSLEQ    R2,R2,#+8
   \      0x1D0   0x0A24             LSREQ    R4,R4,#+8
   \      0x1D2   0xEBB2 0x2F04      CMPEQ    R2,R4, LSL #+8
   \      0x1D6   0xD026             BEQ.N    ??mbedtls_pk_can_do_ext_10
    364                      return 1;
    365                  }
    366          
    367                  if (PSA_ALG_IS_SIGN_HASH(key_alg2) &&
    368                      PSA_ALG_SIGN_GET_HASH(key_alg2) == PSA_ALG_ANY_HASH &&
    369                      (alg & ~PSA_ALG_HASH_MASK) == (key_alg2 & ~PSA_ALG_HASH_MASK)) {
   \                     ??mbedtls_pk_can_do_ext_13: (+1)
   \      0x1D8   0x0A33             LSRS     R3,R6,#+8
   \      0x1DA   0x021B             LSLS     R3,R3,#+8
   \      0x1DC   0x4553             CMP      R3,R10
   \      0x1DE   0xBF1E             ITTT     NE
   \      0x1E0   0x0A32             LSRNE    R2,R6,#+8
   \      0x1E2   0x0212             LSLNE    R2,R2,#+8
   \      0x1E4   0x454A             CMPNE    R2,R9
   \      0x1E6   0xD010             BEQ.N    ??mbedtls_pk_can_do_ext_14
   \      0x1E8   0x0A33             LSRS     R3,R6,#+8
   \      0x1EA   0x021B             LSLS     R3,R3,#+8
   \      0x1EC   0x455B             CMP      R3,R11
   \      0x1EE   0xBF1E             ITTT     NE
   \      0x1F0   0x0A72             LSRNE    R2,R6,#+9
   \      0x1F2   0x0252             LSLNE    R2,R2,#+9
   \      0x1F4   0xF1B2 0x2F06      CMPNE    R2,#+100664832
   \      0x1F8   0xD007             BEQ.N    ??mbedtls_pk_can_do_ext_14
   \      0x1FA   0x0A33             LSRS     R3,R6,#+8
   \      0x1FC   0x021B             LSLS     R3,R3,#+8
   \      0x1FE   0x4543             CMP      R3,R8
   \      0x200   0xBF1E             ITTT     NE
   \      0x202   0x0A72             LSRNE    R2,R6,#+9
   \      0x204   0x0252             LSLNE    R2,R2,#+9
   \      0x206   0x428A             CMPNE    R2,R1
   \      0x208   0xD10F             BNE.N    ??mbedtls_pk_can_do_ext_0
   \                     ??mbedtls_pk_can_do_ext_14: (+1)
   \      0x20A   0x0633             LSLS     R3,R6,#+24
   \      0x20C   0xD00D             BEQ.N    ??mbedtls_pk_can_do_ext_0
   \      0x20E   0xF006 0x01FF      AND      R1,R6,#0xFF
   \      0x212   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \      0x216   0x4281             CMP      R1,R0
   \      0x218   0xBF01             ITTTT    EQ
   \      0x21A   0x0A2D             LSREQ    R5,R5,#+8
   \      0x21C   0x022D             LSLEQ    R5,R5,#+8
   \      0x21E   0x0A36             LSREQ    R6,R6,#+8
   \      0x220   0xEBB5 0x2F06      CMPEQ    R5,R6, LSL #+8
   \      0x224   0xD101             BNE.N    ??mbedtls_pk_can_do_ext_0
    370                      return 1;
   \                     ??mbedtls_pk_can_do_ext_10: (+1)
   \      0x226   0x2001             MOVS     R0,#+1
   \      0x228   0xE000             B.N      ??mbedtls_pk_can_do_ext_15
    371                  }
    372              }
    373          
    374              return 0;
   \                     ??mbedtls_pk_can_do_ext_0: (+1)
   \      0x22A   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_can_do_ext_15: (+1)
   \      0x22C   0xB00B             ADD      SP,SP,#+44
   \      0x22E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    375          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    376          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    377          
    378          /*
    379           * Helper for mbedtls_pk_sign and mbedtls_pk_verify
    380           */

   \                                 In section .text, align 2, keep-with-next
    381          static inline int pk_hashlen_helper(mbedtls_md_type_t md_alg, size_t *hash_len)
    382          {
   \                     pk_hashlen_helper: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    383              if (*hash_len != 0) {
   \        0x4   0x6821             LDR      R1,[R4, #+0]
   \        0x6   0xB941             CBNZ.N   R1,??pk_hashlen_helper_0
    384                  return 0;
    385              }
    386          
    387              *hash_len = mbedtls_md_get_size_from_type(md_alg);
   \        0x8   0x.... 0x....      BL       mbedtls_md_info_from_type
   \        0xC   0x.... 0x....      BL       mbedtls_md_get_size
   \       0x10   0x6020             STR      R0,[R4, #+0]
    388          
    389              if (*hash_len == 0) {
   \       0x12   0xB910             CBNZ.N   R0,??pk_hashlen_helper_0
    390                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x18   0xBD10             POP      {R4,PC}
    391              }
    392          
    393              return 0;
   \                     ??pk_hashlen_helper_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD10             POP      {R4,PC}
    394          }
    395          
    396          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
    397          /*
    398           * Helper to set up a restart context if needed
    399           */
    400          static int pk_restart_setup(mbedtls_pk_restart_ctx *ctx,
    401                                      const mbedtls_pk_info_t *info)
    402          {
    403              /* Don't do anything if already set up or invalid */
    404              if (ctx == NULL || ctx->pk_info != NULL) {
    405                  return 0;
    406              }
    407          
    408              /* Should never happen when we're called */
    409              if (info->rs_alloc_func == NULL || info->rs_free_func == NULL) {
    410                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    411              }
    412          
    413              if ((ctx->rs_ctx = info->rs_alloc_func()) == NULL) {
    414                  return MBEDTLS_ERR_PK_ALLOC_FAILED;
    415              }
    416          
    417              ctx->pk_info = info;
    418          
    419              return 0;
    420          }
    421          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    422          
    423          /*
    424           * Verify a signature (restartable)
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          int mbedtls_pk_verify_restartable(mbedtls_pk_context *ctx,
    427                                            mbedtls_md_type_t md_alg,
    428                                            const unsigned char *hash, size_t hash_len,
    429                                            const unsigned char *sig, size_t sig_len,
    430                                            mbedtls_pk_restart_ctx *rs_ctx)
    431          {
   \                     mbedtls_pk_verify_restartable: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
    432              if ((md_alg != MBEDTLS_MD_NONE || hash_len != 0) && hash == NULL) {
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0xD101             BNE.N    ??mbedtls_pk_verify_restartable_0
   \        0xC   0x0018             MOVS     R0,R3
   \        0xE   0xD000             BEQ.N    ??mbedtls_pk_verify_restartable_1
   \                     ??mbedtls_pk_verify_restartable_0: (+1)
   \       0x10   0xB134             CBZ.N    R4,??mbedtls_pk_verify_restartable_2
    433                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    434              }
    435          
    436              if (ctx->pk_info == NULL ||
    437                  pk_hashlen_helper(md_alg, &hash_len) != 0) {
   \                     ??mbedtls_pk_verify_restartable_1: (+1)
   \       0x12   0x683A             LDR      R2,[R7, #+0]
   \       0x14   0xB122             CBZ.N    R2,??mbedtls_pk_verify_restartable_2
   \       0x16   0xA902             ADD      R1,SP,#+8
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x.... 0x....      BL       pk_hashlen_helper
   \       0x1E   0xB110             CBZ.N    R0,??mbedtls_pk_verify_restartable_3
    438                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_verify_restartable_2: (+1)
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0x24   0xBDFE             POP      {R1-R7,PC}
    439              }
    440          
    441          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
    442              /* optimization: use non-restartable version if restart disabled */
    443              if (rs_ctx != NULL &&
    444                  mbedtls_ecp_restart_is_enabled() &&
    445                  ctx->pk_info->verify_rs_func != NULL) {
    446                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    447          
    448                  if ((ret = pk_restart_setup(rs_ctx, ctx->pk_info)) != 0) {
    449                      return ret;
    450                  }
    451          
    452                  ret = ctx->pk_info->verify_rs_func(ctx,
    453                                                     md_alg, hash, hash_len, sig, sig_len, rs_ctx->rs_ctx);
    454          
    455                  if (ret != MBEDTLS_ERR_ECP_IN_PROGRESS) {
    456                      mbedtls_pk_restart_free(rs_ctx);
    457                  }
    458          
    459                  return ret;
    460              }
    461          #else /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    462              (void) rs_ctx;
    463          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    464          
    465              if (ctx->pk_info->verify_func == NULL) {
   \                     ??mbedtls_pk_verify_restartable_3: (+1)
   \       0x26   0x6838             LDR      R0,[R7, #+0]
   \       0x28   0x6905             LDR      R5,[R0, #+16]
   \       0x2A   0xB915             CBNZ.N   R5,??mbedtls_pk_verify_restartable_4
    466                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable14_16
   \       0x30   0xBDFE             POP      {R1-R7,PC}
    467              }
    468          
    469              return ctx->pk_info->verify_func(ctx, md_alg, hash, hash_len,
    470                                               sig, sig_len);
   \                     ??mbedtls_pk_verify_restartable_4: (+1)
   \       0x32   0x9909             LDR      R1,[SP, #+36]
   \       0x34   0x9808             LDR      R0,[SP, #+32]
   \       0x36   0x9B02             LDR      R3,[SP, #+8]
   \       0x38   0x9101             STR      R1,[SP, #+4]
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x4622             MOV      R2,R4
   \       0x3E   0x4631             MOV      R1,R6
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x47A8             BLX      R5
   \       0x44   0xBDFE             POP      {R1-R7,PC}
    471          }
    472          
    473          /*
    474           * Verify a signature
    475           */

   \                                 In section .text, align 2, keep-with-next
    476          int mbedtls_pk_verify(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    477                                const unsigned char *hash, size_t hash_len,
    478                                const unsigned char *sig, size_t sig_len)
    479          {
   \                     mbedtls_pk_verify: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    480              return mbedtls_pk_verify_restartable(ctx, md_alg, hash, hash_len,
    481                                                   sig, sig_len, NULL);
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x9402             STR      R4,[SP, #+8]
   \        0x6   0x9D07             LDR      R5,[SP, #+28]
   \        0x8   0x9C06             LDR      R4,[SP, #+24]
   \        0xA   0x9501             STR      R5,[SP, #+4]
   \        0xC   0x9400             STR      R4,[SP, #+0]
   \        0xE   0x.... 0x....      BL       mbedtls_pk_verify_restartable
   \       0x12   0xBD3E             POP      {R1-R5,PC}
    482          }
    483          
    484          /*
    485           * Verify a signature with options
    486           */

   \                                 In section .text, align 2, keep-with-next
    487          int mbedtls_pk_verify_ext(mbedtls_pk_type_t type, const void *options,
    488                                    mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    489                                    const unsigned char *hash, size_t hash_len,
    490                                    const unsigned char *sig, size_t sig_len)
    491          {
   \                     mbedtls_pk_verify_ext: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0xEA5F 0x0803      MOVS     R8,R3
   \        0xE   0x9D0A             LDR      R5,[SP, #+40]
   \       0x10   0x9E0B             LDR      R6,[SP, #+44]
    492              if ((md_alg != MBEDTLS_MD_NONE || hash_len != 0) && hash == NULL) {
   \       0x12   0x.... 0x....      LDR.W    R9,??DataTable14_3
   \       0x16   0xBF08             IT       EQ
   \       0x18   0x2E00             CMPEQ    R6,#+0
   \       0x1A   0xD000             BEQ.N    ??mbedtls_pk_verify_ext_0
   \       0x1C   0xB165             CBZ.N    R5,??mbedtls_pk_verify_ext_1
    493                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    494              }
    495          
    496              if (ctx->pk_info == NULL) {
   \                     ??mbedtls_pk_verify_ext_0: (+1)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0xB150             CBZ.N    R0,??mbedtls_pk_verify_ext_1
    497                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    498              }
    499          
    500              if (!mbedtls_pk_can_do(ctx, type)) {
   \       0x22   0x4651             MOV      R1,R10
   \       0x24   0x4638             MOV      R0,R7
   \       0x26   0x.... 0x....      BL       mbedtls_pk_can_do
   \       0x2A   0xB908             CBNZ.N   R0,??mbedtls_pk_verify_ext_2
    501                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \       0x2C   0x....             LDR.N    R0,??DataTable14_16
   \       0x2E   0xE011             B.N      ??mbedtls_pk_verify_ext_3
    502              }
    503          
    504              if (type != MBEDTLS_PK_RSASSA_PSS) {
   \                     ??mbedtls_pk_verify_ext_2: (+1)
   \       0x30   0xF1BA 0x0F06      CMP      R10,#+6
   \       0x34   0xD00D             BEQ.N    ??mbedtls_pk_verify_ext_4
    505                  /* General case: no options */
    506                  if (options != NULL) {
   \       0x36   0xB10C             CBZ.N    R4,??mbedtls_pk_verify_ext_5
    507                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_verify_ext_1: (+1)
   \       0x38   0x4648             MOV      R0,R9
   \       0x3A   0xE00B             B.N      ??mbedtls_pk_verify_ext_3
    508                  }
    509          
    510                  return mbedtls_pk_verify(ctx, md_alg, hash, hash_len, sig, sig_len);
   \                     ??mbedtls_pk_verify_ext_5: (+1)
   \       0x3C   0x990D             LDR      R1,[SP, #+52]
   \       0x3E   0x980C             LDR      R0,[SP, #+48]
   \       0x40   0x9101             STR      R1,[SP, #+4]
   \       0x42   0x4633             MOV      R3,R6
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0x462A             MOV      R2,R5
   \       0x48   0x4641             MOV      R1,R8
   \       0x4A   0x4638             MOV      R0,R7
   \       0x4C   0x.... 0x....      BL       mbedtls_pk_verify
   \       0x50   0xE000             B.N      ??mbedtls_pk_verify_ext_3
    511              }
    512          
    513          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_PKCS1_V21)
    514              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    515              const mbedtls_pk_rsassa_pss_options *pss_opts;
    516          
    517          #if SIZE_MAX > UINT_MAX
    518              if (md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len) {
    519                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    520              }
    521          #endif
    522          
    523              if (options == NULL) {
    524                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    525              }
    526          
    527              pss_opts = (const mbedtls_pk_rsassa_pss_options *) options;
    528          
    529          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    530              if (pss_opts->mgf1_hash_id == md_alg) {
    531                  unsigned char buf[MBEDTLS_PK_RSA_PUB_DER_MAX_BYTES];
    532                  unsigned char *p;
    533                  int key_len;
    534                  size_t signature_length;
    535                  psa_status_t status = PSA_ERROR_DATA_CORRUPT;
    536                  psa_status_t destruction_status = PSA_ERROR_DATA_CORRUPT;
    537          
    538                  psa_algorithm_t psa_md_alg = mbedtls_md_psa_alg_from_type(md_alg);
    539                  mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    540                  psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    541                  psa_algorithm_t psa_sig_alg = PSA_ALG_RSA_PSS_ANY_SALT(psa_md_alg);
    542                  p = buf + sizeof(buf);
    543                  key_len = mbedtls_pk_write_pubkey(&p, buf, ctx);
    544          
    545                  if (key_len < 0) {
    546                      return key_len;
    547                  }
    548          
    549                  psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_PUBLIC_KEY);
    550                  psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_VERIFY_HASH);
    551                  psa_set_key_algorithm(&attributes, psa_sig_alg);
    552          
    553                  status = psa_import_key(&attributes,
    554                                          buf + sizeof(buf) - key_len, key_len,
    555                                          &key_id);
    556                  if (status != PSA_SUCCESS) {
    557                      psa_destroy_key(key_id);
    558                      return PSA_PK_TO_MBEDTLS_ERR(status);
    559                  }
    560          
    561                  /* This function requires returning MBEDTLS_ERR_PK_SIG_LEN_MISMATCH
    562                   * on a valid signature with trailing data in a buffer, but
    563                   * mbedtls_psa_rsa_verify_hash requires the sig_len to be exact,
    564                   * so for this reason the passed sig_len is overwritten. Smaller
    565                   * signature lengths should not be accepted for verification. */
    566                  signature_length = sig_len > mbedtls_pk_get_len(ctx) ?
    567                                     mbedtls_pk_get_len(ctx) : sig_len;
    568                  status = psa_verify_hash(key_id, psa_sig_alg, hash,
    569                                           hash_len, sig, signature_length);
    570                  destruction_status = psa_destroy_key(key_id);
    571          
    572                  if (status == PSA_SUCCESS && sig_len > mbedtls_pk_get_len(ctx)) {
    573                      return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    574                  }
    575          
    576                  if (status == PSA_SUCCESS) {
    577                      status = destruction_status;
    578                  }
    579          
    580                  return PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    581              } else
    582          #endif
    583              {
    584                  if (sig_len < mbedtls_pk_get_len(ctx)) {
    585                      return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    586                  }
    587          
    588                  ret = mbedtls_rsa_rsassa_pss_verify_ext(mbedtls_pk_rsa(*ctx),
    589                                                          md_alg, (unsigned int) hash_len, hash,
    590                                                          pss_opts->mgf1_hash_id,
    591                                                          pss_opts->expected_salt_len,
    592                                                          sig);
    593                  if (ret != 0) {
    594                      return ret;
    595                  }
    596          
    597                  if (sig_len > mbedtls_pk_get_len(ctx)) {
    598                      return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    599                  }
    600          
    601                  return 0;
    602              }
    603          #else
    604              return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_verify_ext_4: (+1)
   \       0x52   0x....             LDR.N    R0,??DataTable14_7
   \                     ??mbedtls_pk_verify_ext_3: (+1)
   \       0x54   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    605          #endif /* MBEDTLS_RSA_C && MBEDTLS_PKCS1_V21 */
    606          }
    607          
    608          /*
    609           * Make a signature (restartable)
    610           */

   \                                 In section .text, align 2, keep-with-next
    611          int mbedtls_pk_sign_restartable(mbedtls_pk_context *ctx,
    612                                          mbedtls_md_type_t md_alg,
    613                                          const unsigned char *hash, size_t hash_len,
    614                                          unsigned char *sig, size_t sig_size, size_t *sig_len,
    615                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
    616                                          mbedtls_pk_restart_ctx *rs_ctx)
    617          {
   \                     mbedtls_pk_sign_restartable: (+1)
   \        0x0   0xB5FC             PUSH     {R2-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0xB085             SUB      SP,SP,#+20
   \        0x8   0x4614             MOV      R4,R2
    618              if ((md_alg != MBEDTLS_MD_NONE || hash_len != 0) && hash == NULL) {
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0xD101             BNE.N    ??mbedtls_pk_sign_restartable_0
   \        0xE   0x0018             MOVS     R0,R3
   \       0x10   0xD000             BEQ.N    ??mbedtls_pk_sign_restartable_1
   \                     ??mbedtls_pk_sign_restartable_0: (+1)
   \       0x12   0xB134             CBZ.N    R4,??mbedtls_pk_sign_restartable_2
    619                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    620              }
    621          
    622              if (ctx->pk_info == NULL || pk_hashlen_helper(md_alg, &hash_len) != 0) {
   \                     ??mbedtls_pk_sign_restartable_1: (+1)
   \       0x14   0x683A             LDR      R2,[R7, #+0]
   \       0x16   0xB122             CBZ.N    R2,??mbedtls_pk_sign_restartable_2
   \       0x18   0xA906             ADD      R1,SP,#+24
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x.... 0x....      BL       pk_hashlen_helper
   \       0x20   0xB108             CBZ.N    R0,??mbedtls_pk_sign_restartable_3
    623                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_sign_restartable_2: (+1)
   \       0x22   0x....             LDR.N    R0,??DataTable14_3
   \       0x24   0xE013             B.N      ??mbedtls_pk_sign_restartable_4
    624              }
    625          
    626          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
    627              /* optimization: use non-restartable version if restart disabled */
    628              if (rs_ctx != NULL &&
    629                  mbedtls_ecp_restart_is_enabled() &&
    630                  ctx->pk_info->sign_rs_func != NULL) {
    631                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    632          
    633                  if ((ret = pk_restart_setup(rs_ctx, ctx->pk_info)) != 0) {
    634                      return ret;
    635                  }
    636          
    637                  ret = ctx->pk_info->sign_rs_func(ctx, md_alg,
    638                                                   hash, hash_len,
    639                                                   sig, sig_size, sig_len,
    640                                                   f_rng, p_rng, rs_ctx->rs_ctx);
    641          
    642                  if (ret != MBEDTLS_ERR_ECP_IN_PROGRESS) {
    643                      mbedtls_pk_restart_free(rs_ctx);
    644                  }
    645          
    646                  return ret;
    647              }
    648          #else /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    649              (void) rs_ctx;
    650          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    651          
    652              if (ctx->pk_info->sign_func == NULL) {
   \                     ??mbedtls_pk_sign_restartable_3: (+1)
   \       0x26   0x6838             LDR      R0,[R7, #+0]
   \       0x28   0x6945             LDR      R5,[R0, #+20]
   \       0x2A   0xB90D             CBNZ.N   R5,??mbedtls_pk_sign_restartable_5
    653                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \       0x2C   0x....             LDR.N    R0,??DataTable14_16
   \       0x2E   0xE00E             B.N      ??mbedtls_pk_sign_restartable_4
    654              }
    655          
    656              return ctx->pk_info->sign_func(ctx, md_alg,
    657                                             hash, hash_len,
    658                                             sig, sig_size, sig_len,
    659                                             f_rng, p_rng);
   \                     ??mbedtls_pk_sign_restartable_5: (+1)
   \       0x30   0x9810             LDR      R0,[SP, #+64]
   \       0x32   0x990F             LDR      R1,[SP, #+60]
   \       0x34   0x9B06             LDR      R3,[SP, #+24]
   \       0x36   0x9004             STR      R0,[SP, #+16]
   \       0x38   0x980E             LDR      R0,[SP, #+56]
   \       0x3A   0x9103             STR      R1,[SP, #+12]
   \       0x3C   0x990D             LDR      R1,[SP, #+52]
   \       0x3E   0x9002             STR      R0,[SP, #+8]
   \       0x40   0x980C             LDR      R0,[SP, #+48]
   \       0x42   0x9101             STR      R1,[SP, #+4]
   \       0x44   0x4622             MOV      R2,R4
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0x4631             MOV      R1,R6
   \       0x4A   0x4638             MOV      R0,R7
   \       0x4C   0x47A8             BLX      R5
   \                     ??mbedtls_pk_sign_restartable_4: (+1)
   \       0x4E   0xB007             ADD      SP,SP,#+28
   \       0x50   0xBDF0             POP      {R4-R7,PC}
    660          }
    661          
    662          /*
    663           * Make a signature
    664           */

   \                                 In section .text, align 2, keep-with-next
    665          int mbedtls_pk_sign(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    666                              const unsigned char *hash, size_t hash_len,
    667                              unsigned char *sig, size_t sig_size, size_t *sig_len,
    668                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    669          {
   \                     mbedtls_pk_sign: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    670              return mbedtls_pk_sign_restartable(ctx, md_alg, hash, hash_len,
    671                                                 sig, sig_size, sig_len,
    672                                                 f_rng, p_rng, NULL);
   \        0x4   0x9C0E             LDR      R4,[SP, #+56]
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x9505             STR      R5,[SP, #+20]
   \        0xA   0x9404             STR      R4,[SP, #+16]
   \        0xC   0x9D0D             LDR      R5,[SP, #+52]
   \        0xE   0x9C0C             LDR      R4,[SP, #+48]
   \       0x10   0x9503             STR      R5,[SP, #+12]
   \       0x12   0x9D0B             LDR      R5,[SP, #+44]
   \       0x14   0x9402             STR      R4,[SP, #+8]
   \       0x16   0x9C0A             LDR      R4,[SP, #+40]
   \       0x18   0x9501             STR      R5,[SP, #+4]
   \       0x1A   0x9400             STR      R4,[SP, #+0]
   \       0x1C   0x.... 0x....      BL       mbedtls_pk_sign_restartable
   \       0x20   0xB007             ADD      SP,SP,#+28
   \       0x22   0xBD30             POP      {R4,R5,PC}
    673          }
    674          
    675          #if defined(MBEDTLS_PSA_CRYPTO_C)
    676          /*
    677           * Make a signature given a signature type.
    678           */

   \                                 In section .text, align 2, keep-with-next
    679          int mbedtls_pk_sign_ext(mbedtls_pk_type_t pk_type,
    680                                  mbedtls_pk_context *ctx,
    681                                  mbedtls_md_type_t md_alg,
    682                                  const unsigned char *hash, size_t hash_len,
    683                                  unsigned char *sig, size_t sig_size, size_t *sig_len,
    684                                  int (*f_rng)(void *, unsigned char *, size_t),
    685                                  void *p_rng)
    686          {
   \                     mbedtls_pk_sign_ext: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x9F0F             LDR      R7,[SP, #+60]
   \        0x8   0x460C             MOV      R4,R1
    687          #if defined(MBEDTLS_RSA_C)
    688              psa_algorithm_t psa_md_alg;
    689          #endif /* MBEDTLS_RSA_C */
    690              *sig_len = 0;
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x4606             MOV      R6,R0
   \        0xE   0x6039             STR      R1,[R7, #+0]
    691          
    692              if (ctx->pk_info == NULL) {
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x4615             MOV      R5,R2
   \       0x14   0x4698             MOV      R8,R3
   \       0x16   0xB908             CBNZ.N   R0,??mbedtls_pk_sign_ext_0
    693                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \       0x18   0x....             LDR.N    R0,??DataTable14_3
   \       0x1A   0xE019             B.N      ??mbedtls_pk_sign_ext_1
    694              }
    695          
    696              if (!mbedtls_pk_can_do(ctx, pk_type)) {
   \                     ??mbedtls_pk_sign_ext_0: (+1)
   \       0x1C   0x4631             MOV      R1,R6
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       mbedtls_pk_can_do
   \       0x24   0xB908             CBNZ.N   R0,??mbedtls_pk_sign_ext_2
    697                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \       0x26   0x....             LDR.N    R0,??DataTable14_16
   \       0x28   0xE012             B.N      ??mbedtls_pk_sign_ext_1
    698              }
    699          
    700              if (pk_type != MBEDTLS_PK_RSASSA_PSS) {
   \                     ??mbedtls_pk_sign_ext_2: (+1)
   \       0x2A   0x2E06             CMP      R6,#+6
   \       0x2C   0xD00F             BEQ.N    ??mbedtls_pk_sign_ext_3
    701                  return mbedtls_pk_sign(ctx, md_alg, hash, hash_len,
    702                                         sig, sig_size, sig_len, f_rng, p_rng);
   \       0x2E   0x9911             LDR      R1,[SP, #+68]
   \       0x30   0x9810             LDR      R0,[SP, #+64]
   \       0x32   0x9104             STR      R1,[SP, #+16]
   \       0x34   0x990E             LDR      R1,[SP, #+56]
   \       0x36   0x9003             STR      R0,[SP, #+12]
   \       0x38   0x980D             LDR      R0,[SP, #+52]
   \       0x3A   0x9B0C             LDR      R3,[SP, #+48]
   \       0x3C   0x9101             STR      R1,[SP, #+4]
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x9702             STR      R7,[SP, #+8]
   \       0x42   0x4642             MOV      R2,R8
   \       0x44   0x4629             MOV      R1,R5
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x.... 0x....      BL       mbedtls_pk_sign
   \       0x4C   0xE000             B.N      ??mbedtls_pk_sign_ext_1
    703              }
    704          
    705          #if defined(MBEDTLS_RSA_C)
    706              psa_md_alg = mbedtls_md_psa_alg_from_type(md_alg);
    707              if (psa_md_alg == 0) {
    708                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    709              }
    710          
    711              if (mbedtls_pk_get_type(ctx) == MBEDTLS_PK_OPAQUE) {
    712                  psa_status_t status;
    713          
    714                  status = psa_sign_hash(ctx->priv_id, PSA_ALG_RSA_PSS(psa_md_alg),
    715                                         hash, hash_len,
    716                                         sig, sig_size, sig_len);
    717                  return PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    718              }
    719          
    720              return mbedtls_pk_psa_rsa_sign_ext(PSA_ALG_RSA_PSS(psa_md_alg),
    721                                                 ctx->pk_ctx, hash, hash_len,
    722                                                 sig, sig_size, sig_len);
    723          #else /* MBEDTLS_RSA_C */
    724              return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_sign_ext_3: (+1)
   \       0x4E   0x....             LDR.N    R0,??DataTable14_7
   \                     ??mbedtls_pk_sign_ext_1: (+1)
   \       0x50   0xB006             ADD      SP,SP,#+24
   \       0x52   0xE8BD 0x81F0      POP      {R4-R8,PC}
    725          #endif /* !MBEDTLS_RSA_C */
    726          
    727          }
    728          #endif /* MBEDTLS_PSA_CRYPTO_C */
    729          
    730          /*
    731           * Decrypt message
    732           */

   \                                 In section .text, align 2, keep-with-next
    733          int mbedtls_pk_decrypt(mbedtls_pk_context *ctx,
    734                                 const unsigned char *input, size_t ilen,
    735                                 unsigned char *output, size_t *olen, size_t osize,
    736                                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    737          {
   \                     mbedtls_pk_decrypt: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
    738              if (ctx->pk_info == NULL) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0xB90C             CBNZ.N   R4,??mbedtls_pk_decrypt_0
    739                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \        0x6   0x....             LDR.N    R0,??DataTable14_3
   \        0x8   0xE006             B.N      ??mbedtls_pk_decrypt_1
    740              }
    741          
    742              if (ctx->pk_info->decrypt_func == NULL) {
   \                     ??mbedtls_pk_decrypt_0: (+1)
   \        0xA   0x69A4             LDR      R4,[R4, #+24]
   \        0xC   0xB90C             CBNZ.N   R4,??mbedtls_pk_decrypt_2
    743                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \        0xE   0x....             LDR.N    R0,??DataTable14_16
   \       0x10   0xE002             B.N      ??mbedtls_pk_decrypt_1
    744              }
    745          
    746              return ctx->pk_info->decrypt_func(ctx, input, ilen,
    747                                                output, olen, osize, f_rng, p_rng);
   \                     ??mbedtls_pk_decrypt_2: (+1)
   \       0x12   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x16   0x47A0             BLX      R4
   \                     ??mbedtls_pk_decrypt_1: (+1)
   \       0x18   0xB004             ADD      SP,SP,#+16
   \       0x1A   0xBD70             POP      {R4-R6,PC}
    748          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x9E0B             LDR      R6,[SP, #+44]
   \        0x2   0x9D0A             LDR      R5,[SP, #+40]
   \        0x4   0x9603             STR      R6,[SP, #+12]
   \        0x6   0x9E09             LDR      R6,[SP, #+36]
   \        0x8   0x9502             STR      R5,[SP, #+8]
   \        0xA   0x9D08             LDR      R5,[SP, #+32]
   \        0xC   0x9601             STR      R6,[SP, #+4]
   \        0xE   0x9500             STR      R5,[SP, #+0]
   \       0x10   0x4770             BX       LR
    749          
    750          /*
    751           * Encrypt message
    752           */

   \                                 In section .text, align 2, keep-with-next
    753          int mbedtls_pk_encrypt(mbedtls_pk_context *ctx,
    754                                 const unsigned char *input, size_t ilen,
    755                                 unsigned char *output, size_t *olen, size_t osize,
    756                                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    757          {
   \                     mbedtls_pk_encrypt: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
    758              if (ctx->pk_info == NULL) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0xB90C             CBNZ.N   R4,??mbedtls_pk_encrypt_0
    759                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \        0x6   0x....             LDR.N    R0,??DataTable14_3
   \        0x8   0xE006             B.N      ??mbedtls_pk_encrypt_1
    760              }
    761          
    762              if (ctx->pk_info->encrypt_func == NULL) {
   \                     ??mbedtls_pk_encrypt_0: (+1)
   \        0xA   0x69E4             LDR      R4,[R4, #+28]
   \        0xC   0xB90C             CBNZ.N   R4,??mbedtls_pk_encrypt_2
    763                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \        0xE   0x....             LDR.N    R0,??DataTable14_16
   \       0x10   0xE002             B.N      ??mbedtls_pk_encrypt_1
    764              }
    765          
    766              return ctx->pk_info->encrypt_func(ctx, input, ilen,
    767                                                output, olen, osize, f_rng, p_rng);
   \                     ??mbedtls_pk_encrypt_2: (+1)
   \       0x12   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x16   0x47A0             BLX      R4
   \                     ??mbedtls_pk_encrypt_1: (+1)
   \       0x18   0xB004             ADD      SP,SP,#+16
   \       0x1A   0xBD70             POP      {R4-R6,PC}
    768          }
    769          
    770          /*
    771           * Check public-private key pair
    772           */

   \                                 In section .text, align 2, keep-with-next
    773          int mbedtls_pk_check_pair(const mbedtls_pk_context *pub,
    774                                    const mbedtls_pk_context *prv,
    775                                    int (*f_rng)(void *, unsigned char *, size_t),
    776                                    void *p_rng)
    777          {
   \                     mbedtls_pk_check_pair: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    778              if (pub->pk_info == NULL ||
    779                  prv->pk_info == NULL) {
   \        0x2   0x6805             LDR      R5,[R0, #+0]
   \        0x4   0x2D00             CMP      R5,#+0
   \        0x6   0xBF1C             ITT      NE
   \        0x8   0x680E             LDRNE    R6,[R1, #+0]
   \        0xA   0x2E00             CMPNE    R6,#+0
   \        0xC   0xD001             BEQ.N    ??mbedtls_pk_check_pair_0
    780                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    781              }
    782          
    783              if (f_rng == NULL) {
   \        0xE   0x0014             MOVS     R4,R2
   \       0x10   0xD101             BNE.N    ??mbedtls_pk_check_pair_1
    784                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_check_pair_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable14_3
   \       0x14   0xBDF2             POP      {R1,R4-R7,PC}
    785              }
    786          
    787              if (prv->pk_info->check_pair_func == NULL) {
   \                     ??mbedtls_pk_check_pair_1: (+1)
   \       0x16   0x6A34             LDR      R4,[R6, #+32]
   \       0x18   0xB90C             CBNZ.N   R4,??mbedtls_pk_check_pair_2
    788                  return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \       0x1A   0x....             LDR.N    R0,??DataTable14_7
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
    789              }
    790          
    791              if (prv->pk_info->type == MBEDTLS_PK_RSA_ALT) {
   \                     ??mbedtls_pk_check_pair_2: (+1)
   \       0x1E   0x7837             LDRB     R7,[R6, #+0]
   \       0x20   0x2F05             CMP      R7,#+5
   \       0x22   0xD104             BNE.N    ??mbedtls_pk_check_pair_3
    792                  if (pub->pk_info->type != MBEDTLS_PK_RSA) {
   \       0x24   0x782D             LDRB     R5,[R5, #+0]
   \       0x26   0x2D01             CMP      R5,#+1
   \       0x28   0xD105             BNE.N    ??mbedtls_pk_check_pair_4
    793                      return MBEDTLS_ERR_PK_TYPE_MISMATCH;
    794                  }
    795              } else {
    796                  if ((prv->pk_info->type != MBEDTLS_PK_OPAQUE) &&
    797                      (pub->pk_info != prv->pk_info)) {
    798                      return MBEDTLS_ERR_PK_TYPE_MISMATCH;
    799                  }
    800              }
    801          
    802              return prv->pk_info->check_pair_func((mbedtls_pk_context *) pub,
    803                                                   (mbedtls_pk_context *) prv,
    804                                                   f_rng, p_rng);
   \                     ??mbedtls_pk_check_pair_5: (+1)
   \       0x2A   0x47A0             BLX      R4
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??mbedtls_pk_check_pair_3: (+1)
   \       0x2E   0x2F07             CMP      R7,#+7
   \       0x30   0xBF18             IT       NE
   \       0x32   0x42B5             CMPNE    R5,R6
   \       0x34   0xD0F9             BEQ.N    ??mbedtls_pk_check_pair_5
   \                     ??mbedtls_pk_check_pair_4: (+1)
   \       0x36   0x....             LDR.N    R0,??DataTable14_16
   \       0x38   0xBDF2             POP      {R1,R4-R7,PC}
    805          }
    806          
    807          /*
    808           * Get key size in bits
    809           */

   \                                 In section .text, align 2, keep-with-next
    810          size_t mbedtls_pk_get_bitlen(const mbedtls_pk_context *ctx)
    811          {
    812              /* For backward compatibility, accept NULL or a context that
    813               * isn't set up yet, and return a fake value that should be safe. */
    814              if (ctx == NULL || ctx->pk_info == NULL) {
   \                     mbedtls_pk_get_bitlen: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1F             ITTTT    NE
   \        0x4   0x6801             LDRNE    R1,[R0, #+0]
   \        0x6   0x2900             CMPNE    R1,#+0
    815                  return 0;
    816              }
    817          
    818              return ctx->pk_info->get_bitlen((mbedtls_pk_context *) ctx);
   \        0x8   0x6889             LDRNE    R1,[R1, #+8]
   \        0xA   0x4708             BXNE     R1
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
    819          }
    820          
    821          /*
    822           * Export debug information
    823           */

   \                                 In section .text, align 2, keep-with-next
    824          int mbedtls_pk_debug(const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items)
    825          {
   \                     mbedtls_pk_debug: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    826              if (ctx->pk_info == NULL) {
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xB90A             CBNZ.N   R2,??mbedtls_pk_debug_0
    827                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \        0x6   0x....             LDR.N    R0,??DataTable14_3
   \        0x8   0xBD02             POP      {R1,PC}
    828              }
    829          
    830              if (ctx->pk_info->debug_func == NULL) {
   \                     ??mbedtls_pk_debug_0: (+1)
   \        0xA   0x6AD2             LDR      R2,[R2, #+44]
   \        0xC   0xB90A             CBNZ.N   R2,??mbedtls_pk_debug_1
    831                  return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \        0xE   0x....             LDR.N    R0,??DataTable14_16
   \       0x10   0xBD02             POP      {R1,PC}
    832              }
    833          
    834              ctx->pk_info->debug_func((mbedtls_pk_context *) ctx, items);
   \                     ??mbedtls_pk_debug_1: (+1)
   \       0x12   0x4790             BLX      R2
    835              return 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD02             POP      {R1,PC}
    836          }
    837          
    838          /*
    839           * Access the PK type name
    840           */

   \                                 In section .text, align 4, keep-with-next
    841          const char *mbedtls_pk_get_name(const mbedtls_pk_context *ctx)
    842          {
    843              if (ctx == NULL || ctx->pk_info == NULL) {
   \                     mbedtls_pk_get_name: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x6800             LDRNE    R0,[R0, #+0]
   \        0x6   0x2800             CMPNE    R0,#+0
   \        0x8   0xD102             BNE.N    ??mbedtls_pk_get_name_0
    844                  return "invalid PK";
   \        0xA   0xBF00             Nop
   \        0xC   0x....             ADR.N    R0,?_3
   \        0xE   0x4770             BX       LR
    845              }
    846          
    847              return ctx->pk_info->name;
   \                     ??mbedtls_pk_get_name_0: (+1)
   \       0x10   0x6840             LDR      R0,[R0, #+4]
   \       0x12   0x4770             BX       LR
    848          }
    849          
    850          /*
    851           * Access the PK type
    852           */

   \                                 In section .text, align 2, keep-with-next
    853          mbedtls_pk_type_t mbedtls_pk_get_type(const mbedtls_pk_context *ctx)
    854          {
    855              if (ctx == NULL || ctx->pk_info == NULL) {
   \                     mbedtls_pk_get_type: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x6800             LDRNE    R0,[R0, #+0]
   \        0x6   0x2800             CMPNE    R0,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_pk_get_type_0
    856                  return MBEDTLS_PK_NONE;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    857              }
    858          
    859              return ctx->pk_info->type;
   \                     ??mbedtls_pk_get_type_0: (+1)
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0x4770             BX       LR
    860          }
    861          
    862          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    863          /*
    864           * Load the key to a PSA key slot,
    865           * then turn the PK context into a wrapper for that key slot.
    866           *
    867           * Currently only works for EC & RSA private keys.
    868           */

   \                                 In section .text, align 2, keep-with-next
    869          int mbedtls_pk_wrap_as_opaque(mbedtls_pk_context *pk,
    870                                        mbedtls_svc_key_id_t *key,
    871                                        psa_algorithm_t alg,
    872                                        psa_key_usage_t usage,
    873                                        psa_algorithm_t alg2)
    874          {
   \                     mbedtls_pk_wrap_as_opaque: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB0BA             SUB      SP,SP,#+232
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4614             MOV      R4,R2
   \        0xC   0x461E             MOV      R6,R3
    875          #if !defined(MBEDTLS_PK_HAVE_ECC_KEYS) && !defined(MBEDTLS_RSA_C)
    876              ((void) pk);
    877              ((void) key);
    878              ((void) alg);
    879              ((void) usage);
    880              ((void) alg2);
    881          #else /* !MBEDTLS_PK_HAVE_ECC_KEYS && !MBEDTLS_RSA_C */
    882          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    883              if (mbedtls_pk_get_type(pk) == MBEDTLS_PK_ECKEY) {
   \        0xE   0x.... 0x....      BL       mbedtls_pk_get_type
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD15C             BNE.N    ??mbedtls_pk_wrap_as_opaque_0
    884                  size_t d_len;
    885                  psa_ecc_family_t curve_id;
    886                  psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x16   0x.... 0x....      BL       ?Subroutine0
    887                  psa_key_type_t key_type;
    888                  size_t bits;
    889                  psa_status_t status;
    890          
    891                  /* export the private key material in the format PSA wants */
    892          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
    893                  unsigned char d[MBEDTLS_PSA_MAX_EC_KEY_PAIR_LENGTH];
    894                  status = psa_export_key(pk->priv_id, d, sizeof(d), &d_len);
    895                  if (status != PSA_SUCCESS) {
    896                      return psa_pk_status_to_mbedtls(status);
    897                  }
    898          
    899                  curve_id = pk->ec_family;
    900                  bits = pk->ec_bits;
    901          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
    902                  unsigned char d[MBEDTLS_ECP_MAX_BYTES];
    903                  mbedtls_ecp_keypair *ec = mbedtls_pk_ec_rw(*pk);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x1A   0xA812             ADD      R0,SP,#+72
   \       0x1C   0x4641             MOV      R1,R8
   \       0x1E   0x22A0             MOVS     R2,#+160
   \       0x20   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x24   0xA812             ADD      R0,SP,#+72
   \       0x26   0x.... 0x....      BL       mbedtls_pk_get_type
   \       0x2A   0x1E80             SUBS     R0,R0,#+2
   \       0x2C   0x2802             CMP      R0,#+2
   \       0x2E   0xBF94             ITE      LS
   \       0x30   0x9F13             LDRLS    R7,[SP, #+76]
   \       0x32   0x2700             MOVHI    R7,#+0
    904                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    905          
    906                  d_len = PSA_BITS_TO_BYTES(ec->grp.nbits);
   \       0x34   0x6C3D             LDR      R5,[R7, #+64]
    907                  if ((ret = mbedtls_ecp_write_key(ec, d, d_len)) != 0) {
   \       0x36   0xA90A             ADD      R1,SP,#+40
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x1DED             ADDS     R5,R5,#+7
   \       0x3C   0x08EA             LSRS     R2,R5,#+3
   \       0x3E   0x.... 0x....      BL       mbedtls_ecp_write_key
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD145             BNE.N    ??mbedtls_pk_wrap_as_opaque_1
    908                      return ret;
    909                  }
    910          
    911                  curve_id = mbedtls_ecc_group_to_psa(ec->grp.id, &bits);
    912          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
    913                  key_type = PSA_KEY_TYPE_ECC_KEY_PAIR(curve_id);
    914          
    915                  /* prepare the key attributes */
    916                  psa_set_key_type(&attributes, key_type);
   \       0x46   0x7838             LDRB     R0,[R7, #+0]
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   \       0x4E   0x9908             LDR      R1,[SP, #+32]
   \       0x50   0xF440 0x40E2      ORR      R0,R0,#0x7100
   \       0x54   0xB911             CBNZ.N   R1,??mbedtls_pk_wrap_as_opaque_2
   \       0x56   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x5A   0xE005             B.N      ??mbedtls_pk_wrap_as_opaque_3
   \                     ??mbedtls_pk_wrap_as_opaque_2: (+1)
   \       0x5C   0x4601             MOV      R1,R0
   \       0x5E   0x2300             MOVS     R3,#+0
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0xA801             ADD      R0,SP,#+4
   \       0x64   0x.... 0x....      BL       psa_set_key_domain_parameters
    917                  psa_set_key_bits(&attributes, bits);
   \                     ??mbedtls_pk_wrap_as_opaque_3: (+1)
   \       0x68   0x9A00             LDR      R2,[SP, #+0]
   \       0x6A   0xF64F 0x71F9      MOVW     R1,#+65529
   \       0x6E   0x428A             CMP      R2,R1
   \       0x70   0xBF26             ITTE     CS
   \       0x72   0xF64F 0x70FF      MOVWCS   R0,#+65535
   \       0x76   0xF8AD 0x0006      STRHCS   R0,[SP, #+6]
   \       0x7A   0xF8AD 0x2006      STRHCC   R2,[SP, #+6]
    918                  psa_set_key_usage_flags(&attributes, usage);
   \       0x7E   0x04F0             LSLS     R0,R6,#+19
   \       0x80   0xBF48             IT       MI
   \       0x82   0xF446 0x6680      ORRMI    R6,R6,#0x400
   \       0x86   0x04B0             LSLS     R0,R6,#+18
   \       0x88   0xBF48             IT       MI
   \       0x8A   0xF446 0x6600      ORRMI    R6,R6,#0x800
   \       0x8E   0x9842             LDR      R0,[SP, #+264]
   \       0x90   0x9604             STR      R6,[SP, #+16]
    919                  psa_set_key_algorithm(&attributes, alg);
   \       0x92   0x9405             STR      R4,[SP, #+20]
    920                  if (alg2 != PSA_ALG_NONE) {
   \       0x94   0xB100             CBZ.N    R0,??mbedtls_pk_wrap_as_opaque_4
    921                      psa_set_key_enrollment_algorithm(&attributes, alg2);
   \       0x96   0x9006             STR      R0,[SP, #+24]
    922                  }
    923          
    924                  /* import private key into PSA */
    925                  status = psa_import_key(&attributes, d, d_len, key);
   \                     ??mbedtls_pk_wrap_as_opaque_4: (+1)
   \       0x98   0x464B             MOV      R3,R9
   \       0x9A   0x08EA             LSRS     R2,R5,#+3
   \       0x9C   0xA90A             ADD      R1,SP,#+40
   \       0x9E   0xA801             ADD      R0,SP,#+4
   \       0xA0   0x.... 0x....      BL       psa_import_key
   \       0xA4   0x4604             MOV      R4,R0
    926                  mbedtls_platform_zeroize(d, sizeof(d));
   \       0xA6   0x2120             MOVS     R1,#+32
   \       0xA8   0xA80A             ADD      R0,SP,#+40
   \       0xAA   0x.... 0x....      BL       mbedtls_platform_zeroize
    927                  if (status != PSA_SUCCESS) {
   \       0xAE   0xB11C             CBZ.N    R4,??mbedtls_pk_wrap_as_opaque_5
    928                      return PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xB0   0x4620             MOV      R0,R4
   \       0xB2   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xB6   0xE00C             B.N      ??mbedtls_pk_wrap_as_opaque_1
    929                  }
    930          
    931                  /* make PK context wrap the key slot */
    932                  mbedtls_pk_free(pk);
   \                     ??mbedtls_pk_wrap_as_opaque_5: (+1)
   \       0xB8   0x4640             MOV      R0,R8
   \       0xBA   0x.... 0x....      BL       mbedtls_pk_free
    933                  mbedtls_pk_init(pk);
   \       0xBE   0x4640             MOV      R0,R8
   \       0xC0   0x.... 0x....      BL       mbedtls_pk_init
    934          
    935                  return mbedtls_pk_setup_opaque(pk, *key);
   \       0xC4   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0xC8   0x4640             MOV      R0,R8
   \       0xCA   0x.... 0x....      BL       mbedtls_pk_setup_opaque
   \       0xCE   0xE000             B.N      ??mbedtls_pk_wrap_as_opaque_1
    936              } else
    937          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    938          #if defined(MBEDTLS_RSA_C)
    939              if (mbedtls_pk_get_type(pk) == MBEDTLS_PK_RSA) {
    940                  unsigned char buf[MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES];
    941                  psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    942                  int key_len;
    943                  psa_status_t status;
    944          
    945                  /* export the private key material in the format PSA wants */
    946                  key_len = mbedtls_pk_write_key_der(pk, buf, sizeof(buf));
    947                  if (key_len <= 0) {
    948                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    949                  }
    950          
    951                  /* prepare the key attributes */
    952                  psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_KEY_PAIR);
    953                  psa_set_key_bits(&attributes, mbedtls_pk_get_bitlen(pk));
    954                  psa_set_key_usage_flags(&attributes, usage);
    955                  psa_set_key_algorithm(&attributes, alg);
    956                  if (alg2 != PSA_ALG_NONE) {
    957                      psa_set_key_enrollment_algorithm(&attributes, alg2);
    958                  }
    959          
    960                  /* import private key into PSA */
    961                  status = psa_import_key(&attributes,
    962                                          buf + sizeof(buf) - key_len,
    963                                          key_len, key);
    964          
    965                  mbedtls_platform_zeroize(buf, sizeof(buf));
    966          
    967                  if (status != PSA_SUCCESS) {
    968                      return PSA_PK_TO_MBEDTLS_ERR(status);
    969                  }
    970          
    971                  /* make PK context wrap the key slot */
    972                  mbedtls_pk_free(pk);
    973                  mbedtls_pk_init(pk);
    974          
    975                  return mbedtls_pk_setup_opaque(pk, *key);
    976              } else
    977          #endif /* MBEDTLS_RSA_C */
    978          #endif /* !MBEDTLS_PK_HAVE_ECC_KEYS && !MBEDTLS_RSA_C */
    979              return MBEDTLS_ERR_PK_TYPE_MISMATCH;
   \                     ??mbedtls_pk_wrap_as_opaque_0: (+1)
   \       0xD0   0x....             LDR.N    R0,??DataTable14_16
   \                     ??mbedtls_pk_wrap_as_opaque_1: (+1)
   \       0xD2   0xB03B             ADD      SP,SP,#+236
   \       0xD4   0xE8BD 0x83F0      POP      {R4-R9,PC}
    980          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     mbedtls_eckey_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     mbedtls_eckeydh_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     mbedtls_ecdsa_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0xFFFF'C180        DC32     0xffffc180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0xFFFF'C080        DC32     0xffffc080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     mbedtls_ecdsa_opaque_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     mbedtls_rsa_opaque_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0xFFFF'C680        DC32     0xffffc680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x0700'0200        DC32     0x7000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x0600'1300        DC32     0x6001300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x0600'0300        DC32     0x6000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x0600'0200        DC32     0x6000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x0902'0000        DC32     0x9020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x0600'0900        DC32     0x6000900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x0600'0400        DC32     0x6000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \        0x0   0x0200'00FF        DC32     0x20000ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \        0x0   0xFFFF'C100        DC32     0xffffc100

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x69 0x6E          DC8 "invalid PK"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x50 0x4B    
   \              0x00
   \        0xB                      DS8 1
    981          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    982          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_pk_can_do
         0   -- Indirect call
      80   mbedtls_pk_can_do_ext
        80   -- Indirect call
        80   -> __aeabi_memclr4
        80   -> mbedtls_pk_get_type
        80   -> psa_get_key_attributes
        80   -> psa_reset_key_attributes
      24   mbedtls_pk_check_pair
        24   -- Indirect call
       8   mbedtls_pk_debug
         8   -- Indirect call
      32   mbedtls_pk_decrypt
        32   -- Indirect call
      32   mbedtls_pk_encrypt
        32   -- Indirect call
       8   mbedtls_pk_free
         8   -- Indirect call
         0   -> mbedtls_platform_zeroize
       0   mbedtls_pk_get_bitlen
         0   -- Indirect call
       0   mbedtls_pk_get_name
       0   mbedtls_pk_get_type
       0   mbedtls_pk_info_from_type
       0   mbedtls_pk_init
      16   mbedtls_pk_setup
        16   -- Indirect call
      56   mbedtls_pk_setup_opaque
        56   -> __aeabi_memclr4
        56   -> psa_get_key_attributes
        56   -> psa_reset_key_attributes
      40   mbedtls_pk_sign
        40   -> mbedtls_pk_sign_restartable
      48   mbedtls_pk_sign_ext
        48   -> mbedtls_pk_can_do
        48   -> mbedtls_pk_sign
      48   mbedtls_pk_sign_restartable
        48   -- Indirect call
        48   -> pk_hashlen_helper
      24   mbedtls_pk_verify
        24   -> mbedtls_pk_verify_restartable
      40   mbedtls_pk_verify_ext
        40   -> mbedtls_pk_can_do
        40   -> mbedtls_pk_verify
      32   mbedtls_pk_verify_restartable
        32   -- Indirect call
        32   -> pk_hashlen_helper
     264   mbedtls_pk_wrap_as_opaque
       264   -> __aeabi_memclr4
       264   -> __aeabi_memcpy4
       264   -> mbedtls_ecc_group_to_psa
       264   -> mbedtls_ecp_write_key
       264   -> mbedtls_pk_free
       264   -> mbedtls_pk_get_type
       264   -> mbedtls_pk_init
       264   -> mbedtls_pk_setup_opaque
       264   -> mbedtls_platform_zeroize
       264   -> psa_import_key
       264   -> psa_pk_status_to_mbedtls
       264   -> psa_set_key_domain_parameters
       8   pk_hashlen_helper
         8   -> mbedtls_md_get_size
         8   -> mbedtls_md_info_from_type


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       8  ?Subroutine0
      18  ?Subroutine1
      36  ?_0
      36  ?_1
      36  ?_2
      12  ?_3
      20  mbedtls_pk_can_do
     562  mbedtls_pk_can_do_ext
      58  mbedtls_pk_check_pair
      24  mbedtls_pk_debug
      28  mbedtls_pk_decrypt
      28  mbedtls_pk_encrypt
      34  mbedtls_pk_free
      16  mbedtls_pk_get_bitlen
      20  mbedtls_pk_get_name
      18  mbedtls_pk_get_type
      36  mbedtls_pk_info_from_type
      10  mbedtls_pk_init
      40  mbedtls_pk_setup
      90  mbedtls_pk_setup_opaque
      36  mbedtls_pk_sign
      86  mbedtls_pk_sign_ext
      82  mbedtls_pk_sign_restartable
      20  mbedtls_pk_verify
      88  mbedtls_pk_verify_ext
      70  mbedtls_pk_verify_restartable
     216  mbedtls_pk_wrap_as_opaque
      30  pk_hashlen_helper

 
   108 bytes in section .rodata
 1'718 bytes in section .text
 
 1'718 bytes of CODE  memory
   108 bytes of CONST memory

Errors: none
Warnings: none
