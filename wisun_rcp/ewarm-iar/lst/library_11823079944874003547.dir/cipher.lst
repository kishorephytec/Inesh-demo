###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:22
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\cipher.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\cipher.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\cipher.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\cipher.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\cipher.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\cipher.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\cipher.c
      1          /**
      2           * \file cipher.c
      3           *
      4           * \brief Generic cipher wrapper for Mbed TLS
      5           *
      6           * \author Adriaan de Jong <dejong@fox-it.com>
      7           *
      8           *  Copyright The Mbed TLS Contributors
      9           *  SPDX-License-Identifier: Apache-2.0
     10           *
     11           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     12           *  not use this file except in compliance with the License.
     13           *  You may obtain a copy of the License at
     14           *
     15           *  http://www.apache.org/licenses/LICENSE-2.0
     16           *
     17           *  Unless required by applicable law or agreed to in writing, software
     18           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     19           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     20           *  See the License for the specific language governing permissions and
     21           *  limitations under the License.
     22           */
     23          
     24          #include "common.h"
     25          
     26          #if defined(MBEDTLS_CIPHER_C)
     27          
     28          #include "mbedtls/cipher.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp size_t mbedtls_cipher_info_get_key_bitlen(mbedtls_cipher_info_t const *)
   \                     mbedtls_cipher_info_get_key_bitlen: (+1)
   \        0x0   0xB118             CBZ.N    R0,??mbedtls_cipher_info_get_key_bitlen_0
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0xF3C0 0x2003      UBFX     R0,R0,#+8,#+4
   \        0x8   0x0180             LSLS     R0,R0,#+6
   \                     ??mbedtls_cipher_info_get_key_bitlen_0: (+1)
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned int mbedtls_cipher_get_block_size(mbedtls_cipher_context_t const *)
   \                     mbedtls_cipher_get_block_size: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0xB110             CBZ.N    R0,??mbedtls_cipher_get_block_size_0
   \        0x4   0x7900             LDRB     R0,[R0, #+4]
   \        0x6   0xF000 0x001F      AND      R0,R0,#0x1F
   \                     ??mbedtls_cipher_get_block_size_0: (+1)
   \        0xA   0x4770             BX       LR
     29          #include "cipher_wrap.h"
     30          #include "mbedtls/platform_util.h"
     31          #include "mbedtls/error.h"
     32          #include "mbedtls/constant_time.h"
     33          #include "constant_time_internal.h"
     34          
     35          #include <stdlib.h>
     36          #include <string.h>
     37          
     38          #if defined(MBEDTLS_CHACHAPOLY_C)
     39          #include "mbedtls/chachapoly.h"
     40          #endif
     41          
     42          #if defined(MBEDTLS_GCM_C)
     43          #include "mbedtls/gcm.h"
     44          #endif
     45          
     46          #if defined(MBEDTLS_CCM_C)
     47          #include "mbedtls/ccm.h"
     48          #endif
     49          
     50          #if defined(MBEDTLS_CHACHA20_C)
     51          #include "mbedtls/chacha20.h"
     52          #endif
     53          
     54          #if defined(MBEDTLS_CMAC_C)
     55          #include "mbedtls/cmac.h"
     56          #endif
     57          
     58          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
     59          #include "psa/crypto.h"
     60          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
     61          
     62          #if defined(MBEDTLS_NIST_KW_C)
     63          #include "mbedtls/nist_kw.h"
     64          #endif
     65          
     66          #include "mbedtls/platform.h"
     67          

   \                                 In section .bss, align 4
     68          static int supported_init = 0;
   \                     supported_init:
   \        0x0                      DS8 4
     69          

   \                                 In section .text, align 2, keep-with-next
     70          static inline const mbedtls_cipher_base_t *mbedtls_cipher_get_base(
     71              const mbedtls_cipher_info_t *info)
     72          {
     73              return mbedtls_cipher_base_lookup_table[info->base_idx];
   \                     mbedtls_cipher_get_base: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable17
   \        0x6   0xF3C0 0x6084      UBFX     R0,R0,#+26,#+5
   \        0xA   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0xE   0x4770             BX       LR
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          const int *mbedtls_cipher_list(void)
     77          {
   \                     mbedtls_cipher_list: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable17_1
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD000             BEQ.N    ??mbedtls_cipher_list_0
   \        0xE   0x4770             BX       LR
   \                     ??mbedtls_cipher_list_0: (+1)
   \       0x10   0xB530             PUSH     {R4,R5,LR}
     78              const mbedtls_cipher_definition_t *def;
     79              int *type;
     80          
     81              if (!supported_init) {
     82                  def = mbedtls_cipher_definitions;
   \       0x12   0x.... 0x....      LDR.W    R3,??DataTable17_3
     83                  type = mbedtls_cipher_supported;
   \       0x16   0x4604             MOV      R4,R0
   \       0x18   0xE003             B.N      ??mbedtls_cipher_list_1
     84          
     85                  while (def->type != 0) {
     86                      *type++ = (*def++).type;
   \                     ??mbedtls_cipher_list_2: (+1)
   \       0x1A   0xF813 0x5B08      LDRB     R5,[R3], #+8
   \       0x1E   0xF844 0x5B04      STR      R5,[R4], #+4
     87                  }
   \                     ??mbedtls_cipher_list_1: (+1)
   \       0x22   0x7819             LDRB     R1,[R3, #+0]
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD1F8             BNE.N    ??mbedtls_cipher_list_2
     88          
     89                  *type = 0;
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x6023             STR      R3,[R4, #+0]
     90          
     91                  supported_init = 1;
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x6011             STR      R1,[R2, #+0]
     92              }
     93          
     94              return mbedtls_cipher_supported;
   \       0x30   0xBD30             POP      {R4,R5,PC}
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_type(
     98              const mbedtls_cipher_type_t cipher_type)
     99          {
    100              const mbedtls_cipher_definition_t *def;
    101          
    102              for (def = mbedtls_cipher_definitions; def->info != NULL; def++) {
   \                     mbedtls_cipher_info_from_type: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable17_3
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0xE000             B.N      ??mbedtls_cipher_info_from_type_0
   \                     ??mbedtls_cipher_info_from_type_1: (+1)
   \        0x8   0x3208             ADDS     R2,R2,#+8
   \                     ??mbedtls_cipher_info_from_type_0: (+1)
   \        0xA   0x6850             LDR      R0,[R2, #+4]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x7813             LDRBNE   R3,[R2, #+0]
   \       0x12   0x428B             CMPNE    R3,R1
    103                  if (def->type == cipher_type) {
   \       0x14   0xD1F8             BNE.N    ??mbedtls_cipher_info_from_type_1
    104                      return def->info;
   \       0x16   0x4770             BX       LR
    105                  }
    106              }
    107          
    108              return NULL;
    109          }
    110          

   \                                 In section .text, align 2, keep-with-next
    111          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_string(
    112              const char *cipher_name)
    113          {
   \                     mbedtls_cipher_info_from_string: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    114              const mbedtls_cipher_definition_t *def;
    115          
    116              if (NULL == cipher_name) {
   \        0x4   0xD00D             BEQ.N    ??mbedtls_cipher_info_from_string_0
    117                  return NULL;
    118              }
    119          
    120              for (def = mbedtls_cipher_definitions; def->info != NULL; def++) {
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable17_3
   \        0xA   0xE000             B.N      ??mbedtls_cipher_info_from_string_1
   \                     ??mbedtls_cipher_info_from_string_2: (+1)
   \        0xC   0x3508             ADDS     R5,R5,#+8
   \                     ??mbedtls_cipher_info_from_string_1: (+1)
   \        0xE   0x6868             LDR      R0,[R5, #+4]
   \       0x10   0xB138             CBZ.N    R0,??mbedtls_cipher_info_from_string_0
    121                  if (!strcmp(def->info->name, cipher_name)) {
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x.... 0x....      BL       strcmp
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD1F6             BNE.N    ??mbedtls_cipher_info_from_string_2
    122                      return def->info;
   \       0x1E   0x6868             LDR      R0,[R5, #+4]
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
    123                  }
    124              }
    125          
    126              return NULL;
   \                     ??mbedtls_cipher_info_from_string_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    127          }
    128          

   \                                 In section .text, align 2, keep-with-next
    129          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values(
    130              const mbedtls_cipher_id_t cipher_id,
    131              int key_bitlen,
    132              const mbedtls_cipher_mode_t mode)
    133          {
   \                     mbedtls_cipher_info_from_values: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    134              const mbedtls_cipher_definition_t *def;
    135          
    136              for (def = mbedtls_cipher_definitions; def->info != NULL; def++) {
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable17_3
   \        0xC   0xE000             B.N      ??mbedtls_cipher_info_from_values_0
   \                     ??mbedtls_cipher_info_from_values_1: (+1)
   \        0xE   0x3708             ADDS     R7,R7,#+8
   \                     ??mbedtls_cipher_info_from_values_0: (+1)
   \       0x10   0x6878             LDR      R0,[R7, #+4]
   \       0x12   0xB180             CBZ.N    R0,??mbedtls_cipher_info_from_values_2
    137                  if (mbedtls_cipher_get_base(def->info)->cipher == cipher_id &&
    138                      mbedtls_cipher_info_get_key_bitlen(def->info) == (unsigned) key_bitlen &&
    139                      def->info->mode == mode) {
   \       0x14   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0x42A1             CMP      R1,R4
   \       0x1C   0xD1F7             BNE.N    ??mbedtls_cipher_info_from_values_1
   \       0x1E   0x6878             LDR      R0,[R7, #+4]
   \       0x20   0x.... 0x....      BL       mbedtls_cipher_info_get_key_bitlen
   \       0x24   0x42A8             CMP      R0,R5
   \       0x26   0xBF01             ITTTT    EQ
   \       0x28   0x6879             LDREQ    R1,[R7, #+4]
   \       0x2A   0x6848             LDREQ    R0,[R1, #+4]
   \       0x2C   0xF3C0 0x3103      UBFXEQ   R1,R0,#+12,#+4
   \       0x30   0x42B1             CMPEQ    R1,R6
   \       0x32   0xD1EC             BNE.N    ??mbedtls_cipher_info_from_values_1
    140                      return def->info;
   \       0x34   0x6878             LDR      R0,[R7, #+4]
   \                     ??mbedtls_cipher_info_from_values_2: (+1)
   \       0x36   0xBDF2             POP      {R1,R4-R7,PC}
    141                  }
    142              }
    143          
    144              return NULL;
    145          }
    146          
    147          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    148          static inline psa_key_type_t mbedtls_psa_translate_cipher_type(
    149              mbedtls_cipher_type_t cipher)
    150          {
    151              switch (cipher) {
    152                  case MBEDTLS_CIPHER_AES_128_CCM:
    153                  case MBEDTLS_CIPHER_AES_192_CCM:
    154                  case MBEDTLS_CIPHER_AES_256_CCM:
    155                  case MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG:
    156                  case MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG:
    157                  case MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG:
    158                  case MBEDTLS_CIPHER_AES_128_GCM:
    159                  case MBEDTLS_CIPHER_AES_192_GCM:
    160                  case MBEDTLS_CIPHER_AES_256_GCM:
    161                  case MBEDTLS_CIPHER_AES_128_CBC:
    162                  case MBEDTLS_CIPHER_AES_192_CBC:
    163                  case MBEDTLS_CIPHER_AES_256_CBC:
    164                  case MBEDTLS_CIPHER_AES_128_ECB:
    165                  case MBEDTLS_CIPHER_AES_192_ECB:
    166                  case MBEDTLS_CIPHER_AES_256_ECB:
    167                      return PSA_KEY_TYPE_AES;
    168          
    169                  /* ARIA not yet supported in PSA. */
    170                  /* case MBEDTLS_CIPHER_ARIA_128_CCM:
    171                     case MBEDTLS_CIPHER_ARIA_192_CCM:
    172                     case MBEDTLS_CIPHER_ARIA_256_CCM:
    173                     case MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG:
    174                     case MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG:
    175                     case MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG:
    176                     case MBEDTLS_CIPHER_ARIA_128_GCM:
    177                     case MBEDTLS_CIPHER_ARIA_192_GCM:
    178                     case MBEDTLS_CIPHER_ARIA_256_GCM:
    179                     case MBEDTLS_CIPHER_ARIA_128_CBC:
    180                     case MBEDTLS_CIPHER_ARIA_192_CBC:
    181                     case MBEDTLS_CIPHER_ARIA_256_CBC:
    182                         return( PSA_KEY_TYPE_ARIA ); */
    183          
    184                  default:
    185                      return 0;
    186              }
    187          }
    188          
    189          static inline psa_algorithm_t mbedtls_psa_translate_cipher_mode(
    190              mbedtls_cipher_mode_t mode, size_t taglen)
    191          {
    192              switch (mode) {
    193                  case MBEDTLS_MODE_ECB:
    194                      return PSA_ALG_ECB_NO_PADDING;
    195                  case MBEDTLS_MODE_GCM:
    196                      return PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, taglen);
    197                  case MBEDTLS_MODE_CCM:
    198                      return PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen);
    199                  case MBEDTLS_MODE_CCM_STAR_NO_TAG:
    200                      return PSA_ALG_CCM_STAR_NO_TAG;
    201                  case MBEDTLS_MODE_CBC:
    202                      if (taglen == 0) {
    203                          return PSA_ALG_CBC_NO_PADDING;
    204                      } else {
    205                          return 0;
    206                      }
    207                  default:
    208                      return 0;
    209              }
    210          }
    211          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    212          

   \                                 In section .text, align 2, keep-with-next
    213          void mbedtls_cipher_init(mbedtls_cipher_context_t *ctx)
    214          {
    215              memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
   \                     mbedtls_cipher_init: (+1)
   \        0x0   0x2148             MOVS     R1,#+72
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4
    216          }
    217          

   \                                 In section .text, align 2, keep-with-next
    218          void mbedtls_cipher_free(mbedtls_cipher_context_t *ctx)
    219          {
   \                     mbedtls_cipher_free: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    220              if (ctx == NULL) {
   \        0x4   0xD01E             BEQ.N    ??mbedtls_cipher_free_0
    221                  return;
    222              }
    223          
    224          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    225              if (ctx->psa_enabled == 1) {
   \        0x6   0xF895 0x0044      LDRB     R0,[R5, #+68]
   \        0xA   0x6BEC             LDR      R4,[R5, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD10B             BNE.N    ??mbedtls_cipher_free_1
    226                  if (ctx->cipher_ctx != NULL) {
   \       0x10   0xB194             CBZ.N    R4,??mbedtls_cipher_free_2
    227                      mbedtls_cipher_context_psa * const cipher_psa =
    228                          (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
    229          
    230                      if (cipher_psa->slot_state == MBEDTLS_CIPHER_PSA_KEY_OWNED) {
   \       0x12   0x7A20             LDRB     R0,[R4, #+8]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xBF04             ITT      EQ
    231                          /* xxx_free() doesn't allow to return failures. */
    232                          (void) psa_destroy_key(cipher_psa->slot);
   \       0x18   0x6860             LDREQ    R0,[R4, #+4]
   \       0x1A   0x.... 0x....      BLEQ     psa_destroy_key
    233                      }
    234          
    235                      mbedtls_zeroize_and_free(cipher_psa, sizeof(*cipher_psa));
   \       0x1E   0x210C             MOVS     R1,#+12
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       mbedtls_zeroize_and_free
   \       0x26   0xE007             B.N      ??mbedtls_cipher_free_2
    236                  }
    237          
    238                  mbedtls_platform_zeroize(ctx, sizeof(mbedtls_cipher_context_t));
    239                  return;
    240              }
    241          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    242          
    243          #if defined(MBEDTLS_CMAC_C)
    244              if (ctx->cmac_ctx) {
    245                  mbedtls_zeroize_and_free(ctx->cmac_ctx,
    246                                           sizeof(mbedtls_cmac_context_t));
    247              }
    248          #endif
    249          
    250              if (ctx->cipher_ctx) {
   \                     ??mbedtls_cipher_free_1: (+1)
   \       0x28   0xB134             CBZ.N    R4,??mbedtls_cipher_free_2
    251                  mbedtls_cipher_get_base(ctx->cipher_info)->ctx_free_func(ctx->cipher_ctx);
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x30   0x4601             MOV      R1,R0
   \       0x32   0x6BE8             LDR      R0,[R5, #+60]
   \       0x34   0x6989             LDR      R1,[R1, #+24]
   \       0x36   0x4788             BLX      R1
    252              }
    253          
    254              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_cipher_context_t));
   \                     ??mbedtls_cipher_free_2: (+1)
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x2148             MOVS     R1,#+72
   \       0x3C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x40   0x.... 0x....      B.W      mbedtls_platform_zeroize
   \                     ??mbedtls_cipher_free_0: (+1)
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}
    255          }
    256          

   \                                 In section .text, align 2, keep-with-next
    257          int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx,
    258                                   const mbedtls_cipher_info_t *cipher_info)
    259          {
   \                     mbedtls_cipher_setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    260              if (cipher_info == NULL) {
   \        0x6   0xD102             BNE.N    ??mbedtls_cipher_setup_0
    261                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
    262              }
    263          
    264              memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
   \                     ??mbedtls_cipher_setup_0: (+1)
   \        0xE   0x2148             MOVS     R1,#+72
   \       0x10   0x.... 0x....      BL       __aeabi_memclr4
    265          
    266              if (NULL == (ctx->cipher_ctx = mbedtls_cipher_get_base(cipher_info)->ctx_alloc_func())) {
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x1A   0x6940             LDR      R0,[R0, #+20]
   \       0x1C   0x4780             BLX      R0
   \       0x1E   0x63E8             STR      R0,[R5, #+60]
   \       0x20   0xB910             CBNZ.N   R0,??mbedtls_cipher_setup_1
    267                  return MBEDTLS_ERR_CIPHER_ALLOC_FAILED;
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    268              }
    269          
    270              ctx->cipher_info = cipher_info;
   \                     ??mbedtls_cipher_setup_1: (+1)
   \       0x28   0x602C             STR      R4,[R5, #+0]
    271          
    272              return 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    273          }
    274          
    275          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)

   \                                 In section .text, align 2, keep-with-next
    276          int mbedtls_cipher_setup_psa(mbedtls_cipher_context_t *ctx,
    277                                       const mbedtls_cipher_info_t *cipher_info,
    278                                       size_t taglen)
    279          {
   \                     mbedtls_cipher_setup_psa: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x000C             MOVS     R4,R1
    280              psa_algorithm_t alg;
    281              mbedtls_cipher_context_psa *cipher_psa;
    282          
    283              if (NULL == cipher_info || NULL == ctx) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2E00             CMPNE    R6,#+0
   \        0xA   0xD102             BNE.N    ??mbedtls_cipher_setup_psa_0
    284                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \       0x10   0xBD70             POP      {R4-R6,PC}
    285              }
    286          
    287              /* Check that the underlying cipher mode and cipher type are
    288               * supported by the underlying PSA Crypto implementation. */
    289              alg = mbedtls_psa_translate_cipher_mode(((mbedtls_cipher_mode_t) cipher_info->mode), taglen);
   \                     ??mbedtls_cipher_setup_psa_0: (+1)
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0x0415             LSLS     R5,R2,#+16
   \       0x16   0xF405 0x157C      AND      R5,R5,#0x3F0000
   \       0x1A   0x0B01             LSRS     R1,R0,#+12
   \       0x1C   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x20   0x2901             CMP      R1,#+1
   \       0x22   0xD02E             BEQ.N    ??mbedtls_cipher_setup_psa_1
   \       0x24   0x2902             CMP      R1,#+2
   \       0x26   0xD006             BEQ.N    ??mbedtls_cipher_setup_psa_2
   \       0x28   0x2906             CMP      R1,#+6
   \       0x2A   0xD025             BEQ.N    ??mbedtls_cipher_setup_psa_3
   \       0x2C   0x2908             CMP      R1,#+8
   \       0x2E   0xD009             BEQ.N    ??mbedtls_cipher_setup_psa_4
   \       0x30   0x2909             CMP      R1,#+9
   \       0x32   0xD004             BEQ.N    ??mbedtls_cipher_setup_psa_5
   \       0x34   0xE028             B.N      ??mbedtls_cipher_setup_psa_6
   \                     ??mbedtls_cipher_setup_psa_2: (+1)
   \       0x36   0xBB3A             CBNZ.N   R2,??mbedtls_cipher_setup_psa_6
   \       0x38   0x.... 0x....      LDR.W    R5,??DataTable17_6
   \       0x3C   0xE006             B.N      ??mbedtls_cipher_setup_psa_7
   \                     ??mbedtls_cipher_setup_psa_5: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R5,??DataTable17_7
   \       0x42   0xE003             B.N      ??mbedtls_cipher_setup_psa_7
   \                     ??mbedtls_cipher_setup_psa_4: (+1)
   \       0x44   0xF045 0x65A8      ORR      R5,R5,#0x5400000
   \       0x48   0xF445 0x7580      ORR      R5,R5,#0x100
    290              if (alg == 0) {
    291                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    292              }
    293              if (mbedtls_psa_translate_cipher_type(((mbedtls_cipher_type_t) cipher_info->type)) == 0) {
   \                     ??mbedtls_cipher_setup_psa_7: (+1)
   \       0x4C   0x0200             LSLS     R0,R0,#+8
   \       0x4E   0x0E00             LSRS     R0,R0,#+24
   \       0x50   0x1E80             SUBS     R0,R0,#+2
   \       0x52   0x2805             CMP      R0,#+5
   \       0x54   0xBF81             ITTTT    HI
   \       0x56   0x380C             SUBHI    R0,R0,#+12
   \       0x58   0x2802             CMPHI    R0,#+2
   \       0x5A   0x3818             SUBHI    R0,R0,#+24
   \       0x5C   0x2805             CMPHI    R0,#+5
   \       0x5E   0xD813             BHI.N    ??mbedtls_cipher_setup_psa_6
    294                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    295              }
    296          
    297              memset(ctx, 0, sizeof(mbedtls_cipher_context_t));
   \       0x60   0x2148             MOVS     R1,#+72
   \       0x62   0x4630             MOV      R0,R6
   \       0x64   0x.... 0x....      BL       __aeabi_memclr4
    298          
    299              cipher_psa = mbedtls_calloc(1, sizeof(mbedtls_cipher_context_psa));
   \       0x68   0x210C             MOVS     R1,#+12
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0x.... 0x....      BL       sl_calloc
    300              if (cipher_psa == NULL) {
   \       0x70   0xB968             CBNZ.N   R0,??mbedtls_cipher_setup_psa_8
    301                  return MBEDTLS_ERR_CIPHER_ALLOC_FAILED;
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \       0x76   0xBD70             POP      {R4-R6,PC}
    302              }
   \                     ??mbedtls_cipher_setup_psa_3: (+1)
   \       0x78   0xF045 0x65A8      ORR      R5,R5,#0x5400000
   \       0x7C   0xF445 0x7500      ORR      R5,R5,#0x200
   \       0x80   0xE7E4             B.N      ??mbedtls_cipher_setup_psa_7
   \                     ??mbedtls_cipher_setup_psa_1: (+1)
   \       0x82   0x.... 0x....      LDR.W    R5,??DataTable17_8
   \       0x86   0xE7E1             B.N      ??mbedtls_cipher_setup_psa_7
   \                     ??mbedtls_cipher_setup_psa_6: (+1)
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \       0x8C   0xBD70             POP      {R4-R6,PC}
    303              cipher_psa->alg  = alg;
   \                     ??mbedtls_cipher_setup_psa_8: (+1)
   \       0x8E   0x6005             STR      R5,[R0, #+0]
    304              ctx->cipher_ctx  = cipher_psa;
   \       0x90   0x63F0             STR      R0,[R6, #+60]
    305              ctx->cipher_info = cipher_info;
   \       0x92   0x6034             STR      R4,[R6, #+0]
    306              ctx->psa_enabled = 1;
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xF886 0x0044      STRB     R0,[R6, #+68]
    307              return 0;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xBD70             POP      {R4-R6,PC}
    308          }
    309          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    310          

   \                                 In section .text, align 2, keep-with-next
    311          int mbedtls_cipher_setkey(mbedtls_cipher_context_t *ctx,
    312                                    const unsigned char *key,
    313                                    int key_bitlen,
    314                                    const mbedtls_operation_t operation)
    315          {
   \                     mbedtls_cipher_setkey: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x461C             MOV      R4,R3
    316              if (operation != MBEDTLS_ENCRYPT && operation != MBEDTLS_DECRYPT) {
   \        0x8   0x.... 0x....      LDR.W    R9,??DataTable17_4
   \        0xC   0x2B01             CMP      R3,#+1
   \        0xE   0xD001             BEQ.N    ??mbedtls_cipher_setkey_0
   \       0x10   0x0023             MOVS     R3,R4
   \       0x12   0xD115             BNE.N    ??mbedtls_cipher_setkey_1
   \                     ??mbedtls_cipher_setkey_0: (+1)
   \       0x14   0x4605             MOV      R5,R0
    317                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    318              }
    319              if (ctx->cipher_info == NULL) {
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD07D             BEQ.N    ??mbedtls_cipher_setkey_2
    320                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    321              }
    322          
    323          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    324              if (ctx->psa_enabled == 1) {
   \       0x1C   0x468A             MOV      R10,R1
   \       0x1E   0xF895 0x1044      LDRB     R1,[R5, #+68]
   \       0x22   0x4616             MOV      R6,R2
   \       0x24   0x2901             CMP      R1,#+1
   \       0x26   0xD149             BNE.N    ??mbedtls_cipher_setkey_3
    325                  mbedtls_cipher_context_psa * const cipher_psa =
    326                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x28   0x6BEF             LDR      R7,[R5, #+60]
    327          
    328                  size_t const key_bytelen = ((size_t) key_bitlen + 7) / 8;
    329          
    330                  psa_status_t status;
    331                  psa_key_type_t key_type;
    332                  psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x2124             MOVS     R1,#+36
   \       0x2E   0x.... 0x....      BL       __aeabi_memclr4
   \       0x32   0xF106 0x0807      ADD      R8,R6,#+7
    333          
    334                  /* PSA Crypto API only accepts byte-aligned keys. */
    335                  if (key_bitlen % 8 != 0) {
   \       0x36   0xF016 0x0F07      TST      R6,#0x7
   \       0x3A   0xBF04             ITT      EQ
   \       0x3C   0x7A38             LDRBEQ   R0,[R7, #+8]
   \       0x3E   0x2800             CMPEQ    R0,#+0
    336                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    337                  }
    338          
    339                  /* Don't allow keys to be set multiple times. */
    340                  if (cipher_psa->slot_state != MBEDTLS_CIPHER_PSA_KEY_UNSET) {
   \                     ??mbedtls_cipher_setkey_1: (+1)
   \       0x40   0xD16A             BNE.N    ??mbedtls_cipher_setkey_2
    341                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    342                  }
    343          
    344                  key_type = mbedtls_psa_translate_cipher_type(
    345                      ((mbedtls_cipher_type_t) ctx->cipher_info->type));
   \       0x42   0x682A             LDR      R2,[R5, #+0]
   \       0x44   0x6851             LDR      R1,[R2, #+4]
   \       0x46   0x0209             LSLS     R1,R1,#+8
   \       0x48   0x0E09             LSRS     R1,R1,#+24
   \       0x4A   0x1E89             SUBS     R1,R1,#+2
   \       0x4C   0x2905             CMP      R1,#+5
   \       0x4E   0xBF81             ITTTT    HI
   \       0x50   0x390C             SUBHI    R1,R1,#+12
   \       0x52   0x2902             CMPHI    R1,#+2
   \       0x54   0x3918             SUBHI    R1,R1,#+24
   \       0x56   0x2905             CMPHI    R1,#+5
   \       0x58   0xD82A             BHI.N    ??mbedtls_cipher_setkey_4
    346                  if (key_type == 0) {
    347                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    348                  }
    349                  psa_set_key_type(&attributes, key_type);
   \       0x5A   0x9807             LDR      R0,[SP, #+28]
   \       0x5C   0xB920             CBNZ.N   R0,??mbedtls_cipher_setkey_5
   \       0x5E   0xF44F 0x5110      MOV      R1,#+9216
   \       0x62   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x66   0xE006             B.N      ??mbedtls_cipher_setkey_6
   \                     ??mbedtls_cipher_setkey_5: (+1)
   \       0x68   0x2300             MOVS     R3,#+0
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0xF44F 0x5110      MOV      R1,#+9216
   \       0x70   0x4668             MOV      R0,SP
   \       0x72   0x.... 0x....      BL       psa_set_key_domain_parameters
    350          
    351                  /* Mbed TLS' cipher layer doesn't enforce the mode of operation
    352                   * (encrypt vs. decrypt): it is possible to setup a key for encryption
    353                   * and use it for AEAD decryption. Until tests relying on this
    354                   * are changed, allow any usage in PSA. */
    355                  psa_set_key_usage_flags(&attributes,
    356                                          PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
   \                     ??mbedtls_cipher_setkey_6: (+1)
   \       0x76   0xF44F 0x7040      MOV      R0,#+768
   \       0x7A   0x9003             STR      R0,[SP, #+12]
    357                  psa_set_key_algorithm(&attributes, cipher_psa->alg);
   \       0x7C   0x6839             LDR      R1,[R7, #+0]
    358          
    359                  status = psa_import_key(&attributes, key, key_bytelen,
    360                                          &cipher_psa->slot);
    361                  switch (status) {
   \       0x7E   0x1D3B             ADDS     R3,R7,#+4
   \       0x80   0xEA4F 0x02D8      LSR      R2,R8,#+3
   \       0x84   0x9104             STR      R1,[SP, #+16]
   \       0x86   0x4651             MOV      R1,R10
   \       0x88   0x4668             MOV      R0,SP
   \       0x8A   0x.... 0x....      BL       psa_import_key
   \       0x8E   0xB130             CBZ.N    R0,??mbedtls_cipher_setkey_7
   \       0x90   0xF06F 0x018C      MVN      R1,#+140
   \       0x94   0x1A40             SUBS     R0,R0,R1
   \       0x96   0xD008             BEQ.N    ??mbedtls_cipher_setkey_8
   \       0x98   0x1FC0             SUBS     R0,R0,#+7
   \       0x9A   0xD009             BEQ.N    ??mbedtls_cipher_setkey_4
   \       0x9C   0xE00B             B.N      ??mbedtls_cipher_setkey_9
    362                      case PSA_SUCCESS:
    363                          break;
    364                      case PSA_ERROR_INSUFFICIENT_MEMORY:
    365                          return MBEDTLS_ERR_CIPHER_ALLOC_FAILED;
    366                      case PSA_ERROR_NOT_SUPPORTED:
    367                          return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    368                      default:
    369                          return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
    370                  }
    371                  /* Indicate that we own the key slot and need to
    372                   * destroy it in mbedtls_cipher_free(). */
    373                  cipher_psa->slot_state = MBEDTLS_CIPHER_PSA_KEY_OWNED;
   \                     ??mbedtls_cipher_setkey_7: (+1)
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0x7238             STRB     R0,[R7, #+8]
    374          
    375                  ctx->key_bitlen = key_bitlen;
   \       0xA2   0x606E             STR      R6,[R5, #+4]
    376                  ctx->operation = operation;
   \       0xA4   0x722C             STRB     R4,[R5, #+8]
    377                  return 0;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE037             B.N      ??mbedtls_cipher_setkey_10
   \                     ??mbedtls_cipher_setkey_8: (+1)
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \       0xAE   0xE034             B.N      ??mbedtls_cipher_setkey_10
   \                     ??mbedtls_cipher_setkey_4: (+1)
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \       0xB4   0xE031             B.N      ??mbedtls_cipher_setkey_10
   \                     ??mbedtls_cipher_setkey_9: (+1)
   \       0xB6   0xF06F 0x006F      MVN      R0,#+111
   \       0xBA   0xE02E             B.N      ??mbedtls_cipher_setkey_10
    378              }
    379          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    380          
    381              if ((ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN) == 0 &&
    382                  (int) mbedtls_cipher_info_get_key_bitlen(ctx->cipher_info) != key_bitlen) {
   \                     ??mbedtls_cipher_setkey_3: (+1)
   \       0xBC   0x6841             LDR      R1,[R0, #+4]
   \       0xBE   0x0E09             LSRS     R1,R1,#+24
   \       0xC0   0x078A             LSLS     R2,R1,#+30
   \       0xC2   0xD403             BMI.N    ??mbedtls_cipher_setkey_11
   \       0xC4   0x.... 0x....      BL       mbedtls_cipher_info_get_key_bitlen
   \       0xC8   0x42B0             CMP      R0,R6
   \       0xCA   0xD125             BNE.N    ??mbedtls_cipher_setkey_2
    383                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    384              }
    385          
    386              ctx->key_bitlen = key_bitlen;
   \                     ??mbedtls_cipher_setkey_11: (+1)
   \       0xCC   0x606E             STR      R6,[R5, #+4]
    387              ctx->operation = operation;
   \       0xCE   0x722C             STRB     R4,[R5, #+8]
    388          
    389              /*
    390               * For OFB, CFB and CTR mode always use the encryption key schedule
    391               */
    392              if (MBEDTLS_ENCRYPT == operation ||
    393                  MBEDTLS_MODE_CFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
    394                  MBEDTLS_MODE_OFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
    395                  MBEDTLS_MODE_CTR == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \       0xD0   0x6828             LDR      R0,[R5, #+0]
   \       0xD2   0x2C01             CMP      R4,#+1
   \       0xD4   0xBF1F             ITTTT    NE
   \       0xD6   0x6841             LDRNE    R1,[R0, #+4]
   \       0xD8   0x0B09             LSRNE    R1,R1,#+12
   \       0xDA   0xF001 0x020F      ANDNE    R2,R1,#0xF
   \       0xDE   0x2A03             CMPNE    R2,#+3
   \       0xE0   0xD007             BEQ.N    ??mbedtls_cipher_setkey_12
   \       0xE2   0xF001 0x030F      AND      R3,R1,#0xF
   \       0xE6   0x2B04             CMP      R3,#+4
   \       0xE8   0xBF1C             ITT      NE
   \       0xEA   0xF001 0x010F      ANDNE    R1,R1,#0xF
   \       0xEE   0x2905             CMPNE    R1,#+5
   \       0xF0   0xD108             BNE.N    ??mbedtls_cipher_setkey_13
    396                  return mbedtls_cipher_get_base(ctx->cipher_info)->setkey_enc_func(ctx->cipher_ctx, key,
    397                                                                                    ctx->key_bitlen);
   \                     ??mbedtls_cipher_setkey_12: (+1)
   \       0xF2   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0xF6   0x4603             MOV      R3,R0
   \       0xF8   0x686A             LDR      R2,[R5, #+4]
   \       0xFA   0x6BE8             LDR      R0,[R5, #+60]
   \       0xFC   0x68DB             LDR      R3,[R3, #+12]
   \       0xFE   0x4651             MOV      R1,R10
   \      0x100   0x4798             BLX      R3
   \      0x102   0xE00A             B.N      ??mbedtls_cipher_setkey_10
    398              }
    399          
    400              if (MBEDTLS_DECRYPT == operation) {
   \                     ??mbedtls_cipher_setkey_13: (+1)
   \      0x104   0xB944             CBNZ.N   R4,??mbedtls_cipher_setkey_2
    401                  return mbedtls_cipher_get_base(ctx->cipher_info)->setkey_dec_func(ctx->cipher_ctx, key,
    402                                                                                    ctx->key_bitlen);
   \      0x106   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x10A   0x4603             MOV      R3,R0
   \      0x10C   0x686A             LDR      R2,[R5, #+4]
   \      0x10E   0x6BE8             LDR      R0,[R5, #+60]
   \      0x110   0x691B             LDR      R3,[R3, #+16]
   \      0x112   0x4651             MOV      R1,R10
   \      0x114   0x4798             BLX      R3
   \      0x116   0xE000             B.N      ??mbedtls_cipher_setkey_10
    403              }
    404          
    405              return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_setkey_2: (+1)
   \      0x118   0x4648             MOV      R0,R9
   \                     ??mbedtls_cipher_setkey_10: (+1)
   \      0x11A   0xB00A             ADD      SP,SP,#+40
   \      0x11C   0xE8BD 0x87F0      POP      {R4-R10,PC}
    406          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    407          

   \                                 In section .text, align 2, keep-with-next
    408          int mbedtls_cipher_set_iv(mbedtls_cipher_context_t *ctx,
    409                                    const unsigned char *iv,
    410                                    size_t iv_len)
    411          {
   \                     mbedtls_cipher_set_iv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
    412              size_t actual_iv_size;
    413          
    414              if (ctx->cipher_info == NULL) {
   \        0x4   0x6838             LDR      R0,[R7, #+0]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0xB378             CBZ.N    R0,??mbedtls_cipher_set_iv_0
    415                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    416              }
    417          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    418              if (ctx->psa_enabled == 1) {
   \        0xC   0xF897 0x1044      LDRB     R1,[R7, #+68]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD001             BEQ.N    ??mbedtls_cipher_set_iv_1
    419                  /* While PSA Crypto has an API for multipart
    420                   * operations, we currently don't make it
    421                   * accessible through the cipher layer. */
    422                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    423              }
    424          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    425          
    426              /* avoid buffer overflow in ctx->iv */
    427              if (iv_len > MBEDTLS_MAX_IV_LENGTH) {
   \       0x14   0x2E11             CMP      R6,#+17
   \       0x16   0xD302             BCC.N    ??mbedtls_cipher_set_iv_2
    428                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_set_iv_1: (+1)
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
    429              }
    430          
    431              if ((ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN) != 0) {
   \                     ??mbedtls_cipher_set_iv_2: (+1)
   \       0x1E   0x6841             LDR      R1,[R0, #+4]
   \       0x20   0xF3C1 0x6000      UBFX     R0,R1,#+24,#+1
   \       0x24   0xB108             CBZ.N    R0,??mbedtls_cipher_set_iv_3
    432                  actual_iv_size = iv_len;
   \       0x26   0x4634             MOV      R4,R6
   \       0x28   0xE004             B.N      ??mbedtls_cipher_set_iv_4
    433              } else {
    434                  actual_iv_size = mbedtls_cipher_info_get_iv_size(ctx->cipher_info);
   \                     ??mbedtls_cipher_set_iv_3: (+1)
   \       0x2A   0x08CC             LSRS     R4,R1,#+3
   \       0x2C   0xF004 0x041C      AND      R4,R4,#0x1C
    435          
    436                  /* avoid reading past the end of input buffer */
    437                  if (actual_iv_size > iv_len) {
   \       0x30   0x42A6             CMP      R6,R4
   \       0x32   0xD31B             BCC.N    ??mbedtls_cipher_set_iv_0
    438                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    439                  }
    440              }
    441          
    442          #if defined(MBEDTLS_CHACHA20_C)
    443              if (((mbedtls_cipher_type_t) ctx->cipher_info->type) == MBEDTLS_CIPHER_CHACHA20) {
    444                  /* Even though the actual_iv_size is overwritten with a correct value
    445                   * of 12 from the cipher info, return an error to indicate that
    446                   * the input iv_len is wrong. */
    447                  if (iv_len != 12) {
    448                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    449                  }
    450          
    451                  if (0 != mbedtls_chacha20_starts((mbedtls_chacha20_context *) ctx->cipher_ctx,
    452                                                   iv,
    453                                                   0U)) {   /* Initial counter value */
    454                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    455                  }
    456              }
    457          #if defined(MBEDTLS_CHACHAPOLY_C)
    458              if (((mbedtls_cipher_type_t) ctx->cipher_info->type) == MBEDTLS_CIPHER_CHACHA20_POLY1305 &&
    459                  iv_len != 12) {
    460                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    461              }
    462          #endif
    463          #endif
    464          
    465          #if defined(MBEDTLS_GCM_C)
    466              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
    467                  return mbedtls_gcm_starts((mbedtls_gcm_context *) ctx->cipher_ctx,
    468                                            ctx->operation,
    469                                            iv, iv_len);
    470              }
    471          #endif
    472          
    473          #if defined(MBEDTLS_CCM_C)
    474              if (MBEDTLS_MODE_CCM_STAR_NO_TAG == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_set_iv_4: (+1)
   \       0x34   0x0B09             LSRS     R1,R1,#+12
   \       0x36   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x3A   0x2909             CMP      R1,#+9
   \       0x3C   0xD119             BNE.N    ??mbedtls_cipher_set_iv_5
    475                  int set_lengths_result;
    476                  int ccm_star_mode;
    477          
    478                  set_lengths_result = mbedtls_ccm_set_lengths(
    479                      (mbedtls_ccm_context *) ctx->cipher_ctx,
    480                      0, 0, 0);
   \       0x3E   0x6BF8             LDR      R0,[R7, #+60]
   \       0x40   0x2300             MOVS     R3,#+0
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x.... 0x....      BL       mbedtls_ccm_set_lengths
    481                  if (set_lengths_result != 0) {
   \       0x4A   0xB9D8             CBNZ.N   R0,??mbedtls_cipher_set_iv_6
    482                      return set_lengths_result;
    483                  }
    484          
    485                  if (ctx->operation == MBEDTLS_DECRYPT) {
   \       0x4C   0xF997 0x0008      LDRSB    R0,[R7, #+8]
   \       0x50   0xB940             CBNZ.N   R0,??mbedtls_cipher_set_iv_7
    486                      ccm_star_mode = MBEDTLS_CCM_STAR_DECRYPT;
   \       0x52   0x2102             MOVS     R1,#+2
    487                  } else if (ctx->operation == MBEDTLS_ENCRYPT) {
    488                      ccm_star_mode = MBEDTLS_CCM_STAR_ENCRYPT;
    489                  } else {
    490                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    491                  }
    492          
    493                  return mbedtls_ccm_starts((mbedtls_ccm_context *) ctx->cipher_ctx,
    494                                            ccm_star_mode,
    495                                            iv, iv_len);
   \                     ??mbedtls_cipher_set_iv_8: (+1)
   \       0x54   0x6BF8             LDR      R0,[R7, #+60]
   \       0x56   0x4633             MOV      R3,R6
   \       0x58   0x462A             MOV      R2,R5
   \       0x5A   0xB001             ADD      SP,SP,#+4
   \       0x5C   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \       0x60   0x.... 0x....      B.W      mbedtls_ccm_starts
   \                     ??mbedtls_cipher_set_iv_7: (+1)
   \       0x64   0x2801             CMP      R0,#+1
   \       0x66   0xBF08             IT       EQ
   \       0x68   0x2103             MOVEQ    R1,#+3
   \       0x6A   0xD0F3             BEQ.N    ??mbedtls_cipher_set_iv_8
   \                     ??mbedtls_cipher_set_iv_0: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \       0x70   0xBDF2             POP      {R1,R4-R7,PC}
    496              }
    497          #endif
    498          
    499              if (actual_iv_size != 0) {
   \                     ??mbedtls_cipher_set_iv_5: (+1)
   \       0x72   0xB134             CBZ.N    R4,??mbedtls_cipher_set_iv_9
    500                  memcpy(ctx->iv, iv, actual_iv_size);
   \       0x74   0x4622             MOV      R2,R4
   \       0x76   0x4629             MOV      R1,R5
   \       0x78   0xF107 0x0028      ADD      R0,R7,#+40
   \       0x7C   0x.... 0x....      BL       __aeabi_memcpy
    501                  ctx->iv_size = actual_iv_size;
   \       0x80   0x63BC             STR      R4,[R7, #+56]
    502              }
    503          
    504              return 0;
   \                     ??mbedtls_cipher_set_iv_9: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_set_iv_6: (+1)
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}
    505          }
    506          

   \                                 In section .text, align 2, keep-with-next
    507          int mbedtls_cipher_reset(mbedtls_cipher_context_t *ctx)
    508          {
    509              if (ctx->cipher_info == NULL) {
   \                     mbedtls_cipher_reset: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xB901             CBNZ.N   R1,??mbedtls_cipher_reset_0
    510                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \        0x4   0x....             B.N      ?Subroutine0
    511              }
    512          
    513          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    514              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_reset_0: (+1)
   \        0x6   0xF890 0x1044      LDRB     R1,[R0, #+68]
   \        0xA   0x2901             CMP      R1,#+1
   \        0xC   0xD102             BNE.N    ??mbedtls_cipher_reset_1
    515                  /* We don't support resetting PSA-based
    516                   * cipher contexts, yet. */
    517                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \       0x12   0x4770             BX       LR
    518              }
    519          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    520          
    521              ctx->unprocessed_len = 0;
   \                     ??mbedtls_cipher_reset_1: (+1)
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6241             STR      R1,[R0, #+36]
    522          
    523              return 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4770             BX       LR
    524          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \        0x4   0x4770             BX       LR
    525          
    526          #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CHACHAPOLY_C)
    527          int mbedtls_cipher_update_ad(mbedtls_cipher_context_t *ctx,
    528                                       const unsigned char *ad, size_t ad_len)
    529          {
    530              if (ctx->cipher_info == NULL) {
    531                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    532              }
    533          
    534          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    535              if (ctx->psa_enabled == 1) {
    536                  /* While PSA Crypto has an API for multipart
    537                   * operations, we currently don't make it
    538                   * accessible through the cipher layer. */
    539                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    540              }
    541          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    542          
    543          #if defined(MBEDTLS_GCM_C)
    544              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
    545                  return mbedtls_gcm_update_ad((mbedtls_gcm_context *) ctx->cipher_ctx,
    546                                               ad, ad_len);
    547              }
    548          #endif
    549          
    550          #if defined(MBEDTLS_CHACHAPOLY_C)
    551              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
    552                  int result;
    553                  mbedtls_chachapoly_mode_t mode;
    554          
    555                  mode = (ctx->operation == MBEDTLS_ENCRYPT)
    556                          ? MBEDTLS_CHACHAPOLY_ENCRYPT
    557                          : MBEDTLS_CHACHAPOLY_DECRYPT;
    558          
    559                  result = mbedtls_chachapoly_starts((mbedtls_chachapoly_context *) ctx->cipher_ctx,
    560                                                     ctx->iv,
    561                                                     mode);
    562                  if (result != 0) {
    563                      return result;
    564                  }
    565          
    566                  return mbedtls_chachapoly_update_aad((mbedtls_chachapoly_context *) ctx->cipher_ctx,
    567                                                       ad, ad_len);
    568              }
    569          #endif
    570          
    571              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    572          }
    573          #endif /* MBEDTLS_GCM_C || MBEDTLS_CHACHAPOLY_C */
    574          

   \                                 In section .text, align 2, keep-with-next
    575          int mbedtls_cipher_update(mbedtls_cipher_context_t *ctx, const unsigned char *input,
    576                                    size_t ilen, unsigned char *output, size_t *olen)
    577          {
   \                     mbedtls_cipher_update: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
    578              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    579              size_t block_size;
    580          
    581              if (ctx->cipher_info == NULL) {
   \        0x6   0x6838             LDR      R0,[R7, #+0]
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4614             MOV      R4,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD041             BEQ.N    ??mbedtls_cipher_update_0
    582                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    583              }
    584          
    585          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
    586              if (ctx->psa_enabled == 1) {
   \       0x12   0xF897 0x0044      LDRB     R0,[R7, #+68]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xF000 0x80BD      BEQ.W    ??mbedtls_cipher_update_1
   \       0x1C   0x9E0A             LDR      R6,[SP, #+40]
    587                  /* While PSA Crypto has an API for multipart
    588                   * operations, we currently don't make it
    589                   * accessible through the cipher layer. */
    590                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    591              }
    592          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
    593          
    594              *olen = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6030             STR      R0,[R6, #+0]
    595              block_size = mbedtls_cipher_get_block_size(ctx);
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \       0x28   0xEA5F 0x0A00      MOVS     R10,R0
    596              if (0 == block_size) {
   \       0x2C   0xBF08             IT       EQ
   \       0x2E   0x.... 0x....      LDREQ.W  R0,??DataTable17_10
    597                  return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
   \       0x32   0xD017             BEQ.N    ??mbedtls_cipher_update_2
    598              }
    599          
    600              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_ECB) {
   \       0x34   0x6839             LDR      R1,[R7, #+0]
   \       0x36   0x6848             LDR      R0,[R1, #+4]
   \       0x38   0x0B00             LSRS     R0,R0,#+12
   \       0x3A   0xF000 0x020F      AND      R2,R0,#0xF
   \       0x3E   0x2A01             CMP      R2,#+1
   \       0x40   0xD111             BNE.N    ??mbedtls_cipher_update_3
    601                  if (ilen != block_size) {
   \       0x42   0x4554             CMP      R4,R10
   \       0x44   0xBF18             IT       NE
   \       0x46   0x.... 0x....      LDRNE.W  R0,??DataTable17_11
    602                      return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   \       0x4A   0xD10B             BNE.N    ??mbedtls_cipher_update_2
    603                  }
    604          
    605                  *olen = ilen;
   \       0x4C   0x6034             STR      R4,[R6, #+0]
    606          
    607                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->ecb_func(ctx->cipher_ctx,
    608                                                                                      ctx->operation, input,
    609                                                                                      output))) {
    610                      return ret;
   \       0x4E   0x4608             MOV      R0,R1
   \       0x50   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0x54   0x4604             MOV      R4,R0
   \       0x56   0xF997 0x1008      LDRSB    R1,[R7, #+8]
   \       0x5A   0x6BF8             LDR      R0,[R7, #+60]
   \       0x5C   0x6864             LDR      R4,[R4, #+4]
   \       0x5E   0x4643             MOV      R3,R8
   \       0x60   0x464A             MOV      R2,R9
   \       0x62   0x47A0             BLX      R4
   \                     ??mbedtls_cipher_update_2: (+1)
   \       0x64   0xE099             B.N      ??mbedtls_cipher_update_4
    611                  }
    612          
    613                  return 0;
    614              }
    615          
    616          #if defined(MBEDTLS_GCM_C)
    617              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_GCM) {
    618                  return mbedtls_gcm_update((mbedtls_gcm_context *) ctx->cipher_ctx,
    619                                            input, ilen,
    620                                            output, ilen, olen);
    621              }
    622          #endif
    623          
    624          #if defined(MBEDTLS_CCM_C)
    625              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CCM_STAR_NO_TAG) {
   \                     ??mbedtls_cipher_update_3: (+1)
   \       0x66   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x6A   0x2809             CMP      R0,#+9
   \       0x6C   0xD108             BNE.N    ??mbedtls_cipher_update_5
    626                  return mbedtls_ccm_update((mbedtls_ccm_context *) ctx->cipher_ctx,
    627                                            input, ilen,
    628                                            output, ilen, olen);
   \       0x6E   0x9601             STR      R6,[SP, #+4]
   \       0x70   0x9400             STR      R4,[SP, #+0]
   \       0x72   0x6BF8             LDR      R0,[R7, #+60]
   \       0x74   0x4643             MOV      R3,R8
   \       0x76   0x4622             MOV      R2,R4
   \       0x78   0x4649             MOV      R1,R9
   \       0x7A   0x.... 0x....      BL       mbedtls_ccm_update
   \       0x7E   0xE08C             B.N      ??mbedtls_cipher_update_4
    629              }
    630          #endif
    631          
    632          #if defined(MBEDTLS_CHACHAPOLY_C)
    633              if (((mbedtls_cipher_type_t) ctx->cipher_info->type) == MBEDTLS_CIPHER_CHACHA20_POLY1305) {
    634                  *olen = ilen;
    635                  return mbedtls_chachapoly_update((mbedtls_chachapoly_context *) ctx->cipher_ctx,
    636                                                   ilen, input, output);
    637              }
    638          #endif
    639          
    640              if (input == output &&
    641                  (ctx->unprocessed_len != 0 || ilen % block_size)) {
   \                     ??mbedtls_cipher_update_5: (+1)
   \       0x80   0x45C1             CMP      R9,R8
   \       0x82   0xD10B             BNE.N    ??mbedtls_cipher_update_6
   \       0x84   0x6A78             LDR      R0,[R7, #+36]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xBF02             ITTT     EQ
   \       0x8A   0xFBB4 0xF0FA      UDIVEQ   R0,R4,R10
   \       0x8E   0xFB0A 0x4010      MLSEQ    R0,R10,R0,R4
   \       0x92   0x2800             CMPEQ    R0,#+0
   \       0x94   0xD002             BEQ.N    ??mbedtls_cipher_update_6
    642                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_update_0: (+1)
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \       0x9A   0xE07E             B.N      ??mbedtls_cipher_update_4
    643              }
    644          
    645          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    646              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CBC) {
   \                     ??mbedtls_cipher_update_6: (+1)
   \       0x9C   0x6848             LDR      R0,[R1, #+4]
   \       0x9E   0x0B00             LSRS     R0,R0,#+12
   \       0xA0   0xF000 0x000F      AND      R0,R0,#0xF
   \       0xA4   0x2802             CMP      R0,#+2
   \       0xA6   0xD176             BNE.N    ??mbedtls_cipher_update_1
    647                  size_t copy_len = 0;
    648          
    649                  /*
    650                   * If there is not enough data for a full block, cache it.
    651                   */
    652                  if ((ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
    653                       ilen <= block_size - ctx->unprocessed_len) ||
    654                      (ctx->operation == MBEDTLS_DECRYPT && NULL == ctx->add_padding &&
    655                       ilen < block_size - ctx->unprocessed_len) ||
    656                      (ctx->operation == MBEDTLS_ENCRYPT &&
    657                       ilen < block_size - ctx->unprocessed_len)) {
   \       0xA8   0xF997 0x0008      LDRSB    R0,[R7, #+8]
   \       0xAC   0xBB28             CBNZ.N   R0,??mbedtls_cipher_update_7
   \       0xAE   0x6A79             LDR      R1,[R7, #+36]
   \       0xB0   0x68F8             LDR      R0,[R7, #+12]
   \       0xB2   0xEBAA 0x0101      SUB      R1,R10,R1
   \       0xB6   0xB398             CBZ.N    R0,??mbedtls_cipher_update_8
   \       0xB8   0x42A1             CMP      R1,R4
   \       0xBA   0xD225             BCS.N    ??mbedtls_cipher_update_9
    658                      memcpy(&(ctx->unprocessed_data[ctx->unprocessed_len]), input,
    659                             ilen);
    660          
    661                      ctx->unprocessed_len += ilen;
    662                      return 0;
    663                  }
    664          
    665                  /*
    666                   * Process cached data first
    667                   */
    668                  if (0 != ctx->unprocessed_len) {
   \                     ??mbedtls_cipher_update_10: (+1)
   \       0xBC   0x6A78             LDR      R0,[R7, #+36]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD039             BEQ.N    ??mbedtls_cipher_update_11
    669                      copy_len = block_size - ctx->unprocessed_len;
   \       0xC2   0xEBAA 0x0500      SUB      R5,R10,R0
    670          
    671                      memcpy(&(ctx->unprocessed_data[ctx->unprocessed_len]), input,
    672                             copy_len);
   \       0xC6   0x1838             ADDS     R0,R7,R0
   \       0xC8   0x462A             MOV      R2,R5
   \       0xCA   0x4649             MOV      R1,R9
   \       0xCC   0x3014             ADDS     R0,R0,#+20
   \       0xCE   0x.... 0x....      BL       __aeabi_memcpy
    673          
    674                      if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cbc_func(ctx->cipher_ctx,
    675                                                                                          ctx->operation,
    676                                                                                          block_size, ctx->iv,
    677                                                                                          ctx->
    678                                                                                          unprocessed_data,
    679                                                                                          output))) {
   \       0xD2   0x6838             LDR      R0,[R7, #+0]
   \       0xD4   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0xD8   0x4684             MOV      R12,R0
   \       0xDA   0xF107 0x0014      ADD      R0,R7,#+20
   \       0xDE   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0xE2   0x9000             STR      R0,[SP, #+0]
   \       0xE4   0xF997 0x1008      LDRSB    R1,[R7, #+8]
   \       0xE8   0x6BF8             LDR      R0,[R7, #+60]
   \       0xEA   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \       0xEE   0xF107 0x0328      ADD      R3,R7,#+40
   \       0xF2   0x4652             MOV      R2,R10
   \       0xF4   0x47E0             BLX      R12
   \       0xF6   0xB1B0             CBZ.N    R0,??mbedtls_cipher_update_12
    680                          return ret;
   \       0xF8   0xE04F             B.N      ??mbedtls_cipher_update_4
    681                      }
   \                     ??mbedtls_cipher_update_7: (+1)
   \       0xFA   0x2801             CMP      R0,#+1
   \       0xFC   0xD1DE             BNE.N    ??mbedtls_cipher_update_10
   \       0xFE   0x6A78             LDR      R0,[R7, #+36]
   \      0x100   0xEBAA 0x0000      SUB      R0,R10,R0
   \      0x104   0x4284             CMP      R4,R0
   \      0x106   0xD2D9             BCS.N    ??mbedtls_cipher_update_10
   \                     ??mbedtls_cipher_update_9: (+1)
   \      0x108   0x6A7B             LDR      R3,[R7, #+36]
   \      0x10A   0x4622             MOV      R2,R4
   \      0x10C   0x4649             MOV      R1,R9
   \      0x10E   0x18FB             ADDS     R3,R7,R3
   \      0x110   0xF103 0x0014      ADD      R0,R3,#+20
   \      0x114   0x.... 0x....      BL       __aeabi_memcpy
   \      0x118   0x6A78             LDR      R0,[R7, #+36]
   \      0x11A   0x1824             ADDS     R4,R4,R0
   \      0x11C   0x627C             STR      R4,[R7, #+36]
   \      0x11E   0xE038             B.N      ??mbedtls_cipher_update_13
   \                     ??mbedtls_cipher_update_8: (+1)
   \      0x120   0x428C             CMP      R4,R1
   \      0x122   0xD3F1             BCC.N    ??mbedtls_cipher_update_9
   \      0x124   0xE7CA             B.N      ??mbedtls_cipher_update_10
    682          
    683                      *olen += block_size;
   \                     ??mbedtls_cipher_update_12: (+1)
   \      0x126   0x6830             LDR      R0,[R6, #+0]
    684                      output += block_size;
    685                      ctx->unprocessed_len = 0;
   \      0x128   0x2100             MOVS     R1,#+0
   \      0x12A   0x44D0             ADD      R8,R8,R10
   \      0x12C   0x4450             ADD      R0,R10,R0
   \      0x12E   0x6030             STR      R0,[R6, #+0]
   \      0x130   0x6279             STR      R1,[R7, #+36]
    686          
    687                      input += copy_len;
   \      0x132   0x44A9             ADD      R9,R9,R5
    688                      ilen -= copy_len;
   \      0x134   0x1B64             SUBS     R4,R4,R5
    689                  }
    690          
    691                  /*
    692                   * Cache final, incomplete block
    693                   */
    694                  if (0 != ilen) {
   \                     ??mbedtls_cipher_update_11: (+1)
   \      0x136   0xB364             CBZ.N    R4,??mbedtls_cipher_update_13
    695                      /* Encryption: only cache partial blocks
    696                       * Decryption w/ padding: always keep at least one whole block
    697                       * Decryption w/o padding: only cache partial blocks
    698                       */
    699                      copy_len = ilen % block_size;
   \      0x138   0xFBB4 0xF5FA      UDIV     R5,R4,R10
   \      0x13C   0xFB0A 0x4515      MLS      R5,R10,R5,R4
    700                      if (copy_len == 0 &&
    701                          ctx->operation == MBEDTLS_DECRYPT &&
    702                          NULL != ctx->add_padding) {
   \      0x140   0x2D00             CMP      R5,#+0
   \      0x142   0xBF04             ITT      EQ
   \      0x144   0xF997 0x0008      LDRSBEQ  R0,[R7, #+8]
   \      0x148   0x2800             CMPEQ    R0,#+0
   \      0x14A   0xD102             BNE.N    ??mbedtls_cipher_update_14
   \      0x14C   0x68F8             LDR      R0,[R7, #+12]
   \      0x14E   0xB100             CBZ.N    R0,??mbedtls_cipher_update_14
    703                          copy_len = block_size;
   \      0x150   0x4655             MOV      R5,R10
    704                      }
    705          
    706                      memcpy(ctx->unprocessed_data, &(input[ilen - copy_len]),
    707                             copy_len);
   \                     ??mbedtls_cipher_update_14: (+1)
   \      0x152   0x1B64             SUBS     R4,R4,R5
   \      0x154   0x462A             MOV      R2,R5
   \      0x156   0xEB09 0x0104      ADD      R1,R9,R4
   \      0x15A   0xF107 0x0014      ADD      R0,R7,#+20
   \      0x15E   0x.... 0x....      BL       __aeabi_memcpy
    708          
    709                      ctx->unprocessed_len += copy_len;
   \      0x162   0x6A78             LDR      R0,[R7, #+36]
   \      0x164   0x182D             ADDS     R5,R5,R0
   \      0x166   0x627D             STR      R5,[R7, #+36]
    710                      ilen -= copy_len;
    711                  }
    712          
    713                  /*
    714                   * Process remaining full blocks
    715                   */
    716                  if (ilen) {
   \      0x168   0xB19C             CBZ.N    R4,??mbedtls_cipher_update_13
    717                      if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cbc_func(ctx->cipher_ctx,
    718                                                                                          ctx->operation,
    719                                                                                          ilen, ctx->iv,
    720                                                                                          input,
    721                                                                                          output))) {
   \      0x16A   0x6838             LDR      R0,[R7, #+0]
   \      0x16C   0x.... 0x....      BL       mbedtls_cipher_get_base
   \      0x170   0x4605             MOV      R5,R0
   \      0x172   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \      0x176   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x17A   0xF997 0x1008      LDRSB    R1,[R7, #+8]
   \      0x17E   0x6BF8             LDR      R0,[R7, #+60]
   \      0x180   0x68AD             LDR      R5,[R5, #+8]
   \      0x182   0xF107 0x0328      ADD      R3,R7,#+40
   \      0x186   0x4622             MOV      R2,R4
   \      0x188   0x47A8             BLX      R5
   \      0x18A   0xB930             CBNZ.N   R0,??mbedtls_cipher_update_4
    722                          return ret;
    723                      }
    724          
    725                      *olen += ilen;
   \      0x18C   0x6830             LDR      R0,[R6, #+0]
   \      0x18E   0x1824             ADDS     R4,R4,R0
   \      0x190   0x6034             STR      R4,[R6, #+0]
    726                  }
    727          
    728                  return 0;
   \                     ??mbedtls_cipher_update_13: (+1)
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0xE001             B.N      ??mbedtls_cipher_update_4
    729              }
    730          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    731          
    732          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    733              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CFB) {
    734                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cfb_func(ctx->cipher_ctx,
    735                                                                                      ctx->operation, ilen,
    736                                                                                      &ctx->unprocessed_len,
    737                                                                                      ctx->iv,
    738                                                                                      input, output))) {
    739                      return ret;
    740                  }
    741          
    742                  *olen = ilen;
    743          
    744                  return 0;
    745              }
    746          #endif /* MBEDTLS_CIPHER_MODE_CFB */
    747          
    748          #if defined(MBEDTLS_CIPHER_MODE_OFB)
    749              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_OFB) {
    750                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->ofb_func(ctx->cipher_ctx,
    751                                                                                      ilen,
    752                                                                                      &ctx->unprocessed_len,
    753                                                                                      ctx->iv,
    754                                                                                      input, output))) {
    755                      return ret;
    756                  }
    757          
    758                  *olen = ilen;
    759          
    760                  return 0;
    761              }
    762          #endif /* MBEDTLS_CIPHER_MODE_OFB */
    763          
    764          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    765              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_CTR) {
    766                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->ctr_func(ctx->cipher_ctx,
    767                                                                                      ilen,
    768                                                                                      &ctx->unprocessed_len,
    769                                                                                      ctx->iv,
    770                                                                                      ctx->unprocessed_data,
    771                                                                                      input, output))) {
    772                      return ret;
    773                  }
    774          
    775                  *olen = ilen;
    776          
    777                  return 0;
    778              }
    779          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    780          
    781          #if defined(MBEDTLS_CIPHER_MODE_XTS)
    782              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_XTS) {
    783                  if (ctx->unprocessed_len > 0) {
    784                      /* We can only process an entire data unit at a time. */
    785                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
    786                  }
    787          
    788                  ret = mbedtls_cipher_get_base(ctx->cipher_info)->xts_func(ctx->cipher_ctx,
    789                                                                            ctx->operation,
    790                                                                            ilen,
    791                                                                            ctx->iv,
    792                                                                            input,
    793                                                                            output);
    794                  if (ret != 0) {
    795                      return ret;
    796                  }
    797          
    798                  *olen = ilen;
    799          
    800                  return 0;
    801              }
    802          #endif /* MBEDTLS_CIPHER_MODE_XTS */
    803          
    804          #if defined(MBEDTLS_CIPHER_MODE_STREAM)
    805              if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) == MBEDTLS_MODE_STREAM) {
    806                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->stream_func(ctx->cipher_ctx,
    807                                                                                         ilen, input,
    808                                                                                         output))) {
    809                      return ret;
    810                  }
    811          
    812                  *olen = ilen;
    813          
    814                  return 0;
    815              }
    816          #endif /* MBEDTLS_CIPHER_MODE_STREAM */
    817          
    818              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_update_1: (+1)
   \      0x196   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \                     ??mbedtls_cipher_update_4: (+1)
   \      0x19A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    819          }
    820          
    821          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
    822          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    823          /*
    824           * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len
    825           */
    826          static void add_pkcs_padding(unsigned char *output, size_t output_len,
    827                                       size_t data_len)
    828          {
    829              size_t padding_len = output_len - data_len;
    830              unsigned char i;
    831          
    832              for (i = 0; i < padding_len; i++) {
    833                  output[data_len + i] = (unsigned char) padding_len;
    834              }
    835          }
    836          
    837          static int get_pkcs_padding(unsigned char *input, size_t input_len,
    838                                      size_t *data_len)
    839          {
    840              size_t i, pad_idx;
    841              unsigned char padding_len;
    842          
    843              if (NULL == input || NULL == data_len) {
    844                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    845              }
    846          
    847              padding_len = input[input_len - 1];
    848              *data_len = input_len - padding_len;
    849          
    850              mbedtls_ct_condition_t bad = mbedtls_ct_uint_gt(padding_len, input_len);
    851              bad = mbedtls_ct_bool_or(bad, mbedtls_ct_uint_eq(padding_len, 0));
    852          
    853              /* The number of bytes checked must be independent of padding_len,
    854               * so pick input_len, which is usually 8 or 16 (one block) */
    855              pad_idx = input_len - padding_len;
    856              for (i = 0; i < input_len; i++) {
    857                  mbedtls_ct_condition_t in_padding = mbedtls_ct_uint_ge(i, pad_idx);
    858                  mbedtls_ct_condition_t different  = mbedtls_ct_uint_ne(input[i], padding_len);
    859                  bad = mbedtls_ct_bool_or(bad, mbedtls_ct_bool_and(in_padding, different));
    860              }
    861          
    862              return mbedtls_ct_error_if_else_0(bad, MBEDTLS_ERR_CIPHER_INVALID_PADDING);
    863          }
    864          #endif /* MBEDTLS_CIPHER_PADDING_PKCS7 */
    865          
    866          #if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
    867          /*
    868           * One and zeros padding: fill with 80 00 ... 00
    869           */
    870          static void add_one_and_zeros_padding(unsigned char *output,
    871                                                size_t output_len, size_t data_len)
    872          {
    873              size_t padding_len = output_len - data_len;
    874              unsigned char i = 0;
    875          
    876              output[data_len] = 0x80;
    877              for (i = 1; i < padding_len; i++) {
    878                  output[data_len + i] = 0x00;
    879              }
    880          }
    881          
    882          static int get_one_and_zeros_padding(unsigned char *input, size_t input_len,
    883                                               size_t *data_len)
    884          {
    885              if (NULL == input || NULL == data_len) {
    886                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    887              }
    888          
    889              mbedtls_ct_condition_t in_padding = MBEDTLS_CT_TRUE;
    890              mbedtls_ct_condition_t bad = MBEDTLS_CT_TRUE;
    891          
    892              *data_len = 0;
    893          
    894              for (ptrdiff_t i = (ptrdiff_t) (input_len) - 1; i >= 0; i--) {
    895                  mbedtls_ct_condition_t is_nonzero = mbedtls_ct_bool(input[i]);
    896          
    897                  mbedtls_ct_condition_t hit_first_nonzero = mbedtls_ct_bool_and(is_nonzero, in_padding);
    898          
    899                  *data_len = mbedtls_ct_size_if(hit_first_nonzero, i, *data_len);
    900          
    901                  bad = mbedtls_ct_bool_if(hit_first_nonzero, mbedtls_ct_uint_ne(input[i], 0x80), bad);
    902          
    903                  in_padding = mbedtls_ct_bool_and(in_padding, mbedtls_ct_bool_not(is_nonzero));
    904              }
    905          
    906              return mbedtls_ct_error_if_else_0(bad, MBEDTLS_ERR_CIPHER_INVALID_PADDING);
    907          }
    908          #endif /* MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS */
    909          
    910          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
    911          /*
    912           * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length
    913           */
    914          static void add_zeros_and_len_padding(unsigned char *output,
    915                                                size_t output_len, size_t data_len)
    916          {
    917              size_t padding_len = output_len - data_len;
    918              unsigned char i = 0;
    919          
    920              for (i = 1; i < padding_len; i++) {
    921                  output[data_len + i - 1] = 0x00;
    922              }
    923              output[output_len - 1] = (unsigned char) padding_len;
    924          }
    925          
    926          static int get_zeros_and_len_padding(unsigned char *input, size_t input_len,
    927                                               size_t *data_len)
    928          {
    929              size_t i, pad_idx;
    930              unsigned char padding_len;
    931              mbedtls_ct_condition_t bad;
    932          
    933              if (NULL == input || NULL == data_len) {
    934                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    935              }
    936          
    937              padding_len = input[input_len - 1];
    938              *data_len = input_len - padding_len;
    939          
    940              /* Avoid logical || since it results in a branch */
    941              bad = mbedtls_ct_uint_gt(padding_len, input_len);
    942              bad = mbedtls_ct_bool_or(bad, mbedtls_ct_uint_eq(padding_len, 0));
    943          
    944              /* The number of bytes checked must be independent of padding_len */
    945              pad_idx = input_len - padding_len;
    946              for (i = 0; i < input_len - 1; i++) {
    947                  mbedtls_ct_condition_t is_padding = mbedtls_ct_uint_ge(i, pad_idx);
    948                  mbedtls_ct_condition_t nonzero_pad_byte;
    949                  nonzero_pad_byte = mbedtls_ct_bool_if_else_0(is_padding, mbedtls_ct_bool(input[i]));
    950                  bad = mbedtls_ct_bool_or(bad, nonzero_pad_byte);
    951              }
    952          
    953              return mbedtls_ct_error_if_else_0(bad, MBEDTLS_ERR_CIPHER_INVALID_PADDING);
    954          }
    955          #endif /* MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN */
    956          
    957          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
    958          /*
    959           * Zero padding: fill with 00 ... 00
    960           */
    961          static void add_zeros_padding(unsigned char *output,
    962                                        size_t output_len, size_t data_len)
    963          {
    964              memset(output + data_len, 0, output_len - data_len);
    965          }
    966          
    967          static int get_zeros_padding(unsigned char *input, size_t input_len,
    968                                       size_t *data_len)
    969          {
    970              size_t i;
    971              mbedtls_ct_condition_t done = MBEDTLS_CT_FALSE, prev_done;
    972          
    973              if (NULL == input || NULL == data_len) {
    974                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    975              }
    976          
    977              *data_len = 0;
    978              for (i = input_len; i > 0; i--) {
    979                  prev_done = done;
    980                  done = mbedtls_ct_bool_or(done, mbedtls_ct_uint_ne(input[i-1], 0));
    981                  *data_len = mbedtls_ct_size_if(mbedtls_ct_bool_ne(done, prev_done), i, *data_len);
    982              }
    983          
    984              return 0;
    985          }
    986          #endif /* MBEDTLS_CIPHER_PADDING_ZEROS */
    987          
    988          /*
    989           * No padding: don't pad :)
    990           *
    991           * There is no add_padding function (check for NULL in mbedtls_cipher_finish)
    992           * but a trivial get_padding function
    993           */

   \                                 In section .text, align 2, keep-with-next
    994          static int get_no_padding(unsigned char *input, size_t input_len,
    995                                    size_t *data_len)
    996          {
    997              if (NULL == input || NULL == data_len) {
   \                     get_no_padding: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF18             IT       NE
   \        0x4   0x2A00             CMPNE    R2,#+0
   \        0x6   0xD100             BNE.N    ??get_no_padding_0
    998                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \        0x8   0x....             B.N      ?Subroutine0
    999              }
   1000          
   1001              *data_len = input_len;
   \                     ??get_no_padding_0: (+1)
   \        0xA   0x6011             STR      R1,[R2, #+0]
   1002          
   1003              return 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   1004          }
   1005          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          int mbedtls_cipher_finish(mbedtls_cipher_context_t *ctx,
   1008                                    unsigned char *output, size_t *olen)
   1009          {
   \                     mbedtls_cipher_finish: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   1010              if (ctx->cipher_info == NULL) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0xB180             CBZ.N    R0,??mbedtls_cipher_finish_0
   1011                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1012              }
   1013          
   1014          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1015              if (ctx->psa_enabled == 1) {
   \        0xA   0xF894 0x3044      LDRB     R3,[R4, #+68]
   \        0xE   0x2B01             CMP      R3,#+1
   \       0x10   0xF000 0x807F      BEQ.W    ??mbedtls_cipher_finish_1
   \       0x14   0x4615             MOV      R5,R2
   1016                  /* While PSA Crypto has an API for multipart
   1017                   * operations, we currently don't make it
   1018                   * accessible through the cipher layer. */
   1019                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1020              }
   1021          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1022          
   1023              *olen = 0;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x6029             STR      R1,[R5, #+0]
   1024          
   1025          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
   1026              /* CBC mode requires padding so we make sure a call to
   1027               * mbedtls_cipher_set_padding_mode has been done successfully. */
   1028              if (MBEDTLS_MODE_CBC == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \       0x1A   0x6843             LDR      R3,[R0, #+4]
   \       0x1C   0x0B1A             LSRS     R2,R3,#+12
   \       0x1E   0xF002 0x010F      AND      R1,R2,#0xF
   \       0x22   0x2902             CMP      R1,#+2
   \       0x24   0xBF04             ITT      EQ
   \       0x26   0x6921             LDREQ    R1,[R4, #+16]
   \       0x28   0x2900             CMPEQ    R1,#+0
   1029                  if (ctx->get_padding == NULL) {
   \       0x2A   0xD102             BNE.N    ??mbedtls_cipher_finish_2
   1030                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_finish_0: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \       0x30   0xBDFE             POP      {R1-R7,PC}
   1031                  }
   1032              }
   1033          #endif
   1034          
   1035              if (MBEDTLS_MODE_CFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1036                  MBEDTLS_MODE_OFB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1037                  MBEDTLS_MODE_CTR == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1038                  MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1039                  MBEDTLS_MODE_CCM_STAR_NO_TAG == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1040                  MBEDTLS_MODE_XTS == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1041                  MBEDTLS_MODE_STREAM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \                     ??mbedtls_cipher_finish_2: (+1)
   \       0x32   0xF002 0x010F      AND      R1,R2,#0xF
   \       0x36   0x2903             CMP      R1,#+3
   \       0x38   0xBF1C             ITT      NE
   \       0x3A   0xF002 0x070F      ANDNE    R7,R2,#0xF
   \       0x3E   0x2F04             CMPNE    R7,#+4
   \       0x40   0xD065             BEQ.N    ??mbedtls_cipher_finish_3
   \       0x42   0x2905             CMP      R1,#+5
   \       0x44   0xBF18             IT       NE
   \       0x46   0x2F06             CMPNE    R7,#+6
   \       0x48   0xD061             BEQ.N    ??mbedtls_cipher_finish_3
   \       0x4A   0x2909             CMP      R1,#+9
   \       0x4C   0xBF18             IT       NE
   \       0x4E   0x2F0A             CMPNE    R7,#+10
   \       0x50   0xD05D             BEQ.N    ??mbedtls_cipher_finish_3
   \       0x52   0x2907             CMP      R1,#+7
   \       0x54   0xBF1E             ITTT     NE
   \       0x56   0x0C1B             LSRNE    R3,R3,#+16
   \       0x58   0xB2D9             UXTBNE   R1,R3
   \       0x5A   0x294C             CMPNE    R1,#+76
   1042                  return 0;
   1043              }
   1044          
   1045              if ((MBEDTLS_CIPHER_CHACHA20          == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) ||
   1046                  (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type))) {
   \       0x5C   0xBF1C             ITT      NE
   \       0x5E   0xB2DB             UXTBNE   R3,R3
   \       0x60   0x2B4D             CMPNE    R3,#+77
   \       0x62   0xD054             BEQ.N    ??mbedtls_cipher_finish_3
   1047                  return 0;
   1048              }
   1049          
   1050              if (MBEDTLS_MODE_ECB == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \       0x64   0xF002 0x010F      AND      R1,R2,#0xF
   \       0x68   0x.... 0x....      LDR.W    R7,??DataTable17_11
   \       0x6C   0x2901             CMP      R1,#+1
   \       0x6E   0xD009             BEQ.N    ??mbedtls_cipher_finish_4
   1051                  if (ctx->unprocessed_len != 0) {
   1052                      return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   1053                  }
   1054          
   1055                  return 0;
   1056              }
   1057          
   1058          #if defined(MBEDTLS_CIPHER_MODE_CBC)
   1059              if (MBEDTLS_MODE_CBC == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \       0x70   0xF002 0x020F      AND      R2,R2,#0xF
   \       0x74   0x2A02             CMP      R2,#+2
   \       0x76   0xD14C             BNE.N    ??mbedtls_cipher_finish_1
   1060                  int ret = 0;
   1061          
   1062                  if (MBEDTLS_ENCRYPT == ctx->operation) {
   \       0x78   0xF994 0x1008      LDRSB    R1,[R4, #+8]
   \       0x7C   0x2901             CMP      R1,#+1
   \       0x7E   0xD126             BNE.N    ??mbedtls_cipher_finish_5
   1063                      /* check for 'no padding' mode */
   1064                      if (NULL == ctx->add_padding) {
   \       0x80   0x68E3             LDR      R3,[R4, #+12]
   \       0x82   0xB91B             CBNZ.N   R3,??mbedtls_cipher_finish_6
   1065                          if (0 != ctx->unprocessed_len) {
   \                     ??mbedtls_cipher_finish_4: (+1)
   \       0x84   0x6A60             LDR      R0,[R4, #+36]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD045             BEQ.N    ??mbedtls_cipher_finish_7
   1066                              return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   \       0x8A   0xE02C             B.N      ??mbedtls_cipher_finish_8
   1067                          }
   1068          
   1069                          return 0;
   1070                      }
   1071          
   1072                      ctx->add_padding(ctx->unprocessed_data, mbedtls_cipher_get_iv_size(ctx),
   1073                                       ctx->unprocessed_len);
   1074                  } else if (mbedtls_cipher_get_block_size(ctx) != ctx->unprocessed_len) {
   \                     ??mbedtls_cipher_finish_6: (+1)
   \       0x8C   0x6BA1             LDR      R1,[R4, #+56]
   \       0x8E   0xB919             CBNZ.N   R1,??mbedtls_cipher_finish_9
   \       0x90   0x6840             LDR      R0,[R0, #+4]
   \       0x92   0xF3C0 0x1142      UBFX     R1,R0,#+5,#+3
   \       0x96   0x0089             LSLS     R1,R1,#+2
   \                     ??mbedtls_cipher_finish_9: (+1)
   \       0x98   0x6A62             LDR      R2,[R4, #+36]
   \       0x9A   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x9E   0x4798             BLX      R3
   1075                      /*
   1076                       * For decrypt operations, expect a full block,
   1077                       * or an empty block if no padding
   1078                       */
   1079                      if (NULL == ctx->add_padding && 0 == ctx->unprocessed_len) {
   1080                          return 0;
   1081                      }
   1082          
   1083                      return MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED;
   1084                  }
   1085          
   1086                  /* cipher block */
   1087                  if (0 != (ret = mbedtls_cipher_get_base(ctx->cipher_info)->cbc_func(ctx->cipher_ctx,
   1088                                                                                      ctx->operation,
   1089                                                                                      mbedtls_cipher_get_block_size(
   1090                                                                                          ctx),
   1091                                                                                      ctx->iv,
   1092                                                                                      ctx->unprocessed_data,
   1093                                                                                      output))) {
   \                     ??mbedtls_cipher_finish_10: (+1)
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \       0xA6   0x4607             MOV      R7,R0
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x.... 0x....      BL       mbedtls_cipher_get_base
   \       0xAE   0x4684             MOV      R12,R0
   \       0xB0   0xF104 0x0014      ADD      R0,R4,#+20
   \       0xB4   0x9601             STR      R6,[SP, #+4]
   \       0xB6   0x9000             STR      R0,[SP, #+0]
   \       0xB8   0x463A             MOV      R2,R7
   \       0xBA   0xF994 0x1008      LDRSB    R1,[R4, #+8]
   \       0xBE   0x6BE0             LDR      R0,[R4, #+60]
   \       0xC0   0xF8DC 0x7008      LDR      R7,[R12, #+8]
   \       0xC4   0xF104 0x0328      ADD      R3,R4,#+40
   \       0xC8   0x47B8             BLX      R7
   \       0xCA   0xB170             CBZ.N    R0,??mbedtls_cipher_finish_11
   1094                      return ret;
   \       0xCC   0xBDFE             POP      {R1-R7,PC}
   1095                  }
   \                     ??mbedtls_cipher_finish_5: (+1)
   \       0xCE   0x4620             MOV      R0,R4
   \       0xD0   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \       0xD4   0x4601             MOV      R1,R0
   \       0xD6   0x6A60             LDR      R0,[R4, #+36]
   \       0xD8   0x4281             CMP      R1,R0
   \       0xDA   0xD0E1             BEQ.N    ??mbedtls_cipher_finish_10
   \       0xDC   0x68E1             LDR      R1,[R4, #+12]
   \       0xDE   0x2900             CMP      R1,#+0
   \       0xE0   0xBF08             IT       EQ
   \       0xE2   0x2800             CMPEQ    R0,#+0
   \       0xE4   0xD017             BEQ.N    ??mbedtls_cipher_finish_7
   \                     ??mbedtls_cipher_finish_8: (+1)
   \       0xE6   0x4638             MOV      R0,R7
   \       0xE8   0xBDFE             POP      {R1-R7,PC}
   1096          
   1097                  /* Set output size for decryption */
   1098                  if (MBEDTLS_DECRYPT == ctx->operation) {
   \                     ??mbedtls_cipher_finish_11: (+1)
   \       0xEA   0xF994 0x0008      LDRSB    R0,[R4, #+8]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0x4620             MOV      R0,R4
   \       0xF2   0xD109             BNE.N    ??mbedtls_cipher_finish_12
   1099                      return ctx->get_padding(output, mbedtls_cipher_get_block_size(ctx),
   1100                                              olen);
   \       0xF4   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \       0xF8   0x4601             MOV      R1,R0
   \       0xFA   0x6923             LDR      R3,[R4, #+16]
   \       0xFC   0x462A             MOV      R2,R5
   \       0xFE   0x4630             MOV      R0,R6
   \      0x100   0xB003             ADD      SP,SP,#+12
   \      0x102   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \      0x106   0x4718             BX       R3
   1101                  }
   1102          
   1103                  /* Set output size for encryption */
   1104                  *olen = mbedtls_cipher_get_block_size(ctx);
   \                     ??mbedtls_cipher_finish_12: (+1)
   \      0x108   0x.... 0x....      BL       mbedtls_cipher_get_block_size
   \      0x10C   0x6028             STR      R0,[R5, #+0]
   1105                  return 0;
   \                     ??mbedtls_cipher_finish_3: (+1)
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0xBDFE             POP      {R1-R7,PC}
   1106              }
   1107          #else
   1108              ((void) output);
   1109          #endif /* MBEDTLS_CIPHER_MODE_CBC */
   1110          
   1111              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_cipher_finish_1: (+1)
   \      0x112   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \                     ??mbedtls_cipher_finish_7: (+1)
   \      0x116   0xBDFE             POP      {R1-R7,PC}
   1112          }
   1113          
   1114          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)

   \                                 In section .text, align 2, keep-with-next
   1115          int mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t *ctx,
   1116                                              mbedtls_cipher_padding_t mode)
   1117          {
   \                     mbedtls_cipher_set_padding_mode: (+1)
   \        0x0   0x4602             MOV      R2,R0
   1118              if (NULL == ctx->cipher_info ||
   1119                  MBEDTLS_MODE_CBC != ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   \        0x2   0x6810             LDR      R0,[R2, #+0]
   \        0x4   0xB128             CBZ.N    R0,??mbedtls_cipher_set_padding_mode_0
   \        0x6   0x6840             LDR      R0,[R0, #+4]
   \        0x8   0x0B00             LSRS     R0,R0,#+12
   \        0xA   0xF000 0x000F      AND      R0,R0,#0xF
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD000             BEQ.N    ??mbedtls_cipher_set_padding_mode_1
   1120                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_cipher_set_padding_mode_0: (+1)
   \       0x12   0x....             B.N      ?Subroutine0
   1121              }
   1122          
   1123          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1124              if (ctx->psa_enabled == 1) {
   \                     ??mbedtls_cipher_set_padding_mode_1: (+1)
   \       0x14   0xF892 0x3044      LDRB     R3,[R2, #+68]
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \       0x1C   0x2B01             CMP      R3,#+1
   \       0x1E   0xD103             BNE.N    ??mbedtls_cipher_set_padding_mode_2
   1125                  /* While PSA Crypto knows about CBC padding
   1126                   * schemes, we currently don't make them
   1127                   * accessible through the cipher layer. */
   1128                  if (mode != MBEDTLS_PADDING_NONE) {
   \       0x20   0x2904             CMP      R1,#+4
   \       0x22   0xD109             BNE.N    ??mbedtls_cipher_set_padding_mode_3
   1129                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1130                  }
   1131          
   1132                  return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR
   1133              }
   1134          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1135          
   1136              switch (mode) {
   \                     ??mbedtls_cipher_set_padding_mode_2: (+1)
   \       0x28   0x2904             CMP      R1,#+4
   \       0x2A   0xD105             BNE.N    ??mbedtls_cipher_set_padding_mode_3
   1137          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
   1138                  case MBEDTLS_PADDING_PKCS7:
   1139                      ctx->add_padding = add_pkcs_padding;
   1140                      ctx->get_padding = get_pkcs_padding;
   1141                      break;
   1142          #endif
   1143          #if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
   1144                  case MBEDTLS_PADDING_ONE_AND_ZEROS:
   1145                      ctx->add_padding = add_one_and_zeros_padding;
   1146                      ctx->get_padding = get_one_and_zeros_padding;
   1147                      break;
   1148          #endif
   1149          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
   1150                  case MBEDTLS_PADDING_ZEROS_AND_LEN:
   1151                      ctx->add_padding = add_zeros_and_len_padding;
   1152                      ctx->get_padding = get_zeros_and_len_padding;
   1153                      break;
   1154          #endif
   1155          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
   1156                  case MBEDTLS_PADDING_ZEROS:
   1157                      ctx->add_padding = add_zeros_padding;
   1158                      ctx->get_padding = get_zeros_padding;
   1159                      break;
   1160          #endif
   1161                  case MBEDTLS_PADDING_NONE:
   1162                      ctx->add_padding = NULL;
   1163                      ctx->get_padding = get_no_padding;
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable17_12
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x6110             STR      R0,[R2, #+16]
   \       0x34   0x60D1             STR      R1,[R2, #+12]
   1164                      break;
   1165          
   1166                  default:
   1167                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1168              }
   1169          
   1170              return 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_set_padding_mode_3: (+1)
   \       0x38   0x4770             BX       LR
   1171          }
   1172          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
   1173          
   1174          #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CHACHAPOLY_C)
   1175          int mbedtls_cipher_write_tag(mbedtls_cipher_context_t *ctx,
   1176                                       unsigned char *tag, size_t tag_len)
   1177          {
   1178              if (ctx->cipher_info == NULL) {
   1179                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1180              }
   1181          
   1182              if (MBEDTLS_ENCRYPT != ctx->operation) {
   1183                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1184              }
   1185          
   1186          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1187              if (ctx->psa_enabled == 1) {
   1188                  /* While PSA Crypto has an API for multipart
   1189                   * operations, we currently don't make it
   1190                   * accessible through the cipher layer. */
   1191                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1192              }
   1193          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1194          
   1195          #if defined(MBEDTLS_GCM_C)
   1196              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1197                  size_t output_length;
   1198                  /* The code here doesn't yet support alternative implementations
   1199                   * that can delay up to a block of output. */
   1200                  return mbedtls_gcm_finish((mbedtls_gcm_context *) ctx->cipher_ctx,
   1201                                            NULL, 0, &output_length,
   1202                                            tag, tag_len);
   1203              }
   1204          #endif
   1205          
   1206          #if defined(MBEDTLS_CHACHAPOLY_C)
   1207              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1208                  /* Don't allow truncated MAC for Poly1305 */
   1209                  if (tag_len != 16U) {
   1210                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1211                  }
   1212          
   1213                  return mbedtls_chachapoly_finish(
   1214                      (mbedtls_chachapoly_context *) ctx->cipher_ctx, tag);
   1215              }
   1216          #endif
   1217          
   1218              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1219          }
   1220          
   1221          int mbedtls_cipher_check_tag(mbedtls_cipher_context_t *ctx,
   1222                                       const unsigned char *tag, size_t tag_len)
   1223          {
   1224              unsigned char check_tag[16];
   1225              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1226          
   1227              if (ctx->cipher_info == NULL) {
   1228                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1229              }
   1230          
   1231              if (MBEDTLS_DECRYPT != ctx->operation) {
   1232                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1233              }
   1234          
   1235          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1236              if (ctx->psa_enabled == 1) {
   1237                  /* While PSA Crypto has an API for multipart
   1238                   * operations, we currently don't make it
   1239                   * accessible through the cipher layer. */
   1240                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1241              }
   1242          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1243          
   1244              /* Status to return on a non-authenticated algorithm. */
   1245              ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1246          
   1247          #if defined(MBEDTLS_GCM_C)
   1248              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1249                  size_t output_length;
   1250                  /* The code here doesn't yet support alternative implementations
   1251                   * that can delay up to a block of output. */
   1252          
   1253                  if (tag_len > sizeof(check_tag)) {
   1254                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1255                  }
   1256          
   1257                  if (0 != (ret = mbedtls_gcm_finish(
   1258                                (mbedtls_gcm_context *) ctx->cipher_ctx,
   1259                                NULL, 0, &output_length,
   1260                                check_tag, tag_len))) {
   1261                      return ret;
   1262                  }
   1263          
   1264                  /* Check the tag in "constant-time" */
   1265                  if (mbedtls_ct_memcmp(tag, check_tag, tag_len) != 0) {
   1266                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1267                      goto exit;
   1268                  }
   1269              }
   1270          #endif /* MBEDTLS_GCM_C */
   1271          
   1272          #if defined(MBEDTLS_CHACHAPOLY_C)
   1273              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1274                  /* Don't allow truncated MAC for Poly1305 */
   1275                  if (tag_len != sizeof(check_tag)) {
   1276                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1277                  }
   1278          
   1279                  ret = mbedtls_chachapoly_finish(
   1280                      (mbedtls_chachapoly_context *) ctx->cipher_ctx, check_tag);
   1281                  if (ret != 0) {
   1282                      return ret;
   1283                  }
   1284          
   1285                  /* Check the tag in "constant-time" */
   1286                  if (mbedtls_ct_memcmp(tag, check_tag, tag_len) != 0) {
   1287                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1288                      goto exit;
   1289                  }
   1290              }
   1291          #endif /* MBEDTLS_CHACHAPOLY_C */
   1292          
   1293          exit:
   1294              mbedtls_platform_zeroize(check_tag, tag_len);
   1295              return ret;
   1296          }
   1297          #endif /* MBEDTLS_GCM_C || MBEDTLS_CHACHAPOLY_C */
   1298          
   1299          /*
   1300           * Packet-oriented wrapper for non-AEAD modes
   1301           */

   \                                 In section .text, align 2, keep-with-next
   1302          int mbedtls_cipher_crypt(mbedtls_cipher_context_t *ctx,
   1303                                   const unsigned char *iv, size_t iv_len,
   1304                                   const unsigned char *input, size_t ilen,
   1305                                   unsigned char *output, size_t *olen)
   1306          {
   \                     mbedtls_cipher_crypt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0xB0AA             SUB      SP,SP,#+168
   1307              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1308              size_t finish_olen;
   1309          
   1310          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1311              if (ctx->psa_enabled == 1) {
   \        0x8   0xF899 0x0044      LDRB     R0,[R9, #+68]
   \        0xC   0x468B             MOV      R11,R1
   \        0xE   0x4690             MOV      R8,R2
   \       0x10   0x469A             MOV      R10,R3
   \       0x12   0x9E34             LDR      R6,[SP, #+208]
   \       0x14   0x9F35             LDR      R7,[SP, #+212]
   \       0x16   0x9C36             LDR      R4,[SP, #+216]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD144             BNE.N    ??mbedtls_cipher_crypt_0
   1312                  /* As in the non-PSA case, we don't check that
   1313                   * a key has been set. If not, the key slot will
   1314                   * still be in its default state of 0, which is
   1315                   * guaranteed to be invalid, hence the PSA-call
   1316                   * below will gracefully fail. */
   1317                  mbedtls_cipher_context_psa * const cipher_psa =
   1318                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   \       0x1C   0xF8D9 0x503C      LDR      R5,[R9, #+60]
   1319          
   1320                  psa_status_t status;
   1321                  psa_cipher_operation_t cipher_op = PSA_CIPHER_OPERATION_INIT;
   \       0x20   0xA804             ADD      R0,SP,#+16
   \       0x22   0x2198             MOVS     R1,#+152
   \       0x24   0x.... 0x....      BL       __aeabi_memclr4
   1322                  size_t part_len;
   1323          
   1324                  if (ctx->operation == MBEDTLS_DECRYPT) {
   \       0x28   0xF999 0x0008      LDRSB    R0,[R9, #+8]
   \       0x2C   0xB950             CBNZ.N   R0,??mbedtls_cipher_crypt_1
   1325                      status = psa_cipher_decrypt_setup(&cipher_op,
   1326                                                        cipher_psa->slot,
   1327                                                        cipher_psa->alg);
   \       0x2E   0x682A             LDR      R2,[R5, #+0]
   \       0x30   0x6869             LDR      R1,[R5, #+4]
   \       0x32   0xA804             ADD      R0,SP,#+16
   \       0x34   0x.... 0x....      BL       psa_cipher_decrypt_setup
   1328                  } else if (ctx->operation == MBEDTLS_ENCRYPT) {
   1329                      status = psa_cipher_encrypt_setup(&cipher_op,
   1330                                                        cipher_psa->slot,
   1331                                                        cipher_psa->alg);
   1332                  } else {
   1333                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1334                  }
   1335          
   1336                  /* In the following, we can immediately return on an error,
   1337                   * because the PSA Crypto API guarantees that cipher operations
   1338                   * are terminated by unsuccessful calls to psa_cipher_update(),
   1339                   * and by any call to psa_cipher_finish(). */
   1340                  if (status == PSA_ERROR_NOT_SUPPORTED) {
   \                     ??mbedtls_cipher_crypt_2: (+1)
   \       0x38   0xF110 0x0F86      CMN      R0,#+134
   \       0x3C   0xD10C             BNE.N    ??mbedtls_cipher_crypt_3
   1341                      return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   \       0x3E   0xF06F 0x0071      MVN      R0,#+113
   \       0x42   0xE04C             B.N      ??mbedtls_cipher_crypt_4
   1342                  } else if (status != PSA_SUCCESS) {
   \                     ??mbedtls_cipher_crypt_1: (+1)
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD105             BNE.N    ??mbedtls_cipher_crypt_5
   \       0x48   0x682A             LDR      R2,[R5, #+0]
   \       0x4A   0x6869             LDR      R1,[R5, #+4]
   \       0x4C   0xA804             ADD      R0,SP,#+16
   \       0x4E   0x.... 0x....      BL       psa_cipher_encrypt_setup
   \       0x52   0xE7F1             B.N      ??mbedtls_cipher_crypt_2
   \                     ??mbedtls_cipher_crypt_5: (+1)
   \       0x54   0x....             LDR.N    R0,??DataTable17_4
   \       0x56   0xE042             B.N      ??mbedtls_cipher_crypt_4
   \                     ??mbedtls_cipher_crypt_3: (+1)
   \       0x58   0xF06F 0x056F      MVN      R5,#+111
   \       0x5C   0xB9F0             CBNZ.N   R0,??mbedtls_cipher_crypt_6
   1343                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   1344                  }
   1345          
   1346                  if (((mbedtls_cipher_mode_t) ctx->cipher_info->mode) != MBEDTLS_MODE_ECB) {
   \       0x5E   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x62   0x6848             LDR      R0,[R1, #+4]
   \       0x64   0x0B00             LSRS     R0,R0,#+12
   \       0x66   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x6A   0x2801             CMP      R0,#+1
   \       0x6C   0xD005             BEQ.N    ??mbedtls_cipher_crypt_7
   1347                      status = psa_cipher_set_iv(&cipher_op, iv, iv_len);
   1348                      if (status != PSA_SUCCESS) {
   \       0x6E   0x4642             MOV      R2,R8
   \       0x70   0x4659             MOV      R1,R11
   \       0x72   0xA804             ADD      R0,SP,#+16
   \       0x74   0x.... 0x....      BL       psa_cipher_set_iv
   \       0x78   0xB980             CBNZ.N   R0,??mbedtls_cipher_crypt_6
   1349                          return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   1350                      }
   1351                  }
   1352          
   1353                  status = psa_cipher_update(&cipher_op,
   1354                                             input, ilen,
   1355                                             output, ilen, olen);
   1356                  if (status != PSA_SUCCESS) {
   \                     ??mbedtls_cipher_crypt_7: (+1)
   \       0x7A   0x9401             STR      R4,[SP, #+4]
   \       0x7C   0x9600             STR      R6,[SP, #+0]
   \       0x7E   0x463B             MOV      R3,R7
   \       0x80   0x4632             MOV      R2,R6
   \       0x82   0x4651             MOV      R1,R10
   \       0x84   0xA804             ADD      R0,SP,#+16
   \       0x86   0x.... 0x....      BL       psa_cipher_update
   \       0x8A   0xB938             CBNZ.N   R0,??mbedtls_cipher_crypt_6
   1357                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   1358                  }
   1359          
   1360                  status = psa_cipher_finish(&cipher_op,
   1361                                             output + *olen, ilen - *olen,
   1362                                             &part_len);
   1363                  if (status != PSA_SUCCESS) {
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x1A32             SUBS     R2,R6,R0
   \       0x90   0xAB02             ADD      R3,SP,#+8
   \       0x92   0x1839             ADDS     R1,R7,R0
   \       0x94   0xA804             ADD      R0,SP,#+16
   \       0x96   0x.... 0x....      BL       psa_cipher_finish
   \       0x9A   0xB108             CBZ.N    R0,??mbedtls_cipher_crypt_8
   1364                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \                     ??mbedtls_cipher_crypt_6: (+1)
   \       0x9C   0x4628             MOV      R0,R5
   \       0x9E   0xE01E             B.N      ??mbedtls_cipher_crypt_4
   1365                  }
   1366          
   1367                  *olen += part_len;
   \                     ??mbedtls_cipher_crypt_8: (+1)
   \       0xA0   0x6821             LDR      R1,[R4, #+0]
   \       0xA2   0x9802             LDR      R0,[SP, #+8]
   \       0xA4   0xE018             B.N      ??mbedtls_cipher_crypt_9
   1368                  return 0;
   1369              }
   1370          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1371          
   1372              if ((ret = mbedtls_cipher_set_iv(ctx, iv, iv_len)) != 0) {
   \                     ??mbedtls_cipher_crypt_0: (+1)
   \       0xA6   0x4648             MOV      R0,R9
   \       0xA8   0x.... 0x....      BL       mbedtls_cipher_set_iv
   \       0xAC   0xB9B8             CBNZ.N   R0,??mbedtls_cipher_crypt_4
   1373                  return ret;
   1374              }
   1375          
   1376              if ((ret = mbedtls_cipher_reset(ctx)) != 0) {
   \       0xAE   0x4648             MOV      R0,R9
   \       0xB0   0x.... 0x....      BL       mbedtls_cipher_reset
   \       0xB4   0xB998             CBNZ.N   R0,??mbedtls_cipher_crypt_4
   1377                  return ret;
   1378              }
   1379          
   1380              if ((ret = mbedtls_cipher_update(ctx, input, ilen,
   1381                                               output, olen)) != 0) {
   \       0xB6   0x9400             STR      R4,[SP, #+0]
   \       0xB8   0x463B             MOV      R3,R7
   \       0xBA   0x4632             MOV      R2,R6
   \       0xBC   0x4651             MOV      R1,R10
   \       0xBE   0x4648             MOV      R0,R9
   \       0xC0   0x.... 0x....      BL       mbedtls_cipher_update
   \       0xC4   0xB958             CBNZ.N   R0,??mbedtls_cipher_crypt_4
   1382                  return ret;
   1383              }
   1384          
   1385              if ((ret = mbedtls_cipher_finish(ctx, output + *olen,
   1386                                               &finish_olen)) != 0) {
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0xAA03             ADD      R2,SP,#+12
   \       0xCA   0x1839             ADDS     R1,R7,R0
   \       0xCC   0x4648             MOV      R0,R9
   \       0xCE   0x.... 0x....      BL       mbedtls_cipher_finish
   \       0xD2   0xB920             CBNZ.N   R0,??mbedtls_cipher_crypt_4
   1387                  return ret;
   1388              }
   1389          
   1390              *olen += finish_olen;
   \       0xD4   0x6821             LDR      R1,[R4, #+0]
   \       0xD6   0x9803             LDR      R0,[SP, #+12]
   \                     ??mbedtls_cipher_crypt_9: (+1)
   \       0xD8   0x1841             ADDS     R1,R0,R1
   \       0xDA   0x6021             STR      R1,[R4, #+0]
   1391          
   1392              return 0;
   \       0xDC   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_crypt_4: (+1)
   \       0xDE   0xB02B             ADD      SP,SP,#+172
   \       0xE0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1393          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 140
   1394          
   1395          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
   1396          /*
   1397           * Packet-oriented encryption for AEAD modes: internal function used by
   1398           * mbedtls_cipher_auth_encrypt_ext().
   1399           */
   1400          static int mbedtls_cipher_aead_encrypt(mbedtls_cipher_context_t *ctx,
   1401                                                 const unsigned char *iv, size_t iv_len,
   1402                                                 const unsigned char *ad, size_t ad_len,
   1403                                                 const unsigned char *input, size_t ilen,
   1404                                                 unsigned char *output, size_t *olen,
   1405                                                 unsigned char *tag, size_t tag_len)
   1406          {
   1407          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1408              if (ctx->psa_enabled == 1) {
   1409                  /* As in the non-PSA case, we don't check that
   1410                   * a key has been set. If not, the key slot will
   1411                   * still be in its default state of 0, which is
   1412                   * guaranteed to be invalid, hence the PSA-call
   1413                   * below will gracefully fail. */
   1414                  mbedtls_cipher_context_psa * const cipher_psa =
   1415                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   1416          
   1417                  psa_status_t status;
   1418          
   1419                  /* PSA Crypto API always writes the authentication tag
   1420                   * at the end of the encrypted message. */
   1421                  if (output == NULL || tag != output + ilen) {
   1422                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1423                  }
   1424          
   1425                  status = psa_aead_encrypt(cipher_psa->slot,
   1426                                            cipher_psa->alg,
   1427                                            iv, iv_len,
   1428                                            ad, ad_len,
   1429                                            input, ilen,
   1430                                            output, ilen + tag_len, olen);
   1431                  if (status == PSA_ERROR_NOT_SUPPORTED) {
   1432                      return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   1433                  } else if (status != PSA_SUCCESS) {
   1434                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   1435                  }
   1436          
   1437                  *olen -= tag_len;
   1438                  return 0;
   1439              }
   1440          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1441          
   1442          #if defined(MBEDTLS_GCM_C)
   1443              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1444                  *olen = ilen;
   1445                  return mbedtls_gcm_crypt_and_tag(ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT,
   1446                                                   ilen, iv, iv_len, ad, ad_len,
   1447                                                   input, output, tag_len, tag);
   1448              }
   1449          #endif /* MBEDTLS_GCM_C */
   1450          #if defined(MBEDTLS_CCM_C)
   1451              if (MBEDTLS_MODE_CCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1452                  *olen = ilen;
   1453                  return mbedtls_ccm_encrypt_and_tag(ctx->cipher_ctx, ilen,
   1454                                                     iv, iv_len, ad, ad_len, input, output,
   1455                                                     tag, tag_len);
   1456              }
   1457          #endif /* MBEDTLS_CCM_C */
   1458          #if defined(MBEDTLS_CHACHAPOLY_C)
   1459              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1460                  /* ChachaPoly has fixed length nonce and MAC (tag) */
   1461                  if ((iv_len != mbedtls_cipher_info_get_iv_size(ctx->cipher_info)) ||
   1462                      (tag_len != 16U)) {
   1463                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1464                  }
   1465          
   1466                  *olen = ilen;
   1467                  return mbedtls_chachapoly_encrypt_and_tag(ctx->cipher_ctx,
   1468                                                            ilen, iv, ad, ad_len, input, output, tag);
   1469              }
   1470          #endif /* MBEDTLS_CHACHAPOLY_C */
   1471          
   1472              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1473          }
   1474          
   1475          /*
   1476           * Packet-oriented encryption for AEAD modes: internal function used by
   1477           * mbedtls_cipher_auth_encrypt_ext().
   1478           */
   1479          static int mbedtls_cipher_aead_decrypt(mbedtls_cipher_context_t *ctx,
   1480                                                 const unsigned char *iv, size_t iv_len,
   1481                                                 const unsigned char *ad, size_t ad_len,
   1482                                                 const unsigned char *input, size_t ilen,
   1483                                                 unsigned char *output, size_t *olen,
   1484                                                 const unsigned char *tag, size_t tag_len)
   1485          {
   1486          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1487              if (ctx->psa_enabled == 1) {
   1488                  /* As in the non-PSA case, we don't check that
   1489                   * a key has been set. If not, the key slot will
   1490                   * still be in its default state of 0, which is
   1491                   * guaranteed to be invalid, hence the PSA-call
   1492                   * below will gracefully fail. */
   1493                  mbedtls_cipher_context_psa * const cipher_psa =
   1494                      (mbedtls_cipher_context_psa *) ctx->cipher_ctx;
   1495          
   1496                  psa_status_t status;
   1497          
   1498                  /* PSA Crypto API always writes the authentication tag
   1499                   * at the end of the encrypted message. */
   1500                  if (input == NULL || tag != input + ilen) {
   1501                      return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1502                  }
   1503          
   1504                  status = psa_aead_decrypt(cipher_psa->slot,
   1505                                            cipher_psa->alg,
   1506                                            iv, iv_len,
   1507                                            ad, ad_len,
   1508                                            input, ilen + tag_len,
   1509                                            output, ilen, olen);
   1510                  if (status == PSA_ERROR_INVALID_SIGNATURE) {
   1511                      return MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1512                  } else if (status == PSA_ERROR_NOT_SUPPORTED) {
   1513                      return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   1514                  } else if (status != PSA_SUCCESS) {
   1515                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   1516                  }
   1517          
   1518                  return 0;
   1519              }
   1520          #endif /* MBEDTLS_USE_PSA_CRYPTO && !MBEDTLS_DEPRECATED_REMOVED */
   1521          
   1522          #if defined(MBEDTLS_GCM_C)
   1523              if (MBEDTLS_MODE_GCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1524                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1525          
   1526                  *olen = ilen;
   1527                  ret = mbedtls_gcm_auth_decrypt(ctx->cipher_ctx, ilen,
   1528                                                 iv, iv_len, ad, ad_len,
   1529                                                 tag, tag_len, input, output);
   1530          
   1531                  if (ret == MBEDTLS_ERR_GCM_AUTH_FAILED) {
   1532                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1533                  }
   1534          
   1535                  return ret;
   1536              }
   1537          #endif /* MBEDTLS_GCM_C */
   1538          #if defined(MBEDTLS_CCM_C)
   1539              if (MBEDTLS_MODE_CCM == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) {
   1540                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1541          
   1542                  *olen = ilen;
   1543                  ret = mbedtls_ccm_auth_decrypt(ctx->cipher_ctx, ilen,
   1544                                                 iv, iv_len, ad, ad_len,
   1545                                                 input, output, tag, tag_len);
   1546          
   1547                  if (ret == MBEDTLS_ERR_CCM_AUTH_FAILED) {
   1548                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1549                  }
   1550          
   1551                  return ret;
   1552              }
   1553          #endif /* MBEDTLS_CCM_C */
   1554          #if defined(MBEDTLS_CHACHAPOLY_C)
   1555              if (MBEDTLS_CIPHER_CHACHA20_POLY1305 == ((mbedtls_cipher_type_t) ctx->cipher_info->type)) {
   1556                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1557          
   1558                  /* ChachaPoly has fixed length nonce and MAC (tag) */
   1559                  if ((iv_len != mbedtls_cipher_info_get_iv_size(ctx->cipher_info)) ||
   1560                      (tag_len != 16U)) {
   1561                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1562                  }
   1563          
   1564                  *olen = ilen;
   1565                  ret = mbedtls_chachapoly_auth_decrypt(ctx->cipher_ctx, ilen,
   1566                                                        iv, ad, ad_len, tag, input, output);
   1567          
   1568                  if (ret == MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED) {
   1569                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   1570                  }
   1571          
   1572                  return ret;
   1573              }
   1574          #endif /* MBEDTLS_CHACHAPOLY_C */
   1575          
   1576              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1577          }
   1578          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
   1579          
   1580          #if defined(MBEDTLS_CIPHER_MODE_AEAD) || defined(MBEDTLS_NIST_KW_C)
   1581          /*
   1582           * Packet-oriented encryption for AEAD/NIST_KW: public function.
   1583           */

   \                                 In section .text, align 2, keep-with-next
   1584          int mbedtls_cipher_auth_encrypt_ext(mbedtls_cipher_context_t *ctx,
   1585                                              const unsigned char *iv, size_t iv_len,
   1586                                              const unsigned char *ad, size_t ad_len,
   1587                                              const unsigned char *input, size_t ilen,
   1588                                              unsigned char *output, size_t output_len,
   1589                                              size_t *olen, size_t tag_len)
   1590          {
   \                     mbedtls_cipher_auth_encrypt_ext: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4686             MOV      LR,R0
   \        0x8   0x4611             MOV      R1,R2
   \        0xA   0xB087             SUB      SP,SP,#+28
   1591          #if defined(MBEDTLS_NIST_KW_C)
   1592              if (
   1593          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1594                  ctx->psa_enabled == 0 &&
   1595          #endif
   1596                  (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1597                   MBEDTLS_MODE_KWP == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode))) {
   \        0xC   0xF89E 0x2044      LDRB     R2,[LR, #+68]
   \       0x10   0x4698             MOV      R8,R3
   \       0x12   0xF8DD 0x9040      LDR      R9,[SP, #+64]
   \       0x16   0xF8DD 0xC044      LDR      R12,[SP, #+68]
   \       0x1A   0xF8DD 0xA048      LDR      R10,[SP, #+72]
   \       0x1E   0x9B13             LDR      R3,[SP, #+76]
   \       0x20   0xF8DD 0xB050      LDR      R11,[SP, #+80]
   \       0x24   0x9E15             LDR      R6,[SP, #+84]
   \       0x26   0x9D16             LDR      R5,[SP, #+88]
   \       0x28   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \       0x2C   0x....             LDR.N    R0,??DataTable17_4
   \       0x2E   0xB9FA             CBNZ.N   R2,??mbedtls_cipher_auth_encrypt_ext_0
   \       0x30   0xF8DE 0x7000      LDR      R7,[LR, #+0]
   \       0x34   0x687F             LDR      R7,[R7, #+4]
   \       0x36   0x0B3F             LSRS     R7,R7,#+12
   \       0x38   0xF007 0x020F      AND      R2,R7,#0xF
   \       0x3C   0x2A0C             CMP      R2,#+12
   \       0x3E   0xD009             BEQ.N    ??mbedtls_cipher_auth_encrypt_ext_1
   \       0x40   0xF007 0x070F      AND      R7,R7,#0xF
   \       0x44   0x2F0D             CMP      R7,#+13
   \       0x46   0xD113             BNE.N    ??mbedtls_cipher_auth_encrypt_ext_0
   \       0x48   0x2401             MOVS     R4,#+1
   1598                  mbedtls_nist_kw_mode_t mode =
   1599                      (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) ?
   1600                      MBEDTLS_KW_MODE_KW : MBEDTLS_KW_MODE_KWP;
   1601          
   1602                  /* There is no iv, tag or ad associated with KW and KWP,
   1603                   * so these length should be 0 as documented. */
   1604                  if (iv_len != 0 || tag_len != 0 || ad_len != 0) {
   \                     ??mbedtls_cipher_auth_encrypt_ext_2: (+1)
   \       0x4A   0x4329             ORRS     R1,R5,R1
   \       0x4C   0xEA59 0x0101      ORRS     R1,R9,R1
   \       0x50   0xD002             BEQ.N    ??mbedtls_cipher_auth_encrypt_ext_3
   1605                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x52   0xE058             B.N      ??mbedtls_cipher_auth_encrypt_ext_4
   1606                  }
   \                     ??mbedtls_cipher_auth_encrypt_ext_1: (+1)
   \       0x54   0x2400             MOVS     R4,#+0
   \       0x56   0xE7F8             B.N      ??mbedtls_cipher_auth_encrypt_ext_2
   1607          
   1608                  (void) iv;
   1609                  (void) ad;
   1610          
   1611                  return mbedtls_nist_kw_wrap(ctx->cipher_ctx, mode, input, ilen,
   1612                                              output, olen, output_len);
   \                     ??mbedtls_cipher_auth_encrypt_ext_3: (+1)
   \       0x58   0xF8CD 0xB008      STR      R11,[SP, #+8]
   \       0x5C   0x9601             STR      R6,[SP, #+4]
   \       0x5E   0x9300             STR      R3,[SP, #+0]
   \       0x60   0xF8DE 0x003C      LDR      R0,[LR, #+60]
   \       0x64   0x4653             MOV      R3,R10
   \       0x66   0x4662             MOV      R2,R12
   \       0x68   0x4621             MOV      R1,R4
   \       0x6A   0x.... 0x....      BL       mbedtls_nist_kw_wrap
   \       0x6E   0xE04A             B.N      ??mbedtls_cipher_auth_encrypt_ext_4
   1613              }
   1614          #endif /* MBEDTLS_NIST_KW_C */
   1615          
   1616          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
   1617              /* AEAD case: check length before passing on to shared function */
   1618              if (output_len < ilen + tag_len) {
   \                     ??mbedtls_cipher_auth_encrypt_ext_0: (+1)
   \       0x70   0xEB05 0x070A      ADD      R7,R5,R10
   \       0x74   0x45BB             CMP      R11,R7
   \       0x76   0xD346             BCC.N    ??mbedtls_cipher_auth_encrypt_ext_4
   1619                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1620              }
   1621          
   1622              int ret = mbedtls_cipher_aead_encrypt(ctx, iv, iv_len, ad, ad_len,
   1623                                                    input, ilen, output, olen,
   1624                                                    output + ilen, tag_len);
   \       0x78   0x4622             MOV      R2,R4
   \       0x7A   0xF89D 0x4000      LDRB     R4,[SP, #+0]
   \       0x7E   0x....             LDR.N    R0,??DataTable17_9
   \       0x80   0x2C01             CMP      R4,#+1
   \       0x82   0xD122             BNE.N    ??mbedtls_cipher_auth_encrypt_ext_5
   \       0x84   0xF8DE 0x403C      LDR      R4,[LR, #+60]
   \       0x88   0x2B00             CMP      R3,#+0
   \       0x8A   0xD039             BEQ.N    ??mbedtls_cipher_auth_encrypt_ext_6
   \       0x8C   0x9606             STR      R6,[SP, #+24]
   \       0x8E   0x9705             STR      R7,[SP, #+20]
   \       0x90   0x9304             STR      R3,[SP, #+16]
   \       0x92   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \       0x96   0xF8CD 0xC008      STR      R12,[SP, #+8]
   \       0x9A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x9E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xA2   0x460B             MOV      R3,R1
   \       0xA4   0x6821             LDR      R1,[R4, #+0]
   \       0xA6   0x6860             LDR      R0,[R4, #+4]
   \       0xA8   0x.... 0x....      BL       psa_aead_encrypt
   \       0xAC   0xF110 0x0F86      CMN      R0,#+134
   \       0xB0   0xBF08             IT       EQ
   \       0xB2   0xF06F 0x0071      MVNEQ    R0,#+113
   \       0xB6   0xD023             BEQ.N    ??mbedtls_cipher_auth_encrypt_ext_6
   \       0xB8   0xB110             CBZ.N    R0,??mbedtls_cipher_auth_encrypt_ext_7
   \       0xBA   0xF06F 0x006F      MVN      R0,#+111
   \       0xBE   0xE01F             B.N      ??mbedtls_cipher_auth_encrypt_ext_6
   \                     ??mbedtls_cipher_auth_encrypt_ext_7: (+1)
   \       0xC0   0x6830             LDR      R0,[R6, #+0]
   \       0xC2   0x1B40             SUBS     R0,R0,R5
   \       0xC4   0x6030             STR      R0,[R6, #+0]
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xE01A             B.N      ??mbedtls_cipher_auth_encrypt_ext_6
   \                     ??mbedtls_cipher_auth_encrypt_ext_5: (+1)
   \       0xCA   0xF8DE 0x7000      LDR      R7,[LR, #+0]
   \       0xCE   0x687C             LDR      R4,[R7, #+4]
   \       0xD0   0x0B24             LSRS     R4,R4,#+12
   \       0xD2   0xF004 0x040F      AND      R4,R4,#0xF
   \       0xD6   0x2C08             CMP      R4,#+8
   \       0xD8   0xD112             BNE.N    ??mbedtls_cipher_auth_encrypt_ext_6
   \       0xDA   0xF8C6 0xA000      STR      R10,[R6, #+0]
   \       0xDE   0xEB03 0x000A      ADD      R0,R3,R10
   \       0xE2   0x9505             STR      R5,[SP, #+20]
   \       0xE4   0x9004             STR      R0,[SP, #+16]
   \       0xE6   0xF8CD 0xC008      STR      R12,[SP, #+8]
   \       0xEA   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0xEE   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xF2   0x9303             STR      R3,[SP, #+12]
   \       0xF4   0xF8DE 0x003C      LDR      R0,[LR, #+60]
   \       0xF8   0x460B             MOV      R3,R1
   \       0xFA   0x4651             MOV      R1,R10
   \       0xFC   0x.... 0x....      BL       mbedtls_ccm_encrypt_and_tag
   1625              *olen += tag_len;
   \                     ??mbedtls_cipher_auth_encrypt_ext_6: (+1)
   \      0x100   0x6831             LDR      R1,[R6, #+0]
   \      0x102   0x186D             ADDS     R5,R5,R1
   \      0x104   0x6035             STR      R5,[R6, #+0]
   1626              return ret;
   \                     ??mbedtls_cipher_auth_encrypt_ext_4: (+1)
   \      0x106   0x....             B.N      ?Subroutine1
   1627          #else
   1628              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1629          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
   1630          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB007             ADD      SP,SP,#+28
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1631          
   1632          /*
   1633           * Packet-oriented decryption for AEAD/NIST_KW: public function.
   1634           */

   \                                 In section .text, align 2, keep-with-next
   1635          int mbedtls_cipher_auth_decrypt_ext(mbedtls_cipher_context_t *ctx,
   1636                                              const unsigned char *iv, size_t iv_len,
   1637                                              const unsigned char *ad, size_t ad_len,
   1638                                              const unsigned char *input, size_t ilen,
   1639                                              unsigned char *output, size_t output_len,
   1640                                              size_t *olen, size_t tag_len)
   1641          {
   \                     mbedtls_cipher_auth_decrypt_ext: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0xB087             SUB      SP,SP,#+28
   1642          #if defined(MBEDTLS_NIST_KW_C)
   1643              if (
   1644          #if defined(MBEDTLS_USE_PSA_CRYPTO) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   1645                  ctx->psa_enabled == 0 &&
   1646          #endif
   1647                  (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode) ||
   1648                   MBEDTLS_MODE_KWP == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode))) {
   \        0xA   0xF897 0x6044      LDRB     R6,[R7, #+68]
   \        0xE   0x4611             MOV      R1,R2
   \       0x10   0x469C             MOV      R12,R3
   \       0x12   0x9D16             LDR      R5,[SP, #+88]
   \       0x14   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   \       0x18   0x9A11             LDR      R2,[SP, #+68]
   \       0x1A   0x9B12             LDR      R3,[SP, #+72]
   \       0x1C   0xF8DD 0xE04C      LDR      LR,[SP, #+76]
   \       0x20   0xF8DD 0xB050      LDR      R11,[SP, #+80]
   \       0x24   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \       0x28   0xF88D 0x6000      STRB     R6,[SP, #+0]
   \       0x2C   0x....             LDR.N    R0,??DataTable17_4
   \       0x2E   0xB9F6             CBNZ.N   R6,??mbedtls_cipher_auth_decrypt_ext_0
   \       0x30   0x683E             LDR      R6,[R7, #+0]
   \       0x32   0x6876             LDR      R6,[R6, #+4]
   \       0x34   0x0B36             LSRS     R6,R6,#+12
   \       0x36   0xF006 0x090F      AND      R9,R6,#0xF
   \       0x3A   0xF1B9 0x0F0C      CMP      R9,#+12
   \       0x3E   0xD009             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_1
   \       0x40   0xF006 0x060F      AND      R6,R6,#0xF
   \       0x44   0x2E0D             CMP      R6,#+13
   \       0x46   0xD112             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_0
   \       0x48   0x2401             MOVS     R4,#+1
   1649                  mbedtls_nist_kw_mode_t mode =
   1650                      (MBEDTLS_MODE_KW == ((mbedtls_cipher_mode_t) ctx->cipher_info->mode)) ?
   1651                      MBEDTLS_KW_MODE_KW : MBEDTLS_KW_MODE_KWP;
   1652          
   1653                  /* There is no iv, tag or ad associated with KW and KWP,
   1654                   * so these length should be 0 as documented. */
   1655                  if (iv_len != 0 || tag_len != 0 || ad_len != 0) {
   \                     ??mbedtls_cipher_auth_decrypt_ext_2: (+1)
   \       0x4A   0x4329             ORRS     R1,R5,R1
   \       0x4C   0xEA5A 0x0101      ORRS     R1,R10,R1
   \       0x50   0xD002             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_3
   1656                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x52   0xE05D             B.N      ??mbedtls_cipher_auth_decrypt_ext_4
   1657                  }
   \                     ??mbedtls_cipher_auth_decrypt_ext_1: (+1)
   \       0x54   0x2400             MOVS     R4,#+0
   \       0x56   0xE7F8             B.N      ??mbedtls_cipher_auth_decrypt_ext_2
   1658          
   1659                  (void) iv;
   1660                  (void) ad;
   1661          
   1662                  return mbedtls_nist_kw_unwrap(ctx->cipher_ctx, mode, input, ilen,
   1663                                                output, olen, output_len);
   \                     ??mbedtls_cipher_auth_decrypt_ext_3: (+1)
   \       0x58   0xF8CD 0xB008      STR      R11,[SP, #+8]
   \       0x5C   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x60   0xF8CD 0xE000      STR      LR,[SP, #+0]
   \       0x64   0x6BF8             LDR      R0,[R7, #+60]
   \       0x66   0x4621             MOV      R1,R4
   \       0x68   0x.... 0x....      BL       mbedtls_nist_kw_unwrap
   \       0x6C   0xE050             B.N      ??mbedtls_cipher_auth_decrypt_ext_4
   1664              }
   1665          #endif /* MBEDTLS_NIST_KW_C */
   1666          
   1667          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
   1668              /* AEAD case: check length before passing on to shared function */
   1669              if (ilen < tag_len || output_len < ilen - tag_len) {
   \                     ??mbedtls_cipher_auth_decrypt_ext_0: (+1)
   \       0x6E   0x42AB             CMP      R3,R5
   \       0x70   0xBF24             ITT      CS
   \       0x72   0xEBA3 0x0905      SUBCS    R9,R3,R5
   \       0x76   0x45CB             CMPCS    R11,R9
   \       0x78   0xD34A             BCC.N    ??mbedtls_cipher_auth_decrypt_ext_4
   1670                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   1671              }
   1672          
   1673              return mbedtls_cipher_aead_decrypt(ctx, iv, iv_len, ad, ad_len,
   1674                                                 input, ilen - tag_len, output, olen,
   1675                                                 input + ilen - tag_len, tag_len);
   \       0x7A   0x4413             ADD      R3,R2,R3
   \       0x7C   0x4268             RSBS     R0,R5,#+0
   \       0x7E   0x4403             ADD      R3,R3,R0
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0xF89D 0x4000      LDRB     R4,[SP, #+0]
   \       0x86   0x.... 0x....      LDR.W    R11,??DataTable17_13
   \       0x8A   0x2C01             CMP      R4,#+1
   \       0x8C   0xD122             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_5
   \       0x8E   0x6BFC             LDR      R4,[R7, #+60]
   \       0x90   0x2A00             CMP      R2,#+0
   \       0x92   0xD03C             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_6
   \       0x94   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x98   0xF8CD 0x9014      STR      R9,[SP, #+20]
   \       0x9C   0xF8CD 0xE010      STR      LR,[SP, #+16]
   \       0xA0   0x444D             ADD      R5,R5,R9
   \       0xA2   0x9503             STR      R5,[SP, #+12]
   \       0xA4   0x9202             STR      R2,[SP, #+8]
   \       0xA6   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0xAA   0xF8CD 0xC000      STR      R12,[SP, #+0]
   \       0xAE   0x460B             MOV      R3,R1
   \       0xB0   0x4602             MOV      R2,R0
   \       0xB2   0x6821             LDR      R1,[R4, #+0]
   \       0xB4   0x6860             LDR      R0,[R4, #+4]
   \       0xB6   0x.... 0x....      BL       psa_aead_decrypt
   \       0xBA   0xF110 0x0F95      CMN      R0,#+149
   \       0xBE   0xD024             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_7
   \       0xC0   0xF110 0x0F86      CMN      R0,#+134
   \       0xC4   0xBF08             IT       EQ
   \       0xC6   0xF06F 0x0071      MVNEQ    R0,#+113
   \       0xCA   0xD021             BEQ.N    ??mbedtls_cipher_auth_decrypt_ext_4
   \       0xCC   0xB300             CBZ.N    R0,??mbedtls_cipher_auth_decrypt_ext_4
   \       0xCE   0xF06F 0x006F      MVN      R0,#+111
   \       0xD2   0xE01D             B.N      ??mbedtls_cipher_auth_decrypt_ext_4
   \                     ??mbedtls_cipher_auth_decrypt_ext_5: (+1)
   \       0xD4   0x683E             LDR      R6,[R7, #+0]
   \       0xD6   0x6874             LDR      R4,[R6, #+4]
   \       0xD8   0x0B24             LSRS     R4,R4,#+12
   \       0xDA   0xF004 0x040F      AND      R4,R4,#0xF
   \       0xDE   0x2C08             CMP      R4,#+8
   \       0xE0   0xD115             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_6
   \       0xE2   0xF8C8 0x9000      STR      R9,[R8, #+0]
   \       0xE6   0x9505             STR      R5,[SP, #+20]
   \       0xE8   0x9202             STR      R2,[SP, #+8]
   \       0xEA   0xF8CD 0xE00C      STR      LR,[SP, #+12]
   \       0xEE   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0xF2   0xF8CD 0xC000      STR      R12,[SP, #+0]
   \       0xF6   0x4602             MOV      R2,R0
   \       0xF8   0x9304             STR      R3,[SP, #+16]
   \       0xFA   0x6BF8             LDR      R0,[R7, #+60]
   \       0xFC   0x460B             MOV      R3,R1
   \       0xFE   0x4649             MOV      R1,R9
   \      0x100   0x.... 0x....      BL       mbedtls_ccm_auth_decrypt
   \      0x104   0xF110 0x0F0F      CMN      R0,#+15
   \      0x108   0xD102             BNE.N    ??mbedtls_cipher_auth_decrypt_ext_4
   \                     ??mbedtls_cipher_auth_decrypt_ext_7: (+1)
   \      0x10A   0x4658             MOV      R0,R11
   \      0x10C   0xE000             B.N      ??mbedtls_cipher_auth_decrypt_ext_4
   \                     ??mbedtls_cipher_auth_decrypt_ext_6: (+1)
   \      0x10E   0x....             LDR.N    R0,??DataTable17_9
   \                     ??mbedtls_cipher_auth_decrypt_ext_4: (+1)
   \      0x110                      REQUIRE ?Subroutine1
   \      0x110                      ;; // Fall through to label ?Subroutine1
   1676          #else
   1677              return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   1678          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
   1679          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     mbedtls_cipher_base_lookup_table

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     supported_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     mbedtls_cipher_supported

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x....'....        DC32     mbedtls_cipher_definitions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0xFFFF'9F00        DC32     0xffff9f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \        0x0   0xFFFF'9E80        DC32     0xffff9e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \        0x0   0x0440'4400        DC32     0x4404400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \        0x0   0xFFFF'9F80        DC32     0xffff9f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \        0x0   0xFFFF'9C80        DC32     0xffff9c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \        0x0   0xFFFF'9D80        DC32     0xffff9d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \        0x0   0x....'....        DC32     get_no_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \        0x0   0xFFFF'9D00        DC32     0xffff9d00
   1680          #endif /* MBEDTLS_CIPHER_MODE_AEAD || MBEDTLS_NIST_KW_C */
   1681          
   1682          #endif /* MBEDTLS_CIPHER_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   get_no_padding
      64   mbedtls_cipher_auth_decrypt_ext
        64   -> mbedtls_ccm_auth_decrypt
        64   -> mbedtls_nist_kw_unwrap
        64   -> psa_aead_decrypt
      64   mbedtls_cipher_auth_encrypt_ext
        64   -> mbedtls_ccm_encrypt_and_tag
        64   -> mbedtls_nist_kw_wrap
        64   -> psa_aead_encrypt
     208   mbedtls_cipher_crypt
       208   -> __aeabi_memclr4
       208   -> mbedtls_cipher_finish
       208   -> mbedtls_cipher_reset
       208   -> mbedtls_cipher_set_iv
       208   -> mbedtls_cipher_update
       208   -> psa_cipher_decrypt_setup
       208   -> psa_cipher_encrypt_setup
       208   -> psa_cipher_finish
       208   -> psa_cipher_set_iv
       208   -> psa_cipher_update
      32   mbedtls_cipher_finish
         0   -- Indirect call
        32   -- Indirect call
        32   -> mbedtls_cipher_get_base
        32   -> mbedtls_cipher_get_block_size
      16   mbedtls_cipher_free
        16   -- Indirect call
        16   -> mbedtls_cipher_get_base
         0   -> mbedtls_platform_zeroize
        16   -> mbedtls_zeroize_and_free
        16   -> psa_destroy_key
       0   mbedtls_cipher_get_base
       0   mbedtls_cipher_get_block_size
      16   mbedtls_cipher_info_from_string
        16   -> strcmp
       0   mbedtls_cipher_info_from_type
      24   mbedtls_cipher_info_from_values
        24   -> mbedtls_cipher_get_base
        24   -> mbedtls_cipher_info_get_key_bitlen
       0   mbedtls_cipher_info_get_key_bitlen
       0   mbedtls_cipher_init
         0   -> __aeabi_memclr4
      12   mbedtls_cipher_list
       0   mbedtls_cipher_reset
      24   mbedtls_cipher_set_iv
        24   -> __aeabi_memcpy
        24   -> mbedtls_ccm_set_lengths
         0   -> mbedtls_ccm_starts
       0   mbedtls_cipher_set_padding_mode
      72   mbedtls_cipher_setkey
        72   -- Indirect call
        72   -> __aeabi_memclr4
        72   -> mbedtls_cipher_get_base
        72   -> mbedtls_cipher_info_get_key_bitlen
        72   -> psa_import_key
        72   -> psa_set_key_domain_parameters
      16   mbedtls_cipher_setup
        16   -- Indirect call
        16   -> __aeabi_memclr4
        16   -> mbedtls_cipher_get_base
      16   mbedtls_cipher_setup_psa
        16   -> __aeabi_memclr4
        16   -> sl_calloc
      40   mbedtls_cipher_update
        40   -- Indirect call
        40   -> __aeabi_memcpy
        40   -> mbedtls_ccm_update
        40   -> mbedtls_cipher_get_base
        40   -> mbedtls_cipher_get_block_size


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       6  ?Subroutine0
       6  ?Subroutine1
      36  ?_0
     152  ?_1
      16  get_no_padding
     272  mbedtls_cipher_auth_decrypt_ext
     264  mbedtls_cipher_auth_encrypt_ext
     228  mbedtls_cipher_crypt
     280  mbedtls_cipher_finish
      70  mbedtls_cipher_free
      16  mbedtls_cipher_get_base
      12  mbedtls_cipher_get_block_size
      38  mbedtls_cipher_info_from_string
      24  mbedtls_cipher_info_from_type
      56  mbedtls_cipher_info_from_values
      12  mbedtls_cipher_info_get_key_bitlen
       6  mbedtls_cipher_init
      50  mbedtls_cipher_list
      28  mbedtls_cipher_reset
     134  mbedtls_cipher_set_iv
      58  mbedtls_cipher_set_padding_mode
     288  mbedtls_cipher_setkey
      46  mbedtls_cipher_setup
     158  mbedtls_cipher_setup_psa
     414  mbedtls_cipher_update
       4  supported_init

 
     4 bytes in section .bss
   188 bytes in section .rodata
 2'538 bytes in section .text
 
 2'538 bytes of CODE  memory
   188 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
