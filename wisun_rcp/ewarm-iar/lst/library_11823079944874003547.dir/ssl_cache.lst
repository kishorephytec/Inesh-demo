###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:44
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_cache.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_cache.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_cache.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_cache.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ssl_cache.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_cache.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_cache.c
      1          /*
      2           *  SSL session cache implementation
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           * These session callbacks use a simple chained list
     21           * to store and retrieve the session information.
     22           */
     23          
     24          #include "common.h"
     25          
     26          #if defined(MBEDTLS_SSL_CACHE_C)
     27          
     28          #include "mbedtls/platform.h"
     29          
     30          #include "mbedtls/ssl_cache.h"
     31          #include "ssl_misc.h"
     32          #include "mbedtls/error.h"
     33          
     34          #include <string.h>
     35          
     36          void mbedtls_ssl_cache_init(mbedtls_ssl_cache_context *cache)
     37          {
     38              memset(cache, 0, sizeof(mbedtls_ssl_cache_context));
     39          
     40              cache->timeout = MBEDTLS_SSL_CACHE_DEFAULT_TIMEOUT;
     41              cache->max_entries = MBEDTLS_SSL_CACHE_DEFAULT_MAX_ENTRIES;
     42          
     43          #if defined(MBEDTLS_THREADING_C)
     44              mbedtls_mutex_init(&cache->mutex);
     45          #endif
     46          }
     47          
     48          MBEDTLS_CHECK_RETURN_CRITICAL
     49          static int ssl_cache_find_entry(mbedtls_ssl_cache_context *cache,
     50                                          unsigned char const *session_id,
     51                                          size_t session_id_len,
     52                                          mbedtls_ssl_cache_entry **dst)
     53          {
     54              int ret = MBEDTLS_ERR_SSL_CACHE_ENTRY_NOT_FOUND;
     55          #if defined(MBEDTLS_HAVE_TIME)
     56              mbedtls_time_t t = mbedtls_time(NULL);
     57          #endif
     58              mbedtls_ssl_cache_entry *cur;
     59          
     60              for (cur = cache->chain; cur != NULL; cur = cur->next) {
     61          #if defined(MBEDTLS_HAVE_TIME)
     62                  if (cache->timeout != 0 &&
     63                      (int) (t - cur->timestamp) > cache->timeout) {
     64                      continue;
     65                  }
     66          #endif
     67          
     68                  if (session_id_len != cur->session_id_len ||
     69                      memcmp(session_id, cur->session_id,
     70                             cur->session_id_len) != 0) {
     71                      continue;
     72                  }
     73          
     74                  break;
     75              }
     76          
     77              if (cur != NULL) {
     78                  *dst = cur;
     79                  ret = 0;
     80              }
     81          
     82              return ret;
     83          }
     84          
     85          
     86          int mbedtls_ssl_cache_get(void *data,
     87                                    unsigned char const *session_id,
     88                                    size_t session_id_len,
     89                                    mbedtls_ssl_session *session)
     90          {
     91              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     92              mbedtls_ssl_cache_context *cache = (mbedtls_ssl_cache_context *) data;
     93              mbedtls_ssl_cache_entry *entry;
     94          
     95          #if defined(MBEDTLS_THREADING_C)
     96              if ((ret = mbedtls_mutex_lock(&cache->mutex)) != 0) {
     97                  return ret;
     98              }
     99          #endif
    100          
    101              ret = ssl_cache_find_entry(cache, session_id, session_id_len, &entry);
    102              if (ret != 0) {
    103                  goto exit;
    104              }
    105          
    106              ret = mbedtls_ssl_session_load(session,
    107                                             entry->session,
    108                                             entry->session_len);
    109              if (ret != 0) {
    110                  goto exit;
    111              }
    112          
    113              ret = 0;
    114          
    115          exit:
    116          #if defined(MBEDTLS_THREADING_C)
    117              if (mbedtls_mutex_unlock(&cache->mutex) != 0) {
    118                  ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
    119              }
    120          #endif
    121          
    122              return ret;
    123          }
    124          
    125          /* zeroize a cache entry */
    126          static void ssl_cache_entry_zeroize(mbedtls_ssl_cache_entry *entry)
    127          {
    128              if (entry == NULL) {
    129                  return;
    130              }
    131          
    132              /* zeroize and free session structure */
    133              if (entry->session != NULL) {
    134                  mbedtls_zeroize_and_free(entry->session, entry->session_len);
    135              }
    136          
    137              /* zeroize the whole entry structure */
    138              mbedtls_platform_zeroize(entry, sizeof(mbedtls_ssl_cache_entry));
    139          }
    140          
    141          MBEDTLS_CHECK_RETURN_CRITICAL
    142          static int ssl_cache_pick_writing_slot(mbedtls_ssl_cache_context *cache,
    143                                                 unsigned char const *session_id,
    144                                                 size_t session_id_len,
    145                                                 mbedtls_ssl_cache_entry **dst)
    146          {
    147          #if defined(MBEDTLS_HAVE_TIME)
    148              mbedtls_time_t t = mbedtls_time(NULL), oldest = 0;
    149          #endif /* MBEDTLS_HAVE_TIME */
    150          
    151              mbedtls_ssl_cache_entry *old = NULL;
    152              int count = 0;
    153              mbedtls_ssl_cache_entry *cur, *last;
    154          
    155              /* Check 1: Is there already an entry with the given session ID?
    156               *
    157               * If yes, overwrite it.
    158               *
    159               * If not, `count` will hold the size of the session cache
    160               * at the end of this loop, and `last` will point to the last
    161               * entry, both of which will be used later. */
    162          
    163              last = NULL;
    164              for (cur = cache->chain; cur != NULL; cur = cur->next) {
    165                  count++;
    166                  if (session_id_len == cur->session_id_len &&
    167                      memcmp(session_id, cur->session_id, cur->session_id_len) == 0) {
    168                      goto found;
    169                  }
    170                  last = cur;
    171              }
    172          
    173              /* Check 2: Is there an outdated entry in the cache?
    174               *
    175               * If so, overwrite it.
    176               *
    177               * If not, remember the oldest entry in `old` for later.
    178               */
    179          
    180          #if defined(MBEDTLS_HAVE_TIME)
    181              for (cur = cache->chain; cur != NULL; cur = cur->next) {
    182                  if (cache->timeout != 0 &&
    183                      (int) (t - cur->timestamp) > cache->timeout) {
    184                      goto found;
    185                  }
    186          
    187                  if (oldest == 0 || cur->timestamp < oldest) {
    188                      oldest = cur->timestamp;
    189                      old = cur;
    190                  }
    191              }
    192          #endif /* MBEDTLS_HAVE_TIME */
    193          
    194              /* Check 3: Is there free space in the cache? */
    195          
    196              if (count < cache->max_entries) {
    197                  /* Create new entry */
    198                  cur = mbedtls_calloc(1, sizeof(mbedtls_ssl_cache_entry));
    199                  if (cur == NULL) {
    200                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
    201                  }
    202          
    203                  /* Append to the end of the linked list. */
    204                  if (last == NULL) {
    205                      cache->chain = cur;
    206                  } else {
    207                      last->next = cur;
    208                  }
    209          
    210                  goto found;
    211              }
    212          
    213              /* Last resort: The cache is full and doesn't contain any outdated
    214               * elements. In this case, we evict the oldest one, judged by timestamp
    215               * (if present) or cache-order. */
    216          
    217          #if defined(MBEDTLS_HAVE_TIME)
    218              if (old == NULL) {
    219                  /* This should only happen on an ill-configured cache
    220                   * with max_entries == 0. */
    221                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
    222              }
    223          #else /* MBEDTLS_HAVE_TIME */
    224              /* Reuse first entry in chain, but move to last place. */
    225              if (cache->chain == NULL) {
    226                  /* This should never happen */
    227                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    228              }
    229          
    230              old = cache->chain;
    231              cache->chain = old->next;
    232              old->next = NULL;
    233              last->next = old;
    234          #endif /* MBEDTLS_HAVE_TIME */
    235          
    236              /* Now `old` points to the oldest entry to be overwritten. */
    237              cur = old;
    238          
    239          found:
    240          
    241              /* If we're reusing an entry, free it first. */
    242              if (cur->session != NULL) {
    243                  /* `ssl_cache_entry_zeroize` would break the chain,
    244                   * so we reuse `old` to record `next` temporarily. */
    245                  old = cur->next;
    246                  ssl_cache_entry_zeroize(cur);
    247                  cur->next = old;
    248              }
    249          
    250          #if defined(MBEDTLS_HAVE_TIME)
    251              cur->timestamp = t;
    252          #endif
    253          
    254              *dst = cur;
    255              return 0;
    256          }
    257          
    258          int mbedtls_ssl_cache_set(void *data,
    259                                    unsigned char const *session_id,
    260                                    size_t session_id_len,
    261                                    const mbedtls_ssl_session *session)
    262          {
    263              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    264              mbedtls_ssl_cache_context *cache = (mbedtls_ssl_cache_context *) data;
    265              mbedtls_ssl_cache_entry *cur;
    266          
    267              size_t session_serialized_len = 0;
    268              unsigned char *session_serialized = NULL;
    269          
    270          #if defined(MBEDTLS_THREADING_C)
    271              if ((ret = mbedtls_mutex_lock(&cache->mutex)) != 0) {
    272                  return ret;
    273              }
    274          #endif
    275          
    276              ret = ssl_cache_pick_writing_slot(cache,
    277                                                session_id, session_id_len,
    278                                                &cur);
    279              if (ret != 0) {
    280                  goto exit;
    281              }
    282          
    283              /* Check how much space we need to serialize the session
    284               * and allocate a sufficiently large buffer. */
    285              ret = mbedtls_ssl_session_save(session, NULL, 0, &session_serialized_len);
    286              if (ret != MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) {
    287                  goto exit;
    288              }
    289          
    290              session_serialized = mbedtls_calloc(1, session_serialized_len);
    291              if (session_serialized == NULL) {
    292                  ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
    293                  goto exit;
    294              }
    295          
    296              /* Now serialize the session into the allocated buffer. */
    297              ret = mbedtls_ssl_session_save(session,
    298                                             session_serialized,
    299                                             session_serialized_len,
    300                                             &session_serialized_len);
    301              if (ret != 0) {
    302                  goto exit;
    303              }
    304          
    305              if (session_id_len > sizeof(cur->session_id)) {
    306                  ret = MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    307                  goto exit;
    308              }
    309              cur->session_id_len = session_id_len;
    310              memcpy(cur->session_id, session_id, session_id_len);
    311          
    312              cur->session = session_serialized;
    313              cur->session_len = session_serialized_len;
    314              session_serialized = NULL;
    315          
    316              ret = 0;
    317          
    318          exit:
    319          #if defined(MBEDTLS_THREADING_C)
    320              if (mbedtls_mutex_unlock(&cache->mutex) != 0) {
    321                  ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
    322              }
    323          #endif
    324          
    325              if (session_serialized != NULL) {
    326                  mbedtls_zeroize_and_free(session_serialized, session_serialized_len);
    327                  session_serialized = NULL;
    328              }
    329          
    330              return ret;
    331          }
    332          
    333          int mbedtls_ssl_cache_remove(void *data,
    334                                       unsigned char const *session_id,
    335                                       size_t session_id_len)
    336          {
    337              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    338              mbedtls_ssl_cache_context *cache = (mbedtls_ssl_cache_context *) data;
    339              mbedtls_ssl_cache_entry *entry;
    340              mbedtls_ssl_cache_entry *prev;
    341          
    342          #if defined(MBEDTLS_THREADING_C)
    343              if ((ret = mbedtls_mutex_lock(&cache->mutex)) != 0) {
    344                  return ret;
    345              }
    346          #endif
    347          
    348              ret = ssl_cache_find_entry(cache, session_id, session_id_len, &entry);
    349              /* No valid entry found, exit with success */
    350              if (ret != 0) {
    351                  ret = 0;
    352                  goto exit;
    353              }
    354          
    355              /* Now we remove the entry from the chain */
    356              if (entry == cache->chain) {
    357                  cache->chain = entry->next;
    358                  goto free;
    359              }
    360              for (prev = cache->chain; prev->next != NULL; prev = prev->next) {
    361                  if (prev->next == entry) {
    362                      prev->next = entry->next;
    363                      break;
    364                  }
    365              }
    366          
    367          free:
    368              ssl_cache_entry_zeroize(entry);
    369              mbedtls_free(entry);
    370              ret = 0;
    371          
    372          exit:
    373          #if defined(MBEDTLS_THREADING_C)
    374              if (mbedtls_mutex_unlock(&cache->mutex) != 0) {
    375                  ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
    376              }
    377          #endif
    378          
    379              return ret;
    380          }
    381          
    382          #if defined(MBEDTLS_HAVE_TIME)
    383          void mbedtls_ssl_cache_set_timeout(mbedtls_ssl_cache_context *cache, int timeout)
    384          {
    385              if (timeout < 0) {
    386                  timeout = 0;
    387              }
    388          
    389              cache->timeout = timeout;
    390          }
    391          #endif /* MBEDTLS_HAVE_TIME */
    392          
    393          void mbedtls_ssl_cache_set_max_entries(mbedtls_ssl_cache_context *cache, int max)
    394          {
    395              if (max < 0) {
    396                  max = 0;
    397              }
    398          
    399              cache->max_entries = max;
    400          }
    401          
    402          void mbedtls_ssl_cache_free(mbedtls_ssl_cache_context *cache)
    403          {
    404              mbedtls_ssl_cache_entry *cur, *prv;
    405          
    406              cur = cache->chain;
    407          
    408              while (cur != NULL) {
    409                  prv = cur;
    410                  cur = cur->next;
    411          
    412                  ssl_cache_entry_zeroize(prv);
    413                  mbedtls_free(prv);
    414              }
    415          
    416          #if defined(MBEDTLS_THREADING_C)
    417              mbedtls_mutex_free(&cache->mutex);
    418          #endif
    419              cache->chain = NULL;
    420          }
    421          
    422          #endif /* MBEDTLS_SSL_CACHE_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
