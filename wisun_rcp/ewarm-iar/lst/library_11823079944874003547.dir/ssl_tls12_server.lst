###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:47
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls12_server.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls12_server.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls12_server.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls12_server.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ssl_tls12_server.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls12_server.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls12_server.c
      1          /*
      2           *  TLS server-side functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_PROTO_TLS1_2)
     23          
     24          #include "mbedtls/platform.h"
     25          
     26          #include "mbedtls/ssl.h"
     27          #include "ssl_misc.h"
     28          #include "mbedtls/debug.h"
     29          #include "mbedtls/error.h"
     30          #include "mbedtls/platform_util.h"
     31          #include "constant_time_internal.h"
     32          #include "mbedtls/constant_time.h"
     33          
     34          #include <string.h>
     35          
     36          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     37          /* Define a local translating function to save code size by not using too many
     38           * arguments in each translating place. */
     39          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_ENABLED) || \
     40              defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDHE_ENABLED)
     41          static int local_err_translation(psa_status_t status)
     42          {
     43              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     44                                           ARRAY_LENGTH(psa_to_ssl_errors),
     45                                           psa_generic_status_to_mbedtls);
     46          }
     47          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     48          #endif
     49          #endif
     50          
     51          #if defined(MBEDTLS_ECP_C)
     52          #include "mbedtls/ecp.h"
     53          #endif
     54          
     55          #if defined(MBEDTLS_HAVE_TIME)
     56          #include "mbedtls/platform_time.h"
     57          #endif
     58          
     59          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
     60          int mbedtls_ssl_set_client_transport_id(mbedtls_ssl_context *ssl,
     61                                                  const unsigned char *info,
     62                                                  size_t ilen)
     63          {
     64              if (ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER) {
     65                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
     66              }
     67          
     68              mbedtls_free(ssl->cli_id);
     69          
     70              if ((ssl->cli_id = mbedtls_calloc(1, ilen)) == NULL) {
     71                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
     72              }
     73          
     74              memcpy(ssl->cli_id, info, ilen);
     75              ssl->cli_id_len = ilen;
     76          
     77              return 0;
     78          }
     79          
     80          void mbedtls_ssl_conf_dtls_cookies(mbedtls_ssl_config *conf,
     81                                             mbedtls_ssl_cookie_write_t *f_cookie_write,
     82                                             mbedtls_ssl_cookie_check_t *f_cookie_check,
     83                                             void *p_cookie)
     84          {
     85              conf->f_cookie_write = f_cookie_write;
     86              conf->f_cookie_check = f_cookie_check;
     87              conf->p_cookie       = p_cookie;
     88          }
     89          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
     90          
     91          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
     92          MBEDTLS_CHECK_RETURN_CRITICAL
     93          static int ssl_conf_has_psk_or_cb(mbedtls_ssl_config const *conf)
     94          {
     95              if (conf->f_psk != NULL) {
     96                  return 1;
     97              }
     98          
     99              if (conf->psk_identity_len == 0 || conf->psk_identity == NULL) {
    100                  return 0;
    101              }
    102          
    103          
    104          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    105              if (!mbedtls_svc_key_id_is_null(conf->psk_opaque)) {
    106                  return 1;
    107              }
    108          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    109          
    110              if (conf->psk != NULL && conf->psk_len != 0) {
    111                  return 1;
    112              }
    113          
    114              return 0;
    115          }
    116          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
    117          
    118          MBEDTLS_CHECK_RETURN_CRITICAL
    119          static int ssl_parse_renegotiation_info(mbedtls_ssl_context *ssl,
    120                                                  const unsigned char *buf,
    121                                                  size_t len)
    122          {
    123          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    124              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
    125                  /* Check verify-data in constant-time. The length OTOH is no secret */
    126                  if (len    != 1 + ssl->verify_data_len ||
    127                      buf[0] !=     ssl->verify_data_len ||
    128                      mbedtls_ct_memcmp(buf + 1, ssl->peer_verify_data,
    129                                        ssl->verify_data_len) != 0) {
    130                      MBEDTLS_SSL_DEBUG_MSG(1, ("non-matching renegotiation info"));
    131                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    132                                                     MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    133                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    134                  }
    135              } else
    136          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    137              {
    138                  if (len != 1 || buf[0] != 0x0) {
    139                      MBEDTLS_SSL_DEBUG_MSG(1, ("non-zero length renegotiation info"));
    140                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    141                                                     MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    142                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
    143                  }
    144          
    145                  ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
    146              }
    147          
    148              return 0;
    149          }
    150          
    151          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    152              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
    153              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    154          /*
    155           * Function for parsing a supported groups (TLS 1.3) or supported elliptic
    156           * curves (TLS 1.2) extension.
    157           *
    158           * The "extension_data" field of a supported groups extension contains a
    159           * "NamedGroupList" value (TLS 1.3 RFC8446):
    160           *      enum {
    161           *          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    162           *          x25519(0x001D), x448(0x001E),
    163           *          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    164           *          ffdhe6144(0x0103), ffdhe8192(0x0104),
    165           *          ffdhe_private_use(0x01FC..0x01FF),
    166           *          ecdhe_private_use(0xFE00..0xFEFF),
    167           *          (0xFFFF)
    168           *      } NamedGroup;
    169           *      struct {
    170           *          NamedGroup named_group_list<2..2^16-1>;
    171           *      } NamedGroupList;
    172           *
    173           * The "extension_data" field of a supported elliptic curves extension contains
    174           * a "NamedCurveList" value (TLS 1.2 RFC 8422):
    175           * enum {
    176           *      deprecated(1..22),
    177           *      secp256r1 (23), secp384r1 (24), secp521r1 (25),
    178           *      x25519(29), x448(30),
    179           *      reserved (0xFE00..0xFEFF),
    180           *      deprecated(0xFF01..0xFF02),
    181           *      (0xFFFF)
    182           *  } NamedCurve;
    183           * struct {
    184           *      NamedCurve named_curve_list<2..2^16-1>
    185           *  } NamedCurveList;
    186           *
    187           * The TLS 1.3 supported groups extension was defined to be a compatible
    188           * generalization of the TLS 1.2 supported elliptic curves extension. They both
    189           * share the same extension identifier.
    190           *
    191           */
    192          MBEDTLS_CHECK_RETURN_CRITICAL
    193          static int ssl_parse_supported_groups_ext(mbedtls_ssl_context *ssl,
    194                                                    const unsigned char *buf,
    195                                                    size_t len)
    196          {
    197              size_t list_size, our_size;
    198              const unsigned char *p;
    199              uint16_t *curves_tls_id;
    200          
    201              if (len < 2) {
    202                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    203                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    204                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    205                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    206              }
    207              list_size = ((buf[0] << 8) | (buf[1]));
    208              if (list_size + 2 != len ||
    209                  list_size % 2 != 0) {
    210                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    211                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    212                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    213                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    214              }
    215          
    216              /* Should never happen unless client duplicates the extension */
    217              if (ssl->handshake->curves_tls_id != NULL) {
    218                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    219                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    220                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    221                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    222              }
    223          
    224              /* Don't allow our peer to make us allocate too much memory,
    225               * and leave room for a final 0 */
    226              our_size = list_size / 2 + 1;
    227              if (our_size > MBEDTLS_ECP_DP_MAX) {
    228                  our_size = MBEDTLS_ECP_DP_MAX;
    229              }
    230          
    231              if ((curves_tls_id = mbedtls_calloc(our_size,
    232                                                  sizeof(*curves_tls_id))) == NULL) {
    233                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    234                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
    235                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
    236              }
    237          
    238              ssl->handshake->curves_tls_id = curves_tls_id;
    239          
    240              p = buf + 2;
    241              while (list_size > 0 && our_size > 1) {
    242                  uint16_t curr_tls_id = MBEDTLS_GET_UINT16_BE(p, 0);
    243          
    244                  if (mbedtls_ssl_get_ecp_group_id_from_tls_id(curr_tls_id) !=
    245                      MBEDTLS_ECP_DP_NONE) {
    246                      *curves_tls_id++ = curr_tls_id;
    247                      our_size--;
    248                  }
    249          
    250                  list_size -= 2;
    251                  p += 2;
    252              }
    253          
    254              return 0;
    255          }
    256          
    257          MBEDTLS_CHECK_RETURN_CRITICAL
    258          static int ssl_parse_supported_point_formats(mbedtls_ssl_context *ssl,
    259                                                       const unsigned char *buf,
    260                                                       size_t len)
    261          {
    262              size_t list_size;
    263              const unsigned char *p;
    264          
    265              if (len == 0 || (size_t) (buf[0] + 1) != len) {
    266                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    267                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    268                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    269                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    270              }
    271              list_size = buf[0];
    272          
    273              p = buf + 1;
    274              while (list_size > 0) {
    275                  if (p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
    276                      p[0] == MBEDTLS_ECP_PF_COMPRESSED) {
    277          #if !defined(MBEDTLS_USE_PSA_CRYPTO) && \
    278                      defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED)
    279                      ssl->handshake->ecdh_ctx.point_format = p[0];
    280          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED */
    281          #if !defined(MBEDTLS_USE_PSA_CRYPTO) &&                             \
    282                      defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    283                      mbedtls_ecjpake_set_point_format(&ssl->handshake->ecjpake_ctx,
    284                                                       p[0]);
    285          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    286                      MBEDTLS_SSL_DEBUG_MSG(4, ("point format selected: %d", p[0]));
    287                      return 0;
    288                  }
    289          
    290                  list_size--;
    291                  p++;
    292              }
    293          
    294              return 0;
    295          }
    296          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
    297                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
    298                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    299          
    300          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    301          MBEDTLS_CHECK_RETURN_CRITICAL
    302          static int ssl_parse_ecjpake_kkpp(mbedtls_ssl_context *ssl,
    303                                            const unsigned char *buf,
    304                                            size_t len)
    305          {
    306              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    307          
    308          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    309              if (ssl->handshake->psa_pake_ctx_is_ok != 1)
    310          #else
    311              if (mbedtls_ecjpake_check(&ssl->handshake->ecjpake_ctx) != 0)
    312          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    313              {
    314                  MBEDTLS_SSL_DEBUG_MSG(3, ("skip ecjpake kkpp extension"));
    315                  return 0;
    316              }
    317          
    318          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    319              if ((ret = mbedtls_psa_ecjpake_read_round(
    320                       &ssl->handshake->psa_pake_ctx, buf, len,
    321                       MBEDTLS_ECJPAKE_ROUND_ONE)) != 0) {
    322                  psa_destroy_key(ssl->handshake->psa_pake_password);
    323                  psa_pake_abort(&ssl->handshake->psa_pake_ctx);
    324          
    325                  MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_input round one", ret);
    326                  mbedtls_ssl_send_alert_message(
    327                      ssl,
    328                      MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    329                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
    330          
    331                  return ret;
    332              }
    333          #else
    334              if ((ret = mbedtls_ecjpake_read_round_one(&ssl->handshake->ecjpake_ctx,
    335                                                        buf, len)) != 0) {
    336                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_read_round_one", ret);
    337                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    338                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    339                  return ret;
    340              }
    341          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    342          
    343              /* Only mark the extension as OK when we're sure it is */
    344              ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;
    345          
    346              return 0;
    347          }
    348          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    349          
    350          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    351          MBEDTLS_CHECK_RETURN_CRITICAL
    352          static int ssl_parse_max_fragment_length_ext(mbedtls_ssl_context *ssl,
    353                                                       const unsigned char *buf,
    354                                                       size_t len)
    355          {
    356              if (len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID) {
    357                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    358                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    359                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    360                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    361              }
    362          
    363              ssl->session_negotiate->mfl_code = buf[0];
    364          
    365              return 0;
    366          }
    367          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    368          
    369          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
    370          MBEDTLS_CHECK_RETURN_CRITICAL
    371          static int ssl_parse_cid_ext(mbedtls_ssl_context *ssl,
    372                                       const unsigned char *buf,
    373                                       size_t len)
    374          {
    375              size_t peer_cid_len;
    376          
    377              /* CID extension only makes sense in DTLS */
    378              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
    379                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    380                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    381                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    382                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    383              }
    384          
    385              /*
    386               *   struct {
    387               *      opaque cid<0..2^8-1>;
    388               *   } ConnectionId;
    389               */
    390          
    391              if (len < 1) {
    392                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    393                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    394                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    395                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    396              }
    397          
    398              peer_cid_len = *buf++;
    399              len--;
    400          
    401              if (len != peer_cid_len) {
    402                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    403                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    404                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    405                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    406              }
    407          
    408              /* Ignore CID if the user has disabled its use. */
    409              if (ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED) {
    410                  /* Leave ssl->handshake->cid_in_use in its default
    411                   * value of MBEDTLS_SSL_CID_DISABLED. */
    412                  MBEDTLS_SSL_DEBUG_MSG(3, ("Client sent CID extension, but CID disabled"));
    413                  return 0;
    414              }
    415          
    416              if (peer_cid_len > MBEDTLS_SSL_CID_OUT_LEN_MAX) {
    417                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    418                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    419                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER);
    420                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    421              }
    422          
    423              ssl->handshake->cid_in_use = MBEDTLS_SSL_CID_ENABLED;
    424              ssl->handshake->peer_cid_len = (uint8_t) peer_cid_len;
    425              memcpy(ssl->handshake->peer_cid, buf, peer_cid_len);
    426          
    427              MBEDTLS_SSL_DEBUG_MSG(3, ("Use of CID extension negotiated"));
    428              MBEDTLS_SSL_DEBUG_BUF(3, "Client CID", buf, peer_cid_len);
    429          
    430              return 0;
    431          }
    432          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    433          
    434          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    435          MBEDTLS_CHECK_RETURN_CRITICAL
    436          static int ssl_parse_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
    437                                                    const unsigned char *buf,
    438                                                    size_t len)
    439          {
    440              if (len != 0) {
    441                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    442                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    443                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    444                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    445              }
    446          
    447              ((void) buf);
    448          
    449              if (ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED) {
    450                  ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
    451              }
    452          
    453              return 0;
    454          }
    455          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    456          
    457          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    458          MBEDTLS_CHECK_RETURN_CRITICAL
    459          static int ssl_parse_extended_ms_ext(mbedtls_ssl_context *ssl,
    460                                               const unsigned char *buf,
    461                                               size_t len)
    462          {
    463              if (len != 0) {
    464                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    465                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    466                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    467                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    468              }
    469          
    470              ((void) buf);
    471          
    472              if (ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED) {
    473                  ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
    474              }
    475          
    476              return 0;
    477          }
    478          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    479          
    480          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    481          MBEDTLS_CHECK_RETURN_CRITICAL
    482          static int ssl_parse_session_ticket_ext(mbedtls_ssl_context *ssl,
    483                                                  unsigned char *buf,
    484                                                  size_t len)
    485          {
    486              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    487              mbedtls_ssl_session session;
    488          
    489              mbedtls_ssl_session_init(&session);
    490          
    491              if (ssl->conf->f_ticket_parse == NULL ||
    492                  ssl->conf->f_ticket_write == NULL) {
    493                  return 0;
    494              }
    495          
    496              /* Remember the client asked us to send a new ticket */
    497              ssl->handshake->new_session_ticket = 1;
    498          
    499              MBEDTLS_SSL_DEBUG_MSG(3, ("ticket length: %" MBEDTLS_PRINTF_SIZET, len));
    500          
    501              if (len == 0) {
    502                  return 0;
    503              }
    504          
    505          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    506              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
    507                  MBEDTLS_SSL_DEBUG_MSG(3, ("ticket rejected: renegotiating"));
    508                  return 0;
    509              }
    510          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    511          
    512              /*
    513               * Failures are ok: just ignore the ticket and proceed.
    514               */
    515              if ((ret = ssl->conf->f_ticket_parse(ssl->conf->p_ticket, &session,
    516                                                   buf, len)) != 0) {
    517                  mbedtls_ssl_session_free(&session);
    518          
    519                  if (ret == MBEDTLS_ERR_SSL_INVALID_MAC) {
    520                      MBEDTLS_SSL_DEBUG_MSG(3, ("ticket is not authentic"));
    521                  } else if (ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) {
    522                      MBEDTLS_SSL_DEBUG_MSG(3, ("ticket is expired"));
    523                  } else {
    524                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_ticket_parse", ret);
    525                  }
    526          
    527                  return 0;
    528              }
    529          
    530              /*
    531               * Keep the session ID sent by the client, since we MUST send it back to
    532               * inform them we're accepting the ticket  (RFC 5077 section 3.4)
    533               */
    534              session.id_len = ssl->session_negotiate->id_len;
    535              memcpy(&session.id, ssl->session_negotiate->id, session.id_len);
    536          
    537              mbedtls_ssl_session_free(ssl->session_negotiate);
    538              memcpy(ssl->session_negotiate, &session, sizeof(mbedtls_ssl_session));
    539          
    540              /* Zeroize instead of free as we copied the content */
    541              mbedtls_platform_zeroize(&session, sizeof(mbedtls_ssl_session));
    542          
    543              MBEDTLS_SSL_DEBUG_MSG(3, ("session successfully restored from ticket"));
    544          
    545              ssl->handshake->resume = 1;
    546          
    547              /* Don't send a new ticket after all, this one is OK */
    548              ssl->handshake->new_session_ticket = 0;
    549          
    550              return 0;
    551          }
    552          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    553          
    554          #if defined(MBEDTLS_SSL_DTLS_SRTP)
    555          MBEDTLS_CHECK_RETURN_CRITICAL
    556          static int ssl_parse_use_srtp_ext(mbedtls_ssl_context *ssl,
    557                                            const unsigned char *buf,
    558                                            size_t len)
    559          {
    560              mbedtls_ssl_srtp_profile client_protection = MBEDTLS_TLS_SRTP_UNSET;
    561              size_t i, j;
    562              size_t profile_length;
    563              uint16_t mki_length;
    564              /*! 2 bytes for profile length and 1 byte for mki len */
    565              const size_t size_of_lengths = 3;
    566          
    567              /* If use_srtp is not configured, just ignore the extension */
    568              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
    569                  (ssl->conf->dtls_srtp_profile_list == NULL) ||
    570                  (ssl->conf->dtls_srtp_profile_list_len == 0)) {
    571                  return 0;
    572              }
    573          
    574              /* RFC5764 section 4.1.1
    575               * uint8 SRTPProtectionProfile[2];
    576               *
    577               * struct {
    578               *   SRTPProtectionProfiles SRTPProtectionProfiles;
    579               *   opaque srtp_mki<0..255>;
    580               * } UseSRTPData;
    581          
    582               * SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;
    583               */
    584          
    585              /*
    586               * Min length is 5: at least one protection profile(2 bytes)
    587               *                  and length(2 bytes) + srtp_mki length(1 byte)
    588               * Check here that we have at least 2 bytes of protection profiles length
    589               * and one of srtp_mki length
    590               */
    591              if (len < size_of_lengths) {
    592                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    593                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    594                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    595              }
    596          
    597              ssl->dtls_srtp_info.chosen_dtls_srtp_profile = MBEDTLS_TLS_SRTP_UNSET;
    598          
    599              /* first 2 bytes are protection profile length(in bytes) */
    600              profile_length = (buf[0] << 8) | buf[1];
    601              buf += 2;
    602          
    603              /* The profile length cannot be bigger than input buffer size - lengths fields */
    604              if (profile_length > len - size_of_lengths ||
    605                  profile_length % 2 != 0) { /* profiles are 2 bytes long, so the length must be even */
    606                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    607                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    608                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    609              }
    610              /*
    611               * parse the extension list values are defined in
    612               * http://www.iana.org/assignments/srtp-protection/srtp-protection.xhtml
    613               */
    614              for (j = 0; j < profile_length; j += 2) {
    615                  uint16_t protection_profile_value = buf[j] << 8 | buf[j + 1];
    616                  client_protection = mbedtls_ssl_check_srtp_profile_value(protection_profile_value);
    617          
    618                  if (client_protection != MBEDTLS_TLS_SRTP_UNSET) {
    619                      MBEDTLS_SSL_DEBUG_MSG(3, ("found srtp profile: %s",
    620                                                mbedtls_ssl_get_srtp_profile_as_string(
    621                                                    client_protection)));
    622                  } else {
    623                      continue;
    624                  }
    625                  /* check if suggested profile is in our list */
    626                  for (i = 0; i < ssl->conf->dtls_srtp_profile_list_len; i++) {
    627                      if (client_protection == ssl->conf->dtls_srtp_profile_list[i]) {
    628                          ssl->dtls_srtp_info.chosen_dtls_srtp_profile = ssl->conf->dtls_srtp_profile_list[i];
    629                          MBEDTLS_SSL_DEBUG_MSG(3, ("selected srtp profile: %s",
    630                                                    mbedtls_ssl_get_srtp_profile_as_string(
    631                                                        client_protection)));
    632                          break;
    633                      }
    634                  }
    635                  if (ssl->dtls_srtp_info.chosen_dtls_srtp_profile != MBEDTLS_TLS_SRTP_UNSET) {
    636                      break;
    637                  }
    638              }
    639              buf += profile_length; /* buf points to the mki length */
    640              mki_length = *buf;
    641              buf++;
    642          
    643              if (mki_length > MBEDTLS_TLS_SRTP_MAX_MKI_LENGTH ||
    644                  mki_length + profile_length + size_of_lengths != len) {
    645                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    646                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
    647                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
    648              }
    649          
    650              /* Parse the mki only if present and mki is supported locally */
    651              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED &&
    652                  mki_length > 0) {
    653                  ssl->dtls_srtp_info.mki_len = mki_length;
    654          
    655                  memcpy(ssl->dtls_srtp_info.mki_value, buf, mki_length);
    656          
    657                  MBEDTLS_SSL_DEBUG_BUF(3, "using mki",  ssl->dtls_srtp_info.mki_value,
    658                                        ssl->dtls_srtp_info.mki_len);
    659              }
    660          
    661              return 0;
    662          }
    663          #endif /* MBEDTLS_SSL_DTLS_SRTP */
    664          
    665          /*
    666           * Auxiliary functions for ServerHello parsing and related actions
    667           */
    668          
    669          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    670          /*
    671           * Return 0 if the given key uses one of the acceptable curves, -1 otherwise
    672           */
    673          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
    674          MBEDTLS_CHECK_RETURN_CRITICAL
    675          static int ssl_check_key_curve(mbedtls_pk_context *pk,
    676                                         uint16_t *curves_tls_id)
    677          {
    678              uint16_t *curr_tls_id = curves_tls_id;
    679              mbedtls_ecp_group_id grp_id = mbedtls_pk_ec_ro(*pk)->grp.id;
    680              mbedtls_ecp_group_id curr_grp_id;
    681          
    682              while (*curr_tls_id != 0) {
    683                  curr_grp_id = mbedtls_ssl_get_ecp_group_id_from_tls_id(*curr_tls_id);
    684                  if (curr_grp_id == grp_id) {
    685                      return 0;
    686                  }
    687                  curr_tls_id++;
    688              }
    689          
    690              return -1;
    691          }
    692          #endif /* MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED */
    693          
    694          /*
    695           * Try picking a certificate for this ciphersuite,
    696           * return 0 on success and -1 on failure.
    697           */
    698          MBEDTLS_CHECK_RETURN_CRITICAL
    699          static int ssl_pick_cert(mbedtls_ssl_context *ssl,
    700                                   const mbedtls_ssl_ciphersuite_t *ciphersuite_info)
    701          {
    702              mbedtls_ssl_key_cert *cur, *list;
    703          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    704              psa_algorithm_t pk_alg =
    705                  mbedtls_ssl_get_ciphersuite_sig_pk_psa_alg(ciphersuite_info);
    706              psa_key_usage_t pk_usage =
    707                  mbedtls_ssl_get_ciphersuite_sig_pk_psa_usage(ciphersuite_info);
    708          #else
    709              mbedtls_pk_type_t pk_alg =
    710                  mbedtls_ssl_get_ciphersuite_sig_pk_alg(ciphersuite_info);
    711          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    712              uint32_t flags;
    713          
    714          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    715              if (ssl->handshake->sni_key_cert != NULL) {
    716                  list = ssl->handshake->sni_key_cert;
    717              } else
    718          #endif
    719              list = ssl->conf->key_cert;
    720          
    721              int pk_alg_is_none = 0;
    722          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    723              pk_alg_is_none = (pk_alg == PSA_ALG_NONE);
    724          #else
    725              pk_alg_is_none = (pk_alg == MBEDTLS_PK_NONE);
    726          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    727              if (pk_alg_is_none) {
    728                  return 0;
    729              }
    730          
    731              MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite requires certificate"));
    732          
    733              if (list == NULL) {
    734                  MBEDTLS_SSL_DEBUG_MSG(3, ("server has no certificate"));
    735                  return -1;
    736              }
    737          
    738              for (cur = list; cur != NULL; cur = cur->next) {
    739                  flags = 0;
    740                  MBEDTLS_SSL_DEBUG_CRT(3, "candidate certificate chain, certificate",
    741                                        cur->cert);
    742          
    743                  int key_type_matches = 0;
    744          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    745          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
    746                  key_type_matches = ((ssl->conf->f_async_sign_start != NULL ||
    747                                       ssl->conf->f_async_decrypt_start != NULL ||
    748                                       mbedtls_pk_can_do_ext(cur->key, pk_alg, pk_usage)) &&
    749                                      mbedtls_pk_can_do_ext(&cur->cert->pk, pk_alg, pk_usage));
    750          #else
    751                  key_type_matches = (
    752                      mbedtls_pk_can_do_ext(cur->key, pk_alg, pk_usage));
    753          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
    754          #else
    755                  key_type_matches = mbedtls_pk_can_do(&cur->cert->pk, pk_alg);
    756          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    757                  if (!key_type_matches) {
    758                      MBEDTLS_SSL_DEBUG_MSG(3, ("certificate mismatch: key type"));
    759                      continue;
    760                  }
    761          
    762                  /*
    763                   * This avoids sending the client a cert it'll reject based on
    764                   * keyUsage or other extensions.
    765                   *
    766                   * It also allows the user to provision different certificates for
    767                   * different uses based on keyUsage, eg if they want to avoid signing
    768                   * and decrypting with the same RSA key.
    769                   */
    770                  if (mbedtls_ssl_check_cert_usage(cur->cert, ciphersuite_info,
    771                                                   MBEDTLS_SSL_IS_SERVER, &flags) != 0) {
    772                      MBEDTLS_SSL_DEBUG_MSG(3, ("certificate mismatch: "
    773                                                "(extended) key usage extension"));
    774                      continue;
    775                  }
    776          
    777          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
    778                  if (pk_alg == MBEDTLS_PK_ECDSA &&
    779                      ssl_check_key_curve(&cur->cert->pk,
    780                                          ssl->handshake->curves_tls_id) != 0) {
    781                      MBEDTLS_SSL_DEBUG_MSG(3, ("certificate mismatch: elliptic curve"));
    782                      continue;
    783                  }
    784          #endif
    785          
    786                  /* If we get there, we got a winner */
    787                  break;
    788              }
    789          
    790              /* Do not update ssl->handshake->key_cert unless there is a match */
    791              if (cur != NULL) {
    792                  ssl->handshake->key_cert = cur;
    793                  MBEDTLS_SSL_DEBUG_CRT(3, "selected certificate chain, certificate",
    794                                        ssl->handshake->key_cert->cert);
    795                  return 0;
    796              }
    797          
    798              return -1;
    799          }
    800          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    801          
    802          /*
    803           * Check if a given ciphersuite is suitable for use with our config/keys/etc
    804           * Sets ciphersuite_info only if the suite matches.
    805           */
    806          MBEDTLS_CHECK_RETURN_CRITICAL
    807          static int ssl_ciphersuite_match(mbedtls_ssl_context *ssl, int suite_id,
    808                                           const mbedtls_ssl_ciphersuite_t **ciphersuite_info)
    809          {
    810              const mbedtls_ssl_ciphersuite_t *suite_info;
    811          
    812          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
    813              mbedtls_pk_type_t sig_type;
    814          #endif
    815          
    816              suite_info = mbedtls_ssl_ciphersuite_from_id(suite_id);
    817              if (suite_info == NULL) {
    818                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
    819                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
    820              }
    821          
    822              MBEDTLS_SSL_DEBUG_MSG(3, ("trying ciphersuite: %#04x (%s)",
    823                                        (unsigned int) suite_id, suite_info->name));
    824          
    825              if (suite_info->min_tls_version > ssl->tls_version ||
    826                  suite_info->max_tls_version < ssl->tls_version) {
    827                  MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: version"));
    828                  return 0;
    829              }
    830          
    831          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    832              if (suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
    833                  (ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK) == 0) {
    834                  MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: ecjpake "
    835                                            "not configured or ext missing"));
    836                  return 0;
    837              }
    838          #endif
    839          
    840          
    841          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
    842              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
    843              if (mbedtls_ssl_ciphersuite_uses_ec(suite_info) &&
    844                  (ssl->handshake->curves_tls_id == NULL ||
    845                   ssl->handshake->curves_tls_id[0] == 0)) {
    846                  MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: "
    847                                            "no common elliptic curve"));
    848                  return 0;
    849              }
    850          #endif
    851          
    852          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
    853              /* If the ciphersuite requires a pre-shared key and we don't
    854               * have one, skip it now rather than failing later */
    855              if (mbedtls_ssl_ciphersuite_uses_psk(suite_info) &&
    856                  ssl_conf_has_psk_or_cb(ssl->conf) == 0) {
    857                  MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: no pre-shared key"));
    858                  return 0;
    859              }
    860          #endif
    861          
    862          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    863              /*
    864               * Final check: if ciphersuite requires us to have a
    865               * certificate/key of a particular type:
    866               * - select the appropriate certificate if we have one, or
    867               * - try the next ciphersuite if we don't
    868               * This must be done last since we modify the key_cert list.
    869               */
    870              if (ssl_pick_cert(ssl, suite_info) != 0) {
    871                  MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: "
    872                                            "no suitable certificate"));
    873                  return 0;
    874              }
    875          #endif
    876          
    877          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
    878              /* If the ciphersuite requires signing, check whether
    879               * a suitable hash algorithm is present. */
    880              sig_type = mbedtls_ssl_get_ciphersuite_sig_alg(suite_info);
    881              if (sig_type != MBEDTLS_PK_NONE &&
    882                  mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg(
    883                      ssl, mbedtls_ssl_sig_from_pk_alg(sig_type)) == MBEDTLS_SSL_HASH_NONE) {
    884                  MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite mismatch: no suitable hash algorithm "
    885                                            "for signature algorithm %u", (unsigned) sig_type));
    886                  return 0;
    887              }
    888          
    889          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
    890          
    891              *ciphersuite_info = suite_info;
    892              return 0;
    893          }
    894          
    895          /* This function doesn't alert on errors that happen early during
    896             ClientHello parsing because they might indicate that the client is
    897             not talking SSL/TLS at all and would not understand our alert. */
    898          MBEDTLS_CHECK_RETURN_CRITICAL
    899          static int ssl_parse_client_hello(mbedtls_ssl_context *ssl)
    900          {
    901              int ret, got_common_suite;
    902              size_t i, j;
    903              size_t ciph_offset, comp_offset, ext_offset;
    904              size_t msg_len, ciph_len, sess_len, comp_len, ext_len;
    905          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    906              size_t cookie_offset, cookie_len;
    907          #endif
    908              unsigned char *buf, *p, *ext;
    909          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    910              int renegotiation_info_seen = 0;
    911          #endif
    912              int handshake_failure = 0;
    913              const int *ciphersuites;
    914              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
    915          
    916              /* If there is no signature-algorithm extension present,
    917               * we need to fall back to the default values for allowed
    918               * signature-hash pairs. */
    919          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
    920              int sig_hash_alg_ext_present = 0;
    921          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
    922          
    923              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse client hello"));
    924          
    925              int renegotiating;
    926          
    927          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
    928          read_record_header:
    929          #endif
    930              /*
    931               * If renegotiating, then the input was read with mbedtls_ssl_read_record(),
    932               * otherwise read it ourselves manually in order to support SSLv2
    933               * ClientHello, which doesn't use the same record layer format.
    934               * Otherwise in a scenario of TLS 1.3/TLS 1.2 version negotiation, the
    935               * ClientHello has been already fully fetched by the TLS 1.3 code and the
    936               * flag ssl->keep_current_message is raised.
    937               */
    938              renegotiating = 0;
    939          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    940              renegotiating = (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE);
    941          #endif
    942              if (!renegotiating && !ssl->keep_current_message) {
    943                  if ((ret = mbedtls_ssl_fetch_input(ssl, 5)) != 0) {
    944                      /* No alert on a read error. */
    945                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_fetch_input", ret);
    946                      return ret;
    947                  }
    948              }
    949          
    950              buf = ssl->in_hdr;
    951          
    952              MBEDTLS_SSL_DEBUG_BUF(4, "record header", buf, mbedtls_ssl_in_hdr_len(ssl));
    953          
    954              /*
    955               * TLS Client Hello
    956               *
    957               * Record layer:
    958               *     0  .   0   message type
    959               *     1  .   2   protocol version
    960               *     3  .   11  DTLS: epoch + record sequence number
    961               *     3  .   4   message length
    962               */
    963              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, message type: %d",
    964                                        buf[0]));
    965          
    966              if (buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE) {
    967                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    968                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
    969              }
    970          
    971              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, message len.: %d",
    972                                        (ssl->in_len[0] << 8) | ssl->in_len[1]));
    973          
    974              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello, protocol version: [%d:%d]",
    975                                        buf[1], buf[2]));
    976          
    977              /* For DTLS if this is the initial handshake, remember the client sequence
    978               * number to use it in our next message (RFC 6347 4.2.1) */
    979          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    980              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM
    981          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    982                  && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
    983          #endif
    984                  ) {
    985                  /* Epoch should be 0 for initial handshakes */
    986                  if (ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0) {
    987                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
    988                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
    989                  }
    990          
    991                  memcpy(&ssl->cur_out_ctr[2], ssl->in_ctr + 2,
    992                         sizeof(ssl->cur_out_ctr) - 2);
    993          
    994          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
    995                  if (mbedtls_ssl_dtls_replay_check(ssl) != 0) {
    996                      MBEDTLS_SSL_DEBUG_MSG(1, ("replayed record, discarding"));
    997                      ssl->next_record_offset = 0;
    998                      ssl->in_left = 0;
    999                      goto read_record_header;
   1000                  }
   1001          
   1002                  /* No MAC to check yet, so we can update right now */
   1003                  mbedtls_ssl_dtls_replay_update(ssl);
   1004          #endif
   1005              }
   1006          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1007          
   1008              msg_len = (ssl->in_len[0] << 8) | ssl->in_len[1];
   1009          
   1010          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1011              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
   1012                  /* Set by mbedtls_ssl_read_record() */
   1013                  msg_len = ssl->in_hslen;
   1014              } else
   1015          #endif
   1016              {
   1017                  if (ssl->keep_current_message) {
   1018                      ssl->keep_current_message = 0;
   1019                  } else {
   1020                      if (msg_len > MBEDTLS_SSL_IN_CONTENT_LEN) {
   1021                          MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1022                          return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   1023                      }
   1024          
   1025                      if ((ret = mbedtls_ssl_fetch_input(ssl,
   1026                                                         mbedtls_ssl_in_hdr_len(ssl) + msg_len)) != 0) {
   1027                          MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_fetch_input", ret);
   1028                          return ret;
   1029                      }
   1030          
   1031                      /* Done reading this record, get ready for the next one */
   1032          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1033                      if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1034                          ssl->next_record_offset = msg_len + mbedtls_ssl_in_hdr_len(ssl);
   1035                      } else
   1036          #endif
   1037                      ssl->in_left = 0;
   1038                  }
   1039              }
   1040          
   1041              buf = ssl->in_msg;
   1042          
   1043              MBEDTLS_SSL_DEBUG_BUF(4, "record contents", buf, msg_len);
   1044          
   1045              ret = ssl->handshake->update_checksum(ssl, buf, msg_len);
   1046              if (0 != ret) {
   1047                  MBEDTLS_SSL_DEBUG_RET(1, ("update_checksum"), ret);
   1048                  return ret;
   1049              }
   1050          
   1051              /*
   1052               * Handshake layer:
   1053               *     0  .   0   handshake type
   1054               *     1  .   3   handshake length
   1055               *     4  .   5   DTLS only: message sequence number
   1056               *     6  .   8   DTLS only: fragment offset
   1057               *     9  .  11   DTLS only: fragment length
   1058               */
   1059              if (msg_len < mbedtls_ssl_hs_hdr_len(ssl)) {
   1060                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1061                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1062              }
   1063          
   1064              MBEDTLS_SSL_DEBUG_MSG(3, ("client hello v3, handshake type: %d", buf[0]));
   1065          
   1066              if (buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO) {
   1067                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1068                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   1069              }
   1070              {
   1071                  size_t handshake_len = MBEDTLS_GET_UINT24_BE(buf, 1);
   1072                  MBEDTLS_SSL_DEBUG_MSG(3, ("client hello v3, handshake len.: %u",
   1073                                            (unsigned) handshake_len));
   1074          
   1075                  /* The record layer has a record size limit of 2^14 - 1 and
   1076                   * fragmentation is not supported, so buf[1] should be zero. */
   1077                  if (buf[1] != 0) {
   1078                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message: %u != 0",
   1079                                                (unsigned) buf[1]));
   1080                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1081                  }
   1082          
   1083                  /* We don't support fragmentation of ClientHello (yet?) */
   1084                  if (msg_len != mbedtls_ssl_hs_hdr_len(ssl) + handshake_len) {
   1085                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message: %u != %u + %u",
   1086                                                (unsigned) msg_len,
   1087                                                (unsigned) mbedtls_ssl_hs_hdr_len(ssl),
   1088                                                (unsigned) handshake_len));
   1089                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1090                  }
   1091              }
   1092          
   1093          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1094              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1095                  /*
   1096                   * Copy the client's handshake message_seq on initial handshakes,
   1097                   * check sequence number on renego.
   1098                   */
   1099          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1100                  if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   1101                      /* This couldn't be done in ssl_prepare_handshake_record() */
   1102                      unsigned int cli_msg_seq = (unsigned int) MBEDTLS_GET_UINT16_BE(ssl->in_msg, 4);
   1103                      if (cli_msg_seq != ssl->handshake->in_msg_seq) {
   1104                          MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message_seq: "
   1105                                                    "%u (expected %u)", cli_msg_seq,
   1106                                                    ssl->handshake->in_msg_seq));
   1107                          return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1108                      }
   1109          
   1110                      ssl->handshake->in_msg_seq++;
   1111                  } else
   1112          #endif
   1113                  {
   1114                      unsigned int cli_msg_seq = (unsigned int) MBEDTLS_GET_UINT16_BE(ssl->in_msg, 4);
   1115                      ssl->handshake->out_msg_seq = cli_msg_seq;
   1116                      ssl->handshake->in_msg_seq  = cli_msg_seq + 1;
   1117                  }
   1118                  {
   1119                      /*
   1120                       * For now we don't support fragmentation, so make sure
   1121                       * fragment_offset == 0 and fragment_length == length
   1122                       */
   1123                      size_t fragment_offset, fragment_length, length;
   1124                      fragment_offset = MBEDTLS_GET_UINT24_BE(ssl->in_msg, 6);
   1125                      fragment_length = MBEDTLS_GET_UINT24_BE(ssl->in_msg, 9);
   1126                      length = MBEDTLS_GET_UINT24_BE(ssl->in_msg, 1);
   1127                      MBEDTLS_SSL_DEBUG_MSG(
   1128                          4, ("fragment_offset=%u fragment_length=%u length=%u",
   1129                              (unsigned) fragment_offset, (unsigned) fragment_length,
   1130                              (unsigned) length));
   1131                      if (fragment_offset != 0 || length != fragment_length) {
   1132                          MBEDTLS_SSL_DEBUG_MSG(1, ("ClientHello fragmentation not supported"));
   1133                          return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1134                      }
   1135                  }
   1136              }
   1137          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1138          
   1139              buf += mbedtls_ssl_hs_hdr_len(ssl);
   1140              msg_len -= mbedtls_ssl_hs_hdr_len(ssl);
   1141          
   1142              /*
   1143               * ClientHello layer:
   1144               *     0  .   1   protocol version
   1145               *     2  .  33   random bytes (starting with 4 bytes of Unix time)
   1146               *    34  .  35   session id length (1 byte)
   1147               *    35  . 34+x  session id
   1148               *   35+x . 35+x  DTLS only: cookie length (1 byte)
   1149               *   36+x .  ..   DTLS only: cookie
   1150               *    ..  .  ..   ciphersuite list length (2 bytes)
   1151               *    ..  .  ..   ciphersuite list
   1152               *    ..  .  ..   compression alg. list length (1 byte)
   1153               *    ..  .  ..   compression alg. list
   1154               *    ..  .  ..   extensions length (2 bytes, optional)
   1155               *    ..  .  ..   extensions (optional)
   1156               */
   1157          
   1158              /*
   1159               * Minimal length (with everything empty and extensions omitted) is
   1160               * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can
   1161               * read at least up to session id length without worrying.
   1162               */
   1163              if (msg_len < 38) {
   1164                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1165                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1166              }
   1167          
   1168              /*
   1169               * Check and save the protocol version
   1170               */
   1171              MBEDTLS_SSL_DEBUG_BUF(3, "client hello, version", buf, 2);
   1172          
   1173              ssl->tls_version = (mbedtls_ssl_protocol_version) mbedtls_ssl_read_version(buf,
   1174                                                                                         ssl->conf->transport);
   1175              ssl->session_negotiate->tls_version = ssl->tls_version;
   1176          
   1177              if (ssl->tls_version != MBEDTLS_SSL_VERSION_TLS1_2) {
   1178                  MBEDTLS_SSL_DEBUG_MSG(1, ("server only supports TLS 1.2"));
   1179                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1180                                                 MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION);
   1181                  return MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION;
   1182              }
   1183          
   1184              /*
   1185               * Save client random (inc. Unix time)
   1186               */
   1187              MBEDTLS_SSL_DEBUG_BUF(3, "client hello, random bytes", buf + 2, 32);
   1188          
   1189              memcpy(ssl->handshake->randbytes, buf + 2, 32);
   1190          
   1191              /*
   1192               * Check the session ID length and save session ID
   1193               */
   1194              sess_len = buf[34];
   1195          
   1196              if (sess_len > sizeof(ssl->session_negotiate->id) ||
   1197                  sess_len + 34 + 2 > msg_len) { /* 2 for cipherlist length field */
   1198                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1199                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1200                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1201                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1202              }
   1203          
   1204              MBEDTLS_SSL_DEBUG_BUF(3, "client hello, session id", buf + 35, sess_len);
   1205          
   1206              ssl->session_negotiate->id_len = sess_len;
   1207              memset(ssl->session_negotiate->id, 0,
   1208                     sizeof(ssl->session_negotiate->id));
   1209              memcpy(ssl->session_negotiate->id, buf + 35,
   1210                     ssl->session_negotiate->id_len);
   1211          
   1212              /*
   1213               * Check the cookie length and content
   1214               */
   1215          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1216              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1217                  cookie_offset = 35 + sess_len;
   1218                  cookie_len = buf[cookie_offset];
   1219          
   1220                  if (cookie_offset + 1 + cookie_len + 2 > msg_len) {
   1221                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1222                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1223                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1224                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1225                  }
   1226          
   1227                  MBEDTLS_SSL_DEBUG_BUF(3, "client hello, cookie",
   1228                                        buf + cookie_offset + 1, cookie_len);
   1229          
   1230          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   1231                  if (ssl->conf->f_cookie_check != NULL
   1232          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1233                      && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
   1234          #endif
   1235                      ) {
   1236                      if (ssl->conf->f_cookie_check(ssl->conf->p_cookie,
   1237                                                    buf + cookie_offset + 1, cookie_len,
   1238                                                    ssl->cli_id, ssl->cli_id_len) != 0) {
   1239                          MBEDTLS_SSL_DEBUG_MSG(2, ("cookie verification failed"));
   1240                          ssl->handshake->cookie_verify_result = 1;
   1241                      } else {
   1242                          MBEDTLS_SSL_DEBUG_MSG(2, ("cookie verification passed"));
   1243                          ssl->handshake->cookie_verify_result = 0;
   1244                      }
   1245                  } else
   1246          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   1247                  {
   1248                      /* We know we didn't send a cookie, so it should be empty */
   1249                      if (cookie_len != 0) {
   1250                          /* This may be an attacker's probe, so don't send an alert */
   1251                          MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1252                          return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1253                      }
   1254          
   1255                      MBEDTLS_SSL_DEBUG_MSG(2, ("cookie verification skipped"));
   1256                  }
   1257          
   1258                  /*
   1259                   * Check the ciphersuitelist length (will be parsed later)
   1260                   */
   1261                  ciph_offset = cookie_offset + 1 + cookie_len;
   1262              } else
   1263          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1264              ciph_offset = 35 + sess_len;
   1265          
   1266              ciph_len = (buf[ciph_offset + 0] << 8)
   1267                         | (buf[ciph_offset + 1]);
   1268          
   1269              if (ciph_len < 2 ||
   1270                  ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */
   1271                  (ciph_len % 2) != 0) {
   1272                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1273                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1274                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1275                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1276              }
   1277          
   1278              MBEDTLS_SSL_DEBUG_BUF(3, "client hello, ciphersuitelist",
   1279                                    buf + ciph_offset + 2,  ciph_len);
   1280          
   1281              /*
   1282               * Check the compression algorithm's length.
   1283               * The list contents are ignored because implementing
   1284               * MBEDTLS_SSL_COMPRESS_NULL is mandatory and is the only
   1285               * option supported by Mbed TLS.
   1286               */
   1287              comp_offset = ciph_offset + 2 + ciph_len;
   1288          
   1289              comp_len = buf[comp_offset];
   1290          
   1291              if (comp_len < 1 ||
   1292                  comp_len > 16 ||
   1293                  comp_len + comp_offset + 1 > msg_len) {
   1294                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1295                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1296                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1297                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1298              }
   1299          
   1300              MBEDTLS_SSL_DEBUG_BUF(3, "client hello, compression",
   1301                                    buf + comp_offset + 1, comp_len);
   1302          
   1303              /*
   1304               * Check the extension length
   1305               */
   1306              ext_offset = comp_offset + 1 + comp_len;
   1307              if (msg_len > ext_offset) {
   1308                  if (msg_len < ext_offset + 2) {
   1309                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1310                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1311                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1312                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1313                  }
   1314          
   1315                  ext_len = (buf[ext_offset + 0] << 8)
   1316                            | (buf[ext_offset + 1]);
   1317          
   1318                  if (msg_len != ext_offset + 2 + ext_len) {
   1319                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1320                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1321                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1322                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1323                  }
   1324              } else {
   1325                  ext_len = 0;
   1326              }
   1327          
   1328              ext = buf + ext_offset + 2;
   1329              MBEDTLS_SSL_DEBUG_BUF(3, "client hello extensions", ext, ext_len);
   1330          
   1331              while (ext_len != 0) {
   1332                  unsigned int ext_id;
   1333                  unsigned int ext_size;
   1334                  if (ext_len < 4) {
   1335                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1336                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1337                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1338                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1339                  }
   1340                  ext_id   = ((ext[0] <<  8) | (ext[1]));
   1341                  ext_size = ((ext[2] <<  8) | (ext[3]));
   1342          
   1343                  if (ext_size + 4 > ext_len) {
   1344                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
   1345                      mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1346                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   1347                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   1348                  }
   1349                  switch (ext_id) {
   1350          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   1351                      case MBEDTLS_TLS_EXT_SERVERNAME:
   1352                          MBEDTLS_SSL_DEBUG_MSG(3, ("found ServerName extension"));
   1353                          ret = mbedtls_ssl_parse_server_name_ext(ssl, ext + 4,
   1354                                                                  ext + 4 + ext_size);
   1355                          if (ret != 0) {
   1356                              return ret;
   1357                          }
   1358                          break;
   1359          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   1360          
   1361                      case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
   1362                          MBEDTLS_SSL_DEBUG_MSG(3, ("found renegotiation extension"));
   1363          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1364                          renegotiation_info_seen = 1;
   1365          #endif
   1366          
   1367                          ret = ssl_parse_renegotiation_info(ssl, ext + 4, ext_size);
   1368                          if (ret != 0) {
   1369                              return ret;
   1370                          }
   1371                          break;
   1372          
   1373          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
   1374                      case MBEDTLS_TLS_EXT_SIG_ALG:
   1375                          MBEDTLS_SSL_DEBUG_MSG(3, ("found signature_algorithms extension"));
   1376          
   1377                          ret = mbedtls_ssl_parse_sig_alg_ext(ssl, ext + 4, ext + 4 + ext_size);
   1378                          if (ret != 0) {
   1379                              return ret;
   1380                          }
   1381          
   1382                          sig_hash_alg_ext_present = 1;
   1383                          break;
   1384          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
   1385          
   1386          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
   1387                          defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
   1388                          defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1389                      case MBEDTLS_TLS_EXT_SUPPORTED_GROUPS:
   1390                          MBEDTLS_SSL_DEBUG_MSG(3, ("found supported elliptic curves extension"));
   1391          
   1392                          ret = ssl_parse_supported_groups_ext(ssl, ext + 4, ext_size);
   1393                          if (ret != 0) {
   1394                              return ret;
   1395                          }
   1396                          break;
   1397          
   1398                      case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
   1399                          MBEDTLS_SSL_DEBUG_MSG(3, ("found supported point formats extension"));
   1400                          ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;
   1401          
   1402                          ret = ssl_parse_supported_point_formats(ssl, ext + 4, ext_size);
   1403                          if (ret != 0) {
   1404                              return ret;
   1405                          }
   1406                          break;
   1407          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED || \
   1408                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
   1409                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1410          
   1411          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1412                      case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
   1413                          MBEDTLS_SSL_DEBUG_MSG(3, ("found ecjpake kkpp extension"));
   1414          
   1415                          ret = ssl_parse_ecjpake_kkpp(ssl, ext + 4, ext_size);
   1416                          if (ret != 0) {
   1417                              return ret;
   1418                          }
   1419                          break;
   1420          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1421          
   1422          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   1423                      case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
   1424                          MBEDTLS_SSL_DEBUG_MSG(3, ("found max fragment length extension"));
   1425          
   1426                          ret = ssl_parse_max_fragment_length_ext(ssl, ext + 4, ext_size);
   1427                          if (ret != 0) {
   1428                              return ret;
   1429                          }
   1430                          break;
   1431          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   1432          
   1433          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1434                      case MBEDTLS_TLS_EXT_CID:
   1435                          MBEDTLS_SSL_DEBUG_MSG(3, ("found CID extension"));
   1436          
   1437                          ret = ssl_parse_cid_ext(ssl, ext + 4, ext_size);
   1438                          if (ret != 0) {
   1439                              return ret;
   1440                          }
   1441                          break;
   1442          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   1443          
   1444          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1445                      case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
   1446                          MBEDTLS_SSL_DEBUG_MSG(3, ("found encrypt then mac extension"));
   1447          
   1448                          ret = ssl_parse_encrypt_then_mac_ext(ssl, ext + 4, ext_size);
   1449                          if (ret != 0) {
   1450                              return ret;
   1451                          }
   1452                          break;
   1453          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1454          
   1455          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   1456                      case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
   1457                          MBEDTLS_SSL_DEBUG_MSG(3, ("found extended master secret extension"));
   1458          
   1459                          ret = ssl_parse_extended_ms_ext(ssl, ext + 4, ext_size);
   1460                          if (ret != 0) {
   1461                              return ret;
   1462                          }
   1463                          break;
   1464          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   1465          
   1466          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   1467                      case MBEDTLS_TLS_EXT_SESSION_TICKET:
   1468                          MBEDTLS_SSL_DEBUG_MSG(3, ("found session ticket extension"));
   1469          
   1470                          ret = ssl_parse_session_ticket_ext(ssl, ext + 4, ext_size);
   1471                          if (ret != 0) {
   1472                              return ret;
   1473                          }
   1474                          break;
   1475          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1476          
   1477          #if defined(MBEDTLS_SSL_ALPN)
   1478                      case MBEDTLS_TLS_EXT_ALPN:
   1479                          MBEDTLS_SSL_DEBUG_MSG(3, ("found alpn extension"));
   1480          
   1481                          ret = mbedtls_ssl_parse_alpn_ext(ssl, ext + 4,
   1482                                                           ext + 4 + ext_size);
   1483                          if (ret != 0) {
   1484                              return ret;
   1485                          }
   1486                          break;
   1487          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1488          
   1489          #if defined(MBEDTLS_SSL_DTLS_SRTP)
   1490                      case MBEDTLS_TLS_EXT_USE_SRTP:
   1491                          MBEDTLS_SSL_DEBUG_MSG(3, ("found use_srtp extension"));
   1492          
   1493                          ret = ssl_parse_use_srtp_ext(ssl, ext + 4, ext_size);
   1494                          if (ret != 0) {
   1495                              return ret;
   1496                          }
   1497                          break;
   1498          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   1499          
   1500                      default:
   1501                          MBEDTLS_SSL_DEBUG_MSG(3, ("unknown extension found: %u (ignoring)",
   1502                                                    ext_id));
   1503                  }
   1504          
   1505                  ext_len -= 4 + ext_size;
   1506                  ext += 4 + ext_size;
   1507              }
   1508          
   1509          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
   1510          
   1511              /*
   1512               * Try to fall back to default hash SHA1 if the client
   1513               * hasn't provided any preferred signature-hash combinations.
   1514               */
   1515              if (!sig_hash_alg_ext_present) {
   1516                  uint16_t *received_sig_algs = ssl->handshake->received_sig_algs;
   1517                  const uint16_t default_sig_algs[] = {
   1518          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   1519                      MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA,
   1520                                                         MBEDTLS_SSL_HASH_SHA1),
   1521          #endif
   1522          #if defined(MBEDTLS_RSA_C)
   1523                      MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_RSA,
   1524                                                         MBEDTLS_SSL_HASH_SHA1),
   1525          #endif
   1526                      MBEDTLS_TLS_SIG_NONE
   1527                  };
   1528          
   1529                  MBEDTLS_STATIC_ASSERT(sizeof(default_sig_algs) / sizeof(default_sig_algs[0])
   1530                                        <= MBEDTLS_RECEIVED_SIG_ALGS_SIZE,
   1531                                        "default_sig_algs is too big");
   1532          
   1533                  memcpy(received_sig_algs, default_sig_algs, sizeof(default_sig_algs));
   1534              }
   1535          
   1536          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
   1537          
   1538              /*
   1539               * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   1540               */
   1541              for (i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2) {
   1542                  if (p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO) {
   1543                      MBEDTLS_SSL_DEBUG_MSG(3, ("received TLS_EMPTY_RENEGOTIATION_INFO "));
   1544          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1545                      if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   1546                          MBEDTLS_SSL_DEBUG_MSG(1, ("received RENEGOTIATION SCSV "
   1547                                                    "during renegotiation"));
   1548                          mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1549                                                         MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1550                          return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1551                      }
   1552          #endif
   1553                      ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
   1554                      break;
   1555                  }
   1556              }
   1557          
   1558              /*
   1559               * Renegotiation security checks
   1560               */
   1561              if (ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1562                  ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE) {
   1563                  MBEDTLS_SSL_DEBUG_MSG(1, ("legacy renegotiation, breaking off handshake"));
   1564                  handshake_failure = 1;
   1565              }
   1566          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1567              else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1568                       ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1569                       renegotiation_info_seen == 0) {
   1570                  MBEDTLS_SSL_DEBUG_MSG(1, ("renegotiation_info extension missing (secure)"));
   1571                  handshake_failure = 1;
   1572              } else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1573                         ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1574                         ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION) {
   1575                  MBEDTLS_SSL_DEBUG_MSG(1, ("legacy renegotiation not allowed"));
   1576                  handshake_failure = 1;
   1577              } else if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1578                         ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1579                         renegotiation_info_seen == 1) {
   1580                  MBEDTLS_SSL_DEBUG_MSG(1, ("renegotiation_info extension present (legacy)"));
   1581                  handshake_failure = 1;
   1582              }
   1583          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1584          
   1585              if (handshake_failure == 1) {
   1586                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1587                                                 MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1588                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1589              }
   1590          
   1591              /*
   1592               * Server certification selection (after processing TLS extensions)
   1593               */
   1594              if (ssl->conf->f_cert_cb && (ret = ssl->conf->f_cert_cb(ssl)) != 0) {
   1595                  MBEDTLS_SSL_DEBUG_RET(1, "f_cert_cb", ret);
   1596                  return ret;
   1597              }
   1598          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   1599              ssl->handshake->sni_name = NULL;
   1600              ssl->handshake->sni_name_len = 0;
   1601          #endif
   1602          
   1603              /*
   1604               * Search for a matching ciphersuite
   1605               * (At the end because we need information from the EC-based extensions
   1606               * and certificate from the SNI callback triggered by the SNI extension
   1607               * or certificate from server certificate selection callback.)
   1608               */
   1609              got_common_suite = 0;
   1610              ciphersuites = ssl->conf->ciphersuite_list;
   1611              ciphersuite_info = NULL;
   1612          
   1613              if (ssl->conf->respect_cli_pref == MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT) {
   1614                  for (j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2) {
   1615                      for (i = 0; ciphersuites[i] != 0; i++) {
   1616                          if (MBEDTLS_GET_UINT16_BE(p, 0) != ciphersuites[i]) {
   1617                              continue;
   1618                          }
   1619          
   1620                          got_common_suite = 1;
   1621          
   1622                          if ((ret = ssl_ciphersuite_match(ssl, ciphersuites[i],
   1623                                                           &ciphersuite_info)) != 0) {
   1624                              return ret;
   1625                          }
   1626          
   1627                          if (ciphersuite_info != NULL) {
   1628                              goto have_ciphersuite;
   1629                          }
   1630                      }
   1631                  }
   1632              } else {
   1633                  for (i = 0; ciphersuites[i] != 0; i++) {
   1634                      for (j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2) {
   1635                          if (MBEDTLS_GET_UINT16_BE(p, 0) != ciphersuites[i]) {
   1636                              continue;
   1637                          }
   1638          
   1639                          got_common_suite = 1;
   1640          
   1641                          if ((ret = ssl_ciphersuite_match(ssl, ciphersuites[i],
   1642                                                           &ciphersuite_info)) != 0) {
   1643                              return ret;
   1644                          }
   1645          
   1646                          if (ciphersuite_info != NULL) {
   1647                              goto have_ciphersuite;
   1648                          }
   1649                      }
   1650                  }
   1651              }
   1652          
   1653              if (got_common_suite) {
   1654                  MBEDTLS_SSL_DEBUG_MSG(1, ("got ciphersuites in common, "
   1655                                            "but none of them usable"));
   1656                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1657                                                 MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1658                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1659              } else {
   1660                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no ciphersuites in common"));
   1661                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1662                                                 MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);
   1663                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   1664              }
   1665          
   1666          have_ciphersuite:
   1667              MBEDTLS_SSL_DEBUG_MSG(2, ("selected ciphersuite: %s", ciphersuite_info->name));
   1668          
   1669              ssl->session_negotiate->ciphersuite = ciphersuites[i];
   1670              ssl->handshake->ciphersuite_info = ciphersuite_info;
   1671          
   1672              ssl->state++;
   1673          
   1674          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1675              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1676                  mbedtls_ssl_recv_flight_completed(ssl);
   1677              }
   1678          #endif
   1679          
   1680              /* Debugging-only output for testsuite */
   1681          #if defined(MBEDTLS_DEBUG_C)                         && \
   1682              defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
   1683              mbedtls_pk_type_t sig_alg = mbedtls_ssl_get_ciphersuite_sig_alg(ciphersuite_info);
   1684              if (sig_alg != MBEDTLS_PK_NONE) {
   1685                  unsigned int sig_hash = mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg(
   1686                      ssl, mbedtls_ssl_sig_from_pk_alg(sig_alg));
   1687                  MBEDTLS_SSL_DEBUG_MSG(3, ("client hello v3, signature_algorithm ext: %u",
   1688                                            sig_hash));
   1689              } else {
   1690                  MBEDTLS_SSL_DEBUG_MSG(3, ("no hash algorithm for signature algorithm "
   1691                                            "%u - should not happen", (unsigned) sig_alg));
   1692              }
   1693          #endif
   1694          
   1695              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse client hello"));
   1696          
   1697              return 0;
   1698          }
   1699          
   1700          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   1701          static void ssl_write_cid_ext(mbedtls_ssl_context *ssl,
   1702                                        unsigned char *buf,
   1703                                        size_t *olen)
   1704          {
   1705              unsigned char *p = buf;
   1706              size_t ext_len;
   1707              const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   1708          
   1709              *olen = 0;
   1710          
   1711              /* Skip writing the extension if we don't want to use it or if
   1712               * the client hasn't offered it. */
   1713              if (ssl->handshake->cid_in_use == MBEDTLS_SSL_CID_DISABLED) {
   1714                  return;
   1715              }
   1716          
   1717              /* ssl->own_cid_len is at most MBEDTLS_SSL_CID_IN_LEN_MAX
   1718               * which is at most 255, so the increment cannot overflow. */
   1719              if (end < p || (size_t) (end - p) < (unsigned) (ssl->own_cid_len + 5)) {
   1720                  MBEDTLS_SSL_DEBUG_MSG(1, ("buffer too small"));
   1721                  return;
   1722              }
   1723          
   1724              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, adding CID extension"));
   1725          
   1726              /*
   1727               *   struct {
   1728               *      opaque cid<0..2^8-1>;
   1729               *   } ConnectionId;
   1730               */
   1731              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_CID, p, 0);
   1732              p += 2;
   1733              ext_len = (size_t) ssl->own_cid_len + 1;
   1734              MBEDTLS_PUT_UINT16_BE(ext_len, p, 0);
   1735              p += 2;
   1736          
   1737              *p++ = (uint8_t) ssl->own_cid_len;
   1738              memcpy(p, ssl->own_cid, ssl->own_cid_len);
   1739          
   1740              *olen = ssl->own_cid_len + 5;
   1741          }
   1742          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   1743          
   1744          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   1745          static void ssl_write_encrypt_then_mac_ext(mbedtls_ssl_context *ssl,
   1746                                                     unsigned char *buf,
   1747                                                     size_t *olen)
   1748          {
   1749              unsigned char *p = buf;
   1750              const mbedtls_ssl_ciphersuite_t *suite = NULL;
   1751          
   1752              /*
   1753               * RFC 7366: "If a server receives an encrypt-then-MAC request extension
   1754               * from a client and then selects a stream or Authenticated Encryption
   1755               * with Associated Data (AEAD) ciphersuite, it MUST NOT send an
   1756               * encrypt-then-MAC response extension back to the client."
   1757               */
   1758              suite = mbedtls_ssl_ciphersuite_from_id(
   1759                  ssl->session_negotiate->ciphersuite);
   1760              if (suite == NULL) {
   1761                  ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_DISABLED;
   1762              } else {
   1763                  mbedtls_ssl_mode_t ssl_mode =
   1764                      mbedtls_ssl_get_mode_from_ciphersuite(
   1765                          ssl->session_negotiate->encrypt_then_mac,
   1766                          suite);
   1767          
   1768                  if (ssl_mode != MBEDTLS_SSL_MODE_CBC_ETM) {
   1769                      ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_DISABLED;
   1770                  }
   1771              }
   1772          
   1773              if (ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED) {
   1774                  *olen = 0;
   1775                  return;
   1776              }
   1777          
   1778              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, adding encrypt then mac extension"));
   1779          
   1780              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC, p, 0);
   1781              p += 2;
   1782          
   1783              *p++ = 0x00;
   1784              *p++ = 0x00;
   1785          
   1786              *olen = 4;
   1787          }
   1788          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   1789          
   1790          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   1791          static void ssl_write_extended_ms_ext(mbedtls_ssl_context *ssl,
   1792                                                unsigned char *buf,
   1793                                                size_t *olen)
   1794          {
   1795              unsigned char *p = buf;
   1796          
   1797              if (ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED) {
   1798                  *olen = 0;
   1799                  return;
   1800              }
   1801          
   1802              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, adding extended master secret "
   1803                                        "extension"));
   1804          
   1805              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET, p, 0);
   1806              p += 2;
   1807          
   1808              *p++ = 0x00;
   1809              *p++ = 0x00;
   1810          
   1811              *olen = 4;
   1812          }
   1813          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   1814          
   1815          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   1816          static void ssl_write_session_ticket_ext(mbedtls_ssl_context *ssl,
   1817                                                   unsigned char *buf,
   1818                                                   size_t *olen)
   1819          {
   1820              unsigned char *p = buf;
   1821          
   1822              if (ssl->handshake->new_session_ticket == 0) {
   1823                  *olen = 0;
   1824                  return;
   1825              }
   1826          
   1827              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, adding session ticket extension"));
   1828          
   1829              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0);
   1830              p += 2;
   1831          
   1832              *p++ = 0x00;
   1833              *p++ = 0x00;
   1834          
   1835              *olen = 4;
   1836          }
   1837          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1838          
   1839          static void ssl_write_renegotiation_ext(mbedtls_ssl_context *ssl,
   1840                                                  unsigned char *buf,
   1841                                                  size_t *olen)
   1842          {
   1843              unsigned char *p = buf;
   1844          
   1845              if (ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION) {
   1846                  *olen = 0;
   1847                  return;
   1848              }
   1849          
   1850              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, secure renegotiation extension"));
   1851          
   1852              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_RENEGOTIATION_INFO, p, 0);
   1853              p += 2;
   1854          
   1855          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1856              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
   1857                  *p++ = 0x00;
   1858                  *p++ = (ssl->verify_data_len * 2 + 1) & 0xFF;
   1859                  *p++ = ssl->verify_data_len * 2 & 0xFF;
   1860          
   1861                  memcpy(p, ssl->peer_verify_data, ssl->verify_data_len);
   1862                  p += ssl->verify_data_len;
   1863                  memcpy(p, ssl->own_verify_data, ssl->verify_data_len);
   1864                  p += ssl->verify_data_len;
   1865              } else
   1866          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1867              {
   1868                  *p++ = 0x00;
   1869                  *p++ = 0x01;
   1870                  *p++ = 0x00;
   1871              }
   1872          
   1873              *olen = p - buf;
   1874          }
   1875          
   1876          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   1877          static void ssl_write_max_fragment_length_ext(mbedtls_ssl_context *ssl,
   1878                                                        unsigned char *buf,
   1879                                                        size_t *olen)
   1880          {
   1881              unsigned char *p = buf;
   1882          
   1883              if (ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE) {
   1884                  *olen = 0;
   1885                  return;
   1886              }
   1887          
   1888              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, max_fragment_length extension"));
   1889          
   1890              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH, p, 0);
   1891              p += 2;
   1892          
   1893              *p++ = 0x00;
   1894              *p++ = 1;
   1895          
   1896              *p++ = ssl->session_negotiate->mfl_code;
   1897          
   1898              *olen = 5;
   1899          }
   1900          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   1901          
   1902          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
   1903              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
   1904              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1905          static void ssl_write_supported_point_formats_ext(mbedtls_ssl_context *ssl,
   1906                                                            unsigned char *buf,
   1907                                                            size_t *olen)
   1908          {
   1909              unsigned char *p = buf;
   1910              ((void) ssl);
   1911          
   1912              if ((ssl->handshake->cli_exts &
   1913                   MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT) == 0) {
   1914                  *olen = 0;
   1915                  return;
   1916              }
   1917          
   1918              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, supported_point_formats extension"));
   1919          
   1920              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS, p, 0);
   1921              p += 2;
   1922          
   1923              *p++ = 0x00;
   1924              *p++ = 2;
   1925          
   1926              *p++ = 1;
   1927              *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
   1928          
   1929              *olen = 6;
   1930          }
   1931          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED ||
   1932                    MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED ||
   1933                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1934          
   1935          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1936          static void ssl_write_ecjpake_kkpp_ext(mbedtls_ssl_context *ssl,
   1937                                                 unsigned char *buf,
   1938                                                 size_t *olen)
   1939          {
   1940              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1941              unsigned char *p = buf;
   1942              const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   1943              size_t kkpp_len;
   1944          
   1945              *olen = 0;
   1946          
   1947              /* Skip costly computation if not needed */
   1948              if (ssl->handshake->ciphersuite_info->key_exchange !=
   1949                  MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   1950                  return;
   1951              }
   1952          
   1953              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, ecjpake kkpp extension"));
   1954          
   1955              if (end - p < 4) {
   1956                  MBEDTLS_SSL_DEBUG_MSG(1, ("buffer too small"));
   1957                  return;
   1958              }
   1959          
   1960              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ECJPAKE_KKPP, p, 0);
   1961              p += 2;
   1962          
   1963          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1964              ret = mbedtls_psa_ecjpake_write_round(&ssl->handshake->psa_pake_ctx,
   1965                                                    p + 2, end - p - 2, &kkpp_len,
   1966                                                    MBEDTLS_ECJPAKE_ROUND_ONE);
   1967              if (ret != 0) {
   1968                  psa_destroy_key(ssl->handshake->psa_pake_password);
   1969                  psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   1970                  MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_output", ret);
   1971                  return;
   1972              }
   1973          #else
   1974              ret = mbedtls_ecjpake_write_round_one(&ssl->handshake->ecjpake_ctx,
   1975                                                    p + 2, end - p - 2, &kkpp_len,
   1976                                                    ssl->conf->f_rng, ssl->conf->p_rng);
   1977              if (ret != 0) {
   1978                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_write_round_one", ret);
   1979                  return;
   1980              }
   1981          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1982          
   1983              MBEDTLS_PUT_UINT16_BE(kkpp_len, p, 0);
   1984              p += 2;
   1985          
   1986              *olen = kkpp_len + 4;
   1987          }
   1988          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1989          
   1990          #if defined(MBEDTLS_SSL_DTLS_SRTP) && defined(MBEDTLS_SSL_PROTO_DTLS)
   1991          static void ssl_write_use_srtp_ext(mbedtls_ssl_context *ssl,
   1992                                             unsigned char *buf,
   1993                                             size_t *olen)
   1994          {
   1995              size_t mki_len = 0, ext_len = 0;
   1996              uint16_t profile_value = 0;
   1997              const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   1998          
   1999              *olen = 0;
   2000          
   2001              if ((ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) ||
   2002                  (ssl->dtls_srtp_info.chosen_dtls_srtp_profile == MBEDTLS_TLS_SRTP_UNSET)) {
   2003                  return;
   2004              }
   2005          
   2006              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, adding use_srtp extension"));
   2007          
   2008              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED) {
   2009                  mki_len = ssl->dtls_srtp_info.mki_len;
   2010              }
   2011          
   2012              /* The extension total size is 9 bytes :
   2013               * - 2 bytes for the extension tag
   2014               * - 2 bytes for the total size
   2015               * - 2 bytes for the protection profile length
   2016               * - 2 bytes for the protection profile
   2017               * - 1 byte for the mki length
   2018               * +  the actual mki length
   2019               * Check we have enough room in the output buffer */
   2020              if ((size_t) (end - buf) < mki_len + 9) {
   2021                  MBEDTLS_SSL_DEBUG_MSG(1, ("buffer too small"));
   2022                  return;
   2023              }
   2024          
   2025              /* extension */
   2026              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_USE_SRTP, buf, 0);
   2027              /*
   2028               * total length 5 and mki value: only one profile(2 bytes)
   2029               *              and length(2 bytes) and srtp_mki  )
   2030               */
   2031              ext_len = 5 + mki_len;
   2032              MBEDTLS_PUT_UINT16_BE(ext_len, buf, 2);
   2033          
   2034              /* protection profile length: 2 */
   2035              buf[4] = 0x00;
   2036              buf[5] = 0x02;
   2037              profile_value = mbedtls_ssl_check_srtp_profile_value(
   2038                  ssl->dtls_srtp_info.chosen_dtls_srtp_profile);
   2039              if (profile_value != MBEDTLS_TLS_SRTP_UNSET) {
   2040                  MBEDTLS_PUT_UINT16_BE(profile_value, buf, 6);
   2041              } else {
   2042                  MBEDTLS_SSL_DEBUG_MSG(1, ("use_srtp extension invalid profile"));
   2043                  return;
   2044              }
   2045          
   2046              buf[8] = mki_len & 0xFF;
   2047              memcpy(&buf[9], ssl->dtls_srtp_info.mki_value, mki_len);
   2048          
   2049              *olen = 9 + mki_len;
   2050          }
   2051          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   2052          
   2053          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   2054          MBEDTLS_CHECK_RETURN_CRITICAL
   2055          static int ssl_write_hello_verify_request(mbedtls_ssl_context *ssl)
   2056          {
   2057              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2058              unsigned char *p = ssl->out_msg + 4;
   2059              unsigned char *cookie_len_byte;
   2060          
   2061              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write hello verify request"));
   2062          
   2063              /*
   2064               * struct {
   2065               *   ProtocolVersion server_version;
   2066               *   opaque cookie<0..2^8-1>;
   2067               * } HelloVerifyRequest;
   2068               */
   2069          
   2070              /* The RFC is not clear on this point, but sending the actual negotiated
   2071               * version looks like the most interoperable thing to do. */
   2072              mbedtls_ssl_write_version(p, ssl->conf->transport, ssl->tls_version);
   2073              MBEDTLS_SSL_DEBUG_BUF(3, "server version", p, 2);
   2074              p += 2;
   2075          
   2076              /* If we get here, f_cookie_check is not null */
   2077              if (ssl->conf->f_cookie_write == NULL) {
   2078                  MBEDTLS_SSL_DEBUG_MSG(1, ("inconsistent cookie callbacks"));
   2079                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2080              }
   2081          
   2082              /* Skip length byte until we know the length */
   2083              cookie_len_byte = p++;
   2084          
   2085              if ((ret = ssl->conf->f_cookie_write(ssl->conf->p_cookie,
   2086                                                   &p, ssl->out_buf + MBEDTLS_SSL_OUT_BUFFER_LEN,
   2087                                                   ssl->cli_id, ssl->cli_id_len)) != 0) {
   2088                  MBEDTLS_SSL_DEBUG_RET(1, "f_cookie_write", ret);
   2089                  return ret;
   2090              }
   2091          
   2092              *cookie_len_byte = (unsigned char) (p - (cookie_len_byte + 1));
   2093          
   2094              MBEDTLS_SSL_DEBUG_BUF(3, "cookie sent", cookie_len_byte + 1, *cookie_len_byte);
   2095          
   2096              ssl->out_msglen  = p - ssl->out_msg;
   2097              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2098              ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
   2099          
   2100              ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
   2101          
   2102              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   2103                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   2104                  return ret;
   2105              }
   2106          
   2107          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2108              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2109                  (ret = mbedtls_ssl_flight_transmit(ssl)) != 0) {
   2110                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_flight_transmit", ret);
   2111                  return ret;
   2112              }
   2113          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   2114          
   2115              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write hello verify request"));
   2116          
   2117              return 0;
   2118          }
   2119          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   2120          
   2121          static void ssl_handle_id_based_session_resumption(mbedtls_ssl_context *ssl)
   2122          {
   2123              int ret;
   2124              mbedtls_ssl_session session_tmp;
   2125              mbedtls_ssl_session * const session = ssl->session_negotiate;
   2126          
   2127              /* Resume is 0  by default, see ssl_handshake_init().
   2128               * It may be already set to 1 by ssl_parse_session_ticket_ext(). */
   2129              if (ssl->handshake->resume == 1) {
   2130                  return;
   2131              }
   2132              if (session->id_len == 0) {
   2133                  return;
   2134              }
   2135              if (ssl->conf->f_get_cache == NULL) {
   2136                  return;
   2137              }
   2138          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   2139              if (ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE) {
   2140                  return;
   2141              }
   2142          #endif
   2143          
   2144              mbedtls_ssl_session_init(&session_tmp);
   2145          
   2146              ret = ssl->conf->f_get_cache(ssl->conf->p_cache,
   2147                                           session->id,
   2148                                           session->id_len,
   2149                                           &session_tmp);
   2150              if (ret != 0) {
   2151                  goto exit;
   2152              }
   2153          
   2154              if (session->ciphersuite != session_tmp.ciphersuite) {
   2155                  /* Mismatch between cached and negotiated session */
   2156                  goto exit;
   2157              }
   2158          
   2159              /* Move semantics */
   2160              mbedtls_ssl_session_free(session);
   2161              *session = session_tmp;
   2162              memset(&session_tmp, 0, sizeof(session_tmp));
   2163          
   2164              MBEDTLS_SSL_DEBUG_MSG(3, ("session successfully restored from cache"));
   2165              ssl->handshake->resume = 1;
   2166          
   2167          exit:
   2168          
   2169              mbedtls_ssl_session_free(&session_tmp);
   2170          }
   2171          
   2172          MBEDTLS_CHECK_RETURN_CRITICAL
   2173          static int ssl_write_server_hello(mbedtls_ssl_context *ssl)
   2174          {
   2175          #if defined(MBEDTLS_HAVE_TIME)
   2176              mbedtls_time_t t;
   2177          #endif
   2178              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2179              size_t olen, ext_len = 0, n;
   2180              unsigned char *buf, *p;
   2181          
   2182              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write server hello"));
   2183          
   2184          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   2185              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2186                  ssl->handshake->cookie_verify_result != 0) {
   2187                  MBEDTLS_SSL_DEBUG_MSG(2, ("client hello was not authenticated"));
   2188                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= write server hello"));
   2189          
   2190                  return ssl_write_hello_verify_request(ssl);
   2191              }
   2192          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   2193          
   2194              if (ssl->conf->f_rng == NULL) {
   2195                  MBEDTLS_SSL_DEBUG_MSG(1, ("no RNG provided"));
   2196                  return MBEDTLS_ERR_SSL_NO_RNG;
   2197              }
   2198          
   2199              /*
   2200               *     0  .   0   handshake type
   2201               *     1  .   3   handshake length
   2202               *     4  .   5   protocol version
   2203               *     6  .   9   UNIX time()
   2204               *    10  .  37   random bytes
   2205               */
   2206              buf = ssl->out_msg;
   2207              p = buf + 4;
   2208          
   2209              mbedtls_ssl_write_version(p, ssl->conf->transport, ssl->tls_version);
   2210              p += 2;
   2211          
   2212              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, chosen version: [%d:%d]",
   2213                                        buf[4], buf[5]));
   2214          
   2215          #if defined(MBEDTLS_HAVE_TIME)
   2216              t = mbedtls_time(NULL);
   2217              MBEDTLS_PUT_UINT32_BE(t, p, 0);
   2218              p += 4;
   2219          
   2220              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, current time: %" MBEDTLS_PRINTF_LONGLONG,
   2221                                        (long long) t));
   2222          #else
   2223              if ((ret = ssl->conf->f_rng(ssl->conf->p_rng, p, 4)) != 0) {
   2224                  return ret;
   2225              }
   2226          
   2227              p += 4;
   2228          #endif /* MBEDTLS_HAVE_TIME */
   2229          
   2230              if ((ret = ssl->conf->f_rng(ssl->conf->p_rng, p, 20)) != 0) {
   2231                  return ret;
   2232              }
   2233              p += 20;
   2234          
   2235          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   2236              /*
   2237               * RFC 8446
   2238               * TLS 1.3 has a downgrade protection mechanism embedded in the server's
   2239               * random value. TLS 1.3 servers which negotiate TLS 1.2 or below in
   2240               * response to a ClientHello MUST set the last 8 bytes of their Random
   2241               * value specially in their ServerHello.
   2242               */
   2243              if (mbedtls_ssl_conf_is_tls13_enabled(ssl->conf)) {
   2244                  static const unsigned char magic_tls12_downgrade_string[] =
   2245                  { 'D', 'O', 'W', 'N', 'G', 'R', 'D', 1 };
   2246          
   2247                  MBEDTLS_STATIC_ASSERT(
   2248                      sizeof(magic_tls12_downgrade_string) == 8,
   2249                      "magic_tls12_downgrade_string does not have the expected size");
   2250          
   2251                  memcpy(p, magic_tls12_downgrade_string,
   2252                         sizeof(magic_tls12_downgrade_string));
   2253              } else
   2254          #endif
   2255              {
   2256                  if ((ret = ssl->conf->f_rng(ssl->conf->p_rng, p, 8)) != 0) {
   2257                      return ret;
   2258                  }
   2259              }
   2260              p += 8;
   2261          
   2262              memcpy(ssl->handshake->randbytes + 32, buf + 6, 32);
   2263          
   2264              MBEDTLS_SSL_DEBUG_BUF(3, "server hello, random bytes", buf + 6, 32);
   2265          
   2266              ssl_handle_id_based_session_resumption(ssl);
   2267          
   2268              if (ssl->handshake->resume == 0) {
   2269                  /*
   2270                   * New session, create a new session id,
   2271                   * unless we're about to issue a session ticket
   2272                   */
   2273                  ssl->state++;
   2274          
   2275          #if defined(MBEDTLS_HAVE_TIME)
   2276                  ssl->session_negotiate->start = mbedtls_time(NULL);
   2277          #endif
   2278          
   2279          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2280                  if (ssl->handshake->new_session_ticket != 0) {
   2281                      ssl->session_negotiate->id_len = n = 0;
   2282                      memset(ssl->session_negotiate->id, 0, 32);
   2283                  } else
   2284          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   2285                  {
   2286                      ssl->session_negotiate->id_len = n = 32;
   2287                      if ((ret = ssl->conf->f_rng(ssl->conf->p_rng, ssl->session_negotiate->id,
   2288                                                  n)) != 0) {
   2289                          return ret;
   2290                      }
   2291                  }
   2292              } else {
   2293                  /*
   2294                   * Resuming a session
   2295                   */
   2296                  n = ssl->session_negotiate->id_len;
   2297                  ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   2298          
   2299                  if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   2300                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   2301                      return ret;
   2302                  }
   2303              }
   2304          
   2305              /*
   2306               *    38  .  38     session id length
   2307               *    39  . 38+n    session id
   2308               *   39+n . 40+n    chosen ciphersuite
   2309               *   41+n . 41+n    chosen compression alg.
   2310               *   42+n . 43+n    extensions length
   2311               *   44+n . 43+n+m  extensions
   2312               */
   2313              *p++ = (unsigned char) ssl->session_negotiate->id_len;
   2314              memcpy(p, ssl->session_negotiate->id, ssl->session_negotiate->id_len);
   2315              p += ssl->session_negotiate->id_len;
   2316          
   2317              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, session id len.: %" MBEDTLS_PRINTF_SIZET, n));
   2318              MBEDTLS_SSL_DEBUG_BUF(3,   "server hello, session id", buf + 39, n);
   2319              MBEDTLS_SSL_DEBUG_MSG(3, ("%s session has been resumed",
   2320                                        ssl->handshake->resume ? "a" : "no"));
   2321          
   2322              MBEDTLS_PUT_UINT16_BE(ssl->session_negotiate->ciphersuite, p, 0);
   2323              p += 2;
   2324              *p++ = MBEDTLS_BYTE_0(MBEDTLS_SSL_COMPRESS_NULL);
   2325          
   2326              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, chosen ciphersuite: %s",
   2327                                        mbedtls_ssl_get_ciphersuite_name(ssl->session_negotiate->ciphersuite)));
   2328              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, compress alg.: 0x%02X",
   2329                                        (unsigned int) MBEDTLS_SSL_COMPRESS_NULL));
   2330          
   2331              /*
   2332               *  First write extensions, then the total length
   2333               */
   2334              ssl_write_renegotiation_ext(ssl, p + 2 + ext_len, &olen);
   2335              ext_len += olen;
   2336          
   2337          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   2338              ssl_write_max_fragment_length_ext(ssl, p + 2 + ext_len, &olen);
   2339              ext_len += olen;
   2340          #endif
   2341          
   2342          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   2343              ssl_write_cid_ext(ssl, p + 2 + ext_len, &olen);
   2344              ext_len += olen;
   2345          #endif
   2346          
   2347          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   2348              ssl_write_encrypt_then_mac_ext(ssl, p + 2 + ext_len, &olen);
   2349              ext_len += olen;
   2350          #endif
   2351          
   2352          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   2353              ssl_write_extended_ms_ext(ssl, p + 2 + ext_len, &olen);
   2354              ext_len += olen;
   2355          #endif
   2356          
   2357          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2358              ssl_write_session_ticket_ext(ssl, p + 2 + ext_len, &olen);
   2359              ext_len += olen;
   2360          #endif
   2361          
   2362          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED) || \
   2363              defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED) || \
   2364              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2365              const mbedtls_ssl_ciphersuite_t *suite =
   2366                  mbedtls_ssl_ciphersuite_from_id(ssl->session_negotiate->ciphersuite);
   2367              if (suite != NULL && mbedtls_ssl_ciphersuite_uses_ec(suite)) {
   2368                  ssl_write_supported_point_formats_ext(ssl, p + 2 + ext_len, &olen);
   2369                  ext_len += olen;
   2370              }
   2371          #endif
   2372          
   2373          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2374              ssl_write_ecjpake_kkpp_ext(ssl, p + 2 + ext_len, &olen);
   2375              ext_len += olen;
   2376          #endif
   2377          
   2378          #if defined(MBEDTLS_SSL_ALPN)
   2379              unsigned char *end = buf + MBEDTLS_SSL_OUT_CONTENT_LEN - 4;
   2380              if ((ret = mbedtls_ssl_write_alpn_ext(ssl, p + 2 + ext_len, end, &olen))
   2381                  != 0) {
   2382                  return ret;
   2383              }
   2384          
   2385              ext_len += olen;
   2386          #endif
   2387          
   2388          #if defined(MBEDTLS_SSL_DTLS_SRTP)
   2389              ssl_write_use_srtp_ext(ssl, p + 2 + ext_len, &olen);
   2390              ext_len += olen;
   2391          #endif
   2392          
   2393              MBEDTLS_SSL_DEBUG_MSG(3, ("server hello, total extension length: %" MBEDTLS_PRINTF_SIZET,
   2394                                        ext_len));
   2395          
   2396              if (ext_len > 0) {
   2397                  MBEDTLS_PUT_UINT16_BE(ext_len, p, 0);
   2398                  p += 2 + ext_len;
   2399              }
   2400          
   2401              ssl->out_msglen  = p - buf;
   2402              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2403              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
   2404          
   2405              ret = mbedtls_ssl_write_handshake_msg(ssl);
   2406          
   2407              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write server hello"));
   2408          
   2409              return ret;
   2410          }
   2411          
   2412          #if !defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   2413          MBEDTLS_CHECK_RETURN_CRITICAL
   2414          static int ssl_write_certificate_request(mbedtls_ssl_context *ssl)
   2415          {
   2416              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2417                  ssl->handshake->ciphersuite_info;
   2418          
   2419              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate request"));
   2420          
   2421              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   2422                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate request"));
   2423                  ssl->state++;
   2424                  return 0;
   2425              }
   2426          
   2427              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   2428              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   2429          }
   2430          #else /* !MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   2431          MBEDTLS_CHECK_RETURN_CRITICAL
   2432          static int ssl_write_certificate_request(mbedtls_ssl_context *ssl)
   2433          {
   2434              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2435              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2436                  ssl->handshake->ciphersuite_info;
   2437              uint16_t dn_size, total_dn_size; /* excluding length bytes */
   2438              size_t ct_len, sa_len; /* including length bytes */
   2439              unsigned char *buf, *p;
   2440              const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN;
   2441              const mbedtls_x509_crt *crt;
   2442              int authmode;
   2443          
   2444              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate request"));
   2445          
   2446              ssl->state++;
   2447          
   2448          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2449              if (ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET) {
   2450                  authmode = ssl->handshake->sni_authmode;
   2451              } else
   2452          #endif
   2453              authmode = ssl->conf->authmode;
   2454          
   2455              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info) ||
   2456                  authmode == MBEDTLS_SSL_VERIFY_NONE) {
   2457                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate request"));
   2458                  return 0;
   2459              }
   2460          
   2461              /*
   2462               *     0  .   0   handshake type
   2463               *     1  .   3   handshake length
   2464               *     4  .   4   cert type count
   2465               *     5  .. m-1  cert types
   2466               *     m  .. m+1  sig alg length (TLS 1.2 only)
   2467               *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)
   2468               *     n  .. n+1  length of all DNs
   2469               *    n+2 .. n+3  length of DN 1
   2470               *    n+4 .. ...  Distinguished Name #1
   2471               *    ... .. ...  length of DN 2, etc.
   2472               */
   2473              buf = ssl->out_msg;
   2474              p = buf + 4;
   2475          
   2476              /*
   2477               * Supported certificate types
   2478               *
   2479               *     ClientCertificateType certificate_types<1..2^8-1>;
   2480               *     enum { (255) } ClientCertificateType;
   2481               */
   2482              ct_len = 0;
   2483          
   2484          #if defined(MBEDTLS_RSA_C)
   2485              p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;
   2486          #endif
   2487          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   2488              p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;
   2489          #endif
   2490          
   2491              p[0] = (unsigned char) ct_len++;
   2492              p += ct_len;
   2493          
   2494              sa_len = 0;
   2495          
   2496              /*
   2497               * Add signature_algorithms for verify (TLS 1.2)
   2498               *
   2499               *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;
   2500               *
   2501               *     struct {
   2502               *           HashAlgorithm hash;
   2503               *           SignatureAlgorithm signature;
   2504               *     } SignatureAndHashAlgorithm;
   2505               *
   2506               *     enum { (255) } HashAlgorithm;
   2507               *     enum { (255) } SignatureAlgorithm;
   2508               */
   2509              const uint16_t *sig_alg = mbedtls_ssl_get_sig_algs(ssl);
   2510              if (sig_alg == NULL) {
   2511                  return MBEDTLS_ERR_SSL_BAD_CONFIG;
   2512              }
   2513          
   2514              for (; *sig_alg != MBEDTLS_TLS_SIG_NONE; sig_alg++) {
   2515                  unsigned char hash = MBEDTLS_BYTE_1(*sig_alg);
   2516          
   2517                  if (mbedtls_ssl_set_calc_verify_md(ssl, hash)) {
   2518                      continue;
   2519                  }
   2520                  if (!mbedtls_ssl_sig_alg_is_supported(ssl, *sig_alg)) {
   2521                      continue;
   2522                  }
   2523          
   2524                  /* Write elements at offsets starting from 1 (offset 0 is for the
   2525                   * length). Thus the offset of each element is the length of the
   2526                   * partial list including that element. */
   2527                  sa_len += 2;
   2528                  MBEDTLS_PUT_UINT16_BE(*sig_alg, p, sa_len);
   2529          
   2530              }
   2531          
   2532              /* Fill in list length. */
   2533              MBEDTLS_PUT_UINT16_BE(sa_len, p, 0);
   2534              sa_len += 2;
   2535              p += sa_len;
   2536          
   2537              /*
   2538               * DistinguishedName certificate_authorities<0..2^16-1>;
   2539               * opaque DistinguishedName<1..2^16-1>;
   2540               */
   2541              p += 2;
   2542          
   2543              total_dn_size = 0;
   2544          
   2545              if (ssl->conf->cert_req_ca_list ==  MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED) {
   2546                  /* NOTE: If trusted certificates are provisioned
   2547                   *       via a CA callback (configured through
   2548                   *       `mbedtls_ssl_conf_ca_cb()`, then the
   2549                   *       CertificateRequest is currently left empty. */
   2550          
   2551          #if defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   2552          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2553                  if (ssl->handshake->dn_hints != NULL) {
   2554                      crt = ssl->handshake->dn_hints;
   2555                  } else
   2556          #endif
   2557                  if (ssl->conf->dn_hints != NULL) {
   2558                      crt = ssl->conf->dn_hints;
   2559                  } else
   2560          #endif
   2561          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2562                  if (ssl->handshake->sni_ca_chain != NULL) {
   2563                      crt = ssl->handshake->sni_ca_chain;
   2564                  } else
   2565          #endif
   2566                  crt = ssl->conf->ca_chain;
   2567          
   2568                  while (crt != NULL && crt->version != 0) {
   2569                      /* It follows from RFC 5280 A.1 that this length
   2570                       * can be represented in at most 11 bits. */
   2571                      dn_size = (uint16_t) crt->subject_raw.len;
   2572          
   2573                      if (end < p || (size_t) (end - p) < 2 + (size_t) dn_size) {
   2574                          MBEDTLS_SSL_DEBUG_MSG(1, ("skipping CAs: buffer too short"));
   2575                          break;
   2576                      }
   2577          
   2578                      MBEDTLS_PUT_UINT16_BE(dn_size, p, 0);
   2579                      p += 2;
   2580                      memcpy(p, crt->subject_raw.p, dn_size);
   2581                      p += dn_size;
   2582          
   2583                      MBEDTLS_SSL_DEBUG_BUF(3, "requested DN", p - dn_size, dn_size);
   2584          
   2585                      total_dn_size += 2 + dn_size;
   2586                      crt = crt->next;
   2587                  }
   2588              }
   2589          
   2590              ssl->out_msglen  = p - buf;
   2591              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2592              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
   2593              MBEDTLS_PUT_UINT16_BE(total_dn_size, ssl->out_msg, 4 + ct_len + sa_len);
   2594          
   2595              ret = mbedtls_ssl_write_handshake_msg(ssl);
   2596          
   2597              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write certificate request"));
   2598          
   2599              return ret;
   2600          }
   2601          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   2602          
   2603          #if defined(MBEDTLS_USE_PSA_CRYPTO) &&                      \
   2604              (defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   2605              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED))
   2606          MBEDTLS_CHECK_RETURN_CRITICAL
   2607          static int ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
   2608          {
   2609              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2610              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2611              mbedtls_pk_context *pk;
   2612              mbedtls_pk_type_t pk_type;
   2613              psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
   2614          #if !defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   2615              uint16_t tls_id = 0;
   2616              psa_key_type_t key_type = PSA_KEY_TYPE_NONE;
   2617              size_t key_len;
   2618              mbedtls_ecp_group_id grp_id;
   2619              unsigned char buf[PSA_KEY_EXPORT_ECC_KEY_PAIR_MAX_SIZE(PSA_VENDOR_ECC_MAX_CURVE_BITS)];
   2620              mbedtls_ecp_keypair *key;
   2621          #endif /* !MBEDTLS_PK_USE_PSA_EC_DATA */
   2622          
   2623              pk = mbedtls_ssl_own_key(ssl);
   2624          
   2625              if (pk == NULL) {
   2626                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2627              }
   2628          
   2629              pk_type = mbedtls_pk_get_type(pk);
   2630          
   2631              switch (pk_type) {
   2632                  case MBEDTLS_PK_OPAQUE:
   2633          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   2634                  case MBEDTLS_PK_ECKEY:
   2635                  case MBEDTLS_PK_ECKEY_DH:
   2636                  case MBEDTLS_PK_ECDSA:
   2637          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   2638                      if (!mbedtls_pk_can_do(pk, MBEDTLS_PK_ECKEY)) {
   2639                          return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   2640                      }
   2641          
   2642                      ssl->handshake->xxdh_psa_privkey = pk->priv_id;
   2643          
   2644                      /* Key should not be destroyed in the TLS library */
   2645                      ssl->handshake->xxdh_psa_privkey_is_external = 1;
   2646          
   2647                      status = psa_get_key_attributes(ssl->handshake->xxdh_psa_privkey,
   2648                                                      &key_attributes);
   2649                      if (status != PSA_SUCCESS) {
   2650                          ssl->handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   2651                          return PSA_TO_MBEDTLS_ERR(status);
   2652                      }
   2653          
   2654                      ssl->handshake->xxdh_psa_type = psa_get_key_type(&key_attributes);
   2655                      ssl->handshake->xxdh_psa_bits = psa_get_key_bits(&key_attributes);
   2656          
   2657                      psa_reset_key_attributes(&key_attributes);
   2658          
   2659                      ret = 0;
   2660                      break;
   2661          #if !defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   2662                  case MBEDTLS_PK_ECKEY:
   2663                  case MBEDTLS_PK_ECKEY_DH:
   2664                  case MBEDTLS_PK_ECDSA:
   2665                      key = mbedtls_pk_ec_rw(*pk);
   2666                      grp_id = mbedtls_pk_get_group_id(pk);
   2667                      if (grp_id == MBEDTLS_ECP_DP_NONE) {
   2668                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2669                      }
   2670                      tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(grp_id);
   2671                      if (tls_id == 0) {
   2672                          /* This elliptic curve is not supported */
   2673                          return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   2674                      }
   2675          
   2676                      /* If the above conversion to TLS ID was fine, then also this one will
   2677                         be, so there is no need to check the return value here */
   2678                      mbedtls_ssl_get_psa_curve_info_from_tls_id(tls_id, &key_type,
   2679                                                                 &ssl->handshake->xxdh_psa_bits);
   2680          
   2681                      ssl->handshake->xxdh_psa_type = key_type;
   2682          
   2683                      key_attributes = psa_key_attributes_init();
   2684                      psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   2685                      psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
   2686                      psa_set_key_type(&key_attributes,
   2687                                       PSA_KEY_TYPE_ECC_KEY_PAIR(ssl->handshake->xxdh_psa_type));
   2688                      psa_set_key_bits(&key_attributes, ssl->handshake->xxdh_psa_bits);
   2689          
   2690                      key_len = PSA_BITS_TO_BYTES(key->grp.pbits);
   2691                      ret = mbedtls_ecp_write_key(key, buf, key_len);
   2692                      if (ret != 0) {
   2693                          mbedtls_platform_zeroize(buf, sizeof(buf));
   2694                          break;
   2695                      }
   2696          
   2697                      status = psa_import_key(&key_attributes, buf, key_len,
   2698                                              &ssl->handshake->xxdh_psa_privkey);
   2699                      if (status != PSA_SUCCESS) {
   2700                          ret = PSA_TO_MBEDTLS_ERR(status);
   2701                          mbedtls_platform_zeroize(buf, sizeof(buf));
   2702                          break;
   2703                      }
   2704          
   2705                      mbedtls_platform_zeroize(buf, sizeof(buf));
   2706                      ret = 0;
   2707                      break;
   2708          #endif /* !MBEDTLS_PK_USE_PSA_EC_DATA */
   2709                  default:
   2710                      ret = MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   2711              }
   2712          
   2713              return ret;
   2714          }
   2715          #elif defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   2716              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2717          MBEDTLS_CHECK_RETURN_CRITICAL
   2718          static int ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
   2719          {
   2720              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2721          
   2722              const mbedtls_pk_context *private_key = mbedtls_ssl_own_key(ssl);
   2723              if (private_key == NULL) {
   2724                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no server private key"));
   2725                  return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
   2726              }
   2727          
   2728              if (!mbedtls_pk_can_do(private_key, MBEDTLS_PK_ECKEY)) {
   2729                  MBEDTLS_SSL_DEBUG_MSG(1, ("server key not ECDH capable"));
   2730                  return MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH;
   2731              }
   2732          
   2733              if ((ret = mbedtls_ecdh_get_params(&ssl->handshake->ecdh_ctx,
   2734                                                 mbedtls_pk_ec_ro(*mbedtls_ssl_own_key(ssl)),
   2735                                                 MBEDTLS_ECDH_OURS)) != 0) {
   2736                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ecdh_get_params"), ret);
   2737                  return ret;
   2738              }
   2739          
   2740              return 0;
   2741          }
   2742          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
   2743                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2744          
   2745          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED) && \
   2746              defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   2747          MBEDTLS_CHECK_RETURN_CRITICAL
   2748          static int ssl_resume_server_key_exchange(mbedtls_ssl_context *ssl,
   2749                                                    size_t *signature_len)
   2750          {
   2751              /* Append the signature to ssl->out_msg, leaving 2 bytes for the
   2752               * signature length which will be added in ssl_write_server_key_exchange
   2753               * after the call to ssl_prepare_server_key_exchange.
   2754               * ssl_write_server_key_exchange also takes care of incrementing
   2755               * ssl->out_msglen. */
   2756              unsigned char *sig_start = ssl->out_msg + ssl->out_msglen + 2;
   2757              size_t sig_max_len = (ssl->out_buf + MBEDTLS_SSL_OUT_CONTENT_LEN
   2758                                    - sig_start);
   2759              int ret = ssl->conf->f_async_resume(ssl,
   2760                                                  sig_start, signature_len, sig_max_len);
   2761              if (ret != MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {
   2762                  ssl->handshake->async_in_progress = 0;
   2763                  mbedtls_ssl_set_async_operation_data(ssl, NULL);
   2764              }
   2765              MBEDTLS_SSL_DEBUG_RET(2, "ssl_resume_server_key_exchange", ret);
   2766              return ret;
   2767          }
   2768          #endif /* defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED) &&
   2769                    defined(MBEDTLS_SSL_ASYNC_PRIVATE) */
   2770          
   2771          /* Prepare the ServerKeyExchange message, up to and including
   2772           * calculating the signature if any, but excluding formatting the
   2773           * signature and sending the message. */
   2774          MBEDTLS_CHECK_RETURN_CRITICAL
   2775          static int ssl_prepare_server_key_exchange(mbedtls_ssl_context *ssl,
   2776                                                     size_t *signature_len)
   2777          {
   2778              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2779                  ssl->handshake->ciphersuite_info;
   2780          
   2781          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PFS_ENABLED)
   2782          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   2783              unsigned char *dig_signed = NULL;
   2784          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
   2785          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PFS_ENABLED */
   2786          
   2787              (void) ciphersuite_info; /* unused in some configurations */
   2788          #if !defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   2789              (void) signature_len;
   2790          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
   2791          
   2792          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   2793          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   2794              size_t out_buf_len = ssl->out_buf_len - (ssl->out_msg - ssl->out_buf);
   2795          #else
   2796              size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN - (ssl->out_msg - ssl->out_buf);
   2797          #endif
   2798          #endif
   2799          
   2800              ssl->out_msglen = 4; /* header (type:1, length:3) to be written later */
   2801          
   2802              /*
   2803               *
   2804               * Part 1: Provide key exchange parameters for chosen ciphersuite.
   2805               *
   2806               */
   2807          
   2808              /*
   2809               * - ECJPAKE key exchanges
   2810               */
   2811          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2812              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   2813                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2814          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2815                  unsigned char *out_p = ssl->out_msg + ssl->out_msglen;
   2816                  unsigned char *end_p = ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN -
   2817                                         ssl->out_msglen;
   2818                  size_t output_offset = 0;
   2819                  size_t output_len = 0;
   2820          
   2821                  /*
   2822                   * The first 3 bytes are:
   2823                   * [0] MBEDTLS_ECP_TLS_NAMED_CURVE
   2824                   * [1, 2] elliptic curve's TLS ID
   2825                   *
   2826                   * However since we only support secp256r1 for now, we hardcode its
   2827                   * TLS ID here
   2828                   */
   2829                  uint16_t tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(
   2830                      MBEDTLS_ECP_DP_SECP256R1);
   2831                  if (tls_id == 0) {
   2832                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2833                  }
   2834                  *out_p = MBEDTLS_ECP_TLS_NAMED_CURVE;
   2835                  MBEDTLS_PUT_UINT16_BE(tls_id, out_p, 1);
   2836                  output_offset += 3;
   2837          
   2838                  ret = mbedtls_psa_ecjpake_write_round(&ssl->handshake->psa_pake_ctx,
   2839                                                        out_p + output_offset,
   2840                                                        end_p - out_p - output_offset, &output_len,
   2841                                                        MBEDTLS_ECJPAKE_ROUND_TWO);
   2842                  if (ret != 0) {
   2843                      psa_destroy_key(ssl->handshake->psa_pake_password);
   2844                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   2845                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_output", ret);
   2846                      return ret;
   2847                  }
   2848          
   2849                  output_offset += output_len;
   2850                  ssl->out_msglen += output_offset;
   2851          #else
   2852                  size_t len = 0;
   2853          
   2854                  ret = mbedtls_ecjpake_write_round_two(
   2855                      &ssl->handshake->ecjpake_ctx,
   2856                      ssl->out_msg + ssl->out_msglen,
   2857                      MBEDTLS_SSL_OUT_CONTENT_LEN - ssl->out_msglen, &len,
   2858                      ssl->conf->f_rng, ssl->conf->p_rng);
   2859                  if (ret != 0) {
   2860                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_write_round_two", ret);
   2861                      return ret;
   2862                  }
   2863          
   2864                  ssl->out_msglen += len;
   2865          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2866              }
   2867          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2868          
   2869              /*
   2870               * For (EC)DHE key exchanges with PSK, parameters are prefixed by support
   2871               * identity hint (RFC 4279, Sec. 3). Until someone needs this feature,
   2872               * we use empty support identity hints here.
   2873               **/
   2874          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)   || \
   2875              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   2876              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2877                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   2878                  ssl->out_msg[ssl->out_msglen++] = 0x00;
   2879                  ssl->out_msg[ssl->out_msglen++] = 0x00;
   2880              }
   2881          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||
   2882                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   2883          
   2884              /*
   2885               * - DHE key exchanges
   2886               */
   2887          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_DHE_ENABLED)
   2888              if (mbedtls_ssl_ciphersuite_uses_dhe(ciphersuite_info)) {
   2889                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2890                  size_t len = 0;
   2891          
   2892                  if (ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL) {
   2893                      MBEDTLS_SSL_DEBUG_MSG(1, ("no DH parameters set"));
   2894                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2895                  }
   2896          
   2897                  /*
   2898                   * Ephemeral DH parameters:
   2899                   *
   2900                   * struct {
   2901                   *     opaque dh_p<1..2^16-1>;
   2902                   *     opaque dh_g<1..2^16-1>;
   2903                   *     opaque dh_Ys<1..2^16-1>;
   2904                   * } ServerDHParams;
   2905                   */
   2906                  if ((ret = mbedtls_dhm_set_group(&ssl->handshake->dhm_ctx,
   2907                                                   &ssl->conf->dhm_P,
   2908                                                   &ssl->conf->dhm_G)) != 0) {
   2909                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_set_group", ret);
   2910                      return ret;
   2911                  }
   2912          
   2913                  if ((ret = mbedtls_dhm_make_params(
   2914                           &ssl->handshake->dhm_ctx,
   2915                           (int) mbedtls_dhm_get_len(&ssl->handshake->dhm_ctx),
   2916                           ssl->out_msg + ssl->out_msglen, &len,
   2917                           ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   2918                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_make_params", ret);
   2919                      return ret;
   2920                  }
   2921          
   2922          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   2923                  dig_signed = ssl->out_msg + ssl->out_msglen;
   2924          #endif
   2925          
   2926                  ssl->out_msglen += len;
   2927          
   2928                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: X ", &ssl->handshake->dhm_ctx.X);
   2929                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: P ", &ssl->handshake->dhm_ctx.P);
   2930                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: G ", &ssl->handshake->dhm_ctx.G);
   2931                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: GX", &ssl->handshake->dhm_ctx.GX);
   2932              }
   2933          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_DHE_ENABLED */
   2934          
   2935              /*
   2936               * - ECDHE key exchanges
   2937               */
   2938          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDHE_ENABLED)
   2939              if (mbedtls_ssl_ciphersuite_uses_ecdhe(ciphersuite_info)) {
   2940                  /*
   2941                   * Ephemeral ECDH parameters:
   2942                   *
   2943                   * struct {
   2944                   *     ECParameters curve_params;
   2945                   *     ECPoint      public;
   2946                   * } ServerECDHParams;
   2947                   */
   2948                  uint16_t *curr_tls_id = ssl->handshake->curves_tls_id;
   2949                  const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
   2950                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2951                  size_t len = 0;
   2952          
   2953                  /* Match our preference list against the offered curves */
   2954                  if ((group_list == NULL) || (curr_tls_id == NULL)) {
   2955                      return MBEDTLS_ERR_SSL_BAD_CONFIG;
   2956                  }
   2957                  for (; *group_list != 0; group_list++) {
   2958                      for (curr_tls_id = ssl->handshake->curves_tls_id;
   2959                           *curr_tls_id != 0; curr_tls_id++) {
   2960                          if (*curr_tls_id == *group_list) {
   2961                              goto curve_matching_done;
   2962                          }
   2963                      }
   2964                  }
   2965          
   2966          curve_matching_done:
   2967                  if (*curr_tls_id == 0) {
   2968                      MBEDTLS_SSL_DEBUG_MSG(1, ("no matching curve for ECDHE"));
   2969                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   2970                  }
   2971          
   2972                  MBEDTLS_SSL_DEBUG_MSG(2, ("ECDHE curve: %s",
   2973                                            mbedtls_ssl_get_curve_name_from_tls_id(*curr_tls_id)));
   2974          
   2975          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2976                  psa_status_t status = PSA_ERROR_GENERIC_ERROR;
   2977                  psa_key_attributes_t key_attributes;
   2978                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   2979                  uint8_t *p = ssl->out_msg + ssl->out_msglen;
   2980                  const size_t header_size = 4; // curve_type(1), namedcurve(2),
   2981                                                // data length(1)
   2982                  const size_t data_length_size = 1;
   2983                  psa_key_type_t key_type = PSA_KEY_TYPE_NONE;
   2984                  size_t ec_bits = 0;
   2985          
   2986                  MBEDTLS_SSL_DEBUG_MSG(1, ("Perform PSA-based ECDH computation."));
   2987          
   2988                  /* Convert EC's TLS ID to PSA key type. */
   2989                  if (mbedtls_ssl_get_psa_curve_info_from_tls_id(*curr_tls_id,
   2990                                                                 &key_type,
   2991                                                                 &ec_bits) == PSA_ERROR_NOT_SUPPORTED) {
   2992                      MBEDTLS_SSL_DEBUG_MSG(1, ("Invalid ecc group parse."));
   2993                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   2994                  }
   2995                  handshake->xxdh_psa_type = key_type;
   2996                  handshake->xxdh_psa_bits = ec_bits;
   2997          
   2998                  key_attributes = psa_key_attributes_init();
   2999                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   3000                  psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
   3001                  psa_set_key_type(&key_attributes, handshake->xxdh_psa_type);
   3002                  psa_set_key_bits(&key_attributes, handshake->xxdh_psa_bits);
   3003          
   3004                  /*
   3005                   * ECParameters curve_params
   3006                   *
   3007                   * First byte is curve_type, always named_curve
   3008                   */
   3009                  *p++ = MBEDTLS_ECP_TLS_NAMED_CURVE;
   3010          
   3011                  /*
   3012                   * Next two bytes are the namedcurve value
   3013                   */
   3014                  MBEDTLS_PUT_UINT16_BE(*curr_tls_id, p, 0);
   3015                  p += 2;
   3016          
   3017                  /* Generate ECDH private key. */
   3018                  status = psa_generate_key(&key_attributes,
   3019                                            &handshake->xxdh_psa_privkey);
   3020                  if (status != PSA_SUCCESS) {
   3021                      ret = PSA_TO_MBEDTLS_ERR(status);
   3022                      MBEDTLS_SSL_DEBUG_RET(1, "psa_generate_key", ret);
   3023                      return ret;
   3024                  }
   3025          
   3026                  /*
   3027                   * ECPoint  public
   3028                   *
   3029                   * First byte is data length.
   3030                   * It will be filled later. p holds now the data length location.
   3031                   */
   3032          
   3033                  /* Export the public part of the ECDH private key from PSA.
   3034                   * Make one byte space for the length.
   3035                   */
   3036                  unsigned char *own_pubkey = p + data_length_size;
   3037          
   3038                  size_t own_pubkey_max_len = (size_t) (MBEDTLS_SSL_OUT_CONTENT_LEN
   3039                                                        - (own_pubkey - ssl->out_msg));
   3040          
   3041                  status = psa_export_public_key(handshake->xxdh_psa_privkey,
   3042                                                 own_pubkey, own_pubkey_max_len,
   3043                                                 &len);
   3044                  if (status != PSA_SUCCESS) {
   3045                      ret = PSA_TO_MBEDTLS_ERR(status);
   3046                      MBEDTLS_SSL_DEBUG_RET(1, "psa_export_public_key", ret);
   3047                      (void) psa_destroy_key(handshake->xxdh_psa_privkey);
   3048                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3049                      return ret;
   3050                  }
   3051          
   3052                  /* Store the length of the exported public key. */
   3053                  *p = (uint8_t) len;
   3054          
   3055                  /* Determine full message length. */
   3056                  len += header_size;
   3057          #else
   3058                  mbedtls_ecp_group_id curr_grp_id =
   3059                      mbedtls_ssl_get_ecp_group_id_from_tls_id(*curr_tls_id);
   3060          
   3061                  if ((ret = mbedtls_ecdh_setup(&ssl->handshake->ecdh_ctx,
   3062                                                curr_grp_id)) != 0) {
   3063                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecp_group_load", ret);
   3064                      return ret;
   3065                  }
   3066          
   3067                  if ((ret = mbedtls_ecdh_make_params(
   3068                           &ssl->handshake->ecdh_ctx, &len,
   3069                           ssl->out_msg + ssl->out_msglen,
   3070                           MBEDTLS_SSL_OUT_CONTENT_LEN - ssl->out_msglen,
   3071                           ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   3072                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_make_params", ret);
   3073                      return ret;
   3074                  }
   3075          
   3076                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   3077                                         MBEDTLS_DEBUG_ECDH_Q);
   3078          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   3079          
   3080          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   3081                  dig_signed = ssl->out_msg + ssl->out_msglen;
   3082          #endif
   3083          
   3084                  ssl->out_msglen += len;
   3085              }
   3086          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDHE_ENABLED */
   3087          
   3088              /*
   3089               *
   3090               * Part 2: For key exchanges involving the server signing the
   3091               *         exchange parameters, compute and add the signature here.
   3092               *
   3093               */
   3094          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   3095              if (mbedtls_ssl_ciphersuite_uses_server_signature(ciphersuite_info)) {
   3096                  if (dig_signed == NULL) {
   3097                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3098                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3099                  }
   3100          
   3101                  size_t dig_signed_len = ssl->out_msg + ssl->out_msglen - dig_signed;
   3102                  size_t hashlen = 0;
   3103                  unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   3104          
   3105                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3106          
   3107                  /*
   3108                   * 2.1: Choose hash algorithm:
   3109                   *      For TLS 1.2, obey signature-hash-algorithm extension
   3110                   *      to choose appropriate hash.
   3111                   */
   3112          
   3113                  mbedtls_pk_type_t sig_alg =
   3114                      mbedtls_ssl_get_ciphersuite_sig_pk_alg(ciphersuite_info);
   3115          
   3116                  unsigned int sig_hash =
   3117                      mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg(
   3118                          ssl, mbedtls_ssl_sig_from_pk_alg(sig_alg));
   3119          
   3120                  mbedtls_md_type_t md_alg = mbedtls_ssl_md_alg_from_hash(sig_hash);
   3121          
   3122                  /*    For TLS 1.2, obey signature-hash-algorithm extension
   3123                   *    (RFC 5246, Sec. 7.4.1.4.1). */
   3124                  if (sig_alg == MBEDTLS_PK_NONE || md_alg == MBEDTLS_MD_NONE) {
   3125                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3126                      /* (... because we choose a cipher suite
   3127                       *      only if there is a matching hash.) */
   3128                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3129                  }
   3130          
   3131                  MBEDTLS_SSL_DEBUG_MSG(3, ("pick hash algorithm %u for signing", (unsigned) md_alg));
   3132          
   3133                  /*
   3134                   * 2.2: Compute the hash to be signed
   3135                   */
   3136                  if (md_alg != MBEDTLS_MD_NONE) {
   3137                      ret = mbedtls_ssl_get_key_exchange_md_tls1_2(ssl, hash, &hashlen,
   3138                                                                   dig_signed,
   3139                                                                   dig_signed_len,
   3140                                                                   md_alg);
   3141                      if (ret != 0) {
   3142                          return ret;
   3143                      }
   3144                  } else {
   3145                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3146                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3147                  }
   3148          
   3149                  MBEDTLS_SSL_DEBUG_BUF(3, "parameters hash", hash, hashlen);
   3150          
   3151                  /*
   3152                   * 2.3: Compute and add the signature
   3153                   */
   3154                  /*
   3155                   * We need to specify signature and hash algorithm explicitly through
   3156                   * a prefix to the signature.
   3157                   *
   3158                   * struct {
   3159                   *    HashAlgorithm hash;
   3160                   *    SignatureAlgorithm signature;
   3161                   * } SignatureAndHashAlgorithm;
   3162                   *
   3163                   * struct {
   3164                   *    SignatureAndHashAlgorithm algorithm;
   3165                   *    opaque signature<0..2^16-1>;
   3166                   * } DigitallySigned;
   3167                   *
   3168                   */
   3169          
   3170                  ssl->out_msg[ssl->out_msglen++] = mbedtls_ssl_hash_from_md_alg(md_alg);
   3171                  ssl->out_msg[ssl->out_msglen++] = mbedtls_ssl_sig_from_pk_alg(sig_alg);
   3172          
   3173          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3174                  if (ssl->conf->f_async_sign_start != NULL) {
   3175                      ret = ssl->conf->f_async_sign_start(ssl,
   3176                                                          mbedtls_ssl_own_cert(ssl),
   3177                                                          md_alg, hash, hashlen);
   3178                      switch (ret) {
   3179                          case MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH:
   3180                              /* act as if f_async_sign was null */
   3181                              break;
   3182                          case 0:
   3183                              ssl->handshake->async_in_progress = 1;
   3184                              return ssl_resume_server_key_exchange(ssl, signature_len);
   3185                          case MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS:
   3186                              ssl->handshake->async_in_progress = 1;
   3187                              return MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS;
   3188                          default:
   3189                              MBEDTLS_SSL_DEBUG_RET(1, "f_async_sign_start", ret);
   3190                              return ret;
   3191                      }
   3192                  }
   3193          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3194          
   3195                  if (mbedtls_ssl_own_key(ssl) == NULL) {
   3196                      MBEDTLS_SSL_DEBUG_MSG(1, ("got no private key"));
   3197                      return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
   3198                  }
   3199          
   3200                  /* Append the signature to ssl->out_msg, leaving 2 bytes for the
   3201                   * signature length which will be added in ssl_write_server_key_exchange
   3202                   * after the call to ssl_prepare_server_key_exchange.
   3203                   * ssl_write_server_key_exchange also takes care of incrementing
   3204                   * ssl->out_msglen. */
   3205                  if ((ret = mbedtls_pk_sign(mbedtls_ssl_own_key(ssl),
   3206                                             md_alg, hash, hashlen,
   3207                                             ssl->out_msg + ssl->out_msglen + 2,
   3208                                             out_buf_len - ssl->out_msglen - 2,
   3209                                             signature_len,
   3210                                             ssl->conf->f_rng,
   3211                                             ssl->conf->p_rng)) != 0) {
   3212                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_pk_sign", ret);
   3213                      return ret;
   3214                  }
   3215              }
   3216          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
   3217          
   3218              return 0;
   3219          }
   3220          
   3221          /* Prepare the ServerKeyExchange message and send it. For ciphersuites
   3222           * that do not include a ServerKeyExchange message, do nothing. Either
   3223           * way, if successful, move on to the next step in the SSL state
   3224           * machine. */
   3225          MBEDTLS_CHECK_RETURN_CRITICAL
   3226          static int ssl_write_server_key_exchange(mbedtls_ssl_context *ssl)
   3227          {
   3228              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3229              size_t signature_len = 0;
   3230          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_NON_PFS_ENABLED)
   3231              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3232                  ssl->handshake->ciphersuite_info;
   3233          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_NON_PFS_ENABLED */
   3234          
   3235              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write server key exchange"));
   3236          
   3237          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_NON_PFS_ENABLED)
   3238              /* Extract static ECDH parameters and abort if ServerKeyExchange
   3239               * is not needed. */
   3240              if (mbedtls_ssl_ciphersuite_no_pfs(ciphersuite_info)) {
   3241                  /* For suites involving ECDH, extract DH parameters
   3242                   * from certificate at this point. */
   3243          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_ENABLED)
   3244                  if (mbedtls_ssl_ciphersuite_uses_ecdh(ciphersuite_info)) {
   3245                      ret = ssl_get_ecdh_params_from_cert(ssl);
   3246                      if (ret != 0) {
   3247                          MBEDTLS_SSL_DEBUG_RET(1, "ssl_get_ecdh_params_from_cert", ret);
   3248                          return ret;
   3249                      }
   3250                  }
   3251          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_ECDH_ENABLED */
   3252          
   3253                  /* Key exchanges not involving ephemeral keys don't use
   3254                   * ServerKeyExchange, so end here. */
   3255                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write server key exchange"));
   3256                  ssl->state++;
   3257                  return 0;
   3258              }
   3259          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_NON_PFS_ENABLED */
   3260          
   3261          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED) && \
   3262              defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3263              /* If we have already prepared the message and there is an ongoing
   3264               * signature operation, resume signing. */
   3265              if (ssl->handshake->async_in_progress != 0) {
   3266                  MBEDTLS_SSL_DEBUG_MSG(2, ("resuming signature operation"));
   3267                  ret = ssl_resume_server_key_exchange(ssl, &signature_len);
   3268              } else
   3269          #endif /* defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED) &&
   3270                    defined(MBEDTLS_SSL_ASYNC_PRIVATE) */
   3271              {
   3272                  /* ServerKeyExchange is needed. Prepare the message. */
   3273                  ret = ssl_prepare_server_key_exchange(ssl, &signature_len);
   3274              }
   3275          
   3276              if (ret != 0) {
   3277                  /* If we're starting to write a new message, set ssl->out_msglen
   3278                   * to 0. But if we're resuming after an asynchronous message,
   3279                   * out_msglen is the amount of data written so far and mst be
   3280                   * preserved. */
   3281                  if (ret == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {
   3282                      MBEDTLS_SSL_DEBUG_MSG(2, ("<= write server key exchange (pending)"));
   3283                  } else {
   3284                      ssl->out_msglen = 0;
   3285                  }
   3286                  return ret;
   3287              }
   3288          
   3289              /* If there is a signature, write its length.
   3290               * ssl_prepare_server_key_exchange already wrote the signature
   3291               * itself at its proper place in the output buffer. */
   3292          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED)
   3293              if (signature_len != 0) {
   3294                  ssl->out_msg[ssl->out_msglen++] = MBEDTLS_BYTE_1(signature_len);
   3295                  ssl->out_msg[ssl->out_msglen++] = MBEDTLS_BYTE_0(signature_len);
   3296          
   3297                  MBEDTLS_SSL_DEBUG_BUF(3, "my signature",
   3298                                        ssl->out_msg + ssl->out_msglen,
   3299                                        signature_len);
   3300          
   3301                  /* Skip over the already-written signature */
   3302                  ssl->out_msglen += signature_len;
   3303              }
   3304          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_SERVER_SIGNATURE_ENABLED */
   3305          
   3306              /* Add header and send. */
   3307              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3308              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
   3309          
   3310              ssl->state++;
   3311          
   3312              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   3313                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3314                  return ret;
   3315              }
   3316          
   3317              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write server key exchange"));
   3318              return 0;
   3319          }
   3320          
   3321          MBEDTLS_CHECK_RETURN_CRITICAL
   3322          static int ssl_write_server_hello_done(mbedtls_ssl_context *ssl)
   3323          {
   3324              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3325          
   3326              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write server hello done"));
   3327          
   3328              ssl->out_msglen  = 4;
   3329              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3330              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
   3331          
   3332              ssl->state++;
   3333          
   3334          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3335              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3336                  mbedtls_ssl_send_flight_completed(ssl);
   3337              }
   3338          #endif
   3339          
   3340              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   3341                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3342                  return ret;
   3343              }
   3344          
   3345          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3346              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3347                  (ret = mbedtls_ssl_flight_transmit(ssl)) != 0) {
   3348                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_flight_transmit", ret);
   3349                  return ret;
   3350              }
   3351          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3352          
   3353              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write server hello done"));
   3354          
   3355              return 0;
   3356          }
   3357          
   3358          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   3359              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3360          MBEDTLS_CHECK_RETURN_CRITICAL
   3361          static int ssl_parse_client_dh_public(mbedtls_ssl_context *ssl, unsigned char **p,
   3362                                                const unsigned char *end)
   3363          {
   3364              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3365              size_t n;
   3366          
   3367              /*
   3368               * Receive G^Y mod P, premaster = (G^Y)^X mod P
   3369               */
   3370              if (*p + 2 > end) {
   3371                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3372                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3373              }
   3374          
   3375              n = ((*p)[0] << 8) | (*p)[1];
   3376              *p += 2;
   3377          
   3378              if (*p + n > end) {
   3379                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3380                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3381              }
   3382          
   3383              if ((ret = mbedtls_dhm_read_public(&ssl->handshake->dhm_ctx, *p, n)) != 0) {
   3384                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_read_public", ret);
   3385                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3386              }
   3387          
   3388              *p += n;
   3389          
   3390              MBEDTLS_SSL_DEBUG_MPI(3, "DHM: GY", &ssl->handshake->dhm_ctx.GY);
   3391          
   3392              return ret;
   3393          }
   3394          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   3395                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3396          
   3397          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
   3398              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3399          
   3400          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3401          MBEDTLS_CHECK_RETURN_CRITICAL
   3402          static int ssl_resume_decrypt_pms(mbedtls_ssl_context *ssl,
   3403                                            unsigned char *peer_pms,
   3404                                            size_t *peer_pmslen,
   3405                                            size_t peer_pmssize)
   3406          {
   3407              int ret = ssl->conf->f_async_resume(ssl,
   3408                                                  peer_pms, peer_pmslen, peer_pmssize);
   3409              if (ret != MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {
   3410                  ssl->handshake->async_in_progress = 0;
   3411                  mbedtls_ssl_set_async_operation_data(ssl, NULL);
   3412              }
   3413              MBEDTLS_SSL_DEBUG_RET(2, "ssl_decrypt_encrypted_pms", ret);
   3414              return ret;
   3415          }
   3416          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3417          
   3418          MBEDTLS_CHECK_RETURN_CRITICAL
   3419          static int ssl_decrypt_encrypted_pms(mbedtls_ssl_context *ssl,
   3420                                               const unsigned char *p,
   3421                                               const unsigned char *end,
   3422                                               unsigned char *peer_pms,
   3423                                               size_t *peer_pmslen,
   3424                                               size_t peer_pmssize)
   3425          {
   3426              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3427          
   3428              mbedtls_x509_crt *own_cert = mbedtls_ssl_own_cert(ssl);
   3429              if (own_cert == NULL) {
   3430                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no local certificate"));
   3431                  return MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE;
   3432              }
   3433              mbedtls_pk_context *public_key = &own_cert->pk;
   3434              mbedtls_pk_context *private_key = mbedtls_ssl_own_key(ssl);
   3435              size_t len = mbedtls_pk_get_len(public_key);
   3436          
   3437          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3438              /* If we have already started decoding the message and there is an ongoing
   3439               * decryption operation, resume signing. */
   3440              if (ssl->handshake->async_in_progress != 0) {
   3441                  MBEDTLS_SSL_DEBUG_MSG(2, ("resuming decryption operation"));
   3442                  return ssl_resume_decrypt_pms(ssl,
   3443                                                peer_pms, peer_pmslen, peer_pmssize);
   3444              }
   3445          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3446          
   3447              /*
   3448               * Prepare to decrypt the premaster using own private RSA key
   3449               */
   3450              if (p + 2 > end) {
   3451                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3452                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3453              }
   3454              if (*p++ != MBEDTLS_BYTE_1(len) ||
   3455                  *p++ != MBEDTLS_BYTE_0(len)) {
   3456                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3457                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3458              }
   3459          
   3460              if (p + len != end) {
   3461                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3462                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3463              }
   3464          
   3465              /*
   3466               * Decrypt the premaster secret
   3467               */
   3468          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3469              if (ssl->conf->f_async_decrypt_start != NULL) {
   3470                  ret = ssl->conf->f_async_decrypt_start(ssl,
   3471                                                         mbedtls_ssl_own_cert(ssl),
   3472                                                         p, len);
   3473                  switch (ret) {
   3474                      case MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH:
   3475                          /* act as if f_async_decrypt_start was null */
   3476                          break;
   3477                      case 0:
   3478                          ssl->handshake->async_in_progress = 1;
   3479                          return ssl_resume_decrypt_pms(ssl,
   3480                                                        peer_pms,
   3481                                                        peer_pmslen,
   3482                                                        peer_pmssize);
   3483                      case MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS:
   3484                          ssl->handshake->async_in_progress = 1;
   3485                          return MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS;
   3486                      default:
   3487                          MBEDTLS_SSL_DEBUG_RET(1, "f_async_decrypt_start", ret);
   3488                          return ret;
   3489                  }
   3490              }
   3491          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3492          
   3493              if (!mbedtls_pk_can_do(private_key, MBEDTLS_PK_RSA)) {
   3494                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no RSA private key"));
   3495                  return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
   3496              }
   3497          
   3498              ret = mbedtls_pk_decrypt(private_key, p, len,
   3499                                       peer_pms, peer_pmslen, peer_pmssize,
   3500                                       ssl->conf->f_rng, ssl->conf->p_rng);
   3501              return ret;
   3502          }
   3503          
   3504          MBEDTLS_CHECK_RETURN_CRITICAL
   3505          static int ssl_parse_encrypted_pms(mbedtls_ssl_context *ssl,
   3506                                             const unsigned char *p,
   3507                                             const unsigned char *end,
   3508                                             size_t pms_offset)
   3509          {
   3510              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3511              unsigned char *pms = ssl->handshake->premaster + pms_offset;
   3512              unsigned char ver[2];
   3513              unsigned char fake_pms[48], peer_pms[48];
   3514              size_t peer_pmslen;
   3515              mbedtls_ct_condition_t diff;
   3516          
   3517              /* In case of a failure in decryption, the decryption may write less than
   3518               * 2 bytes of output, but we always read the first two bytes. It doesn't
   3519               * matter in the end because diff will be nonzero in that case due to
   3520               * ret being nonzero, and we only care whether diff is 0.
   3521               * But do initialize peer_pms and peer_pmslen for robustness anyway. This
   3522               * also makes memory analyzers happy (don't access uninitialized memory,
   3523               * even if it's an unsigned char). */
   3524              peer_pms[0] = peer_pms[1] = ~0;
   3525              peer_pmslen = 0;
   3526          
   3527              ret = ssl_decrypt_encrypted_pms(ssl, p, end,
   3528                                              peer_pms,
   3529                                              &peer_pmslen,
   3530                                              sizeof(peer_pms));
   3531          
   3532          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3533              if (ret == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {
   3534                  return ret;
   3535              }
   3536          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3537          
   3538              mbedtls_ssl_write_version(ver, ssl->conf->transport,
   3539                                        ssl->session_negotiate->tls_version);
   3540          
   3541              /* Avoid data-dependent branches while checking for invalid
   3542               * padding, to protect against timing-based Bleichenbacher-type
   3543               * attacks. */
   3544              diff = mbedtls_ct_bool(ret);
   3545              diff = mbedtls_ct_bool_or(diff, mbedtls_ct_uint_ne(peer_pmslen, 48));
   3546              diff = mbedtls_ct_bool_or(diff, mbedtls_ct_uint_ne(peer_pms[0], ver[0]));
   3547              diff = mbedtls_ct_bool_or(diff, mbedtls_ct_uint_ne(peer_pms[1], ver[1]));
   3548          
   3549              /*
   3550               * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding
   3551               * must not cause the connection to end immediately; instead, send a
   3552               * bad_record_mac later in the handshake.
   3553               * To protect against timing-based variants of the attack, we must
   3554               * not have any branch that depends on whether the decryption was
   3555               * successful. In particular, always generate the fake premaster secret,
   3556               * regardless of whether it will ultimately influence the output or not.
   3557               */
   3558              ret = ssl->conf->f_rng(ssl->conf->p_rng, fake_pms, sizeof(fake_pms));
   3559              if (ret != 0) {
   3560                  /* It's ok to abort on an RNG failure, since this does not reveal
   3561                   * anything about the RSA decryption. */
   3562                  return ret;
   3563              }
   3564          
   3565          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   3566              if (diff != MBEDTLS_CT_FALSE) {
   3567                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3568              }
   3569          #endif
   3570          
   3571              if (sizeof(ssl->handshake->premaster) < pms_offset ||
   3572                  sizeof(ssl->handshake->premaster) - pms_offset < 48) {
   3573                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   3574                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3575              }
   3576              ssl->handshake->pmslen = 48;
   3577          
   3578              /* Set pms to either the true or the fake PMS, without
   3579               * data-dependent branches. */
   3580              mbedtls_ct_memcpy_if(diff, pms, fake_pms, peer_pms, ssl->handshake->pmslen);
   3581          
   3582              return 0;
   3583          }
   3584          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
   3585                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   3586          
   3587          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   3588          MBEDTLS_CHECK_RETURN_CRITICAL
   3589          static int ssl_parse_client_psk_identity(mbedtls_ssl_context *ssl, unsigned char **p,
   3590                                                   const unsigned char *end)
   3591          {
   3592              int ret = 0;
   3593              uint16_t n;
   3594          
   3595              if (ssl_conf_has_psk_or_cb(ssl->conf) == 0) {
   3596                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no pre-shared key"));
   3597                  return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
   3598              }
   3599          
   3600              /*
   3601               * Receive client pre-shared key identity name
   3602               */
   3603              if (end - *p < 2) {
   3604                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3605                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3606              }
   3607          
   3608              n = ((*p)[0] << 8) | (*p)[1];
   3609              *p += 2;
   3610          
   3611              if (n == 0 || n > end - *p) {
   3612                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3613                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3614              }
   3615          
   3616              if (ssl->conf->f_psk != NULL) {
   3617                  if (ssl->conf->f_psk(ssl->conf->p_psk, ssl, *p, n) != 0) {
   3618                      ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3619                  }
   3620              } else {
   3621                  /* Identity is not a big secret since clients send it in the clear,
   3622                   * but treat it carefully anyway, just in case */
   3623                  if (n != ssl->conf->psk_identity_len ||
   3624                      mbedtls_ct_memcmp(ssl->conf->psk_identity, *p, n) != 0) {
   3625                      ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3626                  }
   3627              }
   3628          
   3629              if (ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) {
   3630                  MBEDTLS_SSL_DEBUG_BUF(3, "Unknown PSK identity", *p, n);
   3631                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3632                                                 MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY);
   3633                  return MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3634              }
   3635          
   3636              *p += n;
   3637          
   3638              return 0;
   3639          }
   3640          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   3641          
   3642          MBEDTLS_CHECK_RETURN_CRITICAL
   3643          static int ssl_parse_client_key_exchange(mbedtls_ssl_context *ssl)
   3644          {
   3645              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3646              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
   3647              unsigned char *p, *end;
   3648          
   3649              ciphersuite_info = ssl->handshake->ciphersuite_info;
   3650          
   3651              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse client key exchange"));
   3652          
   3653          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE) && \
   3654              (defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) || \
   3655              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED))
   3656              if ((ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   3657                   ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) &&
   3658                  (ssl->handshake->async_in_progress != 0)) {
   3659                  /* We've already read a record and there is an asynchronous
   3660                   * operation in progress to decrypt it. So skip reading the
   3661                   * record. */
   3662                  MBEDTLS_SSL_DEBUG_MSG(3, ("will resume decryption of previously-read record"));
   3663              } else
   3664          #endif
   3665              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   3666                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   3667                  return ret;
   3668              }
   3669          
   3670              p = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
   3671              end = ssl->in_msg + ssl->in_hslen;
   3672          
   3673              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   3674                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3675                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   3676              }
   3677          
   3678              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE) {
   3679                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange message"));
   3680                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   3681              }
   3682          
   3683          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
   3684              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA) {
   3685                  if ((ret = ssl_parse_client_dh_public(ssl, &p, end)) != 0) {
   3686                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_dh_public"), ret);
   3687                      return ret;
   3688                  }
   3689          
   3690                  if (p != end) {
   3691                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange"));
   3692                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3693                  }
   3694          
   3695                  if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   3696                                                     ssl->handshake->premaster,
   3697                                                     MBEDTLS_PREMASTER_SIZE,
   3698                                                     &ssl->handshake->pmslen,
   3699                                                     ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   3700                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   3701                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3702                  }
   3703          
   3704                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   3705              } else
   3706          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
   3707          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
   3708              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
   3709              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
   3710              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   3711              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   3712                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
   3713                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   3714                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA) {
   3715          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3716                  size_t data_len = (size_t) (*p++);
   3717                  size_t buf_len = (size_t) (end - p);
   3718                  psa_status_t status = PSA_ERROR_GENERIC_ERROR;
   3719                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   3720          
   3721                  MBEDTLS_SSL_DEBUG_MSG(3, ("Read the peer's public key."));
   3722          
   3723                  /*
   3724                   * We must have at least two bytes (1 for length, at least 1 for data)
   3725                   */
   3726                  if (buf_len < 2) {
   3727                      MBEDTLS_SSL_DEBUG_MSG(1, ("Invalid buffer length: %" MBEDTLS_PRINTF_SIZET,
   3728                                                buf_len));
   3729                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   3730                  }
   3731          
   3732                  if (data_len < 1 || data_len > buf_len) {
   3733                      MBEDTLS_SSL_DEBUG_MSG(1, ("Invalid data length: %" MBEDTLS_PRINTF_SIZET
   3734                                                " > %" MBEDTLS_PRINTF_SIZET,
   3735                                                data_len, buf_len));
   3736                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   3737                  }
   3738          
   3739                  /* Store peer's ECDH public key. */
   3740                  if (data_len > sizeof(handshake->xxdh_psa_peerkey)) {
   3741                      MBEDTLS_SSL_DEBUG_MSG(1, ("Invalid public key length: %" MBEDTLS_PRINTF_SIZET
   3742                                                " > %" MBEDTLS_PRINTF_SIZET,
   3743                                                data_len,
   3744                                                sizeof(handshake->xxdh_psa_peerkey)));
   3745                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   3746                  }
   3747                  memcpy(handshake->xxdh_psa_peerkey, p, data_len);
   3748                  handshake->xxdh_psa_peerkey_len = data_len;
   3749          
   3750                  /* Compute ECDH shared secret. */
   3751                  status = psa_raw_key_agreement(
   3752                      PSA_ALG_ECDH, handshake->xxdh_psa_privkey,
   3753                      handshake->xxdh_psa_peerkey, handshake->xxdh_psa_peerkey_len,
   3754                      handshake->premaster, sizeof(handshake->premaster),
   3755                      &handshake->pmslen);
   3756                  if (status != PSA_SUCCESS) {
   3757                      ret = PSA_TO_MBEDTLS_ERR(status);
   3758                      MBEDTLS_SSL_DEBUG_RET(1, "psa_raw_key_agreement", ret);
   3759                      if (handshake->xxdh_psa_privkey_is_external == 0) {
   3760                          (void) psa_destroy_key(handshake->xxdh_psa_privkey);
   3761                      }
   3762                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3763                      return ret;
   3764                  }
   3765          
   3766                  if (handshake->xxdh_psa_privkey_is_external == 0) {
   3767                      status = psa_destroy_key(handshake->xxdh_psa_privkey);
   3768          
   3769                      if (status != PSA_SUCCESS) {
   3770                          ret = PSA_TO_MBEDTLS_ERR(status);
   3771                          MBEDTLS_SSL_DEBUG_RET(1, "psa_destroy_key", ret);
   3772                          return ret;
   3773                      }
   3774                  }
   3775                  handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3776          #else
   3777                  if ((ret = mbedtls_ecdh_read_public(&ssl->handshake->ecdh_ctx,
   3778                                                      p, end - p)) != 0) {
   3779                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_read_public", ret);
   3780                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3781                  }
   3782          
   3783                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   3784                                         MBEDTLS_DEBUG_ECDH_QP);
   3785          
   3786                  if ((ret = mbedtls_ecdh_calc_secret(&ssl->handshake->ecdh_ctx,
   3787                                                      &ssl->handshake->pmslen,
   3788                                                      ssl->handshake->premaster,
   3789                                                      MBEDTLS_MPI_MAX_SIZE,
   3790                                                      ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   3791                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_calc_secret", ret);
   3792                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3793                  }
   3794          
   3795                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   3796                                         MBEDTLS_DEBUG_ECDH_Z);
   3797          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   3798              } else
   3799          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   3800                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   3801                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   3802                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   3803          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   3804              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK) {
   3805                  if ((ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0) {
   3806                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_psk_identity"), ret);
   3807                      return ret;
   3808                  }
   3809          
   3810                  if (p != end) {
   3811                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange"));
   3812                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3813                  }
   3814          
   3815          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   3816                  if ((ret = mbedtls_ssl_psk_derive_premaster(ssl,
   3817                                                              (mbedtls_key_exchange_type_t) ciphersuite_info->
   3818                                                              key_exchange)) != 0) {
   3819                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_psk_derive_premaster", ret);
   3820                      return ret;
   3821                  }
   3822          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   3823              } else
   3824          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
   3825          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3826              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   3827          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3828                  if (ssl->handshake->async_in_progress != 0) {
   3829                      /* There is an asynchronous operation in progress to
   3830                       * decrypt the encrypted premaster secret, so skip
   3831                       * directly to resuming this operation. */
   3832                      MBEDTLS_SSL_DEBUG_MSG(3, ("PSK identity already parsed"));
   3833                      /* Update p to skip the PSK identity. ssl_parse_encrypted_pms
   3834                       * won't actually use it, but maintain p anyway for robustness. */
   3835                      p += ssl->conf->psk_identity_len + 2;
   3836                  } else
   3837          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3838                  if ((ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0) {
   3839                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_psk_identity"), ret);
   3840                      return ret;
   3841                  }
   3842          
   3843                  if ((ret = ssl_parse_encrypted_pms(ssl, p, end, 2)) != 0) {
   3844                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_encrypted_pms"), ret);
   3845                      return ret;
   3846                  }
   3847          
   3848          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   3849                  if ((ret = mbedtls_ssl_psk_derive_premaster(ssl,
   3850                                                              (mbedtls_key_exchange_type_t) ciphersuite_info->
   3851                                                              key_exchange)) != 0) {
   3852                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_psk_derive_premaster", ret);
   3853                      return ret;
   3854                  }
   3855          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   3856              } else
   3857          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   3858          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3859              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   3860                  if ((ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0) {
   3861                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_psk_identity"), ret);
   3862                      return ret;
   3863                  }
   3864                  if ((ret = ssl_parse_client_dh_public(ssl, &p, end)) != 0) {
   3865                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_dh_public"), ret);
   3866                      return ret;
   3867                  }
   3868          
   3869                  if (p != end) {
   3870                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad client key exchange"));
   3871                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3872                  }
   3873          
   3874          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3875                  unsigned char *pms = ssl->handshake->premaster;
   3876                  unsigned char *pms_end = pms + sizeof(ssl->handshake->premaster);
   3877                  size_t pms_len;
   3878          
   3879                  /* Write length only when we know the actual value */
   3880                  if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   3881                                                     pms + 2, pms_end - (pms + 2), &pms_len,
   3882                                                     ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   3883                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   3884                      return ret;
   3885                  }
   3886                  MBEDTLS_PUT_UINT16_BE(pms_len, pms, 0);
   3887                  pms += 2 + pms_len;
   3888          
   3889                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   3890          #else
   3891                  if ((ret = mbedtls_ssl_psk_derive_premaster(ssl,
   3892                                                              (mbedtls_key_exchange_type_t) ciphersuite_info->
   3893                                                              key_exchange)) != 0) {
   3894                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_psk_derive_premaster", ret);
   3895                      return ret;
   3896                  }
   3897          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   3898              } else
   3899          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3900          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   3901              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   3902          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   3903                  psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   3904                  psa_status_t destruction_status = PSA_ERROR_CORRUPTION_DETECTED;
   3905                  size_t ecpoint_len;
   3906          
   3907                  mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   3908          
   3909                  if ((ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0) {
   3910                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_psk_identity"), ret);
   3911                      psa_destroy_key(handshake->xxdh_psa_privkey);
   3912                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3913                      return ret;
   3914                  }
   3915          
   3916                  /* Keep a copy of the peer's public key */
   3917                  if (p >= end) {
   3918                      psa_destroy_key(handshake->xxdh_psa_privkey);
   3919                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3920                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3921                  }
   3922          
   3923                  ecpoint_len = *(p++);
   3924                  if ((size_t) (end - p) < ecpoint_len) {
   3925                      psa_destroy_key(handshake->xxdh_psa_privkey);
   3926                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3927                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3928                  }
   3929          
   3930                  /* When FFDH is enabled, the array handshake->xxdh_psa_peer_key size takes into account
   3931                     the sizes of the FFDH keys which are at least 2048 bits.
   3932                     The size of the array is thus greater than 256 bytes which is greater than any
   3933                     possible value of ecpoint_len (type uint8_t) and the check below can be skipped.*/
   3934          #if !defined(PSA_WANT_ALG_FFDH)
   3935                  if (ecpoint_len > sizeof(handshake->xxdh_psa_peerkey)) {
   3936                      psa_destroy_key(handshake->xxdh_psa_privkey);
   3937                      handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3938                      return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   3939                  }
   3940          #else
   3941                  MBEDTLS_STATIC_ASSERT(sizeof(handshake->xxdh_psa_peerkey) >= UINT8_MAX,
   3942                                        "peer key buffer too small");
   3943          #endif
   3944          
   3945                  memcpy(handshake->xxdh_psa_peerkey, p, ecpoint_len);
   3946                  handshake->xxdh_psa_peerkey_len = ecpoint_len;
   3947                  p += ecpoint_len;
   3948          
   3949                  /* As RFC 5489 section 2, the premaster secret is formed as follows:
   3950                   * - a uint16 containing the length (in octets) of the ECDH computation
   3951                   * - the octet string produced by the ECDH computation
   3952                   * - a uint16 containing the length (in octets) of the PSK
   3953                   * - the PSK itself
   3954                   */
   3955                  unsigned char *psm = ssl->handshake->premaster;
   3956                  const unsigned char * const psm_end =
   3957                      psm + sizeof(ssl->handshake->premaster);
   3958                  /* uint16 to store length (in octets) of the ECDH computation */
   3959                  const size_t zlen_size = 2;
   3960                  size_t zlen = 0;
   3961          
   3962                  /* Compute ECDH shared secret. */
   3963                  status = psa_raw_key_agreement(PSA_ALG_ECDH,
   3964                                                 handshake->xxdh_psa_privkey,
   3965                                                 handshake->xxdh_psa_peerkey,
   3966                                                 handshake->xxdh_psa_peerkey_len,
   3967                                                 psm + zlen_size,
   3968                                                 psm_end - (psm + zlen_size),
   3969                                                 &zlen);
   3970          
   3971                  destruction_status = psa_destroy_key(handshake->xxdh_psa_privkey);
   3972                  handshake->xxdh_psa_privkey = MBEDTLS_SVC_KEY_ID_INIT;
   3973          
   3974                  if (status != PSA_SUCCESS) {
   3975                      return PSA_TO_MBEDTLS_ERR(status);
   3976                  } else if (destruction_status != PSA_SUCCESS) {
   3977                      return PSA_TO_MBEDTLS_ERR(destruction_status);
   3978                  }
   3979          
   3980                  /* Write the ECDH computation length before the ECDH computation */
   3981                  MBEDTLS_PUT_UINT16_BE(zlen, psm, 0);
   3982                  psm += zlen_size + zlen;
   3983          
   3984          #else /* MBEDTLS_USE_PSA_CRYPTO */
   3985                  if ((ret = ssl_parse_client_psk_identity(ssl, &p, end)) != 0) {
   3986                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_client_psk_identity"), ret);
   3987                      return ret;
   3988                  }
   3989          
   3990                  if ((ret = mbedtls_ecdh_read_public(&ssl->handshake->ecdh_ctx,
   3991                                                      p, end - p)) != 0) {
   3992                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_read_public", ret);
   3993                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   3994                  }
   3995          
   3996                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   3997                                         MBEDTLS_DEBUG_ECDH_QP);
   3998          
   3999                  if ((ret = mbedtls_ssl_psk_derive_premaster(ssl,
   4000                                                              (mbedtls_key_exchange_type_t) ciphersuite_info->
   4001                                                              key_exchange)) != 0) {
   4002                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_psk_derive_premaster", ret);
   4003                      return ret;
   4004                  }
   4005          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   4006              } else
   4007          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   4008          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   4009              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
   4010                  if ((ret = ssl_parse_encrypted_pms(ssl, p, end, 0)) != 0) {
   4011                      MBEDTLS_SSL_DEBUG_RET(1, ("ssl_parse_parse_encrypted_pms_secret"), ret);
   4012                      return ret;
   4013                  }
   4014              } else
   4015          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   4016          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   4017              if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   4018          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   4019                  if ((ret = mbedtls_psa_ecjpake_read_round(
   4020                           &ssl->handshake->psa_pake_ctx, p, end - p,
   4021                           MBEDTLS_ECJPAKE_ROUND_TWO)) != 0) {
   4022                      psa_destroy_key(ssl->handshake->psa_pake_password);
   4023                      psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   4024          
   4025                      MBEDTLS_SSL_DEBUG_RET(1, "psa_pake_input round two", ret);
   4026                      return ret;
   4027                  }
   4028          #else
   4029                  ret = mbedtls_ecjpake_read_round_two(&ssl->handshake->ecjpake_ctx,
   4030                                                       p, end - p);
   4031                  if (ret != 0) {
   4032                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_read_round_two", ret);
   4033                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4034                  }
   4035          
   4036                  ret = mbedtls_ecjpake_derive_secret(&ssl->handshake->ecjpake_ctx,
   4037                                                      ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
   4038                                                      ssl->conf->f_rng, ssl->conf->p_rng);
   4039                  if (ret != 0) {
   4040                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecjpake_derive_secret", ret);
   4041                      return ret;
   4042                  }
   4043          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   4044              } else
   4045          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   4046              {
   4047                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4048                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4049              }
   4050          
   4051              if ((ret = mbedtls_ssl_derive_keys(ssl)) != 0) {
   4052                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_derive_keys", ret);
   4053                  return ret;
   4054              }
   4055          
   4056              ssl->state++;
   4057          
   4058              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse client key exchange"));
   4059          
   4060              return 0;
   4061          }
   4062          
   4063          #if !defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   4064          MBEDTLS_CHECK_RETURN_CRITICAL
   4065          static int ssl_parse_certificate_verify(mbedtls_ssl_context *ssl)
   4066          {
   4067              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   4068                  ssl->handshake->ciphersuite_info;
   4069          
   4070              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate verify"));
   4071          
   4072              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   4073                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate verify"));
   4074                  ssl->state++;
   4075                  return 0;
   4076              }
   4077          
   4078              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   4079              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4080          }
   4081          #else /* !MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   4082          MBEDTLS_CHECK_RETURN_CRITICAL
   4083          static int ssl_parse_certificate_verify(mbedtls_ssl_context *ssl)
   4084          {
   4085              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   4086              size_t i, sig_len;
   4087              unsigned char hash[48];
   4088              unsigned char *hash_start = hash;
   4089              size_t hashlen;
   4090              mbedtls_pk_type_t pk_alg;
   4091              mbedtls_md_type_t md_alg;
   4092              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   4093                  ssl->handshake->ciphersuite_info;
   4094              mbedtls_pk_context *peer_pk;
   4095          
   4096              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate verify"));
   4097          
   4098              if (!mbedtls_ssl_ciphersuite_cert_req_allowed(ciphersuite_info)) {
   4099                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate verify"));
   4100                  ssl->state++;
   4101                  return 0;
   4102              }
   4103          
   4104          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   4105              if (ssl->session_negotiate->peer_cert == NULL) {
   4106                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate verify"));
   4107                  ssl->state++;
   4108                  return 0;
   4109              }
   4110          #else /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   4111              if (ssl->session_negotiate->peer_cert_digest == NULL) {
   4112                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate verify"));
   4113                  ssl->state++;
   4114                  return 0;
   4115              }
   4116          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   4117          
   4118              /* Read the message without adding it to the checksum */
   4119              ret = mbedtls_ssl_read_record(ssl, 0 /* no checksum update */);
   4120              if (0 != ret) {
   4121                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ssl_read_record"), ret);
   4122                  return ret;
   4123              }
   4124          
   4125              ssl->state++;
   4126          
   4127              /* Process the message contents */
   4128              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
   4129                  ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY) {
   4130                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate verify message"));
   4131                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   4132              }
   4133          
   4134              i = mbedtls_ssl_hs_hdr_len(ssl);
   4135          
   4136          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   4137              peer_pk = &ssl->handshake->peer_pubkey;
   4138          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   4139              if (ssl->session_negotiate->peer_cert == NULL) {
   4140                  /* Should never happen */
   4141                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   4142              }
   4143              peer_pk = &ssl->session_negotiate->peer_cert->pk;
   4144          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   4145          
   4146              /*
   4147               *  struct {
   4148               *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only
   4149               *     opaque signature<0..2^16-1>;
   4150               *  } DigitallySigned;
   4151               */
   4152              if (i + 2 > ssl->in_hslen) {
   4153                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate verify message"));
   4154                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   4155              }
   4156          
   4157              /*
   4158               * Hash
   4159               */
   4160              md_alg = mbedtls_ssl_md_alg_from_hash(ssl->in_msg[i]);
   4161          
   4162              if (md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md(ssl, ssl->in_msg[i])) {
   4163                  MBEDTLS_SSL_DEBUG_MSG(1, ("peer not adhering to requested sig_alg"
   4164                                            " for verify message"));
   4165                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   4166              }
   4167          
   4168          #if !defined(MBEDTLS_MD_SHA1)
   4169              if (MBEDTLS_MD_SHA1 == md_alg) {
   4170                  hash_start += 16;
   4171              }
   4172          #endif
   4173          
   4174              /* Info from md_alg will be used instead */
   4175              hashlen = 0;
   4176          
   4177              i++;
   4178          
   4179              /*
   4180               * Signature
   4181               */
   4182              if ((pk_alg = mbedtls_ssl_pk_alg_from_sig(ssl->in_msg[i]))
   4183                  == MBEDTLS_PK_NONE) {
   4184                  MBEDTLS_SSL_DEBUG_MSG(1, ("peer not adhering to requested sig_alg"
   4185                                            " for verify message"));
   4186                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   4187              }
   4188          
   4189              /*
   4190               * Check the certificate's key type matches the signature alg
   4191               */
   4192              if (!mbedtls_pk_can_do(peer_pk, pk_alg)) {
   4193                  MBEDTLS_SSL_DEBUG_MSG(1, ("sig_alg doesn't match cert key"));
   4194                  return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   4195              }
   4196          
   4197              i++;
   4198          
   4199              if (i + 2 > ssl->in_hslen) {
   4200                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate verify message"));
   4201                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   4202              }
   4203          
   4204              sig_len = (ssl->in_msg[i] << 8) | ssl->in_msg[i+1];
   4205              i += 2;
   4206          
   4207              if (i + sig_len != ssl->in_hslen) {
   4208                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate verify message"));
   4209                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   4210              }
   4211          
   4212              /* Calculate hash and verify signature */
   4213              {
   4214                  size_t dummy_hlen;
   4215                  ret = ssl->handshake->calc_verify(ssl, hash, &dummy_hlen);
   4216                  if (0 != ret) {
   4217                      MBEDTLS_SSL_DEBUG_RET(1, ("calc_verify"), ret);
   4218                      return ret;
   4219                  }
   4220              }
   4221          
   4222              if ((ret = mbedtls_pk_verify(peer_pk,
   4223                                           md_alg, hash_start, hashlen,
   4224                                           ssl->in_msg + i, sig_len)) != 0) {
   4225                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_pk_verify", ret);
   4226                  return ret;
   4227              }
   4228          
   4229              ret = mbedtls_ssl_update_handshake_status(ssl);
   4230              if (0 != ret) {
   4231                  MBEDTLS_SSL_DEBUG_RET(1, ("mbedtls_ssl_update_handshake_status"), ret);
   4232                  return ret;
   4233              }
   4234          
   4235              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse certificate verify"));
   4236          
   4237              return ret;
   4238          }
   4239          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   4240          
   4241          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   4242          MBEDTLS_CHECK_RETURN_CRITICAL
   4243          static int ssl_write_new_session_ticket(mbedtls_ssl_context *ssl)
   4244          {
   4245              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   4246              size_t tlen;
   4247              uint32_t lifetime;
   4248          
   4249              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write new session ticket"));
   4250          
   4251              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   4252              ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
   4253          
   4254              /*
   4255               * struct {
   4256               *     uint32 ticket_lifetime_hint;
   4257               *     opaque ticket<0..2^16-1>;
   4258               * } NewSessionTicket;
   4259               *
   4260               * 4  .  7   ticket_lifetime_hint (0 = unspecified)
   4261               * 8  .  9   ticket_len (n)
   4262               * 10 .  9+n ticket content
   4263               */
   4264          
   4265              if ((ret = ssl->conf->f_ticket_write(ssl->conf->p_ticket,
   4266                                                   ssl->session_negotiate,
   4267                                                   ssl->out_msg + 10,
   4268                                                   ssl->out_msg + MBEDTLS_SSL_OUT_CONTENT_LEN,
   4269                                                   &tlen, &lifetime)) != 0) {
   4270                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_ticket_write", ret);
   4271                  tlen = 0;
   4272              }
   4273          
   4274              MBEDTLS_PUT_UINT32_BE(lifetime, ssl->out_msg, 4);
   4275              MBEDTLS_PUT_UINT16_BE(tlen, ssl->out_msg, 8);
   4276              ssl->out_msglen = 10 + tlen;
   4277          
   4278              /*
   4279               * Morally equivalent to updating ssl->state, but NewSessionTicket and
   4280               * ChangeCipherSpec share the same state.
   4281               */
   4282              ssl->handshake->new_session_ticket = 0;
   4283          
   4284              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   4285                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   4286                  return ret;
   4287              }
   4288          
   4289              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write new session ticket"));
   4290          
   4291              return 0;
   4292          }
   4293          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   4294          
   4295          /*
   4296           * SSL handshake -- server side -- single step
   4297           */
   4298          int mbedtls_ssl_handshake_server_step(mbedtls_ssl_context *ssl)
   4299          {
   4300              int ret = 0;
   4301          
   4302              MBEDTLS_SSL_DEBUG_MSG(2, ("server state: %d", ssl->state));
   4303          
   4304              switch (ssl->state) {
   4305                  case MBEDTLS_SSL_HELLO_REQUEST:
   4306                      ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   4307                      break;
   4308          
   4309                  /*
   4310                   *  <==   ClientHello
   4311                   */
   4312                  case MBEDTLS_SSL_CLIENT_HELLO:
   4313                      ret = ssl_parse_client_hello(ssl);
   4314                      break;
   4315          
   4316          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4317                  case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:
   4318                      return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED;
   4319          #endif
   4320          
   4321                  /*
   4322                   *  ==>   ServerHello
   4323                   *        Certificate
   4324                   *      ( ServerKeyExchange  )
   4325                   *      ( CertificateRequest )
   4326                   *        ServerHelloDone
   4327                   */
   4328                  case MBEDTLS_SSL_SERVER_HELLO:
   4329                      ret = ssl_write_server_hello(ssl);
   4330                      break;
   4331          
   4332                  case MBEDTLS_SSL_SERVER_CERTIFICATE:
   4333                      ret = mbedtls_ssl_write_certificate(ssl);
   4334                      break;
   4335          
   4336                  case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
   4337                      ret = ssl_write_server_key_exchange(ssl);
   4338                      break;
   4339          
   4340                  case MBEDTLS_SSL_CERTIFICATE_REQUEST:
   4341                      ret = ssl_write_certificate_request(ssl);
   4342                      break;
   4343          
   4344                  case MBEDTLS_SSL_SERVER_HELLO_DONE:
   4345                      ret = ssl_write_server_hello_done(ssl);
   4346                      break;
   4347          
   4348                  /*
   4349                   *  <== ( Certificate/Alert  )
   4350                   *        ClientKeyExchange
   4351                   *      ( CertificateVerify  )
   4352                   *        ChangeCipherSpec
   4353                   *        Finished
   4354                   */
   4355                  case MBEDTLS_SSL_CLIENT_CERTIFICATE:
   4356                      ret = mbedtls_ssl_parse_certificate(ssl);
   4357                      break;
   4358          
   4359                  case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
   4360                      ret = ssl_parse_client_key_exchange(ssl);
   4361                      break;
   4362          
   4363                  case MBEDTLS_SSL_CERTIFICATE_VERIFY:
   4364                      ret = ssl_parse_certificate_verify(ssl);
   4365                      break;
   4366          
   4367                  case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
   4368                      ret = mbedtls_ssl_parse_change_cipher_spec(ssl);
   4369                      break;
   4370          
   4371                  case MBEDTLS_SSL_CLIENT_FINISHED:
   4372                      ret = mbedtls_ssl_parse_finished(ssl);
   4373                      break;
   4374          
   4375                  /*
   4376                   *  ==> ( NewSessionTicket )
   4377                   *        ChangeCipherSpec
   4378                   *        Finished
   4379                   */
   4380                  case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
   4381          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   4382                      if (ssl->handshake->new_session_ticket != 0) {
   4383                          ret = ssl_write_new_session_ticket(ssl);
   4384                      } else
   4385          #endif
   4386                      ret = mbedtls_ssl_write_change_cipher_spec(ssl);
   4387                      break;
   4388          
   4389                  case MBEDTLS_SSL_SERVER_FINISHED:
   4390                      ret = mbedtls_ssl_write_finished(ssl);
   4391                      break;
   4392          
   4393                  case MBEDTLS_SSL_FLUSH_BUFFERS:
   4394                      MBEDTLS_SSL_DEBUG_MSG(2, ("handshake: done"));
   4395                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   4396                      break;
   4397          
   4398                  case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
   4399                      mbedtls_ssl_handshake_wrapup(ssl);
   4400                      break;
   4401          
   4402                  default:
   4403                      MBEDTLS_SSL_DEBUG_MSG(1, ("invalid state %d", ssl->state));
   4404                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4405              }
   4406          
   4407              return ret;
   4408          }
   4409          
   4410          void mbedtls_ssl_conf_preference_order(mbedtls_ssl_config *conf, int order)
   4411          {
   4412              conf->respect_cli_pref = order;
   4413          }
   4414          
   4415          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_PROTO_TLS1_2 */


 
 
 0 bytes of memory

Errors: none
Warnings: none
