###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:26
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\bignum_core.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\bignum_core.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\bignum_core.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\bignum_core.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\bignum_core.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\bignum_core.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\bignum_core.c
      1          /*
      2           *  Core bignum functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     21          
     22          #if defined(MBEDTLS_BIGNUM_C)
     23          
     24          #include <string.h>
     25          
     26          #include "mbedtls/error.h"
     27          #include "mbedtls/platform_util.h"
     28          #include "constant_time_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_compiler_opaque(uint32_t)
   \                     mbedtls_ct_compiler_opaque: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable7
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x4048             EORS     R0,R1,R0
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool(uint32_t)
   \                     mbedtls_ct_bool: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable7
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x4048             EORS     R0,R1,R0
   \        0x8   0x4241             RSBS     R1,R0,#+0
   \        0xA   0x0840             LSRS     R0,R0,#+1
   \        0xC   0x4240             RSBS     R0,R0,#+0
   \        0xE   0x4308             ORRS     R0,R0,R1
   \       0x10   0x0FC0             LSRS     R0,R0,#+31
   \       0x12   0x4240             RSBS     R0,R0,#+0
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_if(uint32_t, uint32_t, uint32_t)
   \                     mbedtls_ct_if: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable7
   \        0x6   0x6823             LDR      R3,[R4, #+0]
   \        0x8   0x4001             ANDS     R1,R1,R0
   \        0xA   0x4058             EORS     R0,R3,R0
   \        0xC   0xEA22 0x0000      BIC      R0,R2,R0
   \       0x10   0x4308             ORRS     R0,R0,R1
   \       0x12   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_uint_lt(uint32_t, uint32_t)
   \                     mbedtls_ct_uint_lt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x4628             MOV      R0,R5
   \        0xC   0x.... 0x....      BL       mbedtls_ct_compiler_opaque
   \       0x10   0x4605             MOV      R5,R0
   \       0x12   0xEA85 0x0004      EOR      R0,R5,R4
   \       0x16   0x0FC0             LSRS     R0,R0,#+31
   \       0x18   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x1C   0x1B62             SUBS     R2,R4,R5
   \       0x1E   0x4629             MOV      R1,R5
   \       0x20   0x.... 0x....      BL       mbedtls_ct_if
   \       0x24   0x0FC0             LSRS     R0,R0,#+31
   \       0x26   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x2A   0x....             B.N      mbedtls_ct_bool

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_mpi_uint_if(uint32_t, uint32_t, uint32_t)
   \                     mbedtls_ct_mpi_uint_if: (+1)
   \        0x0   0x....             B.N      mbedtls_ct_if
     29          
     30          #include "mbedtls/platform.h"
     31          
     32          #include "bignum_core.h"
     33          #include "bn_mul.h"
     34          #include "constant_time_internal.h"
     35          

   \                                 In section .text, align 2, keep-with-next
     36          size_t mbedtls_mpi_core_clz(mbedtls_mpi_uint a)
     37          {
     38          #if defined(__has_builtin)
     39          #if (MBEDTLS_MPI_UINT_MAX == UINT_MAX) && __has_builtin(__builtin_clz)
     40              #define core_clz __builtin_clz
     41          #elif (MBEDTLS_MPI_UINT_MAX == ULONG_MAX) && __has_builtin(__builtin_clzl)
     42              #define core_clz __builtin_clzl
     43          #elif (MBEDTLS_MPI_UINT_MAX == ULLONG_MAX) && __has_builtin(__builtin_clzll)
     44              #define core_clz __builtin_clzll
     45          #endif
     46          #endif
     47          #if defined(core_clz)
     48              return (size_t) core_clz(a);
   \                     mbedtls_mpi_core_clz: (+1)
   \        0x0   0xFAB0 0xF080      CLZ      R0,R0
   \        0x4   0x4770             BX       LR
     49          #else
     50              size_t j;
     51              mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
     52          
     53              for (j = 0; j < biL; j++) {
     54                  if (a & mask) {
     55                      break;
     56                  }
     57          
     58                  mask >>= 1;
     59              }
     60          
     61              return j;
     62          #endif
     63          }
     64          

   \                                 In section .text, align 2, keep-with-next
     65          size_t mbedtls_mpi_core_bitlen(const mbedtls_mpi_uint *A, size_t A_limbs)
     66          {
   \                     mbedtls_mpi_core_bitlen: (+1)
   \        0x0   0x4602             MOV      R2,R0
     67              int i;
     68              size_t j;
     69          
     70              for (i = ((int) A_limbs) - 1; i >= 0; i--) {
   \        0x2   0x1E48             SUBS     R0,R1,#+1
   \        0x4   0xE000             B.N      ??mbedtls_mpi_core_bitlen_0
   \                     ??mbedtls_mpi_core_bitlen_1: (+1)
   \        0x6   0x1E40             SUBS     R0,R0,#+1
   \                     ??mbedtls_mpi_core_bitlen_0: (+1)
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD409             BMI.N    ??mbedtls_mpi_core_bitlen_2
     71                  if (A[i] != 0) {
   \        0xC   0xF852 0x1020      LDR      R1,[R2, R0, LSL #+2]
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD0F8             BEQ.N    ??mbedtls_mpi_core_bitlen_1
     72                      j = biL - mbedtls_mpi_core_clz(A[i]);
     73                      return (i * biL) + j;
   \       0x14   0x0140             LSLS     R0,R0,#+5
   \       0x16   0x3020             ADDS     R0,R0,#+32
   \       0x18   0xFAB1 0xF181      CLZ      R1,R1
   \       0x1C   0x1A40             SUBS     R0,R0,R1
   \       0x1E   0x4770             BX       LR
     74                  }
     75              }
     76          
     77              return 0;
   \                     ??mbedtls_mpi_core_bitlen_2: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR
     78          }
     79          

   \                                 In section .text, align 2, keep-with-next
     80          static mbedtls_mpi_uint mpi_bigendian_to_host(mbedtls_mpi_uint a)
     81          {
     82              if (MBEDTLS_IS_BIG_ENDIAN) {
   \                     mpi_bigendian_to_host: (+1)
   \        0x0   0x.... 0x....      ADR.W    R2,mbedtls_byte_order_detector
   \        0x4   0x7811             LDRB     R1,[R2, #+0]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD00A             BEQ.N    ??mpi_bigendian_to_host_0
     83                  /* Nothing to do on bigendian systems. */
     84                  return a;
     85              } else {
     86          #if defined(MBEDTLS_HAVE_INT32)
     87                  return (mbedtls_mpi_uint) MBEDTLS_BSWAP32(a);
   \        0xA   0x0201             LSLS     R1,R0,#+8
   \        0xC   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \       0x10   0xEA41 0x6100      ORR      R1,R1,R0, LSL #+24
   \       0x14   0x0A02             LSRS     R2,R0,#+8
   \       0x16   0xF402 0x427F      AND      R2,R2,#0xFF00
   \       0x1A   0x4311             ORRS     R1,R2,R1
   \       0x1C   0xEA41 0x6010      ORR      R0,R1,R0, LSR #+24
   \                     ??mpi_bigendian_to_host_0: (+1)
   \       0x20   0x4770             BX       LR
     88          #elif defined(MBEDTLS_HAVE_INT64)
     89                  return (mbedtls_mpi_uint) MBEDTLS_BSWAP64(a);
     90          #endif
     91              }
     92          }
     93          

   \                                 In section .text, align 2, keep-with-next
     94          void mbedtls_mpi_core_bigendian_to_host(mbedtls_mpi_uint *A,
     95                                                  size_t A_limbs)
     96          {
   \                     mbedtls_mpi_core_bigendian_to_host: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
     97              mbedtls_mpi_uint *cur_limb_left;
     98              mbedtls_mpi_uint *cur_limb_right;
     99              if (A_limbs == 0) {
   \        0x4   0xB181             CBZ.N    R1,??mbedtls_mpi_core_bigendian_to_host_0
    100                  return;
    101              }
    102          
    103              /*
    104               * Traverse limbs and
    105               * - adapt byte-order in each limb
    106               * - swap the limbs themselves.
    107               * For that, simultaneously traverse the limbs from left to right
    108               * and from right to left, as long as the left index is not bigger
    109               * than the right index (it's not a problem if limbs is odd and the
    110               * indices coincide in the last iteration).
    111               */
    112              for (cur_limb_left = A, cur_limb_right = A + (A_limbs - 1);
   \        0x6   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \        0xA   0x1F0E             SUBS     R6,R1,#+4
   \        0xC   0xE00A             B.N      ??mbedtls_mpi_core_bigendian_to_host_1
    113                   cur_limb_left <= cur_limb_right;
    114                   cur_limb_left++, cur_limb_right--) {
    115                  mbedtls_mpi_uint tmp;
    116                  /* Note that if cur_limb_left == cur_limb_right,
    117                   * this code effectively swaps the bytes only once. */
    118                  tmp             = mpi_bigendian_to_host(*cur_limb_left);
   \                     ??mbedtls_mpi_core_bigendian_to_host_2: (+1)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x.... 0x....      BL       mpi_bigendian_to_host
   \       0x14   0x4605             MOV      R5,R0
    119                  *cur_limb_left  = mpi_bigendian_to_host(*cur_limb_right);
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0x.... 0x....      BL       mpi_bigendian_to_host
   \       0x1C   0xF844 0x0B04      STR      R0,[R4], #+4
    120                  *cur_limb_right = tmp;
   \       0x20   0xF846 0x5904      STR      R5,[R6], #-4
    121              }
   \                     ??mbedtls_mpi_core_bigendian_to_host_1: (+1)
   \       0x24   0x42A6             CMP      R6,R4
   \       0x26   0xD2F2             BCS.N    ??mbedtls_mpi_core_bigendian_to_host_2
    122          }
   \                     ??mbedtls_mpi_core_bigendian_to_host_0: (+1)
   \       0x28   0xBD70             POP      {R4-R6,PC}
    123          
    124          /* Whether min <= A, in constant time.
    125           * A_limbs must be at least 1. */

   \                                 In section .text, align 2, keep-with-next
    126          mbedtls_ct_condition_t mbedtls_mpi_core_uint_le_mpi(mbedtls_mpi_uint min,
    127                                                              const mbedtls_mpi_uint *A,
    128                                                              size_t A_limbs)
    129          {
   \                     mbedtls_mpi_core_uint_le_mpi: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460C             MOV      R4,R1
    130              /* min <= least significant limb? */
    131              mbedtls_ct_condition_t min_le_lsl = mbedtls_ct_uint_ge(A[0], min);
   \        0x6   0x4601             MOV      R1,R0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x2701             MOVS     R7,#+1
   \        0xE   0x.... 0x....      BL       mbedtls_ct_uint_lt
    132          
    133              /* limbs other than the least significant one are all zero? */
    134              mbedtls_ct_condition_t msll_mask = MBEDTLS_CT_FALSE;
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable7
   \       0x16   0x43C6             MVNS     R6,R0
   \       0x18   0x680D             LDR      R5,[R1, #+0]
    135              for (size_t i = 1; i < A_limbs; i++) {
   \       0x1A   0xE005             B.N      ??mbedtls_mpi_core_uint_le_mpi_0
    136                  msll_mask = mbedtls_ct_bool_or(msll_mask, mbedtls_ct_bool(A[i]));
   \                     ??mbedtls_mpi_core_uint_le_mpi_1: (+1)
   \       0x1C   0xF854 0x0027      LDR      R0,[R4, R7, LSL #+2]
   \       0x20   0x1C7F             ADDS     R7,R7,#+1
   \       0x22   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x26   0x4305             ORRS     R5,R0,R5
    137              }
   \                     ??mbedtls_mpi_core_uint_le_mpi_0: (+1)
   \       0x28   0x4547             CMP      R7,R8
   \       0x2A   0xD3F7             BCC.N    ??mbedtls_mpi_core_uint_le_mpi_1
    138          
    139              /* min <= A iff the lowest limb of A is >= min or the other limbs
    140               * are not all zero. */
    141              return mbedtls_ct_bool_or(msll_mask, min_le_lsl);
   \       0x2C   0xEA46 0x0005      ORR      R0,R6,R5
   \       0x30   0xE8BD 0x81F0      POP      {R4-R8,PC}
    142          }
    143          

   \                                 In section .text, align 2, keep-with-next
    144          mbedtls_ct_condition_t mbedtls_mpi_core_lt_ct(const mbedtls_mpi_uint *A,
    145                                                        const mbedtls_mpi_uint *B,
    146                                                        size_t limbs)
    147          {
   \                     mbedtls_mpi_core_lt_ct: (+1)
   \        0x0   0xE92D 0x4AF8      PUSH     {R3-R7,R9,R11,LR}
   \        0x4   0x460F             MOV      R7,R1
    148              mbedtls_ct_condition_t ret = MBEDTLS_CT_FALSE, cond = MBEDTLS_CT_FALSE, done = MBEDTLS_CT_FALSE;
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable7
   \        0xA   0x4603             MOV      R3,R0
   \        0xC   0x680D             LDR      R5,[R1, #+0]
   \        0xE   0x6808             LDR      R0,[R1, #+0]
   \       0x10   0x0014             MOVS     R4,R2
   \       0x12   0x680E             LDR      R6,[R1, #+0]
    149          
    150              for (size_t i = limbs; i > 0; i--) {
   \       0x14   0xF1A3 0x0B04      SUB      R11,R3,#+4
   \       0x18   0xF1A7 0x0904      SUB      R9,R7,#+4
   \       0x1C   0xE013             B.N      ??mbedtls_mpi_core_lt_ct_0
    151                  /*
    152                   * If B[i - 1] < A[i - 1] then A < B is false and the result must
    153                   * remain 0.
    154                   *
    155                   * Again even if we can make a decision, we just mark the result and
    156                   * the fact that we are done and continue looping.
    157                   */
    158                  cond = mbedtls_ct_uint_lt(B[i - 1], A[i - 1]);
    159                  done = mbedtls_ct_bool_or(done, cond);
   \                     ??mbedtls_mpi_core_lt_ct_1: (+1)
   \       0x1E   0xF85B 0x1024      LDR      R1,[R11, R4, LSL #+2]
   \       0x22   0xF859 0x0024      LDR      R0,[R9, R4, LSL #+2]
   \       0x26   0x.... 0x....      BL       mbedtls_ct_uint_lt
   \       0x2A   0xEA40 0x0706      ORR      R7,R0,R6
    160          
    161                  /*
    162                   * If A[i - 1] < B[i - 1] then A < B is true.
    163                   *
    164                   * Again even if we can make a decision, we just mark the result and
    165                   * the fact that we are done and continue looping.
    166                   */
    167                  cond = mbedtls_ct_uint_lt(A[i - 1], B[i - 1]);
   \       0x2E   0xF859 0x1024      LDR      R1,[R9, R4, LSL #+2]
   \       0x32   0xF85B 0x0024      LDR      R0,[R11, R4, LSL #+2]
   \       0x36   0x.... 0x....      BL       mbedtls_ct_uint_lt
   \       0x3A   0x4606             MOV      R6,R0
    168                  ret  = mbedtls_ct_bool_or(ret, mbedtls_ct_bool_and(cond, mbedtls_ct_bool_not(done)));
   \       0x3C   0xEA26 0x0007      BIC      R0,R6,R7
   \       0x40   0x4305             ORRS     R5,R0,R5
    169                  done = mbedtls_ct_bool_or(done, cond);
    170              }
   \       0x42   0x433E             ORRS     R6,R6,R7
   \       0x44   0x1E64             SUBS     R4,R4,#+1
   \                     ??mbedtls_mpi_core_lt_ct_0: (+1)
   \       0x46   0xD1EA             BNE.N    ??mbedtls_mpi_core_lt_ct_1
    171          
    172              /*
    173               * If all the limbs were equal, then the numbers are equal, A < B is false
    174               * and leaving the result 0 is correct.
    175               */
    176          
    177              return ret;
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0xE8BD 0x8AF2      POP      {R1,R4-R7,R9,R11,PC}
    178          }
    179          

   \                                 In section .text, align 2, keep-with-next
    180          void mbedtls_mpi_core_cond_assign(mbedtls_mpi_uint *X,
    181                                            const mbedtls_mpi_uint *A,
    182                                            size_t limbs,
    183                                            mbedtls_ct_condition_t assign)
    184          {
   \                     mbedtls_mpi_core_cond_assign: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
    185              if (X == A) {
   \        0xC   0x45A0             CMP      R8,R4
   \        0xE   0xD00D             BEQ.N    ??mbedtls_mpi_core_cond_assign_0
    186                  return;
    187              }
    188          
    189              /* This function is very performance-sensitive for RSA. For this reason
    190               * we have the loop below, instead of calling mbedtls_ct_memcpy_if
    191               * (this is more optimal since here we don't have to handle the case where
    192               * we copy awkwardly sized data).
    193               */
    194              for (size_t i = 0; i < limbs; i++) {
   \       0x10   0x2700             MOVS     R7,#+0
   \       0x12   0xE009             B.N      ??mbedtls_mpi_core_cond_assign_1
    195                  X[i] = mbedtls_ct_mpi_uint_if(assign, A[i], X[i]);
   \                     ??mbedtls_mpi_core_cond_assign_2: (+1)
   \       0x14   0xF858 0x2027      LDR      R2,[R8, R7, LSL #+2]
   \       0x18   0xF854 0x1027      LDR      R1,[R4, R7, LSL #+2]
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x.... 0x....      BL       mbedtls_ct_mpi_uint_if
   \       0x22   0xF848 0x0027      STR      R0,[R8, R7, LSL #+2]
    196              }
   \       0x26   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_core_cond_assign_1: (+1)
   \       0x28   0x42AF             CMP      R7,R5
   \       0x2A   0xD3F3             BCC.N    ??mbedtls_mpi_core_cond_assign_2
    197          }
   \                     ??mbedtls_mpi_core_cond_assign_0: (+1)
   \       0x2C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    198          

   \                                 In section .text, align 2, keep-with-next
    199          void mbedtls_mpi_core_cond_swap(mbedtls_mpi_uint *X,
    200                                          mbedtls_mpi_uint *Y,
    201                                          size_t limbs,
    202                                          mbedtls_ct_condition_t swap)
    203          {
   \                     mbedtls_mpi_core_cond_swap: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
    204              if (X == Y) {
   \        0xC   0x45A1             CMP      R9,R4
   \        0xE   0xD016             BEQ.N    ??mbedtls_mpi_core_cond_swap_0
    205                  return;
    206              }
    207          
    208              for (size_t i = 0; i < limbs; i++) {
   \       0x10   0x2700             MOVS     R7,#+0
   \       0x12   0xE012             B.N      ??mbedtls_mpi_core_cond_swap_1
    209                  mbedtls_mpi_uint tmp = X[i];
   \                     ??mbedtls_mpi_core_cond_swap_2: (+1)
   \       0x14   0xF859 0x8027      LDR      R8,[R9, R7, LSL #+2]
    210                  X[i] = mbedtls_ct_mpi_uint_if(swap, Y[i], X[i]);
   \       0x18   0xF854 0x1027      LDR      R1,[R4, R7, LSL #+2]
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x4642             MOV      R2,R8
   \       0x20   0x.... 0x....      BL       mbedtls_ct_mpi_uint_if
   \       0x24   0xF849 0x0027      STR      R0,[R9, R7, LSL #+2]
    211                  Y[i] = mbedtls_ct_mpi_uint_if(swap, tmp, Y[i]);
   \       0x28   0xF854 0x2027      LDR      R2,[R4, R7, LSL #+2]
   \       0x2C   0x4641             MOV      R1,R8
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0x.... 0x....      BL       mbedtls_ct_mpi_uint_if
   \       0x34   0xF844 0x0027      STR      R0,[R4, R7, LSL #+2]
    212              }
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_core_cond_swap_1: (+1)
   \       0x3A   0x42AF             CMP      R7,R5
   \       0x3C   0xD3EA             BCC.N    ??mbedtls_mpi_core_cond_swap_2
    213          }
   \                     ??mbedtls_mpi_core_cond_swap_0: (+1)
   \       0x3E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
    214          

   \                                 In section .text, align 2, keep-with-next
    215          int mbedtls_mpi_core_read_le(mbedtls_mpi_uint *X,
    216                                       size_t X_limbs,
    217                                       const unsigned char *input,
    218                                       size_t input_length)
    219          {
   \                     mbedtls_mpi_core_read_le: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x461E             MOV      R6,R3
   \        0x6   0x4604             MOV      R4,R0
    220              const size_t limbs = CHARS_TO_LIMBS(input_length);
   \        0x8   0xF016 0x0203      ANDS     R2,R6,#0x3
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2201             MOVNE    R2,#+1
    221          
    222              if (X_limbs < limbs) {
   \       0x10   0xEB02 0x0096      ADD      R0,R2,R6, LSR #+2
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD200             BCS.N    ??mbedtls_mpi_core_read_le_0
    223                  return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   \       0x18   0x....             B.N      ?Subroutine0
    224              }
    225          
    226              if (X != NULL) {
   \                     ??mbedtls_mpi_core_read_le_0: (+1)
   \       0x1A   0xB19C             CBZ.N    R4,??mbedtls_mpi_core_read_le_1
    227                  memset(X, 0, X_limbs * ciL);
   \       0x1C   0x0089             LSLS     R1,R1,#+2
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       __aeabi_memclr4
    228          
    229                  for (size_t i = 0; i < input_length; i++) {
   \       0x24   0x2700             MOVS     R7,#+0
   \       0x26   0xE00B             B.N      ??mbedtls_mpi_core_read_le_2
    230                      size_t offset = ((i % ciL) << 3);
    231                      X[i / ciL] |= ((mbedtls_mpi_uint) input[i]) << offset;
   \                     ??mbedtls_mpi_core_read_le_3: (+1)
   \       0x28   0x08BB             LSRS     R3,R7,#+2
   \       0x2A   0x5DE9             LDRB     R1,[R5, R7]
   \       0x2C   0xF854 0x0023      LDR      R0,[R4, R3, LSL #+2]
   \       0x30   0x00FA             LSLS     R2,R7,#+3
   \       0x32   0xF002 0x0218      AND      R2,R2,#0x18
   \       0x36   0x4091             LSLS     R1,R1,R2
   \       0x38   0x4308             ORRS     R0,R1,R0
   \       0x3A   0xF844 0x0023      STR      R0,[R4, R3, LSL #+2]
    232                  }
   \       0x3E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_core_read_le_2: (+1)
   \       0x40   0x42B7             CMP      R7,R6
   \       0x42   0xD3F1             BCC.N    ??mbedtls_mpi_core_read_le_3
    233              }
    234          
    235              return 0;
   \                     ??mbedtls_mpi_core_read_le_1: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBDF2             POP      {R1,R4-R7,PC}
    236          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x0007      MVN      R0,#+7
   \        0x4   0xBDF2             POP      {R1,R4-R7,PC}
    237          

   \                                 In section .text, align 2, keep-with-next
    238          int mbedtls_mpi_core_read_be(mbedtls_mpi_uint *X,
    239                                       size_t X_limbs,
    240                                       const unsigned char *input,
    241                                       size_t input_length)
    242          {
   \                     mbedtls_mpi_core_read_be: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x461D             MOV      R5,R3
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x4690             MOV      R8,R2
    243              const size_t limbs = CHARS_TO_LIMBS(input_length);
   \        0xC   0xF015 0x0103      ANDS     R1,R5,#0x3
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2101             MOVNE    R1,#+1
    244          
    245              if (X_limbs < limbs) {
   \       0x14   0xEB01 0x0095      ADD      R0,R1,R5, LSR #+2
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xBF38             IT       CC
   \       0x1C   0xF06F 0x0007      MVNCC    R0,#+7
    246                  return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
   \       0x20   0xD311             BCC.N    ??mbedtls_mpi_core_read_be_0
    247              }
    248          
    249              /* If X_limbs is 0, input_length must also be 0 (from previous test).
    250               * Nothing to do. */
    251              if (X_limbs == 0) {
   \       0x22   0xB17C             CBZ.N    R4,??mbedtls_mpi_core_read_be_1
    252                  return 0;
    253              }
    254          
    255              memset(X, 0, X_limbs * ciL);
   \       0x24   0x00A6             LSLS     R6,R4,#+2
   \       0x26   0x4631             MOV      R1,R6
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0x.... 0x....      BL       __aeabi_memclr4
    256          
    257              /* memcpy() with (NULL, 0) is undefined behaviour */
    258              if (input_length != 0) {
   \       0x2E   0xB12D             CBZ.N    R5,??mbedtls_mpi_core_read_be_2
    259                  size_t overhead = (X_limbs * ciL) - input_length;
    260                  unsigned char *Xp = (unsigned char *) X;
    261                  memcpy(Xp + overhead, input, input_length);
   \       0x30   0x462A             MOV      R2,R5
   \       0x32   0x1B75             SUBS     R5,R6,R5
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x1978             ADDS     R0,R7,R5
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy
    262              }
    263          
    264              mbedtls_mpi_core_bigendian_to_host(X, X_limbs);
   \                     ??mbedtls_mpi_core_read_be_2: (+1)
   \       0x3C   0x4621             MOV      R1,R4
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_core_bigendian_to_host
    265          
    266              return 0;
   \                     ??mbedtls_mpi_core_read_be_1: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_mpi_core_read_be_0: (+1)
   \       0x46   0xE8BD 0x81F0      POP      {R4-R8,PC}
    267          }
    268          

   \                                 In section .text, align 2, keep-with-next
    269          int mbedtls_mpi_core_write_le(const mbedtls_mpi_uint *A,
    270                                        size_t A_limbs,
    271                                        unsigned char *output,
    272                                        size_t output_length)
    273          {
   \                     mbedtls_mpi_core_write_le: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    274              size_t stored_bytes = A_limbs * ciL;
   \        0x2   0x008C             LSLS     R4,R1,#+2
    275              size_t bytes_to_copy;
    276          
    277              if (stored_bytes < output_length) {
   \        0x4   0x429C             CMP      R4,R3
   \        0x6   0xD202             BCS.N    ??mbedtls_mpi_core_write_le_0
    278                  bytes_to_copy = stored_bytes;
   \        0x8   0x4621             MOV      R1,R4
    279              } else {
    280                  bytes_to_copy = output_length;
    281          
    282                  /* The output buffer is smaller than the allocated size of A.
    283                   * However A may fit if its leading bytes are zero. */
    284                  for (size_t i = bytes_to_copy; i < stored_bytes; i++) {
    285                      if (GET_BYTE(A, i) != 0) {
    286                          return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
    287                      }
    288                  }
    289              }
    290          
    291              for (size_t i = 0; i < bytes_to_copy; i++) {
   \                     ??mbedtls_mpi_core_write_le_1: (+1)
   \        0xA   0x2600             MOVS     R6,#+0
   \        0xC   0xE00E             B.N      ??mbedtls_mpi_core_write_le_2
   \                     ??mbedtls_mpi_core_write_le_0: (+1)
   \        0xE   0x4619             MOV      R1,R3
   \       0x10   0x460E             MOV      R6,R1
   \       0x12   0xE000             B.N      ??mbedtls_mpi_core_write_le_3
   \                     ??mbedtls_mpi_core_write_le_4: (+1)
   \       0x14   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_mpi_core_write_le_3: (+1)
   \       0x16   0x42A6             CMP      R6,R4
   \       0x18   0xD2F7             BCS.N    ??mbedtls_mpi_core_write_le_1
   \       0x1A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x1E   0x063F             LSLS     R7,R7,#+24
   \       0x20   0xD0F8             BEQ.N    ??mbedtls_mpi_core_write_le_4
   \       0x22   0x....             B.N      ?Subroutine0
    292                  output[i] = GET_BYTE(A, i);
   \                     ??mbedtls_mpi_core_write_le_5: (+1)
   \       0x24   0x.... 0x....      BL       ?Subroutine1
    293              }
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x28   0x5597             STRB     R7,[R2, R6]
   \       0x2A   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_mpi_core_write_le_2: (+1)
   \       0x2C   0x428E             CMP      R6,R1
   \       0x2E   0xD3F9             BCC.N    ??mbedtls_mpi_core_write_le_5
    294          
    295              if (stored_bytes < output_length) {
   \       0x30   0x429C             CMP      R4,R3
   \       0x32   0xD203             BCS.N    ??mbedtls_mpi_core_write_le_6
    296                  /* Write trailing 0 bytes */
    297                  memset(output + stored_bytes, 0, output_length - stored_bytes);
   \       0x34   0x1B19             SUBS     R1,R3,R4
   \       0x36   0x1910             ADDS     R0,R2,R4
   \       0x38   0x.... 0x....      BL       __aeabi_memclr
    298              }
    299          
    300              return 0;
   \                     ??mbedtls_mpi_core_write_le_6: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBDF2             POP      {R1,R4-R7,PC}
    301          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xEA4F 0x0C96      LSR      R12,R6,#+2
   \        0x4   0xF850 0x702C      LDR      R7,[R0, R12, LSL #+2]
   \        0x8   0x00F5             LSLS     R5,R6,#+3
   \        0xA   0xF005 0x0518      AND      R5,R5,#0x18
   \        0xE   0x40EF             LSRS     R7,R7,R5
   \       0x10   0x4770             BX       LR
    302          

   \                                 In section .text, align 2, keep-with-next
    303          int mbedtls_mpi_core_write_be(const mbedtls_mpi_uint *X,
    304                                        size_t X_limbs,
    305                                        unsigned char *output,
    306                                        size_t output_length)
    307          {
   \                     mbedtls_mpi_core_write_be: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    308              size_t stored_bytes;
    309              size_t bytes_to_copy;
    310              unsigned char *p;
    311          
    312              stored_bytes = X_limbs * ciL;
   \        0x2   0x0089             LSLS     R1,R1,#+2
   \        0x4   0x4606             MOV      R6,R0
    313          
    314              if (stored_bytes < output_length) {
   \        0x6   0x4299             CMP      R1,R3
   \        0x8   0xD209             BCS.N    ??mbedtls_mpi_core_write_be_0
    315                  /* There is enough space in the output buffer. Write initial
    316                   * null bytes and record the position at which to start
    317                   * writing the significant bytes. In this case, the execution
    318                   * trace of this function does not depend on the value of the
    319                   * number. */
    320                  bytes_to_copy = stored_bytes;
    321                  p = output + output_length - stored_bytes;
   \        0xA   0x18D5             ADDS     R5,R2,R3
   \        0xC   0x4248             RSBS     R0,R1,#+0
   \        0xE   0x460C             MOV      R4,R1
   \       0x10   0x4405             ADD      R5,R5,R0
    322                  memset(output, 0, output_length - stored_bytes);
   \       0x12   0x1A59             SUBS     R1,R3,R1
   \       0x14   0x4610             MOV      R0,R2
   \       0x16   0x.... 0x....      BL       __aeabi_memclr
    323              } else {
    324                  /* The output buffer is smaller than the allocated size of X.
    325                   * However X may fit if its leading bytes are zero. */
    326                  bytes_to_copy = output_length;
    327                  p = output;
    328                  for (size_t i = bytes_to_copy; i < stored_bytes; i++) {
    329                      if (GET_BYTE(X, i) != 0) {
    330                          return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
    331                      }
    332                  }
    333              }
    334          
    335              for (size_t i = 0; i < bytes_to_copy; i++) {
   \                     ??mbedtls_mpi_core_write_be_1: (+1)
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0xE01C             B.N      ??mbedtls_mpi_core_write_be_2
   \                     ??mbedtls_mpi_core_write_be_0: (+1)
   \       0x1E   0x461C             MOV      R4,R3
   \       0x20   0x4615             MOV      R5,R2
   \       0x22   0x4622             MOV      R2,R4
   \       0x24   0xE000             B.N      ??mbedtls_mpi_core_write_be_3
   \                     ??mbedtls_mpi_core_write_be_4: (+1)
   \       0x26   0x1C52             ADDS     R2,R2,#+1
   \                     ??mbedtls_mpi_core_write_be_3: (+1)
   \       0x28   0x428A             CMP      R2,R1
   \       0x2A   0xD2F6             BCS.N    ??mbedtls_mpi_core_write_be_1
   \       0x2C   0x0897             LSRS     R7,R2,#+2
   \       0x2E   0xF856 0x3027      LDR      R3,[R6, R7, LSL #+2]
   \       0x32   0x00D0             LSLS     R0,R2,#+3
   \       0x34   0xF000 0x0018      AND      R0,R0,#0x18
   \       0x38   0x40C3             LSRS     R3,R3,R0
   \       0x3A   0x061B             LSLS     R3,R3,#+24
   \       0x3C   0xD0F3             BEQ.N    ??mbedtls_mpi_core_write_be_4
   \       0x3E   0x....             B.N      ?Subroutine0
    336                  p[bytes_to_copy - i - 1] = GET_BYTE(X, i);
   \                     ??mbedtls_mpi_core_write_be_5: (+1)
   \       0x40   0x088A             LSRS     R2,R1,#+2
   \       0x42   0xF856 0x0022      LDR      R0,[R6, R2, LSL #+2]
   \       0x46   0x00CB             LSLS     R3,R1,#+3
   \       0x48   0xF003 0x0318      AND      R3,R3,#0x18
   \       0x4C   0x1A62             SUBS     R2,R4,R1
   \       0x4E   0x40D8             LSRS     R0,R0,R3
   \       0x50   0x442A             ADD      R2,R5,R2
   \       0x52   0xF802 0x0C01      STRB     R0,[R2, #-1]
    337              }
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \                     ??mbedtls_mpi_core_write_be_2: (+1)
   \       0x58   0x42A1             CMP      R1,R4
   \       0x5A   0xD3F1             BCC.N    ??mbedtls_mpi_core_write_be_5
    338          
    339              return 0;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}
    340          }
    341          

   \                                 In section .text, align 2, keep-with-next
    342          void mbedtls_mpi_core_shift_r(mbedtls_mpi_uint *X, size_t limbs,
    343                                        size_t count)
    344          {
   \                     mbedtls_mpi_core_shift_r: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460C             MOV      R4,R1
    345              size_t i, v0, v1;
    346              mbedtls_mpi_uint r0 = 0, r1;
   \        0x8   0x2600             MOVS     R6,#+0
    347          
    348              v0 = count /  biL;
   \        0xA   0x0950             LSRS     R0,R2,#+5
    349              v1 = count & (biL - 1);
   \        0xC   0xF002 0x051F      AND      R5,R2,#0x1F
    350          
    351              if (v0 > limbs || (v0 == limbs && v1 > 0)) {
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD302             BCC.N    ??mbedtls_mpi_core_shift_r_0
   \       0x14   0x42A0             CMP      R0,R4
   \       0x16   0xD106             BNE.N    ??mbedtls_mpi_core_shift_r_1
   \       0x18   0xB12D             CBZ.N    R5,??mbedtls_mpi_core_shift_r_1
    352                  memset(X, 0, limbs * ciL);
   \                     ??mbedtls_mpi_core_shift_r_0: (+1)
   \       0x1A   0x00A1             LSLS     R1,R4,#+2
   \       0x1C   0x4640             MOV      R0,R8
   \       0x1E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x22   0x.... 0x....      B.W      __aeabi_memclr4
    353                  return;
    354              }
    355          
    356              /*
    357               * shift by count / limb_size
    358               */
    359              if (v0 > 0) {
   \                     ??mbedtls_mpi_core_shift_r_1: (+1)
   \       0x26   0xB198             CBZ.N    R0,??mbedtls_mpi_core_shift_r_2
    360                  for (i = 0; i < limbs - v0; i++) {
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0xE005             B.N      ??mbedtls_mpi_core_shift_r_3
    361                      X[i] = X[i + v0];
   \                     ??mbedtls_mpi_core_shift_r_4: (+1)
   \       0x2C   0x1881             ADDS     R1,R0,R2
   \       0x2E   0xF858 0x3021      LDR      R3,[R8, R1, LSL #+2]
   \       0x32   0xF848 0x3022      STR      R3,[R8, R2, LSL #+2]
    362                  }
   \       0x36   0x463A             MOV      R2,R7
   \                     ??mbedtls_mpi_core_shift_r_3: (+1)
   \       0x38   0x1C57             ADDS     R7,R2,#+1
   \       0x3A   0x1A21             SUBS     R1,R4,R0
   \       0x3C   0x428A             CMP      R2,R1
   \       0x3E   0xD3F5             BCC.N    ??mbedtls_mpi_core_shift_r_4
    363          
    364                  for (; i < limbs; i++) {
   \       0x40   0x42A2             CMP      R2,R4
   \       0x42   0xD205             BCS.N    ??mbedtls_mpi_core_shift_r_2
    365                      X[i] = 0;
   \       0x44   0x1AA1             SUBS     R1,R4,R2
   \       0x46   0x0089             LSLS     R1,R1,#+2
   \       0x48   0xEB08 0x0082      ADD      R0,R8,R2, LSL #+2
   \       0x4C   0x.... 0x....      BL       __aeabi_memclr
    366                  }
    367              }
    368          
    369              /*
    370               * shift by count % limb_size
    371               */
    372              if (v1 > 0) {
   \                     ??mbedtls_mpi_core_shift_r_2: (+1)
   \       0x50   0xB185             CBZ.N    R5,??mbedtls_mpi_core_shift_r_5
    373                  for (i = limbs; i > 0; i--) {
   \       0x52   0x2C00             CMP      R4,#+0
   \       0x54   0xE00D             B.N      ??mbedtls_mpi_core_shift_r_6
    374                      r1 = X[i - 1] << (biL - v1);
   \                     ??mbedtls_mpi_core_shift_r_7: (+1)
   \       0x56   0xEB08 0x0284      ADD      R2,R8,R4, LSL #+2
   \       0x5A   0xF852 0x0C04      LDR      R0,[R2, #-4]
   \       0x5E   0xF1C5 0x0120      RSB      R1,R5,#+32
   \       0x62   0xFA00 0xF101      LSL      R1,R0,R1
    375                      X[i - 1] >>= v1;
    376                      X[i - 1] |= r0;
   \       0x66   0x40E8             LSRS     R0,R0,R5
   \       0x68   0x4306             ORRS     R6,R6,R0
   \       0x6A   0xF842 0x6C04      STR      R6,[R2, #-4]
    377                      r0 = r1;
   \       0x6E   0x460E             MOV      R6,R1
    378                  }
   \       0x70   0x1E64             SUBS     R4,R4,#+1
   \                     ??mbedtls_mpi_core_shift_r_6: (+1)
   \       0x72   0xD1F0             BNE.N    ??mbedtls_mpi_core_shift_r_7
    379              }
    380          }
   \                     ??mbedtls_mpi_core_shift_r_5: (+1)
   \       0x74   0xE8BD 0x81F0      POP      {R4-R8,PC}
    381          

   \                                 In section .text, align 2, keep-with-next
    382          void mbedtls_mpi_core_shift_l(mbedtls_mpi_uint *X, size_t limbs,
    383                                        size_t count)
    384          {
   \                     mbedtls_mpi_core_shift_l: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    385              size_t i, v0, v1;
    386              mbedtls_mpi_uint r0 = 0, r1;
   \        0x2   0x2500             MOVS     R5,#+0
    387          
    388              v0 = count / (biL);
   \        0x4   0x0954             LSRS     R4,R2,#+5
   \        0x6   0x4603             MOV      R3,R0
    389              v1 = count & (biL - 1);
   \        0x8   0xF002 0x021F      AND      R2,R2,#0x1F
    390          
    391              /*
    392               * shift by count / limb_size
    393               */
    394              if (v0 > 0) {
   \        0xC   0xD010             BEQ.N    ??mbedtls_mpi_core_shift_l_0
    395                  for (i = limbs; i > v0; i--) {
   \        0xE   0x4608             MOV      R0,R1
   \       0x10   0x1F1E             SUBS     R6,R3,#+4
   \       0x12   0xE005             B.N      ??mbedtls_mpi_core_shift_l_1
    396                      X[i - 1] = X[i - v0 - 1];
   \                     ??mbedtls_mpi_core_shift_l_2: (+1)
   \       0x14   0x1B07             SUBS     R7,R0,R4
   \       0x16   0xF856 0x7027      LDR      R7,[R6, R7, LSL #+2]
   \       0x1A   0xF846 0x7020      STR      R7,[R6, R0, LSL #+2]
    397                  }
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \                     ??mbedtls_mpi_core_shift_l_1: (+1)
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xD3F7             BCC.N    ??mbedtls_mpi_core_shift_l_2
    398          
    399                  for (; i > 0; i--) {
   \                     ??mbedtls_mpi_core_shift_l_3: (+1)
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xBF1C             ITT      NE
   \       0x28   0xF846 0x5020      STRNE    R5,[R6, R0, LSL #+2]
   \       0x2C   0x1E40             SUBNE    R0,R0,#+1
    400                      X[i - 1] = 0;
   \       0x2E   0xD1F9             BNE.N    ??mbedtls_mpi_core_shift_l_3
    401                  }
    402              }
    403          
    404              /*
    405               * shift by count % limb_size
    406               */
    407              if (v1 > 0) {
   \                     ??mbedtls_mpi_core_shift_l_0: (+1)
   \       0x30   0xB172             CBZ.N    R2,??mbedtls_mpi_core_shift_l_4
    408                  for (i = v0; i < limbs; i++) {
   \       0x32   0xF1C2 0x0020      RSB      R0,R2,#+32
   \       0x36   0xE009             B.N      ??mbedtls_mpi_core_shift_l_5
    409                      r1 = X[i] >> (biL - v1);
   \                     ??mbedtls_mpi_core_shift_l_6: (+1)
   \       0x38   0xF853 0x7024      LDR      R7,[R3, R4, LSL #+2]
   \       0x3C   0xFA27 0xF600      LSR      R6,R7,R0
    410                      X[i] <<= v1;
    411                      X[i] |= r0;
   \       0x40   0x4097             LSLS     R7,R7,R2
   \       0x42   0x433D             ORRS     R5,R5,R7
   \       0x44   0xF843 0x5024      STR      R5,[R3, R4, LSL #+2]
    412                      r0 = r1;
   \       0x48   0x4635             MOV      R5,R6
    413                  }
   \       0x4A   0x1C64             ADDS     R4,R4,#+1
   \                     ??mbedtls_mpi_core_shift_l_5: (+1)
   \       0x4C   0x428C             CMP      R4,R1
   \       0x4E   0xD3F3             BCC.N    ??mbedtls_mpi_core_shift_l_6
    414              }
    415          }
   \                     ??mbedtls_mpi_core_shift_l_4: (+1)
   \       0x50   0xBDF0             POP      {R4-R7,PC}
    416          

   \                                 In section .text, align 2, keep-with-next
    417          mbedtls_mpi_uint mbedtls_mpi_core_add(mbedtls_mpi_uint *X,
    418                                                const mbedtls_mpi_uint *A,
    419                                                const mbedtls_mpi_uint *B,
    420                                                size_t limbs)
    421          {
   \                     mbedtls_mpi_core_add: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    422              mbedtls_mpi_uint c = 0;
   \        0x4   0x2000             MOVS     R0,#+0
    423          
    424              for (size_t i = 0; i < limbs; i++) {
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0xE00F             B.N      ??mbedtls_mpi_core_add_0
    425                  mbedtls_mpi_uint t = c + A[i];
   \                     ??mbedtls_mpi_core_add_1: (+1)
   \        0xA   0xF851 0x7026      LDR      R7,[R1, R6, LSL #+2]
   \        0xE   0x1838             ADDS     R0,R7,R0
   \       0x10   0x4605             MOV      R5,R0
    426                  c = (t < A[i]);
   \       0x12   0x42BD             CMP      R5,R7
    427                  t += B[i];
   \       0x14   0xF852 0x7026      LDR      R7,[R2, R6, LSL #+2]
   \       0x18   0x4180             SBCS     R0,R0,R0
   \       0x1A   0x0FC0             LSRS     R0,R0,#+31
   \       0x1C   0x197D             ADDS     R5,R7,R5
    428                  c += (t < B[i]);
   \       0x1E   0x42BD             CMP      R5,R7
   \       0x20   0xBF38             IT       CC
   \       0x22   0x1C40             ADDCC    R0,R0,#+1
    429                  X[i] = t;
   \       0x24   0xF844 0x5026      STR      R5,[R4, R6, LSL #+2]
    430              }
   \       0x28   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_mpi_core_add_0: (+1)
   \       0x2A   0x429E             CMP      R6,R3
   \       0x2C   0xD3ED             BCC.N    ??mbedtls_mpi_core_add_1
    431          
    432              return c;
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
    433          }
    434          

   \                                 In section .text, align 2, keep-with-next
    435          mbedtls_mpi_uint mbedtls_mpi_core_add_if(mbedtls_mpi_uint *X,
    436                                                   const mbedtls_mpi_uint *A,
    437                                                   size_t limbs,
    438                                                   unsigned cond)
    439          {
   \                     mbedtls_mpi_core_add_if: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    440              mbedtls_mpi_uint c = 0;
    441          
    442              mbedtls_ct_condition_t do_add = mbedtls_ct_bool(cond);
   \        0x8   0x4618             MOV      R0,R3
   \        0xA   0x2700             MOVS     R7,#+0
   \        0xC   0x.... 0x....      BL       mbedtls_ct_bool
    443          
    444              for (size_t i = 0; i < limbs; i++) {
   \       0x10   0x46BC             MOV      R12,R7
   \       0x12   0xE011             B.N      ??mbedtls_mpi_core_add_if_0
    445                  mbedtls_mpi_uint add = mbedtls_ct_mpi_uint_if_else_0(do_add, A[i]);
    446                  mbedtls_mpi_uint t = c + X[i];
   \                     ??mbedtls_mpi_core_add_if_1: (+1)
   \       0x14   0xF854 0x102C      LDR      R1,[R4, R12, LSL #+2]
   \       0x18   0xF855 0x302C      LDR      R3,[R5, R12, LSL #+2]
   \       0x1C   0x19CF             ADDS     R7,R1,R7
   \       0x1E   0x463A             MOV      R2,R7
   \       0x20   0x4003             ANDS     R3,R3,R0
    447                  c = (t < X[i]);
   \       0x22   0x428A             CMP      R2,R1
   \       0x24   0x41BF             SBCS     R7,R7,R7
   \       0x26   0x0FFF             LSRS     R7,R7,#+31
    448                  t += add;
   \       0x28   0x189A             ADDS     R2,R3,R2
    449                  c += (t < add);
   \       0x2A   0x429A             CMP      R2,R3
   \       0x2C   0xBF38             IT       CC
   \       0x2E   0x1C7F             ADDCC    R7,R7,#+1
    450                  X[i] = t;
   \       0x30   0xF844 0x202C      STR      R2,[R4, R12, LSL #+2]
    451              }
   \       0x34   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??mbedtls_mpi_core_add_if_0: (+1)
   \       0x38   0x45B4             CMP      R12,R6
   \       0x3A   0xD3EB             BCC.N    ??mbedtls_mpi_core_add_if_1
    452          
    453              return c;
   \       0x3C   0x4638             MOV      R0,R7
   \       0x3E   0xBDF2             POP      {R1,R4-R7,PC}
    454          }
    455          

   \                                 In section .text, align 2, keep-with-next
    456          mbedtls_mpi_uint mbedtls_mpi_core_sub(mbedtls_mpi_uint *X,
    457                                                const mbedtls_mpi_uint *A,
    458                                                const mbedtls_mpi_uint *B,
    459                                                size_t limbs)
    460          {
   \                     mbedtls_mpi_core_sub: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    461              mbedtls_mpi_uint c = 0;
   \        0x2   0x2400             MOVS     R4,#+0
    462          
    463              for (size_t i = 0; i < limbs; i++) {
   \        0x4   0x46A4             MOV      R12,R4
   \        0x6   0xE011             B.N      ??mbedtls_mpi_core_sub_0
    464                  mbedtls_mpi_uint z = (A[i] < c);
   \                     ??mbedtls_mpi_core_sub_1: (+1)
   \        0x8   0xF851 0x502C      LDR      R5,[R1, R12, LSL #+2]
    465                  mbedtls_mpi_uint t = A[i] - c;
    466                  c = (t < B[i]) + z;
   \        0xC   0xF852 0x602C      LDR      R6,[R2, R12, LSL #+2]
   \       0x10   0x42A5             CMP      R5,R4
   \       0x12   0x41BF             SBCS     R7,R7,R7
   \       0x14   0x1B2C             SUBS     R4,R5,R4
   \       0x16   0x0FFF             LSRS     R7,R7,#+31
   \       0x18   0x4625             MOV      R5,R4
   \       0x1A   0x42B5             CMP      R5,R6
   \       0x1C   0x41A4             SBCS     R4,R4,R4
    467                  X[i] = t - B[i];
   \       0x1E   0x1BAD             SUBS     R5,R5,R6
   \       0x20   0xF840 0x502C      STR      R5,[R0, R12, LSL #+2]
   \       0x24   0xEB07 0x74D4      ADD      R4,R7,R4, LSR #+31
    468              }
   \       0x28   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??mbedtls_mpi_core_sub_0: (+1)
   \       0x2C   0x459C             CMP      R12,R3
   \       0x2E   0xD3EB             BCC.N    ??mbedtls_mpi_core_sub_1
    469          
    470              return c;
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0xBDF0             POP      {R4-R7,PC}
    471          }
    472          

   \                                 In section .text, align 2, keep-with-next
    473          mbedtls_mpi_uint mbedtls_mpi_core_mla(mbedtls_mpi_uint *d, size_t d_len,
    474                                                const mbedtls_mpi_uint *s, size_t s_len,
    475                                                mbedtls_mpi_uint b)
    476          {
   \                     mbedtls_mpi_core_mla: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4614             MOV      R4,R2
   \        0x4   0x9D05             LDR      R5,[SP, #+20]
    477              mbedtls_mpi_uint c = 0; /* carry */
   \        0x6   0xF04F 0x0C00      MOV      R12,#+0
    478              /*
    479               * It is a documented precondition of this function that d_len >= s_len.
    480               * If that's not the case, we swap these round: this turns what would be
    481               * a buffer overflow into an incorrect result.
    482               */
    483              if (d_len < s_len) {
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x4299             CMP      R1,R3
   \        0xE   0xBF88             IT       HI
   \       0x10   0x461E             MOVHI    R6,R3
    484                  s_len = d_len;
    485              }
    486              size_t excess_len = d_len - s_len;
   \       0x12   0x1B8F             SUBS     R7,R1,R6
    487              size_t steps_x8 = s_len / 8;
    488              size_t steps_x1 = s_len & 7;
   \       0x14   0x4623             MOV      R3,R4
   \       0x16   0x08F1             LSRS     R1,R6,#+3
   \       0x18   0x462C             MOV      R4,R5
   \       0x1A   0xF006 0x0607      AND      R6,R6,#0x7
   \       0x1E   0x4602             MOV      R2,R0
   \       0x20   0x460D             MOV      R5,R1
   \       0x22   0xE012             B.N      ??mbedtls_mpi_core_mla_0
    489          
    490              while (steps_x8--) {
    491                  MULADDC_X8_INIT
    492                  MULADDC_X8_CORE
   \                     ??mbedtls_mpi_core_mla_1: (+1)
   \       0x24   0x6190             STR      R0,[R2, #+24]
   \       0x26   0x69D8             LDR      R0,[R3, #+28]
   \       0x28   0x3320             ADDS     R3,R3,#+32
   \       0x2A   0xFBA4 0x0100      UMULL    R0,R1,R4,R0
   \       0x2E   0x4470             ADD      R0,LR,R0
   \       0x30   0x4570             CMP      R0,LR
   \       0x32   0x468C             MOV      R12,R1
   \       0x34   0xBF38             IT       CC
   \       0x36   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0x3A   0x69D1             LDR      R1,[R2, #+28]
   \       0x3C   0x1808             ADDS     R0,R1,R0
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xBF38             IT       CC
   \       0x42   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0x46   0x61D0             STR      R0,[R2, #+28]
   \       0x48   0x3220             ADDS     R2,R2,#+32
   \                     ??mbedtls_mpi_core_mla_0: (+1)
   \       0x4A   0x4628             MOV      R0,R5
   \       0x4C   0x1E45             SUBS     R5,R0,#+1
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD06A             BEQ.N    ??mbedtls_mpi_core_mla_2
   \       0x52   0xF8D3 0xE000      LDR      LR,[R3, #+0]
   \       0x56   0xFBA4 0x010E      UMULL    R0,R1,R4,LR
   \       0x5A   0x4460             ADD      R0,R12,R0
   \       0x5C   0x4560             CMP      R0,R12
   \       0x5E   0x468E             MOV      LR,R1
   \       0x60   0xBF38             IT       CC
   \       0x62   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \       0x66   0x6811             LDR      R1,[R2, #+0]
   \       0x68   0x1808             ADDS     R0,R1,R0
   \       0x6A   0x4288             CMP      R0,R1
   \       0x6C   0xBF38             IT       CC
   \       0x6E   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \       0x72   0x6010             STR      R0,[R2, #+0]
   \       0x74   0x6858             LDR      R0,[R3, #+4]
   \       0x76   0xFBA4 0x0100      UMULL    R0,R1,R4,R0
   \       0x7A   0x4470             ADD      R0,LR,R0
   \       0x7C   0x4570             CMP      R0,LR
   \       0x7E   0x468C             MOV      R12,R1
   \       0x80   0xBF38             IT       CC
   \       0x82   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0x86   0x6851             LDR      R1,[R2, #+4]
   \       0x88   0x1808             ADDS     R0,R1,R0
   \       0x8A   0x4288             CMP      R0,R1
   \       0x8C   0xBF38             IT       CC
   \       0x8E   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0x92   0x6050             STR      R0,[R2, #+4]
   \       0x94   0x6898             LDR      R0,[R3, #+8]
   \       0x96   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x9A   0x468E             MOV      LR,R1
   \       0x9C   0xBF38             IT       CC
   \       0x9E   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \       0xA2   0x6891             LDR      R1,[R2, #+8]
   \       0xA4   0x1808             ADDS     R0,R1,R0
   \       0xA6   0x4288             CMP      R0,R1
   \       0xA8   0xBF38             IT       CC
   \       0xAA   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \       0xAE   0x6090             STR      R0,[R2, #+8]
   \       0xB0   0x68D8             LDR      R0,[R3, #+12]
   \       0xB2   0xFBA4 0x0100      UMULL    R0,R1,R4,R0
   \       0xB6   0x4470             ADD      R0,LR,R0
   \       0xB8   0x4570             CMP      R0,LR
   \       0xBA   0x468C             MOV      R12,R1
   \       0xBC   0xBF38             IT       CC
   \       0xBE   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0xC2   0x68D1             LDR      R1,[R2, #+12]
   \       0xC4   0x1808             ADDS     R0,R1,R0
   \       0xC6   0x4288             CMP      R0,R1
   \       0xC8   0xBF38             IT       CC
   \       0xCA   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0xCE   0x60D0             STR      R0,[R2, #+12]
   \       0xD0   0x6918             LDR      R0,[R3, #+16]
   \       0xD2   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xD6   0x468E             MOV      LR,R1
   \       0xD8   0xBF38             IT       CC
   \       0xDA   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \       0xDE   0x6911             LDR      R1,[R2, #+16]
   \       0xE0   0x1808             ADDS     R0,R1,R0
   \       0xE2   0x4288             CMP      R0,R1
   \       0xE4   0xBF38             IT       CC
   \       0xE6   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \       0xEA   0x6110             STR      R0,[R2, #+16]
   \       0xEC   0x6958             LDR      R0,[R3, #+20]
   \       0xEE   0xFBA4 0x0100      UMULL    R0,R1,R4,R0
   \       0xF2   0x4470             ADD      R0,LR,R0
   \       0xF4   0x4570             CMP      R0,LR
   \       0xF6   0x468C             MOV      R12,R1
   \       0xF8   0xBF38             IT       CC
   \       0xFA   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \       0xFE   0x6951             LDR      R1,[R2, #+20]
   \      0x100   0x1808             ADDS     R0,R1,R0
   \      0x102   0x4288             CMP      R0,R1
   \      0x104   0xBF38             IT       CC
   \      0x106   0xF10C 0x0C01      ADDCC    R12,R12,#+1
   \      0x10A   0x6150             STR      R0,[R2, #+20]
   \      0x10C   0x6998             LDR      R0,[R3, #+24]
   \      0x10E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x112   0x468E             MOV      LR,R1
   \      0x114   0xBF38             IT       CC
   \      0x116   0xF10E 0x0E01      ADDCC    LR,LR,#+1
   \      0x11A   0x6991             LDR      R1,[R2, #+24]
   \      0x11C   0x1808             ADDS     R0,R1,R0
   \      0x11E   0x4288             CMP      R0,R1
   \      0x120   0xD201             BCS.N    ??mbedtls_mpi_core_mla_3
   \      0x122   0xF10E 0x0E01      ADD      LR,LR,#+1
   \                     ??mbedtls_mpi_core_mla_3: (+1)
   \      0x126   0xE77D             B.N      ??mbedtls_mpi_core_mla_1
    493                      MULADDC_X8_STOP
    494              }
    495          
    496              while (steps_x1--) {
   \                     ??mbedtls_mpi_core_mla_2: (+1)
   \      0x128   0x4630             MOV      R0,R6
   \      0x12A   0x1E46             SUBS     R6,R0,#+1
   \      0x12C   0xB1C0             CBZ.N    R0,??mbedtls_mpi_core_mla_4
    497                  MULADDC_X1_INIT
    498                  MULADDC_X1_CORE
   \      0x12E   0xF853 0x0B04      LDR      R0,[R3], #+4
   \      0x132   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x136   0xBF38             IT       CC
   \      0x138   0x1C49             ADDCC    R1,R1,#+1
   \      0x13A   0x6815             LDR      R5,[R2, #+0]
   \      0x13C   0x1828             ADDS     R0,R5,R0
   \      0x13E   0x42A8             CMP      R0,R5
   \      0x140   0xBF2C             ITE      CS
   \      0x142   0x468C             MOVCS    R12,R1
   \      0x144   0xF101 0x0C01      ADDCC    R12,R1,#+1
   \      0x148   0xF842 0x0B04      STR      R0,[R2], #+4
   \      0x14C   0xE7EC             B.N      ??mbedtls_mpi_core_mla_2
    499                      MULADDC_X1_STOP
    500              }
    501          
    502              while (excess_len--) {
    503                  *d += c;
   \                     ??mbedtls_mpi_core_mla_5: (+1)
   \      0x14E   0x6810             LDR      R0,[R2, #+0]
   \      0x150   0x4460             ADD      R0,R12,R0
    504                  c = (*d < c);
   \      0x152   0x4560             CMP      R0,R12
   \      0x154   0xEB6C 0x0C0C      SBC      R12,R12,R12
   \      0x158   0xEA4F 0x7CDC      LSR      R12,R12,#+31
   \      0x15C   0xF842 0x0B04      STR      R0,[R2], #+4
    505                  d++;
    506              }
   \                     ??mbedtls_mpi_core_mla_4: (+1)
   \      0x160   0x4638             MOV      R0,R7
   \      0x162   0x1E47             SUBS     R7,R0,#+1
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD1F2             BNE.N    ??mbedtls_mpi_core_mla_5
   \      0x168   0x4660             MOV      R0,R12
    507          
    508              return c;
   \      0x16A   0xBDF0             POP      {R4-R7,PC}
    509          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xFBA4 0x0100      UMULL    R0,R1,R4,R0
   \        0x4   0x4460             ADD      R0,R12,R0
   \        0x6   0x4560             CMP      R0,R12
   \        0x8   0x4770             BX       LR
    510          

   \                                 In section .text, align 2, keep-with-next
    511          void mbedtls_mpi_core_mul(mbedtls_mpi_uint *X,
    512                                    const mbedtls_mpi_uint *A, size_t A_limbs,
    513                                    const mbedtls_mpi_uint *B, size_t B_limbs)
    514          {
   \                     mbedtls_mpi_core_mul: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x9D08             LDR      R5,[SP, #+32]
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
    515              memset(X, 0, (A_limbs + B_limbs) * ciL);
   \        0xA   0x19A9             ADDS     R1,R5,R6
   \        0xC   0x4604             MOV      R4,R0
   \        0xE   0x4699             MOV      R9,R3
   \       0x10   0x0089             LSLS     R1,R1,#+2
   \       0x12   0x.... 0x....      BL       __aeabi_memclr4
    516          
    517              for (size_t i = 0; i < B_limbs; i++) {
   \       0x16   0x2700             MOVS     R7,#+0
   \       0x18   0xE00A             B.N      ??mbedtls_mpi_core_mul_0
    518                  (void) mbedtls_mpi_core_mla(X + i, A_limbs + 1, A, A_limbs, B[i]);
   \                     ??mbedtls_mpi_core_mul_1: (+1)
   \       0x1A   0xF859 0x0027      LDR      R0,[R9, R7, LSL #+2]
   \       0x1E   0x4633             MOV      R3,R6
   \       0x20   0x4642             MOV      R2,R8
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0x1C71             ADDS     R1,R6,#+1
   \       0x26   0xEB04 0x0087      ADD      R0,R4,R7, LSL #+2
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_core_mla
    519              }
   \       0x2E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_mpi_core_mul_0: (+1)
   \       0x30   0x42AF             CMP      R7,R5
   \       0x32   0xD3F2             BCC.N    ??mbedtls_mpi_core_mul_1
    520          }
   \       0x34   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
    521          
    522          /*
    523           * Fast Montgomery initialization (thanks to Tom St Denis).
    524           */

   \                                 In section .text, align 2, keep-with-next
    525          mbedtls_mpi_uint mbedtls_mpi_core_montmul_init(const mbedtls_mpi_uint *N)
    526          {
    527              mbedtls_mpi_uint x = N[0];
    528          
    529              x += ((N[0] + 2) & 4) << 1;
   \                     mbedtls_mpi_core_montmul_init: (+1)
   \        0x0   0x6803             LDR      R3,[R0, #+0]
    530          
    531              for (unsigned int i = biL; i >= 8; i /= 2) {
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x1C98             ADDS     R0,R3,#+2
   \        0x6   0x0040             LSLS     R0,R0,#+1
   \        0x8   0xF000 0x0008      AND      R0,R0,#0x8
   \        0xC   0x18C0             ADDS     R0,R0,R3
    532                  x *= (2 - (N[0] * x));
   \                     ??mbedtls_mpi_core_montmul_init_0: (+1)
   \        0xE   0xFB00 0xF203      MUL      R2,R0,R3
    533              }
   \       0x12   0x0849             LSRS     R1,R1,#+1
   \       0x14   0xF1C2 0x0202      RSB      R2,R2,#+2
   \       0x18   0x4350             MULS     R0,R2,R0
   \       0x1A   0x2908             CMP      R1,#+8
   \       0x1C   0xD2F7             BCS.N    ??mbedtls_mpi_core_montmul_init_0
    534          
    535              return ~x + 1;
   \       0x1E   0x43C0             MVNS     R0,R0
   \       0x20   0x1C40             ADDS     R0,R0,#+1
   \       0x22   0x4770             BX       LR
    536          }
    537          

   \                                 In section .text, align 2, keep-with-next
    538          void mbedtls_mpi_core_montmul(mbedtls_mpi_uint *X,
    539                                        const mbedtls_mpi_uint *A,
    540                                        const mbedtls_mpi_uint *B,
    541                                        size_t B_limbs,
    542                                        const mbedtls_mpi_uint *N,
    543                                        size_t AN_limbs,
    544                                        mbedtls_mpi_uint mm,
    545                                        mbedtls_mpi_uint *T)
    546          {
   \                     mbedtls_mpi_core_montmul: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0x468A             MOV      R10,R1
   \        0x6   0xB082             SUB      SP,SP,#+8
   \        0x8   0x9D0D             LDR      R5,[SP, #+52]
   \        0xA   0x9E0F             LDR      R6,[SP, #+60]
   \        0xC   0x4617             MOV      R7,R2
    547              memset(T, 0, (2 * AN_limbs + 1) * ciL);
   \        0xE   0x0069             LSLS     R1,R5,#+1
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x4698             MOV      R8,R3
   \       0x14   0x9C0C             LDR      R4,[SP, #+48]
   \       0x16   0xF8DD 0x9038      LDR      R9,[SP, #+56]
   \       0x1A   0x0089             LSLS     R1,R1,#+2
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x.... 0x....      BL       __aeabi_memclr4
    548          
    549              for (size_t i = 0; i < AN_limbs; i++) {
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0x28   0x4682             MOV      R10,R0
   \       0x2A   0xE01B             B.N      ??mbedtls_mpi_core_montmul_0
    550                  /* T = (T + u0*B + u1*N) / 2^biL */
    551                  mbedtls_mpi_uint u0 = A[i];
   \                     ??mbedtls_mpi_core_montmul_1: (+1)
   \       0x2C   0x9801             LDR      R0,[SP, #+4]
    552                  mbedtls_mpi_uint u1 = (T[0] + u0 * B[0]) * mm;
   \       0x2E   0xF8D6 0xB000      LDR      R11,[R6, #+0]
    553          
    554                  (void) mbedtls_mpi_core_mla(T, AN_limbs + 2, B, B_limbs, u0);
   \       0x32   0x4643             MOV      R3,R8
   \       0x34   0xF850 0x102A      LDR      R1,[R0, R10, LSL #+2]
   \       0x38   0x6838             LDR      R0,[R7, #+0]
   \       0x3A   0x463A             MOV      R2,R7
   \       0x3C   0x9100             STR      R1,[SP, #+0]
   \       0x3E   0xFB00 0xBB01      MLA      R11,R0,R1,R11
   \       0x42   0x1CA9             ADDS     R1,R5,#+2
   \       0x44   0x4630             MOV      R0,R6
   \       0x46   0xFB09 0xFB0B      MUL      R11,R9,R11
   \       0x4A   0x.... 0x....      BL       mbedtls_mpi_core_mla
    555                  (void) mbedtls_mpi_core_mla(T, AN_limbs + 2, N, AN_limbs, u1);
   \       0x4E   0x462B             MOV      R3,R5
   \       0x50   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \       0x54   0x4622             MOV      R2,R4
   \       0x56   0x1CA9             ADDS     R1,R5,#+2
   \       0x58   0x4630             MOV      R0,R6
   \       0x5A   0x.... 0x....      BL       mbedtls_mpi_core_mla
    556          
    557                  T++;
   \       0x5E   0x1D36             ADDS     R6,R6,#+4
    558              }
   \       0x60   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??mbedtls_mpi_core_montmul_0: (+1)
   \       0x64   0x45AA             CMP      R10,R5
   \       0x66   0xD3E1             BCC.N    ??mbedtls_mpi_core_montmul_1
   \       0x68   0x4622             MOV      R2,R4
   \       0x6A   0x9C02             LDR      R4,[SP, #+8]
    559          
    560              /*
    561               * The result we want is (T >= N) ? T - N : T.
    562               *
    563               * For better constant-time properties in this function, we always do the
    564               * subtraction, with the result in X.
    565               *
    566               * We also look to see if there was any carry in the final additions in the
    567               * loop above.
    568               */
    569          
    570              mbedtls_mpi_uint carry  = T[AN_limbs];
   \       0x6C   0xF856 0x7025      LDR      R7,[R6, R5, LSL #+2]
    571              mbedtls_mpi_uint borrow = mbedtls_mpi_core_sub(X, T, N, AN_limbs);
   \       0x70   0x462B             MOV      R3,R5
   \       0x72   0x4631             MOV      R1,R6
   \       0x74   0x4620             MOV      R0,R4
   \       0x76   0x.... 0x....      BL       mbedtls_mpi_core_sub
    572          
    573              /*
    574               * Using R as the Montgomery radix (auxiliary modulus) i.e. 2^(biL*AN_limbs):
    575               *
    576               * T can be in one of 3 ranges:
    577               *
    578               * 1) T < N      : (carry, borrow) = (0, 1): we want T
    579               * 2) N <= T < R : (carry, borrow) = (0, 0): we want X
    580               * 3) T >= R     : (carry, borrow) = (1, 1): we want X
    581               *
    582               * and (carry, borrow) = (1, 0) can't happen.
    583               *
    584               * So the correct return value is already in X if (carry ^ borrow) = 0,
    585               * but is in (the lower AN_limbs limbs of) T if (carry ^ borrow) = 1.
    586               */
    587              mbedtls_ct_memcpy_if(mbedtls_ct_bool(carry ^ borrow),
    588                                   (unsigned char *) X,
    589                                   (unsigned char *) T,
    590                                   NULL,
    591                                   AN_limbs * sizeof(mbedtls_mpi_uint));
   \       0x7A   0x4078             EORS     R0,R0,R7
   \       0x7C   0x.... 0x....      BL       mbedtls_ct_bool
   \       0x80   0x00AD             LSLS     R5,R5,#+2
   \       0x82   0x9500             STR      R5,[SP, #+0]
   \       0x84   0x2300             MOVS     R3,#+0
   \       0x86   0x4632             MOV      R2,R6
   \       0x88   0x4621             MOV      R1,R4
   \       0x8A   0x.... 0x....      BL       mbedtls_ct_memcpy_if
    592          }
   \       0x8E   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
    593          

   \                                 In section .text, align 2, keep-with-next
    594          int mbedtls_mpi_core_get_mont_r2_unsafe(mbedtls_mpi *X,
    595                                                  const mbedtls_mpi *N)
    596          {
   \                     mbedtls_mpi_core_get_mont_r2_unsafe: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4605             MOV      R5,R0
    597              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    598          
    599              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, 1));
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_lset
   \        0xC   0xB988             CBNZ.N   R0,??mbedtls_mpi_core_get_mont_r2_unsafe_0
    600              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(X, N->n * 2 * biL));
   \        0xE   0x88E1             LDRH     R1,[R4, #+6]
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x0189             LSLS     R1,R1,#+6
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \       0x18   0xB958             CBNZ.N   R0,??mbedtls_mpi_core_get_mont_r2_unsafe_0
    601              MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(X, X, N));
   \       0x1A   0x4622             MOV      R2,R4
   \       0x1C   0x4629             MOV      R1,R5
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \       0x24   0xB928             CBNZ.N   R0,??mbedtls_mpi_core_get_mont_r2_unsafe_0
    602              MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(X, N->n));
   \       0x26   0x88E1             LDRH     R1,[R4, #+6]
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x2E   0x.... 0x....      B.W      mbedtls_mpi_shrink
    603          
    604          cleanup:
    605              return ret;
   \                     ??mbedtls_mpi_core_get_mont_r2_unsafe_0: (+1)
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}
    606          }
    607          
    608          MBEDTLS_STATIC_TESTABLE
    609          void mbedtls_mpi_core_ct_uint_table_lookup(mbedtls_mpi_uint *dest,
    610                                                     const mbedtls_mpi_uint *table,
    611                                                     size_t limbs,
    612                                                     size_t count,
    613                                                     size_t index)
    614          {
    615              for (size_t i = 0; i < count; i++, table += limbs) {
    616                  mbedtls_ct_condition_t assign = mbedtls_ct_uint_eq(i, index);
    617                  mbedtls_mpi_core_cond_assign(dest, table, limbs, assign);
    618              }
    619          }
    620          
    621          /* Fill X with n_bytes random bytes.
    622           * X must already have room for those bytes.
    623           * The ordering of the bytes returned from the RNG is suitable for
    624           * deterministic ECDSA (see RFC 6979 §3.3 and the specification of
    625           * mbedtls_mpi_core_random()).
    626           */

   \                                 In section .text, align 2, keep-with-next
    627          int mbedtls_mpi_core_fill_random(
    628              mbedtls_mpi_uint *X, size_t X_limbs,
    629              size_t n_bytes,
    630              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    631          {
   \                     mbedtls_mpi_core_fill_random: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4690             MOV      R8,R2
   \        0x8   0x4605             MOV      R5,R0
   \        0xA   0x469B             MOV      R11,R3
    632              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    633              const size_t limbs = CHARS_TO_LIMBS(n_bytes);
   \        0xC   0xF018 0x0103      ANDS     R1,R8,#0x3
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2101             MOVNE    R1,#+1
   \       0x14   0xEB01 0x0698      ADD      R6,R1,R8, LSR #+2
    634              const size_t overhead = (limbs * ciL) - n_bytes;
   \       0x18   0x00B4             LSLS     R4,R6,#+2
   \       0x1A   0xEBA4 0x0908      SUB      R9,R4,R8
    635          
    636              if (X_limbs < limbs) {
   \       0x1E   0x42B7             CMP      R7,R6
   \       0x20   0xBF38             IT       CC
   \       0x22   0xF06F 0x0003      MVNCC    R0,#+3
    637                  return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
   \       0x26   0xD315             BCC.N    ??mbedtls_mpi_core_fill_random_0
   \       0x28   0xF8DD 0xA028      LDR      R10,[SP, #+40]
    638              }
    639          
    640              memset(X, 0, overhead);
   \       0x2C   0x4649             MOV      R1,R9
   \       0x2E   0x.... 0x....      BL       __aeabi_memclr4
    641              memset((unsigned char *) X + limbs * ciL, 0, (X_limbs - limbs) * ciL);
   \       0x32   0x1BBF             SUBS     R7,R7,R6
   \       0x34   0x00B9             LSLS     R1,R7,#+2
   \       0x36   0x1928             ADDS     R0,R5,R4
   \       0x38   0x.... 0x....      BL       __aeabi_memclr
    642              MBEDTLS_MPI_CHK(f_rng(p_rng, (unsigned char *) X + overhead, n_bytes));
   \       0x3C   0x4642             MOV      R2,R8
   \       0x3E   0xEB05 0x0109      ADD      R1,R5,R9
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x47D8             BLX      R11
   \       0x46   0x0004             MOVS     R4,R0
   \       0x48   0xD103             BNE.N    ??mbedtls_mpi_core_fill_random_1
    643              mbedtls_mpi_core_bigendian_to_host(X, limbs);
   \       0x4A   0x4631             MOV      R1,R6
   \       0x4C   0x4628             MOV      R0,R5
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_core_bigendian_to_host
    644          
    645          cleanup:
    646              return ret;
   \                     ??mbedtls_mpi_core_fill_random_1: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \                     ??mbedtls_mpi_core_fill_random_0: (+1)
   \       0x54   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    647          }
    648          

   \                                 In section .text, align 2, keep-with-next
    649          int mbedtls_mpi_core_random(mbedtls_mpi_uint *X,
    650                                      mbedtls_mpi_uint min,
    651                                      const mbedtls_mpi_uint *N,
    652                                      size_t limbs,
    653                                      int (*f_rng)(void *, unsigned char *, size_t),
    654                                      void *p_rng)
    655          {
   \                     mbedtls_mpi_core_random: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4615             MOV      R5,R2
    656              mbedtls_ct_condition_t ge_lower = MBEDTLS_CT_TRUE, lt_upper = MBEDTLS_CT_FALSE;
   \        0x6   0x....             LDR.N    R6,??DataTable7
   \        0x8   0x4680             MOV      R8,R0
   \        0xA   0x6832             LDR      R2,[R6, #+0]
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0x4689             MOV      R9,R1
   \       0x10   0x469A             MOV      R10,R3
    657              size_t n_bits = mbedtls_mpi_core_bitlen(N, limbs);
   \       0x12   0x4651             MOV      R1,R10
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_core_bitlen
    658              size_t n_bytes = (n_bits + 7) / 8;
   \       0x1A   0x1DC7             ADDS     R7,R0,#+7
   \       0x1C   0x08FF             LSRS     R7,R7,#+3
    659              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    660          
    661              /*
    662               * When min == 0, each try has at worst a probability 1/2 of failing
    663               * (the msb has a probability 1/2 of being 0, and then the result will
    664               * be < N), so after 30 tries failure probability is a most 2**(-30).
    665               *
    666               * When N is just below a power of 2, as is the case when generating
    667               * a random scalar on most elliptic curves, 1 try is enough with
    668               * overwhelming probability. When N is just above a power of 2,
    669               * as when generating a random scalar on secp224k1, each try has
    670               * a probability of failing that is almost 1/2.
    671               *
    672               * The probabilities are almost the same if min is nonzero but negligible
    673               * compared to N. This is always the case when N is crypto-sized, but
    674               * it's convenient to support small N for testing purposes. When N
    675               * is small, use a higher repeat count, otherwise the probability of
    676               * failure is macroscopic.
    677               */
    678              int count = (n_bytes > 4 ? 30 : 250);
   \       0x1E   0x2F05             CMP      R7,#+5
   \       0x20   0xBF34             ITE      CC
   \       0x22   0x24FA             MOVCC    R4,#+250
   \       0x24   0x241E             MOVCS    R4,#+30
   \       0x26   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \       0x2A   0x9501             STR      R5,[SP, #+4]
   \       0x2C   0x4681             MOV      R9,R0
   \       0x2E   0xE00F             B.N      ??mbedtls_mpi_core_random_0
    679          
    680              /*
    681               * Match the procedure given in RFC 6979 §3.3 (deterministic ECDSA)
    682               * when f_rng is a suitably parametrized instance of HMAC_DRBG:
    683               * - use the same byte ordering;
    684               * - keep the leftmost n_bits bits of the generated octet string;
    685               * - try until result is in the desired range.
    686               * This also avoids any bias, which is especially important for ECDSA.
    687               */
    688              do {
    689                  MBEDTLS_MPI_CHK(mbedtls_mpi_core_fill_random(X, limbs,
    690                                                               n_bytes,
    691                                                               f_rng, p_rng));
    692                  mbedtls_mpi_core_shift_r(X, limbs, 8 * n_bytes - n_bits);
    693          
    694                  if (--count == 0) {
    695                      ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
    696                      goto cleanup;
    697                  }
    698          
    699                  ge_lower = mbedtls_mpi_core_uint_le_mpi(min, X, limbs);
   \                     ??mbedtls_mpi_core_random_1: (+1)
   \       0x30   0x9802             LDR      R0,[SP, #+8]
   \       0x32   0x4652             MOV      R2,R10
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_core_uint_le_mpi
    700                  lt_upper = mbedtls_mpi_core_lt_ct(X, N, limbs);
   \       0x3A   0x9901             LDR      R1,[SP, #+4]
   \       0x3C   0x4683             MOV      R11,R0
   \       0x3E   0x4652             MOV      R2,R10
   \       0x40   0x4640             MOV      R0,R8
   \       0x42   0x.... 0x....      BL       mbedtls_mpi_core_lt_ct
    701              } while (mbedtls_ct_bool_and(ge_lower, lt_upper) == MBEDTLS_CT_FALSE);
   \       0x46   0xEA00 0x010B      AND      R1,R0,R11
   \       0x4A   0x6830             LDR      R0,[R6, #+0]
   \       0x4C   0x4281             CMP      R1,R0
   \       0x4E   0xD113             BNE.N    ??mbedtls_mpi_core_random_2
   \                     ??mbedtls_mpi_core_random_0: (+1)
   \       0x50   0x990D             LDR      R1,[SP, #+52]
   \       0x52   0x9B0C             LDR      R3,[SP, #+48]
   \       0x54   0x463A             MOV      R2,R7
   \       0x56   0x9100             STR      R1,[SP, #+0]
   \       0x58   0x4651             MOV      R1,R10
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0x.... 0x....      BL       mbedtls_mpi_core_fill_random
   \       0x60   0x0005             MOVS     R5,R0
   \       0x62   0xD109             BNE.N    ??mbedtls_mpi_core_random_2
   \       0x64   0xEBC9 0x02C7      RSB      R2,R9,R7, LSL #+3
   \       0x68   0x4651             MOV      R1,R10
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x.... 0x....      BL       mbedtls_mpi_core_shift_r
   \       0x70   0x1E64             SUBS     R4,R4,#+1
   \       0x72   0xD1DD             BNE.N    ??mbedtls_mpi_core_random_1
   \       0x74   0xF06F 0x050D      MVN      R5,#+13
    702          
    703          cleanup:
    704              return ret;
   \                     ??mbedtls_mpi_core_random_2: (+1)
   \       0x78   0x4628             MOV      R0,R5
   \       0x7A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    705          }
    706          
    707          static size_t exp_mod_get_window_size(size_t Ebits)
    708          {
    709          #if MBEDTLS_MPI_WINDOW_SIZE >= 6
    710              return (Ebits > 671) ? 6 : (Ebits > 239) ? 5 : (Ebits >  79) ? 4 : 1;
    711          #elif MBEDTLS_MPI_WINDOW_SIZE == 5
    712              return (Ebits > 239) ? 5 : (Ebits >  79) ? 4 : 1;
    713          #elif MBEDTLS_MPI_WINDOW_SIZE > 1
    714              return (Ebits >  79) ? MBEDTLS_MPI_WINDOW_SIZE : 1;
    715          #else
    716              (void) Ebits;
    717              return 1;
    718          #endif
    719          }
    720          

   \                                 In section .text, align 2, keep-with-next
    721          size_t mbedtls_mpi_core_exp_mod_working_limbs(size_t AN_limbs, size_t E_limbs)
    722          {
    723              const size_t wsize = exp_mod_get_window_size(E_limbs * biL);
   \                     mbedtls_mpi_core_exp_mod_working_limbs: (+1)
   \        0x0   0x0149             LSLS     R1,R1,#+5
   \        0x2   0x4602             MOV      R2,R0
   \        0x4   0x2950             CMP      R1,#+80
   \        0x6   0xBF2C             ITE      CS
   \        0x8   0x2004             MOVCS    R0,#+4
   \        0xA   0x2002             MOVCC    R0,#+2
    724              const size_t welem = ((size_t) 1) << wsize;
    725          
    726              /* How big does each part of the working memory pool need to be? */
    727              const size_t table_limbs   = welem * AN_limbs;
    728              const size_t select_limbs  = AN_limbs;
    729              const size_t temp_limbs    = 2 * AN_limbs + 1;
    730          
    731              return table_limbs + select_limbs + temp_limbs;
   \        0xC   0xFB02 0x2000      MLA      R0,R2,R0,R2
   \       0x10   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x4770             BX       LR
    732          }
    733          
    734          static void exp_mod_precompute_window(const mbedtls_mpi_uint *A,
    735                                                const mbedtls_mpi_uint *N,
    736                                                size_t AN_limbs,
    737                                                mbedtls_mpi_uint mm,
    738                                                const mbedtls_mpi_uint *RR,
    739                                                size_t welem,
    740                                                mbedtls_mpi_uint *Wtable,
    741                                                mbedtls_mpi_uint *temp)
    742          {
    743              /* W[0] = 1 (in Montgomery presentation) */
    744              memset(Wtable, 0, AN_limbs * ciL);
    745              Wtable[0] = 1;
    746              mbedtls_mpi_core_montmul(Wtable, Wtable, RR, AN_limbs, N, AN_limbs, mm, temp);
    747          
    748              /* W[1] = A (already in Montgomery presentation) */
    749              mbedtls_mpi_uint *W1 = Wtable + AN_limbs;
    750              memcpy(W1, A, AN_limbs * ciL);
    751          
    752              /* W[i+1] = W[i] * W[1], i >= 2 */
    753              mbedtls_mpi_uint *Wprev = W1;
    754              for (size_t i = 2; i < welem; i++) {
    755                  mbedtls_mpi_uint *Wcur = Wprev + AN_limbs;
    756                  mbedtls_mpi_core_montmul(Wcur, Wprev, W1, AN_limbs, N, AN_limbs, mm, temp);
    757                  Wprev = Wcur;
    758              }
    759          }
    760          
    761          /* Exponentiation: X := A^E mod N.
    762           *
    763           * A must already be in Montgomery form.
    764           *
    765           * As in other bignum functions, assume that AN_limbs and E_limbs are nonzero.
    766           *
    767           * RR must contain 2^{2*biL} mod N.
    768           *
    769           * The algorithm is a variant of Left-to-right k-ary exponentiation: HAC 14.82
    770           * (The difference is that the body in our loop processes a single bit instead
    771           * of a full window.)
    772           */

   \                                 In section .text, align 2, keep-with-next
    773          void mbedtls_mpi_core_exp_mod(mbedtls_mpi_uint *X,
    774                                        const mbedtls_mpi_uint *A,
    775                                        const mbedtls_mpi_uint *N,
    776                                        size_t AN_limbs,
    777                                        const mbedtls_mpi_uint *E,
    778                                        size_t E_limbs,
    779                                        const mbedtls_mpi_uint *RR,
    780                                        mbedtls_mpi_uint *T)
    781          {
   \                     mbedtls_mpi_core_exp_mod: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0xF8DD 0xB04C      LDR      R11,[SP, #+76]
   \        0xA   0x460F             MOV      R7,R1
   \        0xC   0x461D             MOV      R5,R3
    782              const size_t wsize = exp_mod_get_window_size(E_limbs * biL);
   \        0xE   0xEA4F 0x104B      LSL      R0,R11,#+5
   \       0x12   0x2850             CMP      R0,#+80
   \       0x14   0xBF27             ITTEE    CS
   \       0x16   0x2302             MOVCS    R3,#+2
   \       0x18   0x9306             STRCS    R3,[SP, #+24]
   \       0x1A   0x2101             MOVCC    R1,#+1
   \       0x1C   0x9106             STRCC    R1,[SP, #+24]
    783              const size_t welem = ((size_t) 1) << wsize;
   \       0x1E   0x9806             LDR      R0,[SP, #+24]
   \       0x20   0x9E14             LDR      R6,[SP, #+80]
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x9204             STR      R2,[SP, #+16]
   \       0x26   0xFA01 0xF800      LSL      R8,R1,R0
    784          
    785              /* This is how we will use the temporary storage T, which must have space
    786               * for table_limbs, select_limbs and (2 * AN_limbs + 1) for montmul. */
    787              const size_t table_limbs  = welem * AN_limbs;
    788              const size_t select_limbs = AN_limbs;
    789          
    790              /* Pointers to specific parts of the temporary working memory pool */
    791              mbedtls_mpi_uint *const Wtable  = T;
    792              mbedtls_mpi_uint *const Wselect = Wtable  +  table_limbs;
   \       0x2A   0x9B15             LDR      R3,[SP, #+84]
   \       0x2C   0xFB05 0xF208      MUL      R2,R5,R8
    793              mbedtls_mpi_uint *const temp    = Wselect + select_limbs;
    794          
    795              /*
    796               * Window precomputation
    797               */
    798          
    799              const mbedtls_mpi_uint mm = mbedtls_mpi_core_montmul_init(N);
   \       0x30   0x9804             LDR      R0,[SP, #+16]
   \       0x32   0xEB03 0x0182      ADD      R1,R3,R2, LSL #+2
   \       0x36   0x9107             STR      R1,[SP, #+28]
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_core_montmul_init
   \       0x3C   0x4604             MOV      R4,R0
    800          
    801              /* Set Wtable[i] = A^(2^i) (in Montgomery representation) */
    802              exp_mod_precompute_window(A, N, AN_limbs,
    803                                        mm, RR,
    804                                        welem, Wtable, temp);
   \       0x3E   0x9815             LDR      R0,[SP, #+84]
   \       0x40   0x00A9             LSLS     R1,R5,#+2
   \       0x42   0x.... 0x....      BL       __aeabi_memclr4
   \       0x46   0x9815             LDR      R0,[SP, #+84]
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0x462B             MOV      R3,R5
   \       0x4C   0x6001             STR      R1,[R0, #+0]
   \       0x4E   0x9907             LDR      R1,[SP, #+28]
   \       0x50   0x9804             LDR      R0,[SP, #+16]
   \       0x52   0x9402             STR      R4,[SP, #+8]
   \       0x54   0xEB01 0x0285      ADD      R2,R1,R5, LSL #+2
   \       0x58   0x9915             LDR      R1,[SP, #+84]
   \       0x5A   0x9203             STR      R2,[SP, #+12]
   \       0x5C   0x9000             STR      R0,[SP, #+0]
   \       0x5E   0x9501             STR      R5,[SP, #+4]
   \       0x60   0x4632             MOV      R2,R6
   \       0x62   0x4608             MOV      R0,R1
   \       0x64   0x.... 0x....      BL       mbedtls_mpi_core_montmul
   \       0x68   0x9915             LDR      R1,[SP, #+84]
   \       0x6A   0x00AA             LSLS     R2,R5,#+2
   \       0x6C   0x2602             MOVS     R6,#+2
   \       0x6E   0xEB01 0x0085      ADD      R0,R1,R5, LSL #+2
   \       0x72   0x9005             STR      R0,[SP, #+20]
   \       0x74   0x4639             MOV      R1,R7
   \       0x76   0x.... 0x....      BL       __aeabi_memcpy
   \       0x7A   0x9905             LDR      R1,[SP, #+20]
   \       0x7C   0x9F04             LDR      R7,[SP, #+16]
   \       0x7E   0xF8DD 0xA01C      LDR      R10,[SP, #+28]
   \       0x82   0xE00E             B.N      ??mbedtls_mpi_core_exp_mod_0
   \                     ??mbedtls_mpi_core_exp_mod_1: (+1)
   \       0x84   0xEB0A 0x0085      ADD      R0,R10,R5, LSL #+2
   \       0x88   0x9003             STR      R0,[SP, #+12]
   \       0x8A   0x9402             STR      R4,[SP, #+8]
   \       0x8C   0x9501             STR      R5,[SP, #+4]
   \       0x8E   0x9700             STR      R7,[SP, #+0]
   \       0x90   0x9A05             LDR      R2,[SP, #+20]
   \       0x92   0xEB01 0x0985      ADD      R9,R1,R5, LSL #+2
   \       0x96   0x462B             MOV      R3,R5
   \       0x98   0x4648             MOV      R0,R9
   \       0x9A   0x.... 0x....      BL       mbedtls_mpi_core_montmul
   \       0x9E   0x4649             MOV      R1,R9
   \       0xA0   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_mpi_core_exp_mod_0: (+1)
   \       0xA2   0x4546             CMP      R6,R8
   \       0xA4   0xD3EE             BCC.N    ??mbedtls_mpi_core_exp_mod_1
   \       0xA6   0x9704             STR      R7,[SP, #+16]
    805          
    806              /*
    807               * Fixed window exponentiation
    808               */
    809          
    810              /* X = 1 (in Montgomery presentation) initially */
    811              memcpy(X, Wtable, AN_limbs * ciL);
   \       0xA8   0x9915             LDR      R1,[SP, #+84]
   \       0xAA   0x9808             LDR      R0,[SP, #+32]
   \       0xAC   0x9407             STR      R4,[SP, #+28]
   \       0xAE   0x00AA             LSLS     R2,R5,#+2
   \       0xB0   0x.... 0x....      BL       __aeabi_memcpy4
    812          
    813              /* We'll process the bits of E from most significant
    814               * (limb_index=E_limbs-1, E_bit_index=biL-1) to least significant
    815               * (limb_index=0, E_bit_index=0). */
    816              size_t E_limb_index = E_limbs;
    817              size_t E_bit_index = 0;
   \       0xB4   0x2400             MOVS     R4,#+0
    818              /* At any given time, window contains window_bits bits from E.
    819               * window_bits can go up to wsize. */
    820              size_t window_bits = 0;
    821              mbedtls_mpi_uint window = 0;
   \       0xB6   0xEB0A 0x0085      ADD      R0,R10,R5, LSL #+2
   \       0xBA   0x46A1             MOV      R9,R4
   \       0xBC   0x2600             MOVS     R6,#+0
   \       0xBE   0x9005             STR      R0,[SP, #+20]
    822          
    823              do {
    824                  /* Square */
    825                  mbedtls_mpi_core_montmul(X, X, X, AN_limbs, N, AN_limbs, mm, temp);
   \                     ??mbedtls_mpi_core_exp_mod_2: (+1)
   \       0xC0   0x9805             LDR      R0,[SP, #+20]
   \       0xC2   0x9907             LDR      R1,[SP, #+28]
   \       0xC4   0x9A08             LDR      R2,[SP, #+32]
   \       0xC6   0x9003             STR      R0,[SP, #+12]
   \       0xC8   0x9804             LDR      R0,[SP, #+16]
   \       0xCA   0x9102             STR      R1,[SP, #+8]
   \       0xCC   0x4611             MOV      R1,R2
   \       0xCE   0x9000             STR      R0,[SP, #+0]
   \       0xD0   0x9501             STR      R5,[SP, #+4]
   \       0xD2   0x462B             MOV      R3,R5
   \       0xD4   0x4608             MOV      R0,R1
   \       0xD6   0x.... 0x....      BL       mbedtls_mpi_core_montmul
    826          
    827                  /* Move to the next bit of the exponent */
    828                  if (E_bit_index == 0) {
   \       0xDA   0x2C00             CMP      R4,#+0
   \       0xDC   0xBF06             ITTE     EQ
   \       0xDE   0xF1AB 0x0B01      SUBEQ    R11,R11,#+1
   \       0xE2   0x241F             MOVEQ    R4,#+31
   \       0xE4   0x1E64             SUBNE    R4,R4,#+1
    829                      --E_limb_index;
    830                      E_bit_index = biL - 1;
    831                  } else {
    832                      --E_bit_index;
    833                  }
    834                  /* Insert next exponent bit into window */
    835                  ++window_bits;
    836                  window <<= 1;
    837                  window |= (E[E_limb_index] >> E_bit_index) & 1;
   \       0xE6   0x9912             LDR      R1,[SP, #+72]
   \       0xE8   0xF109 0x0901      ADD      R9,R9,#+1
   \       0xEC   0xF851 0x202B      LDR      R2,[R1, R11, LSL #+2]
    838          
    839                  /* Clear window if it's full. Also clear the window at the end,
    840                   * when we've finished processing the exponent. */
    841                  if (window_bits == wsize ||
    842                      (E_bit_index == 0 && E_limb_index == 0)) {
   \       0xF0   0x9906             LDR      R1,[SP, #+24]
   \       0xF2   0x40E2             LSRS     R2,R2,R4
   \       0xF4   0x0850             LSRS     R0,R2,#+1
   \       0xF6   0x4176             ADCS     R6,R6,R6
   \       0xF8   0x4589             CMP      R9,R1
   \       0xFA   0xBF18             IT       NE
   \       0xFC   0xEA5B 0x0004      ORRSNE   R0,R11,R4
   \      0x100   0xD128             BNE.N    ??mbedtls_mpi_core_exp_mod_3
    843                      /* Select Wtable[window] without leaking window through
    844                       * memory access patterns. */
    845                      mbedtls_mpi_core_ct_uint_table_lookup(Wselect, Wtable,
    846                                                            AN_limbs, welem, window);
   \      0x102   0x....             LDR.N    R0,??DataTable7
   \      0x104   0xF8DD 0x9054      LDR      R9,[SP, #+84]
   \      0x108   0x2700             MOVS     R7,#+0
   \      0x10A   0x9000             STR      R0,[SP, #+0]
   \      0x10C   0xE011             B.N      ??mbedtls_mpi_core_exp_mod_4
   \                     ??mbedtls_mpi_core_exp_mod_5: (+1)
   \      0x10E   0x9800             LDR      R0,[SP, #+0]
   \      0x110   0x6800             LDR      R0,[R0, #+0]
   \      0x112   0x9900             LDR      R1,[SP, #+0]
   \      0x114   0x6809             LDR      R1,[R1, #+0]
   \      0x116   0x4078             EORS     R0,R0,R7
   \      0x118   0x4070             EORS     R0,R6,R0
   \      0x11A   0x4048             EORS     R0,R1,R0
   \      0x11C   0x.... 0x....      BL       mbedtls_ct_bool
   \      0x120   0x43C3             MVNS     R3,R0
   \      0x122   0x462A             MOV      R2,R5
   \      0x124   0x4649             MOV      R1,R9
   \      0x126   0x4650             MOV      R0,R10
   \      0x128   0x.... 0x....      BL       mbedtls_mpi_core_cond_assign
   \      0x12C   0x1C7F             ADDS     R7,R7,#+1
   \      0x12E   0xEB09 0x0985      ADD      R9,R9,R5, LSL #+2
   \                     ??mbedtls_mpi_core_exp_mod_4: (+1)
   \      0x132   0x4547             CMP      R7,R8
   \      0x134   0xD3EB             BCC.N    ??mbedtls_mpi_core_exp_mod_5
    847                      /* Multiply X by the selected element. */
    848                      mbedtls_mpi_core_montmul(X, X, Wselect, AN_limbs, N, AN_limbs, mm,
    849                                               temp);
   \      0x136   0x9805             LDR      R0,[SP, #+20]
   \      0x138   0x9907             LDR      R1,[SP, #+28]
   \      0x13A   0x9501             STR      R5,[SP, #+4]
   \      0x13C   0x9003             STR      R0,[SP, #+12]
   \      0x13E   0x9102             STR      R1,[SP, #+8]
   \      0x140   0x9804             LDR      R0,[SP, #+16]
   \      0x142   0x9908             LDR      R1,[SP, #+32]
   \      0x144   0x462B             MOV      R3,R5
   \      0x146   0x9000             STR      R0,[SP, #+0]
   \      0x148   0x4652             MOV      R2,R10
   \      0x14A   0x4608             MOV      R0,R1
   \      0x14C   0x2600             MOVS     R6,#+0
   \      0x14E   0x.... 0x....      BL       mbedtls_mpi_core_montmul
    850                      window = 0;
    851                      window_bits = 0;
   \      0x152   0x46B1             MOV      R9,R6
    852                  }
    853              } while (!(E_bit_index == 0 && E_limb_index == 0));
   \                     ??mbedtls_mpi_core_exp_mod_3: (+1)
   \      0x154   0xEA5B 0x0004      ORRS     R0,R11,R4
   \      0x158   0xD1B2             BNE.N    ??mbedtls_mpi_core_exp_mod_2
    854          }
   \      0x15A   0xB009             ADD      SP,SP,#+36
   \      0x15C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    855          

   \                                 In section .text, align 2, keep-with-next
    856          mbedtls_mpi_uint mbedtls_mpi_core_sub_int(mbedtls_mpi_uint *X,
    857                                                    const mbedtls_mpi_uint *A,
    858                                                    mbedtls_mpi_uint c,  /* doubles as carry */
    859                                                    size_t limbs)
    860          {
   \                     mbedtls_mpi_core_sub_int: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    861              for (size_t i = 0; i < limbs; i++) {
   \        0x2   0x2600             MOVS     R6,#+0
   \        0x4   0xE008             B.N      ??mbedtls_mpi_core_sub_int_0
    862                  mbedtls_mpi_uint s = A[i];
   \                     ??mbedtls_mpi_core_sub_int_1: (+1)
   \        0x6   0xF851 0x5026      LDR      R5,[R1, R6, LSL #+2]
    863                  mbedtls_mpi_uint t = s - c;
   \        0xA   0x1AAA             SUBS     R2,R5,R2
   \        0xC   0x4614             MOV      R4,R2
    864                  c = (t > s);
   \        0xE   0x4192             SBCS     R2,R2,R2
    865                  X[i] = t;
   \       0x10   0xF840 0x4026      STR      R4,[R0, R6, LSL #+2]
   \       0x14   0x0FD2             LSRS     R2,R2,#+31
    866              }
   \       0x16   0x1C76             ADDS     R6,R6,#+1
   \                     ??mbedtls_mpi_core_sub_int_0: (+1)
   \       0x18   0x429E             CMP      R6,R3
   \       0x1A   0xD3F4             BCC.N    ??mbedtls_mpi_core_sub_int_1
    867          
    868              return c;
   \       0x1C   0x4610             MOV      R0,R2
   \       0x1E   0xBD70             POP      {R4-R6,PC}
    869          }
    870          

   \                                 In section .text, align 2, keep-with-next
    871          mbedtls_mpi_uint mbedtls_mpi_core_check_zero_ct(const mbedtls_mpi_uint *A,
    872                                                          size_t limbs)
    873          {
   \                     mbedtls_mpi_core_check_zero_ct: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4602             MOV      R2,R0
    874              mbedtls_mpi_uint bits = 0;
   \        0x4   0x2000             MOVS     R0,#+0
    875          
    876              for (size_t i = 0; i < limbs; i++) {
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0xE003             B.N      ??mbedtls_mpi_core_check_zero_ct_0
    877                  bits |= A[i];
   \                     ??mbedtls_mpi_core_check_zero_ct_1: (+1)
   \        0xA   0xF852 0x3024      LDR      R3,[R2, R4, LSL #+2]
    878              }
   \        0xE   0x1C64             ADDS     R4,R4,#+1
   \       0x10   0x4318             ORRS     R0,R3,R0
   \                     ??mbedtls_mpi_core_check_zero_ct_0: (+1)
   \       0x12   0x428C             CMP      R4,R1
   \       0x14   0xD3F9             BCC.N    ??mbedtls_mpi_core_check_zero_ct_1
    879          
    880              return bits;
   \       0x16   0xBD10             POP      {R4,PC}
    881          }
    882          

   \                                 In section .text, align 2, keep-with-next
    883          void mbedtls_mpi_core_to_mont_rep(mbedtls_mpi_uint *X,
    884                                            const mbedtls_mpi_uint *A,
    885                                            const mbedtls_mpi_uint *N,
    886                                            size_t AN_limbs,
    887                                            mbedtls_mpi_uint mm,
    888                                            const mbedtls_mpi_uint *rr,
    889                                            mbedtls_mpi_uint *T)
    890          {
   \                     mbedtls_mpi_core_to_mont_rep: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x9C09             LDR      R4,[SP, #+36]
    891              mbedtls_mpi_core_montmul(X, A, rr, AN_limbs, N, AN_limbs, mm, T);
   \        0x4   0x9E0A             LDR      R6,[SP, #+40]
   \        0x6   0x9D08             LDR      R5,[SP, #+32]
   \        0x8   0x9200             STR      R2,[SP, #+0]
   \        0xA   0x9603             STR      R6,[SP, #+12]
   \        0xC   0x9502             STR      R5,[SP, #+8]
   \        0xE   0x9301             STR      R3,[SP, #+4]
   \       0x10   0x4622             MOV      R2,R4
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_core_montmul
    892          }
   \       0x16   0xBD7F             POP      {R0-R6,PC}
    893          

   \                                 In section .text, align 2, keep-with-next
    894          void mbedtls_mpi_core_from_mont_rep(mbedtls_mpi_uint *X,
    895                                              const mbedtls_mpi_uint *A,
    896                                              const mbedtls_mpi_uint *N,
    897                                              size_t AN_limbs,
    898                                              mbedtls_mpi_uint mm,
    899                                              mbedtls_mpi_uint *T)
    900          {
   \                     mbedtls_mpi_core_from_mont_rep: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    901              const mbedtls_mpi_uint Rinv = 1;    /* 1/R in Mont. rep => 1 */
   \        0x4   0x2401             MOVS     R4,#+1
   \        0x6   0x9404             STR      R4,[SP, #+16]
    902          
    903              mbedtls_mpi_core_montmul(X, A, &Rinv, 1, N, AN_limbs, mm, T);
   \        0x8   0x9D09             LDR      R5,[SP, #+36]
   \        0xA   0x9C08             LDR      R4,[SP, #+32]
   \        0xC   0x9301             STR      R3,[SP, #+4]
   \        0xE   0x9200             STR      R2,[SP, #+0]
   \       0x10   0x9503             STR      R5,[SP, #+12]
   \       0x12   0x9402             STR      R4,[SP, #+8]
   \       0x14   0x2301             MOVS     R3,#+1
   \       0x16   0xAA04             ADD      R2,SP,#+16
   \       0x18   0x.... 0x....      BL       mbedtls_mpi_core_montmul
    904          }
   \       0x1C   0xB005             ADD      SP,SP,#+20
   \       0x1E   0xBD30             POP      {R4,R5,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     mbedtls_ct_zero
    905          
    906          #endif /* MBEDTLS_BIGNUM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_ct_bool
       0   mbedtls_ct_compiler_opaque
       8   mbedtls_ct_if
       0   mbedtls_ct_mpi_uint_if
         0   -> mbedtls_ct_if
      16   mbedtls_ct_uint_lt
         0   -> mbedtls_ct_bool
        16   -> mbedtls_ct_bool
        16   -> mbedtls_ct_compiler_opaque
        16   -> mbedtls_ct_if
      20   mbedtls_mpi_core_add
      24   mbedtls_mpi_core_add_if
        24   -> mbedtls_ct_bool
      16   mbedtls_mpi_core_bigendian_to_host
        16   -> mpi_bigendian_to_host
       0   mbedtls_mpi_core_bitlen
       8   mbedtls_mpi_core_check_zero_ct
       0   mbedtls_mpi_core_clz
      24   mbedtls_mpi_core_cond_assign
        24   -> mbedtls_ct_mpi_uint_if
      32   mbedtls_mpi_core_cond_swap
        32   -> mbedtls_ct_mpi_uint_if
      72   mbedtls_mpi_core_exp_mod
        72   -> __aeabi_memclr4
        72   -> __aeabi_memcpy
        72   -> __aeabi_memcpy4
        72   -> mbedtls_ct_bool
        72   -> mbedtls_mpi_core_cond_assign
        72   -> mbedtls_mpi_core_montmul
        72   -> mbedtls_mpi_core_montmul_init
       0   mbedtls_mpi_core_exp_mod_working_limbs
      40   mbedtls_mpi_core_fill_random
        40   -- Indirect call
        40   -> __aeabi_memclr
        40   -> __aeabi_memclr4
        40   -> mbedtls_mpi_core_bigendian_to_host
      32   mbedtls_mpi_core_from_mont_rep
        32   -> mbedtls_mpi_core_montmul
      16   mbedtls_mpi_core_get_mont_r2_unsafe
        16   -> mbedtls_mpi_lset
        16   -> mbedtls_mpi_mod_mpi
        16   -> mbedtls_mpi_shift_l
         0   -> mbedtls_mpi_shrink
      32   mbedtls_mpi_core_lt_ct
        32   -> mbedtls_ct_uint_lt
      20   mbedtls_mpi_core_mla
      48   mbedtls_mpi_core_montmul
        48   -> __aeabi_memclr4
        48   -> mbedtls_ct_bool
        48   -> mbedtls_ct_memcpy_if
        48   -> mbedtls_mpi_core_mla
        48   -> mbedtls_mpi_core_sub
       0   mbedtls_mpi_core_montmul_init
      32   mbedtls_mpi_core_mul
        32   -> __aeabi_memclr4
        32   -> mbedtls_mpi_core_mla
      48   mbedtls_mpi_core_random
        48   -> mbedtls_mpi_core_bitlen
        48   -> mbedtls_mpi_core_fill_random
        48   -> mbedtls_mpi_core_lt_ct
        48   -> mbedtls_mpi_core_shift_r
        48   -> mbedtls_mpi_core_uint_le_mpi
      24   mbedtls_mpi_core_read_be
        24   -> __aeabi_memclr4
        24   -> __aeabi_memcpy
        24   -> mbedtls_mpi_core_bigendian_to_host
      24   mbedtls_mpi_core_read_le
        24   -> __aeabi_memclr4
      20   mbedtls_mpi_core_shift_l
      24   mbedtls_mpi_core_shift_r
        24   -> __aeabi_memclr
         0   -> __aeabi_memclr4
      20   mbedtls_mpi_core_sub
      16   mbedtls_mpi_core_sub_int
      32   mbedtls_mpi_core_to_mont_rep
        32   -> mbedtls_mpi_core_montmul
      24   mbedtls_mpi_core_uint_le_mpi
        24   -> mbedtls_ct_bool
        24   -> mbedtls_ct_uint_lt
      24   mbedtls_mpi_core_write_be
        24   -> __aeabi_memclr
      24   mbedtls_mpi_core_write_le
        24   -> __aeabi_memclr
       0   mpi_bigendian_to_host


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       6  ?Subroutine0
      18  ?Subroutine1
      10  ?Subroutine2
       2  mbedtls_byte_order_detector
      22  mbedtls_ct_bool
      10  mbedtls_ct_compiler_opaque
      20  mbedtls_ct_if
       2  mbedtls_ct_mpi_uint_if
      44  mbedtls_ct_uint_lt
      48  mbedtls_mpi_core_add
      64  mbedtls_mpi_core_add_if
      42  mbedtls_mpi_core_bigendian_to_host
      36  mbedtls_mpi_core_bitlen
      24  mbedtls_mpi_core_check_zero_ct
       6  mbedtls_mpi_core_clz
      48  mbedtls_mpi_core_cond_assign
      66  mbedtls_mpi_core_cond_swap
     352  mbedtls_mpi_core_exp_mod
      24  mbedtls_mpi_core_exp_mod_working_limbs
      88  mbedtls_mpi_core_fill_random
      32  mbedtls_mpi_core_from_mont_rep
      52  mbedtls_mpi_core_get_mont_r2_unsafe
      78  mbedtls_mpi_core_lt_ct
     364  mbedtls_mpi_core_mla
     146  mbedtls_mpi_core_montmul
      36  mbedtls_mpi_core_montmul_init
      56  mbedtls_mpi_core_mul
     126  mbedtls_mpi_core_random
      74  mbedtls_mpi_core_read_be
      72  mbedtls_mpi_core_read_le
      82  mbedtls_mpi_core_shift_l
     120  mbedtls_mpi_core_shift_r
      52  mbedtls_mpi_core_sub
      32  mbedtls_mpi_core_sub_int
      24  mbedtls_mpi_core_to_mont_rep
      52  mbedtls_mpi_core_uint_le_mpi
      96  mbedtls_mpi_core_write_be
      64  mbedtls_mpi_core_write_le
      34  mpi_bigendian_to_host

 
 2'528 bytes in section .text
 
 2'528 bytes of CODE memory

Errors: none
Warnings: none
