###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:18:02
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\x509.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\x509.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\x509.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\x509.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\x509.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\x509.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf      =  unknown,flags,int_specials,widths
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\x509.c
      1          /*
      2           *  X.509 common functions for parsing and verification
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           *  The ITU-T X.509 standard defines a certificate format for PKI.
     21           *
     22           *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)
     23           *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)
     24           *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)
     25           *
     26           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf
     27           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
     28           */
     29          
     30          #include "common.h"
     31          
     32          #if defined(MBEDTLS_X509_USE_C)
     33          
     34          #include "mbedtls/x509.h"
     35          #include "mbedtls/asn1.h"
     36          #include "mbedtls/error.h"
     37          #include "mbedtls/oid.h"
     38          
     39          #include <stdio.h>
     40          #include <string.h>
     41          
     42          #if defined(MBEDTLS_PEM_PARSE_C)
     43          #include "mbedtls/pem.h"
     44          #endif
     45          
     46          #include "mbedtls/asn1write.h"
     47          
     48          #include "mbedtls/platform.h"
     49          
     50          #if defined(MBEDTLS_HAVE_TIME)
     51          #include "mbedtls/platform_time.h"
     52          #endif
     53          #if defined(MBEDTLS_HAVE_TIME_DATE)
     54          #include "mbedtls/platform_util.h"
     55          #include <time.h>
     56          #endif
     57          
     58          #define CHECK(code)                                     \
     59              do {                                                \
     60                  if ((ret = (code)) != 0) {                      \
     61                      return ret;                                 \
     62                  }                                               \
     63              } while (0)
     64          
     65          #define CHECK_RANGE(min, max, val)                      \
     66              do {                                                \
     67                  if ((val) < (min) || (val) > (max)) {           \
     68                      return ret;                                 \
     69                  }                                               \
     70              } while (0)
     71          
     72          /*
     73           *  CertificateSerialNumber  ::=  INTEGER
     74           */

   \                                 In section .text, align 2, keep-with-next
     75          int mbedtls_x509_get_serial(unsigned char **p, const unsigned char *end,
     76                                      mbedtls_x509_buf *serial)
     77          {
   \                     mbedtls_x509_get_serial: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine5
     78              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     79          
     80              if ((end - *p) < 1) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x6   0xDC02             BGT.N    ??mbedtls_x509_get_serial_0
     81                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_SERIAL,
     82                                           MBEDTLS_ERR_ASN1_OUT_OF_DATA);
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable56
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
     83              }
     84          
     85              if (**p != (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_PRIMITIVE | 2) &&
     86                  **p !=   MBEDTLS_ASN1_INTEGER) {
   \                     ??mbedtls_x509_get_serial_0: (+1)
   \        0xE   0x7802             LDRB     R2,[R0, #+0]
   \       0x10   0x2A82             CMP      R2,#+130
   \       0x12   0xBF18             IT       NE
   \       0x14   0x2A02             CMPNE    R2,#+2
   \       0x16   0xD002             BEQ.N    ??mbedtls_x509_get_serial_1
     87                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_SERIAL,
     88                                           MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
     89              }
     90          
     91              serial->tag = *(*p)++;
   \                     ??mbedtls_x509_get_serial_1: (+1)
   \       0x1E   0x1C43             ADDS     R3,R0,#+1
   \       0x20   0x6023             STR      R3,[R4, #+0]
   \       0x22   0x7800             LDRB     R0,[R0, #+0]
     92          
     93              if ((ret = mbedtls_asn1_get_len(p, end, &serial->len)) != 0) {
   \       0x24   0x1D2A             ADDS     R2,R5,#+4
   \       0x26   0x6028             STR      R0,[R5, #+0]
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       mbedtls_asn1_get_len
   \       0x2E   0xB110             CBZ.N    R0,??mbedtls_x509_get_serial_2
     94                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_SERIAL, ret);
   \       0x30   0xF5A0 0x500A      SUB      R0,R0,#+8832
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
     95              }
     96          
     97              serial->p = *p;
   \                     ??mbedtls_x509_get_serial_2: (+1)
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x60A9             STR      R1,[R5, #+8]
     98              *p += serial->len;
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6869             LDR      R1,[R5, #+4]
   \       0x3E   0x4401             ADD      R1,R0,R1
   \       0x40   0x6021             STR      R1,[R4, #+0]
     99          
    100              return 0;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD32             POP      {R1,R4,R5,PC}
    101          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x6820             LDR      R0,[R4, #+0]
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x1A0A             SUBS     R2,R1,R0
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0x4770             BX       LR
    102          
    103          /* Get an algorithm identifier without parameters (eg for signatures)
    104           *
    105           *  AlgorithmIdentifier  ::=  SEQUENCE  {
    106           *       algorithm               OBJECT IDENTIFIER,
    107           *       parameters              ANY DEFINED BY algorithm OPTIONAL  }
    108           */

   \                                 In section .text, align 2, keep-with-next
    109          int mbedtls_x509_get_alg_null(unsigned char **p, const unsigned char *end,
    110                                        mbedtls_x509_buf *alg)
    111          {
   \                     mbedtls_x509_get_alg_null: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    112              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    113          
    114              if ((ret = mbedtls_asn1_get_alg_null(p, end, alg)) != 0) {
   \        0x2   0x.... 0x....      BL       mbedtls_asn1_get_alg_null
   \        0x6   0x....             B.N      ?Subroutine0
    115                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    116              }
    117          
    118              return 0;
    119          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB108             CBZ.N    R0,??Subroutine0_0
   \        0x2   0xF5A0 0x500C      SUB      R0,R0,#+8960
   \                     ??Subroutine0_0: (+1)
   \        0x6   0xBD02             POP      {R1,PC}
    120          
    121          /*
    122           * Parse an algorithm identifier with (optional) parameters
    123           */

   \                                 In section .text, align 2, keep-with-next
    124          int mbedtls_x509_get_alg(unsigned char **p, const unsigned char *end,
    125                                   mbedtls_x509_buf *alg, mbedtls_x509_buf *params)
    126          {
   \                     mbedtls_x509_get_alg: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    127              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    128          
    129              if ((ret = mbedtls_asn1_get_alg(p, end, alg, params)) != 0) {
   \        0x2   0x.... 0x....      BL       mbedtls_asn1_get_alg
   \        0x6                      REQUIRE ?Subroutine0
   \        0x6                      ;; // Fall through to label ?Subroutine0
    130                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    131              }
    132          
    133              return 0;
    134          }
    135          
    136          /*
    137           * Convert md type to string
    138           */
    139          #if !defined(MBEDTLS_X509_REMOVE_INFO) && defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
    140          
    141          static inline const char *md_type_to_string(mbedtls_md_type_t md_alg)
    142          {
    143              switch (md_alg) {
    144          #if defined(MBEDTLS_MD_CAN_MD5)
    145                  case MBEDTLS_MD_MD5:
    146                      return "MD5";
    147          #endif
    148          #if defined(MBEDTLS_MD_CAN_SHA1)
    149                  case MBEDTLS_MD_SHA1:
    150                      return "SHA1";
    151          #endif
    152          #if defined(MBEDTLS_MD_CAN_SHA224)
    153                  case MBEDTLS_MD_SHA224:
    154                      return "SHA224";
    155          #endif
    156          #if defined(MBEDTLS_MD_CAN_SHA256)
    157                  case MBEDTLS_MD_SHA256:
    158                      return "SHA256";
    159          #endif
    160          #if defined(MBEDTLS_MD_CAN_SHA384)
    161                  case MBEDTLS_MD_SHA384:
    162                      return "SHA384";
    163          #endif
    164          #if defined(MBEDTLS_MD_CAN_SHA512)
    165                  case MBEDTLS_MD_SHA512:
    166                      return "SHA512";
    167          #endif
    168          #if defined(MBEDTLS_MD_CAN_RIPEMD160)
    169                  case MBEDTLS_MD_RIPEMD160:
    170                      return "RIPEMD160";
    171          #endif
    172                  case MBEDTLS_MD_NONE:
    173                      return NULL;
    174                  default:
    175                      return NULL;
    176              }
    177          }
    178          
    179          #endif /* !defined(MBEDTLS_X509_REMOVE_INFO) && defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) */
    180          
    181          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
    182          /*
    183           * HashAlgorithm ::= AlgorithmIdentifier
    184           *
    185           * AlgorithmIdentifier  ::=  SEQUENCE  {
    186           *      algorithm               OBJECT IDENTIFIER,
    187           *      parameters              ANY DEFINED BY algorithm OPTIONAL  }
    188           *
    189           * For HashAlgorithm, parameters MUST be NULL or absent.
    190           */
    191          static int x509_get_hash_alg(const mbedtls_x509_buf *alg, mbedtls_md_type_t *md_alg)
    192          {
    193              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    194              unsigned char *p;
    195              const unsigned char *end;
    196              mbedtls_x509_buf md_oid;
    197              size_t len;
    198          
    199              /* Make sure we got a SEQUENCE and setup bounds */
    200              if (alg->tag != (MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) {
    201                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    202                                           MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
    203              }
    204          
    205              p = alg->p;
    206              end = p + alg->len;
    207          
    208              if (p >= end) {
    209                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    210                                           MBEDTLS_ERR_ASN1_OUT_OF_DATA);
    211              }
    212          
    213              /* Parse md_oid */
    214              md_oid.tag = *p;
    215          
    216              if ((ret = mbedtls_asn1_get_tag(&p, end, &md_oid.len, MBEDTLS_ASN1_OID)) != 0) {
    217                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    218              }
    219          
    220              md_oid.p = p;
    221              p += md_oid.len;
    222          
    223              /* Get md_alg from md_oid */
    224              if ((ret = mbedtls_oid_get_md_alg(&md_oid, md_alg)) != 0) {
    225                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    226              }
    227          
    228              /* Make sure params is absent of NULL */
    229              if (p == end) {
    230                  return 0;
    231              }
    232          
    233              if ((ret = mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_NULL)) != 0 || len != 0) {
    234                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    235              }
    236          
    237              if (p != end) {
    238                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    239                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    240              }
    241          
    242              return 0;
    243          }
    244          
    245          /*
    246           *    RSASSA-PSS-params  ::=  SEQUENCE  {
    247           *       hashAlgorithm     [0] HashAlgorithm DEFAULT sha1Identifier,
    248           *       maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,
    249           *       saltLength        [2] INTEGER DEFAULT 20,
    250           *       trailerField      [3] INTEGER DEFAULT 1  }
    251           *    -- Note that the tags in this Sequence are explicit.
    252           *
    253           * RFC 4055 (which defines use of RSASSA-PSS in PKIX) states that the value
    254           * of trailerField MUST be 1, and PKCS#1 v2.2 doesn't even define any other
    255           * option. Enforce this at parsing time.
    256           */
    257          int mbedtls_x509_get_rsassa_pss_params(const mbedtls_x509_buf *params,
    258                                                 mbedtls_md_type_t *md_alg, mbedtls_md_type_t *mgf_md,
    259                                                 int *salt_len)
    260          {
    261              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    262              unsigned char *p;
    263              const unsigned char *end, *end2;
    264              size_t len;
    265              mbedtls_x509_buf alg_id, alg_params;
    266          
    267              /* First set everything to defaults */
    268              *md_alg = MBEDTLS_MD_SHA1;
    269              *mgf_md = MBEDTLS_MD_SHA1;
    270              *salt_len = 20;
    271          
    272              /* Make sure params is a SEQUENCE and setup bounds */
    273              if (params->tag != (MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) {
    274                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    275                                           MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
    276              }
    277          
    278              p = (unsigned char *) params->p;
    279              end = p + params->len;
    280          
    281              if (p == end) {
    282                  return 0;
    283              }
    284          
    285              /*
    286               * HashAlgorithm
    287               */
    288              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
    289                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    290                                              0)) == 0) {
    291                  end2 = p + len;
    292          
    293                  /* HashAlgorithm ::= AlgorithmIdentifier (without parameters) */
    294                  if ((ret = mbedtls_x509_get_alg_null(&p, end2, &alg_id)) != 0) {
    295                      return ret;
    296                  }
    297          
    298                  if ((ret = mbedtls_oid_get_md_alg(&alg_id, md_alg)) != 0) {
    299                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    300                  }
    301          
    302                  if (p != end2) {
    303                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    304                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    305                  }
    306              } else if (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    307                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    308              }
    309          
    310              if (p == end) {
    311                  return 0;
    312              }
    313          
    314              /*
    315               * MaskGenAlgorithm
    316               */
    317              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
    318                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    319                                              1)) == 0) {
    320                  end2 = p + len;
    321          
    322                  /* MaskGenAlgorithm ::= AlgorithmIdentifier (params = HashAlgorithm) */
    323                  if ((ret = mbedtls_x509_get_alg(&p, end2, &alg_id, &alg_params)) != 0) {
    324                      return ret;
    325                  }
    326          
    327                  /* Only MFG1 is recognised for now */
    328                  if (MBEDTLS_OID_CMP(MBEDTLS_OID_MGF1, &alg_id) != 0) {
    329                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE,
    330                                               MBEDTLS_ERR_OID_NOT_FOUND);
    331                  }
    332          
    333                  /* Parse HashAlgorithm */
    334                  if ((ret = x509_get_hash_alg(&alg_params, mgf_md)) != 0) {
    335                      return ret;
    336                  }
    337          
    338                  if (p != end2) {
    339                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    340                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    341                  }
    342              } else if (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    343                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    344              }
    345          
    346              if (p == end) {
    347                  return 0;
    348              }
    349          
    350              /*
    351               * salt_len
    352               */
    353              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
    354                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    355                                              2)) == 0) {
    356                  end2 = p + len;
    357          
    358                  if ((ret = mbedtls_asn1_get_int(&p, end2, salt_len)) != 0) {
    359                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    360                  }
    361          
    362                  if (p != end2) {
    363                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    364                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    365                  }
    366              } else if (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    367                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    368              }
    369          
    370              if (p == end) {
    371                  return 0;
    372              }
    373          
    374              /*
    375               * trailer_field (if present, must be 1)
    376               */
    377              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
    378                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    379                                              3)) == 0) {
    380                  int trailer_field;
    381          
    382                  end2 = p + len;
    383          
    384                  if ((ret = mbedtls_asn1_get_int(&p, end2, &trailer_field)) != 0) {
    385                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    386                  }
    387          
    388                  if (p != end2) {
    389                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    390                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    391                  }
    392          
    393                  if (trailer_field != 1) {
    394                      return MBEDTLS_ERR_X509_INVALID_ALG;
    395                  }
    396              } else if (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    397                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG, ret);
    398              }
    399          
    400              if (p != end) {
    401                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_ALG,
    402                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    403              }
    404          
    405              return 0;
    406          }
    407          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
    408          
    409          /*
    410           *  AttributeTypeAndValue ::= SEQUENCE {
    411           *    type     AttributeType,
    412           *    value    AttributeValue }
    413           *
    414           *  AttributeType ::= OBJECT IDENTIFIER
    415           *
    416           *  AttributeValue ::= ANY DEFINED BY AttributeType
    417           */
    418          static int x509_get_attr_type_value(unsigned char **p,
    419                                              const unsigned char *end,
    420                                              mbedtls_x509_name *cur)
    421          {
    422              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    423              size_t len;
    424              mbedtls_x509_buf *oid;
    425              mbedtls_x509_buf *val;
    426          
    427              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    428                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    429                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME, ret);
    430              }
    431          
    432              end = *p + len;
    433          
    434              if ((end - *p) < 1) {
    435                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME,
    436                                           MBEDTLS_ERR_ASN1_OUT_OF_DATA);
    437              }
    438          
    439              oid = &cur->oid;
    440              oid->tag = **p;
    441          
    442              if ((ret = mbedtls_asn1_get_tag(p, end, &oid->len, MBEDTLS_ASN1_OID)) != 0) {
    443                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME, ret);
    444              }
    445          
    446              oid->p = *p;
    447              *p += oid->len;
    448          
    449              if ((end - *p) < 1) {
    450                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME,
    451                                           MBEDTLS_ERR_ASN1_OUT_OF_DATA);
    452              }
    453          
    454              if (**p != MBEDTLS_ASN1_BMP_STRING && **p != MBEDTLS_ASN1_UTF8_STRING      &&
    455                  **p != MBEDTLS_ASN1_T61_STRING && **p != MBEDTLS_ASN1_PRINTABLE_STRING &&
    456                  **p != MBEDTLS_ASN1_IA5_STRING && **p != MBEDTLS_ASN1_UNIVERSAL_STRING &&
    457                  **p != MBEDTLS_ASN1_BIT_STRING) {
    458                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME,
    459                                           MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
    460              }
    461          
    462              val = &cur->val;
    463              val->tag = *(*p)++;
    464          
    465              if ((ret = mbedtls_asn1_get_len(p, end, &val->len)) != 0) {
    466                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME, ret);
    467              }
    468          
    469              val->p = *p;
    470              *p += val->len;
    471          
    472              if (*p != end) {
    473                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME,
    474                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    475              }
    476          
    477              cur->next = NULL;
    478          
    479              return 0;
    480          }
    481          
    482          /*
    483           *  Name ::= CHOICE { -- only one possibility for now --
    484           *       rdnSequence  RDNSequence }
    485           *
    486           *  RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
    487           *
    488           *  RelativeDistinguishedName ::=
    489           *    SET OF AttributeTypeAndValue
    490           *
    491           *  AttributeTypeAndValue ::= SEQUENCE {
    492           *    type     AttributeType,
    493           *    value    AttributeValue }
    494           *
    495           *  AttributeType ::= OBJECT IDENTIFIER
    496           *
    497           *  AttributeValue ::= ANY DEFINED BY AttributeType
    498           *
    499           * The data structure is optimized for the common case where each RDN has only
    500           * one element, which is represented as a list of AttributeTypeAndValue.
    501           * For the general case we still use a flat list, but we mark elements of the
    502           * same set so that they are "merged" together in the functions that consume
    503           * this list, eg mbedtls_x509_dn_gets().
    504           *
    505           * On success, this function may allocate a linked list starting at cur->next
    506           * that must later be free'd by the caller using mbedtls_free(). In error
    507           * cases, this function frees all allocated memory internally and the caller
    508           * has no freeing responsibilities.
    509           */

   \                                 In section .text, align 2, keep-with-next
    510          int mbedtls_x509_get_name(unsigned char **p, const unsigned char *end,
    511                                    mbedtls_x509_name *cur)
    512          {
   \                     mbedtls_x509_get_name: (+1)
   \        0x0   0xE92D 0x4BFC      PUSH     {R2-R9,R11,LR}
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x468B             MOV      R11,R1
    513              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    514              size_t set_len;
    515              const unsigned char *end_set;
    516              mbedtls_x509_name *head = cur;
   \        0xA   0x462E             MOV      R6,R5
   \        0xC   0xE006             B.N      ??mbedtls_x509_get_name_0
    517          
    518              /* don't use recursion, we'd risk stack overflow if not optimized */
    519              while (1) {
    520                  /*
    521                   * parse SET
    522                   */
    523                  if ((ret = mbedtls_asn1_get_tag(p, end, &set_len,
    524                                                  MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SET)) != 0) {
    525                      ret = MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_NAME, ret);
    526                      goto error;
    527                  }
    528          
    529                  end_set  = *p + set_len;
    530          
    531                  while (1) {
    532                      if ((ret = x509_get_attr_type_value(p, end_set, cur)) != 0) {
    533                          goto error;
    534                      }
    535          
    536                      if (*p == end_set) {
    537                          break;
    538                      }
    539          
    540                      /* Mark this item as being no the only one in a set */
    541                      cur->next_merged = 1;
    542          
    543                      cur->next = mbedtls_calloc(1, sizeof(mbedtls_x509_name));
    544          
    545                      if (cur->next == NULL) {
    546                          ret = MBEDTLS_ERR_X509_ALLOC_FAILED;
    547                          goto error;
    548                      }
    549          
    550                      cur = cur->next;
    551                  }
    552          
    553                  /*
    554                   * continue until end of SEQUENCE is reached
    555                   */
    556                  if (*p == end) {
    557                      return 0;
    558                  }
    559          
    560                  cur->next = mbedtls_calloc(1, sizeof(mbedtls_x509_name));
   \                     ??mbedtls_x509_get_name_1: (+1)
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x.... 0x....      BL       sl_calloc
   \       0x16   0x61A8             STR      R0,[R5, #+24]
    561          
    562                  if (cur->next == NULL) {
   \       0x18   0x0005             MOVS     R5,R0
   \       0x1A   0xD07A             BEQ.N    ??mbedtls_x509_get_name_2
    563                      ret = MBEDTLS_ERR_X509_ALLOC_FAILED;
    564                      goto error;
    565                  }
    566          
    567                  cur = cur->next;
   \                     ??mbedtls_x509_get_name_0: (+1)
   \       0x1C   0x2331             MOVS     R3,#+49
   \       0x1E   0x466A             MOV      R2,SP
   \       0x20   0x4659             MOV      R1,R11
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x28   0x0004             MOVS     R4,R0
   \       0x2A   0xD104             BNE.N    ??mbedtls_x509_get_name_3
   \       0x2C   0x6839             LDR      R1,[R7, #+0]
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \       0x30   0xEB01 0x0900      ADD      R9,R1,R0
   \       0x34   0xE010             B.N      ??mbedtls_x509_get_name_4
   \                     ??mbedtls_x509_get_name_3: (+1)
   \       0x36   0xF5A0 0x540E      SUB      R4,R0,#+9088
   \       0x3A   0xE057             B.N      ??mbedtls_x509_get_name_5
   \                     ??mbedtls_x509_get_name_6: (+1)
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x61A9             STR      R1,[R5, #+24]
   \       0x40   0x6038             STR      R0,[R7, #+0]
   \                     ??mbedtls_x509_get_name_7: (+1)
   \       0x42   0x6838             LDR      R0,[R7, #+0]
   \       0x44   0x4548             CMP      R0,R9
   \       0x46   0xD010             BEQ.N    ??mbedtls_x509_get_name_8
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0x7728             STRB     R0,[R5, #+28]
   \       0x4C   0x2120             MOVS     R1,#+32
   \       0x4E   0x.... 0x....      BL       sl_calloc
   \       0x52   0x61A8             STR      R0,[R5, #+24]
   \       0x54   0x0005             MOVS     R5,R0
   \       0x56   0xD05C             BEQ.N    ??mbedtls_x509_get_name_2
   \                     ??mbedtls_x509_get_name_4: (+1)
   \       0x58   0x2330             MOVS     R3,#+48
   \       0x5A   0xAA01             ADD      R2,SP,#+4
   \       0x5C   0x4649             MOV      R1,R9
   \       0x5E   0x4638             MOV      R0,R7
   \       0x60   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x64   0x0004             MOVS     R4,R0
   \       0x66   0xD004             BEQ.N    ??mbedtls_x509_get_name_9
   \       0x68   0xE037             B.N      ??mbedtls_x509_get_name_10
   \                     ??mbedtls_x509_get_name_8: (+1)
   \       0x6A   0x4558             CMP      R0,R11
   \       0x6C   0xD1CF             BNE.N    ??mbedtls_x509_get_name_1
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE042             B.N      ??mbedtls_x509_get_name_11
   \                     ??mbedtls_x509_get_name_9: (+1)
   \       0x72   0x6838             LDR      R0,[R7, #+0]
   \       0x74   0x9901             LDR      R1,[SP, #+4]
   \       0x76   0xEB00 0x0801      ADD      R8,R0,R1
   \       0x7A   0x2900             CMP      R1,#+0
   \       0x7C   0xDD31             BLE.N    ??mbedtls_x509_get_name_12
   \       0x7E   0x7800             LDRB     R0,[R0, #+0]
   \       0x80   0x2306             MOVS     R3,#+6
   \       0x82   0x1D2A             ADDS     R2,R5,#+4
   \       0x84   0x6028             STR      R0,[R5, #+0]
   \       0x86   0x4641             MOV      R1,R8
   \       0x88   0x4638             MOV      R0,R7
   \       0x8A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x8E   0x0004             MOVS     R4,R0
   \       0x90   0xD123             BNE.N    ??mbedtls_x509_get_name_10
   \       0x92   0x6838             LDR      R0,[R7, #+0]
   \       0x94   0x60A8             STR      R0,[R5, #+8]
   \       0x96   0x6839             LDR      R1,[R7, #+0]
   \       0x98   0x6868             LDR      R0,[R5, #+4]
   \       0x9A   0x4408             ADD      R0,R1,R0
   \       0x9C   0xEBA8 0x0100      SUB      R1,R8,R0
   \       0xA0   0x6038             STR      R0,[R7, #+0]
   \       0xA2   0x2900             CMP      R1,#+0
   \       0xA4   0xDD1D             BLE.N    ??mbedtls_x509_get_name_12
   \       0xA6   0x7801             LDRB     R1,[R0, #+0]
   \       0xA8   0x291E             CMP      R1,#+30
   \       0xAA   0xBF18             IT       NE
   \       0xAC   0x290C             CMPNE    R1,#+12
   \       0xAE   0xD008             BEQ.N    ??mbedtls_x509_get_name_13
   \       0xB0   0x2914             CMP      R1,#+20
   \       0xB2   0xBF18             IT       NE
   \       0xB4   0x2913             CMPNE    R1,#+19
   \       0xB6   0xD004             BEQ.N    ??mbedtls_x509_get_name_13
   \       0xB8   0x2916             CMP      R1,#+22
   \       0xBA   0xBF1C             ITT      NE
   \       0xBC   0x291C             CMPNE    R1,#+28
   \       0xBE   0x2903             CMPNE    R1,#+3
   \       0xC0   0xD112             BNE.N    ??mbedtls_x509_get_name_14
   \                     ??mbedtls_x509_get_name_13: (+1)
   \       0xC2   0x1C41             ADDS     R1,R0,#+1
   \       0xC4   0x6039             STR      R1,[R7, #+0]
   \       0xC6   0x7800             LDRB     R0,[R0, #+0]
   \       0xC8   0xF105 0x0210      ADD      R2,R5,#+16
   \       0xCC   0x4641             MOV      R1,R8
   \       0xCE   0x60E8             STR      R0,[R5, #+12]
   \       0xD0   0x4638             MOV      R0,R7
   \       0xD2   0x.... 0x....      BL       mbedtls_asn1_get_len
   \       0xD6   0x0004             MOVS     R4,R0
   \       0xD8   0xD010             BEQ.N    ??mbedtls_x509_get_name_15
   \                     ??mbedtls_x509_get_name_10: (+1)
   \       0xDA   0xF5B0 0x540E      SUBS     R4,R0,#+9088
   \       0xDE   0xD0B0             BEQ.N    ??mbedtls_x509_get_name_7
   \       0xE0   0xE004             B.N      ??mbedtls_x509_get_name_5
   \                     ??mbedtls_x509_get_name_12: (+1)
   \       0xE2   0x.... 0x....      LDR.W    R4,??DataTable57
   \       0xE6   0xE001             B.N      ??mbedtls_x509_get_name_5
   \                     ??mbedtls_x509_get_name_14: (+1)
   \       0xE8   0x.... 0x....      LDR.W    R4,??DataTable57_1
    568              }
    569          
    570          error:
    571              /* Skip the first element as we did not allocate it */
    572              mbedtls_asn1_free_named_data_list_shallow(head->next);
   \                     ??mbedtls_x509_get_name_5: (+1)
   \       0xEC   0x69B0             LDR      R0,[R6, #+24]
   \       0xEE   0x.... 0x....      BL       mbedtls_asn1_free_named_data_list_shallow
    573              head->next = NULL;
   \       0xF2   0x2100             MOVS     R1,#+0
   \       0xF4   0x61B1             STR      R1,[R6, #+24]
    574          
    575              return ret;
   \       0xF6   0x4620             MOV      R0,R4
   \                     ??mbedtls_x509_get_name_11: (+1)
   \       0xF8   0xE8BD 0x8BF6      POP      {R1,R2,R4-R9,R11,PC}
   \                     ??mbedtls_x509_get_name_15: (+1)
   \       0xFC   0x6838             LDR      R0,[R7, #+0]
   \       0xFE   0x6168             STR      R0,[R5, #+20]
   \      0x100   0x6839             LDR      R1,[R7, #+0]
   \      0x102   0x6928             LDR      R0,[R5, #+16]
   \      0x104   0x4408             ADD      R0,R1,R0
   \      0x106   0x4540             CMP      R0,R8
   \      0x108   0xD098             BEQ.N    ??mbedtls_x509_get_name_6
   \      0x10A   0x.... 0x....      LDR.W    R4,??DataTable57_2
   \      0x10E   0x6038             STR      R0,[R7, #+0]
   \      0x110   0xE7EC             B.N      ??mbedtls_x509_get_name_5
   \                     ??mbedtls_x509_get_name_2: (+1)
   \      0x112   0x.... 0x....      LDR.W    R4,??DataTable57_3
   \      0x116   0xE7E9             B.N      ??mbedtls_x509_get_name_5
    576          }
    577          
    578          static int x509_date_is_valid(const mbedtls_x509_time *t)
    579          {
    580              unsigned int month_days;
    581              unsigned int year;
    582              switch (t->mon) {
    583                  case 1: case 3: case 5: case 7: case 8: case 10: case 12:
    584                      month_days = 31;
    585                      break;
    586                  case 4: case 6: case 9: case 11:
    587                      month_days = 30;
    588                      break;
    589                  case 2:
    590                      year = (unsigned int) t->year;
    591                      month_days = ((year & 3) || (!(year % 100)
    592                                                   && (year % 400)))
    593                                    ? 28 : 29;
    594                      break;
    595                  default:
    596                      return MBEDTLS_ERR_X509_INVALID_DATE;
    597              }
    598          
    599              if ((unsigned int) (t->day - 1) >= month_days ||      /* (1 - days in month) */
    600                  /* (unsigned int) (t->mon - 1) >= 12 || */  /* (1 - 12) checked above */
    601                  (unsigned int) t->year > 9999 ||         /* (0 - 9999) */
    602                  (unsigned int) t->hour > 23 ||           /* (0 - 23) */
    603                  (unsigned int) t->min  > 59 ||           /* (0 - 59) */
    604                  (unsigned int) t->sec  > 59) {           /* (0 - 59) */
    605                  return MBEDTLS_ERR_X509_INVALID_DATE;
    606              }
    607          
    608              return 0;
    609          }
    610          

   \                                 In section .text, align 2, keep-with-next
    611          static int x509_parse2_int(const unsigned char *p)
    612          {
   \                     x509_parse2_int: (+1)
   \        0x0   0x4601             MOV      R1,R0
    613              uint32_t d1 = p[0] - '0';
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
    614              uint32_t d2 = p[1] - '0';
   \        0x4   0x784A             LDRB     R2,[R1, #+1]
   \        0x6   0x3830             SUBS     R0,R0,#+48
   \        0x8   0x3A30             SUBS     R2,R2,#+48
    615              return (d1 < 10 && d2 < 10) ? (int) (d1 * 10 + d2) : -1;
   \        0xA   0x280A             CMP      R0,#+10
   \        0xC   0xBF38             IT       CC
   \        0xE   0x2A0A             CMPCC    R2,#+10
   \       0x10   0xD203             BCS.N    ??x509_parse2_int_0
   \       0x12   0x210A             MOVS     R1,#+10
   \       0x14   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \       0x18   0x4770             BX       LR
   \                     ??x509_parse2_int_0: (+1)
   \       0x1A   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x1E   0x4770             BX       LR
    616          }
    617          
    618          /*
    619           * Parse an ASN1_UTC_TIME (yearlen=2) or ASN1_GENERALIZED_TIME (yearlen=4)
    620           * field.
    621           */
    622          static int x509_parse_time(const unsigned char *p, mbedtls_x509_time *tm,
    623                                     size_t yearlen)
    624          {
    625              int x;
    626          
    627              /*
    628               * Parse year, month, day, hour, minute, second
    629               */
    630              tm->year = x509_parse2_int(p);
    631              if (tm->year < 0) {
    632                  return MBEDTLS_ERR_X509_INVALID_DATE;
    633              }
    634          
    635              if (4 == yearlen) {
    636                  x = tm->year * 100;
    637                  p += 2;
    638                  tm->year = x509_parse2_int(p);
    639                  if (tm->year < 0) {
    640                      return MBEDTLS_ERR_X509_INVALID_DATE;
    641                  }
    642              } else {
    643                  x = (tm->year < 50) ? 2000 : 1900;
    644              }
    645              tm->year += x;
    646          
    647              tm->mon  = x509_parse2_int(p + 2);
    648              tm->day  = x509_parse2_int(p + 4);
    649              tm->hour = x509_parse2_int(p + 6);
    650              tm->min  = x509_parse2_int(p + 8);
    651              tm->sec  = x509_parse2_int(p + 10);
    652          
    653              return x509_date_is_valid(tm);
    654          }
    655          
    656          /*
    657           *  Time ::= CHOICE {
    658           *       utcTime        UTCTime,
    659           *       generalTime    GeneralizedTime }
    660           */

   \                                 In section .text, align 4, keep-with-next
    661          int mbedtls_x509_get_time(unsigned char **p, const unsigned char *end,
    662                                    mbedtls_x509_time *tm)
    663          {
   \                     mbedtls_x509_get_time: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine5
    664              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    665              size_t len, year_len;
    666              unsigned char tag;
    667          
    668              if ((end - *p) < 1) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0x8   0xBFD8             IT       LE
   \        0xA   0x.... 0x....      LDRLE.W  R0,??DataTable57_4
    669                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE,
    670                                           MBEDTLS_ERR_ASN1_OUT_OF_DATA);
   \        0xE   0xDD3E             BLE.N    ??mbedtls_x509_get_time_1
    671              }
    672          
    673              tag = **p;
   \       0x10   0x7802             LDRB     R2,[R0, #+0]
    674          
    675              if (tag == MBEDTLS_ASN1_UTC_TIME) {
   \       0x12   0x2A17             CMP      R2,#+23
   \       0x14   0xD10A             BNE.N    ??mbedtls_x509_get_time_2
    676                  year_len = 2;
   \       0x16   0x2702             MOVS     R7,#+2
    677              } else if (tag == MBEDTLS_ASN1_GENERALIZED_TIME) {
    678                  year_len = 4;
    679              } else {
    680                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE,
    681                                           MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
    682              }
    683          
    684              (*p)++;
   \                     ??mbedtls_x509_get_time_3: (+1)
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0x6020             STR      R0,[R4, #+0]
    685              ret = mbedtls_asn1_get_len(p, end, &len);
   \       0x1C   0x466A             MOV      R2,SP
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       mbedtls_asn1_get_len
    686          
    687              if (ret != 0) {
   \       0x24   0xB148             CBZ.N    R0,??mbedtls_x509_get_time_4
    688                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE, ret);
   \       0x26   0xF5A0 0x5010      SUB      R0,R0,#+9216
   \       0x2A   0xE030             B.N      ??mbedtls_x509_get_time_1
   \                     ??mbedtls_x509_get_time_2: (+1)
   \       0x2C   0x2A18             CMP      R2,#+24
   \       0x2E   0xBF08             IT       EQ
   \       0x30   0x2704             MOVEQ    R7,#+4
   \       0x32   0xD0F1             BEQ.N    ??mbedtls_x509_get_time_3
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable57_5
   \       0x38   0xE029             B.N      ??mbedtls_x509_get_time_1
    689              }
    690          
    691              /* len is 12 or 14 depending on year_len, plus optional trailing 'Z' */
    692              if (len != year_len + 10 &&
    693                  !(len == year_len + 11 && (*p)[(len - 1)] == 'Z')) {
   \                     ??mbedtls_x509_get_time_4: (+1)
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x.... 0x....      LDR.W    R8,??DataTable57_6
   \       0x40   0x380A             SUBS     R0,R0,#+10
   \       0x42   0x42B8             CMP      R0,R7
   \       0x44   0xD00A             BEQ.N    ??mbedtls_x509_get_time_5
   \       0x46   0x9900             LDR      R1,[SP, #+0]
   \       0x48   0x390B             SUBS     R1,R1,#+11
   \       0x4A   0x42B9             CMP      R1,R7
   \       0x4C   0xD11E             BNE.N    ??mbedtls_x509_get_time_6
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x9900             LDR      R1,[SP, #+0]
   \       0x52   0x4401             ADD      R1,R0,R1
   \       0x54   0xF811 0x0C01      LDRB     R0,[R1, #-1]
   \       0x58   0x285A             CMP      R0,#+90
   \       0x5A   0xD117             BNE.N    ??mbedtls_x509_get_time_6
    694                  return MBEDTLS_ERR_X509_INVALID_DATE;
    695              }
    696          
    697              (*p) += len;
   \                     ??mbedtls_x509_get_time_5: (+1)
   \       0x5C   0x.... 0x....      BL       ?Subroutine6
    698              return x509_parse_time(*p - len, tm, year_len);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x60   0x9900             LDR      R1,[SP, #+0]
   \       0x62   0x6020             STR      R0,[R4, #+0]
   \       0x64   0x4249             RSBS     R1,R1,#+0
   \       0x66   0x1846             ADDS     R6,R0,R1
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x.... 0x....      BL       x509_parse2_int
   \       0x6E   0x6028             STR      R0,[R5, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD40B             BMI.N    ??mbedtls_x509_get_time_6
   \       0x74   0x2464             MOVS     R4,#+100
   \       0x76   0x2F04             CMP      R7,#+4
   \       0x78   0xD10B             BNE.N    ??mbedtls_x509_get_time_7
   \       0x7A   0xFB04 0xF900      MUL      R9,R4,R0
   \       0x7E   0x1CB6             ADDS     R6,R6,#+2
   \       0x80   0x4630             MOV      R0,R6
   \       0x82   0x.... 0x....      BL       x509_parse2_int
   \       0x86   0x6028             STR      R0,[R5, #+0]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD508             BPL.N    ??mbedtls_x509_get_time_8
   \                     ??mbedtls_x509_get_time_6: (+1)
   \       0x8C   0x4640             MOV      R0,R8
   \                     ??mbedtls_x509_get_time_1: (+1)
   \       0x8E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   \                     ??mbedtls_x509_get_time_7: (+1)
   \       0x92   0x2832             CMP      R0,#+50
   \       0x94   0xBFB4             ITE      LT
   \       0x96   0xF44F 0x69FA      MOVLT    R9,#+2000
   \       0x9A   0xF240 0x796C      MOVWGE   R9,#+1900
   \                     ??mbedtls_x509_get_time_8: (+1)
   \       0x9E   0x6828             LDR      R0,[R5, #+0]
   \       0xA0   0x4448             ADD      R0,R9,R0
   \       0xA2   0x6028             STR      R0,[R5, #+0]
   \       0xA4   0x1CB0             ADDS     R0,R6,#+2
   \       0xA6   0x.... 0x....      BL       x509_parse2_int
   \       0xAA   0x6068             STR      R0,[R5, #+4]
   \       0xAC   0x1D30             ADDS     R0,R6,#+4
   \       0xAE   0x.... 0x....      BL       x509_parse2_int
   \       0xB2   0x60A8             STR      R0,[R5, #+8]
   \       0xB4   0x1DB0             ADDS     R0,R6,#+6
   \       0xB6   0x.... 0x....      BL       x509_parse2_int
   \       0xBA   0x60E8             STR      R0,[R5, #+12]
   \       0xBC   0xF106 0x0008      ADD      R0,R6,#+8
   \       0xC0   0x.... 0x....      BL       x509_parse2_int
   \       0xC4   0x6128             STR      R0,[R5, #+16]
   \       0xC6   0xF106 0x000A      ADD      R0,R6,#+10
   \       0xCA   0x.... 0x....      BL       x509_parse2_int
   \       0xCE   0x6168             STR      R0,[R5, #+20]
   \       0xD0   0x6868             LDR      R0,[R5, #+4]
   \       0xD2   0x1E40             SUBS     R0,R0,#+1
   \       0xD4   0x280B             CMP      R0,#+11
   \       0xD6   0xD8D9             BHI.N    ??mbedtls_x509_get_time_6
   \       0xD8   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mbedtls_x509_get_time_0:
   \       0xDC   0x20 0x07          DC8      0x20,0x7,0x20,0x1E
   \              0x20 0x1E
   \       0xE0   0x20 0x1E          DC8      0x20,0x1E,0x20,0x20
   \              0x20 0x20
   \       0xE4   0x1E 0x20          DC8      0x1E,0x20,0x1E,0x20
   \              0x1E 0x20
   \                     ??mbedtls_x509_get_time_9: (+1)
   \       0xE8   0xE7D0             B.N      ??mbedtls_x509_get_time_6
   \                     ??mbedtls_x509_get_time_10: (+1)
   \       0xEA   0x6828             LDR      R0,[R5, #+0]
   \       0xEC   0xF010 0x0F03      TST      R0,#0x3
   \       0xF0   0xD110             BNE.N    ??mbedtls_x509_get_time_11
   \       0xF2   0x2164             MOVS     R1,#+100
   \       0xF4   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0xF8   0xFB04 0x0411      MLS      R4,R4,R1,R0
   \       0xFC   0xB944             CBNZ.N   R4,??mbedtls_x509_get_time_12
   \       0xFE   0xF44F 0x72C8      MOV      R2,#+400
   \      0x102   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \      0x106   0xF44F 0x71C8      MOV      R1,#+400
   \      0x10A   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \      0x10E   0xB908             CBNZ.N   R0,??mbedtls_x509_get_time_11
   \                     ??mbedtls_x509_get_time_12: (+1)
   \      0x110   0x201D             MOVS     R0,#+29
   \      0x112   0xE004             B.N      ??mbedtls_x509_get_time_13
   \                     ??mbedtls_x509_get_time_11: (+1)
   \      0x114   0x201C             MOVS     R0,#+28
   \      0x116   0xE002             B.N      ??mbedtls_x509_get_time_13
   \                     ??mbedtls_x509_get_time_14: (+1)
   \      0x118   0x201E             MOVS     R0,#+30
   \      0x11A   0xE000             B.N      ??mbedtls_x509_get_time_13
   \                     ??mbedtls_x509_get_time_15: (+1)
   \      0x11C   0x201F             MOVS     R0,#+31
   \                     ??mbedtls_x509_get_time_13: (+1)
   \      0x11E   0x68A9             LDR      R1,[R5, #+8]
   \      0x120   0x1E49             SUBS     R1,R1,#+1
   \      0x122   0x4281             CMP      R1,R0
   \      0x124   0xBF3E             ITTT     CC
   \      0x126   0x682A             LDRCC    R2,[R5, #+0]
   \      0x128   0xF242 0x7010      MOVWCC   R0,#+10000
   \      0x12C   0x4282             CMPCC    R2,R0
   \      0x12E   0xD2AD             BCS.N    ??mbedtls_x509_get_time_6
   \      0x130   0x68E9             LDR      R1,[R5, #+12]
   \      0x132   0x2918             CMP      R1,#+24
   \      0x134   0xBF3F             ITTTT    CC
   \      0x136   0x6928             LDRCC    R0,[R5, #+16]
   \      0x138   0x283C             CMPCC    R0,#+60
   \      0x13A   0x6968             LDRCC    R0,[R5, #+20]
   \      0x13C   0x283C             CMPCC    R0,#+60
   \      0x13E   0xD2A5             BCS.N    ??mbedtls_x509_get_time_6
   \      0x140   0xF04F 0x0800      MOV      R8,#+0
   \      0x144   0xE7A2             B.N      ??mbedtls_x509_get_time_6
    699          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6821             LDR      R1,[R4, #+0]
   \        0x2   0x9800             LDR      R0,[SP, #+0]
   \        0x4   0x4408             ADD      R0,R1,R0
   \        0x6   0x4770             BX       LR
    700          

   \                                 In section .text, align 2, keep-with-next
    701          int mbedtls_x509_get_sig(unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig)
    702          {
   \                     mbedtls_x509_get_sig: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
    703              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    704              size_t len;
    705              int tag_type;
    706          
    707              if ((end - *p) < 1) {
   \        0x6   0x6822             LDR      R2,[R4, #+0]
   \        0x8   0x1A88             SUBS     R0,R1,R2
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xDC02             BGT.N    ??mbedtls_x509_get_sig_0
    708                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_SIGNATURE,
    709                                           MBEDTLS_ERR_ASN1_OUT_OF_DATA);
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable58
   \       0x12   0xBD76             POP      {R1,R2,R4-R6,PC}
    710              }
    711          
    712              tag_type = **p;
   \                     ??mbedtls_x509_get_sig_0: (+1)
   \       0x14   0x7816             LDRB     R6,[R2, #+0]
    713          
    714              if ((ret = mbedtls_asn1_get_bitstring_null(p, end, &len)) != 0) {
   \       0x16   0x466A             MOV      R2,SP
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_asn1_get_bitstring_null
   \       0x1E   0xB110             CBZ.N    R0,??mbedtls_x509_get_sig_1
    715                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_SIGNATURE, ret);
   \       0x20   0xF5A0 0x5012      SUB      R0,R0,#+9344
   \       0x24   0xBD76             POP      {R1,R2,R4-R6,PC}
    716              }
    717          
    718              sig->tag = tag_type;
   \                     ??mbedtls_x509_get_sig_1: (+1)
   \       0x26   0x602E             STR      R6,[R5, #+0]
    719              sig->len = len;
   \       0x28   0x9900             LDR      R1,[SP, #+0]
   \       0x2A   0x6069             STR      R1,[R5, #+4]
    720              sig->p = *p;
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x60A8             STR      R0,[R5, #+8]
    721          
    722              *p += len;
   \       0x30   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x34   0x6020             STR      R0,[R4, #+0]
    723          
    724              return 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD76             POP      {R1,R2,R4-R6,PC}
    725          }
    726          
    727          /*
    728           * Get signature algorithm from alg OID and optional parameters
    729           */

   \                                 In section .text, align 2, keep-with-next
    730          int mbedtls_x509_get_sig_alg(const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params,
    731                                       mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg,
    732                                       void **sig_opts)
    733          {
   \                     mbedtls_x509_get_sig_alg: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4611             MOV      R1,R2
   \        0x6   0x9A02             LDR      R2,[SP, #+8]
    734              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    735          
    736              if (*sig_opts != NULL) {
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0xB112             CBZ.N    R2,??mbedtls_x509_get_sig_alg_0
    737                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable58_1
   \       0x10   0xBD10             POP      {R4,PC}
    738              }
    739          
    740              if ((ret = mbedtls_oid_get_sig_alg(sig_oid, md_alg, pk_alg)) != 0) {
   \                     ??mbedtls_x509_get_sig_alg_0: (+1)
   \       0x12   0x461A             MOV      R2,R3
   \       0x14   0x.... 0x....      BL       mbedtls_oid_get_sig_alg
   \       0x18   0xB110             CBZ.N    R0,??mbedtls_x509_get_sig_alg_1
    741                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG, ret);
   \       0x1A   0xF5A0 0x5018      SUB      R0,R0,#+9728
   \       0x1E   0xBD10             POP      {R4,PC}
    742              }
    743          
    744          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
    745              if (*pk_alg == MBEDTLS_PK_RSASSA_PSS) {
    746                  mbedtls_pk_rsassa_pss_options *pss_opts;
    747          
    748                  pss_opts = mbedtls_calloc(1, sizeof(mbedtls_pk_rsassa_pss_options));
    749                  if (pss_opts == NULL) {
    750                      return MBEDTLS_ERR_X509_ALLOC_FAILED;
    751                  }
    752          
    753                  ret = mbedtls_x509_get_rsassa_pss_params(sig_params,
    754                                                           md_alg,
    755                                                           &pss_opts->mgf1_hash_id,
    756                                                           &pss_opts->expected_salt_len);
    757                  if (ret != 0) {
    758                      mbedtls_free(pss_opts);
    759                      return ret;
    760                  }
    761          
    762                  *sig_opts = (void *) pss_opts;
    763              } else
    764          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
    765              {
    766                  /* Make sure parameters are absent or NULL */
    767                  if ((sig_params->tag != MBEDTLS_ASN1_NULL && sig_params->tag != 0) ||
    768                      sig_params->len != 0) {
   \                     ??mbedtls_x509_get_sig_alg_1: (+1)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x2805             CMP      R0,#+5
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2800             CMPNE    R0,#+0
   \       0x28   0xD101             BNE.N    ??mbedtls_x509_get_sig_alg_2
   \       0x2A   0x6860             LDR      R0,[R4, #+4]
   \       0x2C   0xB108             CBZ.N    R0,??mbedtls_x509_get_sig_alg_3
    769                      return MBEDTLS_ERR_X509_INVALID_ALG;
   \                     ??mbedtls_x509_get_sig_alg_2: (+1)
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable60
    770                  }
    771              }
    772          
    773              return 0;
   \                     ??mbedtls_x509_get_sig_alg_3: (+1)
   \       0x32   0xBD10             POP      {R4,PC}
    774          }
    775          
    776          /*
    777           * X.509 Extensions (No parsing of extensions, pointer should
    778           * be either manually updated or extensions should be parsed!)
    779           */

   \                                 In section .text, align 2, keep-with-next
    780          int mbedtls_x509_get_ext(unsigned char **p, const unsigned char *end,
    781                                   mbedtls_x509_buf *ext, int tag)
    782          {
   \                     mbedtls_x509_get_ext: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4615             MOV      R5,R2
    783              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    784              size_t len;
    785          
    786              /* Extension structure use EXPLICIT tagging. That is, the actual
    787               * `Extensions` structure is wrapped by a tag-length pair using
    788               * the respective context-specific tag. */
    789              ret = mbedtls_asn1_get_tag(p, end, &ext->len,
    790                                         MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | tag);
   \        0x4   0xF043 0x06A0      ORR      R6,R3,#0xA0
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x4633             MOV      R3,R6
   \        0xC   0x1D2A             ADDS     R2,R5,#+4
   \        0xE   0x.... 0x....      BL       mbedtls_asn1_get_tag
    791              if (ret != 0) {
   \       0x12   0xB960             CBNZ.N   R0,??mbedtls_x509_get_ext_0
    792                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    793              }
    794          
    795              ext->tag = MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | tag;
   \       0x14   0x602E             STR      R6,[R5, #+0]
    796              ext->p   = *p;
   \       0x16   0x6821             LDR      R1,[R4, #+0]
    797              end      = *p + ext->len;
    798          
    799              /*
    800               * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
    801               */
    802              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    803                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \       0x18   0x2330             MOVS     R3,#+48
   \       0x1A   0x466A             MOV      R2,SP
   \       0x1C   0x60A9             STR      R1,[R5, #+8]
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6869             LDR      R1,[R5, #+4]
   \       0x22   0x1845             ADDS     R5,R0,R1
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x2C   0xB100             CBZ.N    R0,??mbedtls_x509_get_ext_1
    804                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \                     ??mbedtls_x509_get_ext_0: (+1)
   \       0x2E   0x....             B.N      ?Subroutine2
    805              }
    806          
    807              if (end != *p + len) {
   \                     ??mbedtls_x509_get_ext_1: (+1)
   \       0x30   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x34   0x4285             CMP      R5,R0
   \       0x36   0xD000             BEQ.N    ??mbedtls_x509_get_ext_2
    808                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    809                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x38   0x....             B.N      ?Subroutine1
    810              }
    811          
    812              return 0;
   \                     ??mbedtls_x509_get_ext_2: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD76             POP      {R1,R2,R4-R6,PC}
    813          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF5A0 0x5014      SUB      R0,R0,#+9472
   \        0x4   0xBD76             POP      {R1,R2,R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable60_8
   \        0x4   0xBD76             POP      {R1,R2,R4-R6,PC}
    814          

   \                                 In section .text, align 2, keep-with-next
    815          static char nibble_to_hex_digit(int i)
    816          {
    817              return (i < 10) ? (i + '0') : (i - 10 + 'A');
   \                     nibble_to_hex_digit: (+1)
   \        0x0   0x280A             CMP      R0,#+10
   \        0x2   0xBFB4             ITE      LT
   \        0x4   0x3030             ADDLT    R0,R0,#+48
   \        0x6   0x3037             ADDGE    R0,R0,#+55
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x4770             BX       LR
    818          }
    819          
    820          /*
    821           * Store the name in printable form into buf; no more
    822           * than size characters will be written
    823           */

   \                                 In section .text, align 2, keep-with-next
    824          int mbedtls_x509_dn_gets(char *buf, size_t size, const mbedtls_x509_name *dn)
    825          {
   \                     mbedtls_x509_dn_gets: (+1)
   \        0x0   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \        0x4   0xB0C7             SUB      SP,SP,#+284
   \        0x6   0x4607             MOV      R7,R0
    826              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    827              size_t i, j, n, asn1_len_size, asn1_tag_size, asn1_tag_len_buf_start;
    828              /* 6 is enough as our asn1 write functions only write one byte for the tag and at most five bytes for the length*/
    829              unsigned char asn1_tag_len_buf[6];
    830              unsigned char *asn1_len_p;
    831              unsigned char c, merge = 0;
   \        0x8   0x2600             MOVS     R6,#+0
    832              const mbedtls_x509_name *name;
    833              const char *short_name = NULL;
   \        0xA   0x9602             STR      R6,[SP, #+8]
    834              char lowbits, highbits;
    835              char s[MBEDTLS_X509_MAX_DN_NAME_SIZE], *p;
    836              int print_hexstring;
    837          
    838              memset(s, 0, sizeof(s));
   \        0xC   0xF44F 0x7180      MOV      R1,#+256
   \       0x10   0xA807             ADD      R0,SP,#+28
   \       0x12   0x.... 0x....      BL       __aeabi_memclr4
    839          
    840              name = dn;
   \       0x16   0x9948             LDR      R1,[SP, #+288]
    841              p = buf;
    842              n = size;
   \       0x18   0x9D47             LDR      R5,[SP, #+284]
   \       0x1A   0xF10D 0x081C      ADD      R8,SP,#+28
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   \       0x20   0xE001             B.N      ??mbedtls_x509_dn_gets_0
    843          
    844              while (name != NULL) {
    845                  if (!name->oid.p) {
    846                      name = name->next;
   \                     ??mbedtls_x509_dn_gets_1: (+1)
   \       0x22   0x6988             LDR      R0,[R1, #+24]
   \                     ??mbedtls_x509_dn_gets_2: (+1)
   \       0x24   0x9000             STR      R0,[SP, #+0]
    847                      continue;
    848                  }
   \                     ??mbedtls_x509_dn_gets_0: (+1)
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xF000 0x8102      BEQ.W    ??mbedtls_x509_dn_gets_3
   \       0x2E   0x4601             MOV      R1,R0
   \       0x30   0x6888             LDR      R0,[R1, #+8]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD0F5             BEQ.N    ??mbedtls_x509_dn_gets_1
    849          
    850                  if (name != dn) {
   \       0x36   0x9848             LDR      R0,[SP, #+288]
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD00C             BEQ.N    ??mbedtls_x509_dn_gets_4
    851                      ret = mbedtls_snprintf(p, n, merge ? " + " : ", ");
   \       0x3C   0x2E00             CMP      R6,#+0
   \       0x3E   0xBF14             ITE      NE
   \       0x40   0x....             ADRNE.N  R2,??DataTable50
   \       0x42   0x....             ADREQ.N  R2,??DataTable50_1
   \       0x44   0x.... 0x....      BL       ?Subroutine12
    852                      MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD431             BMI.N    ??mbedtls_x509_dn_gets_5
   \       0x4C   0x42A8             CMP      R0,R5
   \       0x4E   0xF080 0x80ED      BCS.W    ??mbedtls_x509_dn_gets_6
   \       0x52   0x1A2D             SUBS     R5,R5,R0
   \       0x54   0x4407             ADD      R7,R7,R0
    853                  }
    854          
    855                  print_hexstring = (name->val.tag != MBEDTLS_ASN1_UTF8_STRING) &&
    856                                    (name->val.tag != MBEDTLS_ASN1_PRINTABLE_STRING) &&
    857                                    (name->val.tag != MBEDTLS_ASN1_IA5_STRING);
   \                     ??mbedtls_x509_dn_gets_4: (+1)
   \       0x56   0x9800             LDR      R0,[SP, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0x280C             CMP      R0,#+12
   \       0x5C   0xBF18             IT       NE
   \       0x5E   0x2813             CMPNE    R0,#+19
   \       0x60   0xD003             BEQ.N    ??mbedtls_x509_dn_gets_7
   \       0x62   0x2816             CMP      R0,#+22
   \       0x64   0xBF18             IT       NE
   \       0x66   0x2401             MOVNE    R4,#+1
   \       0x68   0xD100             BNE.N    ??mbedtls_x509_dn_gets_8
   \                     ??mbedtls_x509_dn_gets_7: (+1)
   \       0x6A   0x2400             MOVS     R4,#+0
    858          
    859                  if ((ret = mbedtls_oid_get_attr_short_name(&name->oid, &short_name)) == 0) {
   \                     ??mbedtls_x509_dn_gets_8: (+1)
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0xA902             ADD      R1,SP,#+8
   \       0x70   0x.... 0x....      BL       mbedtls_oid_get_attr_short_name
   \       0x74   0xB930             CBNZ.N   R0,??mbedtls_x509_dn_gets_9
    860                      ret = mbedtls_snprintf(p, n, "%s=", short_name);
   \       0x76   0x9B02             LDR      R3,[SP, #+8]
   \       0x78   0x....             ADR.N    R2,??DataTable52
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0x4638             MOV      R0,R7
   \       0x7E   0x.... 0x....      BL       snprintf
   \       0x82   0xE014             B.N      ??CrossCallReturnLabel_43
    861                  } else {
    862                      if ((ret = mbedtls_oid_get_numeric_string(p, n, &name->oid)) > 0) {
   \                     ??mbedtls_x509_dn_gets_9: (+1)
   \       0x84   0x9A00             LDR      R2,[SP, #+0]
   \       0x86   0x4629             MOV      R1,R5
   \       0x88   0x4638             MOV      R0,R7
   \       0x8A   0x.... 0x....      BL       mbedtls_oid_get_numeric_string
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xDD06             BLE.N    ??mbedtls_x509_dn_gets_10
    863                          n -= ret;
   \       0x92   0x1A2D             SUBS     R5,R5,R0
    864                          p += ret;
   \       0x94   0x4407             ADD      R7,R7,R0
    865                          ret = mbedtls_snprintf(p, n, "=");
   \       0x96   0x....             ADR.N    R2,??DataTable52_1
   \       0x98   0x.... 0x....      BL       ?Subroutine12
    866                          print_hexstring = 1;
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x9C   0x2401             MOVS     R4,#+1
   \       0x9E   0xE006             B.N      ??CrossCallReturnLabel_43
    867                      } else if (ret == MBEDTLS_ERR_OID_BUF_TOO_SMALL) {
   \                     ??mbedtls_x509_dn_gets_10: (+1)
   \       0xA0   0xF110 0x0F0B      CMN      R0,#+11
   \       0xA4   0xF000 0x80C2      BEQ.W    ??mbedtls_x509_dn_gets_6
    868                          return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
    869                      } else {
    870                          ret = mbedtls_snprintf(p, n, "\?\?=");
   \       0xA8   0x....             ADR.N    R2,??DataTable52_2
   \       0xAA   0x.... 0x....      BL       ?Subroutine12
    871                      }
    872                  }
    873                  MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0xAE   0x2800             CMP      R0,#+0
   \                     ??mbedtls_x509_dn_gets_5: (+1)
   \       0xB0   0xF100 0x80BC      BMI.W    ??mbedtls_x509_dn_gets_6
   \       0xB4   0x42A8             CMP      R0,R5
   \       0xB6   0xD24C             BCS.N    ??mbedtls_x509_dn_gets_11
   \       0xB8   0x1A2D             SUBS     R5,R5,R0
   \       0xBA   0x1839             ADDS     R1,R7,R0
   \       0xBC   0x9505             STR      R5,[SP, #+20]
   \       0xBE   0x9106             STR      R1,[SP, #+24]
    874          
    875                  if (print_hexstring) {
   \       0xC0   0x2C00             CMP      R4,#+0
   \       0xC2   0xD059             BEQ.N    ??mbedtls_x509_dn_gets_12
    876                      s[0] = '#';
    877          
    878                      asn1_len_p = asn1_tag_len_buf + sizeof(asn1_tag_len_buf);
    879                      if ((ret = mbedtls_asn1_write_len(&asn1_len_p, asn1_tag_len_buf, name->val.len)) < 0) {
   \       0xC4   0x9800             LDR      R0,[SP, #+0]
   \       0xC6   0x2223             MOVS     R2,#+35
   \       0xC8   0xF10D 0x0112      ADD      R1,SP,#+18
   \       0xCC   0xF88D 0x201C      STRB     R2,[SP, #+28]
   \       0xD0   0x9101             STR      R1,[SP, #+4]
   \       0xD2   0x6902             LDR      R2,[R0, #+16]
   \       0xD4   0xA903             ADD      R1,SP,#+12
   \       0xD6   0xA801             ADD      R0,SP,#+4
   \       0xD8   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0xDC   0x0004             MOVS     R4,R0
   \       0xDE   0xD410             BMI.N    ??mbedtls_x509_dn_gets_13
    880                          return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    881                      }
    882                      asn1_len_size = ret;
    883                      if ((ret = mbedtls_asn1_write_tag(&asn1_len_p, asn1_tag_len_buf, name->val.tag)) < 0) {
   \       0xE0   0x9800             LDR      R0,[SP, #+0]
   \       0xE2   0x68C1             LDR      R1,[R0, #+12]
   \       0xE4   0xA801             ADD      R0,SP,#+4
   \       0xE6   0xB2CA             UXTB     R2,R1
   \       0xE8   0xA903             ADD      R1,SP,#+12
   \       0xEA   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0xEE   0x4606             MOV      R6,R0
   \       0xF0   0x2E00             CMP      R6,#+0
   \       0xF2   0xD406             BMI.N    ??mbedtls_x509_dn_gets_13
    884                          return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    885                      }
    886                      asn1_tag_size = ret;
    887                      asn1_tag_len_buf_start = sizeof(asn1_tag_len_buf) - asn1_len_size - asn1_tag_size;
   \       0xF4   0xF1C4 0x0706      RSB      R7,R4,#+6
   \       0xF8   0x1BBF             SUBS     R7,R7,R6
    888                      for (i = 0, j = 1; i < asn1_len_size + asn1_tag_size; i++) {
   \       0xFA   0xF04F 0x0900      MOV      R9,#+0
   \       0xFE   0x2501             MOVS     R5,#+1
   \      0x100   0xE01C             B.N      ??mbedtls_x509_dn_gets_14
   \                     ??mbedtls_x509_dn_gets_13: (+1)
   \      0x102   0xF06F 0x006D      MVN      R0,#+109
   \      0x106   0xE096             B.N      ??mbedtls_x509_dn_gets_15
    889                          if (j + 1 >= sizeof(s) - 1) {
   \                     ??mbedtls_x509_dn_gets_16: (+1)
   \      0x108   0xF105 0x0B01      ADD      R11,R5,#+1
   \      0x10C   0xF1BB 0x0FFF      CMP      R11,#+255
   \      0x110   0xD21F             BCS.N    ??mbedtls_x509_dn_gets_11
    890                              return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
    891                          }
    892                          c = asn1_tag_len_buf[asn1_tag_len_buf_start+i];
   \      0x112   0xA903             ADD      R1,SP,#+12
   \      0x114   0xEB09 0x0007      ADD      R0,R9,R7
   \      0x118   0xF811 0xA000      LDRB     R10,[R1, R0]
    893                          lowbits = (c & 0x0F);
    894                          highbits = c >> 4;
    895                          s[j++] = nibble_to_hex_digit(highbits);
   \      0x11C   0xF109 0x0901      ADD      R9,R9,#+1
   \      0x120   0xEA4F 0x101A      LSR      R0,R10,#+4
   \      0x124   0x.... 0x....      BL       nibble_to_hex_digit
   \      0x128   0xF808 0x0005      STRB     R0,[R8, R5]
    896                          s[j++] = nibble_to_hex_digit(lowbits);
   \      0x12C   0xF00A 0x000F      AND      R0,R10,#0xF
   \      0x130   0x.... 0x....      BL       nibble_to_hex_digit
   \      0x134   0xF808 0x000B      STRB     R0,[R8, R11]
   \      0x138   0xF10B 0x0501      ADD      R5,R11,#+1
    897                      }
   \                     ??mbedtls_x509_dn_gets_14: (+1)
   \      0x13C   0x1930             ADDS     R0,R6,R4
   \      0x13E   0x4581             CMP      R9,R0
   \      0x140   0xD3E2             BCC.N    ??mbedtls_x509_dn_gets_16
    898                      for (i = 0; i < name->val.len; i++) {
   \      0x142   0x2600             MOVS     R6,#+0
   \      0x144   0x9C00             LDR      R4,[SP, #+0]
   \      0x146   0x462F             MOV      R7,R5
   \                     ??mbedtls_x509_dn_gets_17: (+1)
   \      0x148   0x6920             LDR      R0,[R4, #+16]
   \      0x14A   0x4286             CMP      R6,R0
   \      0x14C   0xD25A             BCS.N    ??mbedtls_x509_dn_gets_18
    899                          if (j + 1 >= sizeof(s) - 1) {
   \      0x14E   0x1C7D             ADDS     R5,R7,#+1
   \      0x150   0x2DFF             CMP      R5,#+255
   \                     ??mbedtls_x509_dn_gets_11: (+1)
   \      0x152   0xD26B             BCS.N    ??mbedtls_x509_dn_gets_6
    900                              return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
    901                          }
    902                          c = name->val.p[i];
   \      0x154   0x6960             LDR      R0,[R4, #+20]
   \      0x156   0xF810 0x9006      LDRB     R9,[R0, R6]
    903                          lowbits = (c & 0x0F);
    904                          highbits = c >> 4;
    905                          s[j++] = nibble_to_hex_digit(highbits);
   \      0x15A   0x1C76             ADDS     R6,R6,#+1
   \      0x15C   0xEA4F 0x1019      LSR      R0,R9,#+4
   \      0x160   0x.... 0x....      BL       nibble_to_hex_digit
   \      0x164   0xF808 0x0007      STRB     R0,[R8, R7]
    906                          s[j++] = nibble_to_hex_digit(lowbits);
   \      0x168   0xF009 0x000F      AND      R0,R9,#0xF
   \      0x16C   0x.... 0x....      BL       nibble_to_hex_digit
   \      0x170   0xF808 0x0005      STRB     R0,[R8, R5]
   \      0x174   0x1C6F             ADDS     R7,R5,#+1
    907                      }
   \      0x176   0xE7E7             B.N      ??mbedtls_x509_dn_gets_17
    908                  } else {
    909                      for (i = 0, j = 0; i < name->val.len; i++, j++) {
   \                     ??mbedtls_x509_dn_gets_12: (+1)
   \      0x178   0x2700             MOVS     R7,#+0
   \      0x17A   0x9E00             LDR      R6,[SP, #+0]
   \      0x17C   0xE034             B.N      ??mbedtls_x509_dn_gets_19
    910                          if (j >= sizeof(s) - 1) {
    911                              return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
    912                          }
    913          
    914                          c = name->val.p[i];
    915                          // Special characters requiring escaping, RFC 4514 Section 2.4
    916                          if (c == '\0') {
    917                              return MBEDTLS_ERR_X509_INVALID_NAME;
    918                          } else {
    919                              if (strchr(",=+<>;\"\\", c) ||
    920                                  ((i == 0) && strchr("# ", c)) ||
    921                                  ((i == name->val.len-1) && (c == ' '))) {
    922                                  if (j + 1 >= sizeof(s) - 1) {
    923                                      return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
    924                                  }
    925                                  s[j++] = '\\';
    926                              }
    927                          }
    928                          if (c < 32 || c >= 127) {
    929                              if (j + 3 >= sizeof(s) - 1) {
    930                                  return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
    931                              }
    932                              s[j++] = '\\';
    933                              lowbits = (c & 0x0F);
    934                              highbits = c >> 4;
    935                              s[j++] = nibble_to_hex_digit(highbits);
    936                              s[j] = nibble_to_hex_digit(lowbits);
    937                          } else {
    938                              s[j] = c;
   \                     ??mbedtls_x509_dn_gets_20: (+1)
   \      0x17E   0xF808 0x5007      STRB     R5,[R8, R7]
   \      0x182   0xE02F             B.N      ??mbedtls_x509_dn_gets_21
    939                          }
   \                     ??mbedtls_x509_dn_gets_22: (+1)
   \      0x184   0x4629             MOV      R1,R5
   \      0x186   0x.... 0x....      ADR.W    R0,?_10
   \      0x18A   0xF104 0x0901      ADD      R9,R4,#+1
   \      0x18E   0x.... 0x....      BL       strchr
   \      0x192   0xB948             CBNZ.N   R0,??mbedtls_x509_dn_gets_23
   \      0x194   0xB924             CBNZ.N   R4,??mbedtls_x509_dn_gets_24
   \      0x196   0x4629             MOV      R1,R5
   \      0x198   0x....             ADR.N    R0,??DataTable53
   \      0x19A   0x.... 0x....      BL       strchr
   \      0x19E   0xB918             CBNZ.N   R0,??mbedtls_x509_dn_gets_23
   \                     ??mbedtls_x509_dn_gets_24: (+1)
   \      0x1A0   0x45D1             CMP      R9,R10
   \      0x1A2   0xBF08             IT       EQ
   \      0x1A4   0x2D20             CMPEQ    R5,#+32
   \      0x1A6   0xD106             BNE.N    ??mbedtls_x509_dn_gets_25
   \                     ??mbedtls_x509_dn_gets_23: (+1)
   \      0x1A8   0x1C78             ADDS     R0,R7,#+1
   \      0x1AA   0x28FF             CMP      R0,#+255
   \      0x1AC   0xD23E             BCS.N    ??mbedtls_x509_dn_gets_6
   \      0x1AE   0x215C             MOVS     R1,#+92
   \      0x1B0   0xF808 0x1007      STRB     R1,[R8, R7]
   \      0x1B4   0x4607             MOV      R7,R0
   \                     ??mbedtls_x509_dn_gets_25: (+1)
   \      0x1B6   0xF1A5 0x0020      SUB      R0,R5,#+32
   \      0x1BA   0x285F             CMP      R0,#+95
   \      0x1BC   0xD3DF             BCC.N    ??mbedtls_x509_dn_gets_20
   \      0x1BE   0x1CF9             ADDS     R1,R7,#+3
   \      0x1C0   0x29FF             CMP      R1,#+255
   \      0x1C2   0xD233             BCS.N    ??mbedtls_x509_dn_gets_6
   \      0x1C4   0x205C             MOVS     R0,#+92
   \      0x1C6   0xF808 0x0007      STRB     R0,[R8, R7]
   \      0x1CA   0x0928             LSRS     R0,R5,#+4
   \      0x1CC   0x1C7F             ADDS     R7,R7,#+1
   \      0x1CE   0x.... 0x....      BL       nibble_to_hex_digit
   \      0x1D2   0xF808 0x0007      STRB     R0,[R8, R7]
   \      0x1D6   0xF005 0x000F      AND      R0,R5,#0xF
   \      0x1DA   0x1C7F             ADDS     R7,R7,#+1
   \      0x1DC   0x.... 0x....      BL       nibble_to_hex_digit
   \      0x1E0   0xF808 0x0007      STRB     R0,[R8, R7]
   \                     ??mbedtls_x509_dn_gets_21: (+1)
   \      0x1E4   0x464C             MOV      R4,R9
   \      0x1E6   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_x509_dn_gets_19: (+1)
   \      0x1E8   0xF8D6 0xA010      LDR      R10,[R6, #+16]
   \      0x1EC   0x4554             CMP      R4,R10
   \      0x1EE   0xD208             BCS.N    ??mbedtls_x509_dn_gets_26
   \      0x1F0   0x2FFF             CMP      R7,#+255
   \      0x1F2   0xD21B             BCS.N    ??mbedtls_x509_dn_gets_6
   \      0x1F4   0x6970             LDR      R0,[R6, #+20]
   \      0x1F6   0x5D05             LDRB     R5,[R0, R4]
   \      0x1F8   0x2D00             CMP      R5,#+0
   \      0x1FA   0xD1C3             BNE.N    ??mbedtls_x509_dn_gets_22
   \      0x1FC   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \      0x200   0xE019             B.N      ??mbedtls_x509_dn_gets_15
    940                      }
    941                  }
   \                     ??mbedtls_x509_dn_gets_26: (+1)
   \      0x202   0x4634             MOV      R4,R6
    942                  s[j] = '\0';
   \                     ??mbedtls_x509_dn_gets_18: (+1)
   \      0x204   0x2000             MOVS     R0,#+0
   \      0x206   0xA907             ADD      R1,SP,#+28
   \      0x208   0x55C8             STRB     R0,[R1, R7]
    943                  ret = mbedtls_snprintf(p, n, "%s", s);
   \      0x20A   0x9905             LDR      R1,[SP, #+20]
   \      0x20C   0x9806             LDR      R0,[SP, #+24]
   \      0x20E   0xAB07             ADD      R3,SP,#+28
   \      0x210   0x....             ADR.N    R2,??DataTable55
   \      0x212   0x.... 0x....      BL       snprintf
    944                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x216   0x2800             CMP      R0,#+0
   \      0x218   0xD408             BMI.N    ??mbedtls_x509_dn_gets_6
   \      0x21A   0x9905             LDR      R1,[SP, #+20]
   \      0x21C   0x4288             CMP      R0,R1
   \      0x21E   0xD205             BCS.N    ??mbedtls_x509_dn_gets_6
   \      0x220   0x1A0D             SUBS     R5,R1,R0
   \      0x222   0x9906             LDR      R1,[SP, #+24]
    945          
    946                  merge = name->next_merged;
   \      0x224   0x7F26             LDRB     R6,[R4, #+28]
   \      0x226   0x180F             ADDS     R7,R1,R0
    947                  name = name->next;
   \      0x228   0x69A0             LDR      R0,[R4, #+24]
   \      0x22A   0xE6FB             B.N      ??mbedtls_x509_dn_gets_2
   \                     ??mbedtls_x509_dn_gets_6: (+1)
   \      0x22C   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \      0x230   0xE001             B.N      ??mbedtls_x509_dn_gets_15
    948              }
    949          
    950              return (int) (size - n);
   \                     ??mbedtls_x509_dn_gets_3: (+1)
   \      0x232   0x9847             LDR      R0,[SP, #+284]
   \      0x234   0x1B40             SUBS     R0,R0,R5
   \                     ??mbedtls_x509_dn_gets_15: (+1)
   \      0x236   0xB049             ADD      SP,SP,#+292
   \      0x238   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    951          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4629             MOV      R1,R5
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      snprintf
    952          
    953          /*
    954           * Store the serial in printable form into buf; no more
    955           * than size characters will be written
    956           */

   \                                 In section .text, align 2, keep-with-next
    957          int mbedtls_x509_serial_gets(char *buf, size_t size, const mbedtls_x509_buf *serial)
    958          {
   \                     mbedtls_x509_serial_gets: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4616             MOV      R6,R2
    959              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    960              size_t i, n, nr;
    961              char *p;
    962          
    963              p = buf;
    964              n = size;
    965          
    966              nr = (serial->len <= 32)
    967                  ? serial->len  : 28;
   \        0x6   0x6877             LDR      R7,[R6, #+4]
   \        0x8   0x468B             MOV      R11,R1
   \        0xA   0x4682             MOV      R10,R0
   \        0xC   0x465D             MOV      R5,R11
   \        0xE   0x2F21             CMP      R7,#+33
   \       0x10   0xBF28             IT       CS
   \       0x12   0x271C             MOVCS    R7,#+28
    968          
    969              for (i = 0; i < nr; i++) {
   \       0x14   0x2400             MOVS     R4,#+0
   \       0x16   0x.... 0x....      ADR.W    R9,??DataTable55_1
   \       0x1A   0x.... 0x....      ADR.W    R8,??DataTable55_2
   \       0x1E   0xE01A             B.N      ??mbedtls_x509_serial_gets_0
    970                  if (i == 0 && nr > 1 && serial->p[i] == 0x0) {
   \                     ??mbedtls_x509_serial_gets_1: (+1)
   \       0x20   0xB924             CBNZ.N   R4,??mbedtls_x509_serial_gets_2
   \       0x22   0x2F01             CMP      R7,#+1
   \       0x24   0xD902             BLS.N    ??mbedtls_x509_serial_gets_2
   \       0x26   0x68B1             LDR      R1,[R6, #+8]
   \       0x28   0x7808             LDRB     R0,[R1, #+0]
   \       0x2A   0xB198             CBZ.N    R0,??mbedtls_x509_serial_gets_3
    971                      continue;
    972                  }
    973          
    974                  ret = mbedtls_snprintf(p, n, "%02X%s",
    975                                         serial->p[i], (i < nr - 1) ? ":" : "");
   \                     ??mbedtls_x509_serial_gets_2: (+1)
   \       0x2C   0x1E79             SUBS     R1,R7,#+1
   \       0x2E   0x428C             CMP      R4,R1
   \       0x30   0xBF2C             ITE      CS
   \       0x32   0x4648             MOVCS    R0,R9
   \       0x34   0x4640             MOVCC    R0,R8
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x68B0             LDR      R0,[R6, #+8]
   \       0x3A   0x.... 0x....      ADR.W    R2,?_13
   \       0x3E   0x4629             MOV      R1,R5
   \       0x40   0x5D03             LDRB     R3,[R0, R4]
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       snprintf
    976                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD418             BMI.N    ??mbedtls_x509_serial_gets_4
   \       0x4C   0x42A8             CMP      R0,R5
   \       0x4E   0xD216             BCS.N    ??mbedtls_x509_serial_gets_4
   \       0x50   0x1A2D             SUBS     R5,R5,R0
   \       0x52   0x4482             ADD      R10,R10,R0
    977              }
   \                     ??mbedtls_x509_serial_gets_3: (+1)
   \       0x54   0x1C64             ADDS     R4,R4,#+1
   \                     ??mbedtls_x509_serial_gets_0: (+1)
   \       0x56   0x42BC             CMP      R4,R7
   \       0x58   0xD3E2             BCC.N    ??mbedtls_x509_serial_gets_1
    978          
    979              if (nr != serial->len) {
   \       0x5A   0x6871             LDR      R1,[R6, #+4]
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0x428F             CMP      R7,R1
   \       0x60   0xD009             BEQ.N    ??mbedtls_x509_serial_gets_5
    980                  ret = mbedtls_snprintf(p, n, "....");
   \       0x62   0x.... 0x....      ADR.W    R2,?_16
   \       0x66   0x4629             MOV      R1,R5
   \       0x68   0x.... 0x....      BL       snprintf
    981                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD406             BMI.N    ??mbedtls_x509_serial_gets_4
   \       0x70   0x42A8             CMP      R0,R5
   \       0x72   0xD204             BCS.N    ??mbedtls_x509_serial_gets_4
   \       0x74   0x1A2D             SUBS     R5,R5,R0
    982              }
    983          
    984              return (int) (size - n);
   \                     ??mbedtls_x509_serial_gets_5: (+1)
   \       0x76   0xEBAB 0x0005      SUB      R0,R11,R5
   \                     ??mbedtls_x509_serial_gets_6: (+1)
   \       0x7A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   \                     ??mbedtls_x509_serial_gets_4: (+1)
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \       0x82   0xE7FA             B.N      ??mbedtls_x509_serial_gets_6
    985          }
    986          
    987          #if !defined(MBEDTLS_X509_REMOVE_INFO)
    988          /*
    989           * Helper for writing signature algorithms
    990           */

   \                                 In section .text, align 2, keep-with-next
    991          int mbedtls_x509_sig_alg_gets(char *buf, size_t size, const mbedtls_x509_buf *sig_oid,
    992                                        mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg,
    993                                        const void *sig_opts)
    994          {
   \                     mbedtls_x509_sig_alg_gets: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    995              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    996              char *p = buf;
    997              size_t n = size;
    998              const char *desc = NULL;
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x9300             STR      R3,[SP, #+0]
    999          
   1000              ret = mbedtls_oid_get_sig_alg_desc(sig_oid, &desc);
   1001              if (ret != 0) {
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x4610             MOV      R0,R2
   \        0xE   0x.... 0x....      BL       mbedtls_oid_get_sig_alg_desc
   \       0x12   0xB128             CBZ.N    R0,??mbedtls_x509_sig_alg_gets_0
   1002                  ret = mbedtls_snprintf(p, n, "???");
   \       0x14   0x....             ADR.N    R2,??DataTable55_3
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x.... 0x....      BL       snprintf
   \       0x1E   0xE005             B.N      ??mbedtls_x509_sig_alg_gets_1
   1003              } else {
   1004                  ret = mbedtls_snprintf(p, n, "%s", desc);
   \                     ??mbedtls_x509_sig_alg_gets_0: (+1)
   \       0x20   0x9B00             LDR      R3,[SP, #+0]
   \       0x22   0x....             ADR.N    R2,??DataTable55
   \       0x24   0x4621             MOV      R1,R4
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       snprintf
   1005              }
   1006              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??mbedtls_x509_sig_alg_gets_1: (+1)
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD401             BMI.N    ??mbedtls_x509_sig_alg_gets_2
   \       0x30   0x42A0             CMP      R0,R4
   \       0x32   0xD301             BCC.N    ??mbedtls_x509_sig_alg_gets_3
   \                     ??mbedtls_x509_sig_alg_gets_2: (+1)
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable60_2
   1007          
   1008          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   1009              if (pk_alg == MBEDTLS_PK_RSASSA_PSS) {
   1010                  const mbedtls_pk_rsassa_pss_options *pss_opts;
   1011          
   1012                  pss_opts = (const mbedtls_pk_rsassa_pss_options *) sig_opts;
   1013          
   1014                  const char *name = md_type_to_string(md_alg);
   1015                  const char *mgf_name = md_type_to_string(pss_opts->mgf1_hash_id);
   1016          
   1017                  ret = mbedtls_snprintf(p, n, " (%s, MGF1-%s, 0x%02X)",
   1018                                         name ? name : "???",
   1019                                         mgf_name ? mgf_name : "???",
   1020                                         (unsigned int) pss_opts->expected_salt_len);
   1021                  MBEDTLS_X509_SAFE_SNPRINTF;
   1022              }
   1023          #else
   1024              ((void) pk_alg);
   1025              ((void) md_alg);
   1026              ((void) sig_opts);
   1027          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
   1028          
   1029              return (int) (size - n);
   \                     ??mbedtls_x509_sig_alg_gets_3: (+1)
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
   1030          }
   1031          #endif /* MBEDTLS_X509_REMOVE_INFO */
   1032          
   1033          /*
   1034           * Helper for writing "RSA key size", "EC key size", etc
   1035           */

   \                                 In section .text, align 2, keep-with-next
   1036          int mbedtls_x509_key_size_helper(char *buf, size_t buf_size, const char *name)
   1037          {
   \                     mbedtls_x509_key_size_helper: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4613             MOV      R3,R2
   \        0x4   0x460C             MOV      R4,R1
   1038              char *p = buf;
   1039              size_t n = buf_size;
   1040              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1041          
   1042              ret = mbedtls_snprintf(p, n, "%s key size", name);
   \        0x6   0x.... 0x....      ADR.W    R2,?_18
   \        0xA   0x.... 0x....      BL       snprintf
   1043              MBEDTLS_X509_SAFE_SNPRINTF;
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD401             BMI.N    ??mbedtls_x509_key_size_helper_0
   \       0x12   0x42A0             CMP      R0,R4
   \       0x14   0xD302             BCC.N    ??mbedtls_x509_key_size_helper_1
   \                     ??mbedtls_x509_key_size_helper_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \       0x1A   0xBD10             POP      {R4,PC}
   1044          
   1045              return 0;
   \                     ??mbedtls_x509_key_size_helper_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}
   1046          }
   1047          

   \                                 In section .text, align 2, keep-with-next
   1048          int mbedtls_x509_time_cmp(const mbedtls_x509_time *t1,
   1049                                    const mbedtls_x509_time *t2)
   1050          {
   \                     mbedtls_x509_time_cmp: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4602             MOV      R2,R0
   1051              int x;
   1052          
   1053              x = (((t1->year << 9) | (t1->mon << 5) | (t1->day)) -
   1054                   ((t2->year << 9) | (t2->mon << 5) | (t2->day)));
   \        0x4   0x6853             LDR      R3,[R2, #+4]
   \        0x6   0x6810             LDR      R0,[R2, #+0]
   \        0x8   0x684C             LDR      R4,[R1, #+4]
   \        0xA   0x015B             LSLS     R3,R3,#+5
   \        0xC   0xEA43 0x2340      ORR      R3,R3,R0, LSL #+9
   \       0x10   0x6890             LDR      R0,[R2, #+8]
   \       0x12   0x0164             LSLS     R4,R4,#+5
   \       0x14   0x4318             ORRS     R0,R0,R3
   \       0x16   0x680B             LDR      R3,[R1, #+0]
   \       0x18   0xEA44 0x2443      ORR      R4,R4,R3, LSL #+9
   \       0x1C   0x688B             LDR      R3,[R1, #+8]
   \       0x1E   0x431C             ORRS     R4,R3,R4
   \       0x20   0x1B00             SUBS     R0,R0,R4
   1055              if (x != 0) {
   \       0x22   0xD10E             BNE.N    ??mbedtls_x509_time_cmp_0
   1056                  return x;
   1057              }
   1058          
   1059              x = (((t1->hour << 12) | (t1->min << 6) | (t1->sec)) -
   1060                   ((t2->hour << 12) | (t2->min << 6) | (t2->sec)));
   1061              return x;
   \       0x24   0x6910             LDR      R0,[R2, #+16]
   \       0x26   0x68D3             LDR      R3,[R2, #+12]
   \       0x28   0x6952             LDR      R2,[R2, #+20]
   \       0x2A   0x0180             LSLS     R0,R0,#+6
   \       0x2C   0xEA40 0x3003      ORR      R0,R0,R3, LSL #+12
   \       0x30   0x68CB             LDR      R3,[R1, #+12]
   \       0x32   0x4310             ORRS     R0,R2,R0
   \       0x34   0x690A             LDR      R2,[R1, #+16]
   \       0x36   0x6949             LDR      R1,[R1, #+20]
   \       0x38   0x0192             LSLS     R2,R2,#+6
   \       0x3A   0xEA42 0x3203      ORR      R2,R2,R3, LSL #+12
   \       0x3E   0x430A             ORRS     R2,R1,R2
   \       0x40   0x1A80             SUBS     R0,R0,R2
   \                     ??mbedtls_x509_time_cmp_0: (+1)
   \       0x42   0xBD10             POP      {R4,PC}
   1062          }
   1063          
   1064          #if defined(MBEDTLS_HAVE_TIME_DATE)
   1065          int mbedtls_x509_time_gmtime(mbedtls_time_t tt, mbedtls_x509_time *now)
   1066          {
   1067              struct tm tm;
   1068          
   1069              if (mbedtls_platform_gmtime_r(&tt, &tm) == NULL) {
   1070                  return -1;
   1071              }
   1072          
   1073              now->year = tm.tm_year + 1900;
   1074              now->mon  = tm.tm_mon  + 1;
   1075              now->day  = tm.tm_mday;
   1076              now->hour = tm.tm_hour;
   1077              now->min  = tm.tm_min;
   1078              now->sec  = tm.tm_sec;
   1079              return 0;
   1080          }
   1081          
   1082          static int x509_get_current_time(mbedtls_x509_time *now)
   1083          {
   1084              return mbedtls_x509_time_gmtime(mbedtls_time(NULL), now);
   1085          }
   1086          
   1087          int mbedtls_x509_time_is_past(const mbedtls_x509_time *to)
   1088          {
   1089              mbedtls_x509_time now;
   1090          
   1091              if (x509_get_current_time(&now) != 0) {
   1092                  return 1;
   1093              }
   1094          
   1095              return mbedtls_x509_time_cmp(to, &now) < 0;
   1096          }
   1097          
   1098          int mbedtls_x509_time_is_future(const mbedtls_x509_time *from)
   1099          {
   1100              mbedtls_x509_time now;
   1101          
   1102              if (x509_get_current_time(&now) != 0) {
   1103                  return 1;
   1104              }
   1105          
   1106              return mbedtls_x509_time_cmp(from, &now) > 0;
   1107          }
   1108          
   1109          #else  /* MBEDTLS_HAVE_TIME_DATE */
   1110          

   \                                 In section .text, align 2, keep-with-next
   1111          int mbedtls_x509_time_is_past(const mbedtls_x509_time *to)
   1112          {
   1113              ((void) to);
   1114              return 0;
   \                     mbedtls_x509_time_is_past: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
   1115          }
   1116          

   \                                 In section .text, align 2, keep-with-next
   1117          int mbedtls_x509_time_is_future(const mbedtls_x509_time *from)
   1118          {
   1119              ((void) from);
   1120              return 0;
   \                     mbedtls_x509_time_is_future: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
   1121          }
   1122          #endif /* MBEDTLS_HAVE_TIME_DATE */
   1123          
   1124          /* Common functions for parsing CRT and CSR. */
   1125          #if defined(MBEDTLS_X509_CRT_PARSE_C) || defined(MBEDTLS_X509_CSR_PARSE_C)
   1126          /*
   1127           * OtherName ::= SEQUENCE {
   1128           *      type-id    OBJECT IDENTIFIER,
   1129           *      value      [0] EXPLICIT ANY DEFINED BY type-id }
   1130           *
   1131           * HardwareModuleName ::= SEQUENCE {
   1132           *                           hwType OBJECT IDENTIFIER,
   1133           *                           hwSerialNum OCTET STRING }
   1134           *
   1135           * NOTE: we currently only parse and use otherName of type HwModuleName,
   1136           * as defined in RFC 4108.
   1137           */
   1138          static int x509_get_other_name(const mbedtls_x509_buf *subject_alt_name,
   1139                                         mbedtls_x509_san_other_name *other_name)
   1140          {
   1141              int ret = 0;
   1142              size_t len;
   1143              unsigned char *p = subject_alt_name->p;
   1144              const unsigned char *end = p + subject_alt_name->len;
   1145              mbedtls_x509_buf cur_oid;
   1146          
   1147              if ((subject_alt_name->tag &
   1148                   (MBEDTLS_ASN1_TAG_CLASS_MASK | MBEDTLS_ASN1_TAG_VALUE_MASK)) !=
   1149                  (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_OTHER_NAME)) {
   1150                  /*
   1151                   * The given subject alternative name is not of type "othername".
   1152                   */
   1153                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1154              }
   1155          
   1156              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1157                                              MBEDTLS_ASN1_OID)) != 0) {
   1158                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   1159              }
   1160          
   1161              cur_oid.tag = MBEDTLS_ASN1_OID;
   1162              cur_oid.p = p;
   1163              cur_oid.len = len;
   1164          
   1165              /*
   1166               * Only HwModuleName is currently supported.
   1167               */
   1168              if (MBEDTLS_OID_CMP(MBEDTLS_OID_ON_HW_MODULE_NAME, &cur_oid) != 0) {
   1169                  return MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
   1170              }
   1171              other_name->type_id = cur_oid;
   1172          
   1173              p += len;
   1174              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1175                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_CONTEXT_SPECIFIC)) !=
   1176                  0) {
   1177                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   1178              }
   1179          
   1180              if (end != p + len) {
   1181                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1182                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1183              }
   1184          
   1185              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1186                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   1187                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   1188              }
   1189          
   1190              if (end != p + len) {
   1191                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1192                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1193              }
   1194          
   1195              if ((ret = mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_OID)) != 0) {
   1196                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   1197              }
   1198          
   1199              other_name->value.hardware_module_name.oid.tag = MBEDTLS_ASN1_OID;
   1200              other_name->value.hardware_module_name.oid.p = p;
   1201              other_name->value.hardware_module_name.oid.len = len;
   1202          
   1203              p += len;
   1204              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1205                                              MBEDTLS_ASN1_OCTET_STRING)) != 0) {
   1206                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   1207              }
   1208          
   1209              other_name->value.hardware_module_name.val.tag = MBEDTLS_ASN1_OCTET_STRING;
   1210              other_name->value.hardware_module_name.val.p = p;
   1211              other_name->value.hardware_module_name.val.len = len;
   1212              p += len;
   1213              if (p != end) {
   1214                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1215                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1216              }
   1217              return 0;
   1218          }
   1219          
   1220          /* Check mbedtls_x509_get_subject_alt_name for detailed description.
   1221           *
   1222           * In some cases while parsing subject alternative names the sequence tag is optional
   1223           * (e.g. CertSerialNumber). This function is designed to handle such case.
   1224           */

   \                                 In section .text, align 2, keep-with-next
   1225          int mbedtls_x509_get_subject_alt_name_ext(unsigned char **p,
   1226                                                    const unsigned char *end,
   1227                                                    mbedtls_x509_sequence *subject_alt_name)
   1228          {
   \                     mbedtls_x509_get_subject_alt_name_ext: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4617             MOV      R7,R2
   \        0x6   0xB08E             SUB      SP,SP,#+56
   \        0x8   0x4606             MOV      R6,R0
   \        0xA   0x4688             MOV      R8,R1
   1229              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1230              size_t tag_len;
   1231              mbedtls_asn1_sequence *cur = subject_alt_name;
   \        0xC   0x463C             MOV      R4,R7
   \        0xE   0xE028             B.N      ??mbedtls_x509_get_subject_alt_name_ext_0
   1232          
   1233              while (*p < end) {
   1234                  mbedtls_x509_subject_alternative_name tmp_san_name;
   1235                  mbedtls_x509_buf tmp_san_buf;
   1236                  memset(&tmp_san_name, 0, sizeof(tmp_san_name));
   1237          
   1238                  tmp_san_buf.tag = **p;
   1239                  (*p)++;
   1240          
   1241                  if ((ret = mbedtls_asn1_get_len(p, end, &tag_len)) != 0) {
   1242                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   1243                  }
   1244          
   1245                  tmp_san_buf.p = *p;
   \                     ??mbedtls_x509_get_subject_alt_name_ext_1: (+1)
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0x9003             STR      R0,[SP, #+12]
   1246                  tmp_san_buf.len = tag_len;
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0x9002             STR      R0,[SP, #+8]
   1247          
   1248                  if ((tmp_san_buf.tag & MBEDTLS_ASN1_TAG_CLASS_MASK) !=
   1249                      MBEDTLS_ASN1_CONTEXT_SPECIFIC) {
   \       0x18   0x9801             LDR      R0,[SP, #+4]
   \       0x1A   0xF000 0x00C0      AND      R0,R0,#0xC0
   \       0x1E   0x2880             CMP      R0,#+128
   \       0x20   0xD134             BNE.N    ??mbedtls_x509_get_subject_alt_name_ext_2
   1250                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1251                                               MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
   1252                  }
   1253          
   1254                  /*
   1255                   * Check that the SAN is structured correctly by parsing it.
   1256                   * The SAN structure is discarded afterwards.
   1257                   */
   1258                  ret = mbedtls_x509_parse_subject_alt_name(&tmp_san_buf, &tmp_san_name);
   \       0x22   0xA904             ADD      R1,SP,#+16
   \       0x24   0xA801             ADD      R0,SP,#+4
   \       0x26   0x.... 0x....      BL       mbedtls_x509_parse_subject_alt_name
   \       0x2A   0x0005             MOVS     R5,R0
   1259                  /*
   1260                   * In case the extension is malformed, return an error,
   1261                   * and clear the allocated sequences.
   1262                   */
   1263                  if (ret != 0 && ret != MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) {
   \       0x2C   0xBF18             IT       NE
   \       0x2E   0xF515 0x5F02      CMNNE    R5,#+8320
   \       0x32   0xD12E             BNE.N    ??mbedtls_x509_get_subject_alt_name_ext_3
   1264                      mbedtls_asn1_sequence_free(subject_alt_name->next);
   1265                      subject_alt_name->next = NULL;
   1266                      return ret;
   1267                  }
   1268          
   1269                  mbedtls_x509_free_subject_alt_name(&tmp_san_name);
   \       0x34   0xA804             ADD      R0,SP,#+16
   \       0x36   0x.... 0x....      BL       mbedtls_x509_free_subject_alt_name
   1270                  /* Allocate and assign next pointer */
   1271                  if (cur->buf.p != NULL) {
   \       0x3A   0x68A0             LDR      R0,[R4, #+8]
   \       0x3C   0xB140             CBZ.N    R0,??mbedtls_x509_get_subject_alt_name_ext_4
   1272                      if (cur->next != NULL) {
   \       0x3E   0x68E0             LDR      R0,[R4, #+12]
   \       0x40   0xBB70             CBNZ.N   R0,??mbedtls_x509_get_subject_alt_name_ext_5
   1273                          return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
   1274                      }
   1275          
   1276                      cur->next = mbedtls_calloc(1, sizeof(mbedtls_asn1_sequence));
   \       0x42   0x2110             MOVS     R1,#+16
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x.... 0x....      BL       sl_calloc
   \       0x4A   0x60E0             STR      R0,[R4, #+12]
   1277          
   1278                      if (cur->next == NULL) {
   \       0x4C   0x0004             MOVS     R4,R0
   \       0x4E   0xD02A             BEQ.N    ??mbedtls_x509_get_subject_alt_name_ext_6
   1279                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1280                                                   MBEDTLS_ERR_ASN1_ALLOC_FAILED);
   1281                      }
   1282          
   1283                      cur = cur->next;
   1284                  }
   1285          
   1286                  cur->buf = tmp_san_buf;
   \                     ??mbedtls_x509_get_subject_alt_name_ext_4: (+1)
   \       0x50   0xAB01             ADD      R3,SP,#+4
   \       0x52   0xE893 0x0007      LDM      R3,{R0-R2}
   \       0x56   0xE884 0x0007      STM      R4,{R0-R2}
   1287                  *p += tmp_san_buf.len;
   \       0x5A   0x6835             LDR      R5,[R6, #+0]
   \       0x5C   0x9802             LDR      R0,[SP, #+8]
   \       0x5E   0x4428             ADD      R0,R5,R0
   \       0x60   0x6030             STR      R0,[R6, #+0]
   \                     ??mbedtls_x509_get_subject_alt_name_ext_0: (+1)
   \       0x62   0x6835             LDR      R5,[R6, #+0]
   \       0x64   0x4545             CMP      R5,R8
   \       0x66   0xD221             BCS.N    ??mbedtls_x509_get_subject_alt_name_ext_7
   \       0x68   0x2128             MOVS     R1,#+40
   \       0x6A   0xA804             ADD      R0,SP,#+16
   \       0x6C   0x.... 0x....      BL       __aeabi_memclr4
   \       0x70   0x7828             LDRB     R0,[R5, #+0]
   \       0x72   0x1C69             ADDS     R1,R5,#+1
   \       0x74   0x466A             MOV      R2,SP
   \       0x76   0x9001             STR      R0,[SP, #+4]
   \       0x78   0x6031             STR      R1,[R6, #+0]
   \       0x7A   0x4641             MOV      R1,R8
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x.... 0x....      BL       mbedtls_asn1_get_len
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD0C4             BEQ.N    ??mbedtls_x509_get_subject_alt_name_ext_1
   \       0x86   0xF5A0 0x5014      SUB      R0,R0,#+9472
   \       0x8A   0xE015             B.N      ??mbedtls_x509_get_subject_alt_name_ext_8
   \                     ??mbedtls_x509_get_subject_alt_name_ext_2: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \       0x90   0xE012             B.N      ??mbedtls_x509_get_subject_alt_name_ext_8
   \                     ??mbedtls_x509_get_subject_alt_name_ext_3: (+1)
   \       0x92   0x68F8             LDR      R0,[R7, #+12]
   \       0x94   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x60F8             STR      R0,[R7, #+12]
   \       0x9C   0x4628             MOV      R0,R5
   \       0x9E   0xE00B             B.N      ??mbedtls_x509_get_subject_alt_name_ext_8
   \                     ??mbedtls_x509_get_subject_alt_name_ext_5: (+1)
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable60_6
   \       0xA4   0xE008             B.N      ??mbedtls_x509_get_subject_alt_name_ext_8
   1288              }
   \                     ??mbedtls_x509_get_subject_alt_name_ext_6: (+1)
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable60_7
   \       0xAA   0xE005             B.N      ??mbedtls_x509_get_subject_alt_name_ext_8
   1289          
   1290              /* Set final sequence entry's next pointer to NULL */
   1291              cur->next = NULL;
   \                     ??mbedtls_x509_get_subject_alt_name_ext_7: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x60E0             STR      R0,[R4, #+12]
   1292          
   1293              if (*p != end) {
   \       0xB0   0x4545             CMP      R5,R8
   \       0xB2   0xBF18             IT       NE
   \       0xB4   0x.... 0x....      LDRNE.W  R0,??DataTable60_8
   1294                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1295                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1296              }
   1297          
   1298              return 0;
   \                     ??mbedtls_x509_get_subject_alt_name_ext_8: (+1)
   \       0xB8   0xB00E             ADD      SP,SP,#+56
   \       0xBA   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1299          }
   1300          
   1301          /*
   1302           * SubjectAltName ::= GeneralNames
   1303           *
   1304           * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
   1305           *
   1306           * GeneralName ::= CHOICE {
   1307           *      otherName                       [0]     OtherName,
   1308           *      rfc822Name                      [1]     IA5String,
   1309           *      dNSName                         [2]     IA5String,
   1310           *      x400Address                     [3]     ORAddress,
   1311           *      directoryName                   [4]     Name,
   1312           *      ediPartyName                    [5]     EDIPartyName,
   1313           *      uniformResourceIdentifier       [6]     IA5String,
   1314           *      iPAddress                       [7]     OCTET STRING,
   1315           *      registeredID                    [8]     OBJECT IDENTIFIER }
   1316           *
   1317           * OtherName ::= SEQUENCE {
   1318           *      type-id    OBJECT IDENTIFIER,
   1319           *      value      [0] EXPLICIT ANY DEFINED BY type-id }
   1320           *
   1321           * EDIPartyName ::= SEQUENCE {
   1322           *      nameAssigner            [0]     DirectoryString OPTIONAL,
   1323           *      partyName               [1]     DirectoryString }
   1324           *
   1325           * We list all types, but use the following GeneralName types from RFC 5280:
   1326           * "dnsName", "uniformResourceIdentifier" and "hardware_module_name"
   1327           * of type "otherName", as defined in RFC 4108.
   1328           */

   \                                 In section .text, align 2, keep-with-next
   1329          int mbedtls_x509_get_subject_alt_name(unsigned char **p,
   1330                                                const unsigned char *end,
   1331                                                mbedtls_x509_sequence *subject_alt_name)
   1332          {
   \                     mbedtls_x509_get_subject_alt_name: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4616             MOV      R6,R2
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   1333              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1334              size_t len;
   1335          
   1336              /* Get main sequence tag */
   1337              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
   1338                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \        0x8   0x2330             MOVS     R3,#+48
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x10   0xB100             CBZ.N    R0,??mbedtls_x509_get_subject_alt_name_0
   1339                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \       0x12   0x....             B.N      ?Subroutine2
   1340              }
   1341          
   1342              if (*p + len != end) {
   \                     ??mbedtls_x509_get_subject_alt_name_0: (+1)
   \       0x14   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x18   0x42A8             CMP      R0,R5
   \       0x1A   0xD000             BEQ.N    ??mbedtls_x509_get_subject_alt_name_1
   1343                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1344                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   \       0x1C   0x....             B.N      ?Subroutine1
   1345              }
   1346          
   1347              return mbedtls_x509_get_subject_alt_name_ext(p, end, subject_alt_name);
   \                     ??mbedtls_x509_get_subject_alt_name_1: (+1)
   \       0x1E   0x4632             MOV      R2,R6
   \       0x20   0x4629             MOV      R1,R5
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       mbedtls_x509_get_subject_alt_name_ext
   \       0x28   0xBD76             POP      {R1,R2,R4-R6,PC}
   1348          }
   1349          

   \                                 In section .text, align 2, keep-with-next
   1350          int mbedtls_x509_get_ns_cert_type(unsigned char **p,
   1351                                            const unsigned char *end,
   1352                                            unsigned char *ns_cert_type)
   1353          {
   \                     mbedtls_x509_get_ns_cert_type: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1354              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1355              mbedtls_x509_bitstring bs = { 0, 0, NULL };
   1356          
   1357              if ((ret = mbedtls_asn1_get_bitstring(p, end, &bs)) != 0) {
   \                     ??CrossCallReturnLabel_40: (+1)
   \        0x6   0xB100             CBZ.N    R0,??mbedtls_x509_get_ns_cert_type_0
   1358                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \        0x8   0x....             B.N      ?Subroutine3
   1359              }
   1360          
   1361              /* A bitstring with no flags set is still technically valid, as it will mean
   1362                 that the certificate has no designated purpose at the time of creation. */
   1363              if (bs.len == 0) {
   \                     ??mbedtls_x509_get_ns_cert_type_0: (+1)
   \        0xA   0x9800             LDR      R0,[SP, #+0]
   \        0xC   0xB908             CBNZ.N   R0,??mbedtls_x509_get_ns_cert_type_1
   1364                  *ns_cert_type = 0;
   \        0xE   0x7025             STRB     R5,[R4, #+0]
   1365                  return 0;
   \       0x10   0xBDFE             POP      {R1-R7,PC}
   1366              }
   1367          
   1368              if (bs.len != 1) {
   \                     ??mbedtls_x509_get_ns_cert_type_1: (+1)
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD002             BEQ.N    ??mbedtls_x509_get_ns_cert_type_2
   1369                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1370                                           MBEDTLS_ERR_ASN1_INVALID_LENGTH);
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable60_9
   \       0x1A   0xBDFE             POP      {R1-R7,PC}
   1371              }
   1372          
   1373              /* Get actual bitstring */
   1374              *ns_cert_type = *bs.p;
   \                     ??mbedtls_x509_get_ns_cert_type_2: (+1)
   \       0x1C   0x9902             LDR      R1,[SP, #+8]
   \       0x1E   0x7808             LDRB     R0,[R1, #+0]
   \       0x20   0x7020             STRB     R0,[R4, #+0]
   1375              return 0;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBDFE             POP      {R1-R7,PC}
   1376          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x4614             MOV      R4,R2
   \        0x2   0x466F             MOV      R7,SP
   \        0x4   0x2600             MOVS     R6,#+0
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x2500             MOVS     R5,#+0
   \        0xA   0xE887 0x0068      STM      R7,{R3,R5,R6}
   \        0xE   0x466A             MOV      R2,SP
   \       0x10   0x.... 0x....      B.W      mbedtls_asn1_get_bitstring

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF5A0 0x5014      SUB      R0,R0,#+9472
   \        0x4   0xBDFE             POP      {R1-R7,PC}

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_47:
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00               DC8 0
   \        0x5                      DS8 3
   \        0x8   0x0000'0000        DC32 0x0
   1377          

   \                                 In section .text, align 2, keep-with-next
   1378          int mbedtls_x509_get_key_usage(unsigned char **p,
   1379                                         const unsigned char *end,
   1380                                         unsigned int *key_usage)
   1381          {
   \                     mbedtls_x509_get_key_usage: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1382              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1383              size_t i;
   1384              mbedtls_x509_bitstring bs = { 0, 0, NULL };
   1385          
   1386              if ((ret = mbedtls_asn1_get_bitstring(p, end, &bs)) != 0) {
   \                     ??CrossCallReturnLabel_39: (+1)
   \        0x6   0xB100             CBZ.N    R0,??mbedtls_x509_get_key_usage_0
   1387                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
   \        0x8   0x....             B.N      ?Subroutine3
   1388              }
   1389          
   1390              /* A bitstring with no flags set is still technically valid, as it will mean
   1391                 that the certificate has no designated purpose at the time of creation. */
   1392              if (bs.len == 0) {
   \                     ??mbedtls_x509_get_key_usage_0: (+1)
   \        0xA   0x9800             LDR      R0,[SP, #+0]
   \        0xC   0xB908             CBNZ.N   R0,??mbedtls_x509_get_key_usage_1
   1393                  *key_usage = 0;
   \        0xE   0x6025             STR      R5,[R4, #+0]
   1394                  return 0;
   \       0x10   0xBDFE             POP      {R1-R7,PC}
   1395              }
   1396          
   1397              /* Get actual bitstring */
   1398              *key_usage = 0;
   \                     ??mbedtls_x509_get_key_usage_1: (+1)
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6021             STR      R1,[R4, #+0]
   1399              for (i = 0; i < bs.len && i < sizeof(unsigned int); i++) {
   \       0x16   0xE007             B.N      ??mbedtls_x509_get_key_usage_2
   1400                  *key_usage |= (unsigned int) bs.p[i] << (8*i);
   \                     ??mbedtls_x509_get_key_usage_3: (+1)
   \       0x18   0x9B02             LDR      R3,[SP, #+8]
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x00CA             LSLS     R2,R1,#+3
   \       0x1E   0x5C5D             LDRB     R5,[R3, R1]
   1401              }
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x4095             LSLS     R5,R5,R2
   \       0x24   0x4328             ORRS     R0,R5,R0
   \       0x26   0x6020             STR      R0,[R4, #+0]
   \                     ??mbedtls_x509_get_key_usage_2: (+1)
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0x4281             CMP      R1,R0
   \       0x2C   0xBF38             IT       CC
   \       0x2E   0x2904             CMPCC    R1,#+4
   \       0x30   0xD3F2             BCC.N    ??mbedtls_x509_get_key_usage_3
   1402          
   1403              return 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBDFE             POP      {R1-R7,PC}
   1404          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_48:
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00               DC8 0
   \        0x5                      DS8 3
   \        0x8   0x0000'0000        DC32 0x0
   1405          

   \                                 In section .text, align 2, keep-with-next
   1406          int mbedtls_x509_parse_subject_alt_name(const mbedtls_x509_buf *san_buf,
   1407                                                  mbedtls_x509_subject_alternative_name *san)
   1408          {
   \                     mbedtls_x509_parse_subject_alt_name: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x4606             MOV      R6,R0
   1409              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1410              switch (san_buf->tag &
   1411                      (MBEDTLS_ASN1_TAG_CLASS_MASK |
   1412                       MBEDTLS_ASN1_TAG_VALUE_MASK)) {
   \        0x6   0x6830             LDR      R0,[R6, #+0]
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x.... 0x....      LDR.W    R4,??DataTable60_10
   \        0xE   0xF000 0x02DF      AND      R2,R0,#0xDF
   \       0x12   0x.... 0x....      LDR.W    R7,??DataTable58_1
   \       0x16   0x2A80             CMP      R2,#+128
   \       0x18   0xD00E             BEQ.N    ??mbedtls_x509_parse_subject_alt_name_0
   \       0x1A   0x2A81             CMP      R2,#+129
   \       0x1C   0xF000 0x8095      BEQ.W    ??mbedtls_x509_parse_subject_alt_name_1
   \       0x20   0x2A82             CMP      R2,#+130
   \       0x22   0xF000 0x807D      BEQ.W    ??mbedtls_x509_parse_subject_alt_name_2
   \       0x26   0x2A84             CMP      R2,#+132
   \       0x28   0xF000 0x8093      BEQ.W    ??mbedtls_x509_parse_subject_alt_name_3
   \       0x2C   0x2A86             CMP      R2,#+134
   \       0x2E   0xD06D             BEQ.N    ??mbedtls_x509_parse_subject_alt_name_4
   \       0x30   0x2A87             CMP      R2,#+135
   \       0x32   0xF000 0x807F      BEQ.W    ??mbedtls_x509_parse_subject_alt_name_5
   \                     ??mbedtls_x509_parse_subject_alt_name_6: (+1)
   \       0x36   0xE09E             B.N      ??mbedtls_x509_parse_subject_alt_name_7
   1413                  /*
   1414                   * otherName
   1415                   */
   1416                  case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_OTHER_NAME):
   1417                  {
   1418                      mbedtls_x509_san_other_name other_name;
   1419          
   1420                      ret = x509_get_other_name(san_buf, &other_name);
   \                     ??mbedtls_x509_parse_subject_alt_name_0: (+1)
   \       0x38   0x68B1             LDR      R1,[R6, #+8]
   \       0x3A   0x9100             STR      R1,[SP, #+0]
   \       0x3C   0xF000 0x00DF      AND      R0,R0,#0xDF
   \       0x40   0x460A             MOV      R2,R1
   \       0x42   0x6871             LDR      R1,[R6, #+4]
   \       0x44   0x1856             ADDS     R6,R2,R1
   \       0x46   0x2880             CMP      R0,#+128
   \       0x48   0xBF18             IT       NE
   \       0x4A   0x463C             MOVNE    R4,R7
   \       0x4C   0xD1F3             BNE.N    ??mbedtls_x509_parse_subject_alt_name_6
   \       0x4E   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x52   0xB170             CBZ.N    R0,??mbedtls_x509_parse_subject_alt_name_8
   \                     ??mbedtls_x509_parse_subject_alt_name_9: (+1)
   \       0x54   0xF5B0 0x5414      SUBS     R4,R0,#+9472
   1421                      if (ret != 0) {
   \       0x58   0xD10E             BNE.N    ??mbedtls_x509_parse_subject_alt_name_10
   1422                          return ret;
   1423                      }
   1424          
   1425                      memset(san, 0, sizeof(mbedtls_x509_subject_alternative_name));
   \                     ??mbedtls_x509_parse_subject_alt_name_11: (+1)
   \       0x5A   0x.... 0x....      BL       ?Subroutine13
   1426                      san->type = MBEDTLS_X509_SAN_OTHER_NAME;
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6028             STR      R0,[R5, #+0]
   1427                      memcpy(&san->san.other_name,
   1428                             &other_name, sizeof(other_name));
   \       0x62   0x2224             MOVS     R2,#+36
   \       0x64   0xA902             ADD      R1,SP,#+8
   \       0x66   0x1D28             ADDS     R0,R5,#+4
   \       0x68   0x.... 0x....      BL       __aeabi_memcpy4
   1429          
   1430                  }
   1431                  break;
   1432                  /*
   1433                   * uniformResourceIdentifier
   1434                   */
   1435                  case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER):
   1436                  {
   1437                      memset(san, 0, sizeof(mbedtls_x509_subject_alternative_name));
   1438                      san->type = MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER;
   1439          
   1440                      memcpy(&san->san.unstructured_name,
   1441                             san_buf, sizeof(*san_buf));
   1442          
   1443                  }
   1444                  break;
   1445                  /*
   1446                   * dNSName
   1447                   */
   1448                  case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_DNS_NAME):
   1449                  {
   1450                      memset(san, 0, sizeof(mbedtls_x509_subject_alternative_name));
   1451                      san->type = MBEDTLS_X509_SAN_DNS_NAME;
   1452          
   1453                      memcpy(&san->san.unstructured_name,
   1454                             san_buf, sizeof(*san_buf));
   1455                  }
   1456                  break;
   1457                  /*
   1458                   * IP address
   1459                   */
   1460                  case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_IP_ADDRESS):
   1461                  {
   1462                      memset(san, 0, sizeof(mbedtls_x509_subject_alternative_name));
   1463                      san->type = MBEDTLS_X509_SAN_IP_ADDRESS;
   1464                      // Only IPv6 (16 bytes) and IPv4 (4 bytes) types are supported
   1465                      if (san_buf->len == 4 || san_buf->len == 16) {
   1466                          memcpy(&san->san.unstructured_name,
   1467                                 san_buf, sizeof(*san_buf));
   1468                      } else {
   1469                          return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1470                      }
   1471                  }
   1472                  break;
   1473                  /*
   1474                   * rfc822Name
   1475                   */
   1476                  case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_RFC822_NAME):
   1477                  {
   1478                      memset(san, 0, sizeof(mbedtls_x509_subject_alternative_name));
   1479                      san->type = MBEDTLS_X509_SAN_RFC822_NAME;
   1480                      memcpy(&san->san.unstructured_name, san_buf, sizeof(*san_buf));
   1481                  }
   1482                  break;
   1483                  /*
   1484                   * directoryName
   1485                   */
   1486                  case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_X509_SAN_DIRECTORY_NAME):
   1487                  {
   1488                      size_t name_len;
   1489                      unsigned char *p = san_buf->p;
   1490                      memset(san, 0, sizeof(mbedtls_x509_subject_alternative_name));
   1491                      san->type = MBEDTLS_X509_SAN_DIRECTORY_NAME;
   1492          
   1493                      ret = mbedtls_asn1_get_tag(&p, p + san_buf->len, &name_len,
   1494                                                 MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
   1495          
   1496                      if (ret != 0) {
   1497                          return ret;
   1498                      }
   1499          
   1500                      if ((ret = mbedtls_x509_get_name(&p, p + name_len,
   1501                                                       &san->san.directory_name)) != 0) {
   1502                          return ret;
   1503                      }
   1504                  }
   1505                  break;
   1506                  /*
   1507                   * Type not supported
   1508                   */
   1509                  default:
   1510                      return MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
   1511              }
   1512              return 0;
   \                     ??mbedtls_x509_parse_subject_alt_name_12: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_parse_subject_alt_name_13: (+1)
   \       0x6E   0xB00B             ADD      SP,SP,#+44
   \       0x70   0xBDF0             POP      {R4-R7,PC}
   \                     ??mbedtls_x509_parse_subject_alt_name_8: (+1)
   \       0x72   0x9801             LDR      R0,[SP, #+4]
   \       0x74   0x9F00             LDR      R7,[SP, #+0]
   \       0x76   0x2808             CMP      R0,#+8
   \                     ??mbedtls_x509_parse_subject_alt_name_10: (+1)
   \       0x78   0xD17D             BNE.N    ??mbedtls_x509_parse_subject_alt_name_7
   \       0x7A   0x2208             MOVS     R2,#+8
   \       0x7C   0x4639             MOV      R1,R7
   \       0x7E   0x.... 0x....      ADR.W    R0,?_19
   \       0x82   0x.... 0x....      BL       memcmp
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD175             BNE.N    ??mbedtls_x509_parse_subject_alt_name_7
   \       0x8A   0x2108             MOVS     R1,#+8
   \       0x8C   0x9103             STR      R1,[SP, #+12]
   \       0x8E   0x9900             LDR      R1,[SP, #+0]
   \       0x90   0x2006             MOVS     R0,#+6
   \       0x92   0x9002             STR      R0,[SP, #+8]
   \       0x94   0xF101 0x0008      ADD      R0,R1,#+8
   \       0x98   0x9000             STR      R0,[SP, #+0]
   \       0x9A   0x9704             STR      R7,[SP, #+16]
   \       0x9C   0x23A0             MOVS     R3,#+160
   \       0x9E   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0xA2   0x0004             MOVS     R4,R0
   \       0xA4   0xD1D6             BNE.N    ??mbedtls_x509_parse_subject_alt_name_9
   \       0xA6   0x9900             LDR      R1,[SP, #+0]
   \       0xA8   0x9801             LDR      R0,[SP, #+4]
   \       0xAA   0x4408             ADD      R0,R1,R0
   \       0xAC   0x4286             CMP      R6,R0
   \       0xAE   0xD12A             BNE.N    ??mbedtls_x509_parse_subject_alt_name_14
   \       0xB0   0x2330             MOVS     R3,#+48
   \       0xB2   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0xB6   0x0004             MOVS     R4,R0
   \       0xB8   0xD1CC             BNE.N    ??mbedtls_x509_parse_subject_alt_name_9
   \       0xBA   0x9900             LDR      R1,[SP, #+0]
   \       0xBC   0x9801             LDR      R0,[SP, #+4]
   \       0xBE   0x4408             ADD      R0,R1,R0
   \       0xC0   0x4286             CMP      R6,R0
   \       0xC2   0xD120             BNE.N    ??mbedtls_x509_parse_subject_alt_name_14
   \       0xC4   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0xC8   0x0004             MOVS     R4,R0
   \       0xCA   0xD1C3             BNE.N    ??mbedtls_x509_parse_subject_alt_name_9
   \       0xCC   0x2006             MOVS     R0,#+6
   \       0xCE   0x9005             STR      R0,[SP, #+20]
   \       0xD0   0x9800             LDR      R0,[SP, #+0]
   \       0xD2   0x9900             LDR      R1,[SP, #+0]
   \       0xD4   0x2304             MOVS     R3,#+4
   \       0xD6   0x9007             STR      R0,[SP, #+28]
   \       0xD8   0x9801             LDR      R0,[SP, #+4]
   \       0xDA   0xAA01             ADD      R2,SP,#+4
   \       0xDC   0x9006             STR      R0,[SP, #+24]
   \       0xDE   0x9801             LDR      R0,[SP, #+4]
   \       0xE0   0x4408             ADD      R0,R1,R0
   \       0xE2   0x9000             STR      R0,[SP, #+0]
   \       0xE4   0x4631             MOV      R1,R6
   \       0xE6   0x4668             MOV      R0,SP
   \       0xE8   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0xEC   0x0004             MOVS     R4,R0
   \       0xEE   0xD1B1             BNE.N    ??mbedtls_x509_parse_subject_alt_name_9
   \       0xF0   0x2004             MOVS     R0,#+4
   \       0xF2   0x9008             STR      R0,[SP, #+32]
   \       0xF4   0x9800             LDR      R0,[SP, #+0]
   \       0xF6   0x9901             LDR      R1,[SP, #+4]
   \       0xF8   0x900A             STR      R0,[SP, #+40]
   \       0xFA   0x9801             LDR      R0,[SP, #+4]
   \       0xFC   0x9009             STR      R0,[SP, #+36]
   \       0xFE   0x9800             LDR      R0,[SP, #+0]
   \      0x100   0x4401             ADD      R1,R0,R1
   \      0x102   0x42B1             CMP      R1,R6
   \      0x104   0xD0A9             BEQ.N    ??mbedtls_x509_parse_subject_alt_name_11
   \                     ??mbedtls_x509_parse_subject_alt_name_14: (+1)
   \      0x106   0x.... 0x....      LDR.W    R4,??DataTable60_8
   \      0x10A   0xE034             B.N      ??mbedtls_x509_parse_subject_alt_name_7
   \                     ??mbedtls_x509_parse_subject_alt_name_4: (+1)
   \      0x10C   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_47: (+1)
   \      0x110   0x2006             MOVS     R0,#+6
   \      0x112   0x6028             STR      R0,[R5, #+0]
   \                     ??mbedtls_x509_parse_subject_alt_name_15: (+1)
   \      0x114   0xE896 0x0007      LDM      R6,{R0-R2}
   \      0x118   0x1D2B             ADDS     R3,R5,#+4
   \      0x11A   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x11E   0xE7A5             B.N      ??mbedtls_x509_parse_subject_alt_name_12
   \                     ??mbedtls_x509_parse_subject_alt_name_2: (+1)
   \      0x120   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_48: (+1)
   \      0x124   0x2102             MOVS     R1,#+2
   \                     ??mbedtls_x509_parse_subject_alt_name_16: (+1)
   \      0x126   0x6029             STR      R1,[R5, #+0]
   \      0x128   0xE896 0x000E      LDM      R6,{R1-R3}
   \      0x12C   0x1D28             ADDS     R0,R5,#+4
   \      0x12E   0xE880 0x000E      STM      R0,{R1-R3}
   \      0x132   0xE79B             B.N      ??mbedtls_x509_parse_subject_alt_name_12
   \                     ??mbedtls_x509_parse_subject_alt_name_5: (+1)
   \      0x134   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_49: (+1)
   \      0x138   0x2007             MOVS     R0,#+7
   \      0x13A   0x6028             STR      R0,[R5, #+0]
   \      0x13C   0x6870             LDR      R0,[R6, #+4]
   \      0x13E   0x2804             CMP      R0,#+4
   \      0x140   0xBF18             IT       NE
   \      0x142   0x2810             CMPNE    R0,#+16
   \      0x144   0xD0E6             BEQ.N    ??mbedtls_x509_parse_subject_alt_name_15
   \      0x146   0x4638             MOV      R0,R7
   \      0x148   0xE791             B.N      ??mbedtls_x509_parse_subject_alt_name_13
   \                     ??mbedtls_x509_parse_subject_alt_name_1: (+1)
   \      0x14A   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_50: (+1)
   \      0x14E   0x2101             MOVS     R1,#+1
   \      0x150   0xE7E9             B.N      ??mbedtls_x509_parse_subject_alt_name_16
   \                     ??mbedtls_x509_parse_subject_alt_name_3: (+1)
   \      0x152   0x68B1             LDR      R1,[R6, #+8]
   \      0x154   0x4628             MOV      R0,R5
   \      0x156   0x9100             STR      R1,[SP, #+0]
   \      0x158   0x2128             MOVS     R1,#+40
   \      0x15A   0x.... 0x....      BL       __aeabi_memclr4
   \      0x15E   0x2004             MOVS     R0,#+4
   \      0x160   0x6028             STR      R0,[R5, #+0]
   \      0x162   0x9800             LDR      R0,[SP, #+0]
   \      0x164   0x6871             LDR      R1,[R6, #+4]
   \      0x166   0x2330             MOVS     R3,#+48
   \      0x168   0xAA01             ADD      R2,SP,#+4
   \      0x16A   0x4401             ADD      R1,R0,R1
   \      0x16C   0x4668             MOV      R0,SP
   \      0x16E   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \      0x172   0x0004             MOVS     R4,R0
   \      0x174   0xD001             BEQ.N    ??mbedtls_x509_parse_subject_alt_name_17
   \                     ??mbedtls_x509_parse_subject_alt_name_7: (+1)
   \      0x176   0x4620             MOV      R0,R4
   \      0x178   0xE779             B.N      ??mbedtls_x509_parse_subject_alt_name_13
   \                     ??mbedtls_x509_parse_subject_alt_name_17: (+1)
   \      0x17A   0x9900             LDR      R1,[SP, #+0]
   \      0x17C   0x9801             LDR      R0,[SP, #+4]
   \      0x17E   0x1D2A             ADDS     R2,R5,#+4
   \      0x180   0x4401             ADD      R1,R1,R0
   \      0x182   0x4668             MOV      R0,SP
   \      0x184   0x.... 0x....      BL       mbedtls_x509_get_name
   \      0x188   0xE771             B.N      ??mbedtls_x509_parse_subject_alt_name_13
   1513          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2306             MOVS     R3,#+6
   \                     ??Subroutine7_0: (+1)
   \        0x2   0xAA01             ADD      R2,SP,#+4
   \        0x4   0x4631             MOV      R1,R6
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x.... 0x....      B.W      mbedtls_asn1_get_tag
   1514          

   \                                 In section .text, align 2, keep-with-next
   1515          void mbedtls_x509_free_subject_alt_name(mbedtls_x509_subject_alternative_name *san)
   1516          {
   1517              if (san->type == MBEDTLS_X509_SAN_DIRECTORY_NAME) {
   \                     mbedtls_x509_free_subject_alt_name: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x2904             CMP      R1,#+4
   \        0x4   0xBF04             ITT      EQ
   1518                  mbedtls_asn1_free_named_data_list_shallow(san->san.directory_name.next);
   \        0x6   0x69C0             LDREQ    R0,[R0, #+28]
   \        0x8   0x.... 0x....      BEQ.W    mbedtls_asn1_free_named_data_list_shallow
   1519              }
   1520          }
   \        0xC   0x4770             BX       LR
   1521          
   1522          #if !defined(MBEDTLS_X509_REMOVE_INFO)

   \                                 In section .text, align 4, keep-with-next
   1523          int mbedtls_x509_info_subject_alt_name(char **buf, size_t *size,
   1524                                                 const mbedtls_x509_sequence
   1525                                                 *subject_alt_name,
   1526                                                 const char *prefix)
   1527          {
   \                     mbedtls_x509_info_subject_alt_name: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB099             SUB      SP,SP,#+100
   \        0x6   0x4699             MOV      R9,R3
   1528              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1529              size_t i;
   1530              size_t n = *size;
   \        0x8   0x680C             LDR      R4,[R1, #+0]
   1531              char *p = *buf;
   \        0xA   0x6806             LDR      R6,[R0, #+0]
   1532              const mbedtls_x509_sequence *cur = subject_alt_name;
   \        0xC   0x4615             MOV      R5,R2
   \        0xE   0x.... 0x....      LDR.W    R10,??DataTable60_11
   \       0x12   0x.... 0x....      ADR.W    R8,?_20
   \       0x16   0xE00C             B.N      ??mbedtls_x509_info_subject_alt_name_1
   1533              mbedtls_x509_subject_alternative_name san;
   1534              int parse_ret;
   1535          
   1536              while (cur != NULL) {
   1537                  memset(&san, 0, sizeof(san));
   1538                  parse_ret = mbedtls_x509_parse_subject_alt_name(&cur->buf, &san);
   1539                  if (parse_ret != 0) {
   1540                      if (parse_ret == MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) {
   1541                          ret = mbedtls_snprintf(p, n, "\n%s    <unsupported>", prefix);
   1542                          MBEDTLS_X509_SAFE_SNPRINTF;
   1543                      } else {
   1544                          ret = mbedtls_snprintf(p, n, "\n%s    <malformed>", prefix);
   \                     ??mbedtls_x509_info_subject_alt_name_2: (+1)
   \       0x18   0x.... 0x....      ADR.W    R2,?_21
   \       0x1C   0x.... 0x....      BL       ??Subroutine8_0
   1545                          MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xF100 0x8122      BMI.W    ??mbedtls_x509_info_subject_alt_name_3
   \                     ??mbedtls_x509_info_subject_alt_name_4: (+1)
   \       0x26   0x42A0             CMP      R0,R4
   \       0x28   0xF080 0x811F      BCS.W    ??mbedtls_x509_info_subject_alt_name_3
   \       0x2C   0x1A24             SUBS     R4,R4,R0
   \       0x2E   0x4406             ADD      R6,R6,R0
   1546                      }
   1547                      cur = cur->next;
   \                     ??mbedtls_x509_info_subject_alt_name_5: (+1)
   \       0x30   0x68ED             LDR      R5,[R5, #+12]
   1548                      continue;
   \                     ??mbedtls_x509_info_subject_alt_name_1: (+1)
   \       0x32   0x2D00             CMP      R5,#+0
   \       0x34   0xF000 0x811F      BEQ.W    ??mbedtls_x509_info_subject_alt_name_6
   \       0x38   0x2128             MOVS     R1,#+40
   \       0x3A   0xA80F             ADD      R0,SP,#+60
   \       0x3C   0x.... 0x....      BL       __aeabi_memclr4
   \       0x40   0xA90F             ADD      R1,SP,#+60
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x.... 0x....      BL       mbedtls_x509_parse_subject_alt_name
   \       0x48   0xB140             CBZ.N    R0,??mbedtls_x509_info_subject_alt_name_7
   \       0x4A   0xF510 0x5F02      CMN      R0,#+8320
   \       0x4E   0x464B             MOV      R3,R9
   \       0x50   0xD1E2             BNE.N    ??mbedtls_x509_info_subject_alt_name_2
   \       0x52   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD466             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0x5A   0xE7E4             B.N      ??mbedtls_x509_info_subject_alt_name_4
   1549                  }
   1550          
   1551                  switch (san.type) {
   \                     ??mbedtls_x509_info_subject_alt_name_7: (+1)
   \       0x5C   0x980F             LDR      R0,[SP, #+60]
   \       0x5E   0x2807             CMP      R0,#+7
   \       0x60   0xF200 0x80F9      BHI.W    ??mbedtls_x509_info_subject_alt_name_9
   \       0x64   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??mbedtls_x509_info_subject_alt_name_0:
   \       0x68   0x0008 0x0067      DC16     0x8,0x67,0x67,0xF7
   \               0x0067 0x00F
   \              7
   \       0x70   0x00D1 0x00F7      DC16     0xD1,0xF7,0x61,0x85
   \               0x0061 0x008
   \              5
   1552                      /*
   1553                       * otherName
   1554                       */
   1555                      case MBEDTLS_X509_SAN_OTHER_NAME:
   1556                      {
   1557                          mbedtls_x509_san_other_name *other_name = &san.san.other_name;
   1558          
   1559                          ret = mbedtls_snprintf(p, n, "\n%s    otherName :", prefix);
   \                     ??mbedtls_x509_info_subject_alt_name_10: (+1)
   \       0x78   0x464B             MOV      R3,R9
   \       0x7A   0x.... 0x....      ADR.W    R2,?_22
   \       0x7E   0x.... 0x....      BL       ??Subroutine8_0
   1560                          MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD450             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0x86   0x42A0             CMP      R0,R4
   \       0x88   0xD24E             BCS.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0x8A   0x1A24             SUBS     R4,R4,R0
   \       0x8C   0x4406             ADD      R6,R6,R0
   1561          
   1562                          if (MBEDTLS_OID_CMP(MBEDTLS_OID_ON_HW_MODULE_NAME,
   1563                                              &other_name->type_id) == 0) {
   \       0x8E   0x9811             LDR      R0,[SP, #+68]
   \       0x90   0x2808             CMP      R0,#+8
   \       0x92   0xD168             BNE.N    ??mbedtls_x509_info_subject_alt_name_11
   \       0x94   0x9912             LDR      R1,[SP, #+72]
   \       0x96   0x2208             MOVS     R2,#+8
   \       0x98   0x.... 0x....      ADR.W    R0,?_19
   \       0x9C   0x.... 0x....      BL       memcmp
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD160             BNE.N    ??mbedtls_x509_info_subject_alt_name_11
   1564                              ret = mbedtls_snprintf(p, n, "\n%s        hardware module name :", prefix);
   \       0xA4   0x464B             MOV      R3,R9
   \       0xA6   0x4652             MOV      R2,R10
   \       0xA8   0x.... 0x....      BL       ??Subroutine8_0
   1565                              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD43B             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xB0   0x42A0             CMP      R0,R4
   \       0xB2   0xD239             BCS.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xB4   0x1A24             SUBS     R4,R4,R0
   \       0xB6   0x4406             ADD      R6,R6,R0
   1566                              ret =
   1567                                  mbedtls_snprintf(p, n, "\n%s            hardware type          : ", prefix);
   \       0xB8   0x464B             MOV      R3,R9
   \       0xBA   0xF10A 0x0224      ADD      R2,R10,#+36
   \       0xBE   0x.... 0x....      BL       ??Subroutine8_0
   1568                              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD430             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xC6   0x42A0             CMP      R0,R4
   \       0xC8   0xD22E             BCS.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xCA   0x1A24             SUBS     R4,R4,R0
   \       0xCC   0x4406             ADD      R6,R6,R0
   1569          
   1570                              ret = mbedtls_oid_get_numeric_string(p,
   1571                                                                   n,
   1572                                                                   &other_name->value.hardware_module_name.oid);
   \       0xCE   0xAA13             ADD      R2,SP,#+76
   \       0xD0   0x4621             MOV      R1,R4
   \       0xD2   0x4630             MOV      R0,R6
   \       0xD4   0x.... 0x....      BL       mbedtls_oid_get_numeric_string
   1573                              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD425             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xDC   0x42A0             CMP      R0,R4
   \       0xDE   0xD223             BCS.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xE0   0x1A24             SUBS     R4,R4,R0
   \       0xE2   0x4406             ADD      R6,R6,R0
   1574          
   1575                              ret =
   1576                                  mbedtls_snprintf(p, n, "\n%s            hardware serial number : ", prefix);
   \       0xE4   0x464B             MOV      R3,R9
   \       0xE6   0xF10A 0x0250      ADD      R2,R10,#+80
   \       0xEA   0x.... 0x....      BL       ??Subroutine8_0
   1577                              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD41A             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xF2   0x42A0             CMP      R0,R4
   \       0xF4   0xD218             BCS.N    ??mbedtls_x509_info_subject_alt_name_8
   \       0xF6   0x1A24             SUBS     R4,R4,R0
   \       0xF8   0x4406             ADD      R6,R6,R0
   1578          
   1579                              for (i = 0; i < other_name->value.hardware_module_name.val.len; i++) {
   \       0xFA   0xF04F 0x0B00      MOV      R11,#+0
   \       0xFE   0x.... 0x....      ADR.W    R7,?_23
   \                     ??mbedtls_x509_info_subject_alt_name_12: (+1)
   \      0x102   0x9817             LDR      R0,[SP, #+92]
   \      0x104   0x4583             CMP      R11,R0
   \      0x106   0xD22E             BCS.N    ??mbedtls_x509_info_subject_alt_name_11
   1580                                  ret = mbedtls_snprintf(p,
   1581                                                         n,
   1582                                                         "%02X",
   1583                                                         other_name->value.hardware_module_name.val.p[i]);
   \      0x108   0x9818             LDR      R0,[SP, #+96]
   \      0x10A   0x463A             MOV      R2,R7
   \      0x10C   0x4621             MOV      R1,R4
   \      0x10E   0xF810 0x300B      LDRB     R3,[R0, R11]
   \      0x112   0x.... 0x....      BL       ??Subroutine8_1
   1584                                  MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_12: (+1)
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD406             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \      0x11A   0x42A0             CMP      R0,R4
   \      0x11C   0xBF3E             ITTT     CC
   \      0x11E   0x1A24             SUBCC    R4,R4,R0
   \      0x120   0x1836             ADDCC    R6,R6,R0
   \      0x122   0xF10B 0x0B01      ADDCC    R11,R11,#+1
   1585                              }
   \      0x126   0xD3EC             BCC.N    ??mbedtls_x509_info_subject_alt_name_12
   \                     ??mbedtls_x509_info_subject_alt_name_8: (+1)
   \      0x128   0xE09F             B.N      ??mbedtls_x509_info_subject_alt_name_3
   1586                          }/* MBEDTLS_OID_ON_HW_MODULE_NAME */
   1587                      }
   1588                      break;
   1589                      /*
   1590                       * uniformResourceIdentifier
   1591                       */
   1592                      case MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER:
   1593                      {
   1594                          ret = mbedtls_snprintf(p, n, "\n%s    uniformResourceIdentifier : ", prefix);
   \                     ??mbedtls_x509_info_subject_alt_name_13: (+1)
   \      0x12A   0x464B             MOV      R3,R9
   \      0x12C   0xF10A 0x027C      ADD      R2,R10,#+124
   \      0x130   0x.... 0x....      BL       ??Subroutine8_0
   1595                          MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_14: (+1)
   \      0x134   0xE007             B.N      ??CrossCallReturnLabel_42
   1596                          if (san.san.unstructured_name.len >= n) {
   1597                              if (n > 0) {
   1598                                  *p = '\0';
   1599                              }
   1600                              return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
   1601                          }
   1602          
   1603                          memcpy(p, san.san.unstructured_name.p, san.san.unstructured_name.len);
   1604                          p += san.san.unstructured_name.len;
   1605                          n -= san.san.unstructured_name.len;
   1606                      }
   1607                      break;
   1608                      /*
   1609                       * dNSName
   1610                       * RFC822 Name
   1611                       */
   1612                      case MBEDTLS_X509_SAN_DNS_NAME:
   1613                      case MBEDTLS_X509_SAN_RFC822_NAME:
   1614                      {
   1615                          const char *dns_name = "dNSName";
   1616                          const char *rfc822_name = "rfc822Name";
   1617          
   1618                          ret = mbedtls_snprintf(p, n,
   1619                                                 "\n%s    %s : ",
   1620                                                 prefix,
   1621                                                 san.type ==
   1622                                                 MBEDTLS_X509_SAN_DNS_NAME ? dns_name : rfc822_name);
   \                     ??mbedtls_x509_info_subject_alt_name_14: (+1)
   \      0x136   0x2802             CMP      R0,#+2
   \      0x138   0xBF0C             ITE      EQ
   \      0x13A   0x.... 0x....      ADREQ.W  R0,?_24
   \      0x13E   0x.... 0x....      ADRNE.W  R0,?_25
   \      0x142   0x.... 0x....      BL       ?Subroutine11
   1623                          MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_42: (+1)
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xD4EE             BMI.N    ??mbedtls_x509_info_subject_alt_name_8
   \      0x14A   0x42A0             CMP      R0,R4
   \      0x14C   0xD2EC             BCS.N    ??mbedtls_x509_info_subject_alt_name_8
   1624                          if (san.san.unstructured_name.len >= n) {
   \      0x14E   0x9A11             LDR      R2,[SP, #+68]
   \      0x150   0x1A24             SUBS     R4,R4,R0
   \      0x152   0x4406             ADD      R6,R6,R0
   \      0x154   0x42A2             CMP      R2,R4
   \      0x156   0xD207             BCS.N    ??mbedtls_x509_info_subject_alt_name_15
   1625                              if (n > 0) {
   1626                                  *p = '\0';
   1627                              }
   1628                              return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
   1629                          }
   1630          
   1631                          memcpy(p, san.san.unstructured_name.p, san.san.unstructured_name.len);
   \      0x158   0x9912             LDR      R1,[SP, #+72]
   \      0x15A   0x4630             MOV      R0,R6
   \      0x15C   0x.... 0x....      BL       __aeabi_memcpy
   1632                          p += san.san.unstructured_name.len;
   \      0x160   0x9811             LDR      R0,[SP, #+68]
   \      0x162   0x4406             ADD      R6,R6,R0
   1633                          n -= san.san.unstructured_name.len;
   \      0x164   0x1A24             SUBS     R4,R4,R0
   1634                      }
   1635                      break;
   \                     ??mbedtls_x509_info_subject_alt_name_11: (+1)
   \      0x166   0xE082             B.N      ??mbedtls_x509_info_subject_alt_name_16
   \                     ??mbedtls_x509_info_subject_alt_name_15: (+1)
   \      0x168   0x2C00             CMP      R4,#+0
   \      0x16A   0xD001             BEQ.N    ??mbedtls_x509_info_subject_alt_name_17
   \      0x16C   0x2100             MOVS     R1,#+0
   \      0x16E   0x7031             STRB     R1,[R6, #+0]
   \                     ??mbedtls_x509_info_subject_alt_name_17: (+1)
   \      0x170   0xE07B             B.N      ??mbedtls_x509_info_subject_alt_name_3
   1636                      /*
   1637                       * iPAddress
   1638                       */
   1639                      case MBEDTLS_X509_SAN_IP_ADDRESS:
   1640                      {
   1641                          ret = mbedtls_snprintf(p, n, "\n%s    %s : ",
   1642                                                 prefix, "iPAddress");
   \                     ??mbedtls_x509_info_subject_alt_name_18: (+1)
   \      0x172   0x.... 0x....      ADR.W    R0,?_27
   \      0x176   0x.... 0x....      BL       ?Subroutine11
   1643                          MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_41: (+1)
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD475             BMI.N    ??mbedtls_x509_info_subject_alt_name_3
   \      0x17E   0x42A0             CMP      R0,R4
   \      0x180   0xD273             BCS.N    ??mbedtls_x509_info_subject_alt_name_3
   1644                          if (san.san.unstructured_name.len >= n) {
   \      0x182   0x9911             LDR      R1,[SP, #+68]
   \      0x184   0x1A24             SUBS     R4,R4,R0
   \      0x186   0x4406             ADD      R6,R6,R0
   \      0x188   0x42A1             CMP      R1,R4
   \      0x18A   0xD20A             BCS.N    ??mbedtls_x509_info_subject_alt_name_19
   1645                              if (n > 0) {
   1646                                  *p = '\0';
   1647                              }
   1648                              return MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
   1649                          }
   1650          
   1651                          unsigned char *ip = san.san.unstructured_name.p;
   \      0x18C   0x9812             LDR      R0,[SP, #+72]
   1652                          // Only IPv6 (16 bytes) and IPv4 (4 bytes) types are supported
   1653                          if (san.san.unstructured_name.len == 4) {
   \      0x18E   0x2904             CMP      R1,#+4
   \      0x190   0xD10C             BNE.N    ??mbedtls_x509_info_subject_alt_name_20
   1654                              ret = mbedtls_snprintf(p, n, "%u.%u.%u.%u", ip[0], ip[1], ip[2], ip[3]);
   \      0x192   0x78C1             LDRB     R1,[R0, #+3]
   \      0x194   0x9102             STR      R1,[SP, #+8]
   \      0x196   0x7882             LDRB     R2,[R0, #+2]
   \      0x198   0x9201             STR      R2,[SP, #+4]
   \      0x19A   0x7841             LDRB     R1,[R0, #+1]
   \      0x19C   0x.... 0x....      ADR.W    R2,?_28
   \      0x1A0   0xE025             B.N      ??mbedtls_x509_info_subject_alt_name_21
   1655                              MBEDTLS_X509_SAFE_SNPRINTF;
   1656                          } else if (san.san.unstructured_name.len == 16) {
   \                     ??mbedtls_x509_info_subject_alt_name_19: (+1)
   \      0x1A2   0x2C00             CMP      R4,#+0
   \      0x1A4   0xD061             BEQ.N    ??mbedtls_x509_info_subject_alt_name_3
   \      0x1A6   0x2000             MOVS     R0,#+0
   \      0x1A8   0x7030             STRB     R0,[R6, #+0]
   \      0x1AA   0xE05E             B.N      ??mbedtls_x509_info_subject_alt_name_3
   \                     ??mbedtls_x509_info_subject_alt_name_20: (+1)
   \      0x1AC   0x2910             CMP      R1,#+16
   \      0x1AE   0xD127             BNE.N    ??mbedtls_x509_info_subject_alt_name_22
   1657                              ret = mbedtls_snprintf(p, n,
   1658                                                     "%X%X:%X%X:%X%X:%X%X:%X%X:%X%X:%X%X:%X%X",
   1659                                                     ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6],
   1660                                                     ip[7], ip[8], ip[9], ip[10], ip[11], ip[12], ip[13],
   1661                                                     ip[14], ip[15]);
   \      0x1B0   0x7BC2             LDRB     R2,[R0, #+15]
   \      0x1B2   0x920E             STR      R2,[SP, #+56]
   \      0x1B4   0x7B81             LDRB     R1,[R0, #+14]
   \      0x1B6   0x910D             STR      R1,[SP, #+52]
   \      0x1B8   0x7B42             LDRB     R2,[R0, #+13]
   \      0x1BA   0x920C             STR      R2,[SP, #+48]
   \      0x1BC   0x7B01             LDRB     R1,[R0, #+12]
   \      0x1BE   0x910B             STR      R1,[SP, #+44]
   \      0x1C0   0x7AC2             LDRB     R2,[R0, #+11]
   \      0x1C2   0x920A             STR      R2,[SP, #+40]
   \      0x1C4   0x7A81             LDRB     R1,[R0, #+10]
   \      0x1C6   0x9109             STR      R1,[SP, #+36]
   \      0x1C8   0x7A42             LDRB     R2,[R0, #+9]
   \      0x1CA   0x9208             STR      R2,[SP, #+32]
   \      0x1CC   0x7A01             LDRB     R1,[R0, #+8]
   \      0x1CE   0x9107             STR      R1,[SP, #+28]
   \      0x1D0   0x79C2             LDRB     R2,[R0, #+7]
   \      0x1D2   0x9206             STR      R2,[SP, #+24]
   \      0x1D4   0x7981             LDRB     R1,[R0, #+6]
   \      0x1D6   0x9105             STR      R1,[SP, #+20]
   \      0x1D8   0x7942             LDRB     R2,[R0, #+5]
   \      0x1DA   0x9204             STR      R2,[SP, #+16]
   \      0x1DC   0x7901             LDRB     R1,[R0, #+4]
   \      0x1DE   0x9103             STR      R1,[SP, #+12]
   \      0x1E0   0x78C3             LDRB     R3,[R0, #+3]
   \      0x1E2   0x9302             STR      R3,[SP, #+8]
   \      0x1E4   0x7882             LDRB     R2,[R0, #+2]
   \      0x1E6   0x9201             STR      R2,[SP, #+4]
   \      0x1E8   0x7841             LDRB     R1,[R0, #+1]
   \      0x1EA   0xF10A 0x02A0      ADD      R2,R10,#+160
   \                     ??mbedtls_x509_info_subject_alt_name_21: (+1)
   \      0x1EE   0x9100             STR      R1,[SP, #+0]
   \      0x1F0   0x7803             LDRB     R3,[R0, #+0]
   \      0x1F2   0x4621             MOV      R1,R4
   \      0x1F4   0x4630             MOV      R0,R6
   \      0x1F6   0x.... 0x....      BL       snprintf
   1662                              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x1FA   0x2800             CMP      R0,#+0
   \      0x1FC   0xD435             BMI.N    ??mbedtls_x509_info_subject_alt_name_3
   \      0x1FE   0xE02F             B.N      ??mbedtls_x509_info_subject_alt_name_23
   1663                          } else {
   1664                              if (n > 0) {
   \                     ??mbedtls_x509_info_subject_alt_name_22: (+1)
   \      0x200   0xB10C             CBZ.N    R4,??mbedtls_x509_info_subject_alt_name_24
   1665                                  *p = '\0';
   \      0x202   0x2000             MOVS     R0,#+0
   \      0x204   0x7030             STRB     R0,[R6, #+0]
   1666                              }
   1667                              return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \                     ??mbedtls_x509_info_subject_alt_name_24: (+1)
   \      0x206   0x....             LDR.N    R0,??DataTable58_1
   \      0x208   0xE03C             B.N      ??mbedtls_x509_info_subject_alt_name_25
   1668                          }
   1669                      }
   1670                      break;
   1671                      /*
   1672                       * directoryName
   1673                       */
   1674                      case MBEDTLS_X509_SAN_DIRECTORY_NAME:
   1675                      {
   1676                          ret = mbedtls_snprintf(p, n, "\n%s    directoryName : ", prefix);
   \                     ??mbedtls_x509_info_subject_alt_name_26: (+1)
   \      0x20A   0x464B             MOV      R3,R9
   \      0x20C   0x.... 0x....      ADR.W    R2,?_29
   \      0x210   0x.... 0x....      BL       ??Subroutine8_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \      0x214   0x4607             MOV      R7,R0
   1677                          if (ret < 0 || (size_t) ret >= n) {
   \      0x216   0x2F00             CMP      R7,#+0
   \      0x218   0xD401             BMI.N    ??mbedtls_x509_info_subject_alt_name_27
   \      0x21A   0x42A7             CMP      R7,R4
   \      0x21C   0xD304             BCC.N    ??mbedtls_x509_info_subject_alt_name_28
   1678                              mbedtls_x509_free_subject_alt_name(&san);
   \                     ??mbedtls_x509_info_subject_alt_name_27: (+1)
   \      0x21E   0xA80F             ADD      R0,SP,#+60
   \      0x220   0x.... 0x....      BL       mbedtls_x509_free_subject_alt_name
   1679                          }
   1680          
   1681                          MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x224   0x2F00             CMP      R7,#+0
   \      0x226   0xD420             BMI.N    ??mbedtls_x509_info_subject_alt_name_3
   \                     ??mbedtls_x509_info_subject_alt_name_28: (+1)
   \      0x228   0x42A7             CMP      R7,R4
   \      0x22A   0xD21E             BCS.N    ??mbedtls_x509_info_subject_alt_name_3
   \      0x22C   0x1BE4             SUBS     R4,R4,R7
   \      0x22E   0x19F6             ADDS     R6,R6,R7
   1682                          ret = mbedtls_x509_dn_gets(p, n, &san.san.directory_name);
   \      0x230   0xAA10             ADD      R2,SP,#+64
   \      0x232   0x4621             MOV      R1,R4
   \      0x234   0x4630             MOV      R0,R6
   \      0x236   0x.... 0x....      BL       mbedtls_x509_dn_gets
   \      0x23A   0x4607             MOV      R7,R0
   1683          
   1684                          if (ret < 0) {
   \      0x23C   0x2F00             CMP      R7,#+0
   \      0x23E   0xD402             BMI.N    ??mbedtls_x509_info_subject_alt_name_29
   1685                              mbedtls_x509_free_subject_alt_name(&san);
   1686                              if (n > 0) {
   1687                                  *p = '\0';
   1688                              }
   1689                              return ret;
   1690                          }
   1691          
   1692                          p += ret;
   \      0x240   0x19F6             ADDS     R6,R6,R7
   1693                          n -= ret;
   \      0x242   0x1BE4             SUBS     R4,R4,R7
   1694                      }
   1695                      break;
   \      0x244   0xE013             B.N      ??mbedtls_x509_info_subject_alt_name_16
   \                     ??mbedtls_x509_info_subject_alt_name_29: (+1)
   \      0x246   0xA80F             ADD      R0,SP,#+60
   \      0x248   0x.... 0x....      BL       mbedtls_x509_free_subject_alt_name
   \      0x24C   0xB10C             CBZ.N    R4,??mbedtls_x509_info_subject_alt_name_30
   \      0x24E   0x2000             MOVS     R0,#+0
   \      0x250   0x7030             STRB     R0,[R6, #+0]
   \                     ??mbedtls_x509_info_subject_alt_name_30: (+1)
   \      0x252   0x4638             MOV      R0,R7
   \      0x254   0xE016             B.N      ??mbedtls_x509_info_subject_alt_name_25
   1696                      /*
   1697                       * Type not supported, skip item.
   1698                       */
   1699                      default:
   1700                          ret = mbedtls_snprintf(p, n, "\n%s    <unsupported>", prefix);
   \                     ??mbedtls_x509_info_subject_alt_name_9: (+1)
   \      0x256   0x464B             MOV      R3,R9
   \      0x258   0x.... 0x....      BL       ?Subroutine8
   1701                          MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x25C   0x2800             CMP      R0,#+0
   \      0x25E   0xD404             BMI.N    ??mbedtls_x509_info_subject_alt_name_3
   \                     ??mbedtls_x509_info_subject_alt_name_23: (+1)
   \      0x260   0x42A0             CMP      R0,R4
   \      0x262   0xD202             BCS.N    ??mbedtls_x509_info_subject_alt_name_3
   \      0x264   0x1A24             SUBS     R4,R4,R0
   \      0x266   0x4406             ADD      R6,R6,R0
   1702                          break;
   \      0x268   0xE001             B.N      ??mbedtls_x509_info_subject_alt_name_16
   \                     ??mbedtls_x509_info_subject_alt_name_3: (+1)
   \      0x26A   0x....             LDR.N    R0,??DataTable60_2
   \      0x26C   0xE00A             B.N      ??mbedtls_x509_info_subject_alt_name_25
   1703                  }
   1704          
   1705                  /* So far memory is freed only in the case of directoryName
   1706                   * parsing succeeding, as mbedtls_x509_get_name allocates memory. */
   1707                  mbedtls_x509_free_subject_alt_name(&san);
   \                     ??mbedtls_x509_info_subject_alt_name_16: (+1)
   \      0x26E   0xA80F             ADD      R0,SP,#+60
   \      0x270   0x.... 0x....      BL       mbedtls_x509_free_subject_alt_name
   1708                  cur = cur->next;
   \      0x274   0xE6DC             B.N      ??mbedtls_x509_info_subject_alt_name_5
   1709              }
   1710          
   1711              *p = '\0';
   \                     ??mbedtls_x509_info_subject_alt_name_6: (+1)
   \      0x276   0x2000             MOVS     R0,#+0
   \      0x278   0x7030             STRB     R0,[R6, #+0]
   1712          
   1713              *size = n;
   \      0x27A   0x991A             LDR      R1,[SP, #+104]
   \      0x27C   0x600C             STR      R4,[R1, #+0]
   1714              *buf = p;
   \      0x27E   0x9819             LDR      R0,[SP, #+100]
   \      0x280   0x6006             STR      R6,[R0, #+0]
   1715          
   1716              return 0;
   \      0x282   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_info_subject_alt_name_25: (+1)
   \      0x284   0xB01B             ADD      SP,SP,#+108
   \      0x286   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1717          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0x464B             MOV      R3,R9
   \        0x4   0x.... 0x....      ADR.W    R2,?_26
   \        0x8   0x4621             MOV      R1,R4
   \        0xA   0x4630             MOV      R0,R6
   \        0xC   0x.... 0x....      B.W      snprintf

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4642             MOV      R2,R8
   \                     ??Subroutine8_0: (+1)
   \        0x2   0x4621             MOV      R1,R4
   \                     ??Subroutine8_1: (+1)
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x.... 0x....      B.W      snprintf
   1718          
   1719          #define PRINT_ITEM(i)                                   \
   1720              do {                                                \
   1721                  ret = mbedtls_snprintf(p, n, "%s" i, sep);      \
   1722                  MBEDTLS_X509_SAFE_SNPRINTF;                     \
   1723                  sep = ", ";                                     \
   1724              } while (0)
   1725          
   1726          #define CERT_TYPE(type, name)                           \
   1727              do {                                                \
   1728                  if (ns_cert_type & (type)) {                    \
   1729                      PRINT_ITEM(name);                           \
   1730                  }                                               \
   1731              } while (0)
   1732          

   \                                 In section .text, align 4, keep-with-next
   1733          int mbedtls_x509_info_cert_type(char **buf, size_t *size,
   1734                                          unsigned char ns_cert_type)
   1735          {
   \                     mbedtls_x509_info_cert_type: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine4
   1736              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1737              size_t n = *size;
   1738              char *p = *buf;
   1739              const char *sep = "";
   1740          
   1741              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         "SSL Client");
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x8   0xD509             BPL.N    ??CrossCallReturnLabel_51
   \        0xA   0x.... 0x....      ADR.W    R2,?_30
   \        0xE   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD455             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0x16   0x42B0             CMP      R0,R6
   \       0x18   0xD253             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0x1A   0x.... 0x....      BL       ?Subroutine14
   1742              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER,         "SSL Server");
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x1E   0x0668             LSLS     R0,R5,#+25
   \       0x20   0xD509             BPL.N    ??CrossCallReturnLabel_52
   \       0x22   0x.... 0x....      ADR.W    R2,?_31
   \       0x26   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD449             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0x2E   0x42B0             CMP      R0,R6
   \       0x30   0xD247             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0x32   0x.... 0x....      BL       ?Subroutine14
   1743              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_EMAIL,              "Email");
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x36   0x06A8             LSLS     R0,R5,#+26
   \       0x38   0xD509             BPL.N    ??CrossCallReturnLabel_53
   \       0x3A   0x.... 0x....      ADR.W    R2,?_32
   \       0x3E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD43D             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0x46   0x42B0             CMP      R0,R6
   \       0x48   0xD23B             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0x4A   0x.... 0x....      BL       ?Subroutine14
   1744              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING,     "Object Signing");
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x4E   0x06E8             LSLS     R0,R5,#+27
   \       0x50   0xD509             BPL.N    ??CrossCallReturnLabel_54
   \       0x52   0x.... 0x....      ADR.W    R2,?_33
   \       0x56   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD431             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0x5E   0x42B0             CMP      R0,R6
   \       0x60   0xD22F             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0x62   0x.... 0x....      BL       ?Subroutine14
   1745              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_RESERVED,           "Reserved");
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0x66   0x0728             LSLS     R0,R5,#+28
   \       0x68   0xD509             BPL.N    ??CrossCallReturnLabel_55
   \       0x6A   0x.... 0x....      ADR.W    R2,?_34
   \       0x6E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD425             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0x76   0x42B0             CMP      R0,R6
   \       0x78   0xD223             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0x7A   0x.... 0x....      BL       ?Subroutine14
   1746              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_SSL_CA,             "SSL CA");
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0x7E   0x0768             LSLS     R0,R5,#+29
   \       0x80   0xD509             BPL.N    ??CrossCallReturnLabel_56
   \       0x82   0x.... 0x....      ADR.W    R2,?_35
   \       0x86   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD419             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0x8E   0x42B0             CMP      R0,R6
   \       0x90   0xD217             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0x92   0x.... 0x....      BL       ?Subroutine14
   1747              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA,           "Email CA");
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x96   0x07A8             LSLS     R0,R5,#+30
   \       0x98   0xD509             BPL.N    ??CrossCallReturnLabel_57
   \       0x9A   0x.... 0x....      ADR.W    R2,?_36
   \       0x9E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD40D             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0xA6   0x42B0             CMP      R0,R6
   \       0xA8   0xD20B             BCS.N    ??mbedtls_x509_info_cert_type_0
   \       0xAA   0x.... 0x....      BL       ?Subroutine14
   1748              CERT_TYPE(MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA,  "Object Signing CA");
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0xAE   0x07E8             LSLS     R0,R5,#+31
   \       0xB0   0xD50B             BPL.N    ??mbedtls_x509_info_cert_type_1
   \       0xB2   0xBF00             Nop
   \       0xB4   0x....             ADR.N    R2,?_37
   \       0xB6   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD401             BMI.N    ??mbedtls_x509_info_cert_type_0
   \       0xBE   0x42B0             CMP      R0,R6
   \       0xC0   0xD301             BCC.N    ??mbedtls_x509_info_cert_type_2
   \                     ??mbedtls_x509_info_cert_type_0: (+1)
   \       0xC2   0x....             LDR.N    R0,??DataTable60_2
   \       0xC4   0xE005             B.N      ??mbedtls_x509_info_cert_type_3
   \                     ??mbedtls_x509_info_cert_type_2: (+1)
   \       0xC6   0x1A36             SUBS     R6,R6,R0
   \       0xC8   0x4480             ADD      R8,R8,R0
   1749          
   1750              *size = n;
   \                     ??mbedtls_x509_info_cert_type_1: (+1)
   \       0xCA   0x6026             STR      R6,[R4, #+0]
   1751              *buf = p;
   \       0xCC   0xF8C9 0x8000      STR      R8,[R9, #+0]
   1752          
   1753              return 0;
   \       0xD0   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_info_cert_type_3: (+1)
   \       0xD2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1754          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x1A36             SUBS     R6,R6,R0
   \        0x2   0x4480             ADD      R8,R8,R0
   \        0x4   0x463B             MOV      R3,R7
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4631             MOV      R1,R6
   \        0x2   0x4640             MOV      R0,R8
   \        0x4   0x.... 0x....      B.W      snprintf

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4681             MOV      R9,R0
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x6826             LDR      R6,[R4, #+0]
   \        0x8   0xF8D9 0x8000      LDR      R8,[R9, #+0]
   \        0xC   0x....             ADR.N    R3,??DataTable60_3
   \        0xE   0x....             ADR.N    R7,??DataTable60_4
   \       0x10   0x0628             LSLS     R0,R5,#+24
   \       0x12   0x4770             BX       LR
   1755          
   1756          #define KEY_USAGE(code, name)       \
   1757              do {                            \
   1758                  if ((key_usage) & (code)) { \
   1759                      PRINT_ITEM(name);       \
   1760                  }                           \
   1761              } while (0)
   1762          

   \                                 In section .text, align 4, keep-with-next
   1763          int mbedtls_x509_info_key_usage(char **buf, size_t *size,
   1764                                          unsigned int key_usage)
   1765          {
   \                     mbedtls_x509_info_key_usage: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine4
   1766              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1767              size_t n = *size;
   1768              char *p = *buf;
   1769              const char *sep = "";
   1770          
   1771              KEY_USAGE(MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    "Digital Signature");
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x8   0xD509             BPL.N    ??CrossCallReturnLabel_58
   \        0xA   0xBF00             Nop
   \        0xC   0x....             ADR.N    R2,?_38
   \        0xE   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD461             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0x16   0x42B0             CMP      R0,R6
   \       0x18   0xD25F             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0x1A   0x.... 0x....      BL       ?Subroutine14
   1772              KEY_USAGE(MBEDTLS_X509_KU_NON_REPUDIATION,      "Non Repudiation");
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x1E   0x0668             LSLS     R0,R5,#+25
   \       0x20   0xD509             BPL.N    ??CrossCallReturnLabel_59
   \       0x22   0xBF00             Nop
   \       0x24   0x....             ADR.N    R2,?_39
   \       0x26   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD455             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0x2E   0x42B0             CMP      R0,R6
   \       0x30   0xD253             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0x32   0x.... 0x....      BL       ?Subroutine14
   1773              KEY_USAGE(MBEDTLS_X509_KU_KEY_ENCIPHERMENT,     "Key Encipherment");
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x36   0x06A8             LSLS     R0,R5,#+26
   \       0x38   0xD509             BPL.N    ??CrossCallReturnLabel_60
   \       0x3A   0xBF00             Nop
   \       0x3C   0x....             ADR.N    R2,?_40
   \       0x3E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD449             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0x46   0x42B0             CMP      R0,R6
   \       0x48   0xD247             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0x4A   0x.... 0x....      BL       ?Subroutine14
   1774              KEY_USAGE(MBEDTLS_X509_KU_DATA_ENCIPHERMENT,    "Data Encipherment");
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x4E   0x06E8             LSLS     R0,R5,#+27
   \       0x50   0xD509             BPL.N    ??CrossCallReturnLabel_61
   \       0x52   0xBF00             Nop
   \       0x54   0x....             ADR.N    R2,?_41
   \       0x56   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD43D             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0x5E   0x42B0             CMP      R0,R6
   \       0x60   0xD23B             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0x62   0x.... 0x....      BL       ?Subroutine14
   1775              KEY_USAGE(MBEDTLS_X509_KU_KEY_AGREEMENT,        "Key Agreement");
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x66   0x0728             LSLS     R0,R5,#+28
   \       0x68   0xD509             BPL.N    ??CrossCallReturnLabel_62
   \       0x6A   0xBF00             Nop
   \       0x6C   0x....             ADR.N    R2,?_42
   \       0x6E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD431             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0x76   0x42B0             CMP      R0,R6
   \       0x78   0xD22F             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0x7A   0x.... 0x....      BL       ?Subroutine14
   1776              KEY_USAGE(MBEDTLS_X509_KU_KEY_CERT_SIGN,        "Key Cert Sign");
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x7E   0x0768             LSLS     R0,R5,#+29
   \       0x80   0xD509             BPL.N    ??CrossCallReturnLabel_63
   \       0x82   0xBF00             Nop
   \       0x84   0x....             ADR.N    R2,?_43
   \       0x86   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD425             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0x8E   0x42B0             CMP      R0,R6
   \       0x90   0xD223             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0x92   0x.... 0x....      BL       ?Subroutine14
   1777              KEY_USAGE(MBEDTLS_X509_KU_CRL_SIGN,             "CRL Sign");
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x96   0x07A8             LSLS     R0,R5,#+30
   \       0x98   0xD509             BPL.N    ??CrossCallReturnLabel_64
   \       0x9A   0xBF00             Nop
   \       0x9C   0x....             ADR.N    R2,?_44
   \       0x9E   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD419             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0xA6   0x42B0             CMP      R0,R6
   \       0xA8   0xD217             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0xAA   0x.... 0x....      BL       ?Subroutine14
   1778              KEY_USAGE(MBEDTLS_X509_KU_ENCIPHER_ONLY,        "Encipher Only");
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0xAE   0x07E8             LSLS     R0,R5,#+31
   \       0xB0   0xD509             BPL.N    ??CrossCallReturnLabel_65
   \       0xB2   0xBF00             Nop
   \       0xB4   0x....             ADR.N    R2,?_45
   \       0xB6   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD40D             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0xBE   0x42B0             CMP      R0,R6
   \       0xC0   0xD20B             BCS.N    ??mbedtls_x509_info_key_usage_0
   \       0xC2   0x.... 0x....      BL       ?Subroutine14
   1779              KEY_USAGE(MBEDTLS_X509_KU_DECIPHER_ONLY,        "Decipher Only");
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0xC6   0x0428             LSLS     R0,R5,#+16
   \       0xC8   0xD50B             BPL.N    ??mbedtls_x509_info_key_usage_1
   \       0xCA   0xBF00             Nop
   \       0xCC   0x....             ADR.N    R2,?_46
   \       0xCE   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD401             BMI.N    ??mbedtls_x509_info_key_usage_0
   \       0xD6   0x42B0             CMP      R0,R6
   \       0xD8   0xD301             BCC.N    ??mbedtls_x509_info_key_usage_2
   \                     ??mbedtls_x509_info_key_usage_0: (+1)
   \       0xDA   0x....             LDR.N    R0,??DataTable60_2
   \       0xDC   0xE005             B.N      ??mbedtls_x509_info_key_usage_3
   \                     ??mbedtls_x509_info_key_usage_2: (+1)
   \       0xDE   0x1A36             SUBS     R6,R6,R0
   \       0xE0   0x4480             ADD      R8,R8,R0
   1780          
   1781              *size = n;
   \                     ??mbedtls_x509_info_key_usage_1: (+1)
   \       0xE2   0x6026             STR      R6,[R4, #+0]
   1782              *buf = p;
   \       0xE4   0xF8C9 0x8000      STR      R8,[R9, #+0]
   1783          
   1784              return 0;
   \       0xE8   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_info_key_usage_3: (+1)
   \       0xEA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1785          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \        0x0   0x20 0x2B          DC8      " + "          
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_1:
   \        0x0   0x2C 0x20          DC8      0x2C, 0x20, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \        0x0   0x25 0x73          DC8      "%s="          
   \              0x3D 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_1:
   \        0x0   0x3D 0x00          DC8      "=",0x0,0x0    
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_2:
   \        0x0   0x3F 0x3F          DC8      "??="          
   \              0x3D 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \        0x0   0x23 0x20          DC8      0x23, 0x20, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55:
   \        0x0   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_1:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0 
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_2:
   \        0x0   0x3A 0x00          DC8      ":",0x0,0x0    
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_3:
   \        0x0   0x3F 0x3F          DC8      "???"          
   \              0x3F 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \        0x0   0xFFFF'DD20        DC32     0xffffdd20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \        0x0   0xFFFF'DD1E        DC32     0xffffdd1e

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x2128             MOVS     R1,#+40
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \        0x0   0xFFFF'DC20        DC32     0xffffdc20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_1:
   \        0x0   0xFFFF'DC1E        DC32     0xffffdc1e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_2:
   \        0x0   0xFFFF'DC1A        DC32     0xffffdc1a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_3:
   \        0x0   0xFFFF'D780        DC32     0xffffd780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_4:
   \        0x0   0xFFFF'DBA0        DC32     0xffffdba0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_5:
   \        0x0   0xFFFF'DB9E        DC32     0xffffdb9e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_6:
   \        0x0   0xFFFF'DC00        DC32     0xffffdc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \        0x0   0xFFFF'DB20        DC32     0xffffdb20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_1:
   \        0x0   0xFFFF'D800        DC32     0xffffd800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60:
   \        0x0   0xFFFF'DD00        DC32     0xffffdd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_1:
   \        0x0   0xFFFF'DC80        DC32     0xffffdc80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_2:
   \        0x0   0xFFFF'D680        DC32     0xffffd680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_3:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0 
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_4:
   \        0x0   0x2C 0x20          DC8      0x2C, 0x20, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_5:
   \        0x0   0xFFFF'DA9E        DC32     0xffffda9e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_6:
   \        0x0   0xFFFF'DB00        DC32     0xffffdb00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_7:
   \        0x0   0xFFFF'DA96        DC32     0xffffda96

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_8:
   \        0x0   0xFFFF'DA9A        DC32     0xffffda9a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_9:
   \        0x0   0xFFFF'DA9C        DC32     0xffffda9c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_10:
   \        0x0   0xFFFF'DF80        DC32     0xffffdf80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_11:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x2C 0x3D          DC8 ",=+<>;\"\\"
   \              0x2B 0x3C    
   \              0x3E 0x3B    
   \              0x22 0x5C    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x25 0x30          DC8 "%02X%s"
   \              0x32 0x58    
   \              0x25 0x73    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x2E 0x2E          DC8 "...."
   \              0x2E 0x2E    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x25 0x73          DC8 "%s key size"
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \        0x0   0x2B 0x06          DC8 "+\006\001\005\005\007\010\004"
   \              0x01 0x05    
   \              0x05 0x07    
   \              0x08 0x04    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0A 0x25          DC8 "\012%s        hardware module name :"
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x68    
   \              0x61 0x72    
   \              0x64 0x77    
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x6D 0x6F    
   \              0x64 0x75    
   \              0x6C 0x65    
   \              0x20 0x6E    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x3A 0x00
   \       0x22                      DS8 2
   \       0x24   0x0A 0x25          DC8 "\012%s            hardware type          : "
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x68    
   \              0x61 0x72    
   \              0x64 0x77    
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x74 0x79    
   \              0x70 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x00
   \       0x4D                      DS8 3
   \       0x50   0x0A 0x25          DC8 "\012%s            hardware serial number : "
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x68    
   \              0x61 0x72    
   \              0x64 0x77    
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x73 0x65    
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x6E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x3A 0x20    
   \              0x00
   \       0x79                      DS8 3
   \       0x7C   0x0A 0x25          DC8 "\012%s    uniformResourceIdentifier : "
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x75    
   \              0x6E 0x69    
   \              0x66 0x6F    
   \              0x72 0x6D    
   \              0x52 0x65    
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x49 0x64    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x66 0x69    
   \              0x65 0x72    
   \              0x20 0x3A    
   \              0x20 0x00
   \       0xA0   0x25 0x58          DC8 "%X%X:%X%X:%X%X:%X%X:%X%X:%X%X:%X%X:%X%X"
   \              0x25 0x58    
   \              0x3A 0x25    
   \              0x58 0x25    
   \              0x58 0x3A    
   \              0x25 0x58    
   \              0x25 0x58    
   \              0x3A 0x25    
   \              0x58 0x25    
   \              0x58 0x3A    
   \              0x25 0x58    
   \              0x25 0x58    
   \              0x3A 0x25    
   \              0x58 0x25    
   \              0x58 0x3A    
   \              0x25 0x58    
   \              0x25 0x58    
   \              0x3A 0x25    
   \              0x58 0x25    
   \              0x58 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x20 0x2B          DC8 " + "
   \              0x20 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x2C 0x20          DC8 ", "
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x25 0x73          DC8 "%s="
   \              0x3D 0x00

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_8:
   \        0x0   0x3D 0x00          DC8 "="

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x3F 0x3F          DC8 "??="
   \              0x3D 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x23 0x20          DC8 "# "
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x25 0x73          DC8 "%s"
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_14:
   \        0x0   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_15:
   \        0x0   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x3F 0x3F          DC8 "???"
   \              0x3F 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x0A 0x25          DC8 "\012%s    <unsupported>"
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x3C    
   \              0x75 0x6E    
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6F 0x72    
   \              0x74 0x65    
   \              0x64 0x3E    
   \              0x00
   \       0x15                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x0A 0x25          DC8 "\012%s    <malformed>"
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x3C    
   \              0x6D 0x61    
   \              0x6C 0x66    
   \              0x6F 0x72    
   \              0x6D 0x65    
   \              0x64 0x3E    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \        0x0   0x0A 0x25          DC8 "\012%s    otherName :"
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x6F    
   \              0x74 0x68    
   \              0x65 0x72    
   \              0x4E 0x61    
   \              0x6D 0x65    
   \              0x20 0x3A    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \        0x0   0x25 0x30          DC8 "%02X"
   \              0x32 0x58    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \        0x0   0x64 0x4E          DC8 "dNSName"
   \              0x53 0x4E    
   \              0x61 0x6D    
   \              0x65 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \        0x0   0x72 0x66          DC8 "rfc822Name"
   \              0x63 0x38    
   \              0x32 0x32    
   \              0x4E 0x61    
   \              0x6D 0x65    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \        0x0   0x0A 0x25          DC8 "\012%s    %s : "
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x3A 0x20    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \        0x0   0x69 0x50          DC8 "iPAddress"
   \              0x41 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \        0x0   0x25 0x75          DC8 "%u.%u.%u.%u"
   \              0x2E 0x25    
   \              0x75 0x2E    
   \              0x25 0x75    
   \              0x2E 0x25    
   \              0x75 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \        0x0   0x0A 0x25          DC8 "\012%s    directoryName : "
   \              0x73 0x20    
   \              0x20 0x20    
   \              0x20 0x64    
   \              0x69 0x72    
   \              0x65 0x63    
   \              0x74 0x6F    
   \              0x72 0x79    
   \              0x4E 0x61    
   \              0x6D 0x65    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_30:
   \        0x0   0x25 0x73          DC8 "%sSSL Client"
   \              0x53 0x53    
   \              0x4C 0x20    
   \              0x43 0x6C    
   \              0x69 0x65    
   \              0x6E 0x74    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \        0x0   0x25 0x73          DC8 "%sSSL Server"
   \              0x53 0x53    
   \              0x4C 0x20    
   \              0x53 0x65    
   \              0x72 0x76    
   \              0x65 0x72    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \        0x0   0x25 0x73          DC8 "%sEmail"
   \              0x45 0x6D    
   \              0x61 0x69    
   \              0x6C 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \        0x0   0x25 0x73          DC8 "%sObject Signing"
   \              0x4F 0x62    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x20 0x53    
   \              0x69 0x67    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x00
   \       0x11                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \        0x0   0x25 0x73          DC8 "%sReserved"
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x72 0x76    
   \              0x65 0x64    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \        0x0   0x25 0x73          DC8 "%sSSL CA"
   \              0x53 0x53    
   \              0x4C 0x20    
   \              0x43 0x41    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \        0x0   0x25 0x73          DC8 "%sEmail CA"
   \              0x45 0x6D    
   \              0x61 0x69    
   \              0x6C 0x20    
   \              0x43 0x41    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_37:
   \        0x0   0x25 0x73          DC8 "%sObject Signing CA"
   \              0x4F 0x62    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x20 0x53    
   \              0x69 0x67    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x43    
   \              0x41 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \        0x0   0x25 0x73          DC8 "%sDigital Signature"
   \              0x44 0x69    
   \              0x67 0x69    
   \              0x74 0x61    
   \              0x6C 0x20    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x61 0x74    
   \              0x75 0x72    
   \              0x65 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_39:
   \        0x0   0x25 0x73          DC8 "%sNon Repudiation"
   \              0x4E 0x6F    
   \              0x6E 0x20    
   \              0x52 0x65    
   \              0x70 0x75    
   \              0x64 0x69    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x00
   \       0x12                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_40:
   \        0x0   0x25 0x73          DC8 "%sKey Encipherment"
   \              0x4B 0x65    
   \              0x79 0x20    
   \              0x45 0x6E    
   \              0x63 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_41:
   \        0x0   0x25 0x73          DC8 "%sData Encipherment"
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x20 0x45    
   \              0x6E 0x63    
   \              0x69 0x70    
   \              0x68 0x65    
   \              0x72 0x6D    
   \              0x65 0x6E    
   \              0x74 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_42:
   \        0x0   0x25 0x73          DC8 "%sKey Agreement"
   \              0x4B 0x65    
   \              0x79 0x20    
   \              0x41 0x67    
   \              0x72 0x65    
   \              0x65 0x6D    
   \              0x65 0x6E    
   \              0x74 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_43:
   \        0x0   0x25 0x73          DC8 "%sKey Cert Sign"
   \              0x4B 0x65    
   \              0x79 0x20    
   \              0x43 0x65    
   \              0x72 0x74    
   \              0x20 0x53    
   \              0x69 0x67    
   \              0x6E 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_44:
   \        0x0   0x25 0x73          DC8 "%sCRL Sign"
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_45:
   \        0x0   0x25 0x73          DC8 "%sEncipher Only"
   \              0x45 0x6E    
   \              0x63 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x20 0x4F    
   \              0x6E 0x6C    
   \              0x79 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_46:
   \        0x0   0x25 0x73          DC8 "%sDecipher Only"
   \              0x44 0x65    
   \              0x63 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x20 0x4F    
   \              0x6E 0x6C    
   \              0x79 0x00
   1786          #endif /* MBEDTLS_X509_REMOVE_INFO */
   1787          #endif /* MBEDTLS_X509_CRT_PARSE_C || MBEDTLS_X509_CSR_PARSE_C */
   1788          #endif /* MBEDTLS_X509_USE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     328   mbedtls_x509_dn_gets
       328   -> __aeabi_memclr4
       328   -> mbedtls_asn1_write_len
       328   -> mbedtls_asn1_write_tag
       328   -> mbedtls_oid_get_attr_short_name
       328   -> mbedtls_oid_get_numeric_string
       328   -> nibble_to_hex_digit
       328   -> snprintf
       328   -> strchr
       0   mbedtls_x509_free_subject_alt_name
         0   -> mbedtls_asn1_free_named_data_list_shallow
       8   mbedtls_x509_get_alg
         8   -> mbedtls_asn1_get_alg
       8   mbedtls_x509_get_alg_null
         8   -> mbedtls_asn1_get_alg_null
      24   mbedtls_x509_get_ext
        24   -> mbedtls_asn1_get_tag
      32   mbedtls_x509_get_key_usage
        32   -> mbedtls_asn1_get_bitstring
      40   mbedtls_x509_get_name
        40   -> mbedtls_asn1_free_named_data_list_shallow
        40   -> mbedtls_asn1_get_len
        40   -> mbedtls_asn1_get_tag
        40   -> sl_calloc
      32   mbedtls_x509_get_ns_cert_type
        32   -> mbedtls_asn1_get_bitstring
      16   mbedtls_x509_get_serial
        16   -> mbedtls_asn1_get_len
      24   mbedtls_x509_get_sig
        24   -> mbedtls_asn1_get_bitstring_null
       8   mbedtls_x509_get_sig_alg
         8   -> mbedtls_oid_get_sig_alg
      24   mbedtls_x509_get_subject_alt_name
        24   -> mbedtls_asn1_get_tag
        24   -> mbedtls_x509_get_subject_alt_name_ext
      80   mbedtls_x509_get_subject_alt_name_ext
        80   -> __aeabi_memclr4
        80   -> mbedtls_asn1_get_len
        80   -> mbedtls_asn1_sequence_free
        80   -> mbedtls_x509_free_subject_alt_name
        80   -> mbedtls_x509_parse_subject_alt_name
        80   -> sl_calloc
      32   mbedtls_x509_get_time
        32   -> mbedtls_asn1_get_len
        32   -> x509_parse2_int
      32   mbedtls_x509_info_cert_type
        32   -> snprintf
      32   mbedtls_x509_info_key_usage
        32   -> snprintf
     144   mbedtls_x509_info_subject_alt_name
       144   -> __aeabi_memclr4
       144   -> __aeabi_memcpy
       144   -> mbedtls_oid_get_numeric_string
       144   -> mbedtls_x509_dn_gets
       144   -> mbedtls_x509_free_subject_alt_name
       144   -> mbedtls_x509_parse_subject_alt_name
       144   -> memcmp
       144   -> snprintf
       8   mbedtls_x509_key_size_helper
         8   -> snprintf
      64   mbedtls_x509_parse_subject_alt_name
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy4
        64   -> mbedtls_asn1_get_tag
        64   -> mbedtls_x509_get_name
        64   -> memcmp
      40   mbedtls_x509_serial_gets
        40   -> snprintf
      16   mbedtls_x509_sig_alg_gets
        16   -> mbedtls_oid_get_sig_alg_desc
        16   -> snprintf
       8   mbedtls_x509_time_cmp
       0   mbedtls_x509_time_is_future
       0   mbedtls_x509_time_is_past
       0   nibble_to_hex_digit
       0   x509_parse2_int


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable52_2
       4  ??DataTable53
       4  ??DataTable55
       4  ??DataTable55_1
       4  ??DataTable55_2
       4  ??DataTable55_3
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable57_2
       4  ??DataTable57_3
       4  ??DataTable57_4
       4  ??DataTable57_5
       4  ??DataTable57_6
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable60
       4  ??DataTable60_1
       4  ??DataTable60_10
       4  ??DataTable60_11
       4  ??DataTable60_2
       4  ??DataTable60_3
       4  ??DataTable60_4
       4  ??DataTable60_5
       4  ??DataTable60_6
       4  ??DataTable60_7
       4  ??DataTable60_8
       4  ??DataTable60_9
       8  ?Subroutine0
       6  ?Subroutine1
      20  ?Subroutine10
      16  ?Subroutine11
       8  ?Subroutine12
       8  ?Subroutine13
       8  ?Subroutine14
       6  ?Subroutine2
       6  ?Subroutine3
      20  ?Subroutine4
      12  ?Subroutine5
       8  ?Subroutine6
      12  ?Subroutine7
      10  ?Subroutine8
       8  ?Subroutine9
     200  ?_0
      12  ?_10
       4  ?_11
       4  ?_12
       8  ?_13
       2  ?_14
       1  ?_15
       8  ?_16
       4  ?_17
      12  ?_18
      12  ?_19
      24  ?_20
      20  ?_21
      20  ?_22
       8  ?_23
       8  ?_24
      12  ?_25
      16  ?_26
      12  ?_27
      12  ?_28
      24  ?_29
      16  ?_30
      16  ?_31
       8  ?_32
      20  ?_33
      12  ?_34
      12  ?_35
      12  ?_36
      20  ?_37
      20  ?_38
      20  ?_39
      20  ?_40
      20  ?_41
      16  ?_42
      16  ?_43
      12  ?_44
      16  ?_45
      16  ?_46
      12  ?_47
      12  ?_48
       4  ?_5
       4  ?_6
       4  ?_7
       2  ?_8
       4  ?_9
     572  mbedtls_x509_dn_gets
      14  mbedtls_x509_free_subject_alt_name
       6  mbedtls_x509_get_alg
       8  mbedtls_x509_get_alg_null
      62  mbedtls_x509_get_ext
      54  mbedtls_x509_get_key_usage
     280  mbedtls_x509_get_name
      38  mbedtls_x509_get_ns_cert_type
      70  mbedtls_x509_get_serial
      58  mbedtls_x509_get_sig
      52  mbedtls_x509_get_sig_alg
      42  mbedtls_x509_get_subject_alt_name
     190  mbedtls_x509_get_subject_alt_name_ext
     326  mbedtls_x509_get_time
     214  mbedtls_x509_info_cert_type
     238  mbedtls_x509_info_key_usage
     650  mbedtls_x509_info_subject_alt_name
      32  mbedtls_x509_key_size_helper
     394  mbedtls_x509_parse_subject_alt_name
     132  mbedtls_x509_serial_gets
      58  mbedtls_x509_sig_alg_gets
      68  mbedtls_x509_time_cmp
       4  mbedtls_x509_time_is_future
       4  mbedtls_x509_time_is_past
      12  nibble_to_hex_digit
      32  x509_parse2_int

 
   257 bytes in section .rodata
 4'378 bytes in section .text
 
 4'378 bytes of CODE  memory
   257 bytes of CONST memory

Errors: none
Warnings: none
