###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:30
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pem.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pem.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pem.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pem.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\pem.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pem.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pem.c
      1          /*
      2           *  Privacy Enhanced Mail (PEM) decoding
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)
     23          
     24          #include "mbedtls/pem.h"
     25          #include "mbedtls/base64.h"
     26          #include "mbedtls/des.h"
     27          #include "mbedtls/aes.h"
     28          #include "mbedtls/md.h"
     29          #include "mbedtls/cipher.h"
     30          #include "mbedtls/platform_util.h"
     31          #include "mbedtls/error.h"
     32          
     33          #include <string.h>
     34          
     35          #include "mbedtls/platform.h"
     36          
     37          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     38          #include "psa/crypto.h"
     39          #endif
     40          
     41          #if defined(MBEDTLS_MD_CAN_MD5) &&  \
     42              defined(MBEDTLS_CIPHER_MODE_CBC) &&                             \
     43              (defined(MBEDTLS_DES_C) || defined(MBEDTLS_AES_C))
     44          #define PEM_RFC1421
     45          #endif /* MBEDTLS_MD_CAN_MD5 &&
     46                    MBEDTLS_CIPHER_MODE_CBC &&
     47                    ( MBEDTLS_AES_C || MBEDTLS_DES_C ) */
     48          
     49          #if defined(MBEDTLS_PEM_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
     50          void mbedtls_pem_init(mbedtls_pem_context *ctx)
     51          {
     52              memset(ctx, 0, sizeof(mbedtls_pem_context));
   \                     mbedtls_pem_init: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0xE880 0x000E      STM      R0,{R1-R3}
     53          }
   \        0xA   0x4770             BX       LR
     54          
     55          #if defined(PEM_RFC1421)
     56          /*
     57           * Read a 16-byte hex string and convert it to binary
     58           */
     59          static int pem_get_iv(const unsigned char *s, unsigned char *iv,
     60                                size_t iv_len)
     61          {
     62              size_t i, j, k;
     63          
     64              memset(iv, 0, iv_len);
     65          
     66              for (i = 0; i < iv_len * 2; i++, s++) {
     67                  if (*s >= '0' && *s <= '9') {
     68                      j = *s - '0';
     69                  } else
     70                  if (*s >= 'A' && *s <= 'F') {
     71                      j = *s - '7';
     72                  } else
     73                  if (*s >= 'a' && *s <= 'f') {
     74                      j = *s - 'W';
     75                  } else {
     76                      return MBEDTLS_ERR_PEM_INVALID_ENC_IV;
     77                  }
     78          
     79                  k = ((i & 1) != 0) ? j : j << 4;
     80          
     81                  iv[i >> 1] = (unsigned char) (iv[i >> 1] | k);
     82              }
     83          
     84              return 0;
     85          }
     86          
     87          static int pem_pbkdf1(unsigned char *key, size_t keylen,
     88                                unsigned char *iv,
     89                                const unsigned char *pwd, size_t pwdlen)
     90          {
     91              mbedtls_md_context_t md5_ctx;
     92              const mbedtls_md_info_t *md5_info;
     93              unsigned char md5sum[16];
     94              size_t use_len;
     95              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     96          
     97              mbedtls_md_init(&md5_ctx);
     98          
     99              /* Prepare the context. (setup() errors gracefully on NULL info.) */
    100              md5_info = mbedtls_md_info_from_type(MBEDTLS_MD_MD5);
    101              if ((ret = mbedtls_md_setup(&md5_ctx, md5_info, 0)) != 0) {
    102                  goto exit;
    103              }
    104          
    105              /*
    106               * key[ 0..15] = MD5(pwd || IV)
    107               */
    108              if ((ret = mbedtls_md_starts(&md5_ctx)) != 0) {
    109                  goto exit;
    110              }
    111              if ((ret = mbedtls_md_update(&md5_ctx, pwd, pwdlen)) != 0) {
    112                  goto exit;
    113              }
    114              if ((ret = mbedtls_md_update(&md5_ctx, iv,  8)) != 0) {
    115                  goto exit;
    116              }
    117              if ((ret = mbedtls_md_finish(&md5_ctx, md5sum)) != 0) {
    118                  goto exit;
    119              }
    120          
    121              if (keylen <= 16) {
    122                  memcpy(key, md5sum, keylen);
    123                  goto exit;
    124              }
    125          
    126              memcpy(key, md5sum, 16);
    127          
    128              /*
    129               * key[16..23] = MD5(key[ 0..15] || pwd || IV])
    130               */
    131              if ((ret = mbedtls_md_starts(&md5_ctx)) != 0) {
    132                  goto exit;
    133              }
    134              if ((ret = mbedtls_md_update(&md5_ctx, md5sum, 16)) != 0) {
    135                  goto exit;
    136              }
    137              if ((ret = mbedtls_md_update(&md5_ctx, pwd, pwdlen)) != 0) {
    138                  goto exit;
    139              }
    140              if ((ret = mbedtls_md_update(&md5_ctx, iv, 8)) != 0) {
    141                  goto exit;
    142              }
    143              if ((ret = mbedtls_md_finish(&md5_ctx, md5sum)) != 0) {
    144                  goto exit;
    145              }
    146          
    147              use_len = 16;
    148              if (keylen < 32) {
    149                  use_len = keylen - 16;
    150              }
    151          
    152              memcpy(key + 16, md5sum, use_len);
    153          
    154          exit:
    155              mbedtls_md_free(&md5_ctx);
    156              mbedtls_platform_zeroize(md5sum, 16);
    157          
    158              return ret;
    159          }
    160          
    161          #if defined(MBEDTLS_DES_C)
    162          /*
    163           * Decrypt with DES-CBC, using PBKDF1 for key derivation
    164           */
    165          static int pem_des_decrypt(unsigned char des_iv[8],
    166                                     unsigned char *buf, size_t buflen,
    167                                     const unsigned char *pwd, size_t pwdlen)
    168          {
    169              mbedtls_des_context des_ctx;
    170              unsigned char des_key[8];
    171              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    172          
    173              mbedtls_des_init(&des_ctx);
    174          
    175              if ((ret = pem_pbkdf1(des_key, 8, des_iv, pwd, pwdlen)) != 0) {
    176                  goto exit;
    177              }
    178          
    179              if ((ret = mbedtls_des_setkey_dec(&des_ctx, des_key)) != 0) {
    180                  goto exit;
    181              }
    182              ret = mbedtls_des_crypt_cbc(&des_ctx, MBEDTLS_DES_DECRYPT, buflen,
    183                                          des_iv, buf, buf);
    184          
    185          exit:
    186              mbedtls_des_free(&des_ctx);
    187              mbedtls_platform_zeroize(des_key, 8);
    188          
    189              return ret;
    190          }
    191          
    192          /*
    193           * Decrypt with 3DES-CBC, using PBKDF1 for key derivation
    194           */
    195          static int pem_des3_decrypt(unsigned char des3_iv[8],
    196                                      unsigned char *buf, size_t buflen,
    197                                      const unsigned char *pwd, size_t pwdlen)
    198          {
    199              mbedtls_des3_context des3_ctx;
    200              unsigned char des3_key[24];
    201              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    202          
    203              mbedtls_des3_init(&des3_ctx);
    204          
    205              if ((ret = pem_pbkdf1(des3_key, 24, des3_iv, pwd, pwdlen)) != 0) {
    206                  goto exit;
    207              }
    208          
    209              if ((ret = mbedtls_des3_set3key_dec(&des3_ctx, des3_key)) != 0) {
    210                  goto exit;
    211              }
    212              ret = mbedtls_des3_crypt_cbc(&des3_ctx, MBEDTLS_DES_DECRYPT, buflen,
    213                                           des3_iv, buf, buf);
    214          
    215          exit:
    216              mbedtls_des3_free(&des3_ctx);
    217              mbedtls_platform_zeroize(des3_key, 24);
    218          
    219              return ret;
    220          }
    221          #endif /* MBEDTLS_DES_C */
    222          
    223          #if defined(MBEDTLS_AES_C)
    224          /*
    225           * Decrypt with AES-XXX-CBC, using PBKDF1 for key derivation
    226           */
    227          static int pem_aes_decrypt(unsigned char aes_iv[16], unsigned int keylen,
    228                                     unsigned char *buf, size_t buflen,
    229                                     const unsigned char *pwd, size_t pwdlen)
    230          {
    231              mbedtls_aes_context aes_ctx;
    232              unsigned char aes_key[32];
    233              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    234          
    235              mbedtls_aes_init(&aes_ctx);
    236          
    237              if ((ret = pem_pbkdf1(aes_key, keylen, aes_iv, pwd, pwdlen)) != 0) {
    238                  goto exit;
    239              }
    240          
    241              if ((ret = mbedtls_aes_setkey_dec(&aes_ctx, aes_key, keylen * 8)) != 0) {
    242                  goto exit;
    243              }
    244              ret = mbedtls_aes_crypt_cbc(&aes_ctx, MBEDTLS_AES_DECRYPT, buflen,
    245                                          aes_iv, buf, buf);
    246          
    247          exit:
    248              mbedtls_aes_free(&aes_ctx);
    249              mbedtls_platform_zeroize(aes_key, keylen);
    250          
    251              return ret;
    252          }
    253          #endif /* MBEDTLS_AES_C */
    254          
    255          #endif /* PEM_RFC1421 */
    256          

   \                                 In section .text, align 4, keep-with-next
    257          int mbedtls_pem_read_buffer(mbedtls_pem_context *ctx, const char *header, const char *footer,
    258                                      const unsigned char *data, const unsigned char *pwd,
    259                                      size_t pwdlen, size_t *use_len)
    260          {
   \                     mbedtls_pem_read_buffer: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x4699             MOV      R9,R3
    261              int ret, enc;
    262              size_t len;
    263              unsigned char *buf;
    264              const unsigned char *s1, *s2, *end;
    265          #if defined(PEM_RFC1421)
    266              unsigned char pem_iv[16];
    267              mbedtls_cipher_type_t enc_alg = MBEDTLS_CIPHER_NONE;
    268          #else
    269              ((void) pwd);
    270              ((void) pwdlen);
    271          #endif /* PEM_RFC1421 */
    272          
    273              if (ctx == NULL) {
   \        0xC   0xBF08             IT       EQ
   \        0xE   0x....             LDREQ.N  R0,??DataTable3
    274                  return MBEDTLS_ERR_PEM_BAD_INPUT_DATA;
   \       0x10   0xD06A             BEQ.N    ??mbedtls_pem_read_buffer_0
    275              }
    276          
    277              s1 = (unsigned char *) strstr((const char *) data, header);
   \       0x12   0x4648             MOV      R0,R9
   \       0x14   0x.... 0x....      BL       strstr
   \       0x18   0x0005             MOVS     R5,R0
    278          
    279              if (s1 == NULL) {
   \       0x1A   0xD038             BEQ.N    ??mbedtls_pem_read_buffer_1
    280                  return MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
    281              }
    282          
    283              s2 = (unsigned char *) strstr((const char *) data, footer);
   \       0x1C   0x4651             MOV      R1,R10
   \       0x1E   0x4648             MOV      R0,R9
   \       0x20   0x.... 0x....      BL       strstr
   \       0x24   0x0006             MOVS     R6,R0
    284          
    285              if (s2 == NULL || s2 <= s1) {
   \       0x26   0xD032             BEQ.N    ??mbedtls_pem_read_buffer_1
   \       0x28   0x46B0             MOV      R8,R6
   \       0x2A   0x4545             CMP      R5,R8
   \       0x2C   0xD22F             BCS.N    ??mbedtls_pem_read_buffer_1
    286                  return MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
    287              }
    288          
    289              s1 += strlen(header);
   \       0x2E   0x4638             MOV      R0,R7
   \       0x30   0x.... 0x....      BL       strlen
   \       0x34   0x182F             ADDS     R7,R5,R0
    290              if (*s1 == ' ') {
   \       0x36   0x7838             LDRB     R0,[R7, #+0]
   \       0x38   0x2820             CMP      R0,#+32
   \       0x3A   0xBF08             IT       EQ
   \       0x3C   0x1C7F             ADDEQ    R7,R7,#+1
    291                  s1++;
    292              }
    293              if (*s1 == '\r') {
   \       0x3E   0x7838             LDRB     R0,[R7, #+0]
   \       0x40   0x280D             CMP      R0,#+13
   \       0x42   0xBF08             IT       EQ
   \       0x44   0x1C7F             ADDEQ    R7,R7,#+1
    294                  s1++;
    295              }
    296              if (*s1 == '\n') {
   \       0x46   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \       0x4A   0x280A             CMP      R0,#+10
   \       0x4C   0xD11F             BNE.N    ??mbedtls_pem_read_buffer_1
    297                  s1++;
    298              } else {
    299                  return MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
    300              }
    301          
    302              end = s2;
    303              end += strlen(footer);
   \       0x4E   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x52   0x4430             ADD      R0,R6,R0
    304              if (*end == ' ') {
   \       0x54   0x7801             LDRB     R1,[R0, #+0]
   \       0x56   0x2920             CMP      R1,#+32
   \       0x58   0xBF08             IT       EQ
   \       0x5A   0x1C40             ADDEQ    R0,R0,#+1
    305                  end++;
    306              }
    307              if (*end == '\r') {
   \       0x5C   0x7801             LDRB     R1,[R0, #+0]
   \       0x5E   0x290D             CMP      R1,#+13
   \       0x60   0xBF08             IT       EQ
   \       0x62   0x1C40             ADDEQ    R0,R0,#+1
    308                  end++;
    309              }
    310              if (*end == '\n') {
   \       0x64   0x7801             LDRB     R1,[R0, #+0]
   \       0x66   0x290A             CMP      R1,#+10
   \       0x68   0xBF08             IT       EQ
   \       0x6A   0x1C40             ADDEQ    R0,R0,#+1
    311                  end++;
   \       0x6C   0x990C             LDR      R1,[SP, #+48]
    312              }
    313              *use_len = end - data;
   \       0x6E   0xEBA0 0x0009      SUB      R0,R0,R9
    314          
    315              enc = 0;
    316          
    317              if (s2 - s1 >= 22 && memcmp(s1, "Proc-Type: 4,ENCRYPTED", 22) == 0) {
   \       0x72   0xEBA8 0x0607      SUB      R6,R8,R7
   \       0x76   0x6008             STR      R0,[R1, #+0]
   \       0x78   0x2E16             CMP      R6,#+22
   \       0x7A   0xDB0A             BLT.N    ??mbedtls_pem_read_buffer_2
   \       0x7C   0xF05F 0x0216      MOVS.W   R2,#+22
   \       0x80   0x....             ADR.N    R1,?_0
   \       0x82   0x4638             MOV      R0,R7
   \       0x84   0x.... 0x....      BL       memcmp
   \       0x88   0xB918             CBNZ.N   R0,??mbedtls_pem_read_buffer_2
    318          #if defined(PEM_RFC1421)
    319                  enc++;
    320          
    321                  s1 += 22;
    322                  if (*s1 == '\r') {
    323                      s1++;
    324                  }
    325                  if (*s1 == '\n') {
    326                      s1++;
    327                  } else {
    328                      return MBEDTLS_ERR_PEM_INVALID_DATA;
    329                  }
    330          
    331          
    332          #if defined(MBEDTLS_DES_C)
    333                  if (s2 - s1 >= 23 && memcmp(s1, "DEK-Info: DES-EDE3-CBC,", 23) == 0) {
    334                      enc_alg = MBEDTLS_CIPHER_DES_EDE3_CBC;
    335          
    336                      s1 += 23;
    337                      if (s2 - s1 < 16 || pem_get_iv(s1, pem_iv, 8) != 0) {
    338                          return MBEDTLS_ERR_PEM_INVALID_ENC_IV;
    339                      }
    340          
    341                      s1 += 16;
    342                  } else if (s2 - s1 >= 18 && memcmp(s1, "DEK-Info: DES-CBC,", 18) == 0) {
    343                      enc_alg = MBEDTLS_CIPHER_DES_CBC;
    344          
    345                      s1 += 18;
    346                      if (s2 - s1 < 16 || pem_get_iv(s1, pem_iv, 8) != 0) {
    347                          return MBEDTLS_ERR_PEM_INVALID_ENC_IV;
    348                      }
    349          
    350                      s1 += 16;
    351                  }
    352          #endif /* MBEDTLS_DES_C */
    353          
    354          #if defined(MBEDTLS_AES_C)
    355                  if (s2 - s1 >= 14 && memcmp(s1, "DEK-Info: AES-", 14) == 0) {
    356                      if (s2 - s1 < 22) {
    357                          return MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG;
    358                      } else if (memcmp(s1, "DEK-Info: AES-128-CBC,", 22) == 0) {
    359                          enc_alg = MBEDTLS_CIPHER_AES_128_CBC;
    360                      } else if (memcmp(s1, "DEK-Info: AES-192-CBC,", 22) == 0) {
    361                          enc_alg = MBEDTLS_CIPHER_AES_192_CBC;
    362                      } else if (memcmp(s1, "DEK-Info: AES-256-CBC,", 22) == 0) {
    363                          enc_alg = MBEDTLS_CIPHER_AES_256_CBC;
    364                      } else {
    365                          return MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG;
    366                      }
    367          
    368                      s1 += 22;
    369                      if (s2 - s1 < 32 || pem_get_iv(s1, pem_iv, 16) != 0) {
    370                          return MBEDTLS_ERR_PEM_INVALID_ENC_IV;
    371                      }
    372          
    373                      s1 += 32;
    374                  }
    375          #endif /* MBEDTLS_AES_C */
    376          
    377                  if (enc_alg == MBEDTLS_CIPHER_NONE) {
    378                      return MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG;
    379                  }
    380          
    381                  if (*s1 == '\r') {
    382                      s1++;
    383                  }
    384                  if (*s1 == '\n') {
    385                      s1++;
    386                  } else {
    387                      return MBEDTLS_ERR_PEM_INVALID_DATA;
    388                  }
    389          #else
    390                  return MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE;
   \       0x8A   0x....             LDR.N    R0,??DataTable3_1
   \       0x8C   0xE02C             B.N      ??mbedtls_pem_read_buffer_0
    391          #endif /* PEM_RFC1421 */
    392              }
   \                     ??mbedtls_pem_read_buffer_1: (+1)
   \       0x8E   0x....             LDR.N    R0,??DataTable3_2
   \       0x90   0xE02A             B.N      ??mbedtls_pem_read_buffer_0
    393          
    394              if (s1 >= s2) {
   \                     ??mbedtls_pem_read_buffer_2: (+1)
   \       0x92   0x4547             CMP      R7,R8
   \       0x94   0xBF28             IT       CS
   \       0x96   0x....             LDRCS.N  R0,??DataTable3_3
    395                  return MBEDTLS_ERR_PEM_INVALID_DATA;
   \       0x98   0xD226             BCS.N    ??mbedtls_pem_read_buffer_0
    396              }
    397          
    398              ret = mbedtls_base64_decode(NULL, 0, &len, s1, s2 - s1);
    399          
    400              if (ret == MBEDTLS_ERR_BASE64_INVALID_CHARACTER) {
   \       0x9A   0x9600             STR      R6,[SP, #+0]
   \       0x9C   0x463B             MOV      R3,R7
   \       0x9E   0xAA01             ADD      R2,SP,#+4
   \       0xA0   0x2100             MOVS     R1,#+0
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x.... 0x....      BL       mbedtls_base64_decode
   \       0xA8   0xF110 0x0F2C      CMN      R0,#+44
   \       0xAC   0xBF08             IT       EQ
   \       0xAE   0x....             LDREQ.N  R0,??DataTable3_4
    401                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_PEM_INVALID_DATA, ret);
   \       0xB0   0xD01A             BEQ.N    ??mbedtls_pem_read_buffer_0
    402              }
    403          
    404              if ((buf = mbedtls_calloc(1, len)) == NULL) {
   \       0xB2   0x9901             LDR      R1,[SP, #+4]
   \       0xB4   0x2001             MOVS     R0,#+1
   \       0xB6   0x.... 0x....      BL       sl_calloc
   \       0xBA   0x0005             MOVS     R5,R0
   \       0xBC   0xBF08             IT       EQ
   \       0xBE   0x....             LDREQ.N  R0,??DataTable3_5
    405                  return MBEDTLS_ERR_PEM_ALLOC_FAILED;
   \       0xC0   0xD012             BEQ.N    ??mbedtls_pem_read_buffer_0
    406              }
    407          
    408              if ((ret = mbedtls_base64_decode(buf, len, &len, s1, s2 - s1)) != 0) {
   \       0xC2   0x9901             LDR      R1,[SP, #+4]
   \       0xC4   0x9600             STR      R6,[SP, #+0]
   \       0xC6   0x463B             MOV      R3,R7
   \       0xC8   0xAA01             ADD      R2,SP,#+4
   \       0xCA   0x.... 0x....      BL       mbedtls_base64_decode
   \       0xCE   0x0006             MOVS     R6,R0
   \       0xD0   0xD006             BEQ.N    ??mbedtls_pem_read_buffer_3
    409                  mbedtls_zeroize_and_free(buf, len);
   \       0xD2   0x9901             LDR      R1,[SP, #+4]
   \       0xD4   0x4628             MOV      R0,R5
   \       0xD6   0x.... 0x....      BL       mbedtls_zeroize_and_free
    410                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_PEM_INVALID_DATA, ret);
    411              }
   \       0xDA   0xF5A6 0x5088      SUB      R0,R6,#+4352
   \       0xDE   0xE003             B.N      ??mbedtls_pem_read_buffer_0
    412          
    413              if (enc != 0) {
    414          #if defined(PEM_RFC1421)
    415                  if (pwd == NULL) {
    416                      mbedtls_zeroize_and_free(buf, len);
    417                      return MBEDTLS_ERR_PEM_PASSWORD_REQUIRED;
    418                  }
    419          
    420                  ret = 0;
    421          
    422          #if defined(MBEDTLS_DES_C)
    423                  if (enc_alg == MBEDTLS_CIPHER_DES_EDE3_CBC) {
    424                      ret = pem_des3_decrypt(pem_iv, buf, len, pwd, pwdlen);
    425                  } else if (enc_alg == MBEDTLS_CIPHER_DES_CBC) {
    426                      ret = pem_des_decrypt(pem_iv, buf, len, pwd, pwdlen);
    427                  }
    428          #endif /* MBEDTLS_DES_C */
    429          
    430          #if defined(MBEDTLS_AES_C)
    431                  if (enc_alg == MBEDTLS_CIPHER_AES_128_CBC) {
    432                      ret = pem_aes_decrypt(pem_iv, 16, buf, len, pwd, pwdlen);
    433                  } else if (enc_alg == MBEDTLS_CIPHER_AES_192_CBC) {
    434                      ret = pem_aes_decrypt(pem_iv, 24, buf, len, pwd, pwdlen);
    435                  } else if (enc_alg == MBEDTLS_CIPHER_AES_256_CBC) {
    436                      ret = pem_aes_decrypt(pem_iv, 32, buf, len, pwd, pwdlen);
    437                  }
    438          #endif /* MBEDTLS_AES_C */
    439          
    440                  if (ret != 0) {
    441                      mbedtls_free(buf);
    442                      return ret;
    443                  }
    444          
    445                  /*
    446                   * The result will be ASN.1 starting with a SEQUENCE tag, with 1 to 3
    447                   * length bytes (allow 4 to be sure) in all known use cases.
    448                   *
    449                   * Use that as a heuristic to try to detect password mismatches.
    450                   */
    451                  if (len <= 2 || buf[0] != 0x30 || buf[1] > 0x83) {
    452                      mbedtls_zeroize_and_free(buf, len);
    453                      return MBEDTLS_ERR_PEM_PASSWORD_MISMATCH;
    454                  }
    455          #else
    456                  mbedtls_zeroize_and_free(buf, len);
    457                  return MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE;
    458          #endif /* PEM_RFC1421 */
    459              }
    460          
    461              ctx->buf = buf;
   \                     ??mbedtls_pem_read_buffer_3: (+1)
   \       0xE0   0x6025             STR      R5,[R4, #+0]
    462              ctx->buflen = len;
   \       0xE2   0x9801             LDR      R0,[SP, #+4]
   \       0xE4   0x6060             STR      R0,[R4, #+4]
    463          
    464              return 0;
   \       0xE6   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pem_read_buffer_0: (+1)
   \       0xE8   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    465          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4650             MOV      R0,R10
   \        0x2   0x.... 0x....      B.W      strlen
    466          

   \                                 In section .text, align 2, keep-with-next
    467          void mbedtls_pem_free(mbedtls_pem_context *ctx)
    468          {
   \                     mbedtls_pem_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    469              if (ctx->buf != NULL) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xB110             CBZ.N    R0,??mbedtls_pem_free_0
    470                  mbedtls_zeroize_and_free(ctx->buf, ctx->buflen);
   \        0x8   0x6861             LDR      R1,[R4, #+4]
   \        0xA   0x.... 0x....      BL       mbedtls_zeroize_and_free
    471              }
    472              mbedtls_free(ctx->info);
   \                     ??mbedtls_pem_free_0: (+1)
   \        0xE   0x68A0             LDR      R0,[R4, #+8]
   \       0x10   0x.... 0x....      BL       sl_free
    473          
    474              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_pem_context));
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x210C             MOVS     R1,#+12
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x.... 0x....      B.W      mbedtls_platform_zeroize
    475          }
    476          #endif /* MBEDTLS_PEM_PARSE_C */
    477          
    478          #if defined(MBEDTLS_PEM_WRITE_C)

   \                                 In section .text, align 2, keep-with-next
    479          int mbedtls_pem_write_buffer(const char *header, const char *footer,
    480                                       const unsigned char *der_data, size_t der_len,
    481                                       unsigned char *buf, size_t buf_len, size_t *olen)
    482          {
   \                     mbedtls_pem_write_buffer: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461D             MOV      R5,R3
    483              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    484              unsigned char *encode_buf = NULL, *c, *p = buf;
    485              size_t len = 0, use_len, add_len = 0;
    486          
    487              mbedtls_base64_encode(NULL, 0, &use_len, der_data, der_len);
   \        0xC   0x9500             STR      R5,[SP, #+0]
   \        0xE   0x4633             MOV      R3,R6
   \       0x10   0xAA01             ADD      R2,SP,#+4
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x.... 0x....      BL       mbedtls_base64_encode
    488              add_len = strlen(header) + strlen(footer) + (((use_len > 2) ? (use_len - 2) : 0) / 64) + 1;
   \       0x1A   0x4648             MOV      R0,R9
   \       0x1C   0x.... 0x....      BL       strlen
   \       0x20   0x4607             MOV      R7,R0
   \       0x22   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x26   0x9901             LDR      R1,[SP, #+4]
   \       0x28   0xF04F 0x0800      MOV      R8,#+0
   \       0x2C   0x2903             CMP      R1,#+3
   \       0x2E   0xBF26             ITTE     CS
   \       0x30   0x1E89             SUBCS    R1,R1,#+2
   \       0x32   0x0989             LSRCS    R1,R1,#+6
   \       0x34   0x2100             MOVCC    R1,#+0
   \       0x36   0x19C7             ADDS     R7,R0,R7
    489          
    490              if (use_len + add_len > buf_len) {
   \       0x38   0x9801             LDR      R0,[SP, #+4]
   \       0x3A   0xF8DD 0xB034      LDR      R11,[SP, #+52]
   \       0x3E   0x19CF             ADDS     R7,R1,R7
   \       0x40   0x1C7F             ADDS     R7,R7,#+1
   \       0x42   0x183F             ADDS     R7,R7,R0
   \       0x44   0x9C0E             LDR      R4,[SP, #+56]
   \       0x46   0x45BB             CMP      R11,R7
   \       0x48   0xD203             BCS.N    ??mbedtls_pem_write_buffer_0
    491                  *olen = use_len + add_len;
   \       0x4A   0x6027             STR      R7,[R4, #+0]
    492                  return MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL;
   \       0x4C   0xF06F 0x0029      MVN      R0,#+41
   \       0x50   0xE052             B.N      ??mbedtls_pem_write_buffer_1
    493              }
    494          
    495              if (use_len != 0 &&
    496                  ((encode_buf = mbedtls_calloc(1, use_len)) == NULL)) {
   \                     ??mbedtls_pem_write_buffer_0: (+1)
   \       0x52   0xB140             CBZ.N    R0,??mbedtls_pem_write_buffer_2
   \       0x54   0x4601             MOV      R1,R0
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x.... 0x....      BL       sl_calloc
   \       0x5C   0xEA5F 0x0800      MOVS     R8,R0
   \       0x60   0xBF08             IT       EQ
   \       0x62   0x....             LDREQ.N  R0,??DataTable3_5
    497                  return MBEDTLS_ERR_PEM_ALLOC_FAILED;
   \       0x64   0xD048             BEQ.N    ??mbedtls_pem_write_buffer_1
    498              }
    499          
    500              if ((ret = mbedtls_base64_encode(encode_buf, use_len, &use_len, der_data,
    501                                               der_len)) != 0) {
   \                     ??mbedtls_pem_write_buffer_2: (+1)
   \       0x66   0x9901             LDR      R1,[SP, #+4]
   \       0x68   0x9500             STR      R5,[SP, #+0]
   \       0x6A   0x4633             MOV      R3,R6
   \       0x6C   0xAA01             ADD      R2,SP,#+4
   \       0x6E   0x4640             MOV      R0,R8
   \       0x70   0x.... 0x....      BL       mbedtls_base64_encode
   \       0x74   0x0005             MOVS     R5,R0
   \       0x76   0xD004             BEQ.N    ??mbedtls_pem_write_buffer_3
    502                  mbedtls_free(encode_buf);
   \       0x78   0x4640             MOV      R0,R8
   \       0x7A   0x.... 0x....      BL       sl_free
    503                  return ret;
   \       0x7E   0x4628             MOV      R0,R5
   \       0x80   0xE03A             B.N      ??mbedtls_pem_write_buffer_1
    504              }
   \                     ??mbedtls_pem_write_buffer_3: (+1)
   \       0x82   0x9E0C             LDR      R6,[SP, #+48]
    505          
    506              memcpy(p, header, strlen(header));
   \       0x84   0x4648             MOV      R0,R9
   \       0x86   0x.... 0x....      BL       strlen
   \       0x8A   0x4602             MOV      R2,R0
   \       0x8C   0x4649             MOV      R1,R9
   \       0x8E   0x4630             MOV      R0,R6
   \       0x90   0x.... 0x....      BL       __aeabi_memcpy
    507              p += strlen(header);
   \       0x94   0x4648             MOV      R0,R9
   \       0x96   0x.... 0x....      BL       strlen
   \       0x9A   0x1835             ADDS     R5,R6,R0
    508              c = encode_buf;
   \       0x9C   0x46C1             MOV      R9,R8
   \       0x9E   0xE010             B.N      ??mbedtls_pem_write_buffer_4
    509          
    510              while (use_len) {
    511                  len = (use_len > 64) ? 64 : use_len;
   \                     ??mbedtls_pem_write_buffer_5: (+1)
   \       0xA0   0x2840             CMP      R0,#+64
   \       0xA2   0xBF94             ITE      LS
   \       0xA4   0x4607             MOVLS    R7,R0
   \       0xA6   0x2740             MOVHI    R7,#+64
    512                  memcpy(p, c, len);
   \       0xA8   0x463A             MOV      R2,R7
   \       0xAA   0x4649             MOV      R1,R9
   \       0xAC   0x4628             MOV      R0,R5
   \       0xAE   0x.... 0x....      BL       __aeabi_memcpy
    513                  use_len -= len;
   \       0xB2   0x9801             LDR      R0,[SP, #+4]
    514                  p += len;
   \       0xB4   0x19ED             ADDS     R5,R5,R7
    515                  c += len;
    516                  *p++ = '\n';
   \       0xB6   0x210A             MOVS     R1,#+10
   \       0xB8   0x1BC0             SUBS     R0,R0,R7
   \       0xBA   0x9001             STR      R0,[SP, #+4]
   \       0xBC   0x44B9             ADD      R9,R9,R7
   \       0xBE   0xF805 0x1B01      STRB     R1,[R5], #+1
    517              }
   \                     ??mbedtls_pem_write_buffer_4: (+1)
   \       0xC2   0x9801             LDR      R0,[SP, #+4]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD1EB             BNE.N    ??mbedtls_pem_write_buffer_5
    518          
    519              memcpy(p, footer, strlen(footer));
   \       0xC8   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xCC   0x4602             MOV      R2,R0
   \       0xCE   0x4651             MOV      R1,R10
   \       0xD0   0x4628             MOV      R0,R5
   \       0xD2   0x.... 0x....      BL       __aeabi_memcpy
    520              p += strlen(footer);
   \       0xD6   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xDA   0x4428             ADD      R0,R5,R0
    521          
    522              *p++ = '\0';
   \       0xDC   0x2100             MOVS     R1,#+0
   \       0xDE   0xF800 0x1B01      STRB     R1,[R0], #+1
    523              *olen = p - buf;
   \       0xE2   0x1B80             SUBS     R0,R0,R6
   \       0xE4   0x6020             STR      R0,[R4, #+0]
    524          
    525              /* Clean any remaining data previously written to the buffer */
    526              memset(buf + *olen, 0, buf_len - *olen);
   \       0xE6   0xEBAB 0x0100      SUB      R1,R11,R0
   \       0xEA   0x1830             ADDS     R0,R6,R0
   \       0xEC   0x.... 0x....      BL       __aeabi_memclr
    527          
    528              mbedtls_free(encode_buf);
   \       0xF0   0x4640             MOV      R0,R8
   \       0xF2   0x.... 0x....      BL       sl_free
    529              return 0;
   \       0xF6   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pem_write_buffer_1: (+1)
   \       0xF8   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    530          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xFFFF'EB80        DC32     0xffffeb80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0xFFFF'EC00        DC32     0xffffec00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0xFFFF'EF80        DC32     0xffffef80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0xFFFF'EF00        DC32     0xffffef00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0xFFFF'EED4        DC32     0xffffeed4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0xFFFF'EE80        DC32     0xffffee80

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x50 0x72          DC8 "Proc-Type: 4,ENCRYPTED"
   \              0x6F 0x63    
   \              0x2D 0x54    
   \              0x79 0x70    
   \              0x65 0x3A    
   \              0x20 0x34    
   \              0x2C 0x45    
   \              0x4E 0x43    
   \              0x52 0x59    
   \              0x50 0x54    
   \              0x45 0x44    
   \              0x00
   \       0x17                      DS8 1
    531          #endif /* MBEDTLS_PEM_WRITE_C */
    532          #endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   mbedtls_pem_free
         0   -> mbedtls_platform_zeroize
         8   -> mbedtls_zeroize_and_free
         8   -> sl_free
       0   mbedtls_pem_init
      40   mbedtls_pem_read_buffer
        40   -> mbedtls_base64_decode
        40   -> mbedtls_zeroize_and_free
        40   -> memcmp
        40   -> sl_calloc
        40   -> strlen
        40   -> strstr
      48   mbedtls_pem_write_buffer
        48   -> __aeabi_memclr
        48   -> __aeabi_memcpy
        48   -> mbedtls_base64_encode
        48   -> sl_calloc
        48   -> sl_free
        48   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       6  ?Subroutine0
      24  ?_0
      32  mbedtls_pem_free
      12  mbedtls_pem_init
     236  mbedtls_pem_read_buffer
     252  mbedtls_pem_write_buffer

 
 586 bytes in section .text
 
 586 bytes of CODE memory

Errors: none
Warnings: none
