###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:47
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ssl_tls.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ssl_tls.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_tls.c
      1          /*
      2           *  TLS shared functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           *  http://www.ietf.org/rfc/rfc2246.txt
     21           *  http://www.ietf.org/rfc/rfc4346.txt
     22           */
     23          
     24          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \        0x8   0x7841             LDRB     R1,[R0, #+1]
   \        0xA   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \        0xE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \        0x6   0x7002             STRB     R2,[R0, #+0]
   \        0x8   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \        0xC   0x7042             STRB     R2,[R0, #+1]
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xB001             ADD      SP,SP,#+4
   \        0x8   0x4608             MOV      R0,R1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0xB001             ADD      SP,SP,#+4
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_bswap32(uint32_t)
   \                     mbedtls_bswap32: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x0208             LSLS     R0,R1,#+8
   \        0x4   0xF400 0x007F      AND      R0,R0,#0xFF0000
   \        0x8   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \        0xC   0x0A0A             LSRS     R2,R1,#+8
   \        0xE   0xF402 0x427F      AND      R2,R2,#0xFF00
   \       0x12   0x4310             ORRS     R0,R2,R0
   \       0x14   0xEA40 0x6011      ORR      R0,R0,R1, LSR #+24
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     25          
     26          #if defined(MBEDTLS_SSL_TLS_C)
     27          
     28          #include "mbedtls/platform.h"
     29          
     30          #include "mbedtls/ssl.h"

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0x8                      DS8 216

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_usage_flags(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_usage_flags: (+1)
   \        0x0   0x04CA             LSLS     R2,R1,#+19
   \        0x2   0xBF48             IT       MI
   \        0x4   0xF441 0x6180      ORRMI    R1,R1,#0x400
   \        0x8   0x048A             LSLS     R2,R1,#+18
   \        0xA   0xBF48             IT       MI
   \        0xC   0xF441 0x6100      ORRMI    R1,R1,#0x800
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_type(psa_key_attributes_t *, uint16_t)
   \                     psa_set_key_type: (+1)
   \        0x0   0x69C2             LDR      R2,[R0, #+28]
   \        0x2   0xB90A             CBNZ.N   R2,??psa_set_key_type_0
   \        0x4   0x8001             STRH     R1,[R0, #+0]
   \        0x6   0x4770             BX       LR
   \                     ??psa_set_key_type_0: (+1)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x.... 0x....      B.W      psa_set_key_domain_parameters
     31          #include "ssl_client.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_chk_buf_ptr(uint8_t const *, uint8_t const *, size_t)
   \                     mbedtls_ssl_chk_buf_ptr: (+1)
   \        0x0   0x4281             CMP      R1,R0
   \        0x2   0xD304             BCC.N    ??mbedtls_ssl_chk_buf_ptr_0
   \        0x4   0x1A08             SUBS     R0,R1,R0
   \        0x6   0x4290             CMP      R0,R2
   \        0x8   0x4180             SBCS     R0,R0,R0
   \        0xA   0x0FC0             LSRS     R0,R0,#+31
   \        0xC   0x4770             BX       LR
   \                     ??mbedtls_ssl_chk_buf_ptr_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_write_handshake_msg(mbedtls_ssl_context *)
   \                     mbedtls_ssl_write_handshake_msg: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x.... 0x....      B.W      mbedtls_ssl_write_handshake_msg_ext

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_conf_is_tls12_only(mbedtls_ssl_config const *)
   \                     mbedtls_ssl_conf_is_tls12_only: (+1)
   \        0x0   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
   \        0x4   0xF240 0x3103      MOVW     R1,#+771
   \        0x8   0x428A             CMP      R2,R1
   \        0xA   0xBF04             ITT      EQ
   \        0xC   0xF9B0 0x0000      LDRSHEQ  R0,[R0, #+0]
   \       0x10   0x4288             CMPEQ    R0,R1
   \       0x12   0xD101             BNE.N    ??mbedtls_ssl_conf_is_tls12_only_0
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x4770             BX       LR
   \                     ??mbedtls_ssl_conf_is_tls12_only_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void const *mbedtls_ssl_get_sig_algs(mbedtls_ssl_context const *)
   \                     mbedtls_ssl_get_sig_algs: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x6B88             LDR      R0,[R1, #+56]
   \        0x4   0xB120             CBZ.N    R0,??mbedtls_ssl_get_sig_algs_0
   \        0x6   0x7942             LDRB     R2,[R0, #+5]
   \        0x8   0x2A01             CMP      R2,#+1
   \        0xA   0xD101             BNE.N    ??mbedtls_ssl_get_sig_algs_0
   \        0xC   0x6C80             LDR      R0,[R0, #+72]
   \        0xE   0xB908             CBNZ.N   R0,??mbedtls_ssl_get_sig_algs_1
   \                     ??mbedtls_ssl_get_sig_algs_0: (+1)
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x6C80             LDR      R0,[R0, #+72]
   \                     ??mbedtls_ssl_get_sig_algs_1: (+1)
   \       0x14   0x4770             BX       LR

      return 0;
      ^
"C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ssl_misc.h",2433  Warning[Pe111]: 
          statement is unreachable

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ssl_sig_alg_is_supported(mbedtls_ssl_context const *, uint16_t const)
   \                     mbedtls_ssl_sig_alg_is_supported: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xF9B0 0x4008      LDRSH    R4,[R0, #+8]
   \        0x6   0xF240 0x3303      MOVW     R3,#+771
   \        0xA   0x429C             CMP      R4,R3
   \        0xC   0xD108             BNE.N    ??mbedtls_ssl_sig_alg_is_supported_0
   \        0xE   0x0A0A             LSRS     R2,R1,#+8
   \       0x10   0x1E92             SUBS     R2,R2,#+2
   \       0x12   0x2A02             CMP      R2,#+2
   \       0x14   0xD804             BHI.N    ??mbedtls_ssl_sig_alg_is_supported_0
   \       0x16   0xB2C9             UXTB     R1,R1
   \       0x18   0x2903             CMP      R1,#+3
   \       0x1A   0xD101             BNE.N    ??mbedtls_ssl_sig_alg_is_supported_0
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xBD10             POP      {R4,PC}
   \                     ??mbedtls_ssl_sig_alg_is_supported_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD10             POP      {R4,PC}
     32          #include "ssl_debug_helpers.h"
     33          #include "ssl_misc.h"
     34          
     35          #include "mbedtls/debug.h"
     36          #include "mbedtls/error.h"
     37          #include "mbedtls/platform_util.h"
     38          #include "mbedtls/version.h"
     39          #include "mbedtls/constant_time.h"
     40          
     41          #include <string.h>
     42          
     43          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     44          #include "md_psa.h"
     45          #include "psa_util_internal.h"
     46          #include "psa/crypto.h"
     47          #endif
     48          
     49          #if defined(MBEDTLS_X509_CRT_PARSE_C)
     50          #include "mbedtls/oid.h"
     51          #endif
     52          
     53          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     54          /* Define local translating functions to save code size by not using too many
     55           * arguments in each translating place. */

   \                                 In section .text, align 2, keep-with-next
     56          static int local_err_translation(psa_status_t status)
     57          {
     58              return psa_status_to_mbedtls(status, psa_to_ssl_errors,
     59                                           ARRAY_LENGTH(psa_to_ssl_errors),
     60                                           psa_generic_status_to_mbedtls);
   \                     local_err_translation: (+1)
   \        0x0   0x.... 0x....      LDR.W    R3,??DataTable26
   \        0x4   0x2207             MOVS     R2,#+7
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable26_1
   \        0xA   0x.... 0x....      B.W      psa_status_to_mbedtls
     61          }
     62          #define PSA_TO_MBEDTLS_ERR(status) local_err_translation(status)
     63          #endif
     64          
     65          #if defined(MBEDTLS_TEST_HOOKS)
     66          static mbedtls_ssl_chk_buf_ptr_args chk_buf_ptr_fail_args;
     67          
     68          void mbedtls_ssl_set_chk_buf_ptr_fail_args(
     69              const uint8_t *cur, const uint8_t *end, size_t need)
     70          {
     71              chk_buf_ptr_fail_args.cur = cur;
     72              chk_buf_ptr_fail_args.end = end;
     73              chk_buf_ptr_fail_args.need = need;
     74          }
     75          
     76          void mbedtls_ssl_reset_chk_buf_ptr_fail_args(void)
     77          {
     78              memset(&chk_buf_ptr_fail_args, 0, sizeof(chk_buf_ptr_fail_args));
     79          }
     80          
     81          int mbedtls_ssl_cmp_chk_buf_ptr_fail_args(mbedtls_ssl_chk_buf_ptr_args *args)
     82          {
     83              return (chk_buf_ptr_fail_args.cur  != args->cur) ||
     84                     (chk_buf_ptr_fail_args.end  != args->end) ||
     85                     (chk_buf_ptr_fail_args.need != args->need);
     86          }
     87          #endif /* MBEDTLS_TEST_HOOKS */
     88          
     89          #if defined(MBEDTLS_SSL_PROTO_DTLS)
     90          
     91          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
     92          /* Top-level Connection ID API */
     93          
     94          int mbedtls_ssl_conf_cid(mbedtls_ssl_config *conf,
     95                                   size_t len,
     96                                   int ignore_other_cid)
     97          {
     98              if (len > MBEDTLS_SSL_CID_IN_LEN_MAX) {
     99                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    100              }
    101          
    102              if (ignore_other_cid != MBEDTLS_SSL_UNEXPECTED_CID_FAIL &&
    103                  ignore_other_cid != MBEDTLS_SSL_UNEXPECTED_CID_IGNORE) {
    104                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    105              }
    106          
    107              conf->ignore_unexpected_cid = ignore_other_cid;
    108              conf->cid_len = len;
    109              return 0;
    110          }
    111          
    112          int mbedtls_ssl_set_cid(mbedtls_ssl_context *ssl,
    113                                  int enable,
    114                                  unsigned char const *own_cid,
    115                                  size_t own_cid_len)
    116          {
    117              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
    118                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    119              }
    120          
    121              ssl->negotiate_cid = enable;
    122              if (enable == MBEDTLS_SSL_CID_DISABLED) {
    123                  MBEDTLS_SSL_DEBUG_MSG(3, ("Disable use of CID extension."));
    124                  return 0;
    125              }
    126              MBEDTLS_SSL_DEBUG_MSG(3, ("Enable use of CID extension."));
    127              MBEDTLS_SSL_DEBUG_BUF(3, "Own CID", own_cid, own_cid_len);
    128          
    129              if (own_cid_len != ssl->conf->cid_len) {
    130                  MBEDTLS_SSL_DEBUG_MSG(3, ("CID length %u does not match CID length %u in config",
    131                                            (unsigned) own_cid_len,
    132                                            (unsigned) ssl->conf->cid_len));
    133                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    134              }
    135          
    136              memcpy(ssl->own_cid, own_cid, own_cid_len);
    137              /* Truncation is not an issue here because
    138               * MBEDTLS_SSL_CID_IN_LEN_MAX at most 255. */
    139              ssl->own_cid_len = (uint8_t) own_cid_len;
    140          
    141              return 0;
    142          }
    143          
    144          int mbedtls_ssl_get_own_cid(mbedtls_ssl_context *ssl,
    145                                      int *enabled,
    146                                      unsigned char own_cid[MBEDTLS_SSL_CID_OUT_LEN_MAX],
    147                                      size_t *own_cid_len)
    148          {
    149              *enabled = MBEDTLS_SSL_CID_DISABLED;
    150          
    151              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
    152                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    153              }
    154          
    155              /* We report MBEDTLS_SSL_CID_DISABLED in case the CID length is
    156               * zero as this is indistinguishable from not requesting to use
    157               * the CID extension. */
    158              if (ssl->own_cid_len == 0 || ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED) {
    159                  return 0;
    160              }
    161          
    162              if (own_cid_len != NULL) {
    163                  *own_cid_len = ssl->own_cid_len;
    164                  if (own_cid != NULL) {
    165                      memcpy(own_cid, ssl->own_cid, ssl->own_cid_len);
    166                  }
    167              }
    168          
    169              *enabled = MBEDTLS_SSL_CID_ENABLED;
    170          
    171              return 0;
    172          }
    173          
    174          int mbedtls_ssl_get_peer_cid(mbedtls_ssl_context *ssl,
    175                                       int *enabled,
    176                                       unsigned char peer_cid[MBEDTLS_SSL_CID_OUT_LEN_MAX],
    177                                       size_t *peer_cid_len)
    178          {
    179              *enabled = MBEDTLS_SSL_CID_DISABLED;
    180          
    181              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM ||
    182                  mbedtls_ssl_is_handshake_over(ssl) == 0) {
    183                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
    184              }
    185          
    186              /* We report MBEDTLS_SSL_CID_DISABLED in case the CID extensions
    187               * were used, but client and server requested the empty CID.
    188               * This is indistinguishable from not using the CID extension
    189               * in the first place. */
    190              if (ssl->transform_in->in_cid_len  == 0 &&
    191                  ssl->transform_in->out_cid_len == 0) {
    192                  return 0;
    193              }
    194          
    195              if (peer_cid_len != NULL) {
    196                  *peer_cid_len = ssl->transform_in->out_cid_len;
    197                  if (peer_cid != NULL) {
    198                      memcpy(peer_cid, ssl->transform_in->out_cid,
    199                             ssl->transform_in->out_cid_len);
    200                  }
    201              }
    202          
    203              *enabled = MBEDTLS_SSL_CID_ENABLED;
    204          
    205              return 0;
    206          }
    207          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
    208          
    209          #endif /* MBEDTLS_SSL_PROTO_DTLS */
    210          
    211          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    212          /*
    213           * Convert max_fragment_length codes to length.
    214           * RFC 6066 says:
    215           *    enum{
    216           *        2^9(1), 2^10(2), 2^11(3), 2^12(4), (255)
    217           *    } MaxFragmentLength;
    218           * and we add 0 -> extension unused
    219           */
    220          static unsigned int ssl_mfl_code_to_length(int mfl)
    221          {
    222              switch (mfl) {
    223                  case MBEDTLS_SSL_MAX_FRAG_LEN_NONE:
    224                      return MBEDTLS_TLS_EXT_ADV_CONTENT_LEN;
    225                  case MBEDTLS_SSL_MAX_FRAG_LEN_512:
    226                      return 512;
    227                  case MBEDTLS_SSL_MAX_FRAG_LEN_1024:
    228                      return 1024;
    229                  case MBEDTLS_SSL_MAX_FRAG_LEN_2048:
    230                      return 2048;
    231                  case MBEDTLS_SSL_MAX_FRAG_LEN_4096:
    232                      return 4096;
    233                  default:
    234                      return MBEDTLS_TLS_EXT_ADV_CONTENT_LEN;
    235              }
    236          }
    237          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    238          

   \                                 In section .text, align 2, keep-with-next
    239          int mbedtls_ssl_session_copy(mbedtls_ssl_session *dst,
    240                                       const mbedtls_ssl_session *src)
    241          {
   \                     mbedtls_ssl_session_copy: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    242              mbedtls_ssl_session_free(dst);
   \        0x6   0x.... 0x....      BL       mbedtls_ssl_session_free
    243              memcpy(dst, src, sizeof(mbedtls_ssl_session));
   \        0xA   0x2264             MOVS     R2,#+100
   \        0xC   0x4621             MOV      R1,R4
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       __aeabi_memcpy4
    244          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
    245              dst->ticket = NULL;
    246          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
    247              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    248              dst->hostname = NULL;
    249          #endif
    250          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
    251          
    252          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    253          
    254          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
    255              if (src->peer_cert != NULL) {
   \       0x14   0x6DE0             LDR      R0,[R4, #+92]
   \       0x16   0xB1B8             CBZ.N    R0,??mbedtls_ssl_session_copy_0
    256                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    257          
    258                  dst->peer_cert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
   \       0x18   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x1C   0x65E8             STR      R0,[R5, #+92]
    259                  if (dst->peer_cert == NULL) {
   \       0x1E   0xB910             CBNZ.N   R0,??mbedtls_ssl_session_copy_1
    260                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    261                  }
    262          
    263                  mbedtls_x509_crt_init(dst->peer_cert);
   \                     ??mbedtls_ssl_session_copy_1: (+1)
   \       0x26   0x.... 0x....      BL       mbedtls_x509_crt_init
    264          
    265                  if ((ret = mbedtls_x509_crt_parse_der(dst->peer_cert, src->peer_cert->raw.p,
    266                                                        src->peer_cert->raw.len)) != 0) {
   \       0x2A   0x6DE0             LDR      R0,[R4, #+92]
   \       0x2C   0x6882             LDR      R2,[R0, #+8]
   \       0x2E   0x68C1             LDR      R1,[R0, #+12]
   \       0x30   0x6DE8             LDR      R0,[R5, #+92]
   \       0x32   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0x36   0x0004             MOVS     R4,R0
   \       0x38   0xD006             BEQ.N    ??mbedtls_ssl_session_copy_0
    267                      mbedtls_free(dst->peer_cert);
   \       0x3A   0x6DE8             LDR      R0,[R5, #+92]
   \       0x3C   0x.... 0x....      BL       sl_free
    268                      dst->peer_cert = NULL;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x65E8             STR      R0,[R5, #+92]
    269                      return ret;
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}
    270                  }
    271              }
    272          #else /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
    273              if (src->peer_cert_digest != NULL) {
    274                  dst->peer_cert_digest =
    275                      mbedtls_calloc(1, src->peer_cert_digest_len);
    276                  if (dst->peer_cert_digest == NULL) {
    277                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
    278                  }
    279          
    280                  memcpy(dst->peer_cert_digest, src->peer_cert_digest,
    281                         src->peer_cert_digest_len);
    282                  dst->peer_cert_digest_type = src->peer_cert_digest_type;
    283                  dst->peer_cert_digest_len = src->peer_cert_digest_len;
    284              }
    285          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
    286          
    287          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    288          
    289          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
    290              if (src->ticket != NULL) {
    291                  dst->ticket = mbedtls_calloc(1, src->ticket_len);
    292                  if (dst->ticket == NULL) {
    293                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
    294                  }
    295          
    296                  memcpy(dst->ticket, src->ticket, src->ticket_len);
    297              }
    298          
    299          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
    300              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    301              if (src->endpoint == MBEDTLS_SSL_IS_CLIENT) {
    302                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    303                  ret = mbedtls_ssl_session_set_hostname(dst, src->hostname);
    304                  if (ret != 0) {
    305                      return ret;
    306                  }
    307              }
    308          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 &&
    309                    MBEDTLS_SSL_SERVER_NAME_INDICATION */
    310          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
    311          
    312              return 0;
   \                     ??mbedtls_ssl_session_copy_0: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xBD32             POP      {R1,R4,R5,PC}
    313          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0xF44F 0x710B      MOV      R1,#+556
   \                     ??Subroutine9_0: (+1)
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x.... 0x....      B.W      sl_calloc
    314          
    315          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
    316          MBEDTLS_CHECK_RETURN_CRITICAL
    317          static int resize_buffer(unsigned char **buffer, size_t len_new, size_t *len_old)
    318          {
    319              unsigned char *resized_buffer = mbedtls_calloc(1, len_new);
    320              if (resized_buffer == NULL) {
    321                  return -1;
    322              }
    323          
    324              /* We want to copy len_new bytes when downsizing the buffer, and
    325               * len_old bytes when upsizing, so we choose the smaller of two sizes,
    326               * to fit one buffer into another. Size checks, ensuring that no data is
    327               * lost, are done outside of this function. */
    328              memcpy(resized_buffer, *buffer,
    329                     (len_new < *len_old) ? len_new : *len_old);
    330              mbedtls_zeroize_and_free(*buffer, *len_old);
    331          
    332              *buffer = resized_buffer;
    333              *len_old = len_new;
    334          
    335              return 0;
    336          }
    337          
    338          static void handle_buffer_resizing(mbedtls_ssl_context *ssl, int downsizing,
    339                                             size_t in_buf_new_len,
    340                                             size_t out_buf_new_len)
    341          {
    342              int modified = 0;
    343              size_t written_in = 0, iv_offset_in = 0, len_offset_in = 0;
    344              size_t written_out = 0, iv_offset_out = 0, len_offset_out = 0;
    345              if (ssl->in_buf != NULL) {
    346                  written_in = ssl->in_msg - ssl->in_buf;
    347                  iv_offset_in = ssl->in_iv - ssl->in_buf;
    348                  len_offset_in = ssl->in_len - ssl->in_buf;
    349                  if (downsizing ?
    350                      ssl->in_buf_len > in_buf_new_len && ssl->in_left < in_buf_new_len :
    351                      ssl->in_buf_len < in_buf_new_len) {
    352                      if (resize_buffer(&ssl->in_buf, in_buf_new_len, &ssl->in_buf_len) != 0) {
    353                          MBEDTLS_SSL_DEBUG_MSG(1, ("input buffer resizing failed - out of memory"));
    354                      } else {
    355                          MBEDTLS_SSL_DEBUG_MSG(2, ("Reallocating in_buf to %" MBEDTLS_PRINTF_SIZET,
    356                                                    in_buf_new_len));
    357                          modified = 1;
    358                      }
    359                  }
    360              }
    361          
    362              if (ssl->out_buf != NULL) {
    363                  written_out = ssl->out_msg - ssl->out_buf;
    364                  iv_offset_out = ssl->out_iv - ssl->out_buf;
    365                  len_offset_out = ssl->out_len - ssl->out_buf;
    366                  if (downsizing ?
    367                      ssl->out_buf_len > out_buf_new_len && ssl->out_left < out_buf_new_len :
    368                      ssl->out_buf_len < out_buf_new_len) {
    369                      if (resize_buffer(&ssl->out_buf, out_buf_new_len, &ssl->out_buf_len) != 0) {
    370                          MBEDTLS_SSL_DEBUG_MSG(1, ("output buffer resizing failed - out of memory"));
    371                      } else {
    372                          MBEDTLS_SSL_DEBUG_MSG(2, ("Reallocating out_buf to %" MBEDTLS_PRINTF_SIZET,
    373                                                    out_buf_new_len));
    374                          modified = 1;
    375                      }
    376                  }
    377              }
    378              if (modified) {
    379                  /* Update pointers here to avoid doing it twice. */
    380                  mbedtls_ssl_reset_in_out_pointers(ssl);
    381                  /* Fields below might not be properly updated with record
    382                   * splitting or with CID, so they are manually updated here. */
    383                  ssl->out_msg = ssl->out_buf + written_out;
    384                  ssl->out_len = ssl->out_buf + len_offset_out;
    385                  ssl->out_iv = ssl->out_buf + iv_offset_out;
    386          
    387                  ssl->in_msg = ssl->in_buf + written_in;
    388                  ssl->in_len = ssl->in_buf + len_offset_in;
    389                  ssl->in_iv = ssl->in_buf + iv_offset_in;
    390              }
    391          }
    392          #endif /* MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH */
    393          
    394          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    395          
    396          #if defined(MBEDTLS_SSL_CONTEXT_SERIALIZATION)
    397          typedef int (*tls_prf_fn)(const unsigned char *secret, size_t slen,
    398                                    const char *label,
    399                                    const unsigned char *random, size_t rlen,
    400                                    unsigned char *dstbuf, size_t dlen);
    401          
    402          static tls_prf_fn ssl_tls12prf_from_cs(int ciphersuite_id);
    403          
    404          #endif /* MBEDTLS_SSL_CONTEXT_SERIALIZATION */
    405          
    406          /* Type for the TLS PRF */
    407          typedef int ssl_tls_prf_t(const unsigned char *, size_t, const char *,
    408                                    const unsigned char *, size_t,
    409                                    unsigned char *, size_t);
    410          
    411          MBEDTLS_CHECK_RETURN_CRITICAL
    412          static int ssl_tls12_populate_transform(mbedtls_ssl_transform *transform,
    413                                                  int ciphersuite,
    414                                                  const unsigned char master[48],
    415          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
    416                                                  int encrypt_then_mac,
    417          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
    418                                                  ssl_tls_prf_t tls_prf,
    419                                                  const unsigned char randbytes[64],
    420                                                  mbedtls_ssl_protocol_version tls_version,
    421                                                  unsigned endpoint,
    422                                                  const mbedtls_ssl_context *ssl);
    423          
    424          #if defined(MBEDTLS_MD_CAN_SHA256)
    425          MBEDTLS_CHECK_RETURN_CRITICAL
    426          static int tls_prf_sha256(const unsigned char *secret, size_t slen,
    427                                    const char *label,
    428                                    const unsigned char *random, size_t rlen,
    429                                    unsigned char *dstbuf, size_t dlen);
    430          static int ssl_calc_verify_tls_sha256(const mbedtls_ssl_context *, unsigned char *, size_t *);
    431          static int ssl_calc_finished_tls_sha256(mbedtls_ssl_context *, unsigned char *, int);
    432          
    433          #endif /* MBEDTLS_MD_CAN_SHA256*/
    434          
    435          #if defined(MBEDTLS_MD_CAN_SHA384)
    436          MBEDTLS_CHECK_RETURN_CRITICAL
    437          static int tls_prf_sha384(const unsigned char *secret, size_t slen,
    438                                    const char *label,
    439                                    const unsigned char *random, size_t rlen,
    440                                    unsigned char *dstbuf, size_t dlen);
    441          
    442          static int ssl_calc_verify_tls_sha384(const mbedtls_ssl_context *, unsigned char *, size_t *);
    443          static int ssl_calc_finished_tls_sha384(mbedtls_ssl_context *, unsigned char *, int);
    444          #endif /* MBEDTLS_MD_CAN_SHA384*/
    445          
    446          static size_t ssl_tls12_session_save(const mbedtls_ssl_session *session,
    447                                               unsigned char *buf,
    448                                               size_t buf_len);
    449          
    450          MBEDTLS_CHECK_RETURN_CRITICAL
    451          static int ssl_tls12_session_load(mbedtls_ssl_session *session,
    452                                            const unsigned char *buf,
    453                                            size_t len);
    454          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    455          
    456          static int ssl_update_checksum_start(mbedtls_ssl_context *, const unsigned char *, size_t);
    457          
    458          #if defined(MBEDTLS_MD_CAN_SHA256)
    459          static int ssl_update_checksum_sha256(mbedtls_ssl_context *, const unsigned char *, size_t);
    460          #endif /* MBEDTLS_MD_CAN_SHA256*/
    461          
    462          #if defined(MBEDTLS_MD_CAN_SHA384)
    463          static int ssl_update_checksum_sha384(mbedtls_ssl_context *, const unsigned char *, size_t);
    464          #endif /* MBEDTLS_MD_CAN_SHA384*/
    465          

   \                                 In section .text, align 2, keep-with-next
    466          int  mbedtls_ssl_tls_prf(const mbedtls_tls_prf_types prf,
    467                                   const unsigned char *secret, size_t slen,
    468                                   const char *label,
    469                                   const unsigned char *random, size_t rlen,
    470                                   unsigned char *dstbuf, size_t dlen)
    471          {
   \                     mbedtls_ssl_tls_prf: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4611             MOV      R1,R2
   \        0x6   0x461A             MOV      R2,R3
    472              mbedtls_ssl_tls_prf_cb *tls_prf = NULL;
    473          
    474              switch (prf) {
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD10A             BNE.N    ??mbedtls_ssl_tls_prf_0
    475          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    476          #if defined(MBEDTLS_MD_CAN_SHA384)
    477                  case MBEDTLS_SSL_TLS_PRF_SHA384:
    478                      tls_prf = tls_prf_sha384;
    479                      break;
    480          #endif /* MBEDTLS_MD_CAN_SHA384*/
    481          #if defined(MBEDTLS_MD_CAN_SHA256)
    482                  case MBEDTLS_SSL_TLS_PRF_SHA256:
    483                      tls_prf = tls_prf_sha256;
    484                      break;
    485          #endif /* MBEDTLS_MD_CAN_SHA256*/
    486          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    487                  default:
    488                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
    489              }
    490          
    491              return tls_prf(secret, slen, label, random, rlen, dstbuf, dlen);
   \        0xC   0x9809             LDR      R0,[SP, #+36]
   \        0xE   0x9D08             LDR      R5,[SP, #+32]
   \       0x10   0x9B06             LDR      R3,[SP, #+24]
   \       0x12   0x9002             STR      R0,[SP, #+8]
   \       0x14   0x9807             LDR      R0,[SP, #+28]
   \       0x16   0x9501             STR      R5,[SP, #+4]
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       tls_prf_sha256
   \       0x20   0xBD3E             POP      {R1-R5,PC}
   \                     ??mbedtls_ssl_tls_prf_0: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \       0x26   0xBD3E             POP      {R1-R5,PC}
    492          }
    493          
    494          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
    495          static void ssl_clear_peer_cert(mbedtls_ssl_session *session)
    496          {
   \                     ssl_clear_peer_cert: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    497          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
    498              if (session->peer_cert != NULL) {
   \        0x4   0x6DE0             LDR      R0,[R4, #+92]
   \        0x6   0xB130             CBZ.N    R0,??ssl_clear_peer_cert_0
    499                  mbedtls_x509_crt_free(session->peer_cert);
   \        0x8   0x.... 0x....      BL       mbedtls_x509_crt_free
    500                  mbedtls_free(session->peer_cert);
   \        0xC   0x6DE0             LDR      R0,[R4, #+92]
   \        0xE   0x.... 0x....      BL       sl_free
    501                  session->peer_cert = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x65E0             STR      R0,[R4, #+92]
    502              }
    503          #else /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
    504              if (session->peer_cert_digest != NULL) {
    505                  /* Zeroization is not necessary. */
    506                  mbedtls_free(session->peer_cert_digest);
    507                  session->peer_cert_digest      = NULL;
    508                  session->peer_cert_digest_type = MBEDTLS_MD_NONE;
    509                  session->peer_cert_digest_len  = 0;
    510              }
    511          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
    512          }
   \                     ??ssl_clear_peer_cert_0: (+1)
   \       0x16   0xBD10             POP      {R4,PC}
    513          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    514          

   \                                 In section .text, align 4, keep-with-next
    515          uint32_t mbedtls_ssl_get_extension_id(unsigned int extension_type)
    516          {
    517              switch (extension_type) {
   \                     mbedtls_ssl_get_extension_id: (+1)
   \        0x0   0x2833             CMP      R0,#+51
   \        0x2   0xD853             BHI.N    ??mbedtls_ssl_get_extension_id_1
   \        0x4   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mbedtls_ssl_get_extension_id_0:
   \        0x8   0x1A 0x1C          DC8      0x1A,0x1C,0x52,0x52
   \              0x52 0x52
   \        0xC   0x46 0x1E          DC8      0x46,0x1E,0x52,0x52
   \              0x52 0x52
   \       0x10   0x52 0x52          DC8      0x52,0x52,0x20,0x48
   \              0x20 0x48
   \       0x14   0x52 0x22          DC8      0x52,0x22,0x24,0x26
   \              0x24 0x26
   \       0x18   0x28 0x52          DC8      0x28,0x52,0x2A,0x2C
   \              0x2A 0x2C
   \       0x1C   0x2E 0x30          DC8      0x2E,0x30,0x4A,0x4C
   \              0x4A 0x4C
   \       0x20   0x52 0x52          DC8      0x52,0x52,0x52,0x52
   \              0x52 0x52
   \       0x24   0x4E 0x52          DC8      0x4E,0x52,0x52,0x52
   \              0x52 0x52
   \       0x28   0x52 0x52          DC8      0x52,0x52,0x52,0x50
   \              0x52 0x50
   \       0x2C   0x52 0x52          DC8      0x52,0x52,0x52,0x52
   \              0x52 0x52
   \       0x30   0x52 0x32          DC8      0x52,0x32,0x34,0x36
   \              0x34 0x36
   \       0x34   0x38 0x3A          DC8      0x38,0x3A,0x52,0x3C
   \              0x52 0x3C
   \       0x38   0x3E 0x40          DC8      0x3E,0x40,0x42,0x44
   \              0x42 0x44
    518                  case MBEDTLS_TLS_EXT_SERVERNAME:
    519                      return MBEDTLS_SSL_EXT_ID_SERVERNAME;
   \                     ??mbedtls_ssl_get_extension_id_2: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x4770             BX       LR
    520          
    521                  case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
    522                      return MBEDTLS_SSL_EXT_ID_MAX_FRAGMENT_LENGTH;
   \                     ??mbedtls_ssl_get_extension_id_3: (+1)
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0x4770             BX       LR
    523          
    524                  case MBEDTLS_TLS_EXT_STATUS_REQUEST:
    525                      return MBEDTLS_SSL_EXT_ID_STATUS_REQUEST;
   \                     ??mbedtls_ssl_get_extension_id_4: (+1)
   \       0x44   0x2003             MOVS     R0,#+3
   \       0x46   0x4770             BX       LR
    526          
    527                  case MBEDTLS_TLS_EXT_SUPPORTED_GROUPS:
    528                      return MBEDTLS_SSL_EXT_ID_SUPPORTED_GROUPS;
   \                     ??mbedtls_ssl_get_extension_id_5: (+1)
   \       0x48   0x2004             MOVS     R0,#+4
   \       0x4A   0x4770             BX       LR
    529          
    530                  case MBEDTLS_TLS_EXT_SIG_ALG:
    531                      return MBEDTLS_SSL_EXT_ID_SIG_ALG;
   \                     ??mbedtls_ssl_get_extension_id_6: (+1)
   \       0x4C   0x2005             MOVS     R0,#+5
   \       0x4E   0x4770             BX       LR
    532          
    533                  case MBEDTLS_TLS_EXT_USE_SRTP:
    534                      return MBEDTLS_SSL_EXT_ID_USE_SRTP;
   \                     ??mbedtls_ssl_get_extension_id_7: (+1)
   \       0x50   0x2006             MOVS     R0,#+6
   \       0x52   0x4770             BX       LR
    535          
    536                  case MBEDTLS_TLS_EXT_HEARTBEAT:
    537                      return MBEDTLS_SSL_EXT_ID_HEARTBEAT;
   \                     ??mbedtls_ssl_get_extension_id_8: (+1)
   \       0x54   0x2007             MOVS     R0,#+7
   \       0x56   0x4770             BX       LR
    538          
    539                  case MBEDTLS_TLS_EXT_ALPN:
    540                      return MBEDTLS_SSL_EXT_ID_ALPN;
   \                     ??mbedtls_ssl_get_extension_id_9: (+1)
   \       0x58   0x2008             MOVS     R0,#+8
   \       0x5A   0x4770             BX       LR
    541          
    542                  case MBEDTLS_TLS_EXT_SCT:
    543                      return MBEDTLS_SSL_EXT_ID_SCT;
   \                     ??mbedtls_ssl_get_extension_id_10: (+1)
   \       0x5C   0x2009             MOVS     R0,#+9
   \       0x5E   0x4770             BX       LR
    544          
    545                  case MBEDTLS_TLS_EXT_CLI_CERT_TYPE:
    546                      return MBEDTLS_SSL_EXT_ID_CLI_CERT_TYPE;
   \                     ??mbedtls_ssl_get_extension_id_11: (+1)
   \       0x60   0x200A             MOVS     R0,#+10
   \       0x62   0x4770             BX       LR
    547          
    548                  case MBEDTLS_TLS_EXT_SERV_CERT_TYPE:
    549                      return MBEDTLS_SSL_EXT_ID_SERV_CERT_TYPE;
   \                     ??mbedtls_ssl_get_extension_id_12: (+1)
   \       0x64   0x200B             MOVS     R0,#+11
   \       0x66   0x4770             BX       LR
    550          
    551                  case MBEDTLS_TLS_EXT_PADDING:
    552                      return MBEDTLS_SSL_EXT_ID_PADDING;
   \                     ??mbedtls_ssl_get_extension_id_13: (+1)
   \       0x68   0x200C             MOVS     R0,#+12
   \       0x6A   0x4770             BX       LR
    553          
    554                  case MBEDTLS_TLS_EXT_PRE_SHARED_KEY:
    555                      return MBEDTLS_SSL_EXT_ID_PRE_SHARED_KEY;
   \                     ??mbedtls_ssl_get_extension_id_14: (+1)
   \       0x6C   0x200D             MOVS     R0,#+13
   \       0x6E   0x4770             BX       LR
    556          
    557                  case MBEDTLS_TLS_EXT_EARLY_DATA:
    558                      return MBEDTLS_SSL_EXT_ID_EARLY_DATA;
   \                     ??mbedtls_ssl_get_extension_id_15: (+1)
   \       0x70   0x200E             MOVS     R0,#+14
   \       0x72   0x4770             BX       LR
    559          
    560                  case MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS:
    561                      return MBEDTLS_SSL_EXT_ID_SUPPORTED_VERSIONS;
   \                     ??mbedtls_ssl_get_extension_id_16: (+1)
   \       0x74   0x200F             MOVS     R0,#+15
   \       0x76   0x4770             BX       LR
    562          
    563                  case MBEDTLS_TLS_EXT_COOKIE:
    564                      return MBEDTLS_SSL_EXT_ID_COOKIE;
   \                     ??mbedtls_ssl_get_extension_id_17: (+1)
   \       0x78   0x2010             MOVS     R0,#+16
   \       0x7A   0x4770             BX       LR
    565          
    566                  case MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES:
    567                      return MBEDTLS_SSL_EXT_ID_PSK_KEY_EXCHANGE_MODES;
   \                     ??mbedtls_ssl_get_extension_id_18: (+1)
   \       0x7C   0x2011             MOVS     R0,#+17
   \       0x7E   0x4770             BX       LR
    568          
    569                  case MBEDTLS_TLS_EXT_CERT_AUTH:
    570                      return MBEDTLS_SSL_EXT_ID_CERT_AUTH;
   \                     ??mbedtls_ssl_get_extension_id_19: (+1)
   \       0x80   0x2012             MOVS     R0,#+18
   \       0x82   0x4770             BX       LR
    571          
    572                  case MBEDTLS_TLS_EXT_OID_FILTERS:
    573                      return MBEDTLS_SSL_EXT_ID_OID_FILTERS;
   \                     ??mbedtls_ssl_get_extension_id_20: (+1)
   \       0x84   0x2013             MOVS     R0,#+19
   \       0x86   0x4770             BX       LR
    574          
    575                  case MBEDTLS_TLS_EXT_POST_HANDSHAKE_AUTH:
    576                      return MBEDTLS_SSL_EXT_ID_POST_HANDSHAKE_AUTH;
   \                     ??mbedtls_ssl_get_extension_id_21: (+1)
   \       0x88   0x2014             MOVS     R0,#+20
   \       0x8A   0x4770             BX       LR
    577          
    578                  case MBEDTLS_TLS_EXT_SIG_ALG_CERT:
    579                      return MBEDTLS_SSL_EXT_ID_SIG_ALG_CERT;
   \                     ??mbedtls_ssl_get_extension_id_22: (+1)
   \       0x8C   0x2015             MOVS     R0,#+21
   \       0x8E   0x4770             BX       LR
    580          
    581                  case MBEDTLS_TLS_EXT_KEY_SHARE:
    582                      return MBEDTLS_SSL_EXT_ID_KEY_SHARE;
   \                     ??mbedtls_ssl_get_extension_id_23: (+1)
   \       0x90   0x2016             MOVS     R0,#+22
   \       0x92   0x4770             BX       LR
    583          
    584                  case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:
    585                      return MBEDTLS_SSL_EXT_ID_TRUNCATED_HMAC;
   \                     ??mbedtls_ssl_get_extension_id_24: (+1)
   \       0x94   0x2017             MOVS     R0,#+23
   \       0x96   0x4770             BX       LR
    586          
    587                  case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
    588                      return MBEDTLS_SSL_EXT_ID_SUPPORTED_POINT_FORMATS;
   \                     ??mbedtls_ssl_get_extension_id_25: (+1)
   \       0x98   0x2018             MOVS     R0,#+24
   \       0x9A   0x4770             BX       LR
    589          
    590                  case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
    591                      return MBEDTLS_SSL_EXT_ID_ENCRYPT_THEN_MAC;
   \                     ??mbedtls_ssl_get_extension_id_26: (+1)
   \       0x9C   0x2019             MOVS     R0,#+25
   \       0x9E   0x4770             BX       LR
    592          
    593                  case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
    594                      return MBEDTLS_SSL_EXT_ID_EXTENDED_MASTER_SECRET;
   \                     ??mbedtls_ssl_get_extension_id_27: (+1)
   \       0xA0   0x201A             MOVS     R0,#+26
   \       0xA2   0x4770             BX       LR
    595          
    596                  case MBEDTLS_TLS_EXT_RECORD_SIZE_LIMIT:
    597                      return MBEDTLS_SSL_EXT_ID_RECORD_SIZE_LIMIT;
   \                     ??mbedtls_ssl_get_extension_id_28: (+1)
   \       0xA4   0x201C             MOVS     R0,#+28
   \       0xA6   0x4770             BX       LR
    598          
    599                  case MBEDTLS_TLS_EXT_SESSION_TICKET:
    600                      return MBEDTLS_SSL_EXT_ID_SESSION_TICKET;
   \                     ??mbedtls_ssl_get_extension_id_29: (+1)
   \       0xA8   0x201B             MOVS     R0,#+27
   \       0xAA   0x4770             BX       LR
    601          
    602              }
    603          
    604              return MBEDTLS_SSL_EXT_ID_UNRECOGNIZED;
   \                     ??mbedtls_ssl_get_extension_id_1: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x4770             BX       LR
    605          }
    606          

   \                                 In section .text, align 2, keep-with-next
    607          uint32_t mbedtls_ssl_get_extension_mask(unsigned int extension_type)
    608          {
   \                     mbedtls_ssl_get_extension_mask: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    609              return 1 << mbedtls_ssl_get_extension_id(extension_type);
   \        0x2   0x2401             MOVS     R4,#+1
   \        0x4   0x.... 0x....      BL       mbedtls_ssl_get_extension_id
   \        0x8   0xFA04 0xF000      LSL      R0,R4,R0
   \        0xC   0xBD10             POP      {R4,PC}
    610          }
    611          
    612          #if defined(MBEDTLS_DEBUG_C)
    613          static const char *extension_name_table[] = {
    614              [MBEDTLS_SSL_EXT_ID_UNRECOGNIZED] = "unrecognized",
    615              [MBEDTLS_SSL_EXT_ID_SERVERNAME] = "server_name",
    616              [MBEDTLS_SSL_EXT_ID_MAX_FRAGMENT_LENGTH] = "max_fragment_length",
    617              [MBEDTLS_SSL_EXT_ID_STATUS_REQUEST] = "status_request",
    618              [MBEDTLS_SSL_EXT_ID_SUPPORTED_GROUPS] = "supported_groups",
    619              [MBEDTLS_SSL_EXT_ID_SIG_ALG] = "signature_algorithms",
    620              [MBEDTLS_SSL_EXT_ID_USE_SRTP] = "use_srtp",
    621              [MBEDTLS_SSL_EXT_ID_HEARTBEAT] = "heartbeat",
    622              [MBEDTLS_SSL_EXT_ID_ALPN] = "application_layer_protocol_negotiation",
    623              [MBEDTLS_SSL_EXT_ID_SCT] = "signed_certificate_timestamp",
    624              [MBEDTLS_SSL_EXT_ID_CLI_CERT_TYPE] = "client_certificate_type",
    625              [MBEDTLS_SSL_EXT_ID_SERV_CERT_TYPE] = "server_certificate_type",
    626              [MBEDTLS_SSL_EXT_ID_PADDING] = "padding",
    627              [MBEDTLS_SSL_EXT_ID_PRE_SHARED_KEY] = "pre_shared_key",
    628              [MBEDTLS_SSL_EXT_ID_EARLY_DATA] = "early_data",
    629              [MBEDTLS_SSL_EXT_ID_SUPPORTED_VERSIONS] = "supported_versions",
    630              [MBEDTLS_SSL_EXT_ID_COOKIE] = "cookie",
    631              [MBEDTLS_SSL_EXT_ID_PSK_KEY_EXCHANGE_MODES] = "psk_key_exchange_modes",
    632              [MBEDTLS_SSL_EXT_ID_CERT_AUTH] = "certificate_authorities",
    633              [MBEDTLS_SSL_EXT_ID_OID_FILTERS] = "oid_filters",
    634              [MBEDTLS_SSL_EXT_ID_POST_HANDSHAKE_AUTH] = "post_handshake_auth",
    635              [MBEDTLS_SSL_EXT_ID_SIG_ALG_CERT] = "signature_algorithms_cert",
    636              [MBEDTLS_SSL_EXT_ID_KEY_SHARE] = "key_share",
    637              [MBEDTLS_SSL_EXT_ID_TRUNCATED_HMAC] = "truncated_hmac",
    638              [MBEDTLS_SSL_EXT_ID_SUPPORTED_POINT_FORMATS] = "supported_point_formats",
    639              [MBEDTLS_SSL_EXT_ID_ENCRYPT_THEN_MAC] = "encrypt_then_mac",
    640              [MBEDTLS_SSL_EXT_ID_EXTENDED_MASTER_SECRET] = "extended_master_secret",
    641              [MBEDTLS_SSL_EXT_ID_SESSION_TICKET] = "session_ticket",
    642              [MBEDTLS_SSL_EXT_ID_RECORD_SIZE_LIMIT] = "record_size_limit"
    643          };
    644          
    645          static unsigned int extension_type_table[] = {
    646              [MBEDTLS_SSL_EXT_ID_UNRECOGNIZED] = 0xff,
    647              [MBEDTLS_SSL_EXT_ID_SERVERNAME] = MBEDTLS_TLS_EXT_SERVERNAME,
    648              [MBEDTLS_SSL_EXT_ID_MAX_FRAGMENT_LENGTH] = MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH,
    649              [MBEDTLS_SSL_EXT_ID_STATUS_REQUEST] = MBEDTLS_TLS_EXT_STATUS_REQUEST,
    650              [MBEDTLS_SSL_EXT_ID_SUPPORTED_GROUPS] = MBEDTLS_TLS_EXT_SUPPORTED_GROUPS,
    651              [MBEDTLS_SSL_EXT_ID_SIG_ALG] = MBEDTLS_TLS_EXT_SIG_ALG,
    652              [MBEDTLS_SSL_EXT_ID_USE_SRTP] = MBEDTLS_TLS_EXT_USE_SRTP,
    653              [MBEDTLS_SSL_EXT_ID_HEARTBEAT] = MBEDTLS_TLS_EXT_HEARTBEAT,
    654              [MBEDTLS_SSL_EXT_ID_ALPN] = MBEDTLS_TLS_EXT_ALPN,
    655              [MBEDTLS_SSL_EXT_ID_SCT] = MBEDTLS_TLS_EXT_SCT,
    656              [MBEDTLS_SSL_EXT_ID_CLI_CERT_TYPE] = MBEDTLS_TLS_EXT_CLI_CERT_TYPE,
    657              [MBEDTLS_SSL_EXT_ID_SERV_CERT_TYPE] = MBEDTLS_TLS_EXT_SERV_CERT_TYPE,
    658              [MBEDTLS_SSL_EXT_ID_PADDING] = MBEDTLS_TLS_EXT_PADDING,
    659              [MBEDTLS_SSL_EXT_ID_PRE_SHARED_KEY] = MBEDTLS_TLS_EXT_PRE_SHARED_KEY,
    660              [MBEDTLS_SSL_EXT_ID_EARLY_DATA] = MBEDTLS_TLS_EXT_EARLY_DATA,
    661              [MBEDTLS_SSL_EXT_ID_SUPPORTED_VERSIONS] = MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS,
    662              [MBEDTLS_SSL_EXT_ID_COOKIE] = MBEDTLS_TLS_EXT_COOKIE,
    663              [MBEDTLS_SSL_EXT_ID_PSK_KEY_EXCHANGE_MODES] = MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES,
    664              [MBEDTLS_SSL_EXT_ID_CERT_AUTH] = MBEDTLS_TLS_EXT_CERT_AUTH,
    665              [MBEDTLS_SSL_EXT_ID_OID_FILTERS] = MBEDTLS_TLS_EXT_OID_FILTERS,
    666              [MBEDTLS_SSL_EXT_ID_POST_HANDSHAKE_AUTH] = MBEDTLS_TLS_EXT_POST_HANDSHAKE_AUTH,
    667              [MBEDTLS_SSL_EXT_ID_SIG_ALG_CERT] = MBEDTLS_TLS_EXT_SIG_ALG_CERT,
    668              [MBEDTLS_SSL_EXT_ID_KEY_SHARE] = MBEDTLS_TLS_EXT_KEY_SHARE,
    669              [MBEDTLS_SSL_EXT_ID_TRUNCATED_HMAC] = MBEDTLS_TLS_EXT_TRUNCATED_HMAC,
    670              [MBEDTLS_SSL_EXT_ID_SUPPORTED_POINT_FORMATS] = MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS,
    671              [MBEDTLS_SSL_EXT_ID_ENCRYPT_THEN_MAC] = MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC,
    672              [MBEDTLS_SSL_EXT_ID_EXTENDED_MASTER_SECRET] = MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET,
    673              [MBEDTLS_SSL_EXT_ID_SESSION_TICKET] = MBEDTLS_TLS_EXT_SESSION_TICKET,
    674              [MBEDTLS_SSL_EXT_ID_RECORD_SIZE_LIMIT] = MBEDTLS_TLS_EXT_RECORD_SIZE_LIMIT
    675          };
    676          
    677          const char *mbedtls_ssl_get_extension_name(unsigned int extension_type)
    678          {
    679              return extension_name_table[
    680                  mbedtls_ssl_get_extension_id(extension_type)];
    681          }
    682          
    683          static const char *ssl_tls13_get_hs_msg_name(int hs_msg_type)
    684          {
    685              switch (hs_msg_type) {
    686                  case MBEDTLS_SSL_HS_CLIENT_HELLO:
    687                      return "ClientHello";
    688                  case MBEDTLS_SSL_HS_SERVER_HELLO:
    689                      return "ServerHello";
    690                  case MBEDTLS_SSL_TLS1_3_HS_HELLO_RETRY_REQUEST:
    691                      return "HelloRetryRequest";
    692                  case MBEDTLS_SSL_HS_NEW_SESSION_TICKET:
    693                      return "NewSessionTicket";
    694                  case MBEDTLS_SSL_HS_ENCRYPTED_EXTENSIONS:
    695                      return "EncryptedExtensions";
    696                  case MBEDTLS_SSL_HS_CERTIFICATE:
    697                      return "Certificate";
    698                  case MBEDTLS_SSL_HS_CERTIFICATE_REQUEST:
    699                      return "CertificateRequest";
    700              }
    701              return "Unknown";
    702          }
    703          
    704          void mbedtls_ssl_print_extension(const mbedtls_ssl_context *ssl,
    705                                           int level, const char *file, int line,
    706                                           int hs_msg_type, unsigned int extension_type,
    707                                           const char *extra_msg0, const char *extra_msg1)
    708          {
    709              const char *extra_msg;
    710              if (extra_msg0 && extra_msg1) {
    711                  mbedtls_debug_print_msg(
    712                      ssl, level, file, line,
    713                      "%s: %s(%u) extension %s %s.",
    714                      ssl_tls13_get_hs_msg_name(hs_msg_type),
    715                      mbedtls_ssl_get_extension_name(extension_type),
    716                      extension_type,
    717                      extra_msg0, extra_msg1);
    718                  return;
    719              }
    720          
    721              extra_msg = extra_msg0 ? extra_msg0 : extra_msg1;
    722              if (extra_msg) {
    723                  mbedtls_debug_print_msg(
    724                      ssl, level, file, line,
    725                      "%s: %s(%u) extension %s.", ssl_tls13_get_hs_msg_name(hs_msg_type),
    726                      mbedtls_ssl_get_extension_name(extension_type), extension_type,
    727                      extra_msg);
    728                  return;
    729              }
    730          
    731              mbedtls_debug_print_msg(
    732                  ssl, level, file, line,
    733                  "%s: %s(%u) extension.", ssl_tls13_get_hs_msg_name(hs_msg_type),
    734                  mbedtls_ssl_get_extension_name(extension_type), extension_type);
    735          }
    736          
    737          void mbedtls_ssl_print_extensions(const mbedtls_ssl_context *ssl,
    738                                            int level, const char *file, int line,
    739                                            int hs_msg_type, uint32_t extensions_mask,
    740                                            const char *extra)
    741          {
    742          
    743              for (unsigned i = 0;
    744                   i < sizeof(extension_name_table) / sizeof(extension_name_table[0]);
    745                   i++) {
    746                  mbedtls_ssl_print_extension(
    747                      ssl, level, file, line, hs_msg_type, extension_type_table[i],
    748                      extensions_mask & (1 << i) ? "exists" : "does not exist", extra);
    749              }
    750          }
    751          
    752          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && defined(MBEDTLS_SSL_SESSION_TICKETS)
    753          static const char *ticket_flag_name_table[] =
    754          {
    755              [0] = "ALLOW_PSK_RESUMPTION",
    756              [2] = "ALLOW_PSK_EPHEMERAL_RESUMPTION",
    757              [3] = "ALLOW_EARLY_DATA",
    758          };
    759          
    760          void mbedtls_ssl_print_ticket_flags(const mbedtls_ssl_context *ssl,
    761                                              int level, const char *file, int line,
    762                                              unsigned int flags)
    763          {
    764              size_t i;
    765          
    766              mbedtls_debug_print_msg(ssl, level, file, line,
    767                                      "print ticket_flags (0x%02x)", flags);
    768          
    769              flags = flags & MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK;
    770          
    771              for (i = 0; i < ARRAY_LENGTH(ticket_flag_name_table); i++) {
    772                  if ((flags & (1 << i))) {
    773                      mbedtls_debug_print_msg(ssl, level, file, line, "- %s is set.",
    774                                              ticket_flag_name_table[i]);
    775                  }
    776              }
    777          }
    778          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 && MBEDTLS_SSL_SESSION_TICKETS */
    779          
    780          #endif /* MBEDTLS_DEBUG_C */
    781          

   \                                 In section .text, align 2, keep-with-next
    782          void mbedtls_ssl_optimize_checksum(mbedtls_ssl_context *ssl,
    783                                             const mbedtls_ssl_ciphersuite_t *ciphersuite_info)
    784          {
    785              ((void) ciphersuite_info);
    786          
    787          #if defined(MBEDTLS_MD_CAN_SHA384)
    788              if (ciphersuite_info->mac == MBEDTLS_MD_SHA384) {
    789                  ssl->handshake->update_checksum = ssl_update_checksum_sha384;
    790              } else
    791          #endif
    792          #if defined(MBEDTLS_MD_CAN_SHA256)
    793              if (ciphersuite_info->mac != MBEDTLS_MD_SHA384) {
   \                     mbedtls_ssl_optimize_checksum: (+1)
   \        0x0   0x7A4A             LDRB     R2,[R1, #+9]
   \        0x2   0x2A0A             CMP      R2,#+10
   \        0x4   0xD003             BEQ.N    ??mbedtls_ssl_optimize_checksum_0
    794                  ssl->handshake->update_checksum = ssl_update_checksum_sha256;
   \        0x6   0x6B80             LDR      R0,[R0, #+56]
   \        0x8   0x.... 0x....      ADR.W    R1,ssl_update_checksum_sha256
   \        0xC   0x60C1             STR      R1,[R0, #+12]
    795              } else
    796          #endif
    797              {
    798                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
    799                  return;
    800              }
    801          }
   \                     ??mbedtls_ssl_optimize_checksum_0: (+1)
   \        0xE   0x4770             BX       LR
    802          

   \                                 In section .text, align 2, keep-with-next
    803          int mbedtls_ssl_add_hs_hdr_to_checksum(mbedtls_ssl_context *ssl,
    804                                                 unsigned hs_type,
    805                                                 size_t total_hs_len)
    806          {
   \                     mbedtls_ssl_add_hs_hdr_to_checksum: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    807              unsigned char hs_hdr[4];
    808          
    809              /* Build HS header for checksum update. */
    810              hs_hdr[0] = MBEDTLS_BYTE_0(hs_type);
    811              hs_hdr[1] = MBEDTLS_BYTE_2(total_hs_len);
   \        0x2   0x0C14             LSRS     R4,R2,#+16
    812              hs_hdr[2] = MBEDTLS_BYTE_1(total_hs_len);
   \        0x4   0x0A13             LSRS     R3,R2,#+8
   \        0x6   0xF88D 0x4001      STRB     R4,[SP, #+1]
   \        0xA   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \        0xE   0xF88D 0x1000      STRB     R1,[SP, #+0]
    813              hs_hdr[3] = MBEDTLS_BYTE_0(total_hs_len);
   \       0x12   0xF88D 0x2003      STRB     R2,[SP, #+3]
    814          
    815              return ssl->handshake->update_checksum(ssl, hs_hdr, sizeof(hs_hdr));
   \       0x16   0x6B84             LDR      R4,[R0, #+56]
   \       0x18   0x2204             MOVS     R2,#+4
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x68E3             LDR      R3,[R4, #+12]
   \       0x1E   0x4798             BLX      R3
   \       0x20   0xBD16             POP      {R1,R2,R4,PC}
    816          }
    817          

   \                                 In section .text, align 2, keep-with-next
    818          int mbedtls_ssl_add_hs_msg_to_checksum(mbedtls_ssl_context *ssl,
    819                                                 unsigned hs_type,
    820                                                 unsigned char const *msg,
    821                                                 size_t msg_len)
    822          {
   \                     mbedtls_ssl_add_hs_msg_to_checksum: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4614             MOV      R4,R2
   \        0x4   0x461D             MOV      R5,R3
   \        0x6   0x4606             MOV      R6,R0
    823              int ret;
    824              ret = mbedtls_ssl_add_hs_hdr_to_checksum(ssl, hs_type, msg_len);
   \        0x8   0x462A             MOV      R2,R5
   \        0xA   0x.... 0x....      BL       mbedtls_ssl_add_hs_hdr_to_checksum
    825              if (ret != 0) {
   \        0xE   0xB938             CBNZ.N   R0,??mbedtls_ssl_add_hs_msg_to_checksum_0
    826                  return ret;
    827              }
    828              return ssl->handshake->update_checksum(ssl, msg, msg_len);
   \       0x10   0x4621             MOV      R1,R4
   \       0x12   0x6BB4             LDR      R4,[R6, #+56]
   \       0x14   0x462A             MOV      R2,R5
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x68E3             LDR      R3,[R4, #+12]
   \       0x1A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x1E   0x4718             BX       R3
   \                     ??mbedtls_ssl_add_hs_msg_to_checksum_0: (+1)
   \       0x20   0xBD70             POP      {R4-R6,PC}
    829          }
    830          

   \                                 In section .text, align 2, keep-with-next
    831          int mbedtls_ssl_reset_checksum(mbedtls_ssl_context *ssl)
    832          {
   \                     mbedtls_ssl_reset_checksum: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    833          #if defined(MBEDTLS_MD_CAN_SHA256) || \
    834              defined(MBEDTLS_MD_CAN_SHA384)
    835          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    836              psa_status_t status;
    837          #else
    838              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    839          #endif
    840          #else /* SHA-256 or SHA-384 */
    841              ((void) ssl);
    842          #endif /* SHA-256 or SHA-384 */
    843          #if defined(MBEDTLS_MD_CAN_SHA256)
    844          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    845              status = psa_hash_abort(&ssl->handshake->fin_sha256_psa);
   \        0x4   0x6BA1             LDR      R1,[R4, #+56]
   \        0x6   0xF101 0x00EC      ADD      R0,R1,#+236
   \        0xA   0x.... 0x....      BL       psa_hash_abort
    846              if (status != PSA_SUCCESS) {
   \        0xE   0xB930             CBNZ.N   R0,??mbedtls_ssl_reset_checksum_0
    847                  return mbedtls_md_error_from_psa(status);
    848              }
    849              status = psa_hash_setup(&ssl->handshake->fin_sha256_psa, PSA_ALG_SHA_256);
   \       0x10   0x6BA0             LDR      R0,[R4, #+56]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable28
   \       0x16   0x30EC             ADDS     R0,R0,#+236
   \       0x18   0x.... 0x....      BL       psa_hash_setup
    850              if (status != PSA_SUCCESS) {
   \       0x1C   0xB118             CBZ.N    R0,??mbedtls_ssl_reset_checksum_1
    851                  return mbedtls_md_error_from_psa(status);
   \                     ??mbedtls_ssl_reset_checksum_0: (+1)
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x.... 0x....      B.W      mbedtls_md_error_from_psa
    852              }
    853          #else
    854              mbedtls_md_free(&ssl->handshake->fin_sha256);
    855              mbedtls_md_init(&ssl->handshake->fin_sha256);
    856              ret = mbedtls_md_setup(&ssl->handshake->fin_sha256,
    857                                     mbedtls_md_info_from_type(MBEDTLS_MD_SHA256),
    858                                     0);
    859              if (ret != 0) {
    860                  return ret;
    861              }
    862              ret = mbedtls_md_starts(&ssl->handshake->fin_sha256);
    863              if (ret != 0) {
    864                  return ret;
    865              }
    866          #endif
    867          #endif
    868          #if defined(MBEDTLS_MD_CAN_SHA384)
    869          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    870              status = psa_hash_abort(&ssl->handshake->fin_sha384_psa);
    871              if (status != PSA_SUCCESS) {
    872                  return mbedtls_md_error_from_psa(status);
    873              }
    874              status = psa_hash_setup(&ssl->handshake->fin_sha384_psa, PSA_ALG_SHA_384);
    875              if (status != PSA_SUCCESS) {
    876                  return mbedtls_md_error_from_psa(status);
    877              }
    878          #else
    879              mbedtls_md_free(&ssl->handshake->fin_sha384);
    880              mbedtls_md_init(&ssl->handshake->fin_sha384);
    881              ret = mbedtls_md_setup(&ssl->handshake->fin_sha384,
    882                                     mbedtls_md_info_from_type(MBEDTLS_MD_SHA384), 0);
    883              if (ret != 0) {
    884                  return ret;
    885              }
    886              ret = mbedtls_md_starts(&ssl->handshake->fin_sha384);
    887              if (ret != 0) {
    888                  return ret;
    889              }
    890          #endif
    891          #endif
    892              return 0;
   \                     ??mbedtls_ssl_reset_checksum_1: (+1)
   \       0x26   0xBD10             POP      {R4,PC}
    893          }
    894          

   \                                 In section .text, align 2, keep-with-next
    895          static int ssl_update_checksum_start(mbedtls_ssl_context *ssl,
    896                                               const unsigned char *buf, size_t len)
    897          {
   \                     ssl_update_checksum_start: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    898          #if defined(MBEDTLS_MD_CAN_SHA256) || \
    899              defined(MBEDTLS_MD_CAN_SHA384)
    900          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    901              psa_status_t status;
    902          #else
    903              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    904          #endif
    905          #else /* SHA-256 or SHA-384 */
    906              ((void) ssl);
    907              (void) buf;
    908              (void) len;
    909          #endif /* SHA-256 or SHA-384 */
    910          #if defined(MBEDTLS_MD_CAN_SHA256)
    911          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    912              status = psa_hash_update(&ssl->handshake->fin_sha256_psa, buf, len);
   \        0x2   0x.... 0x....      BL       ?Subroutine13
    913              if (status != PSA_SUCCESS) {
   \                     ??CrossCallReturnLabel_27: (+1)
   \        0x6   0xB100             CBZ.N    R0,??ssl_update_checksum_start_0
    914                  return mbedtls_md_error_from_psa(status);
   \        0x8   0x....             B.N      ?Subroutine5
    915              }
    916          #else
    917              ret = mbedtls_md_update(&ssl->handshake->fin_sha256, buf, len);
    918              if (ret != 0) {
    919                  return ret;
    920              }
    921          #endif
    922          #endif
    923          #if defined(MBEDTLS_MD_CAN_SHA384)
    924          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    925              status = psa_hash_update(&ssl->handshake->fin_sha384_psa, buf, len);
    926              if (status != PSA_SUCCESS) {
    927                  return mbedtls_md_error_from_psa(status);
    928              }
    929          #else
    930              ret = mbedtls_md_update(&ssl->handshake->fin_sha384, buf, len);
    931              if (ret != 0) {
    932                  return ret;
    933              }
    934          #endif
    935          #endif
    936              return 0;
   \                     ??ssl_update_checksum_start_0: (+1)
   \        0xA   0xBD02             POP      {R1,PC}
    937          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xE8BD 0x4002      POP      {R1,LR}
   \        0x4   0x.... 0x....      B.W      mbedtls_md_error_from_psa

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x6B83             LDR      R3,[R0, #+56]
   \        0x2   0xF103 0x00EC      ADD      R0,R3,#+236
   \        0x6   0x.... 0x....      B.W      psa_hash_update
    938          
    939          #if defined(MBEDTLS_MD_CAN_SHA256)

   \                                 In section .text, align 4, keep-with-next
    940          static int ssl_update_checksum_sha256(mbedtls_ssl_context *ssl,
    941                                                const unsigned char *buf, size_t len)
    942          {
   \                     ssl_update_checksum_sha256: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    943          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    944              return mbedtls_md_error_from_psa(psa_hash_update(
    945                                                   &ssl->handshake->fin_sha256_psa, buf, len));
   \        0x2   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_26: (+1)
   \        0x6   0xBF00             Nop
   \        0x8                      REQUIRE ?Subroutine5
   \        0x8                      ;; // Fall through to label ?Subroutine5
    946          #else
    947              return mbedtls_md_update(&ssl->handshake->fin_sha256, buf, len);
    948          #endif
    949          }
    950          #endif
    951          
    952          #if defined(MBEDTLS_MD_CAN_SHA384)
    953          static int ssl_update_checksum_sha384(mbedtls_ssl_context *ssl,
    954                                                const unsigned char *buf, size_t len)
    955          {
    956          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    957              return mbedtls_md_error_from_psa(psa_hash_update(
    958                                                   &ssl->handshake->fin_sha384_psa, buf, len));
    959          #else
    960              return mbedtls_md_update(&ssl->handshake->fin_sha384, buf, len);
    961          #endif
    962          }
    963          #endif
    964          
    965          static void ssl_handshake_params_init(mbedtls_ssl_handshake_params *handshake)
    966          {
    967              memset(handshake, 0, sizeof(mbedtls_ssl_handshake_params));
    968          
    969          #if defined(MBEDTLS_MD_CAN_SHA256)
    970          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    971              handshake->fin_sha256_psa = psa_hash_operation_init();
    972          #else
    973              mbedtls_md_init(&handshake->fin_sha256);
    974          #endif
    975          #endif
    976          #if defined(MBEDTLS_MD_CAN_SHA384)
    977          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    978              handshake->fin_sha384_psa = psa_hash_operation_init();
    979          #else
    980              mbedtls_md_init(&handshake->fin_sha384);
    981          #endif
    982          #endif
    983          
    984              handshake->update_checksum = ssl_update_checksum_start;
    985          
    986          #if defined(MBEDTLS_DHM_C)
    987              mbedtls_dhm_init(&handshake->dhm_ctx);
    988          #endif
    989          #if !defined(MBEDTLS_USE_PSA_CRYPTO) && \
    990              defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED)
    991              mbedtls_ecdh_init(&handshake->ecdh_ctx);
    992          #endif
    993          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    994          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    995              handshake->psa_pake_ctx = psa_pake_operation_init();
    996              handshake->psa_pake_password = MBEDTLS_SVC_KEY_ID_INIT;
    997          #else
    998              mbedtls_ecjpake_init(&handshake->ecjpake_ctx);
    999          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1000          #if defined(MBEDTLS_SSL_CLI_C)
   1001              handshake->ecjpake_cache = NULL;
   1002              handshake->ecjpake_cache_len = 0;
   1003          #endif
   1004          #endif
   1005          
   1006          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   1007              mbedtls_x509_crt_restart_init(&handshake->ecrs_ctx);
   1008          #endif
   1009          
   1010          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   1011              handshake->sni_authmode = MBEDTLS_SSL_VERIFY_UNSET;
   1012          #endif
   1013          
   1014          #if defined(MBEDTLS_X509_CRT_PARSE_C) && \
   1015              !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   1016              mbedtls_pk_init(&handshake->peer_pubkey);
   1017          #endif
   1018          }
   1019          

   \                                 In section .text, align 2, keep-with-next
   1020          void mbedtls_ssl_transform_init(mbedtls_ssl_transform *transform)
   1021          {
   \                     mbedtls_ssl_transform_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1022              memset(transform, 0, sizeof(mbedtls_ssl_transform));
   \        0x4   0x2150             MOVS     R1,#+80
   \        0x6   0x.... 0x....      BL       __aeabi_memclr4
   1023          
   1024          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1025              transform->psa_key_enc = MBEDTLS_SVC_KEY_ID_INIT;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6462             STR      R2,[R4, #+68]
   1026              transform->psa_key_dec = MBEDTLS_SVC_KEY_ID_INIT;
   \        0xE   0x64A2             STR      R2,[R4, #+72]
   1027          #else
   1028              mbedtls_cipher_init(&transform->cipher_ctx_enc);
   1029              mbedtls_cipher_init(&transform->cipher_ctx_dec);
   1030          #endif
   1031          
   1032          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   1033          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1034              transform->psa_mac_enc = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x10   0x6362             STR      R2,[R4, #+52]
   1035              transform->psa_mac_dec = MBEDTLS_SVC_KEY_ID_INIT;
   \       0x12   0x63A2             STR      R2,[R4, #+56]
   1036          #else
   1037              mbedtls_md_init(&transform->md_ctx_enc);
   1038              mbedtls_md_init(&transform->md_ctx_dec);
   1039          #endif
   1040          #endif
   1041          }
   \       0x14   0xBD10             POP      {R4,PC}
   1042          

   \                                 In section .text, align 2, keep-with-next
   1043          void mbedtls_ssl_session_init(mbedtls_ssl_session *session)
   1044          {
   1045              memset(session, 0, sizeof(mbedtls_ssl_session));
   \                     mbedtls_ssl_session_init: (+1)
   \        0x0   0x.... 0x....      B.W      ?Subroutine6
   1046          }
   1047          
   1048          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   1049          static int ssl_handshake_init(mbedtls_ssl_context *ssl)
   1050          {
   \                     ssl_handshake_init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   1051              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1052          
   1053              /* Clear old handshake information if present */
   1054          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1055              if (ssl->transform_negotiate) {
   \        0x6   0x6CA0             LDR      R0,[R4, #+72]
   \        0x8   0xB108             CBZ.N    R0,??ssl_handshake_init_0
   1056                  mbedtls_ssl_transform_free(ssl->transform_negotiate);
   \        0xA   0x.... 0x....      BL       mbedtls_ssl_transform_free
   1057              }
   1058          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1059              if (ssl->session_negotiate) {
   \                     ??ssl_handshake_init_0: (+1)
   \        0xE   0x6B60             LDR      R0,[R4, #+52]
   \       0x10   0xB108             CBZ.N    R0,??ssl_handshake_init_1
   1060                  mbedtls_ssl_session_free(ssl->session_negotiate);
   \       0x12   0x.... 0x....      BL       mbedtls_ssl_session_free
   1061              }
   1062              if (ssl->handshake) {
   \                     ??ssl_handshake_init_1: (+1)
   \       0x16   0x6BA0             LDR      R0,[R4, #+56]
   \       0x18   0xB110             CBZ.N    R0,??ssl_handshake_init_2
   1063                  mbedtls_ssl_handshake_free(ssl);
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       mbedtls_ssl_handshake_free
   1064              }
   1065          
   1066          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1067              /*
   1068               * Either the pointers are now NULL or cleared properly and can be freed.
   1069               * Now allocate missing structures.
   1070               */
   1071              if (ssl->transform_negotiate == NULL) {
   \                     ??ssl_handshake_init_2: (+1)
   \       0x20   0x6CA0             LDR      R0,[R4, #+72]
   \       0x22   0xB918             CBNZ.N   R0,??ssl_handshake_init_3
   1072                  ssl->transform_negotiate = mbedtls_calloc(1, sizeof(mbedtls_ssl_transform));
   \       0x24   0x2150             MOVS     R1,#+80
   \       0x26   0x.... 0x....      BL       ??Subroutine9_0
   1073              }
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x2A   0x64A0             STR      R0,[R4, #+72]
   1074          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1075          
   1076              if (ssl->session_negotiate == NULL) {
   \                     ??ssl_handshake_init_3: (+1)
   \       0x2C   0x6B60             LDR      R0,[R4, #+52]
   \       0x2E   0xB918             CBNZ.N   R0,??ssl_handshake_init_4
   1077                  ssl->session_negotiate = mbedtls_calloc(1, sizeof(mbedtls_ssl_session));
   \       0x30   0x2164             MOVS     R1,#+100
   \       0x32   0x.... 0x....      BL       ??Subroutine9_0
   1078              }
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x36   0x6360             STR      R0,[R4, #+52]
   1079          
   1080              if (ssl->handshake == NULL) {
   \                     ??ssl_handshake_init_4: (+1)
   \       0x38   0x6BA0             LDR      R0,[R4, #+56]
   \       0x3A   0xB920             CBNZ.N   R0,??ssl_handshake_init_5
   1081                  ssl->handshake = mbedtls_calloc(1, sizeof(mbedtls_ssl_handshake_params));
   \       0x3C   0xF44F 0x7117      MOV      R1,#+604
   \       0x40   0x.... 0x....      BL       ??Subroutine9_0
   1082              }
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x44   0x63A0             STR      R0,[R4, #+56]
   1083          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   1084              /* If the buffers are too small - reallocate */
   1085          
   1086              handle_buffer_resizing(ssl, 0, MBEDTLS_SSL_IN_BUFFER_LEN,
   1087                                     MBEDTLS_SSL_OUT_BUFFER_LEN);
   1088          #endif
   1089          
   1090              /* All pointers should exist and can be directly freed without issue */
   1091              if (ssl->handshake           == NULL ||
   1092          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1093                  ssl->transform_negotiate == NULL ||
   1094          #endif
   1095                  ssl->session_negotiate   == NULL) {
   \                     ??ssl_handshake_init_5: (+1)
   \       0x46   0x6BA0             LDR      R0,[R4, #+56]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xBF1C             ITT      NE
   \       0x4C   0x6CA1             LDRNE    R1,[R4, #+72]
   \       0x4E   0x2900             CMPNE    R1,#+0
   \       0x50   0xD001             BEQ.N    ??ssl_handshake_init_6
   \       0x52   0x6B61             LDR      R1,[R4, #+52]
   \       0x54   0xB971             CBNZ.N   R1,??ssl_handshake_init_7
   1096                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc() of ssl sub-contexts failed"));
   1097          
   1098                  mbedtls_free(ssl->handshake);
   \                     ??ssl_handshake_init_6: (+1)
   \       0x56   0x.... 0x....      BL       sl_free
   1099                  ssl->handshake = NULL;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x63A0             STR      R0,[R4, #+56]
   1100          
   1101          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1102                  mbedtls_free(ssl->transform_negotiate);
   \       0x5E   0x6CA0             LDR      R0,[R4, #+72]
   \       0x60   0x.... 0x....      BL       sl_free
   1103                  ssl->transform_negotiate = NULL;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x64A0             STR      R0,[R4, #+72]
   1104          #endif
   1105          
   1106                  mbedtls_free(ssl->session_negotiate);
   \       0x68   0x6B60             LDR      R0,[R4, #+52]
   \       0x6A   0x.... 0x....      BL       sl_free
   1107                  ssl->session_negotiate = NULL;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x6360             STR      R0,[R4, #+52]
   \       0x72   0xE06F             B.N      ??ssl_handshake_init_8
   1108          
   1109                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   1110              }
   1111          
   1112              /* Initialize structures */
   1113              mbedtls_ssl_session_init(ssl->session_negotiate);
   \                     ??ssl_handshake_init_7: (+1)
   \       0x74   0x4608             MOV      R0,R1
   \       0x76   0x.... 0x....      BL       mbedtls_ssl_session_init
   1114              ssl_handshake_params_init(ssl->handshake);
   \       0x7A   0x6BA5             LDR      R5,[R4, #+56]
   \       0x7C   0xF44F 0x7117      MOV      R1,#+604
   \       0x80   0x4628             MOV      R0,R5
   \       0x82   0x.... 0x....      BL       __aeabi_memclr4
   \       0x86   0xF105 0x00EC      ADD      R0,R5,#+236
   \       0x8A   0x21E0             MOVS     R1,#+224
   \       0x8C   0x.... 0x....      BL       __aeabi_memclr4
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \       0x94   0x60E8             STR      R0,[R5, #+12]
   1115          
   1116          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1117              mbedtls_ssl_transform_init(ssl->transform_negotiate);
   \       0x96   0x6CA0             LDR      R0,[R4, #+72]
   \       0x98   0x.... 0x....      BL       mbedtls_ssl_transform_init
   1118          #endif
   1119          
   1120              /* Setup handshake checksums */
   1121              ret = mbedtls_ssl_reset_checksum(ssl);
   \       0x9C   0x4620             MOV      R0,R4
   \       0x9E   0x.... 0x....      BL       mbedtls_ssl_reset_checksum
   1122              if (ret != 0) {
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD16E             BNE.N    ??ssl_handshake_init_9
   1123                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_reset_checksum", ret);
   1124                  return ret;
   1125              }
   1126          
   1127          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
   1128              defined(MBEDTLS_SSL_SRV_C) && \
   1129              defined(MBEDTLS_SSL_SESSION_TICKETS)
   1130              ssl->handshake->new_session_tickets_count =
   1131                  ssl->conf->new_session_tickets_count;
   1132          #endif
   1133          
   1134          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1135              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1136                  ssl->handshake->alt_transform_out = ssl->transform_out;
   1137          
   1138                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   1139                      ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;
   1140                  } else {
   1141                      ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
   1142                  }
   1143          
   1144                  mbedtls_ssl_set_timer(ssl, 0);
   1145              }
   1146          #endif
   1147          
   1148          /*
   1149           * curve_list is translated to IANA TLS group identifiers here because
   1150           * mbedtls_ssl_conf_curves returns void and so can't return
   1151           * any error codes.
   1152           */
   1153          #if defined(MBEDTLS_ECP_C)
   1154          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   1155              /* Heap allocate and translate curve_list from internal to IANA group ids */
   1156              if (ssl->conf->curve_list != NULL) {
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x6CC5             LDR      R5,[R0, #+76]
   \       0xAA   0xB335             CBZ.N    R5,??ssl_handshake_init_10
   1157                  size_t length;
   1158                  const mbedtls_ecp_group_id *curve_list = ssl->conf->curve_list;
   1159          
   1160                  for (length = 0;  (curve_list[length] != MBEDTLS_ECP_DP_NONE); length++) {
   \       0xAC   0x2700             MOVS     R7,#+0
   \       0xAE   0xE000             B.N      ??ssl_handshake_init_11
   \                     ??ssl_handshake_init_12: (+1)
   \       0xB0   0x4617             MOV      R7,R2
   \                     ??ssl_handshake_init_11: (+1)
   \       0xB2   0x5DE8             LDRB     R0,[R5, R7]
   \       0xB4   0x1C7A             ADDS     R2,R7,#+1
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD1FA             BNE.N    ??ssl_handshake_init_12
   1161                  }
   1162          
   1163                  /* Leave room for zero termination */
   1164                  uint16_t *group_list = mbedtls_calloc(length + 1, sizeof(uint16_t));
   \       0xBA   0x2102             MOVS     R1,#+2
   \       0xBC   0x4610             MOV      R0,R2
   \       0xBE   0x.... 0x....      BL       sl_calloc
   \       0xC2   0xEA5F 0x0800      MOVS     R8,R0
   1165                  if (group_list == NULL) {
   \       0xC6   0xD045             BEQ.N    ??ssl_handshake_init_8
   1166                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   1167                  }
   1168          
   1169                  for (size_t i = 0; i < length; i++) {
   \       0xC8   0x2600             MOVS     R6,#+0
   \       0xCA   0xE002             B.N      ??ssl_handshake_init_13
   1170                      uint16_t tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(
   1171                          curve_list[i]);
   1172                      if (tls_id == 0) {
   1173                          mbedtls_free(group_list);
   1174                          return MBEDTLS_ERR_SSL_BAD_CONFIG;
   1175                      }
   1176                      group_list[i] = tls_id;
   \                     ??ssl_handshake_init_14: (+1)
   \       0xCC   0xF828 0x0016      STRH     R0,[R8, R6, LSL #+1]
   \       0xD0   0x1C76             ADDS     R6,R6,#+1
   \                     ??ssl_handshake_init_13: (+1)
   \       0xD2   0x42BE             CMP      R6,R7
   \       0xD4   0xD208             BCS.N    ??ssl_handshake_init_15
   \       0xD6   0x5DA8             LDRB     R0,[R5, R6]
   \       0xD8   0x.... 0x....      BL       mbedtls_ssl_get_tls_id_from_ecp_group_id
   \       0xDC   0x0001             MOVS     R1,R0
   \       0xDE   0xD1F5             BNE.N    ??ssl_handshake_init_14
   \       0xE0   0x4640             MOV      R0,R8
   \       0xE2   0x.... 0x....      BL       sl_free
   \       0xE6   0xE02B             B.N      ??ssl_handshake_init_16
   1177                  }
   1178          
   1179                  group_list[length] = 0;
   \                     ??ssl_handshake_init_15: (+1)
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0xF828 0x0017      STRH     R0,[R8, R7, LSL #+1]
   1180          
   1181                  ssl->handshake->group_list = group_list;
   \       0xEE   0x6BA0             LDR      R0,[R4, #+56]
   1182                  ssl->handshake->group_list_heap_allocated = 1;
   \       0xF0   0x2101             MOVS     R1,#+1
   \       0xF2   0xF8C0 0x8044      STR      R8,[R0, #+68]
   \       0xF6   0x7101             STRB     R1,[R0, #+4]
   \       0xF8   0xE004             B.N      ??ssl_handshake_init_17
   1183              } else {
   1184                  ssl->handshake->group_list = ssl->conf->group_list;
   \                     ??ssl_handshake_init_10: (+1)
   \       0xFA   0x6BA1             LDR      R1,[R4, #+56]
   \       0xFC   0x6D00             LDR      R0,[R0, #+80]
   1185                  ssl->handshake->group_list_heap_allocated = 0;
   \       0xFE   0x2200             MOVS     R2,#+0
   \      0x100   0x710A             STRB     R2,[R1, #+4]
   \      0x102   0x6448             STR      R0,[R1, #+68]
   1186              }
   1187          #endif /* MBEDTLS_DEPRECATED_REMOVED */
   1188          #endif /* MBEDTLS_ECP_C */
   1189          
   1190          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   1191          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   1192          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1193              /* Heap allocate and translate sig_hashes from internal hash identifiers to
   1194                 signature algorithms IANA identifiers.  */
   1195              if (mbedtls_ssl_conf_is_tls12_only(ssl->conf) &&
   1196                  ssl->conf->sig_hashes != NULL) {
   \                     ??ssl_handshake_init_17: (+1)
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0x.... 0x....      BL       mbedtls_ssl_conf_is_tls12_only
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xBF1E             ITTT     NE
   \      0x10E   0x6820             LDRNE    R0,[R4, #+0]
   \      0x110   0x6C45             LDRNE    R5,[R0, #+68]
   \      0x112   0x2D00             CMPNE    R5,#+0
   \      0x114   0xD033             BEQ.N    ??ssl_handshake_init_18
   1197                  const int *md;
   1198                  const int *sig_hashes = ssl->conf->sig_hashes;
   1199                  size_t sig_algs_len = 0;
   \      0x116   0x2200             MOVS     R2,#+0
   1200                  uint16_t *p;
   1201          
   1202                  MBEDTLS_STATIC_ASSERT(MBEDTLS_SSL_MAX_SIG_ALG_LIST_LEN
   1203                                        <= (SIZE_MAX - (2 * sizeof(uint16_t))),
   1204                                        "MBEDTLS_SSL_MAX_SIG_ALG_LIST_LEN too big");
   1205          
   1206                  for (md = sig_hashes; *md != MBEDTLS_MD_NONE; md++) {
   \      0x118   0x462B             MOV      R3,R5
   \      0x11A   0xE00B             B.N      ??ssl_handshake_init_19
   1207                      if (mbedtls_ssl_hash_from_md_alg(*md) == MBEDTLS_SSL_HASH_NONE) {
   1208                          continue;
   1209                      }
   1210          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   1211                      sig_algs_len += sizeof(uint16_t);
   \                     ??ssl_handshake_init_20: (+1)
   \      0x11C   0x460A             MOV      R2,R1
   1212          #endif
   1213          
   1214          #if defined(MBEDTLS_RSA_C)
   1215                      sig_algs_len += sizeof(uint16_t);
   1216          #endif
   1217                      if (sig_algs_len > MBEDTLS_SSL_MAX_SIG_ALG_LIST_LEN) {
   \      0x11E   0xF64F 0x70FF      MOVW     R0,#+65535
   \      0x122   0x4282             CMP      R2,R0
   \      0x124   0xD305             BCC.N    ??ssl_handshake_init_21
   \      0x126   0xE00B             B.N      ??ssl_handshake_init_16
   \                     ??ssl_handshake_init_22: (+1)
   \      0x128   0x1F40             SUBS     R0,R0,#+5
   \      0x12A   0xD0F7             BEQ.N    ??ssl_handshake_init_20
   \      0x12C   0x1EC0             SUBS     R0,R0,#+3
   \      0x12E   0x2801             CMP      R0,#+1
   \      0x130   0xD9F4             BLS.N    ??ssl_handshake_init_20
   1218                          return MBEDTLS_ERR_SSL_BAD_CONFIG;
   1219                      }
   1220                  }
   \                     ??ssl_handshake_init_21: (+1)
   \      0x132   0x1D1B             ADDS     R3,R3,#+4
   \                     ??ssl_handshake_init_19: (+1)
   \      0x134   0x6818             LDR      R0,[R3, #+0]
   \      0x136   0x1C91             ADDS     R1,R2,#+2
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD1F5             BNE.N    ??ssl_handshake_init_22
   1221          
   1222                  if (sig_algs_len < MBEDTLS_SSL_MIN_SIG_ALG_LIST_LEN) {
   \      0x13C   0x2A01             CMP      R2,#+1
   \      0x13E   0xD802             BHI.N    ??ssl_handshake_init_23
   1223                      return MBEDTLS_ERR_SSL_BAD_CONFIG;
   \                     ??ssl_handshake_init_16: (+1)
   \      0x140   0x.... 0x....      LDR.W    R0,??DataTable29
   \      0x144   0xE01E             B.N      ??ssl_handshake_init_9
   1224                  }
   1225          
   1226                  ssl->handshake->sig_algs = mbedtls_calloc(1, sig_algs_len +
   1227                                                            sizeof(uint16_t));
   \                     ??ssl_handshake_init_23: (+1)
   \      0x146   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x14A   0x6BA1             LDR      R1,[R4, #+56]
   1228                  if (ssl->handshake->sig_algs == NULL) {
   \      0x14C   0xEA5F 0x0800      MOVS     R8,R0
   \      0x150   0x6488             STR      R0,[R1, #+72]
   \      0x152   0xD10B             BNE.N    ??ssl_handshake_init_24
   1229                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   \                     ??ssl_handshake_init_8: (+1)
   \      0x154   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \      0x158   0xE014             B.N      ??ssl_handshake_init_9
   1230                  }
   1231          
   1232                  p = (uint16_t *) ssl->handshake->sig_algs;
   1233                  for (md = sig_hashes; *md != MBEDTLS_MD_NONE; md++) {
   1234                      unsigned char hash = mbedtls_ssl_hash_from_md_alg(*md);
   \                     ??ssl_handshake_init_25: (+1)
   \      0x15A   0x.... 0x....      BL       mbedtls_ssl_hash_from_md_alg
   1235                      if (hash == MBEDTLS_SSL_HASH_NONE) {
   \      0x15E   0xB120             CBZ.N    R0,??ssl_handshake_init_26
   1236                          continue;
   1237                      }
   1238          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   1239                      *p = ((hash << 8) | MBEDTLS_SSL_SIG_ECDSA);
   \      0x160   0x0200             LSLS     R0,R0,#+8
   \      0x162   0xF040 0x0003      ORR      R0,R0,#0x3
   \      0x166   0xF828 0x0B02      STRH     R0,[R8], #+2
   1240                      p++;
   1241          #endif
   1242          #if defined(MBEDTLS_RSA_C)
   1243                      *p = ((hash << 8) | MBEDTLS_SSL_SIG_RSA);
   1244                      p++;
   1245          #endif
   1246                  }
   \                     ??ssl_handshake_init_26: (+1)
   \      0x16A   0x1D2D             ADDS     R5,R5,#+4
   \                     ??ssl_handshake_init_24: (+1)
   \      0x16C   0x6828             LDR      R0,[R5, #+0]
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD1F3             BNE.N    ??ssl_handshake_init_25
   1247                  *p = MBEDTLS_TLS_SIG_NONE;
   \      0x172   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1248                  ssl->handshake->sig_algs_heap_allocated = 1;
   \      0x176   0x6BA2             LDR      R2,[R4, #+56]
   \      0x178   0x2101             MOVS     R1,#+1
   \      0x17A   0x7151             STRB     R1,[R2, #+5]
   \      0x17C   0xE002             B.N      ??ssl_handshake_init_9
   1249              } else
   1250          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1251              {
   1252                  ssl->handshake->sig_algs_heap_allocated = 0;
   \                     ??ssl_handshake_init_18: (+1)
   \      0x17E   0x6BA1             LDR      R1,[R4, #+56]
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x7148             STRB     R0,[R1, #+5]
   1253              }
   1254          #endif /* !MBEDTLS_DEPRECATED_REMOVED */
   1255          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   1256              return 0;
   \                     ??ssl_handshake_init_9: (+1)
   \      0x184   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1257          }
   1258          
   1259          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   1260          /* Dummy cookie callbacks for defaults */
   1261          MBEDTLS_CHECK_RETURN_CRITICAL
   1262          static int ssl_cookie_write_dummy(void *ctx,
   1263                                            unsigned char **p, unsigned char *end,
   1264                                            const unsigned char *cli_id, size_t cli_id_len)
   1265          {
   1266              ((void) ctx);
   1267              ((void) p);
   1268              ((void) end);
   1269              ((void) cli_id);
   1270              ((void) cli_id_len);
   1271          
   1272              return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1273          }
   1274          
   1275          MBEDTLS_CHECK_RETURN_CRITICAL
   1276          static int ssl_cookie_check_dummy(void *ctx,
   1277                                            const unsigned char *cookie, size_t cookie_len,
   1278                                            const unsigned char *cli_id, size_t cli_id_len)
   1279          {
   1280              ((void) ctx);
   1281              ((void) cookie);
   1282              ((void) cookie_len);
   1283              ((void) cli_id);
   1284              ((void) cli_id_len);
   1285          
   1286              return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1287          }
   1288          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY && MBEDTLS_SSL_SRV_C */
   1289          
   1290          /*
   1291           * Initialize an SSL context
   1292           */

   \                                 In section .text, align 2, keep-with-next
   1293          void mbedtls_ssl_init(mbedtls_ssl_context *ssl)
   1294          {
   1295              memset(ssl, 0, sizeof(mbedtls_ssl_context));
   \                     mbedtls_ssl_init: (+1)
   \        0x0   0x21D4             MOVS     R1,#+212
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4
   1296          }
   1297          
   1298          MBEDTLS_CHECK_RETURN_CRITICAL
   1299          static int ssl_conf_version_check(const mbedtls_ssl_context *ssl)
   1300          {
   1301              const mbedtls_ssl_config *conf = ssl->conf;
   1302          
   1303          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1304              if (mbedtls_ssl_conf_is_tls13_only(conf)) {
   1305                  if (conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1306                      MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS 1.3 is not yet supported."));
   1307                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1308                  }
   1309          
   1310                  MBEDTLS_SSL_DEBUG_MSG(4, ("The SSL configuration is tls13 only."));
   1311                  return 0;
   1312              }
   1313          #endif
   1314          
   1315          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1316              if (mbedtls_ssl_conf_is_tls12_only(conf)) {
   1317                  MBEDTLS_SSL_DEBUG_MSG(4, ("The SSL configuration is tls12 only."));
   1318                  return 0;
   1319              }
   1320          #endif
   1321          
   1322          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1323              if (mbedtls_ssl_conf_is_hybrid_tls12_tls13(conf)) {
   1324                  if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   1325                      MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS not yet supported in Hybrid TLS 1.3 + TLS 1.2"));
   1326                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   1327                  }
   1328          
   1329                  MBEDTLS_SSL_DEBUG_MSG(4, ("The SSL configuration is TLS 1.3 or TLS 1.2."));
   1330                  return 0;
   1331              }
   1332          #endif
   1333          
   1334              MBEDTLS_SSL_DEBUG_MSG(1, ("The SSL configuration is invalid."));
   1335              return MBEDTLS_ERR_SSL_BAD_CONFIG;
   1336          }
   1337          
   1338          MBEDTLS_CHECK_RETURN_CRITICAL
   1339          static int ssl_conf_check(const mbedtls_ssl_context *ssl)
   1340          {
   1341              int ret;
   1342              ret = ssl_conf_version_check(ssl);
   1343              if (ret != 0) {
   1344                  return ret;
   1345              }
   1346          
   1347          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1348              /* RFC 8446 section 4.4.3
   1349               *
   1350               * If the verification fails, the receiver MUST terminate the handshake with
   1351               * a "decrypt_error" alert.
   1352               *
   1353               * If the client is configured as TLS 1.3 only with optional verify, return
   1354               * bad config.
   1355               *
   1356               */
   1357              if (mbedtls_ssl_conf_tls13_ephemeral_enabled(
   1358                      (mbedtls_ssl_context *) ssl)                            &&
   1359                  ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT                &&
   1360                  ssl->conf->max_tls_version == MBEDTLS_SSL_VERSION_TLS1_3    &&
   1361                  ssl->conf->min_tls_version == MBEDTLS_SSL_VERSION_TLS1_3    &&
   1362                  ssl->conf->authmode == MBEDTLS_SSL_VERIFY_OPTIONAL) {
   1363                  MBEDTLS_SSL_DEBUG_MSG(
   1364                      1, ("Optional verify auth mode "
   1365                          "is not available for TLS 1.3 client"));
   1366                  return MBEDTLS_ERR_SSL_BAD_CONFIG;
   1367              }
   1368          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   1369          
   1370              /* Space for further checks */
   1371          
   1372              return 0;
   1373          }
   1374          
   1375          /*
   1376           * Setup an SSL context
   1377           */
   1378          

   \                                 In section .text, align 2, keep-with-next
   1379          int mbedtls_ssl_setup(mbedtls_ssl_context *ssl,
   1380                                const mbedtls_ssl_config *conf)
   1381          {
   \                     mbedtls_ssl_setup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   1382              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1383              size_t in_buf_len = MBEDTLS_SSL_IN_BUFFER_LEN;
   1384              size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN;
   1385          
   1386              ssl->conf = conf;
   1387          
   1388              if ((ret = ssl_conf_check(ssl)) != 0) {
   \        0x4   0x6029             STR      R1,[R5, #+0]
   \        0x6   0x4608             MOV      R0,R1
   \        0x8   0x.... 0x....      BL       mbedtls_ssl_conf_is_tls12_only
   \        0xC   0xB350             CBZ.N    R0,??mbedtls_ssl_setup_0
   1389                  return ret;
   1390              }
   1391              ssl->tls_version = ssl->conf->max_tls_version;
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   1392          
   1393              /*
   1394               * Prepare base structures
   1395               */
   1396          
   1397              /* Set to NULL in case of an error condition */
   1398              ssl->out_buf = NULL;
   \       0x10   0xF105 0x0694      ADD      R6,R5,#+148
   1399          
   1400          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   1401              ssl->in_buf_len = in_buf_len;
   1402          #endif
   1403              ssl->in_buf = mbedtls_calloc(1, in_buf_len);
   \       0x14   0xF240 0x443D      MOVW     R4,#+1085
   \       0x18   0x8801             LDRH     R1,[R0, #+0]
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x8129             STRH     R1,[R5, #+8]
   \       0x1E   0x6030             STR      R0,[R6, #+0]
   \       0x20   0x4621             MOV      R1,R4
   \       0x22   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x26   0x65A8             STR      R0,[R5, #+88]
   1404              if (ssl->in_buf == NULL) {
   \       0x28   0xB120             CBZ.N    R0,??mbedtls_ssl_setup_1
   1405                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc(%" MBEDTLS_PRINTF_SIZET " bytes) failed", in_buf_len));
   1406                  ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
   1407                  goto error;
   1408              }
   1409          
   1410          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   1411              ssl->out_buf_len = out_buf_len;
   1412          #endif
   1413              ssl->out_buf = mbedtls_calloc(1, out_buf_len);
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x30   0x6030             STR      R0,[R6, #+0]
   1414              if (ssl->out_buf == NULL) {
   \       0x32   0xB9D0             CBNZ.N   R0,??mbedtls_ssl_setup_2
   1415                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc(%" MBEDTLS_PRINTF_SIZET " bytes) failed", out_buf_len));
   1416                  ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
   \                     ??mbedtls_ssl_setup_1: (+1)
   \       0x34   0x.... 0x....      LDR.W    R4,??DataTable26_2
   1417                  goto error;
   1418              }
   1419          
   1420              mbedtls_ssl_reset_in_out_pointers(ssl);
   1421          
   1422          #if defined(MBEDTLS_SSL_DTLS_SRTP)
   1423              memset(&ssl->dtls_srtp_info, 0, sizeof(ssl->dtls_srtp_info));
   1424          #endif
   1425          
   1426              if ((ret = ssl_handshake_init(ssl)) != 0) {
   1427                  goto error;
   1428              }
   1429          
   1430              return 0;
   1431          
   1432          error:
   1433              mbedtls_free(ssl->in_buf);
   \                     ??mbedtls_ssl_setup_3: (+1)
   \       0x38   0x6DA8             LDR      R0,[R5, #+88]
   \       0x3A   0x.... 0x....      BL       sl_free
   1434              mbedtls_free(ssl->out_buf);
   \       0x3E   0x6830             LDR      R0,[R6, #+0]
   \       0x40   0x.... 0x....      BL       sl_free
   1435          
   1436              ssl->conf = NULL;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x6028             STR      R0,[R5, #+0]
   1437          
   1438          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   1439              ssl->in_buf_len = 0;
   1440              ssl->out_buf_len = 0;
   1441          #endif
   1442              ssl->in_buf = NULL;
   \       0x48   0x65A8             STR      R0,[R5, #+88]
   1443              ssl->out_buf = NULL;
   \       0x4A   0x6030             STR      R0,[R6, #+0]
   1444          
   1445              ssl->in_hdr = NULL;
   \       0x4C   0x6628             STR      R0,[R5, #+96]
   1446              ssl->in_ctr = NULL;
   \       0x4E   0x65E8             STR      R0,[R5, #+92]
   1447              ssl->in_len = NULL;
   \       0x50   0x6668             STR      R0,[R5, #+100]
   1448              ssl->in_iv = NULL;
   \       0x52   0x66A8             STR      R0,[R5, #+104]
   1449              ssl->in_msg = NULL;
   \       0x54   0x66E8             STR      R0,[R5, #+108]
   1450          
   1451              ssl->out_hdr = NULL;
   \       0x56   0x60B0             STR      R0,[R6, #+8]
   1452              ssl->out_ctr = NULL;
   \       0x58   0x6070             STR      R0,[R6, #+4]
   1453              ssl->out_len = NULL;
   \       0x5A   0x60F0             STR      R0,[R6, #+12]
   1454              ssl->out_iv = NULL;
   \       0x5C   0x6130             STR      R0,[R6, #+16]
   1455              ssl->out_msg = NULL;
   \       0x5E   0x6170             STR      R0,[R6, #+20]
   1456          
   1457              return ret;
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_ssl_setup_0: (+1)
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable29
   \       0x68   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_ssl_setup_2: (+1)
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x.... 0x....      BL       mbedtls_ssl_reset_in_out_pointers
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x.... 0x....      BL       ssl_handshake_init
   \       0x76   0x0004             MOVS     R4,R0
   \       0x78   0xD1DE             BNE.N    ??mbedtls_ssl_setup_3
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xBD70             POP      {R4-R6,PC}
   1458          }
   1459          
   1460          /*
   1461           * Reset an initialized and used SSL context for re-use while retaining
   1462           * all application-set variables, function pointers and data.
   1463           *
   1464           * If partial is non-zero, keep data in the input buffer and client ID.
   1465           * (Use when a DTLS client reconnects from the same port.)
   1466           */

   \                                 In section .text, align 2, keep-with-next
   1467          void mbedtls_ssl_session_reset_msg_layer(mbedtls_ssl_context *ssl,
   1468                                                   int partial)
   1469          {
   \                     mbedtls_ssl_session_reset_msg_layer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1470          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   1471              size_t in_buf_len = ssl->in_buf_len;
   1472              size_t out_buf_len = ssl->out_buf_len;
   1473          #else
   1474              size_t in_buf_len = MBEDTLS_SSL_IN_BUFFER_LEN;
   1475              size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN;
   1476          #endif
   1477          
   1478          #if !defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) || !defined(MBEDTLS_SSL_SRV_C)
   1479              partial = 0;
   1480          #endif
   1481          
   1482              /* Cancel any possibly running timer */
   1483              mbedtls_ssl_set_timer(ssl, 0);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x.... 0x....      BL       mbedtls_ssl_set_timer
   1484          
   1485              mbedtls_ssl_reset_in_out_pointers(ssl);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_reset_in_out_pointers
   1486          
   1487              /* Reset incoming message parsing */
   1488              ssl->in_offt    = NULL;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6720             STR      R0,[R4, #+112]
   1489              ssl->nb_zero    = 0;
   \       0x14   0xF104 0x0584      ADD      R5,R4,#+132
   \       0x18   0x6028             STR      R0,[R5, #+0]
   1490              ssl->in_msgtype = 0;
   \       0x1A   0x6760             STR      R0,[R4, #+116]
   1491              ssl->in_msglen  = 0;
   \       0x1C   0x67A0             STR      R0,[R4, #+120]
   1492              ssl->in_hslen   = 0;
   \       0x1E   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1493              ssl->keep_current_message = 0;
   \       0x22   0x6068             STR      R0,[R5, #+4]
   1494              ssl->transform_in  = NULL;
   \       0x24   0x63E0             STR      R0,[R4, #+60]
   1495          
   1496          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1497              ssl->next_record_offset = 0;
   1498              ssl->in_epoch = 0;
   1499          #endif
   1500          
   1501              /* Keep current datagram if partial == 1 */
   1502              if (partial == 0) {
   1503                  ssl->in_left = 0;
   \       0x26   0x67E0             STR      R0,[R4, #+124]
   1504                  memset(ssl->in_buf, 0, in_buf_len);
   \       0x28   0x6DA0             LDR      R0,[R4, #+88]
   \       0x2A   0xF240 0x463D      MOVW     R6,#+1085
   \       0x2E   0x4631             MOV      R1,R6
   \       0x30   0x.... 0x....      BL       __aeabi_memclr
   1505              }
   1506          
   1507              ssl->send_alert = 0;
   \       0x34   0x2100             MOVS     R1,#+0
   1508          
   1509              /* Reset outgoing message writing */
   1510              ssl->out_msgtype = 0;
   1511              ssl->out_msglen  = 0;
   1512              ssl->out_left    = 0;
   1513              memset(ssl->out_buf, 0, out_buf_len);
   \       0x36   0x6928             LDR      R0,[R5, #+16]
   \       0x38   0x7229             STRB     R1,[R5, #+8]
   \       0x3A   0x62A9             STR      R1,[R5, #+40]
   \       0x3C   0x62E9             STR      R1,[R5, #+44]
   \       0x3E   0x6329             STR      R1,[R5, #+48]
   \       0x40   0x4631             MOV      R1,R6
   \       0x42   0x.... 0x....      BL       __aeabi_memclr
   1514              memset(ssl->cur_out_ctr, 0, sizeof(ssl->cur_out_ctr));
   \       0x46   0x.... 0x....      BL       ?Subroutine14
   1515              ssl->transform_out = NULL;
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x4A   0x6420             STR      R0,[R4, #+64]
   1516          
   1517          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   1518              mbedtls_ssl_dtls_replay_reset(ssl);
   1519          #endif
   1520          
   1521          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1522              if (ssl->transform) {
   \       0x4C   0x6C60             LDR      R0,[R4, #+68]
   \       0x4E   0xB130             CBZ.N    R0,??mbedtls_ssl_session_reset_msg_layer_0
   1523                  mbedtls_ssl_transform_free(ssl->transform);
   \       0x50   0x.... 0x....      BL       mbedtls_ssl_transform_free
   1524                  mbedtls_free(ssl->transform);
   \       0x54   0x6C60             LDR      R0,[R4, #+68]
   \       0x56   0x.... 0x....      BL       sl_free
   1525                  ssl->transform = NULL;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6460             STR      R0,[R4, #+68]
   1526              }
   1527          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1528          
   1529          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1530              mbedtls_ssl_transform_free(ssl->transform_application);
   1531              mbedtls_free(ssl->transform_application);
   1532              ssl->transform_application = NULL;
   1533          
   1534              if (ssl->handshake != NULL) {
   1535          #if defined(MBEDTLS_SSL_EARLY_DATA)
   1536                  mbedtls_ssl_transform_free(ssl->handshake->transform_earlydata);
   1537                  mbedtls_free(ssl->handshake->transform_earlydata);
   1538                  ssl->handshake->transform_earlydata = NULL;
   1539          #endif
   1540          
   1541                  mbedtls_ssl_transform_free(ssl->handshake->transform_handshake);
   1542                  mbedtls_free(ssl->handshake->transform_handshake);
   1543                  ssl->handshake->transform_handshake = NULL;
   1544              }
   1545          
   1546          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   1547          }
   \                     ??mbedtls_ssl_session_reset_msg_layer_0: (+1)
   \       0x5E   0xBD70             POP      {R4-R6,PC}
   1548          

   \                                 In section .text, align 2, keep-with-next
   1549          int mbedtls_ssl_session_reset_int(mbedtls_ssl_context *ssl, int partial)
   1550          {
   \                     mbedtls_ssl_session_reset_int: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1551              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1552          
   1553              ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x6062             STR      R2,[R4, #+4]
   1554          
   1555              mbedtls_ssl_session_reset_msg_layer(ssl, partial);
   \        0x8   0x.... 0x....      BL       mbedtls_ssl_session_reset_msg_layer
   1556          
   1557              /* Reset renegotiation state */
   1558          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1559              ssl->renego_status = MBEDTLS_SSL_INITIAL_HANDSHAKE;
   1560              ssl->renego_records_seen = 0;
   1561          
   1562              ssl->verify_data_len = 0;
   1563              memset(ssl->own_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN);
   1564              memset(ssl->peer_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN);
   1565          #endif
   1566              ssl->secure_renegotiation = MBEDTLS_SSL_LEGACY_RENEGOTIATION;
   1567          
   1568              ssl->session_in  = NULL;
   1569              ssl->session_out = NULL;
   1570              if (ssl->session) {
   \        0xC   0x6B20             LDR      R0,[R4, #+48]
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0xF8C4 0x20C4      STR      R2,[R4, #+196]
   \       0x14   0x62A2             STR      R2,[R4, #+40]
   \       0x16   0x62E2             STR      R2,[R4, #+44]
   \       0x18   0xB130             CBZ.N    R0,??mbedtls_ssl_session_reset_int_0
   1571                  mbedtls_ssl_session_free(ssl->session);
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_session_free
   1572                  mbedtls_free(ssl->session);
   \       0x1E   0x6B20             LDR      R0,[R4, #+48]
   \       0x20   0x.... 0x....      BL       sl_free
   1573                  ssl->session = NULL;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6320             STR      R0,[R4, #+48]
   1574              }
   1575          
   1576          #if defined(MBEDTLS_SSL_ALPN)
   1577              ssl->alpn_chosen = NULL;
   1578          #endif
   1579          
   1580          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   1581              int free_cli_id = 1;
   1582          #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE)
   1583              free_cli_id = (partial == 0);
   1584          #endif
   1585              if (free_cli_id) {
   1586                  mbedtls_free(ssl->cli_id);
   1587                  ssl->cli_id = NULL;
   1588                  ssl->cli_id_len = 0;
   1589              }
   1590          #endif
   1591          
   1592              if ((ret = ssl_handshake_init(ssl)) != 0) {
   1593                  return ret;
   \                     ??mbedtls_ssl_session_reset_int_0: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0xE8BD 0x4010      POP      {R4,LR}
   \       0x2E   0x....             B.N      ssl_handshake_init
   1594              }
   1595          
   1596              return 0;
   1597          }
   1598          
   1599          /*
   1600           * Reset an initialized and used SSL context for re-use while retaining
   1601           * all application-set variables, function pointers and data.
   1602           */

   \                                 In section .text, align 2, keep-with-next
   1603          int mbedtls_ssl_session_reset(mbedtls_ssl_context *ssl)
   1604          {
   1605              return mbedtls_ssl_session_reset_int(ssl, 0);
   \                     mbedtls_ssl_session_reset: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      mbedtls_ssl_session_reset_int
   1606          }
   1607          
   1608          /*
   1609           * SSL set accessors
   1610           */

   \                                 In section .text, align 2, keep-with-next
   1611          void mbedtls_ssl_conf_endpoint(mbedtls_ssl_config *conf, int endpoint)
   1612          {
   1613              conf->endpoint   = endpoint;
   \                     mbedtls_ssl_conf_endpoint: (+1)
   \        0x0   0x7101             STRB     R1,[R0, #+4]
   1614          }
   \        0x2   0x4770             BX       LR
   1615          

   \                                 In section .text, align 2, keep-with-next
   1616          void mbedtls_ssl_conf_transport(mbedtls_ssl_config *conf, int transport)
   1617          {
   1618              conf->transport = transport;
   \                     mbedtls_ssl_conf_transport: (+1)
   \        0x0   0x7141             STRB     R1,[R0, #+5]
   1619          }
   \        0x2   0x4770             BX       LR
   1620          
   1621          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   1622          void mbedtls_ssl_conf_dtls_anti_replay(mbedtls_ssl_config *conf, char mode)
   1623          {
   1624              conf->anti_replay = mode;
   1625          }
   1626          #endif
   1627          

   \                                 In section .text, align 2, keep-with-next
   1628          void mbedtls_ssl_conf_dtls_badmac_limit(mbedtls_ssl_config *conf, unsigned limit)
   1629          {
   1630              conf->badmac_limit = limit;
   \                     mbedtls_ssl_conf_dtls_badmac_limit: (+1)
   \        0x0   0x6581             STR      R1,[R0, #+88]
   1631          }
   \        0x2   0x4770             BX       LR
   1632          
   1633          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1634          
   1635          void mbedtls_ssl_set_datagram_packing(mbedtls_ssl_context *ssl,
   1636                                                unsigned allow_packing)
   1637          {
   1638              ssl->disable_datagram_packing = !allow_packing;
   1639          }
   1640          
   1641          void mbedtls_ssl_conf_handshake_timeout(mbedtls_ssl_config *conf,
   1642                                                  uint32_t min, uint32_t max)
   1643          {
   1644              conf->hs_timeout_min = min;
   1645              conf->hs_timeout_max = max;
   1646          }
   1647          #endif
   1648          

   \                                 In section .text, align 2, keep-with-next
   1649          void mbedtls_ssl_conf_authmode(mbedtls_ssl_config *conf, int authmode)
   1650          {
   1651              conf->authmode   = authmode;
   \                     mbedtls_ssl_conf_authmode: (+1)
   \        0x0   0x7181             STRB     R1,[R0, #+6]
   1652          }
   \        0x2   0x4770             BX       LR
   1653          
   1654          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
   1655          void mbedtls_ssl_conf_verify(mbedtls_ssl_config *conf,
   1656                                       int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   1657                                       void *p_vrfy)
   1658          {
   1659              conf->f_vrfy      = f_vrfy;
   \                     mbedtls_ssl_conf_verify: (+1)
   \        0x0   0x62C1             STR      R1,[R0, #+44]
   1660              conf->p_vrfy      = p_vrfy;
   \        0x2   0x6302             STR      R2,[R0, #+48]
   1661          }
   \        0x4   0x4770             BX       LR
   1662          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   1663          

   \                                 In section .text, align 2, keep-with-next
   1664          void mbedtls_ssl_conf_rng(mbedtls_ssl_config *conf,
   1665                                    int (*f_rng)(void *, unsigned char *, size_t),
   1666                                    void *p_rng)
   1667          {
   1668              conf->f_rng      = f_rng;
   \                     mbedtls_ssl_conf_rng: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
   1669              conf->p_rng      = p_rng;
   \        0x2   0x61C2             STR      R2,[R0, #+28]
   1670          }
   \        0x4   0x4770             BX       LR
   1671          

   \                                 In section .text, align 2, keep-with-next
   1672          void mbedtls_ssl_conf_dbg(mbedtls_ssl_config *conf,
   1673                                    void (*f_dbg)(void *, int, const char *, int, const char *),
   1674                                    void  *p_dbg)
   1675          {
   1676              conf->f_dbg      = f_dbg;
   \                     mbedtls_ssl_conf_dbg: (+1)
   \        0x0   0x....             B.N      ?Subroutine0
   1677              conf->p_dbg      = p_dbg;
   1678          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x6142             STR      R2,[R0, #+20]
   \        0x4   0x4770             BX       LR
   1679          

   \                                 In section .text, align 2, keep-with-next
   1680          void mbedtls_ssl_set_bio(mbedtls_ssl_context *ssl,
   1681                                   void *p_bio,
   1682                                   mbedtls_ssl_send_t *f_send,
   1683                                   mbedtls_ssl_recv_t *f_recv,
   1684                                   mbedtls_ssl_recv_timeout_t *f_recv_timeout)
   1685          {
   \                     mbedtls_ssl_set_bio: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x9C02             LDR      R4,[SP, #+8]
   1686              ssl->p_bio          = p_bio;
   \        0x4   0x6241             STR      R1,[R0, #+36]
   1687              ssl->f_send         = f_send;
   \        0x6   0x6182             STR      R2,[R0, #+24]
   1688              ssl->f_recv         = f_recv;
   \        0x8   0x61C3             STR      R3,[R0, #+28]
   1689              ssl->f_recv_timeout = f_recv_timeout;
   \        0xA   0x6204             STR      R4,[R0, #+32]
   1690          }
   \        0xC   0xBD10             POP      {R4,PC}
   1691          
   1692          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1693          void mbedtls_ssl_set_mtu(mbedtls_ssl_context *ssl, uint16_t mtu)
   1694          {
   1695              ssl->mtu = mtu;
   1696          }
   1697          #endif
   1698          

   \                                 In section .text, align 2, keep-with-next
   1699          void mbedtls_ssl_conf_read_timeout(mbedtls_ssl_config *conf, uint32_t timeout)
   1700          {
   1701              conf->read_timeout   = timeout;
   \                     mbedtls_ssl_conf_read_timeout: (+1)
   \        0x0   0x6541             STR      R1,[R0, #+84]
   1702          }
   \        0x2   0x4770             BX       LR
   1703          

   \                                 In section .text, align 2, keep-with-next
   1704          void mbedtls_ssl_set_timer_cb(mbedtls_ssl_context *ssl,
   1705                                        void *p_timer,
   1706                                        mbedtls_ssl_set_timer_t *f_set_timer,
   1707                                        mbedtls_ssl_get_timer_t *f_get_timer)
   1708          {
   1709              ssl->p_timer        = p_timer;
   \                     mbedtls_ssl_set_timer_cb: (+1)
   \        0x0   0x64C1             STR      R1,[R0, #+76]
   1710              ssl->f_set_timer    = f_set_timer;
   \        0x2   0x6502             STR      R2,[R0, #+80]
   1711              ssl->f_get_timer    = f_get_timer;
   \        0x4   0x6543             STR      R3,[R0, #+84]
   1712          
   1713              /* Make sure we start with no timer running */
   1714              mbedtls_ssl_set_timer(ssl, 0);
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x.... 0x....      B.W      mbedtls_ssl_set_timer
   1715          }
   1716          
   1717          #if defined(MBEDTLS_SSL_SRV_C)
   1718          void mbedtls_ssl_conf_session_cache(mbedtls_ssl_config *conf,
   1719                                              void *p_cache,
   1720                                              mbedtls_ssl_cache_get_t *f_get_cache,
   1721                                              mbedtls_ssl_cache_set_t *f_set_cache)
   1722          {
   1723              conf->p_cache = p_cache;
   1724              conf->f_get_cache = f_get_cache;
   1725              conf->f_set_cache = f_set_cache;
   1726          }
   1727          #endif /* MBEDTLS_SSL_SRV_C */
   1728          
   1729          #if defined(MBEDTLS_SSL_CLI_C)

   \                                 In section .text, align 2, keep-with-next
   1730          int mbedtls_ssl_set_session(mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session)
   1731          {
   \                     mbedtls_ssl_set_session: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1732              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1733          
   1734              if (ssl == NULL ||
   1735                  session == NULL ||
   1736                  ssl->session_negotiate == NULL ||
   1737                  ssl->conf->endpoint != MBEDTLS_SSL_IS_CLIENT) {
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD004             BEQ.N    ??mbedtls_ssl_set_session_0
   \        0xA   0x6B60             LDR      R0,[R4, #+52]
   \        0xC   0xB110             CBZ.N    R0,??mbedtls_ssl_set_session_0
   \        0xE   0x6823             LDR      R3,[R4, #+0]
   \       0x10   0x791A             LDRB     R2,[R3, #+4]
   \       0x12   0xB102             CBZ.N    R2,??mbedtls_ssl_set_session_1
   1738                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_set_session_0: (+1)
   \       0x14   0x....             B.N      ?Subroutine3
   1739              }
   1740          
   1741              if (ssl->handshake->resume == 1) {
   \                     ??mbedtls_ssl_set_session_1: (+1)
   \       0x16   0x6BA3             LDR      R3,[R4, #+56]
   \       0x18   0x781A             LDRB     R2,[R3, #+0]
   \       0x1A   0x2A01             CMP      R2,#+1
   \       0x1C   0xD100             BNE.N    ??mbedtls_ssl_set_session_2
   1742                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   \       0x1E   0x....             B.N      ?Subroutine2
   1743              }
   1744          
   1745          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1746              if (session->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   1747                  const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   1748                      mbedtls_ssl_ciphersuite_from_id(session->ciphersuite);
   1749          
   1750                  if (mbedtls_ssl_validate_ciphersuite(
   1751                          ssl, ciphersuite_info, MBEDTLS_SSL_VERSION_TLS1_3,
   1752                          MBEDTLS_SSL_VERSION_TLS1_3) != 0) {
   1753                      MBEDTLS_SSL_DEBUG_MSG(4, ("%d is not a valid TLS 1.3 ciphersuite.",
   1754                                                session->ciphersuite));
   1755                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   1756                  }
   1757              }
   1758          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   1759          
   1760              if ((ret = mbedtls_ssl_session_copy(ssl->session_negotiate,
   1761                                                  session)) != 0) {
   \                     ??mbedtls_ssl_set_session_2: (+1)
   \       0x20   0x.... 0x....      BL       mbedtls_ssl_session_copy
   \       0x24   0xB918             CBNZ.N   R0,??mbedtls_ssl_set_session_3
   1762                  return ret;
   1763              }
   1764          
   1765              ssl->handshake->resume = 1;
   \       0x26   0x6BA1             LDR      R1,[R4, #+56]
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7008             STRB     R0,[R1, #+0]
   1766          
   1767              return 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_set_session_3: (+1)
   \       0x2E   0xBD10             POP      {R4,PC}
   1768          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \        0x4   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable26_3
   \        0x2   0xBD10             POP      {R4,PC}
   1769          #endif /* MBEDTLS_SSL_CLI_C */
   1770          

   \                                 In section .text, align 2, keep-with-next
   1771          void mbedtls_ssl_conf_ciphersuites(mbedtls_ssl_config *conf,
   1772                                             const int *ciphersuites)
   1773          {
   1774              conf->ciphersuite_list = ciphersuites;
   \                     mbedtls_ssl_conf_ciphersuites: (+1)
   \        0x0   0x60C1             STR      R1,[R0, #+12]
   1775          }
   \        0x2   0x4770             BX       LR
   1776          
   1777          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   1778          void mbedtls_ssl_conf_tls13_key_exchange_modes(mbedtls_ssl_config *conf,
   1779                                                         const int kex_modes)
   1780          {
   1781              conf->tls13_kex_modes = kex_modes & MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL;
   1782          }
   1783          
   1784          #if defined(MBEDTLS_SSL_EARLY_DATA)
   1785          void mbedtls_ssl_tls13_conf_early_data(mbedtls_ssl_config *conf,
   1786                                                 int early_data_enabled)
   1787          {
   1788              conf->early_data_enabled = early_data_enabled;
   1789          }
   1790          
   1791          #if defined(MBEDTLS_SSL_SRV_C)
   1792          void mbedtls_ssl_tls13_conf_max_early_data_size(
   1793              mbedtls_ssl_config *conf, uint32_t max_early_data_size)
   1794          {
   1795              conf->max_early_data_size = max_early_data_size;
   1796          }
   1797          #endif /* MBEDTLS_SSL_SRV_C */
   1798          
   1799          #endif /* MBEDTLS_SSL_EARLY_DATA */
   1800          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   1801          
   1802          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
   1803          void mbedtls_ssl_conf_cert_profile(mbedtls_ssl_config *conf,
   1804                                             const mbedtls_x509_crt_profile *profile)
   1805          {
   1806              conf->cert_profile = profile;
   \                     mbedtls_ssl_conf_cert_profile: (+1)
   \        0x0   0x6341             STR      R1,[R0, #+52]
   1807          }
   \        0x2   0x4770             BX       LR
   1808          

   \                                 In section .text, align 2, keep-with-next
   1809          static void ssl_key_cert_free(mbedtls_ssl_key_cert *key_cert)
   1810          {
   \                     ssl_key_cert_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1811              mbedtls_ssl_key_cert *cur = key_cert, *next;
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xE003             B.N      ??ssl_key_cert_free_0
   1812          
   1813              while (cur != NULL) {
   1814                  next = cur->next;
   \                     ??ssl_key_cert_free_1: (+1)
   \        0x6   0x6884             LDR      R4,[R0, #+8]
   1815                  mbedtls_free(cur);
   \        0x8   0x.... 0x....      BL       sl_free
   1816                  cur = next;
   \        0xC   0x0020             MOVS     R0,R4
   1817              }
   \                     ??ssl_key_cert_free_0: (+1)
   \        0xE   0xD1FA             BNE.N    ??ssl_key_cert_free_1
   1818          }
   \       0x10   0xBD10             POP      {R4,PC}
   1819          
   1820          /* Append a new keycert entry to a (possibly empty) list */
   1821          MBEDTLS_CHECK_RETURN_CRITICAL
   1822          static int ssl_append_key_cert(mbedtls_ssl_key_cert **head,
   1823                                         mbedtls_x509_crt *cert,
   1824                                         mbedtls_pk_context *key)
   1825          {
   1826              mbedtls_ssl_key_cert *new_cert;
   1827          
   1828              if (cert == NULL) {
   1829                  /* Free list if cert is null */
   1830                  ssl_key_cert_free(*head);
   1831                  *head = NULL;
   1832                  return 0;
   1833              }
   1834          
   1835              new_cert = mbedtls_calloc(1, sizeof(mbedtls_ssl_key_cert));
   1836              if (new_cert == NULL) {
   1837                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   1838              }
   1839          
   1840              new_cert->cert = cert;
   1841              new_cert->key  = key;
   1842              new_cert->next = NULL;
   1843          
   1844              /* Update head if the list was null, else add to the end */
   1845              if (*head == NULL) {
   1846                  *head = new_cert;
   1847              } else {
   1848                  mbedtls_ssl_key_cert *cur = *head;
   1849                  while (cur->next != NULL) {
   1850                      cur = cur->next;
   1851                  }
   1852                  cur->next = new_cert;
   1853              }
   1854          
   1855              return 0;
   1856          }
   1857          

   \                                 In section .text, align 2, keep-with-next
   1858          int mbedtls_ssl_conf_own_cert(mbedtls_ssl_config *conf,
   1859                                        mbedtls_x509_crt *own_cert,
   1860                                        mbedtls_pk_context *pk_key)
   1861          {
   \                     mbedtls_ssl_conf_own_cert: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x4616             MOV      R6,R2
   1862              return ssl_append_key_cert(&conf->key_cert, own_cert, pk_key);
   \        0x8   0xD106             BNE.N    ??mbedtls_ssl_conf_own_cert_0
   \        0xA   0x6BA8             LDR      R0,[R5, #+56]
   \        0xC   0x.... 0x....      BL       ssl_key_cert_free
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x63A9             STR      R1,[R5, #+56]
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_ssl_conf_own_cert_0: (+1)
   \       0x18   0x210C             MOVS     R1,#+12
   \       0x1A   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x1E   0x0001             MOVS     R1,R0
   \       0x20   0xD102             BNE.N    ??mbedtls_ssl_conf_own_cert_1
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \       0x26   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_ssl_conf_own_cert_1: (+1)
   \       0x28   0x600C             STR      R4,[R1, #+0]
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x604E             STR      R6,[R1, #+4]
   \       0x2E   0x6088             STR      R0,[R1, #+8]
   \       0x30   0x6BAA             LDR      R2,[R5, #+56]
   \       0x32   0xB912             CBNZ.N   R2,??mbedtls_ssl_conf_own_cert_2
   \       0x34   0x63A9             STR      R1,[R5, #+56]
   \       0x36   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_ssl_conf_own_cert_3: (+1)
   \       0x38   0x4602             MOV      R2,R0
   \                     ??mbedtls_ssl_conf_own_cert_2: (+1)
   \       0x3A   0x6890             LDR      R0,[R2, #+8]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1FB             BNE.N    ??mbedtls_ssl_conf_own_cert_3
   \       0x40   0x6091             STR      R1,[R2, #+8]
   \       0x42   0xBD70             POP      {R4-R6,PC}
   1863          }
   1864          

   \                                 In section .text, align 2, keep-with-next
   1865          void mbedtls_ssl_conf_ca_chain(mbedtls_ssl_config *conf,
   1866                                         mbedtls_x509_crt *ca_chain,
   1867                                         mbedtls_x509_crl *ca_crl)
   1868          {
   1869              conf->ca_chain   = ca_chain;
   \                     mbedtls_ssl_conf_ca_chain: (+1)
   \        0x0   0x63C1             STR      R1,[R0, #+60]
   1870              conf->ca_crl     = ca_crl;
   \        0x2   0x6402             STR      R2,[R0, #+64]
   1871          
   1872          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   1873              /* mbedtls_ssl_conf_ca_chain() and mbedtls_ssl_conf_ca_cb()
   1874               * cannot be used together. */
   1875              conf->f_ca_cb = NULL;
   1876              conf->p_ca_cb = NULL;
   1877          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   1878          }
   \        0x4   0x4770             BX       LR
   1879          
   1880          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   1881          void mbedtls_ssl_conf_ca_cb(mbedtls_ssl_config *conf,
   1882                                      mbedtls_x509_crt_ca_cb_t f_ca_cb,
   1883                                      void *p_ca_cb)
   1884          {
   1885              conf->f_ca_cb = f_ca_cb;
   1886              conf->p_ca_cb = p_ca_cb;
   1887          
   1888              /* mbedtls_ssl_conf_ca_chain() and mbedtls_ssl_conf_ca_cb()
   1889               * cannot be used together. */
   1890              conf->ca_chain   = NULL;
   1891              conf->ca_crl     = NULL;
   1892          }
   1893          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   1894          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   1895          
   1896          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   1897          const unsigned char *mbedtls_ssl_get_hs_sni(mbedtls_ssl_context *ssl,
   1898                                                      size_t *name_len)
   1899          {
   1900              *name_len = ssl->handshake->sni_name_len;
   1901              return ssl->handshake->sni_name;
   1902          }
   1903          
   1904          int mbedtls_ssl_set_hs_own_cert(mbedtls_ssl_context *ssl,
   1905                                          mbedtls_x509_crt *own_cert,
   1906                                          mbedtls_pk_context *pk_key)
   1907          {
   1908              return ssl_append_key_cert(&ssl->handshake->sni_key_cert,
   1909                                         own_cert, pk_key);
   1910          }
   1911          
   1912          void mbedtls_ssl_set_hs_ca_chain(mbedtls_ssl_context *ssl,
   1913                                           mbedtls_x509_crt *ca_chain,
   1914                                           mbedtls_x509_crl *ca_crl)
   1915          {
   1916              ssl->handshake->sni_ca_chain   = ca_chain;
   1917              ssl->handshake->sni_ca_crl     = ca_crl;
   1918          }
   1919          
   1920          #if defined(MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED)
   1921          void mbedtls_ssl_set_hs_dn_hints(mbedtls_ssl_context *ssl,
   1922                                           const mbedtls_x509_crt *crt)
   1923          {
   1924              ssl->handshake->dn_hints = crt;
   1925          }
   1926          #endif /* MBEDTLS_KEY_EXCHANGE_CERT_REQ_ALLOWED_ENABLED */
   1927          
   1928          void mbedtls_ssl_set_hs_authmode(mbedtls_ssl_context *ssl,
   1929                                           int authmode)
   1930          {
   1931              ssl->handshake->sni_authmode = authmode;
   1932          }
   1933          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   1934          
   1935          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 4, keep-with-next
   1936          void mbedtls_ssl_set_verify(mbedtls_ssl_context *ssl,
   1937                                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   1938                                      void *p_vrfy)
   1939          {
   1940              ssl->f_vrfy = f_vrfy;
   \                     mbedtls_ssl_set_verify: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
   1941              ssl->p_vrfy = p_vrfy;
   1942          }
   1943          #endif
   1944          
   1945          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1946          
   1947          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1948          static const uint8_t jpake_server_id[] = { 's', 'e', 'r', 'v', 'e', 'r' };
   1949          static const uint8_t jpake_client_id[] = { 'c', 'l', 'i', 'e', 'n', 't' };
   1950          
   1951          static psa_status_t mbedtls_ssl_set_hs_ecjpake_password_common(
   1952              mbedtls_ssl_context *ssl,
   1953              mbedtls_svc_key_id_t pwd)
   1954          {
   1955              psa_status_t status;
   1956              psa_pake_cipher_suite_t cipher_suite = psa_pake_cipher_suite_init();
   1957              const uint8_t *user = NULL;
   1958              size_t user_len = 0;
   1959              const uint8_t *peer = NULL;
   1960              size_t peer_len = 0;
   1961              psa_pake_cs_set_algorithm(&cipher_suite, PSA_ALG_JPAKE);
   1962              psa_pake_cs_set_primitive(&cipher_suite,
   1963                                        PSA_PAKE_PRIMITIVE(PSA_PAKE_PRIMITIVE_TYPE_ECC,
   1964                                                           PSA_ECC_FAMILY_SECP_R1,
   1965                                                           256));
   1966              psa_pake_cs_set_hash(&cipher_suite, PSA_ALG_SHA_256);
   1967          
   1968              status = psa_pake_setup(&ssl->handshake->psa_pake_ctx, &cipher_suite);
   1969              if (status != PSA_SUCCESS) {
   1970                  return status;
   1971              }
   1972          
   1973              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   1974                  user = jpake_server_id;
   1975                  user_len = sizeof(jpake_server_id);
   1976                  peer = jpake_client_id;
   1977                  peer_len = sizeof(jpake_client_id);
   1978              } else {
   1979                  user = jpake_client_id;
   1980                  user_len = sizeof(jpake_client_id);
   1981                  peer = jpake_server_id;
   1982                  peer_len = sizeof(jpake_server_id);
   1983              }
   1984          
   1985              status = psa_pake_set_user(&ssl->handshake->psa_pake_ctx, user, user_len);
   1986              if (status != PSA_SUCCESS) {
   1987                  return status;
   1988              }
   1989          
   1990              status = psa_pake_set_peer(&ssl->handshake->psa_pake_ctx, peer, peer_len);
   1991              if (status != PSA_SUCCESS) {
   1992                  return status;
   1993              }
   1994          
   1995              status = psa_pake_set_password_key(&ssl->handshake->psa_pake_ctx, pwd);
   1996              if (status != PSA_SUCCESS) {
   1997                  return status;
   1998              }
   1999          
   2000              ssl->handshake->psa_pake_ctx_is_ok = 1;
   2001          
   2002              return PSA_SUCCESS;
   2003          }
   2004          
   2005          int mbedtls_ssl_set_hs_ecjpake_password(mbedtls_ssl_context *ssl,
   2006                                                  const unsigned char *pw,
   2007                                                  size_t pw_len)
   2008          {
   2009              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   2010              psa_status_t status;
   2011          
   2012              if (ssl->handshake == NULL || ssl->conf == NULL) {
   2013                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2014              }
   2015          
   2016              /* Empty password is not valid  */
   2017              if ((pw == NULL) || (pw_len == 0)) {
   2018                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2019              }
   2020          
   2021              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DERIVE);
   2022              psa_set_key_algorithm(&attributes, PSA_ALG_JPAKE);
   2023              psa_set_key_type(&attributes, PSA_KEY_TYPE_PASSWORD);
   2024          
   2025              status = psa_import_key(&attributes, pw, pw_len,
   2026                                      &ssl->handshake->psa_pake_password);
   2027              if (status != PSA_SUCCESS) {
   2028                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2029              }
   2030          
   2031              status = mbedtls_ssl_set_hs_ecjpake_password_common(ssl,
   2032                                                                  ssl->handshake->psa_pake_password);
   2033              if (status != PSA_SUCCESS) {
   2034                  psa_destroy_key(ssl->handshake->psa_pake_password);
   2035                  psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   2036                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2037              }
   2038          
   2039              return 0;
   2040          }
   2041          
   2042          int mbedtls_ssl_set_hs_ecjpake_password_opaque(mbedtls_ssl_context *ssl,
   2043                                                         mbedtls_svc_key_id_t pwd)
   2044          {
   2045              psa_status_t status;
   2046          
   2047              if (ssl->handshake == NULL || ssl->conf == NULL) {
   2048                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2049              }
   2050          
   2051              if (mbedtls_svc_key_id_is_null(pwd)) {
   2052                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2053              }
   2054          
   2055              status = mbedtls_ssl_set_hs_ecjpake_password_common(ssl, pwd);
   2056              if (status != PSA_SUCCESS) {
   2057                  psa_pake_abort(&ssl->handshake->psa_pake_ctx);
   2058                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2059              }
   2060          
   2061              return 0;
   2062          }
   2063          #else /* MBEDTLS_USE_PSA_CRYPTO */
   2064          int mbedtls_ssl_set_hs_ecjpake_password(mbedtls_ssl_context *ssl,
   2065                                                  const unsigned char *pw,
   2066                                                  size_t pw_len)
   2067          {
   2068              mbedtls_ecjpake_role role;
   2069          
   2070              if (ssl->handshake == NULL || ssl->conf == NULL) {
   2071                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2072              }
   2073          
   2074              /* Empty password is not valid  */
   2075              if ((pw == NULL) || (pw_len == 0)) {
   2076                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2077              }
   2078          
   2079              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   2080                  role = MBEDTLS_ECJPAKE_SERVER;
   2081              } else {
   2082                  role = MBEDTLS_ECJPAKE_CLIENT;
   2083              }
   2084          
   2085              return mbedtls_ecjpake_setup(&ssl->handshake->ecjpake_ctx,
   2086                                           role,
   2087                                           MBEDTLS_MD_SHA256,
   2088                                           MBEDTLS_ECP_DP_SECP256R1,
   2089                                           pw, pw_len);
   2090          }
   2091          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2092          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2093          
   2094          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_PSK_ENABLED)
   2095          int mbedtls_ssl_conf_has_static_psk(mbedtls_ssl_config const *conf)
   2096          {
   2097              if (conf->psk_identity     == NULL ||
   2098                  conf->psk_identity_len == 0) {
   2099                  return 0;
   2100              }
   2101          
   2102          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2103              if (!mbedtls_svc_key_id_is_null(conf->psk_opaque)) {
   2104                  return 1;
   2105              }
   2106          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2107          
   2108              if (conf->psk != NULL && conf->psk_len != 0) {
   2109                  return 1;
   2110              }
   2111          
   2112              return 0;
   2113          }
   2114          
   2115          static void ssl_conf_remove_psk(mbedtls_ssl_config *conf)
   2116          {
   2117              /* Remove reference to existing PSK, if any. */
   2118          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2119              if (!mbedtls_svc_key_id_is_null(conf->psk_opaque)) {
   2120                  /* The maintenance of the PSK key slot is the
   2121                   * user's responsibility. */
   2122                  conf->psk_opaque = MBEDTLS_SVC_KEY_ID_INIT;
   2123              }
   2124          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2125              if (conf->psk != NULL) {
   2126                  mbedtls_zeroize_and_free(conf->psk, conf->psk_len);
   2127                  conf->psk = NULL;
   2128                  conf->psk_len = 0;
   2129              }
   2130          
   2131              /* Remove reference to PSK identity, if any. */
   2132              if (conf->psk_identity != NULL) {
   2133                  mbedtls_free(conf->psk_identity);
   2134                  conf->psk_identity = NULL;
   2135                  conf->psk_identity_len = 0;
   2136              }
   2137          }
   2138          
   2139          /* This function assumes that PSK identity in the SSL config is unset.
   2140           * It checks that the provided identity is well-formed and attempts
   2141           * to make a copy of it in the SSL config.
   2142           * On failure, the PSK identity in the config remains unset. */
   2143          MBEDTLS_CHECK_RETURN_CRITICAL
   2144          static int ssl_conf_set_psk_identity(mbedtls_ssl_config *conf,
   2145                                               unsigned char const *psk_identity,
   2146                                               size_t psk_identity_len)
   2147          {
   2148              /* Identity len will be encoded on two bytes */
   2149              if (psk_identity               == NULL ||
   2150                  psk_identity_len           == 0    ||
   2151                  (psk_identity_len >> 16) != 0    ||
   2152                  psk_identity_len > MBEDTLS_SSL_OUT_CONTENT_LEN) {
   2153                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2154              }
   2155          
   2156              conf->psk_identity = mbedtls_calloc(1, psk_identity_len);
   2157              if (conf->psk_identity == NULL) {
   2158                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2159              }
   2160          
   2161              conf->psk_identity_len = psk_identity_len;
   2162              memcpy(conf->psk_identity, psk_identity, conf->psk_identity_len);
   2163          
   2164              return 0;
   2165          }
   2166          
   2167          int mbedtls_ssl_conf_psk(mbedtls_ssl_config *conf,
   2168                                   const unsigned char *psk, size_t psk_len,
   2169                                   const unsigned char *psk_identity, size_t psk_identity_len)
   2170          {
   2171              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2172          
   2173              /* We currently only support one PSK, raw or opaque. */
   2174              if (mbedtls_ssl_conf_has_static_psk(conf)) {
   2175                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2176              }
   2177          
   2178              /* Check and set raw PSK */
   2179              if (psk == NULL) {
   2180                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2181              }
   2182              if (psk_len == 0) {
   2183                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2184              }
   2185              if (psk_len > MBEDTLS_PSK_MAX_LEN) {
   2186                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2187              }
   2188          
   2189              if ((conf->psk = mbedtls_calloc(1, psk_len)) == NULL) {
   2190                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2191              }
   2192              conf->psk_len = psk_len;
   2193              memcpy(conf->psk, psk, conf->psk_len);
   2194          
   2195              /* Check and set PSK Identity */
   2196              ret = ssl_conf_set_psk_identity(conf, psk_identity, psk_identity_len);
   2197              if (ret != 0) {
   2198                  ssl_conf_remove_psk(conf);
   2199              }
   2200          
   2201              return ret;
   2202          }
   2203          
   2204          static void ssl_remove_psk(mbedtls_ssl_context *ssl)
   2205          {
   2206          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2207              if (!mbedtls_svc_key_id_is_null(ssl->handshake->psk_opaque)) {
   2208                  /* The maintenance of the external PSK key slot is the
   2209                   * user's responsibility. */
   2210                  if (ssl->handshake->psk_opaque_is_internal) {
   2211                      psa_destroy_key(ssl->handshake->psk_opaque);
   2212                      ssl->handshake->psk_opaque_is_internal = 0;
   2213                  }
   2214                  ssl->handshake->psk_opaque = MBEDTLS_SVC_KEY_ID_INIT;
   2215              }
   2216          #else
   2217              if (ssl->handshake->psk != NULL) {
   2218                  mbedtls_zeroize_and_free(ssl->handshake->psk,
   2219                                           ssl->handshake->psk_len);
   2220                  ssl->handshake->psk_len = 0;
   2221              }
   2222          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2223          }
   2224          
   2225          int mbedtls_ssl_set_hs_psk(mbedtls_ssl_context *ssl,
   2226                                     const unsigned char *psk, size_t psk_len)
   2227          {
   2228          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2229              psa_key_attributes_t key_attributes = psa_key_attributes_init();
   2230              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2231              psa_algorithm_t alg = PSA_ALG_NONE;
   2232              mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
   2233          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2234          
   2235              if (psk == NULL || ssl->handshake == NULL) {
   2236                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2237              }
   2238          
   2239              if (psk_len > MBEDTLS_PSK_MAX_LEN) {
   2240                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2241              }
   2242          
   2243              ssl_remove_psk(ssl);
   2244          
   2245          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2246          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2247              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
   2248                  if (ssl->handshake->ciphersuite_info->mac == MBEDTLS_MD_SHA384) {
   2249                      alg = PSA_ALG_TLS12_PSK_TO_MS(PSA_ALG_SHA_384);
   2250                  } else {
   2251                      alg = PSA_ALG_TLS12_PSK_TO_MS(PSA_ALG_SHA_256);
   2252                  }
   2253                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   2254              }
   2255          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   2256          
   2257          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   2258              if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   2259                  alg = PSA_ALG_HKDF_EXTRACT(PSA_ALG_ANY_HASH);
   2260                  psa_set_key_usage_flags(&key_attributes,
   2261                                          PSA_KEY_USAGE_DERIVE | PSA_KEY_USAGE_EXPORT);
   2262              }
   2263          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   2264          
   2265              psa_set_key_algorithm(&key_attributes, alg);
   2266              psa_set_key_type(&key_attributes, PSA_KEY_TYPE_DERIVE);
   2267          
   2268              status = psa_import_key(&key_attributes, psk, psk_len, &key);
   2269              if (status != PSA_SUCCESS) {
   2270                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   2271              }
   2272          
   2273              /* Allow calling psa_destroy_key() on psk remove */
   2274              ssl->handshake->psk_opaque_is_internal = 1;
   2275              return mbedtls_ssl_set_hs_psk_opaque(ssl, key);
   2276          #else
   2277              if ((ssl->handshake->psk = mbedtls_calloc(1, psk_len)) == NULL) {
   2278                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2279              }
   2280          
   2281              ssl->handshake->psk_len = psk_len;
   2282              memcpy(ssl->handshake->psk, psk, ssl->handshake->psk_len);
   2283          
   2284              return 0;
   2285          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2286          }
   2287          
   2288          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2289          int mbedtls_ssl_conf_psk_opaque(mbedtls_ssl_config *conf,
   2290                                          mbedtls_svc_key_id_t psk,
   2291                                          const unsigned char *psk_identity,
   2292                                          size_t psk_identity_len)
   2293          {
   2294              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2295          
   2296              /* We currently only support one PSK, raw or opaque. */
   2297              if (mbedtls_ssl_conf_has_static_psk(conf)) {
   2298                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2299              }
   2300          
   2301              /* Check and set opaque PSK */
   2302              if (mbedtls_svc_key_id_is_null(psk)) {
   2303                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2304              }
   2305              conf->psk_opaque = psk;
   2306          
   2307              /* Check and set PSK Identity */
   2308              ret = ssl_conf_set_psk_identity(conf, psk_identity,
   2309                                              psk_identity_len);
   2310              if (ret != 0) {
   2311                  ssl_conf_remove_psk(conf);
   2312              }
   2313          
   2314              return ret;
   2315          }
   2316          
   2317          int mbedtls_ssl_set_hs_psk_opaque(mbedtls_ssl_context *ssl,
   2318                                            mbedtls_svc_key_id_t psk)
   2319          {
   2320              if ((mbedtls_svc_key_id_is_null(psk)) ||
   2321                  (ssl->handshake == NULL)) {
   2322                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2323              }
   2324          
   2325              ssl_remove_psk(ssl);
   2326              ssl->handshake->psk_opaque = psk;
   2327              return 0;
   2328          }
   2329          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2330          
   2331          #if defined(MBEDTLS_SSL_SRV_C)
   2332          void mbedtls_ssl_conf_psk_cb(mbedtls_ssl_config *conf,
   2333                                       int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *,
   2334                                                    size_t),
   2335                                       void *p_psk)
   2336          {
   2337              conf->f_psk = f_psk;
   2338              conf->p_psk = p_psk;
   2339          }
   2340          #endif /* MBEDTLS_SSL_SRV_C */
   2341          
   2342          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_PSK_ENABLED */
   2343          
   2344          #if defined(MBEDTLS_USE_PSA_CRYPTO)

   \                                 In section .text, align 2, keep-with-next
   2345          static mbedtls_ssl_mode_t mbedtls_ssl_get_base_mode(
   2346              psa_algorithm_t alg)
   2347          {
   2348          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   2349              if (alg == PSA_ALG_CBC_NO_PADDING) {
   \                     mbedtls_ssl_get_base_mode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable29_2
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD101             BNE.N    ??mbedtls_ssl_get_base_mode_0
   2350                  return MBEDTLS_SSL_MODE_CBC;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   2351              }
   2352          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
   2353              if (PSA_ALG_IS_AEAD(alg)) {
   \                     ??mbedtls_ssl_get_base_mode_0: (+1)
   \        0xC   0xF000 0x40FE      AND      R0,R0,#0x7F000000
   \       0x10   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \       0x14   0xD101             BNE.N    ??mbedtls_ssl_get_base_mode_1
   2354                  return MBEDTLS_SSL_MODE_AEAD;
   \       0x16   0x2003             MOVS     R0,#+3
   \       0x18   0x4770             BX       LR
   2355              }
   2356              return MBEDTLS_SSL_MODE_STREAM;
   \                     ??mbedtls_ssl_get_base_mode_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4770             BX       LR
   2357          }
   2358          
   2359          #else /* MBEDTLS_USE_PSA_CRYPTO */
   2360          
   2361          static mbedtls_ssl_mode_t mbedtls_ssl_get_base_mode(
   2362              mbedtls_cipher_mode_t mode)
   2363          {
   2364          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   2365              if (mode == MBEDTLS_MODE_CBC) {
   2366                  return MBEDTLS_SSL_MODE_CBC;
   2367              }
   2368          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
   2369          
   2370          #if defined(MBEDTLS_GCM_C) || \
   2371              defined(MBEDTLS_CCM_C) || \
   2372              defined(MBEDTLS_CHACHAPOLY_C)
   2373              if (mode == MBEDTLS_MODE_GCM ||
   2374                  mode == MBEDTLS_MODE_CCM ||
   2375                  mode == MBEDTLS_MODE_CHACHAPOLY) {
   2376                  return MBEDTLS_SSL_MODE_AEAD;
   2377              }
   2378          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C || MBEDTLS_CHACHAPOLY_C */
   2379          
   2380              return MBEDTLS_SSL_MODE_STREAM;
   2381          }
   2382          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2383          
   2384          static mbedtls_ssl_mode_t mbedtls_ssl_get_actual_mode(
   2385              mbedtls_ssl_mode_t base_mode,
   2386              int encrypt_then_mac)
   2387          {
   2388          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   2389              if (encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&
   2390                  base_mode == MBEDTLS_SSL_MODE_CBC) {
   2391                  return MBEDTLS_SSL_MODE_CBC_ETM;
   2392              }
   2393          #else
   2394              (void) encrypt_then_mac;
   2395          #endif
   2396              return base_mode;
   2397          }
   2398          

   \                                 In section .text, align 2, keep-with-next
   2399          mbedtls_ssl_mode_t mbedtls_ssl_get_mode_from_transform(
   2400              const mbedtls_ssl_transform *transform)
   2401          {
   2402              mbedtls_ssl_mode_t base_mode = mbedtls_ssl_get_base_mode(
   2403          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2404                  transform->psa_alg
   2405          #else
   2406                  mbedtls_cipher_get_cipher_mode(&transform->cipher_ctx_enc)
   2407          #endif
   2408                  );
   2409          
   2410              int encrypt_then_mac = 0;
   2411          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   2412              encrypt_then_mac = transform->encrypt_then_mac;
   2413          #endif
   2414              return mbedtls_ssl_get_actual_mode(base_mode, encrypt_then_mac);
   \                     mbedtls_ssl_get_mode_from_transform: (+1)
   \        0x0   0x6CC0             LDR      R0,[R0, #+76]
   \        0x2   0x....             B.N      mbedtls_ssl_get_base_mode
   2415          }
   2416          

   \                                 In section .text, align 2, keep-with-next
   2417          mbedtls_ssl_mode_t mbedtls_ssl_get_mode_from_ciphersuite(
   2418          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   2419              int encrypt_then_mac,
   2420          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   2421              const mbedtls_ssl_ciphersuite_t *suite)
   2422          {
   \                     mbedtls_ssl_get_mode_from_ciphersuite: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   2423              mbedtls_ssl_mode_t base_mode = MBEDTLS_SSL_MODE_STREAM;
   2424          
   2425          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2426              psa_status_t status;
   2427              psa_algorithm_t alg;
   2428              psa_key_type_t type;
   2429              size_t size;
   2430              status = mbedtls_ssl_cipher_to_psa((mbedtls_cipher_type_t) suite->cipher, 0, &alg, &type, &size);
   2431              if (status == PSA_SUCCESS) {
   \        0x4   0xAD03             ADD      R5,SP,#+12
   \        0x6   0x9500             STR      R5,[SP, #+0]
   \        0x8   0x7A00             LDRB     R0,[R0, #+8]
   \        0xA   0xAB01             ADD      R3,SP,#+4
   \        0xC   0xAA02             ADD      R2,SP,#+8
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x2400             MOVS     R4,#+0
   \       0x12   0x.... 0x....      BL       mbedtls_ssl_cipher_to_psa
   \       0x16   0xB918             CBNZ.N   R0,??mbedtls_ssl_get_mode_from_ciphersuite_0
   2432                  base_mode = mbedtls_ssl_get_base_mode(alg);
   \       0x18   0x9802             LDR      R0,[SP, #+8]
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_get_base_mode
   \       0x1E   0x4604             MOV      R4,R0
   2433              }
   2434          #else
   2435              const mbedtls_cipher_info_t *cipher =
   2436                  mbedtls_cipher_info_from_type((mbedtls_cipher_type_t) suite->cipher);
   2437              if (cipher != NULL) {
   2438                  base_mode =
   2439                      mbedtls_ssl_get_base_mode(
   2440                          mbedtls_cipher_info_get_mode(cipher));
   2441              }
   2442          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2443          
   2444          #if !defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   2445              int encrypt_then_mac = 0;
   2446          #endif
   2447              return mbedtls_ssl_get_actual_mode(base_mode, encrypt_then_mac);
   \                     ??mbedtls_ssl_get_mode_from_ciphersuite_0: (+1)
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xB005             ADD      SP,SP,#+20
   \       0x24   0xBD30             POP      {R4,R5,PC}
   2448          }
   2449          
   2450          #if defined(MBEDTLS_USE_PSA_CRYPTO) || defined(MBEDTLS_SSL_PROTO_TLS1_3)
   2451          
   2452          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   2453          /* Serialization of TLS 1.3 sessions:
   2454           *
   2455           *     struct {
   2456           *       opaque hostname<0..2^16-1>;
   2457           *       uint64 ticket_received;
   2458           *       uint32 ticket_lifetime;
   2459           *       opaque ticket<1..2^16-1>;
   2460           *     } ClientOnlyData;
   2461           *
   2462           *     struct {
   2463           *       uint8 endpoint;
   2464           *       uint8 ciphersuite[2];
   2465           *       uint32 ticket_age_add;
   2466           *       uint8 ticket_flags;
   2467           *       opaque resumption_key<0..255>;
   2468           *       select ( endpoint ) {
   2469           *            case client: ClientOnlyData;
   2470           *            case server: uint64 start_time;
   2471           *        };
   2472           *     } serialized_session_tls13;
   2473           *
   2474           */
   2475          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2476          MBEDTLS_CHECK_RETURN_CRITICAL
   2477          static int ssl_tls13_session_save(const mbedtls_ssl_session *session,
   2478                                            unsigned char *buf,
   2479                                            size_t buf_len,
   2480                                            size_t *olen)
   2481          {
   2482              unsigned char *p = buf;
   2483          #if defined(MBEDTLS_SSL_CLI_C) && \
   2484              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2485              size_t hostname_len = (session->hostname == NULL) ?
   2486                                    0 : strlen(session->hostname) + 1;
   2487          #endif
   2488              size_t needed =   1                             /* endpoint */
   2489                              + 2                             /* ciphersuite */
   2490                              + 4                             /* ticket_age_add */
   2491                              + 1                             /* ticket_flags */
   2492                              + 1;                            /* resumption_key length */
   2493              *olen = 0;
   2494          
   2495              if (session->resumption_key_len > MBEDTLS_SSL_TLS1_3_TICKET_RESUMPTION_KEY_LEN) {
   2496                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2497              }
   2498              needed += session->resumption_key_len;  /* resumption_key */
   2499          
   2500          #if defined(MBEDTLS_HAVE_TIME)
   2501              needed += 8; /* start_time or ticket_received */
   2502          #endif
   2503          
   2504          #if defined(MBEDTLS_SSL_CLI_C)
   2505              if (session->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   2506          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2507                  needed +=  2                        /* hostname_len */
   2508                            + hostname_len;           /* hostname */
   2509          #endif
   2510          
   2511                  needed +=   4                       /* ticket_lifetime */
   2512                            + 2;                      /* ticket_len */
   2513          
   2514                  /* Check size_t overflow */
   2515                  if (session->ticket_len > SIZE_MAX - needed) {
   2516                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2517                  }
   2518          
   2519                  needed += session->ticket_len;      /* ticket */
   2520              }
   2521          #endif /* MBEDTLS_SSL_CLI_C */
   2522          
   2523              *olen = needed;
   2524              if (needed > buf_len) {
   2525                  return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   2526              }
   2527          
   2528              p[0] = session->endpoint;
   2529              MBEDTLS_PUT_UINT16_BE(session->ciphersuite, p, 1);
   2530              MBEDTLS_PUT_UINT32_BE(session->ticket_age_add, p, 3);
   2531              p[7] = session->ticket_flags;
   2532          
   2533              /* save resumption_key */
   2534              p[8] = session->resumption_key_len;
   2535              p += 9;
   2536              memcpy(p, session->resumption_key, session->resumption_key_len);
   2537              p += session->resumption_key_len;
   2538          
   2539          #if defined(MBEDTLS_HAVE_TIME) && defined(MBEDTLS_SSL_SRV_C)
   2540              if (session->endpoint == MBEDTLS_SSL_IS_SERVER) {
   2541                  MBEDTLS_PUT_UINT64_BE((uint64_t) session->start, p, 0);
   2542                  p += 8;
   2543              }
   2544          #endif /* MBEDTLS_HAVE_TIME */
   2545          
   2546          #if defined(MBEDTLS_SSL_CLI_C)
   2547              if (session->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   2548          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2549                  MBEDTLS_PUT_UINT16_BE(hostname_len, p, 0);
   2550                  p += 2;
   2551                  if (hostname_len > 0) {
   2552                      /* save host name */
   2553                      memcpy(p, session->hostname, hostname_len);
   2554                      p += hostname_len;
   2555                  }
   2556          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   2557          
   2558          #if defined(MBEDTLS_HAVE_TIME)
   2559                  MBEDTLS_PUT_UINT64_BE((uint64_t) session->ticket_received, p, 0);
   2560                  p += 8;
   2561          #endif
   2562                  MBEDTLS_PUT_UINT32_BE(session->ticket_lifetime, p, 0);
   2563                  p += 4;
   2564          
   2565                  MBEDTLS_PUT_UINT16_BE(session->ticket_len, p, 0);
   2566                  p += 2;
   2567          
   2568                  if (session->ticket != NULL && session->ticket_len > 0) {
   2569                      memcpy(p, session->ticket, session->ticket_len);
   2570                      p += session->ticket_len;
   2571                  }
   2572              }
   2573          #endif /* MBEDTLS_SSL_CLI_C */
   2574              return 0;
   2575          }
   2576          
   2577          MBEDTLS_CHECK_RETURN_CRITICAL
   2578          static int ssl_tls13_session_load(mbedtls_ssl_session *session,
   2579                                            const unsigned char *buf,
   2580                                            size_t len)
   2581          {
   2582              const unsigned char *p = buf;
   2583              const unsigned char *end = buf + len;
   2584          
   2585              if (end - p < 9) {
   2586                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2587              }
   2588              session->endpoint = p[0];
   2589              session->ciphersuite = MBEDTLS_GET_UINT16_BE(p, 1);
   2590              session->ticket_age_add = MBEDTLS_GET_UINT32_BE(p, 3);
   2591              session->ticket_flags = p[7];
   2592          
   2593              /* load resumption_key */
   2594              session->resumption_key_len = p[8];
   2595              p += 9;
   2596          
   2597              if (end - p < session->resumption_key_len) {
   2598                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2599              }
   2600          
   2601              if (sizeof(session->resumption_key) < session->resumption_key_len) {
   2602                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2603              }
   2604              memcpy(session->resumption_key, p, session->resumption_key_len);
   2605              p += session->resumption_key_len;
   2606          
   2607          #if defined(MBEDTLS_HAVE_TIME) && defined(MBEDTLS_SSL_SRV_C)
   2608              if (session->endpoint == MBEDTLS_SSL_IS_SERVER) {
   2609                  if (end - p < 8) {
   2610                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2611                  }
   2612                  session->start = MBEDTLS_GET_UINT64_BE(p, 0);
   2613                  p += 8;
   2614              }
   2615          #endif /* MBEDTLS_HAVE_TIME */
   2616          
   2617          #if defined(MBEDTLS_SSL_CLI_C)
   2618              if (session->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   2619          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION) && \
   2620                  defined(MBEDTLS_SSL_SESSION_TICKETS)
   2621                  size_t hostname_len;
   2622                  /* load host name */
   2623                  if (end - p < 2) {
   2624                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2625                  }
   2626                  hostname_len = MBEDTLS_GET_UINT16_BE(p, 0);
   2627                  p += 2;
   2628          
   2629                  if (end - p < (long int) hostname_len) {
   2630                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2631                  }
   2632                  if (hostname_len > 0) {
   2633                      session->hostname = mbedtls_calloc(1, hostname_len);
   2634                      if (session->hostname == NULL) {
   2635                          return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2636                      }
   2637                      memcpy(session->hostname, p, hostname_len);
   2638                      p += hostname_len;
   2639                  }
   2640          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION &&
   2641                    MBEDTLS_SSL_SESSION_TICKETS */
   2642          
   2643          #if defined(MBEDTLS_HAVE_TIME)
   2644                  if (end - p < 8) {
   2645                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2646                  }
   2647                  session->ticket_received = MBEDTLS_GET_UINT64_BE(p, 0);
   2648                  p += 8;
   2649          #endif
   2650                  if (end - p < 4) {
   2651                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2652                  }
   2653                  session->ticket_lifetime = MBEDTLS_GET_UINT32_BE(p, 0);
   2654                  p += 4;
   2655          
   2656                  if (end - p <  2) {
   2657                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2658                  }
   2659                  session->ticket_len = MBEDTLS_GET_UINT16_BE(p, 0);
   2660                  p += 2;
   2661          
   2662                  if (end - p < (long int) session->ticket_len) {
   2663                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   2664                  }
   2665                  if (session->ticket_len > 0) {
   2666                      session->ticket = mbedtls_calloc(1, session->ticket_len);
   2667                      if (session->ticket == NULL) {
   2668                          return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   2669                      }
   2670                      memcpy(session->ticket, p, session->ticket_len);
   2671                      p += session->ticket_len;
   2672                  }
   2673              }
   2674          #endif /* MBEDTLS_SSL_CLI_C */
   2675          
   2676              return 0;
   2677          
   2678          }
   2679          #else /* MBEDTLS_SSL_SESSION_TICKETS */
   2680          MBEDTLS_CHECK_RETURN_CRITICAL
   2681          static int ssl_tls13_session_save(const mbedtls_ssl_session *session,
   2682                                            unsigned char *buf,
   2683                                            size_t buf_len,
   2684                                            size_t *olen)
   2685          {
   2686              ((void) session);
   2687              ((void) buf);
   2688              ((void) buf_len);
   2689              *olen = 0;
   2690              return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2691          }
   2692          
   2693          static int ssl_tls13_session_load(const mbedtls_ssl_session *session,
   2694                                            unsigned char *buf,
   2695                                            size_t buf_len)
   2696          {
   2697              ((void) session);
   2698              ((void) buf);
   2699              ((void) buf_len);
   2700              return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2701          }
   2702          #endif /* !MBEDTLS_SSL_SESSION_TICKETS */
   2703          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   2704          

   \                                 In section .text, align 2, keep-with-next
   2705          psa_status_t mbedtls_ssl_cipher_to_psa(mbedtls_cipher_type_t mbedtls_cipher_type,
   2706                                                 size_t taglen,
   2707                                                 psa_algorithm_t *alg,
   2708                                                 psa_key_type_t *key_type,
   2709                                                 size_t *key_size)
   2710          {
   \                     mbedtls_ssl_cipher_to_psa: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   2711              switch (mbedtls_cipher_type) {
   \        0x4   0x040C             LSLS     R4,R1,#+16
   \        0x6   0xF404 0x147C      AND      R4,R4,#0x3F0000
   \        0xA   0xF044 0x64A8      ORR      R4,R4,#0x5400000
   \        0xE   0xF444 0x7480      ORR      R4,R4,#0x100
   \       0x12   0xF44F 0x5510      MOV      R5,#+9216
   \       0x16   0xF242 0x4906      MOVW     R9,#+9222
   \       0x1A   0x.... 0x....      LDR.W    R6,??DataTable29_2
   \       0x1E   0x.... 0x....      LDR.W    R8,??DataTable29_3
   \       0x22   0xF242 0x4C03      MOVW     R12,#+9219
   \       0x26   0x.... 0x....      LDR.W    LR,??DataTable29_4
   \       0x2A   0xF44F 0x7780      MOV      R7,#+256
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xF000 0x8085      BEQ.W    ??mbedtls_ssl_cipher_to_psa_0
   \       0x34   0x2805             CMP      R0,#+5
   \       0x36   0xD030             BEQ.N    ??mbedtls_ssl_cipher_to_psa_1
   \       0x38   0x2807             CMP      R0,#+7
   \       0x3A   0xD043             BEQ.N    ??mbedtls_ssl_cipher_to_psa_2
   \       0x3C   0x280E             CMP      R0,#+14
   \       0x3E   0xD039             BEQ.N    ??mbedtls_ssl_cipher_to_psa_3
   \       0x40   0x280F             CMP      R0,#+15
   \       0x42   0xD03D             BEQ.N    ??mbedtls_ssl_cipher_to_psa_4
   \       0x44   0x2810             CMP      R0,#+16
   \       0x46   0xD043             BEQ.N    ??mbedtls_ssl_cipher_to_psa_5
   \       0x48   0x2814             CMP      R0,#+20
   \       0x4A   0xD05B             BEQ.N    ??mbedtls_ssl_cipher_to_psa_6
   \       0x4C   0x2816             CMP      R0,#+22
   \       0x4E   0xD068             BEQ.N    ??mbedtls_ssl_cipher_to_psa_7
   \       0x50   0x281D             CMP      R0,#+29
   \       0x52   0xD05E             BEQ.N    ??mbedtls_ssl_cipher_to_psa_8
   \       0x54   0x281E             CMP      R0,#+30
   \       0x56   0xD062             BEQ.N    ??mbedtls_ssl_cipher_to_psa_9
   \       0x58   0x281F             CMP      R0,#+31
   \       0x5A   0xD069             BEQ.N    ??mbedtls_ssl_cipher_to_psa_10
   \       0x5C   0x2826             CMP      R0,#+38
   \       0x5E   0xD025             BEQ.N    ??mbedtls_ssl_cipher_to_psa_11
   \       0x60   0x2827             CMP      R0,#+39
   \       0x62   0xD029             BEQ.N    ??mbedtls_ssl_cipher_to_psa_12
   \       0x64   0x2828             CMP      R0,#+40
   \       0x66   0xD02F             BEQ.N    ??mbedtls_ssl_cipher_to_psa_13
   \       0x68   0x282C             CMP      R0,#+44
   \       0x6A   0xD04E             BEQ.N    ??mbedtls_ssl_cipher_to_psa_14
   \       0x6C   0x282D             CMP      R0,#+45
   \       0x6E   0xD052             BEQ.N    ??mbedtls_ssl_cipher_to_psa_15
   \       0x70   0x282E             CMP      R0,#+46
   \       0x72   0xD059             BEQ.N    ??mbedtls_ssl_cipher_to_psa_16
   \       0x74   0x2835             CMP      R0,#+53
   \       0x76   0xD02D             BEQ.N    ??mbedtls_ssl_cipher_to_psa_17
   \       0x78   0x2837             CMP      R0,#+55
   \       0x7A   0xD03A             BEQ.N    ??mbedtls_ssl_cipher_to_psa_18
   \       0x7C   0x283E             CMP      R0,#+62
   \       0x7E   0xD030             BEQ.N    ??mbedtls_ssl_cipher_to_psa_19
   \       0x80   0x283F             CMP      R0,#+63
   \       0x82   0xD034             BEQ.N    ??mbedtls_ssl_cipher_to_psa_20
   \       0x84   0x2840             CMP      R0,#+64
   \       0x86   0xD03B             BEQ.N    ??mbedtls_ssl_cipher_to_psa_21
   \       0x88   0x2841             CMP      R0,#+65
   \       0x8A   0xD026             BEQ.N    ??mbedtls_ssl_cipher_to_psa_22
   \       0x8C   0x2842             CMP      R0,#+66
   \       0x8E   0xD02A             BEQ.N    ??mbedtls_ssl_cipher_to_psa_23
   \       0x90   0x2843             CMP      R0,#+67
   \       0x92   0xD031             BEQ.N    ??mbedtls_ssl_cipher_to_psa_24
   \       0x94   0x284D             CMP      R0,#+77
   \       0x96   0xD04D             BEQ.N    ??mbedtls_ssl_cipher_to_psa_25
   \       0x98   0xE056             B.N      ??mbedtls_ssl_cipher_to_psa_26
   2712                  case MBEDTLS_CIPHER_AES_128_CBC:
   2713                      *alg = PSA_ALG_CBC_NO_PADDING;
   \                     ??mbedtls_ssl_cipher_to_psa_1: (+1)
   \       0x9A   0x4634             MOV      R4,R6
   2714                      *key_type = PSA_KEY_TYPE_AES;
   2715                      *key_size = 128;
   \                     ??mbedtls_ssl_cipher_to_psa_27: (+1)
   \       0x9C   0x2780             MOVS     R7,#+128
   2716                      break;
   \                     ??mbedtls_ssl_cipher_to_psa_28: (+1)
   \       0x9E   0x9807             LDR      R0,[SP, #+28]
   2717                  case MBEDTLS_CIPHER_AES_128_CCM:
   2718                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2719                      *key_type = PSA_KEY_TYPE_AES;
   2720                      *key_size = 128;
   2721                      break;
   2722                  case MBEDTLS_CIPHER_AES_128_GCM:
   2723                      *alg = PSA_ALG_GCM;
   2724                      *key_type = PSA_KEY_TYPE_AES;
   2725                      *key_size = 128;
   2726                      break;
   2727                  case MBEDTLS_CIPHER_AES_192_CCM:
   2728                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2729                      *key_type = PSA_KEY_TYPE_AES;
   2730                      *key_size = 192;
   2731                      break;
   2732                  case MBEDTLS_CIPHER_AES_192_GCM:
   2733                      *alg = PSA_ALG_GCM;
   2734                      *key_type = PSA_KEY_TYPE_AES;
   2735                      *key_size = 192;
   2736                      break;
   2737                  case MBEDTLS_CIPHER_AES_256_CBC:
   2738                      *alg = PSA_ALG_CBC_NO_PADDING;
   2739                      *key_type = PSA_KEY_TYPE_AES;
   2740                      *key_size = 256;
   2741                      break;
   2742                  case MBEDTLS_CIPHER_AES_256_CCM:
   2743                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2744                      *key_type = PSA_KEY_TYPE_AES;
   2745                      *key_size = 256;
   2746                      break;
   2747                  case MBEDTLS_CIPHER_AES_256_GCM:
   2748                      *alg = PSA_ALG_GCM;
   2749                      *key_type = PSA_KEY_TYPE_AES;
   2750                      *key_size = 256;
   2751                      break;
   2752                  case MBEDTLS_CIPHER_ARIA_128_CBC:
   2753                      *alg = PSA_ALG_CBC_NO_PADDING;
   2754                      *key_type = PSA_KEY_TYPE_ARIA;
   2755                      *key_size = 128;
   2756                      break;
   2757                  case MBEDTLS_CIPHER_ARIA_128_CCM:
   2758                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2759                      *key_type = PSA_KEY_TYPE_ARIA;
   2760                      *key_size = 128;
   2761                      break;
   2762                  case MBEDTLS_CIPHER_ARIA_128_GCM:
   2763                      *alg = PSA_ALG_GCM;
   2764                      *key_type = PSA_KEY_TYPE_ARIA;
   2765                      *key_size = 128;
   2766                      break;
   2767                  case MBEDTLS_CIPHER_ARIA_192_CCM:
   2768                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2769                      *key_type = PSA_KEY_TYPE_ARIA;
   2770                      *key_size = 192;
   2771                      break;
   2772                  case MBEDTLS_CIPHER_ARIA_192_GCM:
   2773                      *alg = PSA_ALG_GCM;
   2774                      *key_type = PSA_KEY_TYPE_ARIA;
   2775                      *key_size = 192;
   2776                      break;
   2777                  case MBEDTLS_CIPHER_ARIA_256_CBC:
   2778                      *alg = PSA_ALG_CBC_NO_PADDING;
   2779                      *key_type = PSA_KEY_TYPE_ARIA;
   2780                      *key_size = 256;
   2781                      break;
   2782                  case MBEDTLS_CIPHER_ARIA_256_CCM:
   2783                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2784                      *key_type = PSA_KEY_TYPE_ARIA;
   2785                      *key_size = 256;
   2786                      break;
   2787                  case MBEDTLS_CIPHER_ARIA_256_GCM:
   2788                      *alg = PSA_ALG_GCM;
   2789                      *key_type = PSA_KEY_TYPE_ARIA;
   2790                      *key_size = 256;
   2791                      break;
   2792                  case MBEDTLS_CIPHER_CAMELLIA_128_CBC:
   2793                      *alg = PSA_ALG_CBC_NO_PADDING;
   2794                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2795                      *key_size = 128;
   2796                      break;
   2797                  case MBEDTLS_CIPHER_CAMELLIA_128_CCM:
   2798                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2799                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2800                      *key_size = 128;
   2801                      break;
   2802                  case MBEDTLS_CIPHER_CAMELLIA_128_GCM:
   2803                      *alg = PSA_ALG_GCM;
   2804                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2805                      *key_size = 128;
   2806                      break;
   2807                  case MBEDTLS_CIPHER_CAMELLIA_192_CCM:
   2808                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2809                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2810                      *key_size = 192;
   2811                      break;
   2812                  case MBEDTLS_CIPHER_CAMELLIA_192_GCM:
   2813                      *alg = PSA_ALG_GCM;
   2814                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2815                      *key_size = 192;
   2816                      break;
   2817                  case MBEDTLS_CIPHER_CAMELLIA_256_CBC:
   2818                      *alg = PSA_ALG_CBC_NO_PADDING;
   2819                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2820                      *key_size = 256;
   2821                      break;
   2822                  case MBEDTLS_CIPHER_CAMELLIA_256_CCM:
   2823                      *alg = taglen ? PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, taglen) : PSA_ALG_CCM;
   2824                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2825                      *key_size = 256;
   2826                      break;
   2827                  case MBEDTLS_CIPHER_CAMELLIA_256_GCM:
   2828                      *alg = PSA_ALG_GCM;
   2829                      *key_type = PSA_KEY_TYPE_CAMELLIA;
   2830                      *key_size = 256;
   2831                      break;
   2832                  case MBEDTLS_CIPHER_CHACHA20_POLY1305:
   2833                      *alg = PSA_ALG_CHACHA20_POLY1305;
   2834                      *key_type = PSA_KEY_TYPE_CHACHA20;
   2835                      *key_size = 256;
   2836                      break;
   2837                  case MBEDTLS_CIPHER_NULL:
   2838                      *alg = MBEDTLS_SSL_NULL_CIPHER;
   2839                      *key_type = 0;
   2840                      *key_size = 0;
   2841                      break;
   2842                  default:
   2843                      return PSA_ERROR_NOT_SUPPORTED;
   2844              }
   2845          
   2846              return PSA_SUCCESS;
   \       0xA0   0x6014             STR      R4,[R2, #+0]
   \       0xA2   0x6007             STR      R7,[R0, #+0]
   \       0xA4   0x801D             STRH     R5,[R3, #+0]
   \       0xA6   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_cipher_to_psa_29: (+1)
   \       0xA8   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??mbedtls_ssl_cipher_to_psa_11: (+1)
   \       0xAC   0x2900             CMP      R1,#+0
   \       0xAE   0xD1F5             BNE.N    ??mbedtls_ssl_cipher_to_psa_27
   \       0xB0   0x4644             MOV      R4,R8
   \       0xB2   0xE7F3             B.N      ??mbedtls_ssl_cipher_to_psa_27
   \                     ??mbedtls_ssl_cipher_to_psa_3: (+1)
   \       0xB4   0x4674             MOV      R4,LR
   \       0xB6   0xE7F1             B.N      ??mbedtls_ssl_cipher_to_psa_27
   \                     ??mbedtls_ssl_cipher_to_psa_12: (+1)
   \       0xB8   0xB901             CBNZ.N   R1,??mbedtls_ssl_cipher_to_psa_30
   \       0xBA   0x4644             MOV      R4,R8
   \                     ??mbedtls_ssl_cipher_to_psa_30: (+1)
   \       0xBC   0x27C0             MOVS     R7,#+192
   \       0xBE   0xE7EE             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_4: (+1)
   \       0xC0   0x4674             MOV      R4,LR
   \       0xC2   0xE7FB             B.N      ??mbedtls_ssl_cipher_to_psa_30
   \                     ??mbedtls_ssl_cipher_to_psa_2: (+1)
   \       0xC4   0x4634             MOV      R4,R6
   \       0xC6   0xE7EA             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_13: (+1)
   \       0xC8   0x2900             CMP      R1,#+0
   \       0xCA   0xD1E8             BNE.N    ??mbedtls_ssl_cipher_to_psa_28
   \       0xCC   0x4644             MOV      R4,R8
   \       0xCE   0xE7E6             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_5: (+1)
   \       0xD0   0x4674             MOV      R4,LR
   \       0xD2   0xE7E4             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_17: (+1)
   \       0xD4   0x4634             MOV      R4,R6
   \                     ??mbedtls_ssl_cipher_to_psa_31: (+1)
   \       0xD6   0x464D             MOV      R5,R9
   \       0xD8   0xE7E0             B.N      ??mbedtls_ssl_cipher_to_psa_27
   \                     ??mbedtls_ssl_cipher_to_psa_22: (+1)
   \       0xDA   0x2900             CMP      R1,#+0
   \       0xDC   0xD1FB             BNE.N    ??mbedtls_ssl_cipher_to_psa_31
   \       0xDE   0x4644             MOV      R4,R8
   \       0xE0   0xE7F9             B.N      ??mbedtls_ssl_cipher_to_psa_31
   \                     ??mbedtls_ssl_cipher_to_psa_19: (+1)
   \       0xE2   0x4674             MOV      R4,LR
   \       0xE4   0xE7F7             B.N      ??mbedtls_ssl_cipher_to_psa_31
   \                     ??mbedtls_ssl_cipher_to_psa_23: (+1)
   \       0xE6   0xB901             CBNZ.N   R1,??mbedtls_ssl_cipher_to_psa_32
   \       0xE8   0x4644             MOV      R4,R8
   \                     ??mbedtls_ssl_cipher_to_psa_32: (+1)
   \       0xEA   0x464D             MOV      R5,R9
   \       0xEC   0xE7E6             B.N      ??mbedtls_ssl_cipher_to_psa_30
   \                     ??mbedtls_ssl_cipher_to_psa_20: (+1)
   \       0xEE   0x4674             MOV      R4,LR
   \       0xF0   0xE7FB             B.N      ??mbedtls_ssl_cipher_to_psa_32
   \                     ??mbedtls_ssl_cipher_to_psa_18: (+1)
   \       0xF2   0x4634             MOV      R4,R6
   \                     ??mbedtls_ssl_cipher_to_psa_33: (+1)
   \       0xF4   0x464D             MOV      R5,R9
   \       0xF6   0xE7D2             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_24: (+1)
   \       0xF8   0x2900             CMP      R1,#+0
   \       0xFA   0xD1FB             BNE.N    ??mbedtls_ssl_cipher_to_psa_33
   \       0xFC   0x4644             MOV      R4,R8
   \       0xFE   0xE7F9             B.N      ??mbedtls_ssl_cipher_to_psa_33
   \                     ??mbedtls_ssl_cipher_to_psa_21: (+1)
   \      0x100   0x4674             MOV      R4,LR
   \      0x102   0xE7F7             B.N      ??mbedtls_ssl_cipher_to_psa_33
   \                     ??mbedtls_ssl_cipher_to_psa_6: (+1)
   \      0x104   0x4634             MOV      R4,R6
   \                     ??mbedtls_ssl_cipher_to_psa_34: (+1)
   \      0x106   0x4665             MOV      R5,R12
   \      0x108   0xE7C8             B.N      ??mbedtls_ssl_cipher_to_psa_27
   \                     ??mbedtls_ssl_cipher_to_psa_14: (+1)
   \      0x10A   0x2900             CMP      R1,#+0
   \      0x10C   0xD1FB             BNE.N    ??mbedtls_ssl_cipher_to_psa_34
   \      0x10E   0x4644             MOV      R4,R8
   \      0x110   0xE7F9             B.N      ??mbedtls_ssl_cipher_to_psa_34
   \                     ??mbedtls_ssl_cipher_to_psa_8: (+1)
   \      0x112   0x4674             MOV      R4,LR
   \      0x114   0xE7F7             B.N      ??mbedtls_ssl_cipher_to_psa_34
   \                     ??mbedtls_ssl_cipher_to_psa_15: (+1)
   \      0x116   0xB901             CBNZ.N   R1,??mbedtls_ssl_cipher_to_psa_35
   \      0x118   0x4644             MOV      R4,R8
   \                     ??mbedtls_ssl_cipher_to_psa_35: (+1)
   \      0x11A   0x4665             MOV      R5,R12
   \      0x11C   0xE7CE             B.N      ??mbedtls_ssl_cipher_to_psa_30
   \                     ??mbedtls_ssl_cipher_to_psa_9: (+1)
   \      0x11E   0x4674             MOV      R4,LR
   \      0x120   0xE7FB             B.N      ??mbedtls_ssl_cipher_to_psa_35
   \                     ??mbedtls_ssl_cipher_to_psa_7: (+1)
   \      0x122   0x4634             MOV      R4,R6
   \                     ??mbedtls_ssl_cipher_to_psa_36: (+1)
   \      0x124   0x4665             MOV      R5,R12
   \      0x126   0xE7BA             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_16: (+1)
   \      0x128   0x2900             CMP      R1,#+0
   \      0x12A   0xD1FB             BNE.N    ??mbedtls_ssl_cipher_to_psa_36
   \      0x12C   0x4644             MOV      R4,R8
   \      0x12E   0xE7F9             B.N      ??mbedtls_ssl_cipher_to_psa_36
   \                     ??mbedtls_ssl_cipher_to_psa_10: (+1)
   \      0x130   0x4674             MOV      R4,LR
   \      0x132   0xE7F7             B.N      ??mbedtls_ssl_cipher_to_psa_36
   \                     ??mbedtls_ssl_cipher_to_psa_25: (+1)
   \      0x134   0x.... 0x....      LDR.W    R4,??DataTable31
   \      0x138   0xF242 0x0504      MOVW     R5,#+8196
   \      0x13C   0xE7AF             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_0: (+1)
   \      0x13E   0xF04F 0x6480      MOV      R4,#+67108864
   \      0x142   0x2500             MOVS     R5,#+0
   \      0x144   0x2700             MOVS     R7,#+0
   \      0x146   0xE7AA             B.N      ??mbedtls_ssl_cipher_to_psa_28
   \                     ??mbedtls_ssl_cipher_to_psa_26: (+1)
   \      0x148   0xF06F 0x0085      MVN      R0,#+133
   \      0x14C   0xE7AC             B.N      ??mbedtls_ssl_cipher_to_psa_29
   2847          }
   2848          #endif /* MBEDTLS_USE_PSA_CRYPTO || MBEDTLS_SSL_PROTO_TLS1_3 */
   2849          
   2850          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
   2851          int mbedtls_ssl_conf_dh_param_bin(mbedtls_ssl_config *conf,
   2852                                            const unsigned char *dhm_P, size_t P_len,
   2853                                            const unsigned char *dhm_G, size_t G_len)
   2854          {
   2855              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2856          
   2857              mbedtls_mpi_free(&conf->dhm_P);
   2858              mbedtls_mpi_free(&conf->dhm_G);
   2859          
   2860              if ((ret = mbedtls_mpi_read_binary(&conf->dhm_P, dhm_P, P_len)) != 0 ||
   2861                  (ret = mbedtls_mpi_read_binary(&conf->dhm_G, dhm_G, G_len)) != 0) {
   2862                  mbedtls_mpi_free(&conf->dhm_P);
   2863                  mbedtls_mpi_free(&conf->dhm_G);
   2864                  return ret;
   2865              }
   2866          
   2867              return 0;
   2868          }
   2869          
   2870          int mbedtls_ssl_conf_dh_param_ctx(mbedtls_ssl_config *conf, mbedtls_dhm_context *dhm_ctx)
   2871          {
   2872              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2873          
   2874              mbedtls_mpi_free(&conf->dhm_P);
   2875              mbedtls_mpi_free(&conf->dhm_G);
   2876          
   2877              if ((ret = mbedtls_dhm_get_value(dhm_ctx, MBEDTLS_DHM_PARAM_P,
   2878                                               &conf->dhm_P)) != 0 ||
   2879                  (ret = mbedtls_dhm_get_value(dhm_ctx, MBEDTLS_DHM_PARAM_G,
   2880                                               &conf->dhm_G)) != 0) {
   2881                  mbedtls_mpi_free(&conf->dhm_P);
   2882                  mbedtls_mpi_free(&conf->dhm_G);
   2883                  return ret;
   2884              }
   2885          
   2886              return 0;
   2887          }
   2888          #endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_SRV_C */
   2889          
   2890          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)
   2891          /*
   2892           * Set the minimum length for Diffie-Hellman parameters
   2893           */
   2894          void mbedtls_ssl_conf_dhm_min_bitlen(mbedtls_ssl_config *conf,
   2895                                               unsigned int bitlen)
   2896          {
   2897              conf->dhm_min_bitlen = bitlen;
   2898          }
   2899          #endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_CLI_C */
   2900          
   2901          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   2902          #if !defined(MBEDTLS_DEPRECATED_REMOVED) && defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2903          /*
   2904           * Set allowed/preferred hashes for handshake signatures
   2905           */

   \                                 In section .text, align 2, keep-with-next
   2906          void mbedtls_ssl_conf_sig_hashes(mbedtls_ssl_config *conf,
   2907                                           const int *hashes)
   2908          {
   2909              conf->sig_hashes = hashes;
   \                     mbedtls_ssl_conf_sig_hashes: (+1)
   \        0x0   0x6441             STR      R1,[R0, #+68]
   2910          }
   \        0x2   0x4770             BX       LR
   2911          #endif /* !MBEDTLS_DEPRECATED_REMOVED && MBEDTLS_SSL_PROTO_TLS1_2 */
   2912          
   2913          /* Configure allowed signature algorithms for handshake */

   \                                 In section .text, align 2, keep-with-next
   2914          void mbedtls_ssl_conf_sig_algs(mbedtls_ssl_config *conf,
   2915                                         const uint16_t *sig_algs)
   2916          {
   2917          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   2918              conf->sig_hashes = NULL;
   \                     mbedtls_ssl_conf_sig_algs: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x6442             STR      R2,[R0, #+68]
   2919          #endif /* !MBEDTLS_DEPRECATED_REMOVED */
   2920              conf->sig_algs = sig_algs;
   \        0x4   0x6481             STR      R1,[R0, #+72]
   2921          }
   \        0x6   0x4770             BX       LR
   2922          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   2923          
   2924          #if defined(MBEDTLS_ECP_C)
   2925          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   2926          /*
   2927           * Set the allowed elliptic curves
   2928           *
   2929           * mbedtls_ssl_setup() takes the provided list
   2930           * and translates it to a list of IANA TLS group identifiers,
   2931           * stored in ssl->handshake->group_list.
   2932           *
   2933           */

   \                                 In section .text, align 2, keep-with-next
   2934          void mbedtls_ssl_conf_curves(mbedtls_ssl_config *conf,
   2935                                       const mbedtls_ecp_group_id *curve_list)
   2936          {
   2937              conf->curve_list = curve_list;
   \                     mbedtls_ssl_conf_curves: (+1)
   \        0x0   0x64C1             STR      R1,[R0, #+76]
   2938              conf->group_list = NULL;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6501             STR      R1,[R0, #+80]
   2939          }
   \        0x6   0x4770             BX       LR
   2940          #endif /* MBEDTLS_DEPRECATED_REMOVED */
   2941          #endif /* MBEDTLS_ECP_C */
   2942          
   2943          /*
   2944           * Set the allowed groups
   2945           */

   \                                 In section .text, align 2, keep-with-next
   2946          void mbedtls_ssl_conf_groups(mbedtls_ssl_config *conf,
   2947                                       const uint16_t *group_list)
   2948          {
   2949          #if defined(MBEDTLS_ECP_C) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   2950              conf->curve_list = NULL;
   \                     mbedtls_ssl_conf_groups: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x64C2             STR      R2,[R0, #+76]
   2951          #endif
   2952              conf->group_list = group_list;
   \        0x4   0x6501             STR      R1,[R0, #+80]
   2953          }
   \        0x6   0x4770             BX       LR
   2954          
   2955          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
   2956          int mbedtls_ssl_set_hostname(mbedtls_ssl_context *ssl, const char *hostname)
   2957          {
   \                     mbedtls_ssl_set_hostname: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460C             MOV      R4,R1
   2958              /* Initialize to suppress unnecessary compiler warning */
   2959              size_t hostname_len = 0;
   \        0x6   0x2600             MOVS     R6,#+0
   2960          
   2961              /* Check if new hostname is valid before
   2962               * making any change to current one */
   2963              if (hostname != NULL) {
   \        0x8   0xB14C             CBZ.N    R4,??mbedtls_ssl_set_hostname_0
   2964                  hostname_len = strlen(hostname);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x.... 0x....      BL       strlen
   \       0x10   0x4606             MOV      R6,R0
   2965          
   2966                  if (hostname_len > MBEDTLS_SSL_MAX_HOST_NAME_LEN) {
   \       0x12   0xF5B6 0x7F80      CMP      R6,#+256
   \       0x16   0xD302             BCC.N    ??mbedtls_ssl_set_hostname_0
   2967                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
   2968                  }
   2969              }
   2970          
   2971              /* Now it's clear that we will overwrite the old hostname,
   2972               * so we can free it safely */
   2973          
   2974              if (ssl->hostname != NULL) {
   \                     ??mbedtls_ssl_set_hostname_0: (+1)
   \       0x1E   0xF8D7 0x50C0      LDR      R5,[R7, #+192]
   \       0x22   0xB135             CBZ.N    R5,??mbedtls_ssl_set_hostname_1
   2975                  mbedtls_zeroize_and_free(ssl->hostname, strlen(ssl->hostname));
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       strlen
   \       0x2A   0x4601             MOV      R1,R0
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x.... 0x....      BL       mbedtls_zeroize_and_free
   2976              }
   2977          
   2978              /* Passing NULL as hostname shall clear the old one */
   2979          
   2980              if (hostname == NULL) {
   \                     ??mbedtls_ssl_set_hostname_1: (+1)
   \       0x32   0xB91C             CBNZ.N   R4,??mbedtls_ssl_set_hostname_2
   2981                  ssl->hostname = NULL;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF8C7 0x00C0      STR      R0,[R7, #+192]
   \       0x3A   0xBDF2             POP      {R1,R4-R7,PC}
   2982              } else {
   2983                  ssl->hostname = mbedtls_calloc(1, hostname_len + 1);
   \                     ??mbedtls_ssl_set_hostname_2: (+1)
   \       0x3C   0x1C71             ADDS     R1,R6,#+1
   \       0x3E   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x42   0xF8C7 0x00C0      STR      R0,[R7, #+192]
   2984                  if (ssl->hostname == NULL) {
   \       0x46   0xB910             CBNZ.N   R0,??mbedtls_ssl_set_hostname_3
   2985                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \       0x4C   0xBDF2             POP      {R1,R4-R7,PC}
   2986                  }
   2987          
   2988                  memcpy(ssl->hostname, hostname, hostname_len);
   \                     ??mbedtls_ssl_set_hostname_3: (+1)
   \       0x4E   0x4632             MOV      R2,R6
   \       0x50   0x4621             MOV      R1,R4
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
   2989          
   2990                  ssl->hostname[hostname_len] = '\0';
   \       0x56   0xF8D7 0x10C0      LDR      R1,[R7, #+192]
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x5588             STRB     R0,[R1, R6]
   2991              }
   2992          
   2993              return 0;
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}
   2994          }
   2995          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   2996          
   2997          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2998          void mbedtls_ssl_conf_sni(mbedtls_ssl_config *conf,
   2999                                    int (*f_sni)(void *, mbedtls_ssl_context *,
   3000                                                 const unsigned char *, size_t),
   3001                                    void *p_sni)
   3002          {
   3003              conf->f_sni = f_sni;
   3004              conf->p_sni = p_sni;
   3005          }
   3006          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   3007          
   3008          #if defined(MBEDTLS_SSL_ALPN)
   3009          int mbedtls_ssl_conf_alpn_protocols(mbedtls_ssl_config *conf, const char **protos)
   3010          {
   3011              size_t cur_len, tot_len;
   3012              const char **p;
   3013          
   3014              /*
   3015               * RFC 7301 3.1: "Empty strings MUST NOT be included and byte strings
   3016               * MUST NOT be truncated."
   3017               * We check lengths now rather than later.
   3018               */
   3019              tot_len = 0;
   3020              for (p = protos; *p != NULL; p++) {
   3021                  cur_len = strlen(*p);
   3022                  tot_len += cur_len;
   3023          
   3024                  if ((cur_len == 0) ||
   3025                      (cur_len > MBEDTLS_SSL_MAX_ALPN_NAME_LEN) ||
   3026                      (tot_len > MBEDTLS_SSL_MAX_ALPN_LIST_LEN)) {
   3027                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3028                  }
   3029              }
   3030          
   3031              conf->alpn_list = protos;
   3032          
   3033              return 0;
   3034          }
   3035          
   3036          const char *mbedtls_ssl_get_alpn_protocol(const mbedtls_ssl_context *ssl)
   3037          {
   3038              return ssl->alpn_chosen;
   3039          }
   3040          #endif /* MBEDTLS_SSL_ALPN */
   3041          
   3042          #if defined(MBEDTLS_SSL_DTLS_SRTP)
   3043          void mbedtls_ssl_conf_srtp_mki_value_supported(mbedtls_ssl_config *conf,
   3044                                                         int support_mki_value)
   3045          {
   3046              conf->dtls_srtp_mki_support = support_mki_value;
   3047          }
   3048          
   3049          int mbedtls_ssl_dtls_srtp_set_mki_value(mbedtls_ssl_context *ssl,
   3050                                                  unsigned char *mki_value,
   3051                                                  uint16_t mki_len)
   3052          {
   3053              if (mki_len > MBEDTLS_TLS_SRTP_MAX_MKI_LENGTH) {
   3054                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3055              }
   3056          
   3057              if (ssl->conf->dtls_srtp_mki_support == MBEDTLS_SSL_DTLS_SRTP_MKI_UNSUPPORTED) {
   3058                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3059              }
   3060          
   3061              memcpy(ssl->dtls_srtp_info.mki_value, mki_value, mki_len);
   3062              ssl->dtls_srtp_info.mki_len = mki_len;
   3063              return 0;
   3064          }
   3065          
   3066          int mbedtls_ssl_conf_dtls_srtp_protection_profiles(mbedtls_ssl_config *conf,
   3067                                                             const mbedtls_ssl_srtp_profile *profiles)
   3068          {
   3069              const mbedtls_ssl_srtp_profile *p;
   3070              size_t list_size = 0;
   3071          
   3072              /* check the profiles list: all entry must be valid,
   3073               * its size cannot be more than the total number of supported profiles, currently 4 */
   3074              for (p = profiles; *p != MBEDTLS_TLS_SRTP_UNSET &&
   3075                   list_size <= MBEDTLS_TLS_SRTP_MAX_PROFILE_LIST_LENGTH;
   3076                   p++) {
   3077                  if (mbedtls_ssl_check_srtp_profile_value(*p) != MBEDTLS_TLS_SRTP_UNSET) {
   3078                      list_size++;
   3079                  } else {
   3080                      /* unsupported value, stop parsing and set the size to an error value */
   3081                      list_size = MBEDTLS_TLS_SRTP_MAX_PROFILE_LIST_LENGTH + 1;
   3082                  }
   3083              }
   3084          
   3085              if (list_size > MBEDTLS_TLS_SRTP_MAX_PROFILE_LIST_LENGTH) {
   3086                  conf->dtls_srtp_profile_list = NULL;
   3087                  conf->dtls_srtp_profile_list_len = 0;
   3088                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3089              }
   3090          
   3091              conf->dtls_srtp_profile_list = profiles;
   3092              conf->dtls_srtp_profile_list_len = list_size;
   3093          
   3094              return 0;
   3095          }
   3096          
   3097          void mbedtls_ssl_get_dtls_srtp_negotiation_result(const mbedtls_ssl_context *ssl,
   3098                                                            mbedtls_dtls_srtp_info *dtls_srtp_info)
   3099          {
   3100              dtls_srtp_info->chosen_dtls_srtp_profile = ssl->dtls_srtp_info.chosen_dtls_srtp_profile;
   3101              /* do not copy the mki value if there is no chosen profile */
   3102              if (dtls_srtp_info->chosen_dtls_srtp_profile == MBEDTLS_TLS_SRTP_UNSET) {
   3103                  dtls_srtp_info->mki_len = 0;
   3104              } else {
   3105                  dtls_srtp_info->mki_len = ssl->dtls_srtp_info.mki_len;
   3106                  memcpy(dtls_srtp_info->mki_value, ssl->dtls_srtp_info.mki_value,
   3107                         ssl->dtls_srtp_info.mki_len);
   3108              }
   3109          }
   3110          #endif /* MBEDTLS_SSL_DTLS_SRTP */
   3111          
   3112          #if !defined(MBEDTLS_DEPRECATED_REMOVED)

   \                                 In section .text, align 2, keep-with-next
   3113          void mbedtls_ssl_conf_max_version(mbedtls_ssl_config *conf, int major, int minor)
   3114          {
   3115              conf->max_tls_version = (mbedtls_ssl_protocol_version) ((major << 8) | minor);
   \                     mbedtls_ssl_conf_max_version: (+1)
   \        0x0   0xEA42 0x2201      ORR      R2,R2,R1, LSL #+8
   \        0x4   0x8002             STRH     R2,[R0, #+0]
   3116          }
   \        0x6   0x4770             BX       LR
   3117          

   \                                 In section .text, align 2, keep-with-next
   3118          void mbedtls_ssl_conf_min_version(mbedtls_ssl_config *conf, int major, int minor)
   3119          {
   3120              conf->min_tls_version = (mbedtls_ssl_protocol_version) ((major << 8) | minor);
   \                     mbedtls_ssl_conf_min_version: (+1)
   \        0x0   0xEA42 0x2201      ORR      R2,R2,R1, LSL #+8
   \        0x4   0x8042             STRH     R2,[R0, #+2]
   3121          }
   \        0x6   0x4770             BX       LR
   3122          #endif /* MBEDTLS_DEPRECATED_REMOVED */
   3123          
   3124          #if defined(MBEDTLS_SSL_SRV_C)
   3125          void mbedtls_ssl_conf_cert_req_ca_list(mbedtls_ssl_config *conf,
   3126                                                 char cert_req_ca_list)
   3127          {
   3128              conf->cert_req_ca_list = cert_req_ca_list;
   3129          }
   3130          #endif
   3131          
   3132          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   3133          void mbedtls_ssl_conf_encrypt_then_mac(mbedtls_ssl_config *conf, char etm)
   3134          {
   3135              conf->encrypt_then_mac = etm;
   3136          }
   3137          #endif
   3138          
   3139          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   3140          void mbedtls_ssl_conf_extended_master_secret(mbedtls_ssl_config *conf, char ems)
   3141          {
   3142              conf->extended_ms = ems;
   3143          }
   3144          #endif
   3145          
   3146          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)

   \                                 In section .text, align 2, keep-with-next
   3147          int mbedtls_ssl_conf_max_frag_len(mbedtls_ssl_config *conf, unsigned char mfl_code)
   3148          {
   3149              if (mfl_code >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID ||
   3150                  ssl_mfl_code_to_length(mfl_code) > MBEDTLS_TLS_EXT_ADV_CONTENT_LEN) {
   \                     mbedtls_ssl_conf_max_frag_len: (+1)
   \        0x0   0x2905             CMP      R1,#+5
   \        0x2   0xDA02             BGE.N    ??mbedtls_ssl_conf_max_frag_len_0
   \        0x4   0x1E8B             SUBS     R3,R1,#+2
   \        0x6   0x2B02             CMP      R3,#+2
   \        0x8   0xD802             BHI.N    ??mbedtls_ssl_conf_max_frag_len_1
   3151                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_conf_max_frag_len_0: (+1)
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \        0xE   0x4770             BX       LR
   3152              }
   3153          
   3154              conf->mfl_code = mfl_code;
   \                     ??mbedtls_ssl_conf_max_frag_len_1: (+1)
   \       0x10   0x7201             STRB     R1,[R0, #+8]
   3155          
   3156              return 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR
   3157          }
   3158          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   3159          

   \                                 In section .text, align 2, keep-with-next
   3160          void mbedtls_ssl_conf_legacy_renegotiation(mbedtls_ssl_config *conf, int allow_legacy)
   3161          {
   3162              conf->allow_legacy_renegotiation = allow_legacy;
   \                     mbedtls_ssl_conf_legacy_renegotiation: (+1)
   \        0x0   0x71C1             STRB     R1,[R0, #+7]
   3163          }
   \        0x2   0x4770             BX       LR
   3164          
   3165          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   3166          void mbedtls_ssl_conf_renegotiation(mbedtls_ssl_config *conf, int renegotiation)
   3167          {
   3168              conf->disable_renegotiation = renegotiation;
   3169          }
   3170          
   3171          void mbedtls_ssl_conf_renegotiation_enforced(mbedtls_ssl_config *conf, int max_records)
   3172          {
   3173              conf->renego_max_records = max_records;
   3174          }
   3175          
   3176          void mbedtls_ssl_conf_renegotiation_period(mbedtls_ssl_config *conf,
   3177                                                     const unsigned char period[8])
   3178          {
   3179              memcpy(conf->renego_period, period, 8);
   3180          }
   3181          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   3182          
   3183          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3184          #if defined(MBEDTLS_SSL_CLI_C)
   3185          void mbedtls_ssl_conf_session_tickets(mbedtls_ssl_config *conf, int use_tickets)
   3186          {
   3187              conf->session_tickets = use_tickets;
   3188          }
   3189          #endif
   3190          
   3191          #if defined(MBEDTLS_SSL_SRV_C)
   3192          
   3193          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && defined(MBEDTLS_SSL_SESSION_TICKETS)
   3194          void mbedtls_ssl_conf_new_session_tickets(mbedtls_ssl_config *conf,
   3195                                                    uint16_t num_tickets)
   3196          {
   3197              conf->new_session_tickets_count = num_tickets;
   3198          }
   3199          #endif
   3200          
   3201          void mbedtls_ssl_conf_session_tickets_cb(mbedtls_ssl_config *conf,
   3202                                                   mbedtls_ssl_ticket_write_t *f_ticket_write,
   3203                                                   mbedtls_ssl_ticket_parse_t *f_ticket_parse,
   3204                                                   void *p_ticket)
   3205          {
   3206              conf->f_ticket_write = f_ticket_write;
   3207              conf->f_ticket_parse = f_ticket_parse;
   3208              conf->p_ticket       = p_ticket;
   3209          }
   3210          #endif
   3211          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   3212          

   \                                 In section .text, align 2, keep-with-next
   3213          void mbedtls_ssl_set_export_keys_cb(mbedtls_ssl_context *ssl,
   3214                                              mbedtls_ssl_export_keys_t *f_export_keys,
   3215                                              void *p_export_keys)
   3216          {
   3217              ssl->f_export_keys = f_export_keys;
   \                     mbedtls_ssl_set_export_keys_cb: (+1)
   \        0x0   0xF840 0x1FC8      STR      R1,[R0, #+200]!
   3218              ssl->p_export_keys = p_export_keys;
   \        0x4   0x6042             STR      R2,[R0, #+4]
   3219          }
   \        0x6   0x4770             BX       LR
   3220          
   3221          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   3222          void mbedtls_ssl_conf_async_private_cb(
   3223              mbedtls_ssl_config *conf,
   3224              mbedtls_ssl_async_sign_t *f_async_sign,
   3225              mbedtls_ssl_async_decrypt_t *f_async_decrypt,
   3226              mbedtls_ssl_async_resume_t *f_async_resume,
   3227              mbedtls_ssl_async_cancel_t *f_async_cancel,
   3228              void *async_config_data)
   3229          {
   3230              conf->f_async_sign_start = f_async_sign;
   3231              conf->f_async_decrypt_start = f_async_decrypt;
   3232              conf->f_async_resume = f_async_resume;
   3233              conf->f_async_cancel = f_async_cancel;
   3234              conf->p_async_config_data = async_config_data;
   3235          }
   3236          
   3237          void *mbedtls_ssl_conf_get_async_config_data(const mbedtls_ssl_config *conf)
   3238          {
   3239              return conf->p_async_config_data;
   3240          }
   3241          
   3242          void *mbedtls_ssl_get_async_operation_data(const mbedtls_ssl_context *ssl)
   3243          {
   3244              if (ssl->handshake == NULL) {
   3245                  return NULL;
   3246              } else {
   3247                  return ssl->handshake->user_async_ctx;
   3248              }
   3249          }
   3250          
   3251          void mbedtls_ssl_set_async_operation_data(mbedtls_ssl_context *ssl,
   3252                                                    void *ctx)
   3253          {
   3254              if (ssl->handshake != NULL) {
   3255                  ssl->handshake->user_async_ctx = ctx;
   3256              }
   3257          }
   3258          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   3259          
   3260          /*
   3261           * SSL get accessors
   3262           */

   \                                 In section .text, align 2, keep-with-next
   3263          uint32_t mbedtls_ssl_get_verify_result(const mbedtls_ssl_context *ssl)
   3264          {
   3265              if (ssl->session != NULL) {
   \                     mbedtls_ssl_get_verify_result: (+1)
   \        0x0   0x6B01             LDR      R1,[R0, #+48]
   \        0x2   0xB109             CBZ.N    R1,??mbedtls_ssl_get_verify_result_0
   3266                  return ssl->session->verify_result;
   \        0x4   0x6E08             LDR      R0,[R1, #+96]
   \        0x6   0x4770             BX       LR
   3267              }
   3268          
   3269              if (ssl->session_negotiate != NULL) {
   \                     ??mbedtls_ssl_get_verify_result_0: (+1)
   \        0x8   0x6B40             LDR      R0,[R0, #+52]
   \        0xA   0xB108             CBZ.N    R0,??mbedtls_ssl_get_verify_result_1
   3270                  return ssl->session_negotiate->verify_result;
   \        0xC   0x6E00             LDR      R0,[R0, #+96]
   \        0xE   0x4770             BX       LR
   3271              }
   3272          
   3273              return 0xFFFFFFFF;
   \                     ??mbedtls_ssl_get_verify_result_1: (+1)
   \       0x10   0x.... 0x....      B.W      ?Subroutine1
   3274          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#+4294967295
   \        0x4   0x4770             BX       LR
   3275          

   \                                 In section .text, align 2, keep-with-next
   3276          int mbedtls_ssl_get_ciphersuite_id_from_ssl(const mbedtls_ssl_context *ssl)
   3277          {
   3278              if (ssl == NULL || ssl->session == NULL) {
   \                     mbedtls_ssl_get_ciphersuite_id_from_ssl: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x6B00             LDRNE    R0,[R0, #+48]
   \        0x6   0x2800             CMPNE    R0,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_ssl_get_ciphersuite_id_from_ssl_0
   3279                  return 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
   3280              }
   3281          
   3282              return ssl->session->ciphersuite;
   \                     ??mbedtls_ssl_get_ciphersuite_id_from_ssl_0: (+1)
   \        0xE   0x6840             LDR      R0,[R0, #+4]
   \       0x10   0x4770             BX       LR
   3283          }
   3284          

   \                                 In section .text, align 2, keep-with-next
   3285          const char *mbedtls_ssl_get_ciphersuite(const mbedtls_ssl_context *ssl)
   3286          {
   3287              if (ssl == NULL || ssl->session == NULL) {
   \                     mbedtls_ssl_get_ciphersuite: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1F             ITTTT    NE
   \        0x4   0x6B00             LDRNE    R0,[R0, #+48]
   \        0x6   0x2800             CMPNE    R0,#+0
   3288                  return NULL;
   3289              }
   3290          
   3291              return mbedtls_ssl_get_ciphersuite_name(ssl->session->ciphersuite);
   \        0x8   0x6840             LDRNE    R0,[R0, #+4]
   \        0xA   0x.... 0x....      BNE.W    mbedtls_ssl_get_ciphersuite_name
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
   3292          }
   3293          

   \                                 In section .text, align 4, keep-with-next
   3294          const char *mbedtls_ssl_get_version(const mbedtls_ssl_context *ssl)
   3295          {
   3296          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3297              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   3298                  switch (ssl->tls_version) {
   3299                      case MBEDTLS_SSL_VERSION_TLS1_2:
   3300                          return "DTLSv1.2";
   3301                      default:
   3302                          return "unknown (DTLS)";
   3303                  }
   3304              }
   3305          #endif
   3306          
   3307              switch (ssl->tls_version) {
   \                     mbedtls_ssl_get_version: (+1)
   \        0x0   0xF9B0 0x1008      LDRSH    R1,[R0, #+8]
   \        0x4   0xF240 0x3003      MOVW     R0,#+771
   \        0x8   0x1A09             SUBS     R1,R1,R0
   \        0xA   0xD002             BEQ.N    ??mbedtls_ssl_get_version_0
   \        0xC   0x1E49             SUBS     R1,R1,#+1
   \        0xE   0xD003             BEQ.N    ??mbedtls_ssl_get_version_1
   \       0x10   0xE004             B.N      ??mbedtls_ssl_get_version_2
   3308                  case MBEDTLS_SSL_VERSION_TLS1_2:
   3309                      return "TLSv1.2";
   \                     ??mbedtls_ssl_get_version_0: (+1)
   \       0x12   0xBF00             Nop
   \       0x14   0x....             ADR.N    R0,?_5
   \       0x16   0x4770             BX       LR
   3310                  case MBEDTLS_SSL_VERSION_TLS1_3:
   3311                      return "TLSv1.3";
   \                     ??mbedtls_ssl_get_version_1: (+1)
   \       0x18   0x....             ADR.N    R0,?_6
   \       0x1A   0x4770             BX       LR
   3312                  default:
   3313                      return "unknown";
   \                     ??mbedtls_ssl_get_version_2: (+1)
   \       0x1C   0x....             ADR.N    R0,?_7
   \       0x1E   0x4770             BX       LR
   3314              }
   3315          }
   3316          
   3317          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)

   \                                 In section .text, align 4, keep-with-next
   3318          size_t mbedtls_ssl_get_input_max_frag_len(const mbedtls_ssl_context *ssl)
   3319          {
   \                     mbedtls_ssl_get_input_max_frag_len: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   3320              size_t max_len = MBEDTLS_SSL_IN_CONTENT_LEN;
   3321              size_t read_mfl;
   3322          
   3323          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3324              /* Use the configured MFL for the client if we're past SERVER_HELLO_DONE */
   3325              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
   3326                  ssl->state >= MBEDTLS_SSL_SERVER_HELLO_DONE) {
   \        0x2   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \        0x6   0xF44F 0x7140      MOV      R1,#+768
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0xF89C 0x3004      LDRB     R3,[R12, #+4]
   \       0x10   0xF44F 0x7400      MOV      R4,#+512
   \       0x14   0xF44F 0x6580      MOV      R5,#+1024
   \       0x18   0xF44F 0x6600      MOV      R6,#+2048
   \       0x1C   0xF44F 0x5780      MOV      R7,#+4096
   \       0x20   0xB9A3             CBNZ.N   R3,??mbedtls_ssl_get_input_max_frag_len_2
   \       0x22   0x6843             LDR      R3,[R0, #+4]
   \       0x24   0x2B06             CMP      R3,#+6
   \       0x26   0xDB11             BLT.N    ??mbedtls_ssl_get_input_max_frag_len_2
   3327                  return ssl_mfl_code_to_length(ssl->conf->mfl_code);
   \       0x28   0xF89C 0x0008      LDRB     R0,[R12, #+8]
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0x2803             CMP      R0,#+3
   \       0x30   0xD80A             BHI.N    ??mbedtls_ssl_get_input_max_frag_len_3
   \       0x32   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mbedtls_ssl_get_input_max_frag_len_0:
   \       0x36   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_input_max_frag_len_4: (+1)
   \       0x3A   0x4639             MOV      R1,R7
   \       0x3C   0xE004             B.N      ??mbedtls_ssl_get_input_max_frag_len_3
   \                     ??mbedtls_ssl_get_input_max_frag_len_5: (+1)
   \       0x3E   0x4631             MOV      R1,R6
   \       0x40   0xE002             B.N      ??mbedtls_ssl_get_input_max_frag_len_3
   \                     ??mbedtls_ssl_get_input_max_frag_len_6: (+1)
   \       0x42   0x4629             MOV      R1,R5
   \       0x44   0xE000             B.N      ??mbedtls_ssl_get_input_max_frag_len_3
   \                     ??mbedtls_ssl_get_input_max_frag_len_7: (+1)
   \       0x46   0x4621             MOV      R1,R4
   3328              }
   \                     ??mbedtls_ssl_get_input_max_frag_len_3: (+1)
   \       0x48   0x4608             MOV      R0,R1
   \       0x4A   0xBDF0             POP      {R4-R7,PC}
   3329          #endif
   3330          
   3331              /* Check if a smaller max length was negotiated */
   3332              if (ssl->session_out != NULL) {
   \                     ??mbedtls_ssl_get_input_max_frag_len_2: (+1)
   \       0x4C   0x6AC3             LDR      R3,[R0, #+44]
   \       0x4E   0xB11B             CBZ.N    R3,??mbedtls_ssl_get_input_max_frag_len_8
   3333                  read_mfl = ssl_mfl_code_to_length(ssl->session_out->mfl_code);
   \       0x50   0x781B             LDRB     R3,[R3, #+0]
   \       0x52   0x2B01             CMP      R3,#+1
   \       0x54   0xBF08             IT       EQ
   \       0x56   0x4622             MOVEQ    R2,R4
   3334                  if (read_mfl < max_len) {
   3335                      max_len = read_mfl;
   3336                  }
   3337              }
   3338          
   3339              /* During a handshake, use the value being negotiated */
   3340              if (ssl->session_negotiate != NULL) {
   \                     ??mbedtls_ssl_get_input_max_frag_len_8: (+1)
   \       0x58   0x6B40             LDR      R0,[R0, #+52]
   \       0x5A   0xB190             CBZ.N    R0,??mbedtls_ssl_get_input_max_frag_len_9
   3341                  read_mfl = ssl_mfl_code_to_length(ssl->session_negotiate->mfl_code);
   \       0x5C   0x7800             LDRB     R0,[R0, #+0]
   \       0x5E   0x1E40             SUBS     R0,R0,#+1
   \       0x60   0x2803             CMP      R0,#+3
   \       0x62   0xD80A             BHI.N    ??mbedtls_ssl_get_input_max_frag_len_10
   \       0x64   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mbedtls_ssl_get_input_max_frag_len_1:
   \       0x68   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_input_max_frag_len_11: (+1)
   \       0x6C   0x4639             MOV      R1,R7
   \       0x6E   0xE004             B.N      ??mbedtls_ssl_get_input_max_frag_len_10
   \                     ??mbedtls_ssl_get_input_max_frag_len_12: (+1)
   \       0x70   0x4631             MOV      R1,R6
   \       0x72   0xE002             B.N      ??mbedtls_ssl_get_input_max_frag_len_10
   \                     ??mbedtls_ssl_get_input_max_frag_len_13: (+1)
   \       0x74   0x4629             MOV      R1,R5
   \       0x76   0xE000             B.N      ??mbedtls_ssl_get_input_max_frag_len_10
   \                     ??mbedtls_ssl_get_input_max_frag_len_14: (+1)
   \       0x78   0x4621             MOV      R1,R4
   3342                  if (read_mfl < max_len) {
   \                     ??mbedtls_ssl_get_input_max_frag_len_10: (+1)
   \       0x7A   0x4291             CMP      R1,R2
   \       0x7C   0xBF88             IT       HI
   \       0x7E   0x4611             MOVHI    R1,R2
   \       0x80   0x460A             MOV      R2,R1
   3343                      max_len = read_mfl;
   3344                  }
   3345              }
   3346          
   3347              return max_len;
   \                     ??mbedtls_ssl_get_input_max_frag_len_9: (+1)
   \       0x82   0x4610             MOV      R0,R2
   \       0x84   0xBDF0             POP      {R4-R7,PC}
   3348          }
   3349          

   \                                 In section .text, align 4, keep-with-next
   3350          size_t mbedtls_ssl_get_output_max_frag_len(const mbedtls_ssl_context *ssl)
   3351          {
   \                     mbedtls_ssl_get_output_max_frag_len: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   3352              size_t max_len;
   3353          
   3354              /*
   3355               * Assume mfl_code is correct since it was checked when set
   3356               */
   3357              max_len = ssl_mfl_code_to_length(ssl->conf->mfl_code);
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xF44F 0x7740      MOV      R7,#+768
   \        0x8   0xF44F 0x7300      MOV      R3,#+512
   \        0xC   0x7A11             LDRB     R1,[R2, #+8]
   \        0xE   0xF44F 0x6480      MOV      R4,#+1024
   \       0x12   0xF44F 0x6500      MOV      R5,#+2048
   \       0x16   0x1E49             SUBS     R1,R1,#+1
   \       0x18   0xF44F 0x5680      MOV      R6,#+4096
   \       0x1C   0x2903             CMP      R1,#+3
   \       0x1E   0xD80B             BHI.N    ??mbedtls_ssl_get_output_max_frag_len_5
   \       0x20   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??mbedtls_ssl_get_output_max_frag_len_0:
   \       0x24   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_output_max_frag_len_6: (+1)
   \       0x28   0x4631             MOV      R1,R6
   \       0x2A   0xE006             B.N      ??mbedtls_ssl_get_output_max_frag_len_7
   \                     ??mbedtls_ssl_get_output_max_frag_len_8: (+1)
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0xE004             B.N      ??mbedtls_ssl_get_output_max_frag_len_7
   \                     ??mbedtls_ssl_get_output_max_frag_len_9: (+1)
   \       0x30   0x4621             MOV      R1,R4
   \       0x32   0xE002             B.N      ??mbedtls_ssl_get_output_max_frag_len_7
   \                     ??mbedtls_ssl_get_output_max_frag_len_10: (+1)
   \       0x34   0x4619             MOV      R1,R3
   \       0x36   0xE000             B.N      ??mbedtls_ssl_get_output_max_frag_len_7
   \                     ??mbedtls_ssl_get_output_max_frag_len_5: (+1)
   \       0x38   0x4639             MOV      R1,R7
   3358          
   3359              /* Check if a smaller max length was negotiated */
   3360              if (ssl->session_out != NULL &&
   3361                  ssl_mfl_code_to_length(ssl->session_out->mfl_code) < max_len) {
   \                     ??mbedtls_ssl_get_output_max_frag_len_7: (+1)
   \       0x3A   0x6AC2             LDR      R2,[R0, #+44]
   \       0x3C   0xB322             CBZ.N    R2,??mbedtls_ssl_get_output_max_frag_len_11
   \       0x3E   0x7812             LDRB     R2,[R2, #+0]
   \       0x40   0xF1A2 0x0E01      SUB      LR,R2,#+1
   \       0x44   0xF1BE 0x0F03      CMP      LR,#+3
   \       0x48   0xD80B             BHI.N    ??mbedtls_ssl_get_output_max_frag_len_12
   \       0x4A   0xE8DF 0xF00E      TBB      [PC, LR]
   \                     ??mbedtls_ssl_get_output_max_frag_len_1:
   \       0x4E   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_output_max_frag_len_13: (+1)
   \       0x52   0x46B4             MOV      R12,R6
   \       0x54   0xE006             B.N      ??mbedtls_ssl_get_output_max_frag_len_14
   \                     ??mbedtls_ssl_get_output_max_frag_len_15: (+1)
   \       0x56   0x46AC             MOV      R12,R5
   \       0x58   0xE004             B.N      ??mbedtls_ssl_get_output_max_frag_len_14
   \                     ??mbedtls_ssl_get_output_max_frag_len_16: (+1)
   \       0x5A   0x46A4             MOV      R12,R4
   \       0x5C   0xE002             B.N      ??mbedtls_ssl_get_output_max_frag_len_14
   \                     ??mbedtls_ssl_get_output_max_frag_len_17: (+1)
   \       0x5E   0x469C             MOV      R12,R3
   \       0x60   0xE000             B.N      ??mbedtls_ssl_get_output_max_frag_len_14
   \                     ??mbedtls_ssl_get_output_max_frag_len_12: (+1)
   \       0x62   0x46BC             MOV      R12,R7
   \                     ??mbedtls_ssl_get_output_max_frag_len_14: (+1)
   \       0x64   0x458C             CMP      R12,R1
   \       0x66   0xD20F             BCS.N    ??mbedtls_ssl_get_output_max_frag_len_11
   3362                  max_len = ssl_mfl_code_to_length(ssl->session_out->mfl_code);
   \       0x68   0x1E52             SUBS     R2,R2,#+1
   \       0x6A   0x2A03             CMP      R2,#+3
   \       0x6C   0xD80B             BHI.N    ??mbedtls_ssl_get_output_max_frag_len_18
   \       0x6E   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??mbedtls_ssl_get_output_max_frag_len_2:
   \       0x72   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_output_max_frag_len_19: (+1)
   \       0x76   0x4631             MOV      R1,R6
   \       0x78   0xE006             B.N      ??mbedtls_ssl_get_output_max_frag_len_11
   \                     ??mbedtls_ssl_get_output_max_frag_len_20: (+1)
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0xE004             B.N      ??mbedtls_ssl_get_output_max_frag_len_11
   \                     ??mbedtls_ssl_get_output_max_frag_len_21: (+1)
   \       0x7E   0x4621             MOV      R1,R4
   \       0x80   0xE002             B.N      ??mbedtls_ssl_get_output_max_frag_len_11
   \                     ??mbedtls_ssl_get_output_max_frag_len_22: (+1)
   \       0x82   0x4619             MOV      R1,R3
   \       0x84   0xE000             B.N      ??mbedtls_ssl_get_output_max_frag_len_11
   \                     ??mbedtls_ssl_get_output_max_frag_len_18: (+1)
   \       0x86   0x4639             MOV      R1,R7
   3363              }
   3364          
   3365              /* During a handshake, use the value being negotiated */
   3366              if (ssl->session_negotiate != NULL &&
   3367                  ssl_mfl_code_to_length(ssl->session_negotiate->mfl_code) < max_len) {
   \                     ??mbedtls_ssl_get_output_max_frag_len_11: (+1)
   \       0x88   0x6B40             LDR      R0,[R0, #+52]
   \       0x8A   0xB310             CBZ.N    R0,??mbedtls_ssl_get_output_max_frag_len_23
   \       0x8C   0x7800             LDRB     R0,[R0, #+0]
   \       0x8E   0x1E42             SUBS     R2,R0,#+1
   \       0x90   0x2A03             CMP      R2,#+3
   \       0x92   0xD80B             BHI.N    ??mbedtls_ssl_get_output_max_frag_len_24
   \       0x94   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??mbedtls_ssl_get_output_max_frag_len_3:
   \       0x98   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_output_max_frag_len_25: (+1)
   \       0x9C   0x4632             MOV      R2,R6
   \       0x9E   0xE006             B.N      ??mbedtls_ssl_get_output_max_frag_len_26
   \                     ??mbedtls_ssl_get_output_max_frag_len_27: (+1)
   \       0xA0   0x462A             MOV      R2,R5
   \       0xA2   0xE004             B.N      ??mbedtls_ssl_get_output_max_frag_len_26
   \                     ??mbedtls_ssl_get_output_max_frag_len_28: (+1)
   \       0xA4   0x4622             MOV      R2,R4
   \       0xA6   0xE002             B.N      ??mbedtls_ssl_get_output_max_frag_len_26
   \                     ??mbedtls_ssl_get_output_max_frag_len_29: (+1)
   \       0xA8   0x461A             MOV      R2,R3
   \       0xAA   0xE000             B.N      ??mbedtls_ssl_get_output_max_frag_len_26
   \                     ??mbedtls_ssl_get_output_max_frag_len_24: (+1)
   \       0xAC   0x463A             MOV      R2,R7
   \                     ??mbedtls_ssl_get_output_max_frag_len_26: (+1)
   \       0xAE   0x428A             CMP      R2,R1
   \       0xB0   0xD20F             BCS.N    ??mbedtls_ssl_get_output_max_frag_len_23
   3368                  max_len = ssl_mfl_code_to_length(ssl->session_negotiate->mfl_code);
   \       0xB2   0x1E40             SUBS     R0,R0,#+1
   \       0xB4   0x2803             CMP      R0,#+3
   \       0xB6   0xD80B             BHI.N    ??mbedtls_ssl_get_output_max_frag_len_30
   \       0xB8   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mbedtls_ssl_get_output_max_frag_len_4:
   \       0xBC   0x08 0x06          DC8      0x8,0x6,0x4,0x2
   \              0x04 0x02
   \                     ??mbedtls_ssl_get_output_max_frag_len_31: (+1)
   \       0xC0   0x4631             MOV      R1,R6
   \       0xC2   0xE006             B.N      ??mbedtls_ssl_get_output_max_frag_len_23
   \                     ??mbedtls_ssl_get_output_max_frag_len_32: (+1)
   \       0xC4   0x4629             MOV      R1,R5
   \       0xC6   0xE004             B.N      ??mbedtls_ssl_get_output_max_frag_len_23
   \                     ??mbedtls_ssl_get_output_max_frag_len_33: (+1)
   \       0xC8   0x4621             MOV      R1,R4
   \       0xCA   0xE002             B.N      ??mbedtls_ssl_get_output_max_frag_len_23
   \                     ??mbedtls_ssl_get_output_max_frag_len_34: (+1)
   \       0xCC   0x4619             MOV      R1,R3
   \       0xCE   0xE000             B.N      ??mbedtls_ssl_get_output_max_frag_len_23
   \                     ??mbedtls_ssl_get_output_max_frag_len_30: (+1)
   \       0xD0   0x4639             MOV      R1,R7
   3369              }
   3370          
   3371              return max_len;
   \                     ??mbedtls_ssl_get_output_max_frag_len_23: (+1)
   \       0xD2   0x4608             MOV      R0,R1
   \       0xD4   0xBDF0             POP      {R4-R7,PC}
   3372          }
   3373          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   3374          
   3375          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3376          size_t mbedtls_ssl_get_current_mtu(const mbedtls_ssl_context *ssl)
   3377          {
   3378              /* Return unlimited mtu for client hello messages to avoid fragmentation. */
   3379              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
   3380                  (ssl->state == MBEDTLS_SSL_CLIENT_HELLO ||
   3381                   ssl->state == MBEDTLS_SSL_SERVER_HELLO)) {
   3382                  return 0;
   3383              }
   3384          
   3385              if (ssl->handshake == NULL || ssl->handshake->mtu == 0) {
   3386                  return ssl->mtu;
   3387              }
   3388          
   3389              if (ssl->mtu == 0) {
   3390                  return ssl->handshake->mtu;
   3391              }
   3392          
   3393              return ssl->mtu < ssl->handshake->mtu ?
   3394                     ssl->mtu : ssl->handshake->mtu;
   3395          }
   3396          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3397          

   \                                 In section .text, align 2, keep-with-next
   3398          int mbedtls_ssl_get_max_out_record_payload(const mbedtls_ssl_context *ssl)
   3399          {
   \                     mbedtls_ssl_get_max_out_record_payload: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3400              size_t max_len = MBEDTLS_SSL_OUT_CONTENT_LEN;
   3401          
   3402          #if !defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH) && \
   3403              !defined(MBEDTLS_SSL_PROTO_DTLS)
   3404              (void) ssl;
   3405          #endif
   3406          
   3407          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   3408              const size_t mfl = mbedtls_ssl_get_output_max_frag_len(ssl);
   \        0x2   0x.... 0x....      BL       mbedtls_ssl_get_output_max_frag_len
   \        0x6   0xF44F 0x7440      MOV      R4,#+768
   3409          
   3410              if (max_len > mfl) {
   \        0xA   0xF5B0 0x7F40      CMP      R0,#+768
   \        0xE   0xBF38             IT       CC
   \       0x10   0x4604             MOVCC    R4,R0
   3411                  max_len = mfl;
   3412              }
   3413          #endif
   3414          
   3415          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3416              if (mbedtls_ssl_get_current_mtu(ssl) != 0) {
   3417                  const size_t mtu = mbedtls_ssl_get_current_mtu(ssl);
   3418                  const int ret = mbedtls_ssl_get_record_expansion(ssl);
   3419                  const size_t overhead = (size_t) ret;
   3420          
   3421                  if (ret < 0) {
   3422                      return ret;
   3423                  }
   3424          
   3425                  if (mtu <= overhead) {
   3426                      MBEDTLS_SSL_DEBUG_MSG(1, ("MTU too low for record expansion"));
   3427                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3428                  }
   3429          
   3430                  if (max_len > mtu - overhead) {
   3431                      max_len = mtu - overhead;
   3432                  }
   3433              }
   3434          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3435          
   3436          #if !defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH) &&        \
   3437              !defined(MBEDTLS_SSL_PROTO_DTLS)
   3438              ((void) ssl);
   3439          #endif
   3440          
   3441              return (int) max_len;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}
   3442          }
   3443          

   \                                 In section .text, align 2, keep-with-next
   3444          int mbedtls_ssl_get_max_in_record_payload(const mbedtls_ssl_context *ssl)
   3445          {
   \                     mbedtls_ssl_get_max_in_record_payload: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3446              size_t max_len = MBEDTLS_SSL_IN_CONTENT_LEN;
   3447          
   3448          #if !defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   3449              (void) ssl;
   3450          #endif
   3451          
   3452          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   3453              const size_t mfl = mbedtls_ssl_get_input_max_frag_len(ssl);
   \        0x2   0x.... 0x....      BL       mbedtls_ssl_get_input_max_frag_len
   \        0x6   0xF44F 0x7440      MOV      R4,#+768
   3454          
   3455              if (max_len > mfl) {
   \        0xA   0xF5B0 0x7F40      CMP      R0,#+768
   \        0xE   0xBF38             IT       CC
   \       0x10   0x4604             MOVCC    R4,R0
   3456                  max_len = mfl;
   3457              }
   3458          #endif
   3459          
   3460              return (int) max_len;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}
   3461          }
   3462          
   3463          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
   3464          const mbedtls_x509_crt *mbedtls_ssl_get_peer_cert(const mbedtls_ssl_context *ssl)
   3465          {
   3466              if (ssl == NULL || ssl->session == NULL) {
   \                     mbedtls_ssl_get_peer_cert: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x6B00             LDRNE    R0,[R0, #+48]
   \        0x6   0x2800             CMPNE    R0,#+0
   \        0x8   0xD101             BNE.N    ??mbedtls_ssl_get_peer_cert_0
   3467                  return NULL;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
   3468              }
   3469          
   3470          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   3471              return ssl->session->peer_cert;
   \                     ??mbedtls_ssl_get_peer_cert_0: (+1)
   \        0xE   0x6DC0             LDR      R0,[R0, #+92]
   \       0x10   0x4770             BX       LR
   3472          #else
   3473              return NULL;
   3474          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   3475          }
   3476          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   3477          
   3478          #if defined(MBEDTLS_SSL_CLI_C)

   \                                 In section .text, align 2, keep-with-next
   3479          int mbedtls_ssl_get_session(const mbedtls_ssl_context *ssl,
   3480                                      mbedtls_ssl_session *dst)
   3481          {
   \                     mbedtls_ssl_get_session: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x4608             MOV      R0,R1
   3482              int ret;
   3483          
   3484              if (ssl == NULL ||
   3485                  dst == NULL ||
   3486                  ssl->session == NULL ||
   3487                  ssl->conf->endpoint != MBEDTLS_SSL_IS_CLIENT) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2800             CMPNE    R0,#+0
   \        0xA   0xD004             BEQ.N    ??mbedtls_ssl_get_session_0
   \        0xC   0x6B21             LDR      R1,[R4, #+48]
   \        0xE   0xB111             CBZ.N    R1,??mbedtls_ssl_get_session_0
   \       0x10   0x6823             LDR      R3,[R4, #+0]
   \       0x12   0x791A             LDRB     R2,[R3, #+4]
   \       0x14   0xB102             CBZ.N    R2,??mbedtls_ssl_get_session_1
   3488                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_get_session_0: (+1)
   \       0x16   0x....             B.N      ?Subroutine3
   3489              }
   3490          
   3491              /* Since Mbed TLS 3.0, mbedtls_ssl_get_session() is no longer
   3492               * idempotent: Each session can only be exported once.
   3493               *
   3494               * (This is in preparation for TLS 1.3 support where we will
   3495               * need the ability to export multiple sessions (aka tickets),
   3496               * which will be achieved by calling mbedtls_ssl_get_session()
   3497               * multiple times until it fails.)
   3498               *
   3499               * Check whether we have already exported the current session,
   3500               * and fail if so.
   3501               */
   3502              if (ssl->session->exported == 1) {
   \                     ??mbedtls_ssl_get_session_1: (+1)
   \       0x18   0x784A             LDRB     R2,[R1, #+1]
   \       0x1A   0x2A01             CMP      R2,#+1
   \       0x1C   0xD100             BNE.N    ??mbedtls_ssl_get_session_2
   3503                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   \       0x1E   0x....             B.N      ?Subroutine2
   3504              }
   3505          
   3506              ret = mbedtls_ssl_session_copy(dst, ssl->session);
   \                     ??mbedtls_ssl_get_session_2: (+1)
   \       0x20   0x.... 0x....      BL       mbedtls_ssl_session_copy
   3507              if (ret != 0) {
   \       0x24   0xB918             CBNZ.N   R0,??mbedtls_ssl_get_session_3
   3508                  return ret;
   3509              }
   3510          
   3511              /* Remember that we've exported the session. */
   3512              ssl->session->exported = 1;
   \       0x26   0x6B21             LDR      R1,[R4, #+48]
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7048             STRB     R0,[R1, #+1]
   3513              return 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_get_session_3: (+1)
   \       0x2E   0xBD10             POP      {R4,PC}
   3514          }
   3515          #endif /* MBEDTLS_SSL_CLI_C */
   3516          
   3517          /*
   3518           * Define ticket header determining Mbed TLS version
   3519           * and structure of the ticket.
   3520           */
   3521          
   3522          /*
   3523           * Define bitflag determining compile-time settings influencing
   3524           * structure of serialized SSL sessions.
   3525           */
   3526          
   3527          #if defined(MBEDTLS_HAVE_TIME)
   3528          #define SSL_SERIALIZED_SESSION_CONFIG_TIME 1
   3529          #else
   3530          #define SSL_SERIALIZED_SESSION_CONFIG_TIME 0
   3531          #endif /* MBEDTLS_HAVE_TIME */
   3532          
   3533          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   3534          #define SSL_SERIALIZED_SESSION_CONFIG_CRT 1
   3535          #else
   3536          #define SSL_SERIALIZED_SESSION_CONFIG_CRT 0
   3537          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   3538          
   3539          #if defined(MBEDTLS_SSL_CLI_C) && defined(MBEDTLS_SSL_SESSION_TICKETS)
   3540          #define SSL_SERIALIZED_SESSION_CONFIG_CLIENT_TICKET 1
   3541          #else
   3542          #define SSL_SERIALIZED_SESSION_CONFIG_CLIENT_TICKET 0
   3543          #endif /* MBEDTLS_SSL_CLI_C && MBEDTLS_SSL_SESSION_TICKETS */
   3544          
   3545          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   3546          #define SSL_SERIALIZED_SESSION_CONFIG_MFL 1
   3547          #else
   3548          #define SSL_SERIALIZED_SESSION_CONFIG_MFL 0
   3549          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   3550          
   3551          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   3552          #define SSL_SERIALIZED_SESSION_CONFIG_ETM 1
   3553          #else
   3554          #define SSL_SERIALIZED_SESSION_CONFIG_ETM 0
   3555          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   3556          
   3557          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3558          #define SSL_SERIALIZED_SESSION_CONFIG_TICKET 1
   3559          #else
   3560          #define SSL_SERIALIZED_SESSION_CONFIG_TICKET 0
   3561          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   3562          
   3563          #define SSL_SERIALIZED_SESSION_CONFIG_TIME_BIT          0
   3564          #define SSL_SERIALIZED_SESSION_CONFIG_CRT_BIT           1
   3565          #define SSL_SERIALIZED_SESSION_CONFIG_CLIENT_TICKET_BIT 2
   3566          #define SSL_SERIALIZED_SESSION_CONFIG_MFL_BIT           3
   3567          #define SSL_SERIALIZED_SESSION_CONFIG_ETM_BIT           4
   3568          #define SSL_SERIALIZED_SESSION_CONFIG_TICKET_BIT        5
   3569          
   3570          #define SSL_SERIALIZED_SESSION_CONFIG_BITFLAG                           \
   3571              ((uint16_t) (                                                      \
   3572                   (SSL_SERIALIZED_SESSION_CONFIG_TIME << SSL_SERIALIZED_SESSION_CONFIG_TIME_BIT) | \
   3573                   (SSL_SERIALIZED_SESSION_CONFIG_CRT << SSL_SERIALIZED_SESSION_CONFIG_CRT_BIT) | \
   3574                   (SSL_SERIALIZED_SESSION_CONFIG_CLIENT_TICKET << \
   3575                       SSL_SERIALIZED_SESSION_CONFIG_CLIENT_TICKET_BIT) | \
   3576                   (SSL_SERIALIZED_SESSION_CONFIG_MFL << SSL_SERIALIZED_SESSION_CONFIG_MFL_BIT) | \
   3577                   (SSL_SERIALIZED_SESSION_CONFIG_ETM << SSL_SERIALIZED_SESSION_CONFIG_ETM_BIT) | \
   3578                   (SSL_SERIALIZED_SESSION_CONFIG_TICKET << SSL_SERIALIZED_SESSION_CONFIG_TICKET_BIT)))
   3579          

   \                                 In section .data, align 4
   3580          static unsigned char ssl_serialized_session_header[] = {
   \                     ssl_serialized_session_header:
   \        0x0   0x03 0x05          DC8 3, 5, 0, 0, 10
   \              0x00 0x00    
   \              0x0A
   \        0x5                      DS8 3
   3581              MBEDTLS_VERSION_MAJOR,
   3582              MBEDTLS_VERSION_MINOR,
   3583              MBEDTLS_VERSION_PATCH,
   3584              MBEDTLS_BYTE_1(SSL_SERIALIZED_SESSION_CONFIG_BITFLAG),
   3585              MBEDTLS_BYTE_0(SSL_SERIALIZED_SESSION_CONFIG_BITFLAG),
   3586          };
   3587          
   3588          /*
   3589           * Serialize a session in the following format:
   3590           * (in the presentation language of TLS, RFC 8446 section 3)
   3591           *
   3592           *  struct {
   3593           *
   3594           *    opaque mbedtls_version[3];   // library version: major, minor, patch
   3595           *    opaque session_format[2];    // library-version specific 16-bit field
   3596           *                                 // determining the format of the remaining
   3597           *                                 // serialized data.
   3598           *
   3599           *          Note: When updating the format, remember to keep
   3600           *          these version+format bytes.
   3601           *
   3602           *                                 // In this version, `session_format` determines
   3603           *                                 // the setting of those compile-time
   3604           *                                 // configuration options which influence
   3605           *                                 // the structure of mbedtls_ssl_session.
   3606           *
   3607           *    uint8_t minor_ver;           // Protocol minor version. Possible values:
   3608           *                                 // - TLS 1.2 (0x0303)
   3609           *                                 // - TLS 1.3 (0x0304)
   3610           *
   3611           *    select (serialized_session.tls_version) {
   3612           *
   3613           *      case MBEDTLS_SSL_VERSION_TLS1_2:
   3614           *        serialized_session_tls12 data;
   3615           *      case MBEDTLS_SSL_VERSION_TLS1_3:
   3616           *        serialized_session_tls13 data;
   3617           *
   3618           *   };
   3619           *
   3620           * } serialized_session;
   3621           *
   3622           */
   3623          
   3624          MBEDTLS_CHECK_RETURN_CRITICAL
   3625          static int ssl_session_save(const mbedtls_ssl_session *session,
   3626                                      unsigned char omit_header,
   3627                                      unsigned char *buf,
   3628                                      size_t buf_len,
   3629                                      size_t *olen)
   3630          {
   3631              unsigned char *p = buf;
   3632              size_t used = 0;
   3633              size_t remaining_len;
   3634          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   3635              size_t out_len;
   3636              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3637          #endif
   3638              if (session == NULL) {
   3639                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3640              }
   3641          
   3642              if (!omit_header) {
   3643                  /*
   3644                   * Add Mbed TLS version identifier
   3645                   */
   3646                  used += sizeof(ssl_serialized_session_header);
   3647          
   3648                  if (used <= buf_len) {
   3649                      memcpy(p, ssl_serialized_session_header,
   3650                             sizeof(ssl_serialized_session_header));
   3651                      p += sizeof(ssl_serialized_session_header);
   3652                  }
   3653              }
   3654          
   3655              /*
   3656               * TLS version identifier
   3657               */
   3658              used += 1;
   3659              if (used <= buf_len) {
   3660                  *p++ = MBEDTLS_BYTE_0(session->tls_version);
   3661              }
   3662          
   3663              /* Forward to version-specific serialization routine. */
   3664              remaining_len = (buf_len >= used) ? buf_len - used : 0;
   3665              switch (session->tls_version) {
   3666          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3667                  case MBEDTLS_SSL_VERSION_TLS1_2:
   3668                      used += ssl_tls12_session_save(session, p, remaining_len);
   3669                      break;
   3670          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3671          
   3672          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   3673                  case MBEDTLS_SSL_VERSION_TLS1_3:
   3674                      ret = ssl_tls13_session_save(session, p, remaining_len, &out_len);
   3675                      if (ret != 0 && ret != MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) {
   3676                          return ret;
   3677                      }
   3678                      used += out_len;
   3679                      break;
   3680          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   3681          
   3682                  default:
   3683                      return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3684              }
   3685          
   3686              *olen = used;
   3687              if (used > buf_len) {
   3688                  return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   3689              }
   3690          
   3691              return 0;
   3692          }
   3693          
   3694          /*
   3695           * Public wrapper for ssl_session_save()
   3696           */

   \                                 In section .text, align 2, keep-with-next
   3697          int mbedtls_ssl_session_save(const mbedtls_ssl_session *session,
   3698                                       unsigned char *buf,
   3699                                       size_t buf_len,
   3700                                       size_t *olen)
   3701          {
   \                     mbedtls_ssl_session_save: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4699             MOV      R9,R3
   3702              return ssl_session_save(session, 0, buf, buf_len, olen);
   \        0xA   0xBF08             IT       EQ
   \        0xC   0x.... 0x....      LDREQ.W  R0,??DataTable31_2
   \       0x10   0xD067             BEQ.N    ??mbedtls_ssl_session_save_0
   \       0x12   0x4690             MOV      R8,R2
   \       0x14   0xF1B8 0x0F05      CMP      R8,#+5
   \       0x18   0xD305             BCC.N    ??mbedtls_ssl_session_save_1
   \       0x1A   0x2205             MOVS     R2,#+5
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable31_3
   \       0x20   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x24   0x1D6D             ADDS     R5,R5,#+5
   \                     ??mbedtls_ssl_session_save_1: (+1)
   \       0x26   0xF1B8 0x0F05      CMP      R8,#+5
   \       0x2A   0xBF83             ITTTE    HI
   \       0x2C   0x8860             LDRHHI   R0,[R4, #+2]
   \       0x2E   0xF805 0x0B01      STRBHI   R0,[R5], #+1
   \       0x32   0xF1A8 0x0A06      SUBHI    R10,R8,#+6
   \       0x36   0xF04F 0x0A00      MOVLS    R10,#+0
   \       0x3A   0xF9B4 0x1002      LDRSH    R1,[R4, #+2]
   \       0x3E   0xF240 0x3003      MOVW     R0,#+771
   \       0x42   0x4281             CMP      R1,R0
   \       0x44   0xD14C             BNE.N    ??mbedtls_ssl_session_save_2
   \       0x46   0xF1BA 0x0F57      CMP      R10,#+87
   \       0x4A   0xD325             BCC.N    ??mbedtls_ssl_session_save_3
   \       0x4C   0x.... 0x....      LDR.W    R6,??DataTable31_4
   \       0x50   0x7831             LDRB     R1,[R6, #+0]
   \       0x52   0x6860             LDR      R0,[R4, #+4]
   \       0x54   0x2901             CMP      R1,#+1
   \       0x56   0xBF08             IT       EQ
   \       0x58   0xB281             UXTHEQ   R1,R0
   \       0x5A   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x64   0x68A0             LDR      R0,[R4, #+8]
   \       0x66   0x2220             MOVS     R2,#+32
   \       0x68   0xF104 0x010C      ADD      R1,R4,#+12
   \       0x6C   0x70A8             STRB     R0,[R5, #+2]
   \       0x6E   0x1CED             ADDS     R5,R5,#+3
   \       0x70   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x74   0x3520             ADDS     R5,R5,#+32
   \       0x76   0x2230             MOVS     R2,#+48
   \       0x78   0xF104 0x012C      ADD      R1,R4,#+44
   \       0x7C   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x80   0x7831             LDRB     R1,[R6, #+0]
   \       0x82   0x3530             ADDS     R5,R5,#+48
   \       0x84   0x6E20             LDR      R0,[R4, #+96]
   \       0x86   0x2901             CMP      R1,#+1
   \       0x88   0xBF18             IT       NE
   \       0x8A   0x.... 0x....      BLNE     mbedtls_bswap32
   \       0x8E   0x4601             MOV      R1,R0
   \       0x90   0x4628             MOV      R0,R5
   \       0x92   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
   \       0x96   0x1D2D             ADDS     R5,R5,#+4
   \                     ??mbedtls_ssl_session_save_3: (+1)
   \       0x98   0x6DE0             LDR      R0,[R4, #+92]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xBF0C             ITE      EQ
   \       0x9E   0x2700             MOVEQ    R7,#+0
   \       0xA0   0x6887             LDRNE    R7,[R0, #+8]
   \       0xA2   0xF107 0x065A      ADD      R6,R7,#+90
   \       0xA6   0x45B2             CMP      R10,R6
   \       0xA8   0xD30C             BCC.N    ??mbedtls_ssl_session_save_4
   \       0xAA   0x0C39             LSRS     R1,R7,#+16
   \       0xAC   0x7029             STRB     R1,[R5, #+0]
   \       0xAE   0x0A38             LSRS     R0,R7,#+8
   \       0xB0   0x7068             STRB     R0,[R5, #+1]
   \       0xB2   0x70AF             STRB     R7,[R5, #+2]
   \       0xB4   0x6DE0             LDR      R0,[R4, #+92]
   \       0xB6   0x1CED             ADDS     R5,R5,#+3
   \       0xB8   0xB120             CBZ.N    R0,??mbedtls_ssl_session_save_4
   \       0xBA   0x68C1             LDR      R1,[R0, #+12]
   \       0xBC   0x463A             MOV      R2,R7
   \       0xBE   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xC2   0x19ED             ADDS     R5,R5,R7
   \                     ??mbedtls_ssl_session_save_4: (+1)
   \       0xC4   0x1C76             ADDS     R6,R6,#+1
   \       0xC6   0x45B2             CMP      R10,R6
   \       0xC8   0xBF24             ITT      CS
   \       0xCA   0x7820             LDRBCS   R0,[R4, #+0]
   \       0xCC   0x7028             STRBCS   R0,[R5, #+0]
   \       0xCE   0x1DB6             ADDS     R6,R6,#+6
   \       0xD0   0xF8C9 0x6000      STR      R6,[R9, #+0]
   \       0xD4   0x45B0             CMP      R8,R6
   \       0xD6   0xBF34             ITE      CC
   \       0xD8   0x.... 0x....      LDRCC.W  R0,??DataTable32
   \       0xDC   0x2000             MOVCS    R0,#+0
   \       0xDE   0xE000             B.N      ??mbedtls_ssl_session_save_0
   \                     ??mbedtls_ssl_session_save_2: (+1)
   \       0xE0   0x....             LDR.N    R0,??DataTable26_3
   \                     ??mbedtls_ssl_session_save_0: (+1)
   \       0xE2   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3703          }
   3704          
   3705          /*
   3706           * Deserialize session, see mbedtls_ssl_session_save() for format.
   3707           *
   3708           * This internal version is wrapped by a public function that cleans up in
   3709           * case of error, and has an extra option omit_header.
   3710           */
   3711          MBEDTLS_CHECK_RETURN_CRITICAL
   3712          static int ssl_session_load(mbedtls_ssl_session *session,
   3713                                      unsigned char omit_header,
   3714                                      const unsigned char *buf,
   3715                                      size_t len)
   3716          {
   3717              const unsigned char *p = buf;
   3718              const unsigned char * const end = buf + len;
   3719              size_t remaining_len;
   3720          
   3721          
   3722              if (session == NULL) {
   3723                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   3724              }
   3725          
   3726              if (!omit_header) {
   3727                  /*
   3728                   * Check Mbed TLS version identifier
   3729                   */
   3730          
   3731                  if ((size_t) (end - p) < sizeof(ssl_serialized_session_header)) {
   3732                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3733                  }
   3734          
   3735                  if (memcmp(p, ssl_serialized_session_header,
   3736                             sizeof(ssl_serialized_session_header)) != 0) {
   3737                      return MBEDTLS_ERR_SSL_VERSION_MISMATCH;
   3738                  }
   3739                  p += sizeof(ssl_serialized_session_header);
   3740              }
   3741          
   3742              /*
   3743               * TLS version identifier
   3744               */
   3745              if (1 > (size_t) (end - p)) {
   3746                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3747              }
   3748              session->tls_version = (mbedtls_ssl_protocol_version) (0x0300 | *p++);
   3749          
   3750              /* Dispatch according to TLS version. */
   3751              remaining_len = (end - p);
   3752              switch (session->tls_version) {
   3753          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3754                  case MBEDTLS_SSL_VERSION_TLS1_2:
   3755                      return ssl_tls12_session_load(session, p, remaining_len);
   3756          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3757          
   3758          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   3759                  case MBEDTLS_SSL_VERSION_TLS1_3:
   3760                      return ssl_tls13_session_load(session, p, remaining_len);
   3761          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   3762          
   3763                  default:
   3764                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3765              }
   3766          }
   3767          
   3768          /*
   3769           * Deserialize session: public wrapper for error cleaning
   3770           */

   \                                 In section .text, align 2, keep-with-next
   3771          int mbedtls_ssl_session_load(mbedtls_ssl_session *session,
   3772                                       const unsigned char *buf,
   3773                                       size_t len)
   3774          {
   \                     mbedtls_ssl_session_load: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   3775              int ret = ssl_session_load(session, 0, buf, len);
   \        0xA   0xBF08             IT       EQ
   \        0xC   0x.... 0x....      LDREQ.W  R7,??DataTable31_2
   \       0x10   0xD07D             BEQ.N    ??mbedtls_ssl_session_load_0
   \       0x12   0x2E05             CMP      R6,#+5
   \       0x14   0xD379             BCC.N    ??mbedtls_ssl_session_load_1
   \       0x16   0x2205             MOVS     R2,#+5
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable31_3
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x.... 0x....      BL       memcmp
   \       0x22   0xB110             CBZ.N    R0,??mbedtls_ssl_session_load_2
   \       0x24   0x.... 0x....      LDR.W    R7,??DataTable32_1
   \       0x28   0xE071             B.N      ??mbedtls_ssl_session_load_0
   \                     ??mbedtls_ssl_session_load_2: (+1)
   \       0x2A   0x2E05             CMP      R6,#+5
   \       0x2C   0xD06D             BEQ.N    ??mbedtls_ssl_session_load_1
   \       0x2E   0x7969             LDRB     R1,[R5, #+5]
   \       0x30   0xF240 0x3003      MOVW     R0,#+771
   \       0x34   0xF441 0x7140      ORR      R1,R1,#0x300
   \       0x38   0x8061             STRH     R1,[R4, #+2]
   \       0x3A   0x4281             CMP      R1,R0
   \       0x3C   0xD165             BNE.N    ??mbedtls_ssl_session_load_1
   \       0x3E   0x1FB6             SUBS     R6,R6,#+6
   \       0x40   0x2E57             CMP      R6,#+87
   \       0x42   0xD362             BCC.N    ??mbedtls_ssl_session_load_1
   \       0x44   0x79A8             LDRB     R0,[R5, #+6]
   \       0x46   0x79E9             LDRB     R1,[R5, #+7]
   \       0x48   0xF105 0x0708      ADD      R7,R5,#+8
   \       0x4C   0x2220             MOVS     R2,#+32
   \       0x4E   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \       0x52   0x6061             STR      R1,[R4, #+4]
   \       0x54   0xF817 0x0B01      LDRB     R0,[R7], #+1
   \       0x58   0x60A0             STR      R0,[R4, #+8]
   \       0x5A   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x5E   0x4639             MOV      R1,R7
   \       0x60   0x.... 0x....      BL       __aeabi_memcpy
   \       0x64   0x3720             ADDS     R7,R7,#+32
   \       0x66   0x2230             MOVS     R2,#+48
   \       0x68   0x4639             MOV      R1,R7
   \       0x6A   0xF104 0x002C      ADD      R0,R4,#+44
   \       0x6E   0x.... 0x....      BL       __aeabi_memcpy
   \       0x72   0x.... 0x....      LDR.W    R1,??DataTable31_4
   \       0x76   0x7808             LDRB     R0,[R1, #+0]
   \       0x78   0x3730             ADDS     R7,R7,#+48
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0x4638             MOV      R0,R7
   \       0x7E   0xD102             BNE.N    ??mbedtls_ssl_session_load_3
   \       0x80   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x84   0xE003             B.N      ??mbedtls_ssl_session_load_4
   \                     ??mbedtls_ssl_session_load_3: (+1)
   \       0x86   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x8A   0x.... 0x....      BL       mbedtls_bswap32
   \                     ??mbedtls_ssl_session_load_4: (+1)
   \       0x8E   0x6620             STR      R0,[R4, #+96]
   \       0x90   0xEB05 0x0806      ADD      R8,R5,R6
   \       0x94   0x1D38             ADDS     R0,R7,#+4
   \       0x96   0xF108 0x0606      ADD      R6,R8,#+6
   \       0x9A   0x2200             MOVS     R2,#+0
   \       0x9C   0x1A31             SUBS     R1,R6,R0
   \       0x9E   0x65E2             STR      R2,[R4, #+92]
   \       0xA0   0x2903             CMP      R1,#+3
   \       0xA2   0xD332             BCC.N    ??mbedtls_ssl_session_load_1
   \       0xA4   0x7841             LDRB     R1,[R0, #+1]
   \       0xA6   0x7802             LDRB     R2,[R0, #+0]
   \       0xA8   0x7885             LDRB     R5,[R0, #+2]
   \       0xAA   0x0209             LSLS     R1,R1,#+8
   \       0xAC   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \       0xB0   0xF100 0x0903      ADD      R9,R0,#+3
   \       0xB4   0x430D             ORRS     R5,R5,R1
   \       0xB6   0xD01C             BEQ.N    ??mbedtls_ssl_session_load_5
   \       0xB8   0xEBA6 0x0009      SUB      R0,R6,R9
   \       0xBC   0x42A8             CMP      R0,R5
   \       0xBE   0xD324             BCC.N    ??mbedtls_ssl_session_load_1
   \       0xC0   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0xC4   0x65E0             STR      R0,[R4, #+92]
   \       0xC6   0xB908             CBNZ.N   R0,??mbedtls_ssl_session_load_6
   \       0xC8   0x....             LDR.N    R7,??DataTable29_1
   \       0xCA   0xE020             B.N      ??mbedtls_ssl_session_load_0
   \                     ??mbedtls_ssl_session_load_6: (+1)
   \       0xCC   0x.... 0x....      BL       mbedtls_x509_crt_init
   \       0xD0   0x6DE0             LDR      R0,[R4, #+92]
   \       0xD2   0x462A             MOV      R2,R5
   \       0xD4   0x4649             MOV      R1,R9
   \       0xD6   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0xDA   0x0007             MOVS     R7,R0
   \       0xDC   0xD008             BEQ.N    ??mbedtls_ssl_session_load_7
   \       0xDE   0x6DE0             LDR      R0,[R4, #+92]
   \       0xE0   0x.... 0x....      BL       mbedtls_x509_crt_free
   \       0xE4   0x6DE0             LDR      R0,[R4, #+92]
   \       0xE6   0x.... 0x....      BL       sl_free
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x65E0             STR      R0,[R4, #+92]
   \       0xEE   0xE00E             B.N      ??mbedtls_ssl_session_load_0
   \                     ??mbedtls_ssl_session_load_7: (+1)
   \       0xF0   0x44A9             ADD      R9,R9,R5
   \                     ??mbedtls_ssl_session_load_5: (+1)
   \       0xF2   0xEBB6 0x0609      SUBS     R6,R6,R9
   \       0xF6   0xD008             BEQ.N    ??mbedtls_ssl_session_load_1
   \       0xF8   0xF819 0x0B01      LDRB     R0,[R9], #+1
   \       0xFC   0xF108 0x0106      ADD      R1,R8,#+6
   \      0x100   0x7020             STRB     R0,[R4, #+0]
   \      0x102   0x4589             CMP      R9,R1
   \      0x104   0xBF08             IT       EQ
   \      0x106   0x2700             MOVEQ    R7,#+0
   \      0x108   0xD004             BEQ.N    ??mbedtls_ssl_session_load_8
   \                     ??mbedtls_ssl_session_load_1: (+1)
   \      0x10A   0x.... 0x....      LDR.W    R7,??DataTable31_1
   3776          
   3777              if (ret != 0) {
   3778                  mbedtls_ssl_session_free(session);
   \                     ??mbedtls_ssl_session_load_0: (+1)
   \      0x10E   0x4620             MOV      R0,R4
   \      0x110   0x.... 0x....      BL       mbedtls_ssl_session_free
   3779              }
   3780          
   3781              return ret;
   \                     ??mbedtls_ssl_session_load_8: (+1)
   \      0x114   0x4638             MOV      R0,R7
   \      0x116   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   3782          }
   3783          
   3784          /*
   3785           * Perform a single step of the SSL handshake
   3786           */
   3787          MBEDTLS_CHECK_RETURN_CRITICAL
   3788          static int ssl_prepare_handshake_step(mbedtls_ssl_context *ssl)
   3789          {
   3790              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3791          
   3792              /*
   3793               * We may have not been able to send to the peer all the handshake data
   3794               * that were written into the output buffer by the previous handshake step,
   3795               * if the write to the network callback returned with the
   3796               * #MBEDTLS_ERR_SSL_WANT_WRITE error code.
   3797               * We proceed to the next handshake step only when all data from the
   3798               * previous one have been sent to the peer, thus we make sure that this is
   3799               * the case here by calling `mbedtls_ssl_flush_output()`. The function may
   3800               * return with the #MBEDTLS_ERR_SSL_WANT_WRITE error code in which case
   3801               * we have to wait before to go ahead.
   3802               * In the case of TLS 1.3, handshake step handlers do not send data to the
   3803               * peer. Data are only sent here and through
   3804               * `mbedtls_ssl_handle_pending_alert` in case an error that triggered an
   3805               * alert occurred.
   3806               */
   3807              if ((ret = mbedtls_ssl_flush_output(ssl)) != 0) {
   3808                  return ret;
   3809              }
   3810          
   3811          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3812              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3813                  ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING) {
   3814                  if ((ret = mbedtls_ssl_flight_transmit(ssl)) != 0) {
   3815                      return ret;
   3816                  }
   3817              }
   3818          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3819          
   3820              return ret;
   3821          }
   3822          

   \                                 In section .text, align 2, keep-with-next
   3823          int mbedtls_ssl_handshake_step(mbedtls_ssl_context *ssl)
   3824          {
   \                     mbedtls_ssl_handshake_step: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3825              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3826          
   3827              if (ssl            == NULL                       ||
   3828                  ssl->conf      == NULL                       ||
   3829                  ssl->handshake == NULL                       ||
   3830                  ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER) {
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable31_1
   \        0x8   0xBF1C             ITT      NE
   \        0xA   0x6820             LDRNE    R0,[R4, #+0]
   \        0xC   0x2800             CMPNE    R0,#+0
   \        0xE   0xD005             BEQ.N    ??mbedtls_ssl_handshake_step_0
   \       0x10   0x6BA0             LDR      R0,[R4, #+56]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x6860             LDRNE    R0,[R4, #+4]
   \       0x18   0x281B             CMPNE    R0,#+27
   \       0x1A   0xD101             BNE.N    ??mbedtls_ssl_handshake_step_1
   3831                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \                     ??mbedtls_ssl_handshake_step_0: (+1)
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
   3832              }
   3833          
   3834              ret = ssl_prepare_handshake_step(ssl);
   \                     ??mbedtls_ssl_handshake_step_1: (+1)
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       mbedtls_ssl_flush_output
   \       0x26   0xBB00             CBNZ.N   R0,??mbedtls_ssl_handshake_step_2
   3835              if (ret != 0) {
   3836                  return ret;
   3837              }
   3838          
   3839              ret = mbedtls_ssl_handle_pending_alert(ssl);
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       mbedtls_ssl_handle_pending_alert
   3840              if (ret != 0) {
   \       0x2E   0xB9E0             CBNZ.N   R0,??mbedtls_ssl_handshake_step_2
   3841                  goto cleanup;
   3842              }
   3843          
   3844              /* If ssl->conf->endpoint is not one of MBEDTLS_SSL_IS_CLIENT or
   3845               * MBEDTLS_SSL_IS_SERVER, this is the return code we give */
   3846              ret = MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3847          
   3848          #if defined(MBEDTLS_SSL_CLI_C)
   3849              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   \       0x30   0x6822             LDR      R2,[R4, #+0]
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x7911             LDRB     R1,[R2, #+4]
   \       0x36   0xB981             CBNZ.N   R1,??mbedtls_ssl_handshake_step_3
   3850                  MBEDTLS_SSL_DEBUG_MSG(2, ("client state: %s",
   3851                                            mbedtls_ssl_states_str((mbedtls_ssl_states) ssl->state)));
   3852          
   3853                  switch (ssl->state) {
   \       0x38   0x6861             LDR      R1,[R4, #+4]
   \       0x3A   0xB111             CBZ.N    R1,??mbedtls_ssl_handshake_step_4
   \       0x3C   0x2901             CMP      R1,#+1
   \       0x3E   0xD004             BEQ.N    ??mbedtls_ssl_handshake_step_5
   \       0x40   0xE007             B.N      ??mbedtls_ssl_handshake_step_6
   3854                      case MBEDTLS_SSL_HELLO_REQUEST:
   3855                          ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   \                     ??mbedtls_ssl_handshake_step_4: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0x6060             STR      R0,[R4, #+4]
   3856                          ret = 0;
   \       0x46   0x2000             MOVS     R0,#+0
   3857                          break;
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}
   3858          
   3859                      case MBEDTLS_SSL_CLIENT_HELLO:
   3860                          ret = mbedtls_ssl_write_client_hello(ssl);
   \                     ??mbedtls_ssl_handshake_step_5: (+1)
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x.... 0x....      BL       mbedtls_ssl_write_client_hello
   3861                          break;
   \       0x50   0xE002             B.N      ??mbedtls_ssl_handshake_step_7
   3862          
   3863                      default:
   3864          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_TLS1_3)
   3865                          if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   3866                              ret = mbedtls_ssl_tls13_handshake_client_step(ssl);
   3867                          } else {
   3868                              ret = mbedtls_ssl_handshake_client_step(ssl);
   3869                          }
   3870          #elif defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3871                          ret = mbedtls_ssl_handshake_client_step(ssl);
   \                     ??mbedtls_ssl_handshake_step_6: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x.... 0x....      BL       mbedtls_ssl_handshake_client_step
   3872          #else
   3873                          ret = mbedtls_ssl_tls13_handshake_client_step(ssl);
   3874          #endif
   3875                  }
   3876              }
   3877          #endif /* MBEDTLS_SSL_CLI_C */
   3878          
   3879          #if defined(MBEDTLS_SSL_SRV_C)
   3880              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   3881          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_TLS1_3)
   3882                  if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   3883                      ret = mbedtls_ssl_tls13_handshake_server_step(ssl);
   3884                  } else {
   3885                      ret = mbedtls_ssl_handshake_server_step(ssl);
   3886                  }
   3887          #elif defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3888                  ret = mbedtls_ssl_handshake_server_step(ssl);
   3889          #else
   3890                  ret = mbedtls_ssl_tls13_handshake_server_step(ssl);
   3891          #endif
   3892              }
   3893          #endif /* MBEDTLS_SSL_SRV_C */
   3894          
   3895              if (ret != 0) {
   \                     ??mbedtls_ssl_handshake_step_7: (+1)
   \       0x58   0xB138             CBZ.N    R0,??mbedtls_ssl_handshake_step_2
   3896                  /* handshake_step return error. And it is same
   3897                   * with alert_reason.
   3898                   */
   3899                  if (ssl->send_alert) {
   \                     ??mbedtls_ssl_handshake_step_3: (+1)
   \       0x5A   0xF894 0x108C      LDRB     R1,[R4, #+140]
   \       0x5E   0xB121             CBZ.N    R1,??mbedtls_ssl_handshake_step_2
   3900                      ret = mbedtls_ssl_handle_pending_alert(ssl);
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x66   0x.... 0x....      B.W      mbedtls_ssl_handle_pending_alert
   3901                      goto cleanup;
   3902                  }
   3903              }
   3904          
   3905          cleanup:
   3906              return ret;
   \                     ??mbedtls_ssl_handshake_step_2: (+1)
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}
   3907          }
   3908          
   3909          /*
   3910           * Perform the SSL handshake
   3911           */

   \                                 In section .text, align 2, keep-with-next
   3912          int mbedtls_ssl_handshake(mbedtls_ssl_context *ssl)
   3913          {
   \                     mbedtls_ssl_handshake: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   3914              int ret = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   3915          
   3916              /* Sanity checks */
   3917          
   3918              if (ssl == NULL || ssl->conf == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xBF1C             ITT      NE
   \        0xA   0x6821             LDRNE    R1,[R4, #+0]
   \        0xC   0x2900             CMPNE    R1,#+0
   \        0xE   0xD100             BNE.N    ??mbedtls_ssl_handshake_0
   3919                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   \       0x10   0x....             B.N      ?Subroutine3
   3920              }
   3921          
   3922          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3923              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3924                  (ssl->f_set_timer == NULL || ssl->f_get_timer == NULL)) {
   3925                  MBEDTLS_SSL_DEBUG_MSG(1, ("You must use "
   3926                                            "mbedtls_ssl_set_timer_cb() for DTLS"));
   3927                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   3928              }
   3929          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3930          
   3931              MBEDTLS_SSL_DEBUG_MSG(2, ("=> handshake"));
   3932          
   3933              /* Main handshake loop */
   3934              while (ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER) {
   \                     ??mbedtls_ssl_handshake_0: (+1)
   \       0x12   0x6861             LDR      R1,[R4, #+4]
   \       0x14   0x291B             CMP      R1,#+27
   \       0x16   0xD004             BEQ.N    ??mbedtls_ssl_handshake_1
   3935                  ret = mbedtls_ssl_handshake_step(ssl);
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_handshake_step
   3936          
   3937                  if (ret != 0) {
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD0F7             BEQ.N    ??mbedtls_ssl_handshake_0
   3938                      break;
   3939                  }
   3940              }
   3941          
   3942              MBEDTLS_SSL_DEBUG_MSG(2, ("<= handshake"));
   3943          
   3944              return ret;
   \                     ??mbedtls_ssl_handshake_1: (+1)
   \       0x22   0xBD10             POP      {R4,PC}
   3945          }
   3946          
   3947          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   3948          #if defined(MBEDTLS_SSL_SRV_C)
   3949          /*
   3950           * Write HelloRequest to request renegotiation on server
   3951           */
   3952          MBEDTLS_CHECK_RETURN_CRITICAL
   3953          static int ssl_write_hello_request(mbedtls_ssl_context *ssl)
   3954          {
   3955              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3956          
   3957              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write hello request"));
   3958          
   3959              ssl->out_msglen  = 4;
   3960              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3961              ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_REQUEST;
   3962          
   3963              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   3964                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   3965                  return ret;
   3966              }
   3967          
   3968              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write hello request"));
   3969          
   3970              return 0;
   3971          }
   3972          #endif /* MBEDTLS_SSL_SRV_C */
   3973          
   3974          /*
   3975           * Actually renegotiate current connection, triggered by either:
   3976           * - any side: calling mbedtls_ssl_renegotiate(),
   3977           * - client: receiving a HelloRequest during mbedtls_ssl_read(),
   3978           * - server: receiving any handshake message on server during mbedtls_ssl_read() after
   3979           *   the initial handshake is completed.
   3980           * If the handshake doesn't complete due to waiting for I/O, it will continue
   3981           * during the next calls to mbedtls_ssl_renegotiate() or mbedtls_ssl_read() respectively.
   3982           */
   3983          int mbedtls_ssl_start_renegotiation(mbedtls_ssl_context *ssl)
   3984          {
   3985              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3986          
   3987              MBEDTLS_SSL_DEBUG_MSG(2, ("=> renegotiate"));
   3988          
   3989              if ((ret = ssl_handshake_init(ssl)) != 0) {
   3990                  return ret;
   3991              }
   3992          
   3993              /* RFC 6347 4.2.2: "[...] the HelloRequest will have message_seq = 0 and
   3994               * the ServerHello will have message_seq = 1" */
   3995          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3996              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3997                  ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING) {
   3998                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   3999                      ssl->handshake->out_msg_seq = 1;
   4000                  } else {
   4001                      ssl->handshake->in_msg_seq = 1;
   4002                  }
   4003              }
   4004          #endif
   4005          
   4006              ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
   4007              ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS;
   4008          
   4009              if ((ret = mbedtls_ssl_handshake(ssl)) != 0) {
   4010                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_handshake", ret);
   4011                  return ret;
   4012              }
   4013          
   4014              MBEDTLS_SSL_DEBUG_MSG(2, ("<= renegotiate"));
   4015          
   4016              return 0;
   4017          }
   4018          
   4019          /*
   4020           * Renegotiate current connection on client,
   4021           * or request renegotiation on server
   4022           */
   4023          int mbedtls_ssl_renegotiate(mbedtls_ssl_context *ssl)
   4024          {
   4025              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   4026          
   4027              if (ssl == NULL || ssl->conf == NULL) {
   4028                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4029              }
   4030          
   4031          #if defined(MBEDTLS_SSL_SRV_C)
   4032              /* On server, just send the request */
   4033              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   4034                  if (mbedtls_ssl_is_handshake_over(ssl) == 0) {
   4035                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4036                  }
   4037          
   4038                  ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
   4039          
   4040                  /* Did we already try/start sending HelloRequest? */
   4041                  if (ssl->out_left != 0) {
   4042                      return mbedtls_ssl_flush_output(ssl);
   4043                  }
   4044          
   4045                  return ssl_write_hello_request(ssl);
   4046              }
   4047          #endif /* MBEDTLS_SSL_SRV_C */
   4048          
   4049          #if defined(MBEDTLS_SSL_CLI_C)
   4050              /*
   4051               * On client, either start the renegotiation process or,
   4052               * if already in progress, continue the handshake
   4053               */
   4054              if (ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   4055                  if (mbedtls_ssl_is_handshake_over(ssl) == 0) {
   4056                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4057                  }
   4058          
   4059                  if ((ret = mbedtls_ssl_start_renegotiation(ssl)) != 0) {
   4060                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_start_renegotiation", ret);
   4061                      return ret;
   4062                  }
   4063              } else {
   4064                  if ((ret = mbedtls_ssl_handshake(ssl)) != 0) {
   4065                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_handshake", ret);
   4066                      return ret;
   4067                  }
   4068              }
   4069          #endif /* MBEDTLS_SSL_CLI_C */
   4070          
   4071              return ret;
   4072          }
   4073          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   4074          

   \                                 In section .text, align 2, keep-with-next
   4075          void mbedtls_ssl_handshake_free(mbedtls_ssl_context *ssl)
   4076          {
   \                     mbedtls_ssl_handshake_free: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   4077              mbedtls_ssl_handshake_params *handshake = ssl->handshake;
   \        0x4   0x6BB0             LDR      R0,[R6, #+56]
   \        0x6   0x0004             MOVS     R4,R0
   4078          
   4079              if (handshake == NULL) {
   \        0x8   0xD020             BEQ.N    ??mbedtls_ssl_handshake_free_0
   4080                  return;
   4081              }
   4082          
   4083          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
   4084          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   4085              if (ssl->handshake->group_list_heap_allocated) {
   \        0xA   0x7901             LDRB     R1,[R0, #+4]
   \        0xC   0xF104 0x0544      ADD      R5,R4,#+68
   \       0x10   0xB111             CBZ.N    R1,??mbedtls_ssl_handshake_free_1
   4086                  mbedtls_free((void *) handshake->group_list);
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x.... 0x....      BL       sl_free
   4087              }
   4088              handshake->group_list = NULL;
   \                     ??mbedtls_ssl_handshake_free_1: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6029             STR      R1,[R5, #+0]
   4089          #endif /* MBEDTLS_DEPRECATED_REMOVED */
   4090          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   4091          
   4092          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   4093          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   4094              if (ssl->handshake->sig_algs_heap_allocated) {
   \       0x1C   0x6BB2             LDR      R2,[R6, #+56]
   \       0x1E   0x7950             LDRB     R0,[R2, #+5]
   \       0x20   0xB110             CBZ.N    R0,??mbedtls_ssl_handshake_free_2
   4095                  mbedtls_free((void *) handshake->sig_algs);
   \       0x22   0x6868             LDR      R0,[R5, #+4]
   \       0x24   0x.... 0x....      BL       sl_free
   4096              }
   4097              handshake->sig_algs = NULL;
   \                     ??mbedtls_ssl_handshake_free_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6068             STR      R0,[R5, #+4]
   4098          #endif /* MBEDTLS_DEPRECATED_REMOVED */
   4099          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   4100              if (ssl->handshake->certificate_request_context) {
   4101                  mbedtls_free((void *) handshake->certificate_request_context);
   4102              }
   4103          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   4104          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   4105          
   4106          #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
   4107              if (ssl->conf->f_async_cancel != NULL && handshake->async_in_progress != 0) {
   4108                  ssl->conf->f_async_cancel(ssl);
   4109                  handshake->async_in_progress = 0;
   4110              }
   4111          #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
   4112          
   4113          #if defined(MBEDTLS_MD_CAN_SHA256)
   4114          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   4115              psa_hash_abort(&handshake->fin_sha256_psa);
   \       0x2C   0xF104 0x00EC      ADD      R0,R4,#+236
   \       0x30   0x.... 0x....      BL       psa_hash_abort
   4116          #else
   4117              mbedtls_md_free(&handshake->fin_sha256);
   4118          #endif
   4119          #endif
   4120          #if defined(MBEDTLS_MD_CAN_SHA384)
   4121          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   4122              psa_hash_abort(&handshake->fin_sha384_psa);
   4123          #else
   4124              mbedtls_md_free(&handshake->fin_sha384);
   4125          #endif
   4126          #endif
   4127          
   4128          #if defined(MBEDTLS_DHM_C)
   4129              mbedtls_dhm_free(&handshake->dhm_ctx);
   4130          #endif
   4131          #if !defined(MBEDTLS_USE_PSA_CRYPTO) && \
   4132              defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_1_2_ENABLED)
   4133              mbedtls_ecdh_free(&handshake->ecdh_ctx);
   4134          #endif
   4135          
   4136          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   4137          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   4138              psa_pake_abort(&handshake->psa_pake_ctx);
   4139              /*
   4140               * Opaque keys are not stored in the handshake's data and it's the user
   4141               * responsibility to destroy them. Clear ones, instead, are created by
   4142               * the TLS library and should be destroyed at the same level
   4143               */
   4144              if (!mbedtls_svc_key_id_is_null(handshake->psa_pake_password)) {
   4145                  psa_destroy_key(handshake->psa_pake_password);
   4146              }
   4147              handshake->psa_pake_password = MBEDTLS_SVC_KEY_ID_INIT;
   4148          #else
   4149              mbedtls_ecjpake_free(&handshake->ecjpake_ctx);
   4150          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   4151          #if defined(MBEDTLS_SSL_CLI_C)
   4152              mbedtls_free(handshake->ecjpake_cache);
   4153              handshake->ecjpake_cache = NULL;
   4154              handshake->ecjpake_cache_len = 0;
   4155          #endif
   4156          #endif
   4157          
   4158          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_ECDH_OR_ECDHE_ANY_ENABLED) || \
   4159              defined(MBEDTLS_KEY_EXCHANGE_WITH_ECDSA_ANY_ENABLED) || \
   4160              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   4161              /* explicit void pointer cast for buggy MS compiler */
   4162              mbedtls_free((void *) handshake->curves_tls_id);
   \       0x34   0x6DE8             LDR      R0,[R5, #+92]
   \       0x36   0x.... 0x....      BL       sl_free
   4163          #endif
   4164          
   4165          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_PSK_ENABLED)
   4166          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   4167              if (!mbedtls_svc_key_id_is_null(ssl->handshake->psk_opaque)) {
   4168                  /* The maintenance of the external PSK key slot is the
   4169                   * user's responsibility. */
   4170                  if (ssl->handshake->psk_opaque_is_internal) {
   4171                      psa_destroy_key(ssl->handshake->psk_opaque);
   4172                      ssl->handshake->psk_opaque_is_internal = 0;
   4173                  }
   4174                  ssl->handshake->psk_opaque = MBEDTLS_SVC_KEY_ID_INIT;
   4175              }
   4176          #else
   4177              if (handshake->psk != NULL) {
   4178                  mbedtls_zeroize_and_free(handshake->psk, handshake->psk_len);
   4179              }
   4180          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   4181          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_PSK_ENABLED */
   4182          
   4183          #if defined(MBEDTLS_X509_CRT_PARSE_C) && \
   4184              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   4185              /*
   4186               * Free only the linked list wrapper, not the keys themselves
   4187               * since the belong to the SNI callback
   4188               */
   4189              ssl_key_cert_free(handshake->sni_key_cert);
   4190          #endif /* MBEDTLS_X509_CRT_PARSE_C && MBEDTLS_SSL_SERVER_NAME_INDICATION */
   4191          
   4192          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   4193              mbedtls_x509_crt_restart_free(&handshake->ecrs_ctx);
   4194              if (handshake->ecrs_peer_cert != NULL) {
   4195                  mbedtls_x509_crt_free(handshake->ecrs_peer_cert);
   4196                  mbedtls_free(handshake->ecrs_peer_cert);
   4197              }
   4198          #endif
   4199          
   4200          #if defined(MBEDTLS_X509_CRT_PARSE_C) &&        \
   4201              !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   4202              mbedtls_pk_free(&handshake->peer_pubkey);
   4203          #endif /* MBEDTLS_X509_CRT_PARSE_C && !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   4204          
   4205          #if defined(MBEDTLS_SSL_CLI_C) && \
   4206              (defined(MBEDTLS_SSL_PROTO_DTLS) || defined(MBEDTLS_SSL_PROTO_TLS1_3))
   4207              mbedtls_free(handshake->cookie);
   4208          #endif /* MBEDTLS_SSL_CLI_C &&
   4209                    ( MBEDTLS_SSL_PROTO_DTLS || MBEDTLS_SSL_PROTO_TLS1_3 ) */
   4210          
   4211          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4212              mbedtls_ssl_flight_free(handshake->flight);
   4213              mbedtls_ssl_buffering_free(ssl);
   4214          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4215          
   4216          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_XXDH_PSA_ANY_ENABLED)
   4217              if (handshake->xxdh_psa_privkey_is_external == 0) {
   \       0x3A   0x7D28             LDRB     R0,[R5, #+20]
   \       0x3C   0xB910             CBNZ.N   R0,??mbedtls_ssl_handshake_free_3
   4218                  psa_destroy_key(handshake->xxdh_psa_privkey);
   \       0x3E   0x6928             LDR      R0,[R5, #+16]
   \       0x40   0x.... 0x....      BL       psa_destroy_key
   4219              }
   4220          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_XXDH_PSA_ANY_ENABLED */
   4221          
   4222          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   4223              mbedtls_ssl_transform_free(handshake->transform_handshake);
   4224              mbedtls_free(handshake->transform_handshake);
   4225          #if defined(MBEDTLS_SSL_EARLY_DATA)
   4226              mbedtls_ssl_transform_free(handshake->transform_earlydata);
   4227              mbedtls_free(handshake->transform_earlydata);
   4228          #endif
   4229          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   4230          
   4231          
   4232          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   4233              /* If the buffers are too big - reallocate. Because of the way Mbed TLS
   4234               * processes datagrams and the fact that a datagram is allowed to have
   4235               * several records in it, it is possible that the I/O buffers are not
   4236               * empty at this stage */
   4237              handle_buffer_resizing(ssl, 1, mbedtls_ssl_get_input_buflen(ssl),
   4238                                     mbedtls_ssl_get_output_buflen(ssl));
   4239          #endif
   4240          
   4241              /* mbedtls_platform_zeroize MUST be last one in this function */
   4242              mbedtls_platform_zeroize(handshake,
   4243                                       sizeof(mbedtls_ssl_handshake_params));
   \                     ??mbedtls_ssl_handshake_free_3: (+1)
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0xF44F 0x7117      MOV      R1,#+604
   \       0x4A   0x....             B.N      ?Subroutine8
   \                     ??mbedtls_ssl_handshake_free_0: (+1)
   \       0x4C   0xBD70             POP      {R4-R6,PC}
   4244          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0xE8BD 0x4070      POP      {R4-R6,LR}
   \        0x4   0x.... 0x....      B.W      mbedtls_platform_zeroize
   4245          

   \                                 In section .text, align 2, keep-with-next
   4246          void mbedtls_ssl_session_free(mbedtls_ssl_session *session)
   4247          {
   \                     mbedtls_ssl_session_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4248              if (session == NULL) {
   \        0x4   0xD002             BEQ.N    ??mbedtls_ssl_session_free_0
   4249                  return;
   4250              }
   4251          
   4252          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   4253              ssl_clear_peer_cert(session);
   \        0x6   0x.... 0x....      BL       ssl_clear_peer_cert
   4254          #endif
   4255          
   4256          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   4257          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
   4258              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   4259              mbedtls_free(session->hostname);
   4260          #endif
   4261              mbedtls_free(session->ticket);
   4262          #endif
   4263          
   4264              mbedtls_platform_zeroize(session, sizeof(mbedtls_ssl_session));
   \        0xA   0x....             B.N      ?Subroutine7
   \                     ??mbedtls_ssl_session_free_0: (+1)
   \        0xC   0xBD10             POP      {R4,PC}
   4265          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x2164             MOVS     R1,#+100
   \        0x4   0xE8BD 0x4010      POP      {R4,LR}
   \        0x8   0x.... 0x....      B.W      mbedtls_platform_zeroize
   4266          
   4267          #if defined(MBEDTLS_SSL_CONTEXT_SERIALIZATION)
   4268          
   4269          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4270          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_CONNECTION_ID 1u
   4271          #else
   4272          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_CONNECTION_ID 0u
   4273          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4274          
   4275          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_BADMAC_LIMIT 1u
   4276          
   4277          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   4278          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_ANTI_REPLAY 1u
   4279          #else
   4280          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_ANTI_REPLAY 0u
   4281          #endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */
   4282          
   4283          #if defined(MBEDTLS_SSL_ALPN)
   4284          #define SSL_SERIALIZED_CONTEXT_CONFIG_ALPN 1u
   4285          #else
   4286          #define SSL_SERIALIZED_CONTEXT_CONFIG_ALPN 0u
   4287          #endif /* MBEDTLS_SSL_ALPN */
   4288          
   4289          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_CONNECTION_ID_BIT    0
   4290          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_BADMAC_LIMIT_BIT     1
   4291          #define SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_ANTI_REPLAY_BIT      2
   4292          #define SSL_SERIALIZED_CONTEXT_CONFIG_ALPN_BIT                  3
   4293          
   4294          #define SSL_SERIALIZED_CONTEXT_CONFIG_BITFLAG   \
   4295              ((uint32_t) (                              \
   4296                   (SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_CONNECTION_ID << \
   4297                       SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_CONNECTION_ID_BIT) | \
   4298                   (SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_BADMAC_LIMIT << \
   4299                       SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_BADMAC_LIMIT_BIT) | \
   4300                   (SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_ANTI_REPLAY << \
   4301                       SSL_SERIALIZED_CONTEXT_CONFIG_DTLS_ANTI_REPLAY_BIT) | \
   4302                   (SSL_SERIALIZED_CONTEXT_CONFIG_ALPN << SSL_SERIALIZED_CONTEXT_CONFIG_ALPN_BIT) | \
   4303                   0u))
   4304          
   4305          static unsigned char ssl_serialized_context_header[] = {
   4306              MBEDTLS_VERSION_MAJOR,
   4307              MBEDTLS_VERSION_MINOR,
   4308              MBEDTLS_VERSION_PATCH,
   4309              MBEDTLS_BYTE_1(SSL_SERIALIZED_SESSION_CONFIG_BITFLAG),
   4310              MBEDTLS_BYTE_0(SSL_SERIALIZED_SESSION_CONFIG_BITFLAG),
   4311              MBEDTLS_BYTE_2(SSL_SERIALIZED_CONTEXT_CONFIG_BITFLAG),
   4312              MBEDTLS_BYTE_1(SSL_SERIALIZED_CONTEXT_CONFIG_BITFLAG),
   4313              MBEDTLS_BYTE_0(SSL_SERIALIZED_CONTEXT_CONFIG_BITFLAG),
   4314          };
   4315          
   4316          /*
   4317           * Serialize a full SSL context
   4318           *
   4319           * The format of the serialized data is:
   4320           * (in the presentation language of TLS, RFC 8446 section 3)
   4321           *
   4322           *  // header
   4323           *  opaque mbedtls_version[3];   // major, minor, patch
   4324           *  opaque context_format[5];    // version-specific field determining
   4325           *                               // the format of the remaining
   4326           *                               // serialized data.
   4327           *  Note: When updating the format, remember to keep these
   4328           *        version+format bytes. (We may make their size part of the API.)
   4329           *
   4330           *  // session sub-structure
   4331           *  opaque session<1..2^32-1>;  // see mbedtls_ssl_session_save()
   4332           *  // transform sub-structure
   4333           *  uint8 random[64];           // ServerHello.random+ClientHello.random
   4334           *  uint8 in_cid<0..2^8-1>      // Connection ID: expected incoming value
   4335           *  uint8 out_cid<0..2^8-1>     // Connection ID: outgoing value to use
   4336           *  // fields from ssl_context
   4337           *  uint32 badmac_seen;         // DTLS: number of records with failing MAC
   4338           *  uint64 in_window_top;       // DTLS: last validated record seq_num
   4339           *  uint64 in_window;           // DTLS: bitmask for replay protection
   4340           *  uint8 disable_datagram_packing; // DTLS: only one record per datagram
   4341           *  uint64 cur_out_ctr;         // Record layer: outgoing sequence number
   4342           *  uint16 mtu;                 // DTLS: path mtu (max outgoing fragment size)
   4343           *  uint8 alpn_chosen<0..2^8-1> // ALPN: negotiated application protocol
   4344           *
   4345           * Note that many fields of the ssl_context or sub-structures are not
   4346           * serialized, as they fall in one of the following categories:
   4347           *
   4348           *  1. forced value (eg in_left must be 0)
   4349           *  2. pointer to dynamically-allocated memory (eg session, transform)
   4350           *  3. value can be re-derived from other data (eg session keys from MS)
   4351           *  4. value was temporary (eg content of input buffer)
   4352           *  5. value will be provided by the user again (eg I/O callbacks and context)
   4353           */
   4354          int mbedtls_ssl_context_save(mbedtls_ssl_context *ssl,
   4355                                       unsigned char *buf,
   4356                                       size_t buf_len,
   4357                                       size_t *olen)
   4358          {
   4359              unsigned char *p = buf;
   4360              size_t used = 0;
   4361              size_t session_len;
   4362              int ret = 0;
   4363          
   4364              /*
   4365               * Enforce usage restrictions, see "return BAD_INPUT_DATA" in
   4366               * this function's documentation.
   4367               *
   4368               * These are due to assumptions/limitations in the implementation. Some of
   4369               * them are likely to stay (no handshake in progress) some might go away
   4370               * (only DTLS) but are currently used to simplify the implementation.
   4371               */
   4372              /* The initial handshake must be over */
   4373              if (mbedtls_ssl_is_handshake_over(ssl) == 0) {
   4374                  MBEDTLS_SSL_DEBUG_MSG(1, ("Initial handshake isn't over"));
   4375                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4376              }
   4377              if (ssl->handshake != NULL) {
   4378                  MBEDTLS_SSL_DEBUG_MSG(1, ("Handshake isn't completed"));
   4379                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4380              }
   4381              /* Double-check that sub-structures are indeed ready */
   4382              if (ssl->transform == NULL || ssl->session == NULL) {
   4383                  MBEDTLS_SSL_DEBUG_MSG(1, ("Serialised structures aren't ready"));
   4384                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4385              }
   4386              /* There must be no pending incoming or outgoing data */
   4387              if (mbedtls_ssl_check_pending(ssl) != 0) {
   4388                  MBEDTLS_SSL_DEBUG_MSG(1, ("There is pending incoming data"));
   4389                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4390              }
   4391              if (ssl->out_left != 0) {
   4392                  MBEDTLS_SSL_DEBUG_MSG(1, ("There is pending outgoing data"));
   4393                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4394              }
   4395              /* Protocol must be DTLS, not TLS */
   4396              if (ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   4397                  MBEDTLS_SSL_DEBUG_MSG(1, ("Only DTLS is supported"));
   4398                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4399              }
   4400              /* Version must be 1.2 */
   4401              if (ssl->tls_version != MBEDTLS_SSL_VERSION_TLS1_2) {
   4402                  MBEDTLS_SSL_DEBUG_MSG(1, ("Only version 1.2 supported"));
   4403                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4404              }
   4405              /* We must be using an AEAD ciphersuite */
   4406              if (mbedtls_ssl_transform_uses_aead(ssl->transform) != 1) {
   4407                  MBEDTLS_SSL_DEBUG_MSG(1, ("Only AEAD ciphersuites supported"));
   4408                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4409              }
   4410              /* Renegotiation must not be enabled */
   4411          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   4412              if (ssl->conf->disable_renegotiation != MBEDTLS_SSL_RENEGOTIATION_DISABLED) {
   4413                  MBEDTLS_SSL_DEBUG_MSG(1, ("Renegotiation must not be enabled"));
   4414                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4415              }
   4416          #endif
   4417          
   4418              /*
   4419               * Version and format identifier
   4420               */
   4421              used += sizeof(ssl_serialized_context_header);
   4422          
   4423              if (used <= buf_len) {
   4424                  memcpy(p, ssl_serialized_context_header,
   4425                         sizeof(ssl_serialized_context_header));
   4426                  p += sizeof(ssl_serialized_context_header);
   4427              }
   4428          
   4429              /*
   4430               * Session (length + data)
   4431               */
   4432              ret = ssl_session_save(ssl->session, 1, NULL, 0, &session_len);
   4433              if (ret != MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) {
   4434                  return ret;
   4435              }
   4436          
   4437              used += 4 + session_len;
   4438              if (used <= buf_len) {
   4439                  MBEDTLS_PUT_UINT32_BE(session_len, p, 0);
   4440                  p += 4;
   4441          
   4442                  ret = ssl_session_save(ssl->session, 1,
   4443                                         p, session_len, &session_len);
   4444                  if (ret != 0) {
   4445                      return ret;
   4446                  }
   4447          
   4448                  p += session_len;
   4449              }
   4450          
   4451              /*
   4452               * Transform
   4453               */
   4454              used += sizeof(ssl->transform->randbytes);
   4455              if (used <= buf_len) {
   4456                  memcpy(p, ssl->transform->randbytes,
   4457                         sizeof(ssl->transform->randbytes));
   4458                  p += sizeof(ssl->transform->randbytes);
   4459              }
   4460          
   4461          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4462              used += 2 + ssl->transform->in_cid_len + ssl->transform->out_cid_len;
   4463              if (used <= buf_len) {
   4464                  *p++ = ssl->transform->in_cid_len;
   4465                  memcpy(p, ssl->transform->in_cid, ssl->transform->in_cid_len);
   4466                  p += ssl->transform->in_cid_len;
   4467          
   4468                  *p++ = ssl->transform->out_cid_len;
   4469                  memcpy(p, ssl->transform->out_cid, ssl->transform->out_cid_len);
   4470                  p += ssl->transform->out_cid_len;
   4471              }
   4472          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4473          
   4474              /*
   4475               * Saved fields from top-level ssl_context structure
   4476               */
   4477              used += 4;
   4478              if (used <= buf_len) {
   4479                  MBEDTLS_PUT_UINT32_BE(ssl->badmac_seen, p, 0);
   4480                  p += 4;
   4481              }
   4482          
   4483          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   4484              used += 16;
   4485              if (used <= buf_len) {
   4486                  MBEDTLS_PUT_UINT64_BE(ssl->in_window_top, p, 0);
   4487                  p += 8;
   4488          
   4489                  MBEDTLS_PUT_UINT64_BE(ssl->in_window, p, 0);
   4490                  p += 8;
   4491              }
   4492          #endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */
   4493          
   4494          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4495              used += 1;
   4496              if (used <= buf_len) {
   4497                  *p++ = ssl->disable_datagram_packing;
   4498              }
   4499          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4500          
   4501              used += MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   4502              if (used <= buf_len) {
   4503                  memcpy(p, ssl->cur_out_ctr, MBEDTLS_SSL_SEQUENCE_NUMBER_LEN);
   4504                  p += MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
   4505              }
   4506          
   4507          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4508              used += 2;
   4509              if (used <= buf_len) {
   4510                  MBEDTLS_PUT_UINT16_BE(ssl->mtu, p, 0);
   4511                  p += 2;
   4512              }
   4513          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4514          
   4515          #if defined(MBEDTLS_SSL_ALPN)
   4516              {
   4517                  const uint8_t alpn_len = ssl->alpn_chosen
   4518                                         ? (uint8_t) strlen(ssl->alpn_chosen)
   4519                                         : 0;
   4520          
   4521                  used += 1 + alpn_len;
   4522                  if (used <= buf_len) {
   4523                      *p++ = alpn_len;
   4524          
   4525                      if (ssl->alpn_chosen != NULL) {
   4526                          memcpy(p, ssl->alpn_chosen, alpn_len);
   4527                          p += alpn_len;
   4528                      }
   4529                  }
   4530              }
   4531          #endif /* MBEDTLS_SSL_ALPN */
   4532          
   4533              /*
   4534               * Done
   4535               */
   4536              *olen = used;
   4537          
   4538              if (used > buf_len) {
   4539                  return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   4540              }
   4541          
   4542              MBEDTLS_SSL_DEBUG_BUF(4, "saved context", buf, used);
   4543          
   4544              return mbedtls_ssl_session_reset_int(ssl, 0);
   4545          }
   4546          
   4547          /*
   4548           * Deserialize context, see mbedtls_ssl_context_save() for format.
   4549           *
   4550           * This internal version is wrapped by a public function that cleans up in
   4551           * case of error.
   4552           */
   4553          MBEDTLS_CHECK_RETURN_CRITICAL
   4554          static int ssl_context_load(mbedtls_ssl_context *ssl,
   4555                                      const unsigned char *buf,
   4556                                      size_t len)
   4557          {
   4558              const unsigned char *p = buf;
   4559              const unsigned char * const end = buf + len;
   4560              size_t session_len;
   4561              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   4562          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   4563              tls_prf_fn prf_func = NULL;
   4564          #endif
   4565          
   4566              /*
   4567               * The context should have been freshly setup or reset.
   4568               * Give the user an error in case of obvious misuse.
   4569               * (Checking session is useful because it won't be NULL if we're
   4570               * renegotiating, or if the user mistakenly loaded a session first.)
   4571               */
   4572              if (ssl->state != MBEDTLS_SSL_HELLO_REQUEST ||
   4573                  ssl->session != NULL) {
   4574                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4575              }
   4576          
   4577              /*
   4578               * We can't check that the config matches the initial one, but we can at
   4579               * least check it matches the requirements for serializing.
   4580               */
   4581              if (
   4582          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   4583                  ssl->conf->disable_renegotiation != MBEDTLS_SSL_RENEGOTIATION_DISABLED ||
   4584          #endif
   4585                  ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM ||
   4586                  ssl->conf->max_tls_version < MBEDTLS_SSL_VERSION_TLS1_2 ||
   4587                  ssl->conf->min_tls_version > MBEDTLS_SSL_VERSION_TLS1_2
   4588                  ) {
   4589                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4590              }
   4591          
   4592              MBEDTLS_SSL_DEBUG_BUF(4, "context to load", buf, len);
   4593          
   4594              /*
   4595               * Check version identifier
   4596               */
   4597              if ((size_t) (end - p) < sizeof(ssl_serialized_context_header)) {
   4598                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4599              }
   4600          
   4601              if (memcmp(p, ssl_serialized_context_header,
   4602                         sizeof(ssl_serialized_context_header)) != 0) {
   4603                  return MBEDTLS_ERR_SSL_VERSION_MISMATCH;
   4604              }
   4605              p += sizeof(ssl_serialized_context_header);
   4606          
   4607              /*
   4608               * Session
   4609               */
   4610              if ((size_t) (end - p) < 4) {
   4611                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4612              }
   4613          
   4614              session_len = MBEDTLS_GET_UINT32_BE(p, 0);
   4615              p += 4;
   4616          
   4617              /* This has been allocated by ssl_handshake_init(), called by
   4618               * by either mbedtls_ssl_session_reset_int() or mbedtls_ssl_setup(). */
   4619              ssl->session = ssl->session_negotiate;
   4620              ssl->session_in = ssl->session;
   4621              ssl->session_out = ssl->session;
   4622              ssl->session_negotiate = NULL;
   4623          
   4624              if ((size_t) (end - p) < session_len) {
   4625                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4626              }
   4627          
   4628              ret = ssl_session_load(ssl->session, 1, p, session_len);
   4629              if (ret != 0) {
   4630                  mbedtls_ssl_session_free(ssl->session);
   4631                  return ret;
   4632              }
   4633          
   4634              p += session_len;
   4635          
   4636              /*
   4637               * Transform
   4638               */
   4639          
   4640              /* This has been allocated by ssl_handshake_init(), called by
   4641               * by either mbedtls_ssl_session_reset_int() or mbedtls_ssl_setup(). */
   4642          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   4643              ssl->transform = ssl->transform_negotiate;
   4644              ssl->transform_in = ssl->transform;
   4645              ssl->transform_out = ssl->transform;
   4646              ssl->transform_negotiate = NULL;
   4647          #endif
   4648          
   4649          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   4650              prf_func = ssl_tls12prf_from_cs(ssl->session->ciphersuite);
   4651              if (prf_func == NULL) {
   4652                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4653              }
   4654          
   4655              /* Read random bytes and populate structure */
   4656              if ((size_t) (end - p) < sizeof(ssl->transform->randbytes)) {
   4657                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4658              }
   4659          
   4660              ret = ssl_tls12_populate_transform(ssl->transform,
   4661                                                 ssl->session->ciphersuite,
   4662                                                 ssl->session->master,
   4663          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   4664                                                 ssl->session->encrypt_then_mac,
   4665          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   4666                                                 prf_func,
   4667                                                 p, /* currently pointing to randbytes */
   4668                                                 MBEDTLS_SSL_VERSION_TLS1_2, /* (D)TLS 1.2 is forced */
   4669                                                 ssl->conf->endpoint,
   4670                                                 ssl);
   4671              if (ret != 0) {
   4672                  return ret;
   4673              }
   4674          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   4675              p += sizeof(ssl->transform->randbytes);
   4676          
   4677          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   4678              /* Read connection IDs and store them */
   4679              if ((size_t) (end - p) < 1) {
   4680                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4681              }
   4682          
   4683              ssl->transform->in_cid_len = *p++;
   4684          
   4685              if ((size_t) (end - p) < ssl->transform->in_cid_len + 1u) {
   4686                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4687              }
   4688          
   4689              memcpy(ssl->transform->in_cid, p, ssl->transform->in_cid_len);
   4690              p += ssl->transform->in_cid_len;
   4691          
   4692              ssl->transform->out_cid_len = *p++;
   4693          
   4694              if ((size_t) (end - p) < ssl->transform->out_cid_len) {
   4695                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4696              }
   4697          
   4698              memcpy(ssl->transform->out_cid, p, ssl->transform->out_cid_len);
   4699              p += ssl->transform->out_cid_len;
   4700          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   4701          
   4702              /*
   4703               * Saved fields from top-level ssl_context structure
   4704               */
   4705              if ((size_t) (end - p) < 4) {
   4706                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4707              }
   4708          
   4709              ssl->badmac_seen = MBEDTLS_GET_UINT32_BE(p, 0);
   4710              p += 4;
   4711          
   4712          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   4713              if ((size_t) (end - p) < 16) {
   4714                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4715              }
   4716          
   4717              ssl->in_window_top = MBEDTLS_GET_UINT64_BE(p, 0);
   4718              p += 8;
   4719          
   4720              ssl->in_window = MBEDTLS_GET_UINT64_BE(p, 0);
   4721              p += 8;
   4722          #endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */
   4723          
   4724          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4725              if ((size_t) (end - p) < 1) {
   4726                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4727              }
   4728          
   4729              ssl->disable_datagram_packing = *p++;
   4730          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4731          
   4732              if ((size_t) (end - p) < sizeof(ssl->cur_out_ctr)) {
   4733                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4734              }
   4735              memcpy(ssl->cur_out_ctr, p, sizeof(ssl->cur_out_ctr));
   4736              p += sizeof(ssl->cur_out_ctr);
   4737          
   4738          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4739              if ((size_t) (end - p) < 2) {
   4740                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4741              }
   4742          
   4743              ssl->mtu = (p[0] << 8) | p[1];
   4744              p += 2;
   4745          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4746          
   4747          #if defined(MBEDTLS_SSL_ALPN)
   4748              {
   4749                  uint8_t alpn_len;
   4750                  const char **cur;
   4751          
   4752                  if ((size_t) (end - p) < 1) {
   4753                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4754                  }
   4755          
   4756                  alpn_len = *p++;
   4757          
   4758                  if (alpn_len != 0 && ssl->conf->alpn_list != NULL) {
   4759                      /* alpn_chosen should point to an item in the configured list */
   4760                      for (cur = ssl->conf->alpn_list; *cur != NULL; cur++) {
   4761                          if (strlen(*cur) == alpn_len &&
   4762                              memcmp(p, cur, alpn_len) == 0) {
   4763                              ssl->alpn_chosen = *cur;
   4764                              break;
   4765                          }
   4766                      }
   4767                  }
   4768          
   4769                  /* can only happen on conf mismatch */
   4770                  if (alpn_len != 0 && ssl->alpn_chosen == NULL) {
   4771                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4772                  }
   4773          
   4774                  p += alpn_len;
   4775              }
   4776          #endif /* MBEDTLS_SSL_ALPN */
   4777          
   4778              /*
   4779               * Forced fields from top-level ssl_context structure
   4780               *
   4781               * Most of them already set to the correct value by mbedtls_ssl_init() and
   4782               * mbedtls_ssl_reset(), so we only need to set the remaining ones.
   4783               */
   4784              ssl->state = MBEDTLS_SSL_HANDSHAKE_OVER;
   4785              ssl->tls_version = MBEDTLS_SSL_VERSION_TLS1_2;
   4786          
   4787              /* Adjust pointers for header fields of outgoing records to
   4788               * the given transform, accounting for explicit IV and CID. */
   4789              mbedtls_ssl_update_out_pointers(ssl, ssl->transform);
   4790          
   4791          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4792              ssl->in_epoch = 1;
   4793          #endif
   4794          
   4795              /* mbedtls_ssl_reset() leaves the handshake sub-structure allocated,
   4796               * which we don't want - otherwise we'd end up freeing the wrong transform
   4797               * by calling mbedtls_ssl_handshake_wrapup_free_hs_transform()
   4798               * inappropriately. */
   4799              if (ssl->handshake != NULL) {
   4800                  mbedtls_ssl_handshake_free(ssl);
   4801                  mbedtls_free(ssl->handshake);
   4802                  ssl->handshake = NULL;
   4803              }
   4804          
   4805              /*
   4806               * Done - should have consumed entire buffer
   4807               */
   4808              if (p != end) {
   4809                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   4810              }
   4811          
   4812              return 0;
   4813          }
   4814          
   4815          /*
   4816           * Deserialize context: public wrapper for error cleaning
   4817           */
   4818          int mbedtls_ssl_context_load(mbedtls_ssl_context *context,
   4819                                       const unsigned char *buf,
   4820                                       size_t len)
   4821          {
   4822              int ret = ssl_context_load(context, buf, len);
   4823          
   4824              if (ret != 0) {
   4825                  mbedtls_ssl_free(context);
   4826              }
   4827          
   4828              return ret;
   4829          }
   4830          #endif /* MBEDTLS_SSL_CONTEXT_SERIALIZATION */
   4831          
   4832          /*
   4833           * Free an SSL context
   4834           */

   \                                 In section .text, align 2, keep-with-next
   4835          void mbedtls_ssl_free(mbedtls_ssl_context *ssl)
   4836          {
   \                     mbedtls_ssl_free: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4837              if (ssl == NULL) {
   \        0x4   0xD03F             BEQ.N    ??mbedtls_ssl_free_0
   4838                  return;
   4839              }
   4840          
   4841              MBEDTLS_SSL_DEBUG_MSG(2, ("=> free"));
   4842          
   4843              if (ssl->out_buf != NULL) {
   \        0x6   0xF104 0x0594      ADD      R5,R4,#+148
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0xF240 0x463D      MOVW     R6,#+1085
   \       0x10   0xB120             CBZ.N    R0,??mbedtls_ssl_free_1
   4844          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   4845                  size_t out_buf_len = ssl->out_buf_len;
   4846          #else
   4847                  size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN;
   4848          #endif
   4849          
   4850                  mbedtls_zeroize_and_free(ssl->out_buf, out_buf_len);
   \       0x12   0x4631             MOV      R1,R6
   \       0x14   0x.... 0x....      BL       mbedtls_zeroize_and_free
   4851                  ssl->out_buf = NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6028             STR      R0,[R5, #+0]
   4852              }
   4853          
   4854              if (ssl->in_buf != NULL) {
   \                     ??mbedtls_ssl_free_1: (+1)
   \       0x1C   0x6DA0             LDR      R0,[R4, #+88]
   \       0x1E   0xB120             CBZ.N    R0,??mbedtls_ssl_free_2
   4855          #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
   4856                  size_t in_buf_len = ssl->in_buf_len;
   4857          #else
   4858                  size_t in_buf_len = MBEDTLS_SSL_IN_BUFFER_LEN;
   4859          #endif
   4860          
   4861                  mbedtls_zeroize_and_free(ssl->in_buf, in_buf_len);
   \       0x20   0x4631             MOV      R1,R6
   \       0x22   0x.... 0x....      BL       mbedtls_zeroize_and_free
   4862                  ssl->in_buf = NULL;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x65A0             STR      R0,[R4, #+88]
   4863              }
   4864          
   4865              if (ssl->transform) {
   \                     ??mbedtls_ssl_free_2: (+1)
   \       0x2A   0x6C60             LDR      R0,[R4, #+68]
   \       0x2C   0xB120             CBZ.N    R0,??mbedtls_ssl_free_3
   4866                  mbedtls_ssl_transform_free(ssl->transform);
   \       0x2E   0x.... 0x....      BL       mbedtls_ssl_transform_free
   4867                  mbedtls_free(ssl->transform);
   \       0x32   0x6C60             LDR      R0,[R4, #+68]
   \       0x34   0x.... 0x....      BL       sl_free
   4868              }
   4869          
   4870              if (ssl->handshake) {
   \                     ??mbedtls_ssl_free_3: (+1)
   \       0x38   0x6BA0             LDR      R0,[R4, #+56]
   \       0x3A   0xB188             CBZ.N    R0,??mbedtls_ssl_free_4
   4871                  mbedtls_ssl_handshake_free(ssl);
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       mbedtls_ssl_handshake_free
   4872                  mbedtls_free(ssl->handshake);
   \       0x42   0x6BA0             LDR      R0,[R4, #+56]
   \       0x44   0x.... 0x....      BL       sl_free
   4873          
   4874          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   4875                  mbedtls_ssl_transform_free(ssl->transform_negotiate);
   \       0x48   0x6CA0             LDR      R0,[R4, #+72]
   \       0x4A   0x.... 0x....      BL       mbedtls_ssl_transform_free
   4876                  mbedtls_free(ssl->transform_negotiate);
   \       0x4E   0x6CA0             LDR      R0,[R4, #+72]
   \       0x50   0x.... 0x....      BL       sl_free
   4877          #endif
   4878          
   4879                  mbedtls_ssl_session_free(ssl->session_negotiate);
   \       0x54   0x6B60             LDR      R0,[R4, #+52]
   \       0x56   0x.... 0x....      BL       mbedtls_ssl_session_free
   4880                  mbedtls_free(ssl->session_negotiate);
   \       0x5A   0x6B60             LDR      R0,[R4, #+52]
   \       0x5C   0x.... 0x....      BL       sl_free
   4881              }
   4882          
   4883          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   4884              mbedtls_ssl_transform_free(ssl->transform_application);
   4885              mbedtls_free(ssl->transform_application);
   4886          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   4887          
   4888              if (ssl->session) {
   \                     ??mbedtls_ssl_free_4: (+1)
   \       0x60   0x6B20             LDR      R0,[R4, #+48]
   \       0x62   0xB120             CBZ.N    R0,??mbedtls_ssl_free_5
   4889                  mbedtls_ssl_session_free(ssl->session);
   \       0x64   0x.... 0x....      BL       mbedtls_ssl_session_free
   4890                  mbedtls_free(ssl->session);
   \       0x68   0x6B20             LDR      R0,[R4, #+48]
   \       0x6A   0x.... 0x....      BL       sl_free
   4891              }
   4892          
   4893          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   4894              if (ssl->hostname != NULL) {
   \                     ??mbedtls_ssl_free_5: (+1)
   \       0x6E   0x6AED             LDR      R5,[R5, #+44]
   \       0x70   0xB135             CBZ.N    R5,??mbedtls_ssl_free_6
   4895                  mbedtls_zeroize_and_free(ssl->hostname, strlen(ssl->hostname));
   \       0x72   0x4628             MOV      R0,R5
   \       0x74   0x.... 0x....      BL       strlen
   \       0x78   0x4601             MOV      R1,R0
   \       0x7A   0x4628             MOV      R0,R5
   \       0x7C   0x.... 0x....      BL       mbedtls_zeroize_and_free
   4896              }
   4897          #endif
   4898          
   4899          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   4900              mbedtls_free(ssl->cli_id);
   4901          #endif
   4902          
   4903              MBEDTLS_SSL_DEBUG_MSG(2, ("<= free"));
   4904          
   4905              /* Actually clear after last debug message */
   4906              mbedtls_platform_zeroize(ssl, sizeof(mbedtls_ssl_context));
   \                     ??mbedtls_ssl_free_6: (+1)
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0x21D4             MOVS     R1,#+212
   \       0x84   0x....             B.N      ?Subroutine8
   \                     ??mbedtls_ssl_free_0: (+1)
   \       0x86   0xBD70             POP      {R4-R6,PC}
   4907          }
   4908          
   4909          /*
   4910           * Initialize mbedtls_ssl_config
   4911           */

   \                                 In section .text, align 4, keep-with-next
   4912          void mbedtls_ssl_config_init(mbedtls_ssl_config *conf)
   4913          {
   4914              memset(conf, 0, sizeof(mbedtls_ssl_config));
   \                     mbedtls_ssl_config_init: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine6
   \        0x2                      ;; // Fall through to label ?Subroutine6
   4915          }
   4916          
   4917          /* The selection should be the same as mbedtls_x509_crt_profile_default in
   4918           * x509_crt.c, plus Montgomery curves for ECDHE. Here, the order matters:
   4919           * curves with a lower resource usage come first.
   4920           * See the documentation of mbedtls_ssl_conf_curves() for what we promise
   4921           * about this list.
   4922           */
   4923          static uint16_t ssl_preset_default_groups[] = {
   4924          #if defined(MBEDTLS_ECP_HAVE_CURVE25519)
   4925              MBEDTLS_SSL_IANA_TLS_GROUP_X25519,
   4926          #endif
   4927          #if defined(MBEDTLS_ECP_HAVE_SECP256R1)
   4928              MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1,
   4929          #endif
   4930          #if defined(MBEDTLS_ECP_HAVE_SECP384R1)
   4931              MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1,
   4932          #endif
   4933          #if defined(MBEDTLS_ECP_HAVE_CURVE448)
   4934              MBEDTLS_SSL_IANA_TLS_GROUP_X448,
   4935          #endif
   4936          #if defined(MBEDTLS_ECP_HAVE_SECP521R1)
   4937              MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1,
   4938          #endif
   4939          #if defined(MBEDTLS_ECP_HAVE_BP256R1)
   4940              MBEDTLS_SSL_IANA_TLS_GROUP_BP256R1,
   4941          #endif
   4942          #if defined(MBEDTLS_ECP_HAVE_BP384R1)
   4943              MBEDTLS_SSL_IANA_TLS_GROUP_BP384R1,
   4944          #endif
   4945          #if defined(MBEDTLS_ECP_HAVE_BP512R1)
   4946              MBEDTLS_SSL_IANA_TLS_GROUP_BP512R1,
   4947          #endif
   4948          #if defined(PSA_WANT_ALG_FFDH)
   4949              MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE2048,
   4950              MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE3072,
   4951              MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE4096,
   4952              MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE6144,
   4953              MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE8192,
   4954          #endif
   4955              MBEDTLS_SSL_IANA_TLS_GROUP_NONE
   4956          };
   4957          

   \                                 In section .text, align 4, keep-with-next
   4958          static const int ssl_preset_suiteb_ciphersuites[] = {
   \                     ssl_preset_suiteb_ciphersuites:
   \        0x0   0x0000'C02B        DC32 49'195, 49'196, 0
   \              0x0000'C02C  
   \              0x0000'0000

   \                                 In section .data, align 4
   \                     ssl_preset_default_groups:
   \        0x0   0x0017 0x0000      DC16 23, 0
   \        0x4   0x0403 0x0000      DC16 1'027, 0
   \        0x8   0x0403 0x0000      DC16 1'027, 0
   \        0xC   0x0403 0x0000      DC16 1'027, 0
   \       0x10   0x0403 0x0000      DC16 1'027, 0
   \       0x14   0x0017 0x0000      DC16 23, 0
   4959              MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
   4960              MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
   4961              0
   4962          };
   4963          
   4964          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   4965          
   4966          /* NOTICE:
   4967           *   For ssl_preset_*_sig_algs and ssl_tls12_preset_*_sig_algs, the following
   4968           *   rules SHOULD be upheld.
   4969           *   - No duplicate entries.
   4970           *   - But if there is a good reason, do not change the order of the algorithms.
   4971           *   - ssl_tls12_preset* is for TLS 1.2 use only.
   4972           *   - ssl_preset_* is for TLS 1.3 only or hybrid TLS 1.3/1.2 handshakes.
   4973           */
   4974          static uint16_t ssl_preset_default_sig_algs[] = {
   4975          
   4976          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED) && \
   4977              defined(MBEDTLS_MD_CAN_SHA256) && \
   4978              defined(PSA_WANT_ECC_SECP_R1_256)
   4979              MBEDTLS_TLS1_3_SIG_ECDSA_SECP256R1_SHA256,
   4980              // == MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA256)
   4981          #endif
   4982          
   4983          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED) && \
   4984              defined(MBEDTLS_MD_CAN_SHA384) && \
   4985              defined(PSA_WANT_ECC_SECP_R1_384)
   4986              MBEDTLS_TLS1_3_SIG_ECDSA_SECP384R1_SHA384,
   4987              // == MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA384)
   4988          #endif
   4989          
   4990          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED) && \
   4991              defined(MBEDTLS_MD_CAN_SHA512) && \
   4992              defined(PSA_WANT_ECC_SECP_R1_521)
   4993              MBEDTLS_TLS1_3_SIG_ECDSA_SECP521R1_SHA512,
   4994              // == MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA512)
   4995          #endif
   4996          
   4997          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) && \
   4998              defined(MBEDTLS_MD_CAN_SHA512)
   4999              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA512,
   5000          #endif \
   5001              /* MBEDTLS_X509_RSASSA_PSS_SUPPORT && MBEDTLS_MD_CAN_SHA512 */
   5002          
   5003          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) && \
   5004              defined(MBEDTLS_MD_CAN_SHA384)
   5005              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA384,
   5006          #endif \
   5007              /* MBEDTLS_X509_RSASSA_PSS_SUPPORT && MBEDTLS_MD_CAN_SHA384 */
   5008          
   5009          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) && \
   5010              defined(MBEDTLS_MD_CAN_SHA256)
   5011              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256,
   5012          #endif \
   5013              /* MBEDTLS_X509_RSASSA_PSS_SUPPORT && MBEDTLS_MD_CAN_SHA256 */
   5014          
   5015          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_MD_CAN_SHA512)
   5016              MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA512,
   5017          #endif /* MBEDTLS_RSA_C && MBEDTLS_MD_CAN_SHA512 */
   5018          
   5019          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_MD_CAN_SHA384)
   5020              MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA384,
   5021          #endif /* MBEDTLS_RSA_C && MBEDTLS_MD_CAN_SHA384 */
   5022          
   5023          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_MD_CAN_SHA256)
   5024              MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA256,
   5025          #endif /* MBEDTLS_RSA_C && MBEDTLS_MD_CAN_SHA256 */
   5026          
   5027              MBEDTLS_TLS_SIG_NONE
   5028          };
   5029          
   5030          /* NOTICE: see above */
   5031          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5032          static uint16_t ssl_tls12_preset_default_sig_algs[] = {
   5033          #if defined(MBEDTLS_MD_CAN_SHA512)
   5034          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   5035              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA512),
   5036          #endif
   5037          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   5038              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA512,
   5039          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
   5040          #if defined(MBEDTLS_RSA_C)
   5041              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_RSA, MBEDTLS_SSL_HASH_SHA512),
   5042          #endif
   5043          #endif /* MBEDTLS_MD_CAN_SHA512*/
   5044          #if defined(MBEDTLS_MD_CAN_SHA384)
   5045          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   5046              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA384),
   5047          #endif
   5048          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   5049              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA384,
   5050          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
   5051          #if defined(MBEDTLS_RSA_C)
   5052              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_RSA, MBEDTLS_SSL_HASH_SHA384),
   5053          #endif
   5054          #endif /* MBEDTLS_MD_CAN_SHA384*/
   5055          #if defined(MBEDTLS_MD_CAN_SHA256)
   5056          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   5057              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA256),
   5058          #endif
   5059          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   5060              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256,
   5061          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
   5062          #if defined(MBEDTLS_RSA_C)
   5063              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_RSA, MBEDTLS_SSL_HASH_SHA256),
   5064          #endif
   5065          #endif /* MBEDTLS_MD_CAN_SHA256*/
   5066              MBEDTLS_TLS_SIG_NONE
   5067          };
   5068          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5069          /* NOTICE: see above */
   5070          static uint16_t ssl_preset_suiteb_sig_algs[] = {
   5071          
   5072          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED) && \
   5073              defined(MBEDTLS_MD_CAN_SHA256) && \
   5074              defined(MBEDTLS_ECP_HAVE_SECP256R1)
   5075              MBEDTLS_TLS1_3_SIG_ECDSA_SECP256R1_SHA256,
   5076              // == MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA256)
   5077          #endif
   5078          
   5079          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED) && \
   5080              defined(MBEDTLS_MD_CAN_SHA384) && \
   5081              defined(MBEDTLS_ECP_HAVE_SECP384R1)
   5082              MBEDTLS_TLS1_3_SIG_ECDSA_SECP384R1_SHA384,
   5083              // == MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA384)
   5084          #endif
   5085          
   5086          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) && \
   5087              defined(MBEDTLS_MD_CAN_SHA256)
   5088              MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256,
   5089          #endif \
   5090              /* MBEDTLS_X509_RSASSA_PSS_SUPPORT && MBEDTLS_MD_CAN_SHA256*/
   5091          
   5092          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_MD_CAN_SHA256)
   5093              MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA256,
   5094          #endif /* MBEDTLS_RSA_C && MBEDTLS_MD_CAN_SHA256*/
   5095          
   5096              MBEDTLS_TLS_SIG_NONE
   5097          };
   5098          
   5099          /* NOTICE: see above */
   5100          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5101          static uint16_t ssl_tls12_preset_suiteb_sig_algs[] = {
   5102          #if defined(MBEDTLS_MD_CAN_SHA256)
   5103          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   5104              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA256),
   5105          #endif
   5106          #if defined(MBEDTLS_RSA_C)
   5107              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_RSA, MBEDTLS_SSL_HASH_SHA256),
   5108          #endif
   5109          #endif /* MBEDTLS_MD_CAN_SHA256*/
   5110          #if defined(MBEDTLS_MD_CAN_SHA384)
   5111          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ALLOWED_ENABLED)
   5112              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_ECDSA, MBEDTLS_SSL_HASH_SHA384),
   5113          #endif
   5114          #if defined(MBEDTLS_RSA_C)
   5115              MBEDTLS_SSL_TLS12_SIG_AND_HASH_ALG(MBEDTLS_SSL_SIG_RSA, MBEDTLS_SSL_HASH_SHA384),
   5116          #endif
   5117          #endif /* MBEDTLS_MD_CAN_SHA256*/
   5118              MBEDTLS_TLS_SIG_NONE
   5119          };
   5120          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5121          
   5122          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   5123          
   5124          static uint16_t ssl_preset_suiteb_groups[] = {
   5125          #if defined(MBEDTLS_ECP_HAVE_SECP256R1)
   5126              MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1,
   5127          #endif
   5128          #if defined(MBEDTLS_ECP_HAVE_SECP384R1)
   5129              MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1,
   5130          #endif
   5131              MBEDTLS_SSL_IANA_TLS_GROUP_NONE
   5132          };
   5133          
   5134          #if defined(MBEDTLS_DEBUG_C) && defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   5135          /* Function for checking `ssl_preset_*_sig_algs` and `ssl_tls12_preset_*_sig_algs`
   5136           * to make sure there are no duplicated signature algorithm entries. */
   5137          MBEDTLS_CHECK_RETURN_CRITICAL
   5138          static int ssl_check_no_sig_alg_duplication(uint16_t *sig_algs)
   5139          {
   5140              size_t i, j;
   5141              int ret = 0;
   5142          
   5143              for (i = 0; sig_algs[i] != MBEDTLS_TLS_SIG_NONE; i++) {
   5144                  for (j = 0; j < i; j++) {
   5145                      if (sig_algs[i] != sig_algs[j]) {
   5146                          continue;
   5147                      }
   5148                      mbedtls_printf(" entry(%04x,%" MBEDTLS_PRINTF_SIZET
   5149                                     ") is duplicated at %" MBEDTLS_PRINTF_SIZET "\n",
   5150                                     sig_algs[i], j, i);
   5151                      ret = -1;
   5152                  }
   5153              }
   5154              return ret;
   5155          }
   5156          
   5157          #endif /* MBEDTLS_DEBUG_C && MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   5158          
   5159          /*
   5160           * Load default in mbedtls_ssl_config
   5161           */

   \                                 In section .text, align 4, keep-with-next
   5162          int mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf,
   5163                                          int endpoint, int transport, int preset)
   5164          {
   \                     mbedtls_ssl_config_defaults: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5165          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
   5166              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   5167          #endif
   5168          
   5169          #if defined(MBEDTLS_DEBUG_C) && defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   5170              if (ssl_check_no_sig_alg_duplication(ssl_preset_suiteb_sig_algs)) {
   5171                  mbedtls_printf("ssl_preset_suiteb_sig_algs has duplicated entries\n");
   5172                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   5173              }
   5174          
   5175              if (ssl_check_no_sig_alg_duplication(ssl_preset_default_sig_algs)) {
   5176                  mbedtls_printf("ssl_preset_default_sig_algs has duplicated entries\n");
   5177                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   5178              }
   5179          
   5180          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5181              if (ssl_check_no_sig_alg_duplication(ssl_tls12_preset_suiteb_sig_algs)) {
   5182                  mbedtls_printf("ssl_tls12_preset_suiteb_sig_algs has duplicated entries\n");
   5183                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   5184              }
   5185          
   5186              if (ssl_check_no_sig_alg_duplication(ssl_tls12_preset_default_sig_algs)) {
   5187                  mbedtls_printf("ssl_tls12_preset_default_sig_algs has duplicated entries\n");
   5188                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   5189              }
   5190          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5191          #endif /* MBEDTLS_DEBUG_C && MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   5192          
   5193              /* Use the functions here so that they are covered in tests,
   5194               * but otherwise access member directly for efficiency */
   5195              mbedtls_ssl_conf_endpoint(conf, endpoint);
   \        0x4   0x7121             STRB     R1,[R4, #+4]
   5196              mbedtls_ssl_conf_transport(conf, transport);
   \        0x6   0x7162             STRB     R2,[R4, #+5]
   5197          
   5198              /*
   5199               * Things that are common to all presets
   5200               */
   5201          #if defined(MBEDTLS_SSL_CLI_C)
   5202              if (endpoint == MBEDTLS_SSL_IS_CLIENT) {
   \        0x8   0xB909             CBNZ.N   R1,??mbedtls_ssl_config_defaults_0
   5203                  conf->authmode = MBEDTLS_SSL_VERIFY_REQUIRED;
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0x71A0             STRB     R0,[R4, #+6]
   5204          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   5205                  conf->session_tickets = MBEDTLS_SSL_SESSION_TICKETS_ENABLED;
   5206          #endif
   5207              }
   5208          #endif
   5209          
   5210          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   5211              conf->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
   5212          #endif
   5213          
   5214          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   5215              conf->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
   5216          #endif
   5217          
   5218          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   5219              conf->f_cookie_write = ssl_cookie_write_dummy;
   5220              conf->f_cookie_check = ssl_cookie_check_dummy;
   5221          #endif
   5222          
   5223          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   5224              conf->anti_replay = MBEDTLS_SSL_ANTI_REPLAY_ENABLED;
   5225          #endif
   5226          
   5227          #if defined(MBEDTLS_SSL_SRV_C)
   5228              conf->cert_req_ca_list = MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED;
   5229              conf->respect_cli_pref = MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER;
   5230          #endif
   5231          
   5232          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5233              conf->hs_timeout_min = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN;
   5234              conf->hs_timeout_max = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX;
   5235          #endif
   5236          
   5237          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5238              conf->renego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;
   5239              memset(conf->renego_period,     0x00, 2);
   5240              memset(conf->renego_period + 2, 0xFF, 6);
   5241          #endif
   5242          
   5243          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
   5244              if (endpoint == MBEDTLS_SSL_IS_SERVER) {
   5245                  const unsigned char dhm_p[] =
   5246                      MBEDTLS_DHM_RFC3526_MODP_2048_P_BIN;
   5247                  const unsigned char dhm_g[] =
   5248                      MBEDTLS_DHM_RFC3526_MODP_2048_G_BIN;
   5249          
   5250                  if ((ret = mbedtls_ssl_conf_dh_param_bin(conf,
   5251                                                           dhm_p, sizeof(dhm_p),
   5252                                                           dhm_g, sizeof(dhm_g))) != 0) {
   5253                      return ret;
   5254                  }
   5255              }
   5256          #endif
   5257          
   5258          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   5259          
   5260          #if defined(MBEDTLS_SSL_EARLY_DATA)
   5261              mbedtls_ssl_tls13_conf_early_data(conf, MBEDTLS_SSL_EARLY_DATA_DISABLED);
   5262          #if defined(MBEDTLS_SSL_SRV_C)
   5263              mbedtls_ssl_tls13_conf_max_early_data_size(
   5264                  conf, MBEDTLS_SSL_MAX_EARLY_DATA_SIZE);
   5265          #endif
   5266          #endif /* MBEDTLS_SSL_EARLY_DATA */
   5267          
   5268          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_SESSION_TICKETS)
   5269              mbedtls_ssl_conf_new_session_tickets(
   5270                  conf, MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS);
   5271          #endif
   5272              /*
   5273               * Allow all TLS 1.3 key exchange modes by default.
   5274               */
   5275              conf->tls13_kex_modes = MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL;
   5276          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   5277          
   5278              if (transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   5279          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5280                  conf->min_tls_version = MBEDTLS_SSL_VERSION_TLS1_2;
   5281                  conf->max_tls_version = MBEDTLS_SSL_VERSION_TLS1_2;
   5282          #else
   5283                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   5284          #endif
   5285              } else {
   5286          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_TLS1_3)
   5287                  conf->min_tls_version = MBEDTLS_SSL_VERSION_TLS1_2;
   5288                  conf->max_tls_version = MBEDTLS_SSL_VERSION_TLS1_3;
   5289          #elif defined(MBEDTLS_SSL_PROTO_TLS1_3)
   5290                  conf->min_tls_version = MBEDTLS_SSL_VERSION_TLS1_3;
   5291                  conf->max_tls_version = MBEDTLS_SSL_VERSION_TLS1_3;
   5292          #elif defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5293                  conf->min_tls_version = MBEDTLS_SSL_VERSION_TLS1_2;
   \                     ??mbedtls_ssl_config_defaults_0: (+1)
   \        0xE   0xF240 0x3003      MOVW     R0,#+771
   \       0x12   0x8060             STRH     R0,[R4, #+2]
   5294                  conf->max_tls_version = MBEDTLS_SSL_VERSION_TLS1_2;
   \       0x14   0x8020             STRH     R0,[R4, #+0]
   5295          #else
   5296                  return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   5297          #endif
   5298              }
   5299          
   5300              /*
   5301               * Preset-specific defaults
   5302               */
   5303              switch (preset) {
   \       0x16   0x.... 0x....      LDR.W    R5,??DataTable33
   \       0x1A   0x2B02             CMP      R3,#+2
   \       0x1C   0xD110             BNE.N    ??mbedtls_ssl_config_defaults_1
   5304                  /*
   5305                   * NSA Suite B
   5306                   */
   5307                  case MBEDTLS_SSL_PRESET_SUITEB:
   5308          
   5309                      conf->ciphersuite_list = ssl_preset_suiteb_ciphersuites;
   \       0x1E   0xBF00             Nop
   \       0x20   0x....             ADR.N    R2,ssl_preset_suiteb_ciphersuites
   5310          
   5311          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   5312                      conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable33_1
   \       0x26   0x60E2             STR      R2,[R4, #+12]
   \       0x28   0x6361             STR      R1,[R4, #+52]
   5313          #endif
   5314          
   5315          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   5316          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5317                      if (mbedtls_ssl_conf_is_tls12_only(conf)) {
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       mbedtls_ssl_conf_is_tls12_only
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xBF14             ITE      NE
   \       0x34   0xF105 0x0110      ADDNE    R1,R5,#+16
   \       0x38   0xF105 0x010C      ADDEQ    R1,R5,#+12
   5318                          conf->sig_algs = ssl_tls12_preset_suiteb_sig_algs;
   5319                      } else
   5320          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5321                      conf->sig_algs = ssl_preset_suiteb_sig_algs;
   5322          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   5323          
   5324          #if defined(MBEDTLS_ECP_C) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   5325                      conf->curve_list = NULL;
   5326          #endif
   5327                      conf->group_list = ssl_preset_suiteb_groups;
   \       0x3C   0x3514             ADDS     R5,R5,#+20
   5328                      break;
   \       0x3E   0xE00D             B.N      ??mbedtls_ssl_config_defaults_2
   5329          
   5330                  /*
   5331                   * Default
   5332                   */
   5333                  default:
   5334          
   5335                      conf->ciphersuite_list = mbedtls_ssl_list_ciphersuites();
   \                     ??mbedtls_ssl_config_defaults_1: (+1)
   \       0x40   0x.... 0x....      BL       mbedtls_ssl_list_ciphersuites
   \       0x44   0x60E0             STR      R0,[R4, #+12]
   5336          
   5337          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   5338                      conf->cert_profile = &mbedtls_x509_crt_profile_default;
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable34
   \       0x4A   0x6360             STR      R0,[R4, #+52]
   5339          #endif
   5340          
   5341          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   5342          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5343                      if (mbedtls_ssl_conf_is_tls12_only(conf)) {
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       mbedtls_ssl_conf_is_tls12_only
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xBF14             ITE      NE
   \       0x56   0xF105 0x0108      ADDNE    R1,R5,#+8
   \       0x5A   0x1D29             ADDEQ    R1,R5,#+4
   5344                          conf->sig_algs = ssl_tls12_preset_default_sig_algs;
   5345                      } else
   5346          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5347                      conf->sig_algs = ssl_preset_default_sig_algs;
   5348          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   5349          
   5350          #if defined(MBEDTLS_ECP_C) && !defined(MBEDTLS_DEPRECATED_REMOVED)
   5351                      conf->curve_list = NULL;
   5352          #endif
   5353                      conf->group_list = ssl_preset_default_groups;
   \                     ??mbedtls_ssl_config_defaults_2: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x64E0             STR      R0,[R4, #+76]
   \       0x60   0x6525             STR      R5,[R4, #+80]
   5354          
   5355          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)
   5356                      conf->dhm_min_bitlen = 1024;
   5357          #endif
   5358              }
   5359          
   5360              return 0;
   \       0x62   0x64A1             STR      R1,[R4, #+72]
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}
   5361          }
   5362          
   5363          /*
   5364           * Free mbedtls_ssl_config
   5365           */

   \                                 In section .text, align 2, keep-with-next
   5366          void mbedtls_ssl_config_free(mbedtls_ssl_config *conf)
   5367          {
   \                     mbedtls_ssl_config_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   5368          #if defined(MBEDTLS_DHM_C)
   5369              mbedtls_mpi_free(&conf->dhm_P);
   5370              mbedtls_mpi_free(&conf->dhm_G);
   5371          #endif
   5372          
   5373          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_PSK_ENABLED)
   5374          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   5375              if (!mbedtls_svc_key_id_is_null(conf->psk_opaque)) {
   5376                  conf->psk_opaque = MBEDTLS_SVC_KEY_ID_INIT;
   5377              }
   5378          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   5379              if (conf->psk != NULL) {
   5380                  mbedtls_zeroize_and_free(conf->psk, conf->psk_len);
   5381                  conf->psk = NULL;
   5382                  conf->psk_len = 0;
   5383              }
   5384          
   5385              if (conf->psk_identity != NULL) {
   5386                  mbedtls_zeroize_and_free(conf->psk_identity, conf->psk_identity_len);
   5387                  conf->psk_identity = NULL;
   5388                  conf->psk_identity_len = 0;
   5389              }
   5390          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_PSK_ENABLED */
   5391          
   5392          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   5393              ssl_key_cert_free(conf->key_cert);
   \        0x4   0x6BA0             LDR      R0,[R4, #+56]
   \        0x6   0x.... 0x....      BL       ssl_key_cert_free
   5394          #endif
   5395          
   5396              mbedtls_platform_zeroize(conf, sizeof(mbedtls_ssl_config));
   \        0xA                      REQUIRE ?Subroutine7
   \        0xA                      ;; // Fall through to label ?Subroutine7
   5397          }
   5398          
   5399          #if defined(MBEDTLS_PK_C) && \
   5400              (defined(MBEDTLS_RSA_C) || defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED))
   5401          /*
   5402           * Convert between MBEDTLS_PK_XXX and SSL_SIG_XXX
   5403           */

   \                                 In section .text, align 2, keep-with-next
   5404          unsigned char mbedtls_ssl_sig_from_pk(mbedtls_pk_context *pk)
   5405          {
   \                     mbedtls_ssl_sig_from_pk: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   5406          #if defined(MBEDTLS_RSA_C)
   5407              if (mbedtls_pk_can_do(pk, MBEDTLS_PK_RSA)) {
   5408                  return MBEDTLS_SSL_SIG_RSA;
   5409              }
   5410          #endif
   5411          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED)
   5412              if (mbedtls_pk_can_do(pk, MBEDTLS_PK_ECDSA)) {
   \        0x2   0x2104             MOVS     R1,#+4
   \        0x4   0x.... 0x....      BL       mbedtls_pk_can_do
   \        0x8   0xB100             CBZ.N    R0,??mbedtls_ssl_sig_from_pk_0
   5413                  return MBEDTLS_SSL_SIG_ECDSA;
   \        0xA   0x2003             MOVS     R0,#+3
   5414              }
   5415          #endif
   5416              return MBEDTLS_SSL_SIG_ANON;
   \                     ??mbedtls_ssl_sig_from_pk_0: (+1)
   \        0xC   0xBD02             POP      {R1,PC}
   5417          }
   5418          

   \                                 In section .text, align 2, keep-with-next
   5419          unsigned char mbedtls_ssl_sig_from_pk_alg(mbedtls_pk_type_t type)
   5420          {
   5421              switch (type) {
   \                     mbedtls_ssl_sig_from_pk_alg: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xD006             BEQ.N    ??mbedtls_ssl_sig_from_pk_alg_0
   \        0x4   0x2802             CMP      R0,#+2
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2804             CMPNE    R0,#+4
   \        0xA   0xD101             BNE.N    ??mbedtls_ssl_sig_from_pk_alg_1
   5422                  case MBEDTLS_PK_RSA:
   5423                      return MBEDTLS_SSL_SIG_RSA;
   5424                  case MBEDTLS_PK_ECDSA:
   5425                  case MBEDTLS_PK_ECKEY:
   5426                      return MBEDTLS_SSL_SIG_ECDSA;
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0x4770             BX       LR
   5427                  default:
   5428                      return MBEDTLS_SSL_SIG_ANON;
   \                     ??mbedtls_ssl_sig_from_pk_alg_1: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_sig_from_pk_alg_0: (+1)
   \       0x12   0x4770             BX       LR
   5429              }
   5430          }
   5431          

   \                                 In section .text, align 2, keep-with-next
   5432          mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig(unsigned char sig)
   5433          {
   5434              switch (sig) {
   \                     mbedtls_ssl_pk_alg_from_sig: (+1)
   \        0x0   0x2803             CMP      R0,#+3
   \        0x2   0xD101             BNE.N    ??mbedtls_ssl_pk_alg_from_sig_0
   5435          #if defined(MBEDTLS_RSA_C)
   5436                  case MBEDTLS_SSL_SIG_RSA:
   5437                      return MBEDTLS_PK_RSA;
   5438          #endif
   5439          #if defined(MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED)
   5440                  case MBEDTLS_SSL_SIG_ECDSA:
   5441                      return MBEDTLS_PK_ECDSA;
   \        0x4   0x2004             MOVS     R0,#+4
   \        0x6   0x4770             BX       LR
   5442          #endif
   5443                  default:
   5444                      return MBEDTLS_PK_NONE;
   \                     ??mbedtls_ssl_pk_alg_from_sig_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   5445              }
   5446          }
   5447          #endif /* MBEDTLS_PK_C &&
   5448                    ( MBEDTLS_RSA_C || MBEDTLS_KEY_EXCHANGE_ECDSA_CERT_REQ_ANY_ALLOWED_ENABLED ) */
   5449          
   5450          /*
   5451           * Convert from MBEDTLS_SSL_HASH_XXX to MBEDTLS_MD_XXX
   5452           */

   \                                 In section .text, align 2, keep-with-next
   5453          mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash(unsigned char hash)
   5454          {
   5455              switch (hash) {
   \                     mbedtls_ssl_md_alg_from_hash: (+1)
   \        0x0   0x2802             CMP      R0,#+2
   \        0x2   0xD004             BEQ.N    ??mbedtls_ssl_md_alg_from_hash_0
   \        0x4   0xD309             BCC.N    ??mbedtls_ssl_md_alg_from_hash_1
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD005             BEQ.N    ??mbedtls_ssl_md_alg_from_hash_2
   \        0xA   0xD302             BCC.N    ??mbedtls_ssl_md_alg_from_hash_3
   \        0xC   0xE005             B.N      ??mbedtls_ssl_md_alg_from_hash_1
   5456          #if defined(MBEDTLS_MD_CAN_MD5)
   5457                  case MBEDTLS_SSL_HASH_MD5:
   5458                      return MBEDTLS_MD_MD5;
   5459          #endif
   5460          #if defined(MBEDTLS_MD_CAN_SHA1)
   5461                  case MBEDTLS_SSL_HASH_SHA1:
   5462                      return MBEDTLS_MD_SHA1;
   \                     ??mbedtls_ssl_md_alg_from_hash_0: (+1)
   \        0xE   0x2005             MOVS     R0,#+5
   \       0x10   0x4770             BX       LR
   5463          #endif
   5464          #if defined(MBEDTLS_MD_CAN_SHA224)
   5465                  case MBEDTLS_SSL_HASH_SHA224:
   5466                      return MBEDTLS_MD_SHA224;
   \                     ??mbedtls_ssl_md_alg_from_hash_3: (+1)
   \       0x12   0x2008             MOVS     R0,#+8
   \       0x14   0x4770             BX       LR
   5467          #endif
   5468          #if defined(MBEDTLS_MD_CAN_SHA256)
   5469                  case MBEDTLS_SSL_HASH_SHA256:
   5470                      return MBEDTLS_MD_SHA256;
   \                     ??mbedtls_ssl_md_alg_from_hash_2: (+1)
   \       0x16   0x2009             MOVS     R0,#+9
   \       0x18   0x4770             BX       LR
   5471          #endif
   5472          #if defined(MBEDTLS_MD_CAN_SHA384)
   5473                  case MBEDTLS_SSL_HASH_SHA384:
   5474                      return MBEDTLS_MD_SHA384;
   5475          #endif
   5476          #if defined(MBEDTLS_MD_CAN_SHA512)
   5477                  case MBEDTLS_SSL_HASH_SHA512:
   5478                      return MBEDTLS_MD_SHA512;
   5479          #endif
   5480                  default:
   5481                      return MBEDTLS_MD_NONE;
   \                     ??mbedtls_ssl_md_alg_from_hash_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4770             BX       LR
   5482              }
   5483          }
   5484          
   5485          /*
   5486           * Convert from MBEDTLS_MD_XXX to MBEDTLS_SSL_HASH_XXX
   5487           */

   \                                 In section .text, align 2, keep-with-next
   5488          unsigned char mbedtls_ssl_hash_from_md_alg(int md)
   5489          {
   5490              switch (md) {
   \                     mbedtls_ssl_hash_from_md_alg: (+1)
   \        0x0   0x2805             CMP      R0,#+5
   \        0x2   0xD004             BEQ.N    ??mbedtls_ssl_hash_from_md_alg_0
   \        0x4   0x2808             CMP      R0,#+8
   \        0x6   0xD004             BEQ.N    ??mbedtls_ssl_hash_from_md_alg_1
   \        0x8   0x2809             CMP      R0,#+9
   \        0xA   0xD004             BEQ.N    ??mbedtls_ssl_hash_from_md_alg_2
   \        0xC   0xE005             B.N      ??mbedtls_ssl_hash_from_md_alg_3
   5491          #if defined(MBEDTLS_MD_CAN_MD5)
   5492                  case MBEDTLS_MD_MD5:
   5493                      return MBEDTLS_SSL_HASH_MD5;
   5494          #endif
   5495          #if defined(MBEDTLS_MD_CAN_SHA1)
   5496                  case MBEDTLS_MD_SHA1:
   5497                      return MBEDTLS_SSL_HASH_SHA1;
   \                     ??mbedtls_ssl_hash_from_md_alg_0: (+1)
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x4770             BX       LR
   5498          #endif
   5499          #if defined(MBEDTLS_MD_CAN_SHA224)
   5500                  case MBEDTLS_MD_SHA224:
   5501                      return MBEDTLS_SSL_HASH_SHA224;
   \                     ??mbedtls_ssl_hash_from_md_alg_1: (+1)
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0x4770             BX       LR
   5502          #endif
   5503          #if defined(MBEDTLS_MD_CAN_SHA256)
   5504                  case MBEDTLS_MD_SHA256:
   5505                      return MBEDTLS_SSL_HASH_SHA256;
   \                     ??mbedtls_ssl_hash_from_md_alg_2: (+1)
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0x4770             BX       LR
   5506          #endif
   5507          #if defined(MBEDTLS_MD_CAN_SHA384)
   5508                  case MBEDTLS_MD_SHA384:
   5509                      return MBEDTLS_SSL_HASH_SHA384;
   5510          #endif
   5511          #if defined(MBEDTLS_MD_CAN_SHA512)
   5512                  case MBEDTLS_MD_SHA512:
   5513                      return MBEDTLS_SSL_HASH_SHA512;
   5514          #endif
   5515                  default:
   5516                      return MBEDTLS_SSL_HASH_NONE;
   \                     ??mbedtls_ssl_hash_from_md_alg_3: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4770             BX       LR
   5517              }
   5518          }
   5519          
   5520          /*
   5521           * Check if a curve proposed by the peer is in our list.
   5522           * Return 0 if we're willing to use it, -1 otherwise.
   5523           */

   \                                 In section .text, align 2, keep-with-next
   5524          int mbedtls_ssl_check_curve_tls_id(const mbedtls_ssl_context *ssl, uint16_t tls_id)
   5525          {
   \                     mbedtls_ssl_check_curve_tls_id: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5526              const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
   \        0x2   0x6B82             LDR      R2,[R0, #+56]
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xBF19             ITTEE    NE
   \        0x8   0x6C52             LDRNE    R2,[R2, #+68]
   \        0xA   0x2A00             CMPNE    R2,#+0
   \        0xC   0x6800             LDREQ    R0,[R0, #+0]
   \        0xE   0x6D02             LDREQ    R2,[R0, #+80]
   5527          
   5528              if (group_list == NULL) {
   \       0x10   0xB13A             CBZ.N    R2,??mbedtls_ssl_check_curve_tls_id_0
   5529                  return -1;
   5530              }
   5531          
   5532              for (; *group_list != 0; group_list++) {
   \                     ??mbedtls_ssl_check_curve_tls_id_1: (+1)
   \       0x12   0x8810             LDRH     R0,[R2, #+0]
   \       0x14   0xB128             CBZ.N    R0,??mbedtls_ssl_check_curve_tls_id_0
   5533                  if (*group_list == tls_id) {
   \       0x16   0xF832 0x4B02      LDRH     R4,[R2], #+2
   \       0x1A   0x428C             CMP      R4,R1
   \       0x1C   0xD1F9             BNE.N    ??mbedtls_ssl_check_curve_tls_id_1
   5534                      return 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD10             POP      {R4,PC}
   5535                  }
   5536              }
   5537          
   5538              return -1;
   \                     ??mbedtls_ssl_check_curve_tls_id_0: (+1)
   \       0x22                      REQUIRE ?Subroutine4
   \       0x22                      ;; // Fall through to label ?Subroutine4
   5539          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#+4294967295
   \        0x4   0xBD10             POP      {R4,PC}
   5540          
   5541          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
   5542          /*
   5543           * Same as mbedtls_ssl_check_curve_tls_id() but with a mbedtls_ecp_group_id.
   5544           */

   \                                 In section .text, align 2, keep-with-next
   5545          int mbedtls_ssl_check_curve(const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id)
   5546          {
   \                     mbedtls_ssl_check_curve: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
   5547              uint16_t tls_id = mbedtls_ssl_get_tls_id_from_ecp_group_id(grp_id);
   \        0x6   0x.... 0x....      BL       mbedtls_ssl_get_tls_id_from_ecp_group_id
   5548          
   5549              if (tls_id == 0) {
   \        0xA   0x0001             MOVS     R1,R0
   \        0xC   0xD100             BNE.N    ??mbedtls_ssl_check_curve_0
   5550                  return -1;
   \        0xE   0x....             B.N      ?Subroutine4
   5551              }
   5552          
   5553              return mbedtls_ssl_check_curve_tls_id(ssl, tls_id);
   \                     ??mbedtls_ssl_check_curve_0: (+1)
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4010      POP      {R4,LR}
   \       0x16   0x....             B.N      mbedtls_ssl_check_curve_tls_id
   5554          }
   5555          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   5556          
   5557          static const struct {
   5558              uint16_t tls_id;
   5559              mbedtls_ecp_group_id ecp_group_id;
   5560              psa_ecc_family_t psa_family;
   5561              uint16_t bits;

   \                                 In section .text, align 4, keep-with-next
   5562          } tls_id_match_table[] =
   \                     tls_id_match_table:
   \        0x0   0x0017             DC16 23
   \        0x2   0x03 0x12          DC8 3, 18
   \        0x4   0x0100 0x0000      DC16 256, 0
   \        0x8   0x00 0x00          DC8 0, 0
   \        0xA   0x0000             DC16 0
   5563          {
   5564          #if defined(MBEDTLS_ECP_HAVE_SECP521R1)
   5565              { 25, MBEDTLS_ECP_DP_SECP521R1, PSA_ECC_FAMILY_SECP_R1, 521 },
   5566          #endif
   5567          #if defined(MBEDTLS_ECP_HAVE_BP512R1)
   5568              { 28, MBEDTLS_ECP_DP_BP512R1, PSA_ECC_FAMILY_BRAINPOOL_P_R1, 512 },
   5569          #endif
   5570          #if defined(MBEDTLS_ECP_HAVE_SECP384R1)
   5571              { 24, MBEDTLS_ECP_DP_SECP384R1, PSA_ECC_FAMILY_SECP_R1, 384 },
   5572          #endif
   5573          #if defined(MBEDTLS_ECP_HAVE_BP384R1)
   5574              { 27, MBEDTLS_ECP_DP_BP384R1, PSA_ECC_FAMILY_BRAINPOOL_P_R1, 384 },
   5575          #endif
   5576          #if defined(MBEDTLS_ECP_HAVE_SECP256R1)
   5577              { 23, MBEDTLS_ECP_DP_SECP256R1, PSA_ECC_FAMILY_SECP_R1, 256 },
   5578          #endif
   5579          #if defined(MBEDTLS_ECP_HAVE_SECP256K1)
   5580              { 22, MBEDTLS_ECP_DP_SECP256K1, PSA_ECC_FAMILY_SECP_K1, 256 },
   5581          #endif
   5582          #if defined(MBEDTLS_ECP_HAVE_BP256R1)
   5583              { 26, MBEDTLS_ECP_DP_BP256R1, PSA_ECC_FAMILY_BRAINPOOL_P_R1, 256 },
   5584          #endif
   5585          #if defined(MBEDTLS_ECP_HAVE_SECP224R1)
   5586              { 21, MBEDTLS_ECP_DP_SECP224R1, PSA_ECC_FAMILY_SECP_R1, 224 },
   5587          #endif
   5588          #if defined(MBEDTLS_ECP_HAVE_SECP224K1)
   5589              { 20, MBEDTLS_ECP_DP_SECP224K1, PSA_ECC_FAMILY_SECP_K1, 224 },
   5590          #endif
   5591          #if defined(MBEDTLS_ECP_HAVE_SECP192R1)
   5592              { 19, MBEDTLS_ECP_DP_SECP192R1, PSA_ECC_FAMILY_SECP_R1, 192 },
   5593          #endif
   5594          #if defined(MBEDTLS_ECP_HAVE_SECP192K1)
   5595              { 18, MBEDTLS_ECP_DP_SECP192K1, PSA_ECC_FAMILY_SECP_K1, 192 },
   5596          #endif
   5597          #if defined(MBEDTLS_ECP_HAVE_CURVE25519)
   5598              { 29, MBEDTLS_ECP_DP_CURVE25519, PSA_ECC_FAMILY_MONTGOMERY, 255 },
   5599          #endif
   5600          #if defined(MBEDTLS_ECP_HAVE_CURVE448)
   5601              { 30, MBEDTLS_ECP_DP_CURVE448, PSA_ECC_FAMILY_MONTGOMERY, 448 },
   5602          #endif
   5603              { 0, MBEDTLS_ECP_DP_NONE, 0, 0 },
   5604          };
   5605          

   \                                 In section .text, align 4, keep-with-next
   5606          int mbedtls_ssl_get_psa_curve_info_from_tls_id(uint16_t tls_id,
   5607                                                         psa_key_type_t *type,
   5608                                                         size_t *bits)
   5609          {
   \                     mbedtls_ssl_get_psa_curve_info_from_tls_id: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5610              for (int i = 0; tls_id_match_table[i].tls_id != 0; i++) {
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0xE000             B.N      ??mbedtls_ssl_get_psa_curve_info_from_tls_id_0
   \                     ??mbedtls_ssl_get_psa_curve_info_from_tls_id_1: (+1)
   \        0x6   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mbedtls_ssl_get_psa_curve_info_from_tls_id_0: (+1)
   \        0x8   0x2306             MOVS     R3,#+6
   \        0xA   0x436B             MULS     R3,R3,R5
   \        0xC   0x....             ADR.N    R4,tls_id_match_table
   \        0xE   0x441C             ADD      R4,R4,R3
   \       0x10   0x8823             LDRH     R3,[R4, #+0]
   \       0x12   0xB15B             CBZ.N    R3,??mbedtls_ssl_get_psa_curve_info_from_tls_id_2
   5611                  if (tls_id_match_table[i].tls_id == tls_id) {
   \       0x14   0x4283             CMP      R3,R0
   \       0x16   0xD1F6             BNE.N    ??mbedtls_ssl_get_psa_curve_info_from_tls_id_1
   5612                      if (type != NULL) {
   \       0x18   0xB119             CBZ.N    R1,??mbedtls_ssl_get_psa_curve_info_from_tls_id_3
   5613                          *type = PSA_KEY_TYPE_ECC_KEY_PAIR(tls_id_match_table[i].psa_family);
   \       0x1A   0x78E0             LDRB     R0,[R4, #+3]
   \       0x1C   0xF440 0x40E2      ORR      R0,R0,#0x7100
   \       0x20   0x8008             STRH     R0,[R1, #+0]
   5614                      }
   5615                      if (bits != NULL) {
   \                     ??mbedtls_ssl_get_psa_curve_info_from_tls_id_3: (+1)
   \       0x22   0xB10A             CBZ.N    R2,??mbedtls_ssl_get_psa_curve_info_from_tls_id_4
   5616                          *bits = tls_id_match_table[i].bits;
   \       0x24   0x88A0             LDRH     R0,[R4, #+4]
   \       0x26   0x6010             STR      R0,[R2, #+0]
   5617                      }
   5618                      return PSA_SUCCESS;
   \                     ??mbedtls_ssl_get_psa_curve_info_from_tls_id_4: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD30             POP      {R4,R5,PC}
   5619                  }
   5620              }
   5621          
   5622              return PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_ssl_get_psa_curve_info_from_tls_id_2: (+1)
   \       0x2C   0xF06F 0x0085      MVN      R0,#+133
   \       0x30   0xBD30             POP      {R4,R5,PC}
   5623          }
   5624          

   \                                 In section .text, align 4, keep-with-next
   5625          mbedtls_ecp_group_id mbedtls_ssl_get_ecp_group_id_from_tls_id(uint16_t tls_id)
   5626          {
   \                     mbedtls_ssl_get_ecp_group_id_from_tls_id: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   5627              for (int i = 0; tls_id_match_table[i].tls_id != 0; i++) {
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x....             ADR.N    R2,tls_id_match_table
   \        0x6   0xE000             B.N      ??mbedtls_ssl_get_ecp_group_id_from_tls_id_0
   \                     ??mbedtls_ssl_get_ecp_group_id_from_tls_id_1: (+1)
   \        0x8   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mbedtls_ssl_get_ecp_group_id_from_tls_id_0: (+1)
   \        0xA   0x2406             MOVS     R4,#+6
   \        0xC   0x436C             MULS     R4,R4,R5
   \        0xE   0x5B11             LDRH     R1,[R2, R4]
   \       0x10   0xB121             CBZ.N    R1,??mbedtls_ssl_get_ecp_group_id_from_tls_id_2
   5628                  if (tls_id_match_table[i].tls_id == tls_id) {
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD1F8             BNE.N    ??mbedtls_ssl_get_ecp_group_id_from_tls_id_1
   5629                      return tls_id_match_table[i].ecp_group_id;
   \       0x16   0x1910             ADDS     R0,R2,R4
   \       0x18   0x7880             LDRB     R0,[R0, #+2]
   \       0x1A   0xBD30             POP      {R4,R5,PC}
   5630                  }
   5631              }
   5632          
   5633              return MBEDTLS_ECP_DP_NONE;
   \                     ??mbedtls_ssl_get_ecp_group_id_from_tls_id_2: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD30             POP      {R4,R5,PC}
   5634          }
   5635          

   \                                 In section .text, align 4, keep-with-next
   5636          uint16_t mbedtls_ssl_get_tls_id_from_ecp_group_id(mbedtls_ecp_group_id grp_id)
   5637          {
   \                     mbedtls_ssl_get_tls_id_from_ecp_group_id: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5638              for (int i = 0; tls_id_match_table[i].ecp_group_id != MBEDTLS_ECP_DP_NONE;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x....             ADR.N    R2,tls_id_match_table
   \        0x6   0xE000             B.N      ??mbedtls_ssl_get_tls_id_from_ecp_group_id_0
   5639                   i++) {
   \                     ??mbedtls_ssl_get_tls_id_from_ecp_group_id_1: (+1)
   \        0x8   0x1C64             ADDS     R4,R4,#+1
   \                     ??mbedtls_ssl_get_tls_id_from_ecp_group_id_0: (+1)
   \        0xA   0x2306             MOVS     R3,#+6
   \        0xC   0x4363             MULS     R3,R3,R4
   \        0xE   0x18D1             ADDS     R1,R2,R3
   \       0x10   0x7889             LDRB     R1,[R1, #+2]
   \       0x12   0xB119             CBZ.N    R1,??mbedtls_ssl_get_tls_id_from_ecp_group_id_2
   5640                  if (tls_id_match_table[i].ecp_group_id == grp_id) {
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD1F7             BNE.N    ??mbedtls_ssl_get_tls_id_from_ecp_group_id_1
   5641                      return tls_id_match_table[i].tls_id;
   \       0x18   0x5AD0             LDRH     R0,[R2, R3]
   \       0x1A   0xBD10             POP      {R4,PC}
   5642                  }
   5643              }
   5644          
   5645              return 0;
   \                     ??mbedtls_ssl_get_tls_id_from_ecp_group_id_2: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}
   5646          }
   5647          
   5648          #if defined(MBEDTLS_DEBUG_C)
   5649          static const struct {
   5650              uint16_t tls_id;
   5651              const char *name;
   5652          } tls_id_curve_name_table[] =
   5653          {
   5654              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1, "secp521r1" },
   5655              { MBEDTLS_SSL_IANA_TLS_GROUP_BP512R1, "brainpoolP512r1" },
   5656              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1, "secp384r1" },
   5657              { MBEDTLS_SSL_IANA_TLS_GROUP_BP384R1, "brainpoolP384r1" },
   5658              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1, "secp256r1" },
   5659              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP256K1, "secp256k1" },
   5660              { MBEDTLS_SSL_IANA_TLS_GROUP_BP256R1, "brainpoolP256r1" },
   5661              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP224R1, "secp224r1" },
   5662              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP224K1, "secp224k1" },
   5663              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP192R1, "secp192r1" },
   5664              { MBEDTLS_SSL_IANA_TLS_GROUP_SECP192K1, "secp192k1" },
   5665              { MBEDTLS_SSL_IANA_TLS_GROUP_X25519, "x25519" },
   5666              { MBEDTLS_SSL_IANA_TLS_GROUP_X448, "x448" },
   5667              { 0, NULL },
   5668          };
   5669          
   5670          const char *mbedtls_ssl_get_curve_name_from_tls_id(uint16_t tls_id)
   5671          {
   5672              for (int i = 0; tls_id_curve_name_table[i].tls_id != 0; i++) {
   5673                  if (tls_id_curve_name_table[i].tls_id == tls_id) {
   5674                      return tls_id_curve_name_table[i].name;
   5675                  }
   5676              }
   5677          
   5678              return NULL;
   5679          }
   5680          #endif
   5681          
   5682          #if defined(MBEDTLS_X509_CRT_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
   5683          int mbedtls_ssl_check_cert_usage(const mbedtls_x509_crt *cert,
   5684                                           const mbedtls_ssl_ciphersuite_t *ciphersuite,
   5685                                           int cert_endpoint,
   5686                                           uint32_t *flags)
   5687          {
   \                     mbedtls_ssl_check_cert_usage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4617             MOV      R7,R2
   5688              int ret = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   5689              int usage = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x461D             MOV      R5,R3
   5690              const char *ext_oid;
   5691              size_t ext_len;
   5692          
   5693              if (cert_endpoint == MBEDTLS_SSL_IS_SERVER) {
   \        0xE   0x2F01             CMP      R7,#+1
   \       0x10   0xD10E             BNE.N    ??mbedtls_ssl_check_cert_usage_0
   5694                  /* Server part of the key exchange */
   5695                  switch (ciphersuite->key_exchange) {
   \       0x12   0x7A8A             LDRB     R2,[R1, #+10]
   \       0x14   0x1E52             SUBS     R2,R2,#+1
   \       0x16   0xD009             BEQ.N    ??mbedtls_ssl_check_cert_usage_1
   \       0x18   0x1E52             SUBS     R2,R2,#+1
   \       0x1A   0x2A02             CMP      R2,#+2
   \       0x1C   0xD908             BLS.N    ??mbedtls_ssl_check_cert_usage_0
   \       0x1E   0x1F52             SUBS     R2,R2,#+5
   \       0x20   0xD004             BEQ.N    ??mbedtls_ssl_check_cert_usage_1
   \       0x22   0x1E92             SUBS     R2,R2,#+2
   \       0x24   0x2A01             CMP      R2,#+1
   \       0x26   0xBF98             IT       LS
   \       0x28   0x2008             MOVLS    R0,#+8
   5696                      case MBEDTLS_KEY_EXCHANGE_RSA:
   5697                      case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
   5698                          usage = MBEDTLS_X509_KU_KEY_ENCIPHERMENT;
   5699                          break;
   5700          
   5701                      case MBEDTLS_KEY_EXCHANGE_DHE_RSA:
   5702                      case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
   5703                      case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
   5704                          usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
   5705                          break;
   5706          
   5707                      case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
   5708                      case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
   5709                          usage = MBEDTLS_X509_KU_KEY_AGREEMENT;
   \       0x2A   0xE002             B.N      ??mbedtls_ssl_check_cert_usage_2
   \                     ??mbedtls_ssl_check_cert_usage_1: (+1)
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0xE000             B.N      ??mbedtls_ssl_check_cert_usage_2
   5710                          break;
   5711          
   5712                      /* Don't use default: we want warnings when adding new values */
   5713                      case MBEDTLS_KEY_EXCHANGE_NONE:
   5714                      case MBEDTLS_KEY_EXCHANGE_PSK:
   5715                      case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
   5716                      case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
   5717                      case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
   5718                          usage = 0;
   5719                  }
   5720              } else {
   5721                  /* Client auth: we only implement rsa_sign and mbedtls_ecdsa_sign for now */
   5722                  usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
   \                     ??mbedtls_ssl_check_cert_usage_0: (+1)
   \       0x30   0x2080             MOVS     R0,#+128
   5723              }
   5724          
   5725              if (mbedtls_x509_crt_check_key_usage(cert, usage) != 0) {
   \                     ??mbedtls_ssl_check_cert_usage_2: (+1)
   \       0x32   0x4601             MOV      R1,R0
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0xF04F 0x38FF      MOV      R8,#+4294967295
   \       0x3A   0x.... 0x....      BL       mbedtls_x509_crt_check_key_usage
   \       0x3E   0xB120             CBZ.N    R0,??mbedtls_ssl_check_cert_usage_3
   5726                  *flags |= MBEDTLS_X509_BADCERT_KEY_USAGE;
   \       0x40   0x6828             LDR      R0,[R5, #+0]
   5727                  ret = -1;
   \       0x42   0x4646             MOV      R6,R8
   \       0x44   0xF440 0x6000      ORR      R0,R0,#0x800
   \       0x48   0x6028             STR      R0,[R5, #+0]
   5728              }
   5729          
   5730              if (cert_endpoint == MBEDTLS_SSL_IS_SERVER) {
   \                     ??mbedtls_ssl_check_cert_usage_3: (+1)
   \       0x4A   0x2F01             CMP      R7,#+1
   \       0x4C   0xBF0C             ITE      EQ
   \       0x4E   0x.... 0x....      ADREQ.W  R1,?_8
   \       0x52   0x.... 0x....      ADRNE.W  R1,?_9
   5731                  ext_oid = MBEDTLS_OID_SERVER_AUTH;
   5732                  ext_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_SERVER_AUTH);
   5733              } else {
   5734                  ext_oid = MBEDTLS_OID_CLIENT_AUTH;
   5735                  ext_len = MBEDTLS_OID_SIZE(MBEDTLS_OID_CLIENT_AUTH);
   5736              }
   5737          
   5738              if (mbedtls_x509_crt_check_extended_key_usage(cert, ext_oid, ext_len) != 0) {
   \       0x56   0x2208             MOVS     R2,#+8
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x.... 0x....      BL       mbedtls_x509_crt_check_extended_key_usage
   \       0x5E   0xB120             CBZ.N    R0,??mbedtls_ssl_check_cert_usage_4
   5739                  *flags |= MBEDTLS_X509_BADCERT_EXT_KEY_USAGE;
   \       0x60   0x6828             LDR      R0,[R5, #+0]
   5740                  ret = -1;
   \       0x62   0x4646             MOV      R6,R8
   \       0x64   0xF440 0x5080      ORR      R0,R0,#0x1000
   \       0x68   0x6028             STR      R0,[R5, #+0]
   5741              }
   5742          
   5743              return ret;
   \                     ??mbedtls_ssl_check_cert_usage_4: (+1)
   \       0x6A   0x4630             MOV      R0,R6
   \       0x6C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   5744          }
   5745          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   5746          
   5747          #if defined(MBEDTLS_USE_PSA_CRYPTO)

   \                                 In section .text, align 2, keep-with-next
   5748          int mbedtls_ssl_get_handshake_transcript(mbedtls_ssl_context *ssl,
   5749                                                   const mbedtls_md_type_t md,
   5750                                                   unsigned char *dst,
   5751                                                   size_t dst_len,
   5752                                                   size_t *olen)
   5753          {
   \                     mbedtls_ssl_get_handshake_transcript: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB0B8             SUB      SP,SP,#+224
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x469A             MOV      R10,R3
   \        0xE   0x9C40             LDR      R4,[SP, #+256]
   5754              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   5755              psa_hash_operation_t *hash_operation_to_clone;
   5756              psa_hash_operation_t hash_operation = psa_hash_operation_init();
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   5757          
   5758              *olen = 0;
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x14   0x2700             MOVS     R7,#+0
   \       0x16   0xF06F 0x0896      MVN      R8,#+150
   \       0x1A   0x6027             STR      R7,[R4, #+0]
   5759          
   5760              switch (md) {
   \       0x1C   0x2D09             CMP      R5,#+9
   \       0x1E   0xD10E             BNE.N    ??mbedtls_ssl_get_handshake_transcript_0
   5761          #if defined(MBEDTLS_MD_CAN_SHA384)
   5762                  case MBEDTLS_MD_SHA384:
   5763                      hash_operation_to_clone = &ssl->handshake->fin_sha384_psa;
   5764                      break;
   5765          #endif
   5766          
   5767          #if defined(MBEDTLS_MD_CAN_SHA256)
   5768                  case MBEDTLS_MD_SHA256:
   5769                      hash_operation_to_clone = &ssl->handshake->fin_sha256_psa;
   5770                      break;
   5771          #endif
   5772          
   5773                  default:
   5774                      goto exit;
   5775              }
   5776          
   5777              status = psa_hash_clone(hash_operation_to_clone, &hash_operation);
   \       0x20   0x6BB0             LDR      R0,[R6, #+56]
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x30EC             ADDS     R0,R0,#+236
   \       0x26   0x.... 0x....      BL       psa_hash_clone
   \       0x2A   0xEA5F 0x0800      MOVS     R8,R0
   5778              if (status != PSA_SUCCESS) {
   \       0x2E   0xD106             BNE.N    ??mbedtls_ssl_get_handshake_transcript_0
   5779                  goto exit;
   5780              }
   5781          
   5782              status = psa_hash_finish(&hash_operation, dst, dst_len, olen);
   \       0x30   0x4623             MOV      R3,R4
   \       0x32   0x4652             MOV      R2,R10
   \       0x34   0x4649             MOV      R1,R9
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x.... 0x....      BL       psa_hash_finish
   \       0x3C   0x4680             MOV      R8,R0
   5783              if (status != PSA_SUCCESS) {
   5784                  goto exit;
   5785              }
   5786          
   5787          exit:
   5788          #if !defined(MBEDTLS_MD_CAN_SHA384) && \
   5789              !defined(MBEDTLS_MD_CAN_SHA256)
   5790              (void) ssl;
   5791          #endif
   5792              return PSA_TO_MBEDTLS_ERR(status);
   \                     ??mbedtls_ssl_get_handshake_transcript_0: (+1)
   \       0x3E   0x4640             MOV      R0,R8
   \       0x40   0x.... 0x....      BL       local_err_translation
   \       0x44   0xB038             ADD      SP,SP,#+224
   \       0x46   0xE8BD 0x87F0      POP      {R4-R10,PC}
   5793          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x4668             MOV      R0,SP
   \        0x2   0x21E0             MOVS     R1,#+224
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4
   5794          #else /* MBEDTLS_USE_PSA_CRYPTO */
   5795          
   5796          #if defined(MBEDTLS_MD_CAN_SHA384)
   5797          MBEDTLS_CHECK_RETURN_CRITICAL
   5798          static int ssl_get_handshake_transcript_sha384(mbedtls_ssl_context *ssl,
   5799                                                         unsigned char *dst,
   5800                                                         size_t dst_len,
   5801                                                         size_t *olen)
   5802          {
   5803              int ret;
   5804              mbedtls_md_context_t sha384;
   5805          
   5806              if (dst_len < 48) {
   5807                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   5808              }
   5809          
   5810              mbedtls_md_init(&sha384);
   5811              ret = mbedtls_md_setup(&sha384, mbedtls_md_info_from_type(MBEDTLS_MD_SHA384), 0);
   5812              if (ret != 0) {
   5813                  goto exit;
   5814              }
   5815              ret = mbedtls_md_clone(&sha384, &ssl->handshake->fin_sha384);
   5816              if (ret != 0) {
   5817                  goto exit;
   5818              }
   5819          
   5820              if ((ret = mbedtls_md_finish(&sha384, dst)) != 0) {
   5821                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_finish", ret);
   5822                  goto exit;
   5823              }
   5824          
   5825              *olen = 48;
   5826          
   5827          exit:
   5828          
   5829              mbedtls_md_free(&sha384);
   5830              return ret;
   5831          }
   5832          #endif /* MBEDTLS_MD_CAN_SHA384 */
   5833          
   5834          #if defined(MBEDTLS_MD_CAN_SHA256)
   5835          MBEDTLS_CHECK_RETURN_CRITICAL
   5836          static int ssl_get_handshake_transcript_sha256(mbedtls_ssl_context *ssl,
   5837                                                         unsigned char *dst,
   5838                                                         size_t dst_len,
   5839                                                         size_t *olen)
   5840          {
   5841              int ret;
   5842              mbedtls_md_context_t sha256;
   5843          
   5844              if (dst_len < 32) {
   5845                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   5846              }
   5847          
   5848              mbedtls_md_init(&sha256);
   5849              ret = mbedtls_md_setup(&sha256, mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), 0);
   5850              if (ret != 0) {
   5851                  goto exit;
   5852              }
   5853              ret = mbedtls_md_clone(&sha256, &ssl->handshake->fin_sha256);
   5854              if (ret != 0) {
   5855                  goto exit;
   5856              }
   5857          
   5858              if ((ret = mbedtls_md_finish(&sha256, dst)) != 0) {
   5859                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_finish", ret);
   5860                  goto exit;
   5861              }
   5862          
   5863              *olen = 32;
   5864          
   5865          exit:
   5866          
   5867              mbedtls_md_free(&sha256);
   5868              return ret;
   5869          }
   5870          #endif /* MBEDTLS_MD_CAN_SHA256 */
   5871          
   5872          int mbedtls_ssl_get_handshake_transcript(mbedtls_ssl_context *ssl,
   5873                                                   const mbedtls_md_type_t md,
   5874                                                   unsigned char *dst,
   5875                                                   size_t dst_len,
   5876                                                   size_t *olen)
   5877          {
   5878              switch (md) {
   5879          
   5880          #if defined(MBEDTLS_MD_CAN_SHA384)
   5881                  case MBEDTLS_MD_SHA384:
   5882                      return ssl_get_handshake_transcript_sha384(ssl, dst, dst_len, olen);
   5883          #endif /* MBEDTLS_MD_CAN_SHA384*/
   5884          
   5885          #if defined(MBEDTLS_MD_CAN_SHA256)
   5886                  case MBEDTLS_MD_SHA256:
   5887                      return ssl_get_handshake_transcript_sha256(ssl, dst, dst_len, olen);
   5888          #endif /* MBEDTLS_MD_CAN_SHA256*/
   5889          
   5890                  default:
   5891          #if !defined(MBEDTLS_MD_CAN_SHA384) && \
   5892                      !defined(MBEDTLS_MD_CAN_SHA256)
   5893                      (void) ssl;
   5894                      (void) dst;
   5895                      (void) dst_len;
   5896                      (void) olen;
   5897          #endif
   5898                      break;
   5899              }
   5900              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   5901          }
   5902          
   5903          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   5904          
   5905          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   5906          /* mbedtls_ssl_parse_sig_alg_ext()
   5907           *
   5908           * The `extension_data` field of signature algorithm contains  a `SignatureSchemeList`
   5909           * value (TLS 1.3 RFC8446):
   5910           *      enum {
   5911           *         ....
   5912           *        ecdsa_secp256r1_sha256( 0x0403 ),
   5913           *        ecdsa_secp384r1_sha384( 0x0503 ),
   5914           *        ecdsa_secp521r1_sha512( 0x0603 ),
   5915           *         ....
   5916           *      } SignatureScheme;
   5917           *
   5918           *      struct {
   5919           *         SignatureScheme supported_signature_algorithms<2..2^16-2>;
   5920           *      } SignatureSchemeList;
   5921           *
   5922           * The `extension_data` field of signature algorithm contains a `SignatureAndHashAlgorithm`
   5923           * value (TLS 1.2 RFC5246):
   5924           *      enum {
   5925           *          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
   5926           *          sha512(6), (255)
   5927           *      } HashAlgorithm;
   5928           *
   5929           *      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
   5930           *        SignatureAlgorithm;
   5931           *
   5932           *      struct {
   5933           *          HashAlgorithm hash;
   5934           *          SignatureAlgorithm signature;
   5935           *      } SignatureAndHashAlgorithm;
   5936           *
   5937           *      SignatureAndHashAlgorithm
   5938           *        supported_signature_algorithms<2..2^16-2>;
   5939           *
   5940           * The TLS 1.3 signature algorithm extension was defined to be a compatible
   5941           * generalization of the TLS 1.2 signature algorithm extension.
   5942           * `SignatureAndHashAlgorithm` field of TLS 1.2 can be represented by
   5943           * `SignatureScheme` field of TLS 1.3
   5944           *
   5945           */

   \                                 In section .text, align 2, keep-with-next
   5946          int mbedtls_ssl_parse_sig_alg_ext(mbedtls_ssl_context *ssl,
   5947                                            const unsigned char *buf,
   5948                                            const unsigned char *end)
   5949          {
   \                     mbedtls_ssl_parse_sig_alg_ext: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4691             MOV      R9,R2
   5950              const unsigned char *p = buf;
   5951              size_t supported_sig_algs_len = 0;
   5952              const unsigned char *supported_sig_algs_end;
   5953              uint16_t sig_alg;
   5954              uint32_t common_idx = 0;
   5955          
   5956              MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 2);
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x4649             MOV      R1,R9
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x2400             MOVS     R4,#+0
   \       0x12   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD15A             BNE.N    ??mbedtls_ssl_parse_sig_alg_ext_0
   5957              supported_sig_algs_len = MBEDTLS_GET_UINT16_BE(p, 0);
   \       0x1A   0x....             LDR.N    R6,??DataTable31_4
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0xD103             BNE.N    ??mbedtls_ssl_parse_sig_alg_ext_1
   \       0x24   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x28   0x4680             MOV      R8,R0
   \       0x2A   0xE006             B.N      ??mbedtls_ssl_parse_sig_alg_ext_2
   \                     ??mbedtls_ssl_parse_sig_alg_ext_1: (+1)
   \       0x2C   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x30   0x0A01             LSRS     R1,R0,#+8
   \       0x32   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \       0x36   0xFA1F 0xF880      UXTH     R8,R0
   5958              p += 2;
   5959          
   5960              memset(ssl->handshake->received_sig_algs, 0,
   5961                     sizeof(ssl->handshake->received_sig_algs));
   \                     ??mbedtls_ssl_parse_sig_alg_ext_2: (+1)
   \       0x3A   0x6BB8             LDR      R0,[R7, #+56]
   \       0x3C   0x2128             MOVS     R1,#+40
   \       0x3E   0xF105 0x0A02      ADD      R10,R5,#+2
   \       0x42   0x301C             ADDS     R0,R0,#+28
   \       0x44   0x.... 0x....      BL       __aeabi_memclr4
   5962          
   5963              MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, supported_sig_algs_len);
   \       0x48   0x4642             MOV      R2,R8
   \       0x4A   0x4649             MOV      R1,R9
   \       0x4C   0x4650             MOV      R0,R10
   \       0x4E   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD13C             BNE.N    ??mbedtls_ssl_parse_sig_alg_ext_0
   5964              supported_sig_algs_end = p + supported_sig_algs_len;
   \       0x56   0x44D0             ADD      R8,R10,R8
   \       0x58   0xE005             B.N      ??mbedtls_ssl_parse_sig_alg_ext_3
   5965              while (p < supported_sig_algs_end) {
   5966                  MBEDTLS_SSL_CHK_BUF_READ_PTR(p, supported_sig_algs_end, 2);
   5967                  sig_alg = MBEDTLS_GET_UINT16_BE(p, 0);
   \                     ??mbedtls_ssl_parse_sig_alg_ext_4: (+1)
   \       0x5A   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x5E   0x0A05             LSRS     R5,R0,#+8
   \       0x60   0xEA45 0x2500      ORR      R5,R5,R0, LSL #+8
   \       0x64   0xE00E             B.N      ??mbedtls_ssl_parse_sig_alg_ext_5
   \                     ??mbedtls_ssl_parse_sig_alg_ext_3: (+1)
   \       0x66   0x45C2             CMP      R10,R8
   \       0x68   0xD230             BCS.N    ??mbedtls_ssl_parse_sig_alg_ext_6
   \       0x6A   0x2202             MOVS     R2,#+2
   \       0x6C   0x4641             MOV      R1,R8
   \       0x6E   0x4650             MOV      R0,R10
   \       0x70   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x74   0xBB60             CBNZ.N   R0,??mbedtls_ssl_parse_sig_alg_ext_0
   \       0x76   0x7830             LDRB     R0,[R6, #+0]
   \       0x78   0x2801             CMP      R0,#+1
   \       0x7A   0x4650             MOV      R0,R10
   \       0x7C   0xD1ED             BNE.N    ??mbedtls_ssl_parse_sig_alg_ext_4
   \       0x7E   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x82   0x4605             MOV      R5,R0
   5968                  p += 2;
   5969                  MBEDTLS_SSL_DEBUG_MSG(4, ("received signature algorithm: 0x%x %s",
   5970                                            sig_alg,
   5971                                            mbedtls_ssl_sig_alg_to_str(sig_alg)));
   5972          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5973                  if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2 &&
   5974                      (!(mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg) &&
   5975                         mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg)))) {
   \                     ??mbedtls_ssl_parse_sig_alg_ext_5: (+1)
   \       0x84   0xF9B7 0x1008      LDRSH    R1,[R7, #+8]
   \       0x88   0xF240 0x3003      MOVW     R0,#+771
   \       0x8C   0xF10A 0x0A02      ADD      R10,R10,#+2
   \       0x90   0x4281             CMP      R1,R0
   \       0x92   0xD112             BNE.N    ??mbedtls_ssl_parse_sig_alg_ext_7
   \       0x94   0xB2A9             UXTH     R1,R5
   \       0x96   0x4638             MOV      R0,R7
   \       0x98   0x.... 0x....      BL       mbedtls_ssl_sig_alg_is_supported
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD0E2             BEQ.N    ??mbedtls_ssl_parse_sig_alg_ext_3
   \       0xA0   0x4638             MOV      R0,R7
   \       0xA2   0x.... 0x....      BL       mbedtls_ssl_get_sig_algs
   \       0xA6   0x0001             MOVS     R1,R0
   \       0xA8   0xD0DD             BEQ.N    ??mbedtls_ssl_parse_sig_alg_ext_3
   \                     ??mbedtls_ssl_parse_sig_alg_ext_8: (+1)
   \       0xAA   0x8808             LDRH     R0,[R1, #+0]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD0DA             BEQ.N    ??mbedtls_ssl_parse_sig_alg_ext_3
   \       0xB0   0xF831 0x3B02      LDRH     R3,[R1], #+2
   \       0xB4   0xB2AA             UXTH     R2,R5
   \       0xB6   0x4293             CMP      R3,R2
   \       0xB8   0xD1F7             BNE.N    ??mbedtls_ssl_parse_sig_alg_ext_8
   5976                      continue;
   5977                  }
   5978          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5979          
   5980                  MBEDTLS_SSL_DEBUG_MSG(4, ("valid signature algorithm: %s",
   5981                                            mbedtls_ssl_sig_alg_to_str(sig_alg)));
   5982          
   5983                  if (common_idx + 1 < MBEDTLS_RECEIVED_SIG_ALGS_SIZE) {
   \                     ??mbedtls_ssl_parse_sig_alg_ext_7: (+1)
   \       0xBA   0x1C60             ADDS     R0,R4,#+1
   \       0xBC   0x2814             CMP      R0,#+20
   \       0xBE   0xD2D2             BCS.N    ??mbedtls_ssl_parse_sig_alg_ext_3
   5984                      ssl->handshake->received_sig_algs[common_idx] = sig_alg;
   \       0xC0   0x6BB9             LDR      R1,[R7, #+56]
   \       0xC2   0xEB01 0x0244      ADD      R2,R1,R4, LSL #+1
   \       0xC6   0x8395             STRH     R5,[R2, #+28]
   5985                      common_idx += 1;
   \       0xC8   0x4604             MOV      R4,R0
   \       0xCA   0xE7CC             B.N      ??mbedtls_ssl_parse_sig_alg_ext_3
   5986                  }
   5987              }
   5988              /* Check that we consumed all the message. */
   5989              if (p != end) {
   \                     ??mbedtls_ssl_parse_sig_alg_ext_6: (+1)
   \       0xCC   0x45CA             CMP      R10,R9
   \       0xCE   0xD004             BEQ.N    ??mbedtls_ssl_parse_sig_alg_ext_9
   5990                  MBEDTLS_SSL_DEBUG_MSG(1,
   5991                                        ("Signature algorithms extension length misaligned"));
   5992                  MBEDTLS_SSL_PEND_FATAL_ALERT(MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR,
   5993                                               MBEDTLS_ERR_SSL_DECODE_ERROR);
   \                     ??mbedtls_ssl_parse_sig_alg_ext_0: (+1)
   \       0xD0   0x.... 0x....      LDR.W    R4,??DataTable36
   \       0xD4   0x4622             MOV      R2,R4
   \       0xD6   0x2132             MOVS     R1,#+50
   \       0xD8   0xE004             B.N      ??mbedtls_ssl_parse_sig_alg_ext_10
   5994                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   5995              }
   5996          
   5997              if (common_idx == 0) {
   \                     ??mbedtls_ssl_parse_sig_alg_ext_9: (+1)
   \       0xDA   0xB944             CBNZ.N   R4,??mbedtls_ssl_parse_sig_alg_ext_11
   5998                  MBEDTLS_SSL_DEBUG_MSG(3, ("no signature algorithm in common"));
   5999                  MBEDTLS_SSL_PEND_FATAL_ALERT(MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE,
   6000                                               MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE);
   \       0xDC   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \       0xE0   0x4622             MOV      R2,R4
   \       0xE2   0x2128             MOVS     R1,#+40
   \                     ??mbedtls_ssl_parse_sig_alg_ext_10: (+1)
   \       0xE4   0x4638             MOV      R0,R7
   \       0xE6   0x.... 0x....      BL       mbedtls_ssl_pend_fatal_alert
   6001                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \       0xEA   0x4620             MOV      R0,R4
   \       0xEC   0xE004             B.N      ??mbedtls_ssl_parse_sig_alg_ext_12
   6002              }
   6003          
   6004              ssl->handshake->received_sig_algs[common_idx] = MBEDTLS_TLS_SIG_NONE;
   \                     ??mbedtls_ssl_parse_sig_alg_ext_11: (+1)
   \       0xEE   0x6BBA             LDR      R2,[R7, #+56]
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0xEB02 0x0144      ADD      R1,R2,R4, LSL #+1
   \       0xF6   0x8388             STRH     R0,[R1, #+28]
   6005              return 0;
   \                     ??mbedtls_ssl_parse_sig_alg_ext_12: (+1)
   \       0xF8   0xE8BD 0x87F0      POP      {R4-R10,PC}
   6006          }

   \                                 In section .rodata, align 4
   \   struct psa_key_attributes_s const v
   \                     `psa_key_attributes_init::v`:
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   \       0x24   0x0000'0000        DC32 0
   \       0x28   0x00               DC8 0
   \       0x29                      DS8 3
   \       0x2C   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \       0x34                      DS8 88

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   6007          
   6008          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   6009          
   6010          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   6011          
   6012          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   6013          
   6014          static psa_status_t setup_psa_key_derivation(psa_key_derivation_operation_t *derivation,
   6015                                                       mbedtls_svc_key_id_t key,
   6016                                                       psa_algorithm_t alg,
   6017                                                       const unsigned char *raw_psk, size_t raw_psk_length,
   6018                                                       const unsigned char *seed, size_t seed_length,
   6019                                                       const unsigned char *label, size_t label_length,
   6020                                                       const unsigned char *other_secret,
   6021                                                       size_t other_secret_length,
   6022                                                       size_t capacity)
   6023          {
   6024              psa_status_t status;
   6025          
   6026              status = psa_key_derivation_setup(derivation, alg);
   6027              if (status != PSA_SUCCESS) {
   6028                  return status;
   6029              }
   6030          
   6031              if (PSA_ALG_IS_TLS12_PRF(alg) || PSA_ALG_IS_TLS12_PSK_TO_MS(alg)) {
   6032                  status = psa_key_derivation_input_bytes(derivation,
   6033                                                          PSA_KEY_DERIVATION_INPUT_SEED,
   6034                                                          seed, seed_length);
   6035                  if (status != PSA_SUCCESS) {
   6036                      return status;
   6037                  }
   6038          
   6039                  if (other_secret != NULL) {
   6040                      status = psa_key_derivation_input_bytes(derivation,
   6041                                                              PSA_KEY_DERIVATION_INPUT_OTHER_SECRET,
   6042                                                              other_secret, other_secret_length);
   6043                      if (status != PSA_SUCCESS) {
   6044                          return status;
   6045                      }
   6046                  }
   6047          
   6048                  if (mbedtls_svc_key_id_is_null(key)) {
   6049                      status = psa_key_derivation_input_bytes(
   6050                          derivation, PSA_KEY_DERIVATION_INPUT_SECRET,
   6051                          raw_psk, raw_psk_length);
   6052                  } else {
   6053                      status = psa_key_derivation_input_key(
   6054                          derivation, PSA_KEY_DERIVATION_INPUT_SECRET, key);
   6055                  }
   6056                  if (status != PSA_SUCCESS) {
   6057                      return status;
   6058                  }
   6059          
   6060                  status = psa_key_derivation_input_bytes(derivation,
   6061                                                          PSA_KEY_DERIVATION_INPUT_LABEL,
   6062                                                          label, label_length);
   6063                  if (status != PSA_SUCCESS) {
   6064                      return status;
   6065                  }
   6066              } else {
   6067                  return PSA_ERROR_NOT_SUPPORTED;
   6068              }
   6069          
   6070              status = psa_key_derivation_set_capacity(derivation, capacity);
   6071              if (status != PSA_SUCCESS) {
   6072                  return status;
   6073              }
   6074          
   6075              return PSA_SUCCESS;
   6076          }
   6077          
   6078          #if defined(PSA_WANT_ALG_SHA_384) || \
   6079              defined(PSA_WANT_ALG_SHA_256)
   6080          MBEDTLS_CHECK_RETURN_CRITICAL
   6081          static int tls_prf_generic(mbedtls_md_type_t md_type,
   6082                                     const unsigned char *secret, size_t slen,
   6083                                     const char *label,
   6084                                     const unsigned char *random, size_t rlen,
   6085                                     unsigned char *dstbuf, size_t dlen)
   6086          {
   6087              psa_status_t status;
   6088              psa_algorithm_t alg;
   6089              mbedtls_svc_key_id_t master_key = MBEDTLS_SVC_KEY_ID_INIT;
   6090              psa_key_derivation_operation_t derivation =
   6091                  PSA_KEY_DERIVATION_OPERATION_INIT;
   6092          
   6093              if (md_type == MBEDTLS_MD_SHA384) {
   6094                  alg = PSA_ALG_TLS12_PRF(PSA_ALG_SHA_384);
   6095              } else {
   6096                  alg = PSA_ALG_TLS12_PRF(PSA_ALG_SHA_256);
   6097              }
   6098          
   6099              /* Normally a "secret" should be long enough to be impossible to
   6100               * find by brute force, and in particular should not be empty. But
   6101               * this PRF is also used to derive an IV, in particular in EAP-TLS,
   6102               * and for this use case it makes sense to have a 0-length "secret".
   6103               * Since the key API doesn't allow importing a key of length 0,
   6104               * keep master_key=0, which setup_psa_key_derivation() understands
   6105               * to mean a 0-length "secret" input. */
   6106              if (slen != 0) {
   6107                  psa_key_attributes_t key_attributes = psa_key_attributes_init();
   6108                  psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
   6109                  psa_set_key_algorithm(&key_attributes, alg);
   6110                  psa_set_key_type(&key_attributes, PSA_KEY_TYPE_DERIVE);
   6111          
   6112                  status = psa_import_key(&key_attributes, secret, slen, &master_key);
   6113                  if (status != PSA_SUCCESS) {
   6114                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6115                  }
   6116              }
   6117          
   6118              status = setup_psa_key_derivation(&derivation,
   6119                                                master_key, alg,
   6120                                                NULL, 0,
   6121                                                random, rlen,
   6122                                                (unsigned char const *) label,
   6123                                                (size_t) strlen(label),
   6124                                                NULL, 0,
   6125                                                dlen);
   6126              if (status != PSA_SUCCESS) {
   6127                  psa_key_derivation_abort(&derivation);
   6128                  psa_destroy_key(master_key);
   6129                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6130              }
   6131          
   6132              status = psa_key_derivation_output_bytes(&derivation, dstbuf, dlen);
   6133              if (status != PSA_SUCCESS) {
   6134                  psa_key_derivation_abort(&derivation);
   6135                  psa_destroy_key(master_key);
   6136                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6137              }
   6138          
   6139              status = psa_key_derivation_abort(&derivation);
   6140              if (status != PSA_SUCCESS) {
   6141                  psa_destroy_key(master_key);
   6142                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6143              }
   6144          
   6145              if (!mbedtls_svc_key_id_is_null(master_key)) {
   6146                  status = psa_destroy_key(master_key);
   6147              }
   6148              if (status != PSA_SUCCESS) {
   6149                  return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6150              }
   6151          
   6152              return 0;
   6153          }
   6154          #endif /* PSA_WANT_ALG_SHA_256 || PSA_WANT_ALG_SHA_384 */
   6155          #else /* MBEDTLS_USE_PSA_CRYPTO */
   6156          
   6157          #if defined(MBEDTLS_MD_C) &&       \
   6158              (defined(MBEDTLS_MD_CAN_SHA256) || \
   6159              defined(MBEDTLS_MD_CAN_SHA384))
   6160          MBEDTLS_CHECK_RETURN_CRITICAL
   6161          static int tls_prf_generic(mbedtls_md_type_t md_type,
   6162                                     const unsigned char *secret, size_t slen,
   6163                                     const char *label,
   6164                                     const unsigned char *random, size_t rlen,
   6165                                     unsigned char *dstbuf, size_t dlen)
   6166          {
   6167              size_t nb;
   6168              size_t i, j, k, md_len;
   6169              unsigned char *tmp;
   6170              size_t tmp_len = 0;
   6171              unsigned char h_i[MBEDTLS_MD_MAX_SIZE];
   6172              const mbedtls_md_info_t *md_info;
   6173              mbedtls_md_context_t md_ctx;
   6174              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   6175          
   6176              mbedtls_md_init(&md_ctx);
   6177          
   6178              if ((md_info = mbedtls_md_info_from_type(md_type)) == NULL) {
   6179                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6180              }
   6181          
   6182              md_len = mbedtls_md_get_size(md_info);
   6183          
   6184              tmp_len = md_len + strlen(label) + rlen;
   6185              tmp = mbedtls_calloc(1, tmp_len);
   6186              if (tmp == NULL) {
   6187                  ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
   6188                  goto exit;
   6189              }
   6190          
   6191              nb = strlen(label);
   6192              memcpy(tmp + md_len, label, nb);
   6193              memcpy(tmp + md_len + nb, random, rlen);
   6194              nb += rlen;
   6195          
   6196              /*
   6197               * Compute P_<hash>(secret, label + random)[0..dlen]
   6198               */
   6199              if ((ret = mbedtls_md_setup(&md_ctx, md_info, 1)) != 0) {
   6200                  goto exit;
   6201              }
   6202          
   6203              ret = mbedtls_md_hmac_starts(&md_ctx, secret, slen);
   6204              if (ret != 0) {
   6205                  goto exit;
   6206              }
   6207              ret = mbedtls_md_hmac_update(&md_ctx, tmp + md_len, nb);
   6208              if (ret != 0) {
   6209                  goto exit;
   6210              }
   6211              ret = mbedtls_md_hmac_finish(&md_ctx, tmp);
   6212              if (ret != 0) {
   6213                  goto exit;
   6214              }
   6215          
   6216              for (i = 0; i < dlen; i += md_len) {
   6217                  ret = mbedtls_md_hmac_reset(&md_ctx);
   6218                  if (ret != 0) {
   6219                      goto exit;
   6220                  }
   6221                  ret = mbedtls_md_hmac_update(&md_ctx, tmp, md_len + nb);
   6222                  if (ret != 0) {
   6223                      goto exit;
   6224                  }
   6225                  ret = mbedtls_md_hmac_finish(&md_ctx, h_i);
   6226                  if (ret != 0) {
   6227                      goto exit;
   6228                  }
   6229          
   6230                  ret = mbedtls_md_hmac_reset(&md_ctx);
   6231                  if (ret != 0) {
   6232                      goto exit;
   6233                  }
   6234                  ret = mbedtls_md_hmac_update(&md_ctx, tmp, md_len);
   6235                  if (ret != 0) {
   6236                      goto exit;
   6237                  }
   6238                  ret = mbedtls_md_hmac_finish(&md_ctx, tmp);
   6239                  if (ret != 0) {
   6240                      goto exit;
   6241                  }
   6242          
   6243                  k = (i + md_len > dlen) ? dlen % md_len : md_len;
   6244          
   6245                  for (j = 0; j < k; j++) {
   6246                      dstbuf[i + j]  = h_i[j];
   6247                  }
   6248              }
   6249          
   6250          exit:
   6251              mbedtls_md_free(&md_ctx);
   6252          
   6253              if (tmp != NULL) {
   6254                  mbedtls_platform_zeroize(tmp, tmp_len);
   6255              }
   6256          
   6257              mbedtls_platform_zeroize(h_i, sizeof(h_i));
   6258          
   6259              mbedtls_free(tmp);
   6260          
   6261              return ret;
   6262          }
   6263          #endif /* MBEDTLS_MD_C && ( MBEDTLS_MD_CAN_SHA256 || MBEDTLS_MD_CAN_SHA384 ) */
   6264          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   6265          
   6266          #if defined(MBEDTLS_MD_CAN_SHA256)
   6267          MBEDTLS_CHECK_RETURN_CRITICAL

   \                                 In section .text, align 2, keep-with-next
   6268          static int tls_prf_sha256(const unsigned char *secret, size_t slen,
   6269                                    const char *label,
   6270                                    const unsigned char *random, size_t rlen,
   6271                                    unsigned char *dstbuf, size_t dlen)
   6272          {
   \                     tls_prf_sha256: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xB0A4             SUB      SP,SP,#+144
   6273              return tls_prf_generic(MBEDTLS_MD_SHA256, secret, slen,
   6274                                     label, random, rlen, dstbuf, dlen);
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x4681             MOV      R9,R0
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x9100             STR      R1,[SP, #+0]
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable36_2
   \       0x14   0x4698             MOV      R8,R3
   \       0x16   0xA80A             ADD      R0,SP,#+40
   \       0x18   0xF105 0x0124      ADD      R1,R5,#+36
   \       0x1C   0x2268             MOVS     R2,#+104
   \       0x1E   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x22   0x.... 0x....      LDR.W    R7,??DataTable36_3
   \       0x26   0xB1BC             CBZ.N    R4,??tls_prf_sha256_0
   \       0x28   0xA801             ADD      R0,SP,#+4
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x2224             MOVS     R2,#+36
   \       0x2E   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x32   0xF44F 0x4180      MOV      R1,#+16384
   \       0x36   0xA801             ADD      R0,SP,#+4
   \       0x38   0x.... 0x....      BL       psa_set_key_usage_flags
   \       0x3C   0x9705             STR      R7,[SP, #+20]
   \       0x3E   0xF44F 0x5190      MOV      R1,#+4608
   \       0x42   0xA801             ADD      R0,SP,#+4
   \       0x44   0x.... 0x....      BL       psa_set_key_type
   \       0x48   0x466B             MOV      R3,SP
   \       0x4A   0x4622             MOV      R2,R4
   \       0x4C   0x4649             MOV      R1,R9
   \       0x4E   0xA801             ADD      R0,SP,#+4
   \       0x50   0x.... 0x....      BL       psa_import_key
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD142             BNE.N    ??tls_prf_sha256_1
   \                     ??tls_prf_sha256_0: (+1)
   \       0x58   0x4630             MOV      R0,R6
   \       0x5A   0x.... 0x....      BL       strlen
   \       0x5E   0x4605             MOV      R5,R0
   \       0x60   0x9C00             LDR      R4,[SP, #+0]
   \       0x62   0x4639             MOV      R1,R7
   \       0x64   0xA80A             ADD      R0,SP,#+40
   \       0x66   0x.... 0x....      BL       psa_key_derivation_setup
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD13E             BNE.N    ??tls_prf_sha256_2
   \       0x6E   0x9B2C             LDR      R3,[SP, #+176]
   \       0x70   0x4642             MOV      R2,R8
   \       0x72   0xF44F 0x7101      MOV      R1,#+516
   \       0x76   0xA80A             ADD      R0,SP,#+40
   \       0x78   0x.... 0x....      BL       psa_key_derivation_input_bytes
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD135             BNE.N    ??tls_prf_sha256_2
   \       0x80   0xF240 0x1101      MOVW     R1,#+257
   \       0x84   0xB92C             CBNZ.N   R4,??tls_prf_sha256_3
   \       0x86   0x2300             MOVS     R3,#+0
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0xA80A             ADD      R0,SP,#+40
   \       0x8C   0x.... 0x....      BL       psa_key_derivation_input_bytes
   \       0x90   0xE003             B.N      ??tls_prf_sha256_4
   \                     ??tls_prf_sha256_3: (+1)
   \       0x92   0x4622             MOV      R2,R4
   \       0x94   0xA80A             ADD      R0,SP,#+40
   \       0x96   0x.... 0x....      BL       psa_key_derivation_input_key
   \                     ??tls_prf_sha256_4: (+1)
   \       0x9A   0xBB38             CBNZ.N   R0,??tls_prf_sha256_2
   \       0x9C   0x462B             MOV      R3,R5
   \       0x9E   0x4632             MOV      R2,R6
   \       0xA0   0xF240 0x2101      MOVW     R1,#+513
   \       0xA4   0xA80A             ADD      R0,SP,#+40
   \       0xA6   0x.... 0x....      BL       psa_key_derivation_input_bytes
   \       0xAA   0xB9F8             CBNZ.N   R0,??tls_prf_sha256_2
   \       0xAC   0x9C2E             LDR      R4,[SP, #+184]
   \       0xAE   0xA80A             ADD      R0,SP,#+40
   \       0xB0   0x4621             MOV      R1,R4
   \       0xB2   0x.... 0x....      BL       psa_key_derivation_set_capacity
   \       0xB6   0xB9C8             CBNZ.N   R0,??tls_prf_sha256_2
   \       0xB8   0x992D             LDR      R1,[SP, #+180]
   \       0xBA   0x4622             MOV      R2,R4
   \       0xBC   0xA80A             ADD      R0,SP,#+40
   \       0xBE   0x.... 0x....      BL       psa_key_derivation_output_bytes
   \       0xC2   0xB998             CBNZ.N   R0,??tls_prf_sha256_2
   \       0xC4   0xA80A             ADD      R0,SP,#+40
   \       0xC6   0x.... 0x....      BL       psa_key_derivation_abort
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0x9800             LDR      R0,[SP, #+0]
   \       0xCE   0xD002             BEQ.N    ??tls_prf_sha256_5
   \                     ??tls_prf_sha256_6: (+1)
   \       0xD0   0x.... 0x....      BL       psa_destroy_key
   \       0xD4   0xE003             B.N      ??tls_prf_sha256_1
   \                     ??tls_prf_sha256_5: (+1)
   \       0xD6   0xB138             CBZ.N    R0,??tls_prf_sha256_7
   \       0xD8   0x.... 0x....      BL       psa_destroy_key
   \       0xDC   0xB120             CBZ.N    R0,??tls_prf_sha256_7
   \                     ??tls_prf_sha256_1: (+1)
   \       0xDE   0x.... 0x....      LDR.W    R0,??DataTable37
   \                     ??tls_prf_sha256_8: (+1)
   \       0xE2   0xB025             ADD      SP,SP,#+148
   \       0xE4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??tls_prf_sha256_7: (+1)
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0xE7FA             B.N      ??tls_prf_sha256_8
   \                     ??tls_prf_sha256_2: (+1)
   \       0xEC   0xA80A             ADD      R0,SP,#+40
   \       0xEE   0x.... 0x....      BL       psa_key_derivation_abort
   \       0xF2   0x9800             LDR      R0,[SP, #+0]
   \       0xF4   0xE7EC             B.N      ??tls_prf_sha256_6
   6275          }
   6276          #endif /* MBEDTLS_MD_CAN_SHA256*/
   6277          
   6278          #if defined(MBEDTLS_MD_CAN_SHA384)
   6279          MBEDTLS_CHECK_RETURN_CRITICAL
   6280          static int tls_prf_sha384(const unsigned char *secret, size_t slen,
   6281                                    const char *label,
   6282                                    const unsigned char *random, size_t rlen,
   6283                                    unsigned char *dstbuf, size_t dlen)
   6284          {
   6285              return tls_prf_generic(MBEDTLS_MD_SHA384, secret, slen,
   6286                                     label, random, rlen, dstbuf, dlen);
   6287          }
   6288          #endif /* MBEDTLS_MD_CAN_SHA384*/
   6289          
   6290          /*
   6291           * Set appropriate PRF function and other SSL / TLS1.2 functions
   6292           *
   6293           * Inputs:
   6294           * - hash associated with the ciphersuite (only used by TLS 1.2)
   6295           *
   6296           * Outputs:
   6297           * - the tls_prf, calc_verify and calc_finished members of handshake structure
   6298           */
   6299          MBEDTLS_CHECK_RETURN_CRITICAL
   6300          static int ssl_set_handshake_prfs(mbedtls_ssl_handshake_params *handshake,
   6301                                            mbedtls_md_type_t hash)
   6302          {
   6303          #if defined(MBEDTLS_MD_CAN_SHA384)
   6304              if (hash == MBEDTLS_MD_SHA384) {
   6305                  handshake->tls_prf = tls_prf_sha384;
   6306                  handshake->calc_verify = ssl_calc_verify_tls_sha384;
   6307                  handshake->calc_finished = ssl_calc_finished_tls_sha384;
   6308              } else
   6309          #endif
   6310          #if defined(MBEDTLS_MD_CAN_SHA256)
   6311              {
   6312                  (void) hash;
   6313                  handshake->tls_prf = tls_prf_sha256;
   6314                  handshake->calc_verify = ssl_calc_verify_tls_sha256;
   6315                  handshake->calc_finished = ssl_calc_finished_tls_sha256;
   6316              }
   6317          #else
   6318              {
   6319                  (void) handshake;
   6320                  (void) hash;
   6321                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6322              }
   6323          #endif
   6324          
   6325              return 0;
   6326          }
   6327          
   6328          /*
   6329           * Compute master secret if needed
   6330           *
   6331           * Parameters:
   6332           * [in/out] handshake
   6333           *          [in] resume, premaster, extended_ms, calc_verify, tls_prf
   6334           *               (PSA-PSK) ciphersuite_info, psk_opaque
   6335           *          [out] premaster (cleared)
   6336           * [out] master
   6337           * [in] ssl: optionally used for debugging, EMS and PSA-PSK
   6338           *      debug: conf->f_dbg, conf->p_dbg
   6339           *      EMS: passed to calc_verify (debug + session_negotiate)
   6340           *      PSA-PSA: conf
   6341           */
   6342          MBEDTLS_CHECK_RETURN_CRITICAL
   6343          static int ssl_compute_master(mbedtls_ssl_handshake_params *handshake,
   6344                                        unsigned char *master,
   6345                                        const mbedtls_ssl_context *ssl)
   6346          {
   6347              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   6348          
   6349              /* cf. RFC 5246, Section 8.1:
   6350               * "The master secret is always exactly 48 bytes in length." */
   6351              size_t const master_secret_len = 48;
   6352          
   6353          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   6354              unsigned char session_hash[48];
   6355          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   6356          
   6357              /* The label for the KDF used for key expansion.
   6358               * This is either "master secret" or "extended master secret"
   6359               * depending on whether the Extended Master Secret extension
   6360               * is used. */
   6361              char const *lbl = "master secret";
   6362          
   6363              /* The seed for the KDF used for key expansion.
   6364               * - If the Extended Master Secret extension is not used,
   6365               *   this is ClientHello.Random + ServerHello.Random
   6366               *   (see Sect. 8.1 in RFC 5246).
   6367               * - If the Extended Master Secret extension is used,
   6368               *   this is the transcript of the handshake so far.
   6369               *   (see Sect. 4 in RFC 7627). */
   6370              unsigned char const *seed = handshake->randbytes;
   6371              size_t seed_len = 64;
   6372          
   6373          #if !defined(MBEDTLS_DEBUG_C) &&                    \
   6374              !defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET) && \
   6375              !(defined(MBEDTLS_USE_PSA_CRYPTO) &&            \
   6376              defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED))
   6377              ssl = NULL; /* make sure we don't use it except for those cases */
   6378              (void) ssl;
   6379          #endif
   6380          
   6381              if (handshake->resume != 0) {
   6382                  MBEDTLS_SSL_DEBUG_MSG(3, ("no premaster (session resumed)"));
   6383                  return 0;
   6384              }
   6385          
   6386          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   6387              if (handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED) {
   6388                  lbl  = "extended master secret";
   6389                  seed = session_hash;
   6390                  ret = handshake->calc_verify(ssl, session_hash, &seed_len);
   6391                  if (ret != 0) {
   6392                      MBEDTLS_SSL_DEBUG_RET(1, "calc_verify", ret);
   6393                  }
   6394          
   6395                  MBEDTLS_SSL_DEBUG_BUF(3, "session hash for extended master secret",
   6396                                        session_hash, seed_len);
   6397              }
   6398          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   6399          
   6400          #if defined(MBEDTLS_USE_PSA_CRYPTO) &&                   \
   6401              defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   6402              if (mbedtls_ssl_ciphersuite_uses_psk(handshake->ciphersuite_info) == 1) {
   6403                  /* Perform PSK-to-MS expansion in a single step. */
   6404                  psa_status_t status;
   6405                  psa_algorithm_t alg;
   6406                  mbedtls_svc_key_id_t psk;
   6407                  psa_key_derivation_operation_t derivation =
   6408                      PSA_KEY_DERIVATION_OPERATION_INIT;
   6409                  mbedtls_md_type_t hash_alg = (mbedtls_md_type_t) handshake->ciphersuite_info->mac;
   6410          
   6411                  MBEDTLS_SSL_DEBUG_MSG(2, ("perform PSA-based PSK-to-MS expansion"));
   6412          
   6413                  psk = mbedtls_ssl_get_opaque_psk(ssl);
   6414          
   6415                  if (hash_alg == MBEDTLS_MD_SHA384) {
   6416                      alg = PSA_ALG_TLS12_PSK_TO_MS(PSA_ALG_SHA_384);
   6417                  } else {
   6418                      alg = PSA_ALG_TLS12_PSK_TO_MS(PSA_ALG_SHA_256);
   6419                  }
   6420          
   6421                  size_t other_secret_len = 0;
   6422                  unsigned char *other_secret = NULL;
   6423          
   6424                  switch (handshake->ciphersuite_info->key_exchange) {
   6425                      /* Provide other secret.
   6426                       * Other secret is stored in premaster, where first 2 bytes hold the
   6427                       * length of the other key.
   6428                       */
   6429                      case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
   6430                          /* For RSA-PSK other key length is always 48 bytes. */
   6431                          other_secret_len = 48;
   6432                          other_secret = handshake->premaster + 2;
   6433                          break;
   6434                      case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
   6435                      case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
   6436                          other_secret_len = MBEDTLS_GET_UINT16_BE(handshake->premaster, 0);
   6437                          other_secret = handshake->premaster + 2;
   6438                          break;
   6439                      default:
   6440                          break;
   6441                  }
   6442          
   6443                  status = setup_psa_key_derivation(&derivation, psk, alg,
   6444                                                    ssl->conf->psk, ssl->conf->psk_len,
   6445                                                    seed, seed_len,
   6446                                                    (unsigned char const *) lbl,
   6447                                                    (size_t) strlen(lbl),
   6448                                                    other_secret, other_secret_len,
   6449                                                    master_secret_len);
   6450                  if (status != PSA_SUCCESS) {
   6451                      psa_key_derivation_abort(&derivation);
   6452                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6453                  }
   6454          
   6455                  status = psa_key_derivation_output_bytes(&derivation,
   6456                                                           master,
   6457                                                           master_secret_len);
   6458                  if (status != PSA_SUCCESS) {
   6459                      psa_key_derivation_abort(&derivation);
   6460                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6461                  }
   6462          
   6463                  status = psa_key_derivation_abort(&derivation);
   6464                  if (status != PSA_SUCCESS) {
   6465                      return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6466                  }
   6467              } else
   6468          #endif
   6469              {
   6470          #if defined(MBEDTLS_USE_PSA_CRYPTO) &&                              \
   6471                  defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   6472                  if (handshake->ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE) {
   6473                      psa_status_t status;
   6474                      psa_algorithm_t alg = PSA_ALG_TLS12_ECJPAKE_TO_PMS;
   6475                      psa_key_derivation_operation_t derivation =
   6476                          PSA_KEY_DERIVATION_OPERATION_INIT;
   6477          
   6478                      MBEDTLS_SSL_DEBUG_MSG(2, ("perform PSA-based PMS KDF for ECJPAKE"));
   6479          
   6480                      handshake->pmslen = PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE;
   6481          
   6482          #if defined(SLI_MBEDTLS_PSA_EC_JPAKE_TLS_WORKAROUND)
   6483                      (void)derivation;
   6484                      (void)alg;
   6485                      status = psa_pake_derive_secret(&handshake->psa_pake_ctx,
   6486                                                      handshake->premaster,
   6487                                                      handshake->pmslen);
   6488                      if (status != PSA_SUCCESS) {
   6489                          return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6490                      }
   6491          #else
   6492                      status = psa_key_derivation_setup(&derivation, alg);
   6493                      if (status != PSA_SUCCESS) {
   6494                          return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6495                      }
   6496          
   6497                      status = psa_key_derivation_set_capacity(&derivation,
   6498                                                               PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE);
   6499                      if (status != PSA_SUCCESS) {
   6500                          psa_key_derivation_abort(&derivation);
   6501                          return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6502                      }
   6503          
   6504                      status = psa_pake_get_implicit_key(&handshake->psa_pake_ctx,
   6505                                                         &derivation);
   6506                      if (status != PSA_SUCCESS) {
   6507                          psa_key_derivation_abort(&derivation);
   6508                          return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6509                      }
   6510          
   6511                      status = psa_key_derivation_output_bytes(&derivation,
   6512                                                               handshake->premaster,
   6513                                                               handshake->pmslen);
   6514                      if (status != PSA_SUCCESS) {
   6515                          psa_key_derivation_abort(&derivation);
   6516                          return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6517                      }
   6518          
   6519                      status = psa_key_derivation_abort(&derivation);
   6520                      if (status != PSA_SUCCESS) {
   6521                          return MBEDTLS_ERR_SSL_HW_ACCEL_FAILED;
   6522                      }
   6523          #endif // SLI_MBEDTLS_PSA_EC_JPAKE_TLS_WORKAROUND
   6524                  }
   6525          #endif
   6526                  ret = handshake->tls_prf(handshake->premaster, handshake->pmslen,
   6527                                           lbl, seed, seed_len,
   6528                                           master,
   6529                                           master_secret_len);
   6530                  if (ret != 0) {
   6531                      MBEDTLS_SSL_DEBUG_RET(1, "prf", ret);
   6532                      return ret;
   6533                  }
   6534          
   6535                  MBEDTLS_SSL_DEBUG_BUF(3, "premaster secret",
   6536                                        handshake->premaster,
   6537                                        handshake->pmslen);
   6538          
   6539                  mbedtls_platform_zeroize(handshake->premaster,
   6540                                           sizeof(handshake->premaster));
   6541              }
   6542          
   6543              return 0;
   6544          }
   6545          

   \                                 In section .text, align 2, keep-with-next
   6546          int mbedtls_ssl_derive_keys(mbedtls_ssl_context *ssl)
   6547          {
   \                     mbedtls_ssl_derive_keys: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB0D3             SUB      SP,SP,#+332
   \        0x6   0x4607             MOV      R7,R0
   6548              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   6549              const mbedtls_ssl_ciphersuite_t * const ciphersuite_info =
   6550                  ssl->handshake->ciphersuite_info;
   6551          
   6552              MBEDTLS_SSL_DEBUG_MSG(2, ("=> derive keys"));
   6553          
   6554              /* Set PRF, calc_verify and calc_finished function pointers */
   6555              ret = ssl_set_handshake_prfs(ssl->handshake,
   6556                                           (mbedtls_md_type_t) ciphersuite_info->mac);
   \        0x8   0x6BBD             LDR      R5,[R7, #+56]
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable37_1
   \        0xE   0x.... 0x....      ADR.W    R0,ssl_calc_verify_tls_sha256
   \       0x12   0x61A9             STR      R1,[R5, #+24]
   \       0x14   0x.... 0x....      ADR.W    R1,ssl_calc_finished_tls_sha256
   \       0x18   0x6128             STR      R0,[R5, #+16]
   \       0x1A   0x6169             STR      R1,[R5, #+20]
   6557              if (ret != 0) {
   6558                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_set_handshake_prfs", ret);
   6559                  return ret;
   6560              }
   6561          
   6562              /* Compute master secret if needed */
   6563              ret = ssl_compute_master(ssl->handshake,
   6564                                       ssl->session_negotiate->master,
   6565                                       ssl);
   \       0x1C   0x7828             LDRB     R0,[R5, #+0]
   \       0x1E   0xB9B8             CBNZ.N   R0,??mbedtls_ssl_derive_keys_0
   \       0x20   0x2130             MOVS     R1,#+48
   \       0x22   0x9102             STR      R1,[SP, #+8]
   \       0x24   0x6B78             LDR      R0,[R7, #+52]
   \       0x26   0x2140             MOVS     R1,#+64
   \       0x28   0xF505 0x73FC      ADD      R3,R5,#+504
   \       0x2C   0x302C             ADDS     R0,R0,#+44
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   \       0x30   0x9100             STR      R1,[SP, #+0]
   \       0x32   0xF8D5 0x1258      LDR      R1,[R5, #+600]
   \       0x36   0xF505 0x740E      ADD      R4,R5,#+568
   \       0x3A   0x69AD             LDR      R5,[R5, #+24]
   \       0x3C   0x.... 0x....      ADR.W    R2,?_10
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x47A8             BLX      R5
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD16E             BNE.N    ??mbedtls_ssl_derive_keys_1
   6566              if (ret != 0) {
   6567                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_compute_master", ret);
   6568                  return ret;
   \       0x48   0x2120             MOVS     R1,#+32
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x.... 0x....      BL       mbedtls_platform_zeroize
   6569              }
   6570          
   6571              /* Swap the client and server random values:
   6572               * - MS derivation wanted client+server (RFC 5246 8.1)
   6573               * - key derivation wants server+client (RFC 5246 6.3) */
   6574              {
   6575                  unsigned char tmp[64];
   6576                  memcpy(tmp, ssl->handshake->randbytes, 64);
   \                     ??mbedtls_ssl_derive_keys_0: (+1)
   \       0x50   0x6BB8             LDR      R0,[R7, #+56]
   \       0x52   0x2240             MOVS     R2,#+64
   6577                  memcpy(ssl->handshake->randbytes, tmp + 32, 32);
   6578                  memcpy(ssl->handshake->randbytes + 32, tmp, 32);
   6579                  mbedtls_platform_zeroize(tmp, sizeof(tmp));
   \       0x54   0x46B8             MOV      R8,R7
   \       0x56   0xF500 0x74FC      ADD      R4,R0,#+504
   \       0x5A   0x4621             MOV      R1,R4
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x62   0x2220             MOVS     R2,#+32
   \       0x64   0xA908             ADD      R1,SP,#+32
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x6C   0x6BB8             LDR      R0,[R7, #+56]
   \       0x6E   0x2220             MOVS     R2,#+32
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0xF500 0x7006      ADD      R0,R0,#+536
   \       0x76   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x7A   0x2140             MOVS     R1,#+64
   \       0x7C   0x4668             MOV      R0,SP
   \       0x7E   0x.... 0x....      BL       mbedtls_platform_zeroize
   6580              }
   6581          
   6582              /* Populate transform structure */
   6583              ret = ssl_tls12_populate_transform(ssl->transform_negotiate,
   6584                                                 ssl->session_negotiate->ciphersuite,
   6585                                                 ssl->session_negotiate->master,
   6586          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   6587                                                 ssl->session_negotiate->encrypt_then_mac,
   6588          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   6589                                                 ssl->handshake->tls_prf,
   6590                                                 ssl->handshake->randbytes,
   6591                                                 ssl->tls_version,
   6592                                                 ssl->conf->endpoint,
   6593                                                 ssl);
   \       0x82   0x6839             LDR      R1,[R7, #+0]
   \       0x84   0x2500             MOVS     R5,#+0
   \       0x86   0x7908             LDRB     R0,[R1, #+4]
   \       0x88   0x9007             STR      R0,[SP, #+28]
   \       0x8A   0xF9B7 0x1008      LDRSH    R1,[R7, #+8]
   \       0x8E   0xF8AD 0x100E      STRH     R1,[SP, #+14]
   \       0x92   0x6BB8             LDR      R0,[R7, #+56]
   \       0x94   0xF500 0x71FC      ADD      R1,R0,#+504
   \       0x98   0x9106             STR      R1,[SP, #+24]
   \       0x9A   0xF8D0 0x9018      LDR      R9,[R0, #+24]
   \       0x9E   0x6B78             LDR      R0,[R7, #+52]
   \       0xA0   0xF100 0x012C      ADD      R1,R0,#+44
   \       0xA4   0x9109             STR      R1,[SP, #+36]
   \       0xA6   0x6844             LDR      R4,[R0, #+4]
   \       0xA8   0x6CBE             LDR      R6,[R7, #+72]
   \       0xAA   0xA80A             ADD      R0,SP,#+40
   \       0xAC   0x2124             MOVS     R1,#+36
   \       0xAE   0x.... 0x....      BL       __aeabi_memclr4
   \       0xB2   0xF8D8 0x00C8      LDR      R0,[R8, #+200]
   \       0xB6   0xB900             CBNZ.N   R0,??mbedtls_ssl_derive_keys_2
   \       0xB8   0x46A8             MOV      R8,R5
   \                     ??mbedtls_ssl_derive_keys_2: (+1)
   \       0xBA   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \       0xBE   0xF8A6 0x0040      STRH     R0,[R6, #+64]
   \       0xC2   0x4620             MOV      R0,R4
   \       0xC4   0x.... 0x....      BL       mbedtls_ssl_ciphersuite_from_id
   \       0xC8   0xEA5F 0x0A00      MOVS     R10,R0
   \       0xCC   0xF000 0x8185      BEQ.W    ??mbedtls_ssl_derive_keys_3
   \       0xD0   0x.... 0x....      BL       mbedtls_ssl_get_mode_from_ciphersuite
   \       0xD4   0x4604             MOV      R4,R0
   \       0xD6   0x2C03             CMP      R4,#+3
   \       0xD8   0xD106             BNE.N    ??mbedtls_ssl_derive_keys_4
   \       0xDA   0xF89A 0x100B      LDRB     R1,[R10, #+11]
   \       0xDE   0x0788             LSLS     R0,R1,#+30
   \       0xE0   0xBF4C             ITE      MI
   \       0xE2   0x2008             MOVMI    R0,#+8
   \       0xE4   0x2010             MOVPL    R0,#+16
   \       0xE6   0x6130             STR      R0,[R6, #+16]
   \                     ??mbedtls_ssl_derive_keys_4: (+1)
   \       0xE8   0xA805             ADD      R0,SP,#+20
   \       0xEA   0x9000             STR      R0,[SP, #+0]
   \       0xEC   0x6931             LDR      R1,[R6, #+16]
   \       0xEE   0xF89A 0x0008      LDRB     R0,[R10, #+8]
   \       0xF2   0xAB03             ADD      R3,SP,#+12
   \       0xF4   0xAA04             ADD      R2,SP,#+16
   \       0xF6   0x.... 0x....      BL       mbedtls_ssl_cipher_to_psa
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xF040 0x8155      BNE.W    ??mbedtls_ssl_derive_keys_5
   \      0x100   0xF89A 0x0009      LDRB     R0,[R10, #+9]
   \      0x104   0xF44F 0x7180      MOV      R1,#+256
   \      0x108   0x2240             MOVS     R2,#+64
   \      0x10A   0xF040 0x7B00      ORR      R11,R0,#0x2000000
   \      0x10E   0xA813             ADD      R0,SP,#+76
   \      0x110   0x9001             STR      R0,[SP, #+4]
   \      0x112   0x9B06             LDR      R3,[SP, #+24]
   \      0x114   0x9809             LDR      R0,[SP, #+36]
   \      0x116   0x9102             STR      R1,[SP, #+8]
   \      0x118   0x9200             STR      R2,[SP, #+0]
   \      0x11A   0x.... 0x....      ADR.W    R2,?_13
   \      0x11E   0x2130             MOVS     R1,#+48
   \      0x120   0x47C8             BLX      R9
   \      0x122   0xEA5F 0x0A00      MOVS     R10,R0
   \                     ??mbedtls_ssl_derive_keys_1: (+1)
   \      0x126   0xF040 0x8155      BNE.W    ??mbedtls_ssl_derive_keys_6
   \      0x12A   0x9905             LDR      R1,[SP, #+20]
   \      0x12C   0xF242 0x0E04      MOVW     LR,#+8196
   \      0x130   0x1DC9             ADDS     R1,R1,#+7
   \      0x132   0x2C03             CMP      R4,#+3
   \      0x134   0xD110             BNE.N    ??mbedtls_ssl_derive_keys_7
   \      0x136   0x60F0             STR      R0,[R6, #+12]
   \      0x138   0x220C             MOVS     R2,#+12
   \      0x13A   0x6072             STR      R2,[R6, #+4]
   \      0x13C   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \      0x140   0x4570             CMP      R0,LR
   \      0x142   0xBF0C             ITE      EQ
   \      0x144   0x200C             MOVEQ    R0,#+12
   \      0x146   0x2004             MOVNE    R0,#+4
   \      0x148   0x60B0             STR      R0,[R6, #+8]
   \      0x14A   0x4602             MOV      R2,R0
   \      0x14C   0x6930             LDR      R0,[R6, #+16]
   \      0x14E   0xF1C2 0x020C      RSB      R2,R2,#+12
   \      0x152   0x1882             ADDS     R2,R0,R2
   \      0x154   0x6032             STR      R2,[R6, #+0]
   \      0x156   0xE0A1             B.N      ??mbedtls_ssl_derive_keys_8
   \                     ??mbedtls_ssl_derive_keys_7: (+1)
   \      0x158   0x2C00             CMP      R4,#+0
   \      0x15A   0xBF18             IT       NE
   \      0x15C   0x2C01             CMPNE    R4,#+1
   \      0x15E   0xD004             BEQ.N    ??mbedtls_ssl_derive_keys_9
   \      0x160   0x2C02             CMP      R4,#+2
   \      0x162   0xBF18             IT       NE
   \      0x164   0x.... 0x....      LDRNE.W  R0,??DataTable37_2
   \      0x168   0xD1DD             BNE.N    ??mbedtls_ssl_derive_keys_1
   \                     ??mbedtls_ssl_derive_keys_9: (+1)
   \      0x16A   0xF8BD 0x200C      LDRH     R2,[SP, #+12]
   \      0x16E   0x2301             MOVS     R3,#+1
   \      0x170   0xF402 0x40E0      AND      R0,R2,#0x7000
   \      0x174   0xF5B0 0x5F00      CMP      R0,#+8192
   \      0x178   0xBF03             ITTTE    EQ
   \      0x17A   0x0A10             LSREQ    R0,R2,#+8
   \      0x17C   0xF000 0x0007      ANDEQ    R0,R0,#0x7
   \      0x180   0xFA03 0xF000      LSLEQ    R0,R3,R0
   \      0x184   0x2000             MOVNE    R0,#+0
   \      0x186   0x.... 0x....      LDR.W    R12,??DataTable37_3
   \      0x18A   0x45E3             CMP      R11,R12
   \      0x18C   0xBF08             IT       EQ
   \      0x18E   0x2510             MOVEQ    R5,#+16
   \      0x190   0xD038             BEQ.N    ??mbedtls_ssl_derive_keys_10
   \      0x192   0x.... 0x....      LDR.W    R12,??DataTable37_4
   \      0x196   0x45E3             CMP      R11,R12
   \      0x198   0xBF1C             ITT      NE
   \      0x19A   0x.... 0x....      LDRNE.W  R12,??DataTable37_5
   \      0x19E   0x45E3             CMPNE    R11,R12
   \      0x1A0   0xD02F             BEQ.N    ??mbedtls_ssl_derive_keys_11
   \      0x1A2   0x.... 0x....      LDR.W    R12,??DataTable37_6
   \      0x1A6   0x45E3             CMP      R11,R12
   \      0x1A8   0xD029             BEQ.N    ??mbedtls_ssl_derive_keys_12
   \      0x1AA   0x.... 0x....      LDR.W    R12,??DataTable37_7
   \      0x1AE   0x45E3             CMP      R11,R12
   \      0x1B0   0xD023             BEQ.N    ??mbedtls_ssl_derive_keys_13
   \      0x1B2   0x.... 0x....      LDR.W    R12,??DataTable37_8
   \      0x1B6   0x45E3             CMP      R11,R12
   \      0x1B8   0xD01D             BEQ.N    ??mbedtls_ssl_derive_keys_14
   \      0x1BA   0x.... 0x....      LDR.W    R12,??DataTable37_9
   \      0x1BE   0x45E3             CMP      R11,R12
   \      0x1C0   0xD017             BEQ.N    ??mbedtls_ssl_derive_keys_15
   \      0x1C2   0x.... 0x....      LDR.W    R12,??DataTable37_10
   \      0x1C6   0x45E3             CMP      R11,R12
   \      0x1C8   0xD019             BEQ.N    ??mbedtls_ssl_derive_keys_12
   \      0x1CA   0x.... 0x....      LDR.W    R12,??DataTable37_11
   \      0x1CE   0x45E3             CMP      R11,R12
   \      0x1D0   0xD013             BEQ.N    ??mbedtls_ssl_derive_keys_13
   \      0x1D2   0x.... 0x....      LDR.W    R12,??DataTable37_12
   \      0x1D6   0x45E3             CMP      R11,R12
   \      0x1D8   0xD011             BEQ.N    ??mbedtls_ssl_derive_keys_12
   \      0x1DA   0x.... 0x....      LDR.W    R12,??DataTable37_13
   \      0x1DE   0x45E3             CMP      R11,R12
   \      0x1E0   0xD00B             BEQ.N    ??mbedtls_ssl_derive_keys_13
   \      0x1E2   0x.... 0x....      LDR.W    R12,??DataTable37_14
   \      0x1E6   0x45E3             CMP      R11,R12
   \      0x1E8   0xD005             BEQ.N    ??mbedtls_ssl_derive_keys_14
   \      0x1EA   0x.... 0x....      LDR.W    R12,??DataTable37_15
   \      0x1EE   0x45E3             CMP      R11,R12
   \      0x1F0   0xD108             BNE.N    ??mbedtls_ssl_derive_keys_10
   \                     ??mbedtls_ssl_derive_keys_15: (+1)
   \      0x1F2   0x2540             MOVS     R5,#+64
   \      0x1F4   0xE006             B.N      ??mbedtls_ssl_derive_keys_10
   \                     ??mbedtls_ssl_derive_keys_14: (+1)
   \      0x1F6   0x2530             MOVS     R5,#+48
   \      0x1F8   0xE004             B.N      ??mbedtls_ssl_derive_keys_10
   \                     ??mbedtls_ssl_derive_keys_13: (+1)
   \      0x1FA   0x2520             MOVS     R5,#+32
   \      0x1FC   0xE002             B.N      ??mbedtls_ssl_derive_keys_10
   \                     ??mbedtls_ssl_derive_keys_12: (+1)
   \      0x1FE   0x251C             MOVS     R5,#+28
   \      0x200   0xE000             B.N      ??mbedtls_ssl_derive_keys_10
   \                     ??mbedtls_ssl_derive_keys_11: (+1)
   \      0x202   0x2514             MOVS     R5,#+20
   \                     ??mbedtls_ssl_derive_keys_10: (+1)
   \      0x204   0xF402 0x42E0      AND      R2,R2,#0x7000
   \      0x208   0x60F5             STR      R5,[R6, #+12]
   \      0x20A   0xF5B2 0x5F00      CMP      R2,#+8192
   \      0x20E   0xD121             BNE.N    ??mbedtls_ssl_derive_keys_16
   \      0x210   0xF8BD 0x200C      LDRH     R2,[SP, #+12]
   \      0x214   0x0A12             LSRS     R2,R2,#+8
   \      0x216   0xF002 0x0207      AND      R2,R2,#0x7
   \      0x21A   0x4093             LSLS     R3,R3,R2
   \      0x21C   0x2B01             CMP      R3,#+1
   \      0x21E   0xD919             BLS.N    ??mbedtls_ssl_derive_keys_16
   \      0x220   0xF8DD 0xC010      LDR      R12,[SP, #+16]
   \      0x224   0x.... 0x....      LDR.W    R2,??DataTable37_16
   \      0x228   0x4594             CMP      R12,R2
   \      0x22A   0xBF1C             ITT      NE
   \      0x22C   0x.... 0x....      LDRNE.W  R2,??DataTable37_17
   \      0x230   0x4594             CMPNE    R12,R2
   \      0x232   0xD020             BEQ.N    ??mbedtls_ssl_derive_keys_17
   \      0x234   0x.... 0x....      LDR.W    R2,??DataTable37_18
   \      0x238   0x4594             CMP      R12,R2
   \      0x23A   0xBF1C             ITT      NE
   \      0x23C   0x.... 0x....      LDRNE.W  R2,??DataTable37_19
   \      0x240   0x4594             CMPNE    R12,R2
   \      0x242   0xD018             BEQ.N    ??mbedtls_ssl_derive_keys_17
   \      0x244   0x.... 0x....      LDR.W    R2,??DataTable37_20
   \      0x248   0x4594             CMP      R12,R2
   \      0x24A   0xBF1C             ITT      NE
   \      0x24C   0x.... 0x....      LDRNE.W  R2,??DataTable37_21
   \      0x250   0x4594             CMPNE    R12,R2
   \      0x252   0xD010             BEQ.N    ??mbedtls_ssl_derive_keys_17
   \                     ??mbedtls_ssl_derive_keys_16: (+1)
   \      0x254   0xF8BD 0x300C      LDRH     R3,[SP, #+12]
   \      0x258   0x4573             CMP      R3,LR
   \      0x25A   0xBF01             ITTTT    EQ
   \      0x25C   0x9A04             LDREQ    R2,[SP, #+16]
   \      0x25E   0x.... 0x....      LDREQ.W  R3,??DataTable37_22
   \      0x262   0x429A             CMPEQ    R2,R3
   \      0x264   0x230C             MOVEQ    R3,#+12
   \      0x266   0xD006             BEQ.N    ??mbedtls_ssl_derive_keys_17
   \      0x268   0x9A04             LDR      R2,[SP, #+16]
   \      0x26A   0x.... 0x....      LDR.W    R3,??DataTable37_23
   \      0x26E   0x429A             CMP      R2,R3
   \      0x270   0xBF0C             ITE      EQ
   \      0x272   0x230D             MOVEQ    R3,#+13
   \      0x274   0x2300             MOVNE    R3,#+0
   \                     ??mbedtls_ssl_derive_keys_17: (+1)
   \      0x276   0x6073             STR      R3,[R6, #+4]
   \      0x278   0xB90C             CBNZ.N   R4,??mbedtls_ssl_derive_keys_18
   \      0x27A   0x6035             STR      R5,[R6, #+0]
   \      0x27C   0xE00E             B.N      ??mbedtls_ssl_derive_keys_8
   \                     ??mbedtls_ssl_derive_keys_18: (+1)
   \      0x27E   0x462C             MOV      R4,R5
   \      0x280   0xFBB4 0xF4F0      UDIV     R4,R4,R0
   \      0x284   0xF240 0x3303      MOVW     R3,#+771
   \      0x288   0xFB00 0x0004      MLA      R0,R0,R4,R0
   \      0x28C   0x6030             STR      R0,[R6, #+0]
   \      0x28E   0xF9BD 0x200E      LDRSH    R2,[SP, #+14]
   \      0x292   0x429A             CMP      R2,R3
   \      0x294   0xD104             BNE.N    ??mbedtls_ssl_derive_keys_19
   \      0x296   0x6872             LDR      R2,[R6, #+4]
   \      0x298   0x1810             ADDS     R0,R2,R0
   \      0x29A   0x6030             STR      R0,[R6, #+0]
   \                     ??mbedtls_ssl_derive_keys_8: (+1)
   \      0x29C   0x9807             LDR      R0,[SP, #+28]
   \      0x29E   0x2800             CMP      R0,#+0
   \                     ??mbedtls_ssl_derive_keys_19: (+1)
   \      0x2A0   0xF040 0x8087      BNE.W    ??mbedtls_ssl_derive_keys_20
   \      0x2A4   0xAA13             ADD      R2,SP,#+76
   \      0x2A6   0xEB02 0x0045      ADD      R0,R2,R5, LSL #+1
   \      0x2AA   0xEB00 0x02D1      ADD      R2,R0,R1, LSR #+3
   \      0x2AE   0x9008             STR      R0,[SP, #+32]
   \      0x2B0   0x9207             STR      R2,[SP, #+28]
   \      0x2B2   0x68B0             LDR      R0,[R6, #+8]
   \      0x2B4   0xB900             CBNZ.N   R0,??mbedtls_ssl_derive_keys_21
   \      0x2B6   0x6870             LDR      R0,[R6, #+4]
   \                     ??mbedtls_ssl_derive_keys_21: (+1)
   \      0x2B8   0x9000             STR      R0,[SP, #+0]
   \      0x2BA   0xEB02 0x04D1      ADD      R4,R2,R1, LSR #+3
   \      0x2BE   0x9A00             LDR      R2,[SP, #+0]
   \      0x2C0   0xF106 0x0014      ADD      R0,R6,#+20
   \      0x2C4   0x4621             MOV      R1,R4
   \      0x2C6   0x.... 0x....      BL       __aeabi_memcpy
   \      0x2CA   0x9A00             LDR      R2,[SP, #+0]
   \      0x2CC   0xF106 0x0024      ADD      R0,R6,#+36
   \      0x2D0   0x18A1             ADDS     R1,R4,R2
   \      0x2D2   0x.... 0x....      BL       __aeabi_memcpy
   \      0x2D6   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x2DA   0xBF1E             ITTT     NE
   \      0x2DC   0xF108 0x00C8      ADDNE    R0,R8,#+200
   \      0x2E0   0x6804             LDRNE    R4,[R0, #+0]
   \      0x2E2   0x2C00             CMPNE    R4,#+0
   \      0x2E4   0xD011             BEQ.N    ??mbedtls_ssl_derive_keys_22
   \      0x2E6   0x.... 0x....      LDR.W    R1,??DataTable37_1
   \      0x2EA   0x4589             CMP      R9,R1
   \      0x2EC   0xBF0C             ITE      EQ
   \      0x2EE   0x2102             MOVEQ    R1,#+2
   \      0x2F0   0x2100             MOVNE    R1,#+0
   \      0x2F2   0x9B06             LDR      R3,[SP, #+24]
   \      0x2F4   0x9102             STR      R1,[SP, #+8]
   \      0x2F6   0x9906             LDR      R1,[SP, #+24]
   \      0x2F8   0xF103 0x0220      ADD      R2,R3,#+32
   \      0x2FC   0x9200             STR      R2,[SP, #+0]
   \      0x2FE   0x9A09             LDR      R2,[SP, #+36]
   \      0x300   0x9101             STR      R1,[SP, #+4]
   \      0x302   0x6840             LDR      R0,[R0, #+4]
   \      0x304   0x2330             MOVS     R3,#+48
   \      0x306   0x2100             MOVS     R1,#+0
   \      0x308   0x47A0             BLX      R4
   \                     ??mbedtls_ssl_derive_keys_22: (+1)
   \      0x30A   0x9804             LDR      R0,[SP, #+16]
   \      0x30C   0x64F0             STR      R0,[R6, #+76]
   \      0x30E   0x9904             LDR      R1,[SP, #+16]
   \      0x310   0xF1B1 0x6F80      CMP      R1,#+67108864
   \      0x314   0xD01E             BEQ.N    ??mbedtls_ssl_derive_keys_23
   \      0x316   0xF44F 0x7180      MOV      R1,#+256
   \      0x31A   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_35: (+1)
   \      0x31E   0x9804             LDR      R0,[SP, #+16]
   \      0x320   0xF8BD 0x100C      LDRH     R1,[SP, #+12]
   \      0x324   0x900E             STR      R0,[SP, #+56]
   \      0x326   0xA80A             ADD      R0,SP,#+40
   \      0x328   0x.... 0x....      BL       psa_set_key_type
   \      0x32C   0x9A05             LDR      R2,[SP, #+20]
   \      0x32E   0x9908             LDR      R1,[SP, #+32]
   \      0x330   0xF106 0x0344      ADD      R3,R6,#+68
   \      0x334   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_39: (+1)
   \      0x338   0x2800             CMP      R0,#+0
   \      0x33A   0xD136             BNE.N    ??mbedtls_ssl_derive_keys_5
   \      0x33C   0xF44F 0x7100      MOV      R1,#+512
   \      0x340   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_36: (+1)
   \      0x344   0x9A05             LDR      R2,[SP, #+20]
   \      0x346   0x9907             LDR      R1,[SP, #+28]
   \      0x348   0xF106 0x0348      ADD      R3,R6,#+72
   \      0x34C   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_40: (+1)
   \      0x350   0x2800             CMP      R0,#+0
   \      0x352   0xD12A             BNE.N    ??mbedtls_ssl_derive_keys_5
   \                     ??mbedtls_ssl_derive_keys_23: (+1)
   \      0x354   0x2D00             CMP      R5,#+0
   \      0x356   0xD02E             BEQ.N    ??mbedtls_ssl_derive_keys_24
   \      0x358   0xF04B 0x7460      ORR      R4,R11,#0x3800000
   \      0x35C   0x63F4             STR      R4,[R6, #+60]
   \      0x35E   0xF44F 0x6180      MOV      R1,#+1024
   \      0x362   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_37: (+1)
   \      0x366   0x940E             STR      R4,[SP, #+56]
   \      0x368   0xF44F 0x5188      MOV      R1,#+4352
   \      0x36C   0xA80A             ADD      R0,SP,#+40
   \      0x36E   0x.... 0x....      BL       psa_set_key_type
   \      0x372   0xF106 0x0334      ADD      R3,R6,#+52
   \      0x376   0x462A             MOV      R2,R5
   \      0x378   0xA913             ADD      R1,SP,#+76
   \      0x37A   0x.... 0x....      BL       ??Subroutine18_0
   \                     ??CrossCallReturnLabel_41: (+1)
   \      0x37E   0xB9A0             CBNZ.N   R0,??mbedtls_ssl_derive_keys_5
   \      0x380   0x6CF0             LDR      R0,[R6, #+76]
   \      0x382   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x386   0xBF1D             ITTTE    NE
   \      0x388   0x.... 0x....      LDRNE.W  R1,??DataTable37_20
   \      0x38C   0x4288             CMPNE    R0,R1
   \      0x38E   0xF44F 0x5100      MOVNE    R1,#+8192
   \      0x392   0xF242 0x0101      MOVWEQ   R1,#+8193
   \      0x396   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_38: (+1)
   \      0x39A   0xA813             ADD      R0,SP,#+76
   \      0x39C   0x1941             ADDS     R1,R0,R5
   \      0x39E   0xF106 0x0338      ADD      R3,R6,#+56
   \      0x3A2   0x462A             MOV      R2,R5
   \      0x3A4   0x.... 0x....      BL       ??Subroutine18_0
   \                     ??CrossCallReturnLabel_42: (+1)
   \      0x3A8   0xB128             CBZ.N    R0,??mbedtls_ssl_derive_keys_24
   \                     ??mbedtls_ssl_derive_keys_5: (+1)
   \      0x3AA   0x.... 0x....      BL       local_err_translation
   \      0x3AE   0x4682             MOV      R10,R0
   \      0x3B0   0xE001             B.N      ??mbedtls_ssl_derive_keys_24
   \                     ??mbedtls_ssl_derive_keys_20: (+1)
   \      0x3B2   0x.... 0x....      LDR.W    R10,??DataTable37_2
   \                     ??mbedtls_ssl_derive_keys_24: (+1)
   \      0x3B6   0xF44F 0x7180      MOV      R1,#+256
   \      0x3BA   0xA813             ADD      R0,SP,#+76
   \      0x3BC   0x.... 0x....      BL       mbedtls_platform_zeroize
   \      0x3C0   0xEA5F 0x000A      MOVS     R0,R10
   6594              if (ret != 0) {
   \      0x3C4   0xD106             BNE.N    ??mbedtls_ssl_derive_keys_6
   6595                  MBEDTLS_SSL_DEBUG_RET(1, "ssl_tls12_populate_transform", ret);
   6596                  return ret;
   6597              }
   6598          
   6599              /* We no longer need Server/ClientHello.random values */
   6600              mbedtls_platform_zeroize(ssl->handshake->randbytes,
   6601                                       sizeof(ssl->handshake->randbytes));
   \      0x3C6   0x6BB8             LDR      R0,[R7, #+56]
   \      0x3C8   0x2140             MOVS     R1,#+64
   \      0x3CA   0xF500 0x70FC      ADD      R0,R0,#+504
   \      0x3CE   0x.... 0x....      BL       mbedtls_platform_zeroize
   6602          
   6603              MBEDTLS_SSL_DEBUG_MSG(2, ("<= derive keys"));
   6604          
   6605              return 0;
   \      0x3D2   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_derive_keys_6: (+1)
   \      0x3D4   0xB053             ADD      SP,SP,#+332
   \      0x3D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??mbedtls_ssl_derive_keys_3: (+1)
   \      0x3DA   0x.... 0x....      LDR.W    R0,??DataTable37_24
   \      0x3DE   0xE7F9             B.N      ??mbedtls_ssl_derive_keys_6
   6606          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x1DD2             ADDS     R2,R2,#+7
   \        0x2   0x08D2             LSRS     R2,R2,#+3
   \                     ??Subroutine18_0: (+1)
   \        0x4   0xA80A             ADD      R0,SP,#+40
   \        0x6   0x.... 0x....      B.W      psa_import_key

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0xA80A             ADD      R0,SP,#+40
   \        0x2   0x.... 0x....      B.W      psa_set_key_usage_flags
   6607          

   \                                 In section .text, align 2, keep-with-next
   6608          int mbedtls_ssl_set_calc_verify_md(mbedtls_ssl_context *ssl, int md)
   6609          {
   6610              switch (md) {
   \                     mbedtls_ssl_set_calc_verify_md: (+1)
   \        0x0   0x2904             CMP      R1,#+4
   \        0x2   0xD105             BNE.N    ??mbedtls_ssl_set_calc_verify_md_0
   6611          #if defined(MBEDTLS_MD_CAN_SHA384)
   6612                  case MBEDTLS_SSL_HASH_SHA384:
   6613                      ssl->handshake->calc_verify = ssl_calc_verify_tls_sha384;
   6614                      break;
   6615          #endif
   6616          #if defined(MBEDTLS_MD_CAN_SHA256)
   6617                  case MBEDTLS_SSL_HASH_SHA256:
   6618                      ssl->handshake->calc_verify = ssl_calc_verify_tls_sha256;
   \        0x4   0x6B80             LDR      R0,[R0, #+56]
   \        0x6   0x.... 0x....      ADR.W    R1,ssl_calc_verify_tls_sha256
   \        0xA   0x6101             STR      R1,[R0, #+16]
   6619                      break;
   6620          #endif
   6621                  default:
   6622                      return -1;
   6623              }
   6624          #if !defined(MBEDTLS_MD_CAN_SHA384) && \
   6625              !defined(MBEDTLS_MD_CAN_SHA256)
   6626              (void) ssl;
   6627          #endif
   6628              return 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   \                     ??mbedtls_ssl_set_calc_verify_md_0: (+1)
   \       0x10                      REQUIRE ?Subroutine1
   \       0x10                      ;; // Fall through to label ?Subroutine1
   6629          }
   6630          
   6631          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   6632          static int ssl_calc_verify_tls_psa(const mbedtls_ssl_context *ssl,
   6633                                             const psa_hash_operation_t *hs_op,
   6634                                             size_t buffer_size,
   6635                                             unsigned char *hash,
   6636                                             size_t *hlen)
   6637          {
   6638              psa_status_t status;
   6639              psa_hash_operation_t cloned_op = psa_hash_operation_init();
   6640          
   6641          #if !defined(MBEDTLS_DEBUG_C)
   6642              (void) ssl;
   6643          #endif
   6644              MBEDTLS_SSL_DEBUG_MSG(2, ("=> PSA calc verify"));
   6645              status = psa_hash_clone(hs_op, &cloned_op);
   6646              if (status != PSA_SUCCESS) {
   6647                  goto exit;
   6648              }
   6649          
   6650              status = psa_hash_finish(&cloned_op, hash, buffer_size, hlen);
   6651              if (status != PSA_SUCCESS) {
   6652                  goto exit;
   6653              }
   6654          
   6655              MBEDTLS_SSL_DEBUG_BUF(3, "PSA calculated verify result", hash, *hlen);
   6656              MBEDTLS_SSL_DEBUG_MSG(2, ("<= PSA calc verify"));
   6657          
   6658          exit:
   6659              psa_hash_abort(&cloned_op);
   6660              return mbedtls_md_error_from_psa(status);
   6661          }
   6662          #else
   6663          static int ssl_calc_verify_tls_legacy(const mbedtls_ssl_context *ssl,
   6664                                                const mbedtls_md_context_t *hs_ctx,
   6665                                                unsigned char *hash,
   6666                                                size_t *hlen)
   6667          {
   6668              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   6669              mbedtls_md_context_t cloned_ctx;
   6670          
   6671              mbedtls_md_init(&cloned_ctx);
   6672          
   6673          #if !defined(MBEDTLS_DEBUG_C)
   6674              (void) ssl;
   6675          #endif
   6676              MBEDTLS_SSL_DEBUG_MSG(2, ("=> calc verify"));
   6677          
   6678              ret = mbedtls_md_setup(&cloned_ctx, mbedtls_md_info_from_ctx(hs_ctx), 0);
   6679              if (ret != 0) {
   6680                  goto exit;
   6681              }
   6682              ret = mbedtls_md_clone(&cloned_ctx, hs_ctx);
   6683              if (ret != 0) {
   6684                  goto exit;
   6685              }
   6686          
   6687              ret = mbedtls_md_finish(&cloned_ctx, hash);
   6688              if (ret != 0) {
   6689                  goto exit;
   6690              }
   6691          
   6692              *hlen = mbedtls_md_get_size(mbedtls_md_info_from_ctx(hs_ctx));
   6693          
   6694              MBEDTLS_SSL_DEBUG_BUF(3, "calculated verify result", hash, *hlen);
   6695              MBEDTLS_SSL_DEBUG_MSG(2, ("<= calc verify"));
   6696          
   6697          exit:
   6698              mbedtls_md_free(&cloned_ctx);
   6699              return ret;
   6700          }
   6701          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   6702          
   6703          #if defined(MBEDTLS_MD_CAN_SHA256)

   \                                 In section .text, align 4, keep-with-next
   6704          int ssl_calc_verify_tls_sha256(const mbedtls_ssl_context *ssl,
   6705                                         unsigned char *hash,
   6706                                         size_t *hlen)
   6707          {
   \                     ssl_calc_verify_tls_sha256: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB0B8             SUB      SP,SP,#+224
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   6708          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   6709              return ssl_calc_verify_tls_psa(ssl, &ssl->handshake->fin_sha256_psa, 32,
   6710                                             hash, hlen);
   \        0xA   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_33: (+1)
   \        0xE   0x6BA0             LDR      R0,[R4, #+56]
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x30EC             ADDS     R0,R0,#+236
   \       0x14   0x.... 0x....      BL       psa_hash_clone
   \       0x18   0x0004             MOVS     R4,R0
   \       0x1A   0xD102             BNE.N    ??ssl_calc_verify_tls_sha256_0
   \       0x1C   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x20   0x4604             MOV      R4,R0
   \                     ??ssl_calc_verify_tls_sha256_0: (+1)
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x.... 0x....      BL       psa_hash_abort
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       mbedtls_md_error_from_psa
   \       0x2E   0xB038             ADD      SP,SP,#+224
   \       0x30   0xBD70             POP      {R4-R6,PC}
   6711          #else
   6712              return ssl_calc_verify_tls_legacy(ssl, &ssl->handshake->fin_sha256,
   6713                                                hash, hlen);
   6714          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   6715          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x4633             MOV      R3,R6
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x4629             MOV      R1,R5
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x.... 0x....      B.W      psa_hash_finish
   6716          #endif /* MBEDTLS_MD_CAN_SHA256 */
   6717          
   6718          #if defined(MBEDTLS_MD_CAN_SHA384)
   6719          int ssl_calc_verify_tls_sha384(const mbedtls_ssl_context *ssl,
   6720                                         unsigned char *hash,
   6721                                         size_t *hlen)
   6722          {
   6723          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   6724              return ssl_calc_verify_tls_psa(ssl, &ssl->handshake->fin_sha384_psa, 48,
   6725                                             hash, hlen);
   6726          #else
   6727              return ssl_calc_verify_tls_legacy(ssl, &ssl->handshake->fin_sha384,
   6728                                                hash, hlen);
   6729          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   6730          }
   6731          #endif /* MBEDTLS_MD_CAN_SHA384 */
   6732          
   6733          #if !defined(MBEDTLS_USE_PSA_CRYPTO) &&                      \
   6734              defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   6735          int mbedtls_ssl_psk_derive_premaster(mbedtls_ssl_context *ssl, mbedtls_key_exchange_type_t key_ex)
   6736          {
   6737              unsigned char *p = ssl->handshake->premaster;
   6738              unsigned char *end = p + sizeof(ssl->handshake->premaster);
   6739              const unsigned char *psk = NULL;
   6740              size_t psk_len = 0;
   6741              int psk_ret = mbedtls_ssl_get_psk(ssl, &psk, &psk_len);
   6742          
   6743              if (psk_ret == MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) {
   6744                  /*
   6745                   * This should never happen because the existence of a PSK is always
   6746                   * checked before calling this function.
   6747                   *
   6748                   * The exception is opaque DHE-PSK. For DHE-PSK fill premaster with
   6749                   * the shared secret without PSK.
   6750                   */
   6751                  if (key_ex != MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   6752                      MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   6753                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6754                  }
   6755              }
   6756          
   6757              /*
   6758               * PMS = struct {
   6759               *     opaque other_secret<0..2^16-1>;
   6760               *     opaque psk<0..2^16-1>;
   6761               * };
   6762               * with "other_secret" depending on the particular key exchange
   6763               */
   6764          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   6765              if (key_ex == MBEDTLS_KEY_EXCHANGE_PSK) {
   6766                  if (end - p < 2) {
   6767                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   6768                  }
   6769          
   6770                  MBEDTLS_PUT_UINT16_BE(psk_len, p, 0);
   6771                  p += 2;
   6772          
   6773                  if (end < p || (size_t) (end - p) < psk_len) {
   6774                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   6775                  }
   6776          
   6777                  memset(p, 0, psk_len);
   6778                  p += psk_len;
   6779              } else
   6780          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
   6781          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   6782              if (key_ex == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   6783                  /*
   6784                   * other_secret already set by the ClientKeyExchange message,
   6785                   * and is 48 bytes long
   6786                   */
   6787                  if (end - p < 2) {
   6788                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   6789                  }
   6790          
   6791                  *p++ = 0;
   6792                  *p++ = 48;
   6793                  p += 48;
   6794              } else
   6795          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   6796          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   6797              if (key_ex == MBEDTLS_KEY_EXCHANGE_DHE_PSK) {
   6798                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   6799                  size_t len;
   6800          
   6801                  /* Write length only when we know the actual value */
   6802                  if ((ret = mbedtls_dhm_calc_secret(&ssl->handshake->dhm_ctx,
   6803                                                     p + 2, end - (p + 2), &len,
   6804                                                     ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   6805                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_dhm_calc_secret", ret);
   6806                      return ret;
   6807                  }
   6808                  MBEDTLS_PUT_UINT16_BE(len, p, 0);
   6809                  p += 2 + len;
   6810          
   6811                  MBEDTLS_SSL_DEBUG_MPI(3, "DHM: K ", &ssl->handshake->dhm_ctx.K);
   6812              } else
   6813          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   6814          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   6815              if (key_ex == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK) {
   6816                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   6817                  size_t zlen;
   6818          
   6819                  if ((ret = mbedtls_ecdh_calc_secret(&ssl->handshake->ecdh_ctx, &zlen,
   6820                                                      p + 2, end - (p + 2),
   6821                                                      ssl->conf->f_rng, ssl->conf->p_rng)) != 0) {
   6822                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ecdh_calc_secret", ret);
   6823                      return ret;
   6824                  }
   6825          
   6826                  MBEDTLS_PUT_UINT16_BE(zlen, p, 0);
   6827                  p += 2 + zlen;
   6828          
   6829                  MBEDTLS_SSL_DEBUG_ECDH(3, &ssl->handshake->ecdh_ctx,
   6830                                         MBEDTLS_DEBUG_ECDH_Z);
   6831              } else
   6832          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   6833              {
   6834                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   6835                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6836              }
   6837          
   6838              /* opaque psk<0..2^16-1>; */
   6839              if (end - p < 2) {
   6840                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   6841              }
   6842          
   6843              MBEDTLS_PUT_UINT16_BE(psk_len, p, 0);
   6844              p += 2;
   6845          
   6846              if (end < p || (size_t) (end - p) < psk_len) {
   6847                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   6848              }
   6849          
   6850              memcpy(p, psk, psk_len);
   6851              p += psk_len;
   6852          
   6853              ssl->handshake->pmslen = p - ssl->handshake->premaster;
   6854          
   6855              return 0;
   6856          }
   6857          #endif /* !MBEDTLS_USE_PSA_CRYPTO && MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   6858          
   6859          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
   6860          MBEDTLS_CHECK_RETURN_CRITICAL
   6861          static int ssl_write_hello_request(mbedtls_ssl_context *ssl);
   6862          
   6863          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6864          int mbedtls_ssl_resend_hello_request(mbedtls_ssl_context *ssl)
   6865          {
   6866              /* If renegotiation is not enforced, retransmit until we would reach max
   6867               * timeout if we were using the usual handshake doubling scheme */
   6868              if (ssl->conf->renego_max_records < 0) {
   6869                  uint32_t ratio = ssl->conf->hs_timeout_max / ssl->conf->hs_timeout_min + 1;
   6870                  unsigned char doublings = 1;
   6871          
   6872                  while (ratio != 0) {
   6873                      ++doublings;
   6874                      ratio >>= 1;
   6875                  }
   6876          
   6877                  if (++ssl->renego_records_seen > doublings) {
   6878                      MBEDTLS_SSL_DEBUG_MSG(2, ("no longer retransmitting hello request"));
   6879                      return 0;
   6880                  }
   6881              }
   6882          
   6883              return ssl_write_hello_request(ssl);
   6884          }
   6885          #endif
   6886          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
   6887          
   6888          /*
   6889           * Handshake functions
   6890           */
   6891          #if !defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
   6892          /* No certificate support -> dummy functions */
   6893          int mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
   6894          {
   6895              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   6896                  ssl->handshake->ciphersuite_info;
   6897          
   6898              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate"));
   6899          
   6900              if (!mbedtls_ssl_ciphersuite_uses_srv_cert(ciphersuite_info)) {
   6901                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate"));
   6902                  ssl->state++;
   6903                  return 0;
   6904              }
   6905          
   6906              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   6907              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6908          }
   6909          
   6910          int mbedtls_ssl_parse_certificate(mbedtls_ssl_context *ssl)
   6911          {
   6912              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   6913                  ssl->handshake->ciphersuite_info;
   6914          
   6915              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate"));
   6916          
   6917              if (!mbedtls_ssl_ciphersuite_uses_srv_cert(ciphersuite_info)) {
   6918                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate"));
   6919                  ssl->state++;
   6920                  return 0;
   6921              }
   6922          
   6923              MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   6924              return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6925          }
   6926          
   6927          #else /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
   6928          /* Some certificate support -> implement write and parse */
   6929          

   \                                 In section .text, align 2, keep-with-next
   6930          int mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
   6931          {
   \                     mbedtls_ssl_write_certificate: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   6932              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   6933              size_t i, n;
   6934              const mbedtls_x509_crt *crt;
   6935              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   6936                  ssl->handshake->ciphersuite_info;
   6937          
   6938              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write certificate"));
   6939          
   6940              if (!mbedtls_ssl_ciphersuite_uses_srv_cert(ciphersuite_info)) {
   \        0x6   0x6BA8             LDR      R0,[R5, #+56]
   \        0x8   0x6883             LDR      R3,[R0, #+8]
   \        0xA   0x7A9A             LDRB     R2,[R3, #+10]
   \        0xC   0x1E52             SUBS     R2,R2,#+1
   \        0xE   0x2A03             CMP      R2,#+3
   \       0x10   0xD904             BLS.N    ??mbedtls_ssl_write_certificate_0
   \       0x12   0x1F92             SUBS     R2,R2,#+6
   \       0x14   0xD002             BEQ.N    ??mbedtls_ssl_write_certificate_0
   \       0x16   0x1E92             SUBS     R2,R2,#+2
   \       0x18   0x2A01             CMP      R2,#+1
   \       0x1A   0xD807             BHI.N    ??mbedtls_ssl_write_certificate_1
   6941                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate"));
   6942                  ssl->state++;
   6943                  return 0;
   6944              }
   6945          
   6946          #if defined(MBEDTLS_SSL_CLI_C)
   6947              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   \                     ??mbedtls_ssl_write_certificate_0: (+1)
   \       0x1C   0x682A             LDR      R2,[R5, #+0]
   \       0x1E   0x7911             LDRB     R1,[R2, #+4]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xBF04             ITT      EQ
   \       0x24   0xF890 0x11CC      LDRBEQ   R1,[R0, #+460]
   \       0x28   0x2900             CMPEQ    R1,#+0
   6948                  if (ssl->handshake->client_auth == 0) {
   \       0x2A   0xD105             BNE.N    ??mbedtls_ssl_write_certificate_2
   6949                      MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate"));
   6950                      ssl->state++;
   \                     ??mbedtls_ssl_write_certificate_1: (+1)
   \       0x2C   0x6868             LDR      R0,[R5, #+4]
   \       0x2E   0x1C40             ADDS     R0,R0,#+1
   \       0x30   0x6068             STR      R0,[R5, #+4]
   6951                      return 0;
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_write_certificate_3: (+1)
   \       0x34   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6952                  }
   6953              }
   6954          #endif /* MBEDTLS_SSL_CLI_C */
   6955          #if defined(MBEDTLS_SSL_SRV_C)
   6956              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   6957                  if (mbedtls_ssl_own_cert(ssl) == NULL) {
   6958                      /* Should never happen because we shouldn't have picked the
   6959                       * ciphersuite if we don't have a certificate. */
   6960                      return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   6961                  }
   6962              }
   6963          #endif
   6964          
   6965              MBEDTLS_SSL_DEBUG_CRT(3, "own certificate", mbedtls_ssl_own_cert(ssl));
   6966          
   6967              /*
   6968               *     0  .  0    handshake type
   6969               *     1  .  3    handshake length
   6970               *     4  .  6    length of all certs
   6971               *     7  .  9    length of cert. 1
   6972               *    10  . n-1   peer certificate
   6973               *     n  . n+2   length of cert. 2
   6974               *    n+3 . ...   upper level cert, etc.
   6975               */
   6976              i = 7;
   \                     ??mbedtls_ssl_write_certificate_2: (+1)
   \       0x38   0x2607             MOVS     R6,#+7
   6977              crt = mbedtls_ssl_own_cert(ssl);
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xBF1C             ITT      NE
   \       0x3E   0xF8D0 0x00A4      LDRNE    R0,[R0, #+164]
   \       0x42   0x2800             CMPNE    R0,#+0
   \       0x44   0xD003             BEQ.N    ??mbedtls_ssl_write_certificate_4
   \                     ??mbedtls_ssl_write_certificate_5: (+1)
   \       0x46   0x6804             LDR      R4,[R0, #+0]
   \                     ??mbedtls_ssl_write_certificate_6: (+1)
   \       0x48   0xF105 0x07A8      ADD      R7,R5,#+168
   \       0x4C   0xE01B             B.N      ??mbedtls_ssl_write_certificate_7
   \                     ??mbedtls_ssl_write_certificate_4: (+1)
   \       0x4E   0x6B90             LDR      R0,[R2, #+56]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD1F8             BNE.N    ??mbedtls_ssl_write_certificate_5
   \       0x54   0x2400             MOVS     R4,#+0
   \       0x56   0xE7F7             B.N      ??mbedtls_ssl_write_certificate_6
   6978          
   6979              while (crt != NULL) {
   6980                  n = crt->raw.len;
   6981                  if (n > MBEDTLS_SSL_OUT_CONTENT_LEN - 3 - i) {
   6982                      MBEDTLS_SSL_DEBUG_MSG(1, ("certificate too large, %" MBEDTLS_PRINTF_SIZET
   6983                                                " > %" MBEDTLS_PRINTF_SIZET,
   6984                                                i + 3 + n, (size_t) MBEDTLS_SSL_OUT_CONTENT_LEN));
   6985                      return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;
   6986                  }
   6987          
   6988                  ssl->out_msg[i] = MBEDTLS_BYTE_2(n);
   \                     ??mbedtls_ssl_write_certificate_8: (+1)
   \       0x58   0x683A             LDR      R2,[R7, #+0]
   \       0x5A   0xEA4F 0x4318      LSR      R3,R8,#+16
   6989                  ssl->out_msg[i + 1] = MBEDTLS_BYTE_1(n);
   \       0x5E   0xEA4F 0x2018      LSR      R0,R8,#+8
   \       0x62   0x5593             STRB     R3,[R2, R6]
   \       0x64   0x6839             LDR      R1,[R7, #+0]
   6990                  ssl->out_msg[i + 2] = MBEDTLS_BYTE_0(n);
   6991          
   6992                  i += 3; memcpy(ssl->out_msg + i, crt->raw.p, n);
   \       0x66   0x4642             MOV      R2,R8
   \       0x68   0x4431             ADD      R1,R1,R6
   \       0x6A   0x7048             STRB     R0,[R1, #+1]
   \       0x6C   0x683B             LDR      R3,[R7, #+0]
   \       0x6E   0x4433             ADD      R3,R3,R6
   \       0x70   0xF883 0x8002      STRB     R8,[R3, #+2]
   \       0x74   0x6838             LDR      R0,[R7, #+0]
   \       0x76   0x68E1             LDR      R1,[R4, #+12]
   \       0x78   0x1CF6             ADDS     R6,R6,#+3
   \       0x7A   0x4430             ADD      R0,R0,R6
   \       0x7C   0x.... 0x....      BL       __aeabi_memcpy
   6993                  i += n; crt = crt->next;
   \       0x80   0x4446             ADD      R6,R8,R6
   \       0x82   0xF8D4 0x4228      LDR      R4,[R4, #+552]
   \                     ??mbedtls_ssl_write_certificate_7: (+1)
   \       0x86   0xB14C             CBZ.N    R4,??mbedtls_ssl_write_certificate_9
   \       0x88   0xF8D4 0x8008      LDR      R8,[R4, #+8]
   \       0x8C   0xF240 0x20FD      MOVW     R0,#+765
   \       0x90   0x1B80             SUBS     R0,R0,R6
   \       0x92   0x4540             CMP      R0,R8
   \       0x94   0xD2E0             BCS.N    ??mbedtls_ssl_write_certificate_8
   \       0x96   0x.... 0x....      LDR.W    R0,??DataTable37_25
   \       0x9A   0xE7CB             B.N      ??mbedtls_ssl_write_certificate_3
   6994              }
   6995          
   6996              ssl->out_msg[4]  = MBEDTLS_BYTE_2(i - 7);
   \                     ??mbedtls_ssl_write_certificate_9: (+1)
   \       0x9C   0x6839             LDR      R1,[R7, #+0]
   \       0x9E   0x1FF0             SUBS     R0,R6,#+7
   \       0xA0   0x0C02             LSRS     R2,R0,#+16
   \       0xA2   0x710A             STRB     R2,[R1, #+4]
   6997              ssl->out_msg[5]  = MBEDTLS_BYTE_1(i - 7);
   \       0xA4   0x683A             LDR      R2,[R7, #+0]
   \       0xA6   0x0A00             LSRS     R0,R0,#+8
   6998              ssl->out_msg[6]  = MBEDTLS_BYTE_0(i - 7);
   \       0xA8   0xF106 0x01F9      ADD      R1,R6,#+249
   \       0xAC   0x7150             STRB     R0,[R2, #+5]
   \       0xAE   0x6838             LDR      R0,[R7, #+0]
   6999          
   7000              ssl->out_msglen  = i;
   7001              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   \       0xB0   0x2216             MOVS     R2,#+22
   \       0xB2   0x7181             STRB     R1,[R0, #+6]
   7002              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
   \       0xB4   0x6839             LDR      R1,[R7, #+0]
   \       0xB6   0x60BE             STR      R6,[R7, #+8]
   \       0xB8   0x607A             STR      R2,[R7, #+4]
   \       0xBA   0x200B             MOVS     R0,#+11
   \       0xBC   0x7008             STRB     R0,[R1, #+0]
   7003          
   7004              ssl->state++;
   \       0xBE   0x686A             LDR      R2,[R5, #+4]
   7005          
   7006              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   7007                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   7008                  return ret;
   \       0xC0   0x4628             MOV      R0,R5
   \       0xC2   0x1C52             ADDS     R2,R2,#+1
   \       0xC4   0x606A             STR      R2,[R5, #+4]
   \       0xC6   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xCA   0x.... 0x....      B.W      mbedtls_ssl_write_handshake_msg
   7009              }
   7010          
   7011              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write certificate"));
   7012          
   7013              return ret;
   7014          }
   7015          
   7016          #if defined(MBEDTLS_SSL_RENEGOTIATION) && defined(MBEDTLS_SSL_CLI_C)
   7017          
   7018          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   7019          MBEDTLS_CHECK_RETURN_CRITICAL
   7020          static int ssl_check_peer_crt_unchanged(mbedtls_ssl_context *ssl,
   7021                                                  unsigned char *crt_buf,
   7022                                                  size_t crt_buf_len)
   7023          {
   7024              mbedtls_x509_crt const * const peer_crt = ssl->session->peer_cert;
   7025          
   7026              if (peer_crt == NULL) {
   7027                  return -1;
   7028              }
   7029          
   7030              if (peer_crt->raw.len != crt_buf_len) {
   7031                  return -1;
   7032              }
   7033          
   7034              return memcmp(peer_crt->raw.p, crt_buf, peer_crt->raw.len);
   7035          }
   7036          #else /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   7037          MBEDTLS_CHECK_RETURN_CRITICAL
   7038          static int ssl_check_peer_crt_unchanged(mbedtls_ssl_context *ssl,
   7039                                                  unsigned char *crt_buf,
   7040                                                  size_t crt_buf_len)
   7041          {
   7042              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   7043              unsigned char const * const peer_cert_digest =
   7044                  ssl->session->peer_cert_digest;
   7045              mbedtls_md_type_t const peer_cert_digest_type =
   7046                  ssl->session->peer_cert_digest_type;
   7047              mbedtls_md_info_t const * const digest_info =
   7048                  mbedtls_md_info_from_type(peer_cert_digest_type);
   7049              unsigned char tmp_digest[MBEDTLS_SSL_PEER_CERT_DIGEST_MAX_LEN];
   7050              size_t digest_len;
   7051          
   7052              if (peer_cert_digest == NULL || digest_info == NULL) {
   7053                  return -1;
   7054              }
   7055          
   7056              digest_len = mbedtls_md_get_size(digest_info);
   7057              if (digest_len > MBEDTLS_SSL_PEER_CERT_DIGEST_MAX_LEN) {
   7058                  return -1;
   7059              }
   7060          
   7061              ret = mbedtls_md(digest_info, crt_buf, crt_buf_len, tmp_digest);
   7062              if (ret != 0) {
   7063                  return -1;
   7064              }
   7065          
   7066              return memcmp(tmp_digest, peer_cert_digest, digest_len);
   7067          }
   7068          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   7069          #endif /* MBEDTLS_SSL_RENEGOTIATION && MBEDTLS_SSL_CLI_C */
   7070          
   7071          /*
   7072           * Once the certificate message is read, parse it into a cert chain and
   7073           * perform basic checks, but leave actual verification to the caller
   7074           */
   7075          MBEDTLS_CHECK_RETURN_CRITICAL
   7076          static int ssl_parse_certificate_chain(mbedtls_ssl_context *ssl,
   7077                                                 mbedtls_x509_crt *chain)
   7078          {
   7079              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   7080          #if defined(MBEDTLS_SSL_RENEGOTIATION) && defined(MBEDTLS_SSL_CLI_C)
   7081              int crt_cnt = 0;
   7082          #endif
   7083              size_t i, n;
   7084              uint8_t alert;
   7085          
   7086              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   7087                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
   7088                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7089                                                 MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   7090                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   7091              }
   7092          
   7093              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE) {
   7094                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7095                                                 MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   7096                  return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   7097              }
   7098          
   7099              if (ssl->in_hslen < mbedtls_ssl_hs_hdr_len(ssl) + 3 + 3) {
   7100                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
   7101                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7102                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   7103                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   7104              }
   7105          
   7106              i = mbedtls_ssl_hs_hdr_len(ssl);
   7107          
   7108              /*
   7109               * Same message structure as in mbedtls_ssl_write_certificate()
   7110               */
   7111              n = (ssl->in_msg[i+1] << 8) | ssl->in_msg[i+2];
   7112          
   7113              if (ssl->in_msg[i] != 0 ||
   7114                  ssl->in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len(ssl)) {
   7115                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
   7116                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7117                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   7118                  return MBEDTLS_ERR_SSL_DECODE_ERROR;
   7119              }
   7120          
   7121              /* Make &ssl->in_msg[i] point to the beginning of the CRT chain. */
   7122              i += 3;
   7123          
   7124              /* Iterate through and parse the CRTs in the provided chain. */
   7125              while (i < ssl->in_hslen) {
   7126                  /* Check that there's room for the next CRT's length fields. */
   7127                  if (i + 3 > ssl->in_hslen) {
   7128                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
   7129                      mbedtls_ssl_send_alert_message(ssl,
   7130                                                     MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7131                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   7132                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   7133                  }
   7134                  /* In theory, the CRT can be up to 2**24 Bytes, but we don't support
   7135                   * anything beyond 2**16 ~ 64K. */
   7136                  if (ssl->in_msg[i] != 0) {
   7137                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
   7138                      mbedtls_ssl_send_alert_message(ssl,
   7139                                                     MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7140                                                     MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT);
   7141                      return MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   7142                  }
   7143          
   7144                  /* Read length of the next CRT in the chain. */
   7145                  n = ((unsigned int) ssl->in_msg[i + 1] << 8)
   7146                      | (unsigned int) ssl->in_msg[i + 2];
   7147                  i += 3;
   7148          
   7149                  if (n < 128 || i + n > ssl->in_hslen) {
   7150                      MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
   7151                      mbedtls_ssl_send_alert_message(ssl,
   7152                                                     MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7153                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   7154                      return MBEDTLS_ERR_SSL_DECODE_ERROR;
   7155                  }
   7156          
   7157                  /* Check if we're handling the first CRT in the chain. */
   7158          #if defined(MBEDTLS_SSL_RENEGOTIATION) && defined(MBEDTLS_SSL_CLI_C)
   7159                  if (crt_cnt++ == 0 &&
   7160                      ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
   7161                      ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   7162                      /* During client-side renegotiation, check that the server's
   7163                       * end-CRTs hasn't changed compared to the initial handshake,
   7164                       * mitigating the triple handshake attack. On success, reuse
   7165                       * the original end-CRT instead of parsing it again. */
   7166                      MBEDTLS_SSL_DEBUG_MSG(3, ("Check that peer CRT hasn't changed during renegotiation"));
   7167                      if (ssl_check_peer_crt_unchanged(ssl,
   7168                                                       &ssl->in_msg[i],
   7169                                                       n) != 0) {
   7170                          MBEDTLS_SSL_DEBUG_MSG(1, ("new server cert during renegotiation"));
   7171                          mbedtls_ssl_send_alert_message(ssl,
   7172                                                         MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7173                                                         MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED);
   7174                          return MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   7175                      }
   7176          
   7177                      /* Now we can safely free the original chain. */
   7178                      ssl_clear_peer_cert(ssl->session);
   7179                  }
   7180          #endif /* MBEDTLS_SSL_RENEGOTIATION && MBEDTLS_SSL_CLI_C */
   7181          
   7182                  /* Parse the next certificate in the chain. */
   7183          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   7184                  ret = mbedtls_x509_crt_parse_der(chain, ssl->in_msg + i, n);
   7185          #else
   7186                  /* If we don't need to store the CRT chain permanently, parse
   7187                   * it in-place from the input buffer instead of making a copy. */
   7188                  ret = mbedtls_x509_crt_parse_der_nocopy(chain, ssl->in_msg + i, n);
   7189          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   7190                  switch (ret) {
   7191                      case 0: /*ok*/
   7192                      case MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND:
   7193                          /* Ignore certificate with an unknown algorithm: maybe a
   7194                             prior certificate was already trusted. */
   7195                          break;
   7196          
   7197                      case MBEDTLS_ERR_X509_ALLOC_FAILED:
   7198                          alert = MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR;
   7199                          goto crt_parse_der_failed;
   7200          
   7201                      case MBEDTLS_ERR_X509_UNKNOWN_VERSION:
   7202                          alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   7203                          goto crt_parse_der_failed;
   7204          
   7205                      default:
   7206                          alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
   7207          crt_parse_der_failed:
   7208                          mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, alert);
   7209                          MBEDTLS_SSL_DEBUG_RET(1, " mbedtls_x509_crt_parse_der", ret);
   7210                          return ret;
   7211                  }
   7212          
   7213                  i += n;
   7214              }
   7215          
   7216              MBEDTLS_SSL_DEBUG_CRT(3, "peer certificate", chain);
   7217              return 0;
   7218          }
   7219          
   7220          #if defined(MBEDTLS_SSL_SRV_C)
   7221          MBEDTLS_CHECK_RETURN_CRITICAL
   7222          static int ssl_srv_check_client_no_crt_notification(mbedtls_ssl_context *ssl)
   7223          {
   7224              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   7225                  return -1;
   7226              }
   7227          
   7228              if (ssl->in_hslen   == 3 + mbedtls_ssl_hs_hdr_len(ssl) &&
   7229                  ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    &&
   7230                  ssl->in_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   &&
   7231                  memcmp(ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl), "\0\0\0", 3) == 0) {
   7232                  MBEDTLS_SSL_DEBUG_MSG(1, ("peer has no certificate"));
   7233                  return 0;
   7234              }
   7235              return -1;
   7236          }
   7237          #endif /* MBEDTLS_SSL_SRV_C */
   7238          
   7239          /* Check if a certificate message is expected.
   7240           * Return either
   7241           * - SSL_CERTIFICATE_EXPECTED, or
   7242           * - SSL_CERTIFICATE_SKIP
   7243           * indicating whether a Certificate message is expected or not.
   7244           */
   7245          #define SSL_CERTIFICATE_EXPECTED 0
   7246          #define SSL_CERTIFICATE_SKIP     1
   7247          MBEDTLS_CHECK_RETURN_CRITICAL
   7248          static int ssl_parse_certificate_coordinate(mbedtls_ssl_context *ssl,
   7249                                                      int authmode)
   7250          {
   7251              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   7252                  ssl->handshake->ciphersuite_info;
   7253          
   7254              if (!mbedtls_ssl_ciphersuite_uses_srv_cert(ciphersuite_info)) {
   7255                  return SSL_CERTIFICATE_SKIP;
   7256              }
   7257          
   7258          #if defined(MBEDTLS_SSL_SRV_C)
   7259              if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   7260                  if (ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK) {
   7261                      return SSL_CERTIFICATE_SKIP;
   7262                  }
   7263          
   7264                  if (authmode == MBEDTLS_SSL_VERIFY_NONE) {
   7265                      ssl->session_negotiate->verify_result =
   7266                          MBEDTLS_X509_BADCERT_SKIP_VERIFY;
   7267                      return SSL_CERTIFICATE_SKIP;
   7268                  }
   7269              }
   7270          #else
   7271              ((void) authmode);
   7272          #endif /* MBEDTLS_SSL_SRV_C */
   7273          
   7274              return SSL_CERTIFICATE_EXPECTED;
   7275          }
   7276          
   7277          MBEDTLS_CHECK_RETURN_CRITICAL
   7278          static int ssl_parse_certificate_verify(mbedtls_ssl_context *ssl,
   7279                                                  int authmode,
   7280                                                  mbedtls_x509_crt *chain,
   7281                                                  void *rs_ctx)
   7282          {
   7283              int ret = 0;
   7284              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   7285                  ssl->handshake->ciphersuite_info;
   7286              int have_ca_chain = 0;
   7287          
   7288              int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *);
   7289              void *p_vrfy;
   7290          
   7291              if (authmode == MBEDTLS_SSL_VERIFY_NONE) {
   7292                  return 0;
   7293              }
   7294          
   7295              if (ssl->f_vrfy != NULL) {
   7296                  MBEDTLS_SSL_DEBUG_MSG(3, ("Use context-specific verification callback"));
   7297                  f_vrfy = ssl->f_vrfy;
   7298                  p_vrfy = ssl->p_vrfy;
   7299              } else {
   7300                  MBEDTLS_SSL_DEBUG_MSG(3, ("Use configuration-specific verification callback"));
   7301                  f_vrfy = ssl->conf->f_vrfy;
   7302                  p_vrfy = ssl->conf->p_vrfy;
   7303              }
   7304          
   7305              /*
   7306               * Main check: verify certificate
   7307               */
   7308          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   7309              if (ssl->conf->f_ca_cb != NULL) {
   7310                  ((void) rs_ctx);
   7311                  have_ca_chain = 1;
   7312          
   7313                  MBEDTLS_SSL_DEBUG_MSG(3, ("use CA callback for X.509 CRT verification"));
   7314                  ret = mbedtls_x509_crt_verify_with_ca_cb(
   7315                      chain,
   7316                      ssl->conf->f_ca_cb,
   7317                      ssl->conf->p_ca_cb,
   7318                      ssl->conf->cert_profile,
   7319                      ssl->hostname,
   7320                      &ssl->session_negotiate->verify_result,
   7321                      f_vrfy, p_vrfy);
   7322              } else
   7323          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   7324              {
   7325                  mbedtls_x509_crt *ca_chain;
   7326                  mbedtls_x509_crl *ca_crl;
   7327          
   7328          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   7329                  if (ssl->handshake->sni_ca_chain != NULL) {
   7330                      ca_chain = ssl->handshake->sni_ca_chain;
   7331                      ca_crl   = ssl->handshake->sni_ca_crl;
   7332                  } else
   7333          #endif
   7334                  {
   7335                      ca_chain = ssl->conf->ca_chain;
   7336                      ca_crl   = ssl->conf->ca_crl;
   7337                  }
   7338          
   7339                  if (ca_chain != NULL) {
   7340                      have_ca_chain = 1;
   7341                  }
   7342          
   7343                  ret = mbedtls_x509_crt_verify_restartable(
   7344                      chain,
   7345                      ca_chain, ca_crl,
   7346                      ssl->conf->cert_profile,
   7347                      ssl->hostname,
   7348                      &ssl->session_negotiate->verify_result,
   7349                      f_vrfy, p_vrfy, rs_ctx);
   7350              }
   7351          
   7352              if (ret != 0) {
   7353                  MBEDTLS_SSL_DEBUG_RET(1, "x509_verify_cert", ret);
   7354              }
   7355          
   7356          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   7357              if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   7358                  return MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS;
   7359              }
   7360          #endif
   7361          
   7362              /*
   7363               * Secondary checks: always done, but change 'ret' only if it was 0
   7364               */
   7365          
   7366          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
   7367              {
   7368                  const mbedtls_pk_context *pk = &chain->pk;
   7369          
   7370                  /* If certificate uses an EC key, make sure the curve is OK.
   7371                   * This is a public key, so it can't be opaque, so can_do() is a good
   7372                   * enough check to ensure pk_ec() is safe to use here. */
   7373                  if (mbedtls_pk_can_do(pk, MBEDTLS_PK_ECKEY)) {
   7374                      /* and in the unlikely case the above assumption no longer holds
   7375                       * we are making sure that pk_ec() here does not return a NULL
   7376                       */
   7377                      mbedtls_ecp_group_id grp_id = mbedtls_pk_get_group_id(pk);
   7378                      if (grp_id == MBEDTLS_ECP_DP_NONE) {
   7379                          MBEDTLS_SSL_DEBUG_MSG(1, ("invalid group ID"));
   7380                          return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   7381                      }
   7382                      if (mbedtls_ssl_check_curve(ssl, grp_id) != 0) {
   7383                          ssl->session_negotiate->verify_result |=
   7384                              MBEDTLS_X509_BADCERT_BAD_KEY;
   7385          
   7386                          MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate (EC key curve)"));
   7387                          if (ret == 0) {
   7388                              ret = MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   7389                          }
   7390                      }
   7391                  }
   7392              }
   7393          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   7394          
   7395              if (mbedtls_ssl_check_cert_usage(chain,
   7396                                               ciphersuite_info,
   7397                                               !ssl->conf->endpoint,
   7398                                               &ssl->session_negotiate->verify_result) != 0) {
   7399                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate (usage extensions)"));
   7400                  if (ret == 0) {
   7401                      ret = MBEDTLS_ERR_SSL_BAD_CERTIFICATE;
   7402                  }
   7403              }
   7404          
   7405              /* mbedtls_x509_crt_verify_with_profile is supposed to report a
   7406               * verification failure through MBEDTLS_ERR_X509_CERT_VERIFY_FAILED,
   7407               * with details encoded in the verification flags. All other kinds
   7408               * of error codes, including those from the user provided f_vrfy
   7409               * functions, are treated as fatal and lead to a failure of
   7410               * ssl_parse_certificate even if verification was optional. */
   7411              if (authmode == MBEDTLS_SSL_VERIFY_OPTIONAL &&
   7412                  (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ||
   7413                   ret == MBEDTLS_ERR_SSL_BAD_CERTIFICATE)) {
   7414                  ret = 0;
   7415              }
   7416          
   7417              if (have_ca_chain == 0 && authmode == MBEDTLS_SSL_VERIFY_REQUIRED) {
   7418                  MBEDTLS_SSL_DEBUG_MSG(1, ("got no CA chain"));
   7419                  ret = MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED;
   7420              }
   7421          
   7422              if (ret != 0) {
   7423                  uint8_t alert;
   7424          
   7425                  /* The certificate may have been rejected for several reasons.
   7426                     Pick one and send the corresponding alert. Which alert to send
   7427                     may be a subject of debate in some cases. */
   7428                  if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_OTHER) {
   7429                      alert = MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED;
   7430                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_CN_MISMATCH) {
   7431                      alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
   7432                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_KEY_USAGE) {
   7433                      alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   7434                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXT_KEY_USAGE) {
   7435                      alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   7436                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_NS_CERT_TYPE) {
   7437                      alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   7438                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_PK) {
   7439                      alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   7440                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_KEY) {
   7441                      alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   7442                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXPIRED) {
   7443                      alert = MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED;
   7444                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_REVOKED) {
   7445                      alert = MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED;
   7446                  } else if (ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_NOT_TRUSTED) {
   7447                      alert = MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA;
   7448                  } else {
   7449                      alert = MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN;
   7450                  }
   7451                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7452                                                 alert);
   7453              }
   7454          
   7455          #if defined(MBEDTLS_DEBUG_C)
   7456              if (ssl->session_negotiate->verify_result != 0) {
   7457                  MBEDTLS_SSL_DEBUG_MSG(3, ("! Certificate verification flags %08x",
   7458                                            (unsigned int) ssl->session_negotiate->verify_result));
   7459              } else {
   7460                  MBEDTLS_SSL_DEBUG_MSG(3, ("Certificate verification flags clear"));
   7461              }
   7462          #endif /* MBEDTLS_DEBUG_C */
   7463          
   7464              return ret;
   7465          }
   7466          
   7467          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   7468          MBEDTLS_CHECK_RETURN_CRITICAL
   7469          static int ssl_remember_peer_crt_digest(mbedtls_ssl_context *ssl,
   7470                                                  unsigned char *start, size_t len)
   7471          {
   7472              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   7473              /* Remember digest of the peer's end-CRT. */
   7474              ssl->session_negotiate->peer_cert_digest =
   7475                  mbedtls_calloc(1, MBEDTLS_SSL_PEER_CERT_DIGEST_DFL_LEN);
   7476              if (ssl->session_negotiate->peer_cert_digest == NULL) {
   7477                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc(%d bytes) failed",
   7478                                            MBEDTLS_SSL_PEER_CERT_DIGEST_DFL_LEN));
   7479                  mbedtls_ssl_send_alert_message(ssl,
   7480                                                 MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7481                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   7482          
   7483                  return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   7484              }
   7485          
   7486              ret = mbedtls_md(mbedtls_md_info_from_type(
   7487                                   MBEDTLS_SSL_PEER_CERT_DIGEST_DFL_TYPE),
   7488                               start, len,
   7489                               ssl->session_negotiate->peer_cert_digest);
   7490          
   7491              ssl->session_negotiate->peer_cert_digest_type =
   7492                  MBEDTLS_SSL_PEER_CERT_DIGEST_DFL_TYPE;
   7493              ssl->session_negotiate->peer_cert_digest_len =
   7494                  MBEDTLS_SSL_PEER_CERT_DIGEST_DFL_LEN;
   7495          
   7496              return ret;
   7497          }
   7498          
   7499          MBEDTLS_CHECK_RETURN_CRITICAL
   7500          static int ssl_remember_peer_pubkey(mbedtls_ssl_context *ssl,
   7501                                              unsigned char *start, size_t len)
   7502          {
   7503              unsigned char *end = start + len;
   7504              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   7505          
   7506              /* Make a copy of the peer's raw public key. */
   7507              mbedtls_pk_init(&ssl->handshake->peer_pubkey);
   7508              ret = mbedtls_pk_parse_subpubkey(&start, end,
   7509                                               &ssl->handshake->peer_pubkey);
   7510              if (ret != 0) {
   7511                  /* We should have parsed the public key before. */
   7512                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   7513              }
   7514          
   7515              return 0;
   7516          }
   7517          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   7518          

   \                                 In section .text, align 2, keep-with-next
   7519          int mbedtls_ssl_parse_certificate(mbedtls_ssl_context *ssl)
   7520          {
   \                     mbedtls_ssl_parse_certificate: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0A8             SUB      SP,SP,#+160
   \        0x6   0x4605             MOV      R5,R0
   7521              int ret = 0;
   7522              int crt_expected;
   7523          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   7524              const int authmode = ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET
   7525                                 ? ssl->handshake->sni_authmode
   7526                                 : ssl->conf->authmode;
   7527          #else
   7528              const int authmode = ssl->conf->authmode;
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   7529          #endif
   7530              void *rs_ctx = NULL;
   7531              mbedtls_x509_crt *chain = NULL;
   7532          
   7533              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse certificate"));
   7534          
   7535              crt_expected = ssl_parse_certificate_coordinate(ssl, authmode);
   \        0xA   0x6BA9             LDR      R1,[R5, #+56]
   \        0xC   0x2400             MOVS     R4,#+0
   \        0xE   0x7986             LDRB     R6,[R0, #+6]
   \       0x10   0x6888             LDR      R0,[R1, #+8]
   \       0x12   0x46A1             MOV      R9,R4
   \       0x14   0x7A83             LDRB     R3,[R0, #+10]
   \       0x16   0x1E5B             SUBS     R3,R3,#+1
   \       0x18   0x2B03             CMP      R3,#+3
   \       0x1A   0xD904             BLS.N    ??mbedtls_ssl_parse_certificate_0
   \       0x1C   0x1F9B             SUBS     R3,R3,#+6
   \       0x1E   0xD002             BEQ.N    ??mbedtls_ssl_parse_certificate_0
   \       0x20   0x1E9B             SUBS     R3,R3,#+2
   \       0x22   0x2B01             CMP      R3,#+1
   \       0x24   0xD85C             BHI.N    ??mbedtls_ssl_parse_certificate_1
   7536              if (crt_expected == SSL_CERTIFICATE_SKIP) {
   7537                  MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip parse certificate"));
   7538                  goto exit;
   7539              }
   7540          
   7541          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   7542              if (ssl->handshake->ecrs_enabled &&
   7543                  ssl->handshake->ecrs_state == ssl_ecrs_crt_verify) {
   7544                  chain = ssl->handshake->ecrs_peer_cert;
   7545                  ssl->handshake->ecrs_peer_cert = NULL;
   7546                  goto crt_verify;
   7547              }
   7548          #endif
   7549          
   7550              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \                     ??mbedtls_ssl_parse_certificate_0: (+1)
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x2E   0x0004             MOVS     R4,R0
   \       0x30   0xD156             BNE.N    ??mbedtls_ssl_parse_certificate_1
   7551                  /* mbedtls_ssl_read_record may have sent an alert already. We
   7552                     let it decide whether to alert. */
   7553                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   7554                  goto exit;
   7555              }
   7556          
   7557          #if defined(MBEDTLS_SSL_SRV_C)
   7558              if (ssl_srv_check_client_no_crt_notification(ssl) == 0) {
   7559                  ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_MISSING;
   7560          
   7561                  if (authmode != MBEDTLS_SSL_VERIFY_OPTIONAL) {
   7562                      ret = MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE;
   7563                  }
   7564          
   7565                  goto exit;
   7566              }
   7567          #endif /* MBEDTLS_SSL_SRV_C */
   7568          
   7569              /* Clear existing peer CRT structure in case we tried to
   7570               * reuse a session but it failed, and allocate a new one. */
   7571              ssl_clear_peer_cert(ssl->session_negotiate);
   \       0x32   0x6B68             LDR      R0,[R5, #+52]
   \       0x34   0x.... 0x....      BL       ssl_clear_peer_cert
   7572          
   7573              chain = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
   \       0x38   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x3C   0xEA5F 0x0900      MOVS     R9,R0
   7574              if (chain == NULL) {
   \       0x40   0xD105             BNE.N    ??mbedtls_ssl_parse_certificate_2
   7575                  MBEDTLS_SSL_DEBUG_MSG(1, ("alloc(%" MBEDTLS_PRINTF_SIZET " bytes) failed",
   7576                                            sizeof(mbedtls_x509_crt)));
   7577                  mbedtls_ssl_send_alert_message(ssl,
   7578                                                 MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7579                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   \       0x42   0x2250             MOVS     R2,#+80
   \       0x44   0x.... 0x....      BL       ??Subroutine10_0
   7580          
   7581                  ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x48   0x.... 0x....      LDR.W    R4,??DataTable37_26
   7582                  goto exit;
   \       0x4C   0xE11F             B.N      ??mbedtls_ssl_parse_certificate_3
   7583              }
   7584              mbedtls_x509_crt_init(chain);
   \                     ??mbedtls_ssl_parse_certificate_2: (+1)
   \       0x4E   0x.... 0x....      BL       mbedtls_x509_crt_init
   7585          
   7586              ret = ssl_parse_certificate_chain(ssl, chain);
   \       0x52   0x6F68             LDR      R0,[R5, #+116]
   \       0x54   0x2816             CMP      R0,#+22
   \       0x56   0xBF02             ITTT     EQ
   \       0x58   0x6EE9             LDREQ    R1,[R5, #+108]
   \       0x5A   0x7808             LDRBEQ   R0,[R1, #+0]
   \       0x5C   0x280B             CMPEQ    R0,#+11
   \       0x5E   0xD15D             BNE.N    ??mbedtls_ssl_parse_certificate_4
   \       0x60   0xF8D5 0x2080      LDR      R2,[R5, #+128]
   \       0x64   0x2A0A             CMP      R2,#+10
   \       0x66   0xD354             BCC.N    ??mbedtls_ssl_parse_certificate_5
   \       0x68   0x7908             LDRB     R0,[R1, #+4]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD151             BNE.N    ??mbedtls_ssl_parse_certificate_5
   \       0x6E   0x7948             LDRB     R0,[R1, #+5]
   \       0x70   0x7989             LDRB     R1,[R1, #+6]
   \       0x72   0x1FD2             SUBS     R2,R2,#+7
   \       0x74   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \       0x78   0x428A             CMP      R2,R1
   \       0x7A   0xD14A             BNE.N    ??mbedtls_ssl_parse_certificate_5
   \       0x7C   0x2707             MOVS     R7,#+7
   \       0x7E   0xE019             B.N      ??mbedtls_ssl_parse_certificate_6
   \                     ??mbedtls_ssl_parse_certificate_7: (+1)
   \       0x80   0x7850             LDRB     R0,[R2, #+1]
   \       0x82   0x7892             LDRB     R2,[R2, #+2]
   \       0x84   0xEA42 0x2200      ORR      R2,R2,R0, LSL #+8
   \       0x88   0x2A80             CMP      R2,#+128
   \       0x8A   0xBF24             ITT      CS
   \       0x8C   0x1917             ADDCS    R7,R2,R4
   \       0x8E   0x42B9             CMPCS    R1,R7
   \       0x90   0xD33F             BCC.N    ??mbedtls_ssl_parse_certificate_5
   \       0x92   0x1919             ADDS     R1,R3,R4
   \       0x94   0x4648             MOV      R0,R9
   \       0x96   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0x9A   0x0004             MOVS     R4,R0
   \       0x9C   0xD00A             BEQ.N    ??mbedtls_ssl_parse_certificate_6
   \       0x9E   0x.... 0x....      LDR.W    R0,??DataTable37_27
   \       0xA2   0x1A21             SUBS     R1,R4,R0
   \       0xA4   0xD02F             BEQ.N    ??mbedtls_ssl_parse_certificate_8
   \       0xA6   0xF240 0x2052      MOVW     R0,#+594
   \       0xAA   0x1A09             SUBS     R1,R1,R0
   \       0xAC   0xD002             BEQ.N    ??mbedtls_ssl_parse_certificate_6
   \       0xAE   0x39AE             SUBS     R1,R1,#+174
   \       0xB0   0xD012             BEQ.N    ??mbedtls_ssl_parse_certificate_9
   \       0xB2   0xE02A             B.N      ??mbedtls_ssl_parse_certificate_10
   \                     ??mbedtls_ssl_parse_certificate_6: (+1)
   \       0xB4   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \       0xB8   0x428F             CMP      R7,R1
   \       0xBA   0xD228             BCS.N    ??mbedtls_ssl_parse_certificate_11
   \       0xBC   0x1CFC             ADDS     R4,R7,#+3
   \       0xBE   0x42A1             CMP      R1,R4
   \       0xC0   0xD327             BCC.N    ??mbedtls_ssl_parse_certificate_5
   \       0xC2   0x6EEB             LDR      R3,[R5, #+108]
   \       0xC4   0x19DA             ADDS     R2,R3,R7
   \       0xC6   0x7810             LDRB     R0,[R2, #+0]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD0D9             BEQ.N    ??mbedtls_ssl_parse_certificate_7
   \       0xCC   0x222B             MOVS     R2,#+43
   \       0xCE   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xD2   0x.... 0x....      LDR.W    R4,??DataTable37_28
   \       0xD6   0xE0D4             B.N      ??mbedtls_ssl_parse_certificate_12
   \                     ??mbedtls_ssl_parse_certificate_9: (+1)
   \       0xD8   0x222B             MOVS     R2,#+43
   \                     ??mbedtls_ssl_parse_certificate_13: (+1)
   \       0xDA   0x.... 0x....      BL       ??Subroutine10_0
   7587              if (ret != 0) {
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0xDE   0x2C00             CMP      R4,#+0
   \                     ??mbedtls_ssl_parse_certificate_1: (+1)
   \       0xE0   0xF040 0x80C8      BNE.W    ??mbedtls_ssl_parse_certificate_14
   7588                  goto exit;
   7589              }
   7590          
   7591          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   7592              if (ssl->handshake->ecrs_enabled) {
   7593                  ssl->handshake->ecrs_state = ssl_ecrs_crt_verify;
   7594              }
   7595          
   7596          crt_verify:
   7597              if (ssl->handshake->ecrs_enabled) {
   7598                  rs_ctx = &ssl->handshake->ecrs_ctx;
   7599              }
   7600          #endif
   7601          
   7602              ret = ssl_parse_certificate_verify(ssl, authmode,
   7603                                                 chain, rs_ctx);
   \                     ??mbedtls_ssl_parse_certificate_15: (+1)
   \       0xE4   0x6BA8             LDR      R0,[R5, #+56]
   \       0xE6   0x2700             MOVS     R7,#+0
   \       0xE8   0x2E00             CMP      R6,#+0
   \       0xEA   0xF8D0 0xA008      LDR      R10,[R0, #+8]
   \       0xEE   0xF000 0x80BB      BEQ.W    ??mbedtls_ssl_parse_certificate_16
   \       0xF2   0x6928             LDR      R0,[R5, #+16]
   \       0xF4   0x682B             LDR      R3,[R5, #+0]
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xBF12             ITEE     NE
   \       0xFA   0xF8D5 0xC014      LDRNE    R12,[R5, #+20]
   \       0xFE   0x6AD8             LDREQ    R0,[R3, #+44]
   \      0x100   0xF8D3 0xC030      LDREQ    R12,[R3, #+48]
   \      0x104   0xE010             B.N      ??mbedtls_ssl_parse_certificate_17
   \                     ??mbedtls_ssl_parse_certificate_8: (+1)
   \      0x106   0x2250             MOVS     R2,#+80
   \      0x108   0xE7E7             B.N      ??mbedtls_ssl_parse_certificate_13
   \                     ??mbedtls_ssl_parse_certificate_10: (+1)
   \      0x10A   0x222A             MOVS     R2,#+42
   \      0x10C   0xE7E5             B.N      ??mbedtls_ssl_parse_certificate_13
   \                     ??mbedtls_ssl_parse_certificate_11: (+1)
   \      0x10E   0x2400             MOVS     R4,#+0
   \      0x110   0xE7E8             B.N      ??mbedtls_ssl_parse_certificate_15
   \                     ??mbedtls_ssl_parse_certificate_5: (+1)
   \      0x112   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_17: (+1)
   \      0x116   0x.... 0x....      LDR.W    R4,??DataTable36
   \      0x11A   0xE0B2             B.N      ??mbedtls_ssl_parse_certificate_12
   \                     ??mbedtls_ssl_parse_certificate_4: (+1)
   \      0x11C   0x220A             MOVS     R2,#+10
   \      0x11E   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_18: (+1)
   \      0x122   0x.... 0x....      LDR.W    R4,??DataTable37_29
   \      0x126   0xE0AC             B.N      ??mbedtls_ssl_parse_certificate_12
   \                     ??mbedtls_ssl_parse_certificate_17: (+1)
   \      0x128   0x6BD9             LDR      R1,[R3, #+60]
   \      0x12A   0x6C1A             LDR      R2,[R3, #+64]
   \      0x12C   0xB101             CBZ.N    R1,??mbedtls_ssl_parse_certificate_18
   \      0x12E   0x2701             MOVS     R7,#+1
   \                     ??mbedtls_ssl_parse_certificate_18: (+1)
   \      0x130   0x2400             MOVS     R4,#+0
   \      0x132   0x9404             STR      R4,[SP, #+16]
   \      0x134   0xF8CD 0xC00C      STR      R12,[SP, #+12]
   \      0x138   0x9002             STR      R0,[SP, #+8]
   \      0x13A   0x6B68             LDR      R0,[R5, #+52]
   \      0x13C   0xF109 0x0BCC      ADD      R11,R9,#+204
   \      0x140   0x.... 0x....      LDR.W    R8,??DataTable37_28
   \      0x144   0x3060             ADDS     R0,R0,#+96
   \      0x146   0x9001             STR      R0,[SP, #+4]
   \      0x148   0xF8D5 0x00C0      LDR      R0,[R5, #+192]
   \      0x14C   0x9000             STR      R0,[SP, #+0]
   \      0x14E   0x6B5B             LDR      R3,[R3, #+52]
   \      0x150   0x4648             MOV      R0,R9
   \      0x152   0x.... 0x....      BL       mbedtls_x509_crt_verify_restartable
   \      0x156   0x4604             MOV      R4,R0
   \      0x158   0x2102             MOVS     R1,#+2
   \      0x15A   0x4658             MOV      R0,R11
   \      0x15C   0x.... 0x....      BL       mbedtls_pk_can_do
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD043             BEQ.N    ??mbedtls_ssl_parse_certificate_19
   \      0x164   0x4658             MOV      R0,R11
   \      0x166   0x.... 0x....      BL       mbedtls_pk_get_type
   \      0x16A   0x2807             CMP      R0,#+7
   \      0x16C   0x4668             MOV      R0,SP
   \      0x16E   0xD11F             BNE.N    ??mbedtls_ssl_parse_certificate_20
   \      0x170   0x2124             MOVS     R1,#+36
   \      0x172   0x.... 0x....      BL       __aeabi_memclr4
   \      0x176   0xF8D9 0x00D4      LDR      R0,[R9, #+212]
   \      0x17A   0x4669             MOV      R1,SP
   \      0x17C   0x.... 0x....      BL       psa_get_key_attributes
   \      0x180   0xB110             CBZ.N    R0,??mbedtls_ssl_parse_certificate_21
   \                     ??mbedtls_ssl_parse_certificate_22: (+1)
   \      0x182   0x.... 0x....      LDR.W    R4,??DataTable37_2
   \      0x186   0xE07C             B.N      ??mbedtls_ssl_parse_certificate_12
   \                     ??mbedtls_ssl_parse_certificate_21: (+1)
   \      0x188   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x18C   0x.... 0x....      LDR.W    R1,??DataTable37_30
   \      0x190   0x4001             ANDS     R1,R1,R0
   \      0x192   0xF5B1 0x4F82      CMP      R1,#+16640
   \      0x196   0xBF18             IT       NE
   \      0x198   0x2000             MOVNE    R0,#+0
   \      0x19A   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \      0x19E   0x2200             MOVS     R2,#+0
   \      0x1A0   0xB2C0             UXTB     R0,R0
   \      0x1A2   0x.... 0x....      BL       mbedtls_ecc_group_of_psa
   \      0x1A6   0x4683             MOV      R11,R0
   \      0x1A8   0x4668             MOV      R0,SP
   \      0x1AA   0x.... 0x....      BL       psa_reset_key_attributes
   \      0x1AE   0xE00E             B.N      ??mbedtls_ssl_parse_certificate_23
   \                     ??mbedtls_ssl_parse_certificate_20: (+1)
   \      0x1B0   0xF109 0x01CC      ADD      R1,R9,#+204
   \      0x1B4   0x22A0             MOVS     R2,#+160
   \      0x1B6   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x1BA   0x4668             MOV      R0,SP
   \      0x1BC   0x.... 0x....      BL       mbedtls_pk_get_type
   \      0x1C0   0x1E80             SUBS     R0,R0,#+2
   \      0x1C2   0x2802             CMP      R0,#+2
   \      0x1C4   0xBF94             ITE      LS
   \      0x1C6   0x9801             LDRLS    R0,[SP, #+4]
   \      0x1C8   0x2000             MOVHI    R0,#+0
   \      0x1CA   0xF890 0xB000      LDRB     R11,[R0, #+0]
   \                     ??mbedtls_ssl_parse_certificate_23: (+1)
   \      0x1CE   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x1D2   0xD0D6             BEQ.N    ??mbedtls_ssl_parse_certificate_22
   \      0x1D4   0x4659             MOV      R1,R11
   \      0x1D6   0x4628             MOV      R0,R5
   \      0x1D8   0x.... 0x....      BL       mbedtls_ssl_check_curve
   \      0x1DC   0xB130             CBZ.N    R0,??mbedtls_ssl_parse_certificate_19
   \      0x1DE   0x6B68             LDR      R0,[R5, #+52]
   \      0x1E0   0x6E01             LDR      R1,[R0, #+96]
   \      0x1E2   0xF441 0x3180      ORR      R1,R1,#0x10000
   \      0x1E6   0x6601             STR      R1,[R0, #+96]
   \      0x1E8   0xB904             CBNZ.N   R4,??mbedtls_ssl_parse_certificate_19
   \      0x1EA   0x4644             MOV      R4,R8
   \                     ??mbedtls_ssl_parse_certificate_19: (+1)
   \      0x1EC   0x6828             LDR      R0,[R5, #+0]
   \      0x1EE   0x7901             LDRB     R1,[R0, #+4]
   \      0x1F0   0x6B68             LDR      R0,[R5, #+52]
   \      0x1F2   0x1E4A             SUBS     R2,R1,#+1
   \      0x1F4   0x4192             SBCS     R2,R2,R2
   \      0x1F6   0xF100 0x0360      ADD      R3,R0,#+96
   \      0x1FA   0x0FD2             LSRS     R2,R2,#+31
   \      0x1FC   0x4651             MOV      R1,R10
   \      0x1FE   0x4648             MOV      R0,R9
   \      0x200   0x.... 0x....      BL       mbedtls_ssl_check_cert_usage
   \      0x204   0xB108             CBZ.N    R0,??mbedtls_ssl_parse_certificate_24
   \      0x206   0xB904             CBNZ.N   R4,??mbedtls_ssl_parse_certificate_24
   \      0x208   0x4644             MOV      R4,R8
   \                     ??mbedtls_ssl_parse_certificate_24: (+1)
   \      0x20A   0x2E01             CMP      R6,#+1
   \      0x20C   0xD10D             BNE.N    ??mbedtls_ssl_parse_certificate_25
   \      0x20E   0xF514 0x5F1C      CMN      R4,#+9984
   \      0x212   0xD101             BNE.N    ??mbedtls_ssl_parse_certificate_26
   \                     ??mbedtls_ssl_parse_certificate_27: (+1)
   \      0x214   0x2400             MOVS     R4,#+0
   \      0x216   0xE026             B.N      ??CrossCallReturnLabel_19
   \                     ??mbedtls_ssl_parse_certificate_26: (+1)
   \      0x218   0x4544             CMP      R4,R8
   \      0x21A   0xD0FB             BEQ.N    ??mbedtls_ssl_parse_certificate_27
   \                     ??mbedtls_ssl_parse_certificate_28: (+1)
   \      0x21C   0xB31C             CBZ.N    R4,??CrossCallReturnLabel_19
   \                     ??mbedtls_ssl_parse_certificate_29: (+1)
   \      0x21E   0x6B68             LDR      R0,[R5, #+52]
   \      0x220   0x6E00             LDR      R0,[R0, #+96]
   \      0x222   0x05C1             LSLS     R1,R0,#+23
   \      0x224   0xD508             BPL.N    ??mbedtls_ssl_parse_certificate_30
   \      0x226   0x2231             MOVS     R2,#+49
   \      0x228   0xE01B             B.N      ??mbedtls_ssl_parse_certificate_31
   \                     ??mbedtls_ssl_parse_certificate_25: (+1)
   \      0x22A   0x2F00             CMP      R7,#+0
   \      0x22C   0xBF08             IT       EQ
   \      0x22E   0x2E02             CMPEQ    R6,#+2
   \      0x230   0xD1F4             BNE.N    ??mbedtls_ssl_parse_certificate_28
   \      0x232   0x.... 0x....      LDR.W    R4,??DataTable37_31
   \      0x236   0xE7F2             B.N      ??mbedtls_ssl_parse_certificate_29
   \                     ??mbedtls_ssl_parse_certificate_30: (+1)
   \      0x238   0x0741             LSLS     R1,R0,#+29
   \      0x23A   0xBF48             IT       MI
   \      0x23C   0x222A             MOVMI    R2,#+42
   \      0x23E   0xD410             BMI.N    ??mbedtls_ssl_parse_certificate_31
   \      0x240   0xF410 0x3FDC      TST      R0,#0x1B800
   \      0x244   0xD10C             BNE.N    ??mbedtls_ssl_parse_certificate_32
   \      0x246   0x07C1             LSLS     R1,R0,#+31
   \      0x248   0xBF48             IT       MI
   \      0x24A   0x222D             MOVMI    R2,#+45
   \      0x24C   0xD409             BMI.N    ??mbedtls_ssl_parse_certificate_31
   \      0x24E   0x0781             LSLS     R1,R0,#+30
   \      0x250   0xBF48             IT       MI
   \      0x252   0x222C             MOVMI    R2,#+44
   \      0x254   0xD405             BMI.N    ??mbedtls_ssl_parse_certificate_31
   \      0x256   0x0700             LSLS     R0,R0,#+28
   \      0x258   0xBF54             ITE      PL
   \      0x25A   0x222E             MOVPL    R2,#+46
   \      0x25C   0x2230             MOVMI    R2,#+48
   \      0x25E   0xE000             B.N      ??mbedtls_ssl_parse_certificate_31
   \                     ??mbedtls_ssl_parse_certificate_32: (+1)
   \      0x260   0x222B             MOVS     R2,#+43
   \                     ??mbedtls_ssl_parse_certificate_31: (+1)
   \      0x262   0x.... 0x....      BL       ??Subroutine10_0
   7604              if (ret != 0) {
   \                     ??CrossCallReturnLabel_19: (+1)
   \      0x266   0xB94C             CBNZ.N   R4,??mbedtls_ssl_parse_certificate_33
   7605                  goto exit;
   7606              }
   7607          
   7608          #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   7609              {
   7610                  unsigned char *crt_start, *pk_start;
   7611                  size_t crt_len, pk_len;
   7612          
   7613                  /* We parse the CRT chain without copying, so
   7614                   * these pointers point into the input buffer,
   7615                   * and are hence still valid after freeing the
   7616                   * CRT chain. */
   7617          
   7618                  crt_start = chain->raw.p;
   7619                  crt_len   = chain->raw.len;
   7620          
   7621                  pk_start = chain->pk_raw.p;
   7622                  pk_len   = chain->pk_raw.len;
   7623          
   7624                  /* Free the CRT structures before computing
   7625                   * digest and copying the peer's public key. */
   7626                  mbedtls_x509_crt_free(chain);
   7627                  mbedtls_free(chain);
   7628                  chain = NULL;
   7629          
   7630                  ret = ssl_remember_peer_crt_digest(ssl, crt_start, crt_len);
   7631                  if (ret != 0) {
   7632                      goto exit;
   7633                  }
   7634          
   7635                  ret = ssl_remember_peer_pubkey(ssl, pk_start, pk_len);
   7636                  if (ret != 0) {
   7637                      goto exit;
   7638                  }
   7639              }
   7640          #else /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   7641              /* Pass ownership to session structure. */
   7642              ssl->session_negotiate->peer_cert = chain;
   \                     ??mbedtls_ssl_parse_certificate_16: (+1)
   \      0x268   0x6B68             LDR      R0,[R5, #+52]
   \      0x26A   0xF8C0 0x905C      STR      R9,[R0, #+92]
   7643              chain = NULL;
   \      0x26E   0xF04F 0x0900      MOV      R9,#+0
   7644          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   7645          
   7646              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse certificate"));
   \      0x272   0xE000             B.N      ??mbedtls_ssl_parse_certificate_34
   7647          
   7648          exit:
   7649          
   7650              if (ret == 0) {
   \                     ??mbedtls_ssl_parse_certificate_14: (+1)
   \      0x274   0xB914             CBNZ.N   R4,??mbedtls_ssl_parse_certificate_33
   7651                  ssl->state++;
   \                     ??mbedtls_ssl_parse_certificate_34: (+1)
   \      0x276   0x6868             LDR      R0,[R5, #+4]
   \      0x278   0x1C40             ADDS     R0,R0,#+1
   \      0x27A   0x6068             STR      R0,[R5, #+4]
   7652              }
   7653          
   7654          #if defined(MBEDTLS_SSL_ECP_RESTARTABLE_ENABLED)
   7655              if (ret == MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS) {
   7656                  ssl->handshake->ecrs_peer_cert = chain;
   7657                  chain = NULL;
   7658              }
   7659          #endif
   7660          
   7661              if (chain != NULL) {
   \                     ??mbedtls_ssl_parse_certificate_33: (+1)
   \      0x27C   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x280   0xD005             BEQ.N    ??mbedtls_ssl_parse_certificate_3
   7662                  mbedtls_x509_crt_free(chain);
   \                     ??mbedtls_ssl_parse_certificate_12: (+1)
   \      0x282   0x4648             MOV      R0,R9
   \      0x284   0x.... 0x....      BL       mbedtls_x509_crt_free
   7663                  mbedtls_free(chain);
   \      0x288   0x4648             MOV      R0,R9
   \      0x28A   0x.... 0x....      BL       sl_free
   7664              }
   7665          
   7666              return ret;
   \                     ??mbedtls_ssl_parse_certificate_3: (+1)
   \      0x28E   0x4620             MOV      R0,R4
   \      0x290   0xB029             ADD      SP,SP,#+164
   \      0x292   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   7667          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x2232             MOVS     R2,#+50
   \                     ??Subroutine10_0: (+1)
   \        0x2   0x2102             MOVS     R1,#+2
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x.... 0x....      B.W      mbedtls_ssl_send_alert_message
   7668          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
   7669          
   7670          static int ssl_calc_finished_tls_generic(mbedtls_ssl_context *ssl, void *ctx,
   7671                                                   unsigned char *padbuf, size_t hlen,
   7672                                                   unsigned char *buf, int from)
   7673          {
   7674              int len = 12;
   7675              const char *sender;
   7676          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   7677              psa_status_t status;
   7678              psa_hash_operation_t *hs_op = ctx;

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0x8                      DS8 216
   7679              psa_hash_operation_t cloned_op = PSA_HASH_OPERATION_INIT;
   7680              size_t hash_size;
   7681          #else
   7682              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   7683              mbedtls_md_context_t *hs_ctx = ctx;
   7684              mbedtls_md_context_t cloned_ctx;
   7685              mbedtls_md_init(&cloned_ctx);
   7686          #endif
   7687          
   7688              mbedtls_ssl_session *session = ssl->session_negotiate;
   7689              if (!session) {
   7690                  session = ssl->session;
   7691              }
   7692          
   7693              sender = (from == MBEDTLS_SSL_IS_CLIENT)
   7694                       ? "client finished"
   7695                       : "server finished";
   7696          
   7697          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   7698              MBEDTLS_SSL_DEBUG_MSG(2, ("=> calc PSA finished tls"));
   7699          
   7700              status = psa_hash_clone(hs_op, &cloned_op);
   7701              if (status != PSA_SUCCESS) {
   7702                  goto exit;
   7703              }
   7704          
   7705              status = psa_hash_finish(&cloned_op, padbuf, hlen, &hash_size);
   7706              if (status != PSA_SUCCESS) {
   7707                  goto exit;
   7708              }
   7709              MBEDTLS_SSL_DEBUG_BUF(3, "PSA calculated padbuf", padbuf, hlen);
   7710          #else
   7711              MBEDTLS_SSL_DEBUG_MSG(2, ("=> calc finished tls"));
   7712          
   7713              ret = mbedtls_md_setup(&cloned_ctx, mbedtls_md_info_from_ctx(hs_ctx), 0);
   7714              if (ret != 0) {
   7715                  goto exit;
   7716              }
   7717              ret = mbedtls_md_clone(&cloned_ctx, hs_ctx);
   7718              if (ret != 0) {
   7719                  goto exit;
   7720              }
   7721          
   7722              ret = mbedtls_md_finish(&cloned_ctx, padbuf);
   7723              if (ret != 0) {
   7724                  goto exit;
   7725              }
   7726          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   7727          
   7728              MBEDTLS_SSL_DEBUG_BUF(4, "finished output", padbuf, hlen);
   7729          
   7730              /*
   7731               * TLSv1.2:
   7732               *   hash = PRF( master, finished_label,
   7733               *               Hash( handshake ) )[0.11]
   7734               */
   7735              ssl->handshake->tls_prf(session->master, 48, sender,
   7736                                      padbuf, hlen, buf, len);
   7737          
   7738              MBEDTLS_SSL_DEBUG_BUF(3, "calc finished result", buf, len);
   7739          
   7740              mbedtls_platform_zeroize(padbuf, hlen);
   7741          
   7742              MBEDTLS_SSL_DEBUG_MSG(2, ("<= calc finished"));
   7743          
   7744          exit:
   7745          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   7746              psa_hash_abort(&cloned_op);
   7747              return mbedtls_md_error_from_psa(status);
   7748          #else
   7749              mbedtls_md_free(&cloned_ctx);
   7750              return ret;
   7751          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   7752          }
   7753          
   7754          #if defined(MBEDTLS_MD_CAN_SHA256)

   \                                 In section .text, align 4, keep-with-next
   7755          static int ssl_calc_finished_tls_sha256(
   7756              mbedtls_ssl_context *ssl, unsigned char *buf, int from)
   7757          {
   \                     ssl_calc_finished_tls_sha256: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB0C4             SUB      SP,SP,#+272
   \        0x6   0x4607             MOV      R7,R0
   7758              unsigned char padbuf[32];
   7759              return ssl_calc_finished_tls_generic(ssl,
   7760          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   7761                                                   &ssl->handshake->fin_sha256_psa,
   7762          #else
   7763                                                   &ssl->handshake->fin_sha256,
   7764          #endif
   7765                                                   padbuf, sizeof(padbuf),
   7766                                                   buf, from);
   \        0x8   0x6BBD             LDR      R5,[R7, #+56]
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x4614             MOV      R4,R2
   \        0xE   0xA80C             ADD      R0,SP,#+48
   \       0x10   0x21E0             MOVS     R1,#+224
   \       0x12   0xF105 0x09EC      ADD      R9,R5,#+236
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
   \       0x1A   0x6B7D             LDR      R5,[R7, #+52]
   \       0x1C   0xB905             CBNZ.N   R5,??ssl_calc_finished_tls_sha256_0
   \       0x1E   0x6B3D             LDR      R5,[R7, #+48]
   \                     ??ssl_calc_finished_tls_sha256_0: (+1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xBF0C             ITE      EQ
   \       0x24   0x.... 0x....      ADREQ.W  R8,?_11
   \       0x28   0x.... 0x....      ADRNE.W  R8,?_12
   \       0x2C   0xA90C             ADD      R1,SP,#+48
   \       0x2E   0x4648             MOV      R0,R9
   \       0x30   0x.... 0x....      BL       psa_hash_clone
   \       0x34   0x0004             MOVS     R4,R0
   \       0x36   0xD118             BNE.N    ??ssl_calc_finished_tls_sha256_1
   \       0x38   0xAB03             ADD      R3,SP,#+12
   \       0x3A   0x2220             MOVS     R2,#+32
   \       0x3C   0xA904             ADD      R1,SP,#+16
   \       0x3E   0xA80C             ADD      R0,SP,#+48
   \       0x40   0x.... 0x....      BL       psa_hash_finish
   \       0x44   0x0004             MOVS     R4,R0
   \       0x46   0xD110             BNE.N    ??ssl_calc_finished_tls_sha256_1
   \       0x48   0x9601             STR      R6,[SP, #+4]
   \       0x4A   0x200C             MOVS     R0,#+12
   \       0x4C   0x9002             STR      R0,[SP, #+8]
   \       0x4E   0xF105 0x002C      ADD      R0,R5,#+44
   \       0x52   0x2120             MOVS     R1,#+32
   \       0x54   0x9100             STR      R1,[SP, #+0]
   \       0x56   0x6BBE             LDR      R6,[R7, #+56]
   \       0x58   0xAB04             ADD      R3,SP,#+16
   \       0x5A   0x4642             MOV      R2,R8
   \       0x5C   0x69B5             LDR      R5,[R6, #+24]
   \       0x5E   0x2130             MOVS     R1,#+48
   \       0x60   0x47A8             BLX      R5
   \       0x62   0x2120             MOVS     R1,#+32
   \       0x64   0xA804             ADD      R0,SP,#+16
   \       0x66   0x.... 0x....      BL       mbedtls_platform_zeroize
   \                     ??ssl_calc_finished_tls_sha256_1: (+1)
   \       0x6A   0xA80C             ADD      R0,SP,#+48
   \       0x6C   0x.... 0x....      BL       psa_hash_abort
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0x.... 0x....      BL       mbedtls_md_error_from_psa
   \       0x76   0xB045             ADD      SP,SP,#+276
   \       0x78   0xE8BD 0x83F0      POP      {R4-R9,PC}
   7767          }
   7768          #endif /* MBEDTLS_MD_CAN_SHA256*/
   7769          
   7770          
   7771          #if defined(MBEDTLS_MD_CAN_SHA384)
   7772          static int ssl_calc_finished_tls_sha384(
   7773              mbedtls_ssl_context *ssl, unsigned char *buf, int from)
   7774          {
   7775              unsigned char padbuf[48];
   7776              return ssl_calc_finished_tls_generic(ssl,
   7777          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   7778                                                   &ssl->handshake->fin_sha384_psa,
   7779          #else
   7780                                                   &ssl->handshake->fin_sha384,
   7781          #endif
   7782                                                   padbuf, sizeof(padbuf),
   7783                                                   buf, from);
   7784          }
   7785          #endif /* MBEDTLS_MD_CAN_SHA384*/
   7786          

   \                                 In section .text, align 2, keep-with-next
   7787          void mbedtls_ssl_handshake_wrapup_free_hs_transform(mbedtls_ssl_context *ssl)
   7788          {
   \                     mbedtls_ssl_handshake_wrapup_free_hs_transform: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   7789              MBEDTLS_SSL_DEBUG_MSG(3, ("=> handshake wrapup: final free"));
   7790          
   7791              /*
   7792               * Free our handshake params
   7793               */
   7794              mbedtls_ssl_handshake_free(ssl);
   \        0x4   0x.... 0x....      BL       mbedtls_ssl_handshake_free
   7795              mbedtls_free(ssl->handshake);
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x.... 0x....      BL       sl_free
   7796              ssl->handshake = NULL;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x63A0             STR      R0,[R4, #+56]
   7797          
   7798              /*
   7799               * Free the previous transform and switch in the current one
   7800               */
   7801              if (ssl->transform) {
   \       0x12   0x6C60             LDR      R0,[R4, #+68]
   \       0x14   0xB120             CBZ.N    R0,??mbedtls_ssl_handshake_wrapup_free_hs_transfor_0
   7802                  mbedtls_ssl_transform_free(ssl->transform);
   \       0x16   0x.... 0x....      BL       mbedtls_ssl_transform_free
   7803                  mbedtls_free(ssl->transform);
   \       0x1A   0x6C60             LDR      R0,[R4, #+68]
   \       0x1C   0x.... 0x....      BL       sl_free
   7804              }
   7805              ssl->transform = ssl->transform_negotiate;
   \                     ??mbedtls_ssl_handshake_wrapup_free_hs_transfor_0: (+1)
   \       0x20   0x6CA1             LDR      R1,[R4, #+72]
   7806              ssl->transform_negotiate = NULL;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x64A0             STR      R0,[R4, #+72]
   \       0x26   0x6461             STR      R1,[R4, #+68]
   7807          
   7808              MBEDTLS_SSL_DEBUG_MSG(3, ("<= handshake wrapup: final free"));
   7809          }
   \       0x28   0xBD10             POP      {R4,PC}
   7810          

   \                                 In section .text, align 2, keep-with-next
   7811          void mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context *ssl)
   7812          {
   \                     mbedtls_ssl_handshake_wrapup: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   7813              int resume = ssl->handshake->resume;
   \        0x4   0x6BB0             LDR      R0,[R6, #+56]
   \        0x6   0x7804             LDRB     R4,[R0, #+0]
   7814          
   7815              MBEDTLS_SSL_DEBUG_MSG(3, ("=> handshake wrapup"));
   7816          
   7817          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7818              if (ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS) {
   7819                  ssl->renego_status =  MBEDTLS_SSL_RENEGOTIATION_DONE;
   7820                  ssl->renego_records_seen = 0;
   7821              }
   7822          #endif
   7823          
   7824              /*
   7825               * Free the previous session and switch in the current one
   7826               */
   7827              if (ssl->session) {
   \        0x8   0x6B30             LDR      R0,[R6, #+48]
   \        0xA   0xB120             CBZ.N    R0,??mbedtls_ssl_handshake_wrapup_0
   7828          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   7829                  /* RFC 7366 3.1: keep the EtM state */
   7830                  ssl->session_negotiate->encrypt_then_mac =
   7831                      ssl->session->encrypt_then_mac;
   7832          #endif
   7833          
   7834                  mbedtls_ssl_session_free(ssl->session);
   \        0xC   0x.... 0x....      BL       mbedtls_ssl_session_free
   7835                  mbedtls_free(ssl->session);
   \       0x10   0x6B30             LDR      R0,[R6, #+48]
   \       0x12   0x.... 0x....      BL       sl_free
   7836              }
   7837              ssl->session = ssl->session_negotiate;
   \                     ??mbedtls_ssl_handshake_wrapup_0: (+1)
   \       0x16   0x6B73             LDR      R3,[R6, #+52]
   7838              ssl->session_negotiate = NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6370             STR      R0,[R6, #+52]
   \       0x1C   0x6333             STR      R3,[R6, #+48]
   7839          
   7840              /*
   7841               * Add cache entry
   7842               */
   7843              if (ssl->conf->f_set_cache != NULL &&
   7844                  ssl->session->id_len != 0 &&
   7845                  resume == 0) {
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6A45             LDR      R5,[R0, #+36]
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xBF1C             ITT      NE
   \       0x26   0x689A             LDRNE    R2,[R3, #+8]
   \       0x28   0x2A00             CMPNE    R2,#+0
   \       0x2A   0xD004             BEQ.N    ??mbedtls_ssl_handshake_wrapup_1
   \       0x2C   0xB91C             CBNZ.N   R4,??mbedtls_ssl_handshake_wrapup_1
   7846                  if (ssl->conf->f_set_cache(ssl->conf->p_cache,
   7847                                             ssl->session->id,
   7848                                             ssl->session->id_len,
   7849                                             ssl->session) != 0) {
   \       0x2E   0x6A80             LDR      R0,[R0, #+40]
   \       0x30   0xF103 0x010C      ADD      R1,R3,#+12
   \       0x34   0x47A8             BLX      R5
   7850                      MBEDTLS_SSL_DEBUG_MSG(1, ("cache did not store session"));
   7851                  }
   7852              }
   7853          
   7854          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7855              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   7856                  ssl->handshake->flight != NULL) {
   7857                  /* Cancel handshake timer */
   7858                  mbedtls_ssl_set_timer(ssl, 0);
   7859          
   7860                  /* Keep last flight around in case we need to resend it:
   7861                   * we need the handshake and transform structures for that */
   7862                  MBEDTLS_SSL_DEBUG_MSG(3, ("skip freeing handshake and transform"));
   7863              } else
   7864          #endif
   7865              mbedtls_ssl_handshake_wrapup_free_hs_transform(ssl);
   \                     ??mbedtls_ssl_handshake_wrapup_1: (+1)
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x.... 0x....      BL       mbedtls_ssl_handshake_wrapup_free_hs_transform
   7866          
   7867              ssl->state = MBEDTLS_SSL_HANDSHAKE_OVER;
   \       0x3C   0x201B             MOVS     R0,#+27
   \       0x3E   0x6070             STR      R0,[R6, #+4]
   7868          
   7869              MBEDTLS_SSL_DEBUG_MSG(3, ("<= handshake wrapup"));
   7870          }
   \       0x40   0xBD70             POP      {R4-R6,PC}
   7871          

   \                                 In section .text, align 2, keep-with-next
   7872          int mbedtls_ssl_write_finished(mbedtls_ssl_context *ssl)
   7873          {
   \                     mbedtls_ssl_write_finished: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   7874              int ret, hash_len;
   7875          
   7876              MBEDTLS_SSL_DEBUG_MSG(2, ("=> write finished"));
   7877          
   7878              mbedtls_ssl_update_out_pointers(ssl, ssl->transform_negotiate);
   \        0x4   0x6CA1             LDR      R1,[R4, #+72]
   \        0x6   0xF104 0x05A8      ADD      R5,R4,#+168
   \        0xA   0x.... 0x....      BL       mbedtls_ssl_update_out_pointers
   7879          
   7880              ret = ssl->handshake->calc_finished(ssl, ssl->out_msg + 4, ssl->conf->endpoint);
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x6BA6             LDR      R6,[R4, #+56]
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x790A             LDRB     R2,[R1, #+4]
   \       0x16   0x6973             LDR      R3,[R6, #+20]
   \       0x18   0x1D01             ADDS     R1,R0,#+4
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x4798             BLX      R3
   7881              if (ret != 0) {
   7882                  MBEDTLS_SSL_DEBUG_RET(1, "calc_finished", ret);
   7883              }
   7884          
   7885              /*
   7886               * RFC 5246 7.4.9 (Page 63) says 12 is the default length and ciphersuites
   7887               * may define some other value. Currently (early 2016), no defined
   7888               * ciphersuite does this (and this is unlikely to change as activity has
   7889               * moved to TLS 1.3 now) so we can keep the hardcoded 12 here.
   7890               */
   7891              hash_len = 12;
   7892          
   7893          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7894              ssl->verify_data_len = hash_len;
   7895              memcpy(ssl->own_verify_data, ssl->out_msg + 4, hash_len);
   7896          #endif
   7897          
   7898              ssl->out_msglen  = 4 + hash_len;
   \       0x1E   0x2010             MOVS     R0,#+16
   7899              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   7900              ssl->out_msg[0]  = MBEDTLS_SSL_HS_FINISHED;
   \       0x20   0x6829             LDR      R1,[R5, #+0]
   \       0x22   0x60A8             STR      R0,[R5, #+8]
   \       0x24   0x2216             MOVS     R2,#+22
   \       0x26   0x606A             STR      R2,[R5, #+4]
   \       0x28   0x2014             MOVS     R0,#+20
   \       0x2A   0x7008             STRB     R0,[R1, #+0]
   7901          
   7902              /*
   7903               * In case of session resuming, invert the client and server
   7904               * ChangeCipherSpec messages order.
   7905               */
   7906              if (ssl->handshake->resume != 0) {
   \       0x2C   0x6BA2             LDR      R2,[R4, #+56]
   \       0x2E   0x7810             LDRB     R0,[R2, #+0]
   \       0x30   0xB128             CBZ.N    R0,??mbedtls_ssl_write_finished_0
   7907          #if defined(MBEDTLS_SSL_CLI_C)
   7908                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x7908             LDRB     R0,[R1, #+4]
   \       0x36   0xB928             CBNZ.N   R0,??mbedtls_ssl_write_finished_1
   7909                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   \       0x38   0x210F             MOVS     R1,#+15
   \       0x3A   0x6061             STR      R1,[R4, #+4]
   \       0x3C   0xE002             B.N      ??mbedtls_ssl_write_finished_1
   7910                  }
   7911          #endif
   7912          #if defined(MBEDTLS_SSL_SRV_C)
   7913                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   7914                      ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
   7915                  }
   7916          #endif
   7917              } else {
   7918                  ssl->state++;
   \                     ??mbedtls_ssl_write_finished_0: (+1)
   \       0x3E   0x6860             LDR      R0,[R4, #+4]
   \       0x40   0x1C40             ADDS     R0,R0,#+1
   \       0x42   0x6060             STR      R0,[R4, #+4]
   7919              }
   7920          
   7921              /*
   7922               * Switch to our negotiated transform and session parameters for outbound
   7923               * data.
   7924               */
   7925              MBEDTLS_SSL_DEBUG_MSG(3, ("switching to new transform spec for outbound data"));
   7926          
   7927          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7928              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   7929                  unsigned char i;
   7930          
   7931                  /* Remember current epoch settings for resending */
   7932                  ssl->handshake->alt_transform_out = ssl->transform_out;
   7933                  memcpy(ssl->handshake->alt_out_ctr, ssl->cur_out_ctr,
   7934                         sizeof(ssl->handshake->alt_out_ctr));
   7935          
   7936                  /* Set sequence_number to zero */
   7937                  memset(&ssl->cur_out_ctr[2], 0, sizeof(ssl->cur_out_ctr) - 2);
   7938          
   7939          
   7940                  /* Increment epoch */
   7941                  for (i = 2; i > 0; i--) {
   7942                      if (++ssl->cur_out_ctr[i - 1] != 0) {
   7943                          break;
   7944                      }
   7945                  }
   7946          
   7947                  /* The loop goes to its end iff the counter is wrapping */
   7948                  if (i == 0) {
   7949                      MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS epoch would wrap"));
   7950                      return MBEDTLS_ERR_SSL_COUNTER_WRAPPING;
   7951                  }
   7952              } else
   7953          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   7954              memset(ssl->cur_out_ctr, 0, sizeof(ssl->cur_out_ctr));
   \                     ??mbedtls_ssl_write_finished_1: (+1)
   \       0x44   0x.... 0x....      BL       ?Subroutine14
   7955          
   7956              ssl->transform_out = ssl->transform_negotiate;
   7957              ssl->session_out = ssl->session_negotiate;
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x48   0x6B60             LDR      R0,[R4, #+52]
   \       0x4A   0x6CA1             LDR      R1,[R4, #+72]
   \       0x4C   0x62E0             STR      R0,[R4, #+44]
   7958          
   7959          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7960              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   7961                  mbedtls_ssl_send_flight_completed(ssl);
   7962              }
   7963          #endif
   7964          
   7965              if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
   7966                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
   7967                  return ret;
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x6421             STR      R1,[R4, #+64]
   \       0x52   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x56   0x.... 0x....      B.W      mbedtls_ssl_write_handshake_msg
   7968              }
   7969          
   7970          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7971              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   7972                  (ret = mbedtls_ssl_flight_transmit(ssl)) != 0) {
   7973                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_flight_transmit", ret);
   7974                  return ret;
   7975              }
   7976          #endif
   7977          
   7978              MBEDTLS_SSL_DEBUG_MSG(2, ("<= write finished"));
   7979          
   7980              return 0;
   7981          }
   7982          
   7983          #define SSL_MAX_HASH_LEN 12
   7984          

   \                                 In section .text, align 2, keep-with-next
   7985          int mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl)
   7986          {
   \                     mbedtls_ssl_parse_finished: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   7987              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   7988              unsigned int hash_len = 12;
   7989              unsigned char buf[SSL_MAX_HASH_LEN];
   7990          
   7991              MBEDTLS_SSL_DEBUG_MSG(2, ("=> parse finished"));
   7992          
   7993              ret = ssl->handshake->calc_finished(ssl, buf, ssl->conf->endpoint ^ 1);
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x6BAC             LDR      R4,[R5, #+56]
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x7902             LDRB     R2,[R0, #+4]
   \        0xC   0x6963             LDR      R3,[R4, #+20]
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x14   0x4798             BLX      R3
   7994              if (ret != 0) {
   7995                  MBEDTLS_SSL_DEBUG_RET(1, "calc_finished", ret);
   7996              }
   7997          
   7998              if ((ret = mbedtls_ssl_read_record(ssl, 1)) != 0) {
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x.... 0x....      BL       mbedtls_ssl_read_record
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0xD12A             BNE.N    ??mbedtls_ssl_parse_finished_0
   7999                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_read_record", ret);
   8000                  goto exit;
   8001              }
   8002          
   8003              if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
   \       0x22   0x6F68             LDR      R0,[R5, #+116]
   \       0x24   0x2816             CMP      R0,#+22
   \       0x26   0xBF02             ITTT     EQ
   \       0x28   0x6EE8             LDREQ    R0,[R5, #+108]
   \       0x2A   0x7801             LDRBEQ   R1,[R0, #+0]
   \       0x2C   0x2914             CMPEQ    R1,#+20
   8004                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad finished message"));
   8005                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8006                                                 MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   8007                  ret = MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   8008                  goto exit;
   8009              }
   8010          
   8011              if (ssl->in_msg[0] != MBEDTLS_SSL_HS_FINISHED) {
   \       0x2E   0xD004             BEQ.N    ??mbedtls_ssl_parse_finished_1
   8012                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8013                                                 MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE);
   \       0x30   0x220A             MOVS     R2,#+10
   \       0x32   0x.... 0x....      BL       ??Subroutine10_0
   8014                  ret = MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x36   0x....             LDR.N    R4,??DataTable37_29
   8015                  goto exit;
   \       0x38   0xE01E             B.N      ??mbedtls_ssl_parse_finished_0
   8016              }
   8017          
   8018              if (ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl) + hash_len) {
   \                     ??mbedtls_ssl_parse_finished_1: (+1)
   \       0x3A   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \       0x3E   0x2910             CMP      R1,#+16
   \       0x40   0xD003             BEQ.N    ??mbedtls_ssl_parse_finished_2
   8019                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad finished message"));
   8020                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8021                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
   \       0x42   0x.... 0x....      BL       ?Subroutine10
   8022                  ret = MBEDTLS_ERR_SSL_DECODE_ERROR;
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x46   0x....             LDR.N    R4,??DataTable36
   8023                  goto exit;
   \       0x48   0xE016             B.N      ??mbedtls_ssl_parse_finished_0
   8024              }
   8025          
   8026              if (mbedtls_ct_memcmp(ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl),
   8027                                    buf, hash_len) != 0) {
   \                     ??mbedtls_ssl_parse_finished_2: (+1)
   \       0x4A   0x220C             MOVS     R2,#+12
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x1D00             ADDS     R0,R0,#+4
   \       0x50   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x54   0xB120             CBZ.N    R0,??mbedtls_ssl_parse_finished_3
   8028                  MBEDTLS_SSL_DEBUG_MSG(1, ("bad finished message"));
   8029                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8030                                                 MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR);
   \       0x56   0x2233             MOVS     R2,#+51
   \       0x58   0x.... 0x....      BL       ??Subroutine10_0
   8031                  ret = MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x5C   0x....             LDR.N    R4,??DataTable36_1
   8032                  goto exit;
   \       0x5E   0xE00B             B.N      ??mbedtls_ssl_parse_finished_0
   8033              }
   8034          
   8035          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   8036              ssl->verify_data_len = hash_len;
   8037              memcpy(ssl->peer_verify_data, buf, hash_len);
   8038          #endif
   8039          
   8040              if (ssl->handshake->resume != 0) {
   \                     ??mbedtls_ssl_parse_finished_3: (+1)
   \       0x60   0x6BA9             LDR      R1,[R5, #+56]
   \       0x62   0x7808             LDRB     R0,[R1, #+0]
   \       0x64   0xB128             CBZ.N    R0,??mbedtls_ssl_parse_finished_4
   8041          #if defined(MBEDTLS_SSL_CLI_C)
   8042                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT) {
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x7908             LDRB     R0,[R1, #+4]
   \       0x6A   0xB928             CBNZ.N   R0,??mbedtls_ssl_parse_finished_0
   8043                      ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
   \       0x6C   0x210A             MOVS     R1,#+10
   \       0x6E   0x6069             STR      R1,[R5, #+4]
   \       0x70   0xE002             B.N      ??mbedtls_ssl_parse_finished_0
   8044                  }
   8045          #endif
   8046          #if defined(MBEDTLS_SSL_SRV_C)
   8047                  if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
   8048                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   8049                  }
   8050          #endif
   8051              } else {
   8052                  ssl->state++;
   \                     ??mbedtls_ssl_parse_finished_4: (+1)
   \       0x72   0x6868             LDR      R0,[R5, #+4]
   \       0x74   0x1C40             ADDS     R0,R0,#+1
   \       0x76   0x6068             STR      R0,[R5, #+4]
   8053              }
   8054          
   8055          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   8056              if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
   8057                  mbedtls_ssl_recv_flight_completed(ssl);
   8058              }
   8059          #endif
   8060          
   8061              MBEDTLS_SSL_DEBUG_MSG(2, ("<= parse finished"));
   8062          
   8063          exit:
   8064              mbedtls_platform_zeroize(buf, hash_len);
   \                     ??mbedtls_ssl_parse_finished_0: (+1)
   \       0x78   0x210C             MOVS     R1,#+12
   \       0x7A   0x4668             MOV      R0,SP
   \       0x7C   0x.... 0x....      BL       mbedtls_platform_zeroize
   8065              return ret;
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0xBD3E             POP      {R1-R5,PC}
   8066          }
   8067          
   8068          #if defined(MBEDTLS_SSL_CONTEXT_SERIALIZATION)
   8069          /*
   8070           * Helper to get TLS 1.2 PRF from ciphersuite
   8071           * (Duplicates bits of logic from ssl_set_handshake_prfs().)
   8072           */
   8073          static tls_prf_fn ssl_tls12prf_from_cs(int ciphersuite_id)
   8074          {
   8075              const mbedtls_ssl_ciphersuite_t * const ciphersuite_info =
   8076                  mbedtls_ssl_ciphersuite_from_id(ciphersuite_id);
   8077          #if defined(MBEDTLS_MD_CAN_SHA384)
   8078              if (ciphersuite_info != NULL && ciphersuite_info->mac == MBEDTLS_MD_SHA384) {
   8079                  return tls_prf_sha384;
   8080              } else
   8081          #endif
   8082          #if defined(MBEDTLS_MD_CAN_SHA256)
   8083              {
   8084                  if (ciphersuite_info != NULL && ciphersuite_info->mac == MBEDTLS_MD_SHA256) {
   8085                      return tls_prf_sha256;
   8086                  }
   8087              }
   8088          #endif
   8089          #if !defined(MBEDTLS_MD_CAN_SHA384) && \
   8090              !defined(MBEDTLS_MD_CAN_SHA256)
   8091              (void) ciphersuite_info;
   8092          #endif
   8093          
   8094              return NULL;
   8095          }
   8096          #endif /* MBEDTLS_SSL_CONTEXT_SERIALIZATION */
   8097          
   8098          static mbedtls_tls_prf_types tls_prf_get_type(mbedtls_ssl_tls_prf_cb *tls_prf)
   8099          {
   8100              ((void) tls_prf);
   8101          #if defined(MBEDTLS_MD_CAN_SHA384)
   8102              if (tls_prf == tls_prf_sha384) {
   8103                  return MBEDTLS_SSL_TLS_PRF_SHA384;
   8104              } else
   8105          #endif
   8106          #if defined(MBEDTLS_MD_CAN_SHA256)
   8107              if (tls_prf == tls_prf_sha256) {
   8108                  return MBEDTLS_SSL_TLS_PRF_SHA256;
   8109              } else
   8110          #endif
   8111              return MBEDTLS_SSL_TLS_PRF_NONE;
   8112          }
   8113          
   8114          /*
   8115           * Populate a transform structure with session keys and all the other
   8116           * necessary information.
   8117           *
   8118           * Parameters:
   8119           * - [in/out]: transform: structure to populate
   8120           *      [in] must be just initialised with mbedtls_ssl_transform_init()
   8121           *      [out] fully populated, ready for use by mbedtls_ssl_{en,de}crypt_buf()
   8122           * - [in] ciphersuite
   8123           * - [in] master
   8124           * - [in] encrypt_then_mac
   8125           * - [in] tls_prf: pointer to PRF to use for key derivation
   8126           * - [in] randbytes: buffer holding ServerHello.random + ClientHello.random
   8127           * - [in] tls_version: TLS version
   8128           * - [in] endpoint: client or server
   8129           * - [in] ssl: used for:
   8130           *        - ssl->conf->{f,p}_export_keys
   8131           *      [in] optionally used for:
   8132           *        - MBEDTLS_DEBUG_C: ssl->conf->{f,p}_dbg
   8133           */
   8134          MBEDTLS_CHECK_RETURN_CRITICAL
   8135          static int ssl_tls12_populate_transform(mbedtls_ssl_transform *transform,
   8136                                                  int ciphersuite,
   8137                                                  const unsigned char master[48],
   8138          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   8139                                                  int encrypt_then_mac,
   8140          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   8141                                                  ssl_tls_prf_t tls_prf,
   8142                                                  const unsigned char randbytes[64],
   8143                                                  mbedtls_ssl_protocol_version tls_version,
   8144                                                  unsigned endpoint,
   8145                                                  const mbedtls_ssl_context *ssl)
   8146          {
   8147              int ret = 0;
   8148              unsigned char keyblk[256];
   8149              unsigned char *key1;
   8150              unsigned char *key2;
   8151              unsigned char *mac_enc;
   8152              unsigned char *mac_dec;
   8153              size_t mac_key_len = 0;
   8154              size_t iv_copy_len;
   8155              size_t keylen;
   8156              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
   8157              mbedtls_ssl_mode_t ssl_mode;
   8158          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   8159              const mbedtls_cipher_info_t *cipher_info;
   8160              const mbedtls_md_info_t *md_info;
   8161          #endif /* !MBEDTLS_USE_PSA_CRYPTO */
   8162          
   8163          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8164              psa_key_type_t key_type;

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   8165              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   8166              psa_algorithm_t alg;
   8167              psa_algorithm_t mac_alg = 0;
   8168              size_t key_bits;
   8169              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   8170          #endif
   8171          
   8172          #if !defined(MBEDTLS_DEBUG_C) && \
   8173              !defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   8174              if (ssl->f_export_keys == NULL) {
   8175                  ssl = NULL; /* make sure we don't use it except for these cases */
   8176                  (void) ssl;
   8177              }
   8178          #endif
   8179          
   8180              /*
   8181               * Some data just needs copying into the structure
   8182               */
   8183          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   8184              transform->encrypt_then_mac = encrypt_then_mac;
   8185          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   8186              transform->tls_version = tls_version;
   8187          
   8188          #if defined(MBEDTLS_SSL_CONTEXT_SERIALIZATION)
   8189              memcpy(transform->randbytes, randbytes, sizeof(transform->randbytes));
   8190          #endif
   8191          
   8192          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   8193              if (tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
   8194                  /* At the moment, we keep TLS <= 1.2 and TLS 1.3 transform
   8195                   * generation separate. This should never happen. */
   8196                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   8197              }
   8198          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   8199          
   8200              /*
   8201               * Get various info structures
   8202               */
   8203              ciphersuite_info = mbedtls_ssl_ciphersuite_from_id(ciphersuite);
   8204              if (ciphersuite_info == NULL) {
   8205                  MBEDTLS_SSL_DEBUG_MSG(1, ("ciphersuite info for %d not found",
   8206                                            ciphersuite));
   8207                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   8208              }
   8209          
   8210              ssl_mode = mbedtls_ssl_get_mode_from_ciphersuite(
   8211          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   8212                  encrypt_then_mac,
   8213          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM */
   8214                  ciphersuite_info);
   8215          
   8216              if (ssl_mode == MBEDTLS_SSL_MODE_AEAD) {
   8217                  transform->taglen =
   8218                      ciphersuite_info->flags & MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
   8219              }
   8220          
   8221          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8222              if ((status = mbedtls_ssl_cipher_to_psa((mbedtls_cipher_type_t) ciphersuite_info->cipher,
   8223                                                      transform->taglen,
   8224                                                      &alg,
   8225                                                      &key_type,
   8226                                                      &key_bits)) != PSA_SUCCESS) {
   8227                  ret = PSA_TO_MBEDTLS_ERR(status);
   8228                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_cipher_to_psa", ret);
   8229                  goto end;
   8230              }
   8231          #else
   8232              cipher_info = mbedtls_cipher_info_from_type((mbedtls_cipher_type_t) ciphersuite_info->cipher);
   8233              if (cipher_info == NULL) {
   8234                  MBEDTLS_SSL_DEBUG_MSG(1, ("cipher info for %u not found",
   8235                                            ciphersuite_info->cipher));
   8236                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   8237              }
   8238          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8239          
   8240          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8241              mac_alg = mbedtls_md_psa_alg_from_type((mbedtls_md_type_t) ciphersuite_info->mac);
   8242              if (mac_alg == 0) {
   8243                  MBEDTLS_SSL_DEBUG_MSG(1, ("mbedtls_md_psa_alg_from_type for %u not found",
   8244                                            (unsigned) ciphersuite_info->mac));
   8245                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   8246              }
   8247          #else
   8248              md_info = mbedtls_md_info_from_type((mbedtls_md_type_t) ciphersuite_info->mac);
   8249              if (md_info == NULL) {
   8250                  MBEDTLS_SSL_DEBUG_MSG(1, ("mbedtls_md info for %u not found",
   8251                                            (unsigned) ciphersuite_info->mac));
   8252                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   8253              }
   8254          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8255          
   8256          #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
   8257              /* Copy own and peer's CID if the use of the CID
   8258               * extension has been negotiated. */
   8259              if (ssl->handshake->cid_in_use == MBEDTLS_SSL_CID_ENABLED) {
   8260                  MBEDTLS_SSL_DEBUG_MSG(3, ("Copy CIDs into SSL transform"));
   8261          
   8262                  transform->in_cid_len = ssl->own_cid_len;
   8263                  memcpy(transform->in_cid, ssl->own_cid, ssl->own_cid_len);
   8264                  MBEDTLS_SSL_DEBUG_BUF(3, "Incoming CID", transform->in_cid,
   8265                                        transform->in_cid_len);
   8266          
   8267                  transform->out_cid_len = ssl->handshake->peer_cid_len;
   8268                  memcpy(transform->out_cid, ssl->handshake->peer_cid,
   8269                         ssl->handshake->peer_cid_len);
   8270                  MBEDTLS_SSL_DEBUG_BUF(3, "Outgoing CID", transform->out_cid,
   8271                                        transform->out_cid_len);
   8272              }
   8273          #endif /* MBEDTLS_SSL_DTLS_CONNECTION_ID */
   8274          
   8275              /*
   8276               * Compute key block using the PRF
   8277               */
   8278              ret = tls_prf(master, 48, "key expansion", randbytes, 64, keyblk, 256);
   8279              if (ret != 0) {
   8280                  MBEDTLS_SSL_DEBUG_RET(1, "prf", ret);
   8281                  return ret;
   8282              }
   8283          
   8284              MBEDTLS_SSL_DEBUG_MSG(3, ("ciphersuite = %s",
   8285                                        mbedtls_ssl_get_ciphersuite_name(ciphersuite)));
   8286              MBEDTLS_SSL_DEBUG_BUF(3, "master secret", master, 48);
   8287              MBEDTLS_SSL_DEBUG_BUF(4, "random bytes", randbytes, 64);
   8288              MBEDTLS_SSL_DEBUG_BUF(4, "key block", keyblk, 256);
   8289          
   8290              /*
   8291               * Determine the appropriate key, IV and MAC length.
   8292               */
   8293          
   8294          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8295              keylen = PSA_BITS_TO_BYTES(key_bits);
   8296          #else
   8297              keylen = mbedtls_cipher_info_get_key_bitlen(cipher_info) / 8;
   8298          #endif
   8299          
   8300          #if defined(MBEDTLS_GCM_C) ||                           \
   8301              defined(MBEDTLS_CCM_C) ||                           \
   8302              defined(MBEDTLS_CHACHAPOLY_C)
   8303              if (ssl_mode == MBEDTLS_SSL_MODE_AEAD) {
   8304                  size_t explicit_ivlen;
   8305          
   8306                  transform->maclen = 0;
   8307                  mac_key_len = 0;
   8308          
   8309                  /* All modes haves 96-bit IVs, but the length of the static parts vary
   8310                   * with mode and version:
   8311                   * - For GCM and CCM in TLS 1.2, there's a static IV of 4 Bytes
   8312                   *   (to be concatenated with a dynamically chosen IV of 8 Bytes)
   8313                   * - For ChaChaPoly in TLS 1.2, and all modes in TLS 1.3, there's
   8314                   *   a static IV of 12 Bytes (to be XOR'ed with the 8 Byte record
   8315                   *   sequence number).
   8316                   */
   8317                  transform->ivlen = 12;
   8318          
   8319                  int is_chachapoly = 0;
   8320          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8321                  is_chachapoly = (key_type == PSA_KEY_TYPE_CHACHA20);
   8322          #else
   8323                  is_chachapoly = (mbedtls_cipher_info_get_mode(cipher_info)
   8324                                   == MBEDTLS_MODE_CHACHAPOLY);
   8325          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8326          
   8327                  if (is_chachapoly) {
   8328                      transform->fixed_ivlen = 12;
   8329                  } else {
   8330                      transform->fixed_ivlen = 4;
   8331                  }
   8332          
   8333                  /* Minimum length of encrypted record */
   8334                  explicit_ivlen = transform->ivlen - transform->fixed_ivlen;
   8335                  transform->minlen = explicit_ivlen + transform->taglen;
   8336              } else
   8337          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C || MBEDTLS_CHACHAPOLY_C */
   8338          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   8339              if (ssl_mode == MBEDTLS_SSL_MODE_STREAM ||
   8340                  ssl_mode == MBEDTLS_SSL_MODE_CBC ||
   8341                  ssl_mode == MBEDTLS_SSL_MODE_CBC_ETM) {
   8342          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8343                  size_t block_size = PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type);
   8344          #else
   8345                  size_t block_size = mbedtls_cipher_info_get_block_size(cipher_info);
   8346          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8347          
   8348          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8349                  /* Get MAC length */
   8350                  mac_key_len = PSA_HASH_LENGTH(mac_alg);
   8351          #else
   8352                  /* Initialize HMAC contexts */
   8353                  if ((ret = mbedtls_md_setup(&transform->md_ctx_enc, md_info, 1)) != 0 ||
   8354                      (ret = mbedtls_md_setup(&transform->md_ctx_dec, md_info, 1)) != 0) {
   8355                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_setup", ret);
   8356                      goto end;
   8357                  }
   8358          
   8359                  /* Get MAC length */
   8360                  mac_key_len = mbedtls_md_get_size(md_info);
   8361          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8362                  transform->maclen = mac_key_len;
   8363          
   8364                  /* IV length */
   8365          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8366                  transform->ivlen = PSA_CIPHER_IV_LENGTH(key_type, alg);
   8367          #else
   8368                  transform->ivlen = mbedtls_cipher_info_get_iv_size(cipher_info);
   8369          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8370          
   8371                  /* Minimum length */
   8372                  if (ssl_mode == MBEDTLS_SSL_MODE_STREAM) {
   8373                      transform->minlen = transform->maclen;
   8374                  } else {
   8375                      /*
   8376                       * GenericBlockCipher:
   8377                       * 1. if EtM is in use: one block plus MAC
   8378                       *    otherwise: * first multiple of blocklen greater than maclen
   8379                       * 2. IV
   8380                       */
   8381          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   8382                      if (ssl_mode == MBEDTLS_SSL_MODE_CBC_ETM) {
   8383                          transform->minlen = transform->maclen
   8384                                              + block_size;
   8385                      } else
   8386          #endif
   8387                      {
   8388                          transform->minlen = transform->maclen
   8389                                              + block_size
   8390                                              - transform->maclen % block_size;
   8391                      }
   8392          
   8393                      if (tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
   8394                          transform->minlen += transform->ivlen;
   8395                      } else {
   8396                          MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   8397                          ret = MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   8398                          goto end;
   8399                      }
   8400                  }
   8401              } else
   8402          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
   8403              {
   8404                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   8405                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   8406              }
   8407          
   8408              MBEDTLS_SSL_DEBUG_MSG(3, ("keylen: %u, minlen: %u, ivlen: %u, maclen: %u",
   8409                                        (unsigned) keylen,
   8410                                        (unsigned) transform->minlen,
   8411                                        (unsigned) transform->ivlen,
   8412                                        (unsigned) transform->maclen));
   8413          
   8414              /*
   8415               * Finally setup the cipher contexts, IVs and MAC secrets.
   8416               */
   8417          #if defined(MBEDTLS_SSL_CLI_C)
   8418              if (endpoint == MBEDTLS_SSL_IS_CLIENT) {
   8419                  key1 = keyblk + mac_key_len * 2;
   8420                  key2 = keyblk + mac_key_len * 2 + keylen;
   8421          
   8422                  mac_enc = keyblk;
   8423                  mac_dec = keyblk + mac_key_len;
   8424          
   8425                  iv_copy_len = (transform->fixed_ivlen) ?
   8426                                transform->fixed_ivlen : transform->ivlen;
   8427                  memcpy(transform->iv_enc, key2 + keylen,  iv_copy_len);
   8428                  memcpy(transform->iv_dec, key2 + keylen + iv_copy_len,
   8429                         iv_copy_len);
   8430              } else
   8431          #endif /* MBEDTLS_SSL_CLI_C */
   8432          #if defined(MBEDTLS_SSL_SRV_C)
   8433              if (endpoint == MBEDTLS_SSL_IS_SERVER) {
   8434                  key1 = keyblk + mac_key_len * 2 + keylen;
   8435                  key2 = keyblk + mac_key_len * 2;
   8436          
   8437                  mac_enc = keyblk + mac_key_len;
   8438                  mac_dec = keyblk;
   8439          
   8440                  iv_copy_len = (transform->fixed_ivlen) ?
   8441                                transform->fixed_ivlen : transform->ivlen;
   8442                  memcpy(transform->iv_dec, key1 + keylen,  iv_copy_len);
   8443                  memcpy(transform->iv_enc, key1 + keylen + iv_copy_len,
   8444                         iv_copy_len);
   8445              } else
   8446          #endif /* MBEDTLS_SSL_SRV_C */
   8447              {
   8448                  MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
   8449                  ret = MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   8450                  goto end;
   8451              }
   8452          
   8453              if (ssl != NULL && ssl->f_export_keys != NULL) {
   8454                  ssl->f_export_keys(ssl->p_export_keys,
   8455                                     MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET,
   8456                                     master, 48,
   8457                                     randbytes + 32,
   8458                                     randbytes,
   8459                                     tls_prf_get_type(tls_prf));
   8460              }
   8461          
   8462          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8463              transform->psa_alg = alg;
   8464          
   8465              if (alg != MBEDTLS_SSL_NULL_CIPHER) {
   8466                  psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
   8467                  psa_set_key_algorithm(&attributes, alg);
   8468                  psa_set_key_type(&attributes, key_type);
   8469          
   8470                  if ((status = psa_import_key(&attributes,
   8471                                               key1,
   8472                                               PSA_BITS_TO_BYTES(key_bits),
   8473                                               &transform->psa_key_enc)) != PSA_SUCCESS) {
   8474                      MBEDTLS_SSL_DEBUG_RET(3, "psa_import_key", (int) status);
   8475                      ret = PSA_TO_MBEDTLS_ERR(status);
   8476                      MBEDTLS_SSL_DEBUG_RET(1, "psa_import_key", ret);
   8477                      goto end;
   8478                  }
   8479          
   8480                  psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
   8481          
   8482                  if ((status = psa_import_key(&attributes,
   8483                                               key2,
   8484                                               PSA_BITS_TO_BYTES(key_bits),
   8485                                               &transform->psa_key_dec)) != PSA_SUCCESS) {
   8486                      ret = PSA_TO_MBEDTLS_ERR(status);
   8487                      MBEDTLS_SSL_DEBUG_RET(1, "psa_import_key", ret);
   8488                      goto end;
   8489                  }
   8490              }
   8491          #else
   8492              if ((ret = mbedtls_cipher_setup(&transform->cipher_ctx_enc,
   8493                                              cipher_info)) != 0) {
   8494                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_setup", ret);
   8495                  goto end;
   8496              }
   8497          
   8498              if ((ret = mbedtls_cipher_setup(&transform->cipher_ctx_dec,
   8499                                              cipher_info)) != 0) {
   8500                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_setup", ret);
   8501                  goto end;
   8502              }
   8503          
   8504              if ((ret = mbedtls_cipher_setkey(&transform->cipher_ctx_enc, key1,
   8505                                               (int) mbedtls_cipher_info_get_key_bitlen(cipher_info),
   8506                                               MBEDTLS_ENCRYPT)) != 0) {
   8507                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_setkey", ret);
   8508                  goto end;
   8509              }
   8510          
   8511              if ((ret = mbedtls_cipher_setkey(&transform->cipher_ctx_dec, key2,
   8512                                               (int) mbedtls_cipher_info_get_key_bitlen(cipher_info),
   8513                                               MBEDTLS_DECRYPT)) != 0) {
   8514                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_setkey", ret);
   8515                  goto end;
   8516              }
   8517          
   8518          #if defined(MBEDTLS_CIPHER_MODE_CBC)
   8519              if (mbedtls_cipher_info_get_mode(cipher_info) == MBEDTLS_MODE_CBC) {
   8520                  if ((ret = mbedtls_cipher_set_padding_mode(&transform->cipher_ctx_enc,
   8521                                                             MBEDTLS_PADDING_NONE)) != 0) {
   8522                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_set_padding_mode", ret);
   8523                      goto end;
   8524                  }
   8525          
   8526                  if ((ret = mbedtls_cipher_set_padding_mode(&transform->cipher_ctx_dec,
   8527                                                             MBEDTLS_PADDING_NONE)) != 0) {
   8528                      MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_cipher_set_padding_mode", ret);
   8529                      goto end;
   8530                  }
   8531              }
   8532          #endif /* MBEDTLS_CIPHER_MODE_CBC */
   8533          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8534          
   8535          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
   8536              /* For HMAC-based ciphersuites, initialize the HMAC transforms.
   8537                 For AEAD-based ciphersuites, there is nothing to do here. */
   8538              if (mac_key_len != 0) {
   8539          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8540                  transform->psa_mac_alg = PSA_ALG_HMAC(mac_alg);
   8541          
   8542                  psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_MESSAGE);
   8543                  psa_set_key_algorithm(&attributes, PSA_ALG_HMAC(mac_alg));
   8544                  psa_set_key_type(&attributes, PSA_KEY_TYPE_HMAC);
   8545          
   8546                  if ((status = psa_import_key(&attributes,
   8547                                               mac_enc, mac_key_len,
   8548                                               &transform->psa_mac_enc)) != PSA_SUCCESS) {
   8549                      ret = PSA_TO_MBEDTLS_ERR(status);
   8550                      MBEDTLS_SSL_DEBUG_RET(1, "psa_import_mac_key", ret);
   8551                      goto end;
   8552                  }
   8553          
   8554                  if ((transform->psa_alg == MBEDTLS_SSL_NULL_CIPHER) ||
   8555                      ((transform->psa_alg == PSA_ALG_CBC_NO_PADDING)
   8556          #if defined(MBEDTLS_SSL_SOME_SUITES_USE_CBC_ETM)
   8557                       && (transform->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED)
   8558          #endif
   8559                      )) {
   8560                      /* mbedtls_ct_hmac() requires the key to be exportable */
   8561                      psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_EXPORT |
   8562                                              PSA_KEY_USAGE_VERIFY_HASH);
   8563                  } else {
   8564                      psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_VERIFY_HASH);
   8565                  }
   8566          
   8567                  if ((status = psa_import_key(&attributes,
   8568                                               mac_dec, mac_key_len,
   8569                                               &transform->psa_mac_dec)) != PSA_SUCCESS) {
   8570                      ret = PSA_TO_MBEDTLS_ERR(status);
   8571                      MBEDTLS_SSL_DEBUG_RET(1, "psa_import_mac_key", ret);
   8572                      goto end;
   8573                  }
   8574          #else
   8575                  ret = mbedtls_md_hmac_starts(&transform->md_ctx_enc, mac_enc, mac_key_len);
   8576                  if (ret != 0) {
   8577                      goto end;
   8578                  }
   8579                  ret = mbedtls_md_hmac_starts(&transform->md_ctx_dec, mac_dec, mac_key_len);
   8580                  if (ret != 0) {
   8581                      goto end;
   8582                  }
   8583          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8584              }
   8585          #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
   8586          
   8587              ((void) mac_dec);
   8588              ((void) mac_enc);
   8589          
   8590          end:
   8591              mbedtls_platform_zeroize(keyblk, sizeof(keyblk));
   8592              return ret;
   8593          }
   8594          
   8595          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED) && \
   8596              defined(MBEDTLS_USE_PSA_CRYPTO)
   8597          int mbedtls_psa_ecjpake_read_round(
   8598              psa_pake_operation_t *pake_ctx,
   8599              const unsigned char *buf,
   8600              size_t len, mbedtls_ecjpake_rounds_t round)
   8601          {
   8602              psa_status_t status;
   8603              size_t input_offset = 0;
   8604              /*
   8605               * At round one repeat the KEY_SHARE, ZK_PUBLIC & ZF_PROOF twice
   8606               * At round two perform a single cycle
   8607               */
   8608              unsigned int remaining_steps = (round == MBEDTLS_ECJPAKE_ROUND_ONE) ? 2 : 1;
   8609          
   8610              for (; remaining_steps > 0; remaining_steps--) {
   8611                  for (psa_pake_step_t step = PSA_PAKE_STEP_KEY_SHARE;
   8612                       step <= PSA_PAKE_STEP_ZK_PROOF;
   8613                       ++step) {
   8614                      /* Length is stored at the first byte */
   8615                      size_t length = buf[input_offset];
   8616                      input_offset += 1;
   8617          
   8618                      if (input_offset + length > len) {
   8619                          return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   8620                      }
   8621          
   8622                      status = psa_pake_input(pake_ctx, step,
   8623                                              buf + input_offset, length);
   8624                      if (status != PSA_SUCCESS) {
   8625                          return PSA_TO_MBEDTLS_ERR(status);
   8626                      }
   8627          
   8628                      input_offset += length;
   8629                  }
   8630              }
   8631          
   8632              if (input_offset != len) {
   8633                  return MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
   8634              }
   8635          
   8636              return 0;
   8637          }
   8638          
   8639          int mbedtls_psa_ecjpake_write_round(
   8640              psa_pake_operation_t *pake_ctx,
   8641              unsigned char *buf,
   8642              size_t len, size_t *olen,
   8643              mbedtls_ecjpake_rounds_t round)
   8644          {
   8645              psa_status_t status;
   8646              size_t output_offset = 0;
   8647              size_t output_len;
   8648              /*
   8649               * At round one repeat the KEY_SHARE, ZK_PUBLIC & ZF_PROOF twice
   8650               * At round two perform a single cycle
   8651               */
   8652              unsigned int remaining_steps = (round == MBEDTLS_ECJPAKE_ROUND_ONE) ? 2 : 1;
   8653          
   8654              for (; remaining_steps > 0; remaining_steps--) {
   8655                  for (psa_pake_step_t step = PSA_PAKE_STEP_KEY_SHARE;
   8656                       step <= PSA_PAKE_STEP_ZK_PROOF;
   8657                       ++step) {
   8658                      /*
   8659                       * For each step, prepend 1 byte with the length of the data as
   8660                       * given by psa_pake_output().
   8661                       */
   8662                      status = psa_pake_output(pake_ctx, step,
   8663                                               buf + output_offset + 1,
   8664                                               len - output_offset - 1,
   8665                                               &output_len);
   8666                      if (status != PSA_SUCCESS) {
   8667                          return PSA_TO_MBEDTLS_ERR(status);
   8668                      }
   8669          
   8670                      *(buf + output_offset) = (uint8_t) output_len;
   8671          
   8672                      output_offset += output_len + 1;
   8673                  }
   8674              }
   8675          
   8676              *olen = output_offset;
   8677          
   8678              return 0;
   8679          }
   8680          #endif //MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED && MBEDTLS_USE_PSA_CRYPTO
   8681          
   8682          #if defined(MBEDTLS_USE_PSA_CRYPTO)

   \                                 In section .text, align 2, keep-with-next
   8683          int mbedtls_ssl_get_key_exchange_md_tls1_2(mbedtls_ssl_context *ssl,
   8684                                                     unsigned char *hash, size_t *hashlen,
   8685                                                     unsigned char *data, size_t data_len,
   8686                                                     mbedtls_md_type_t md_alg)
   8687          {
   \                     mbedtls_ssl_get_key_exchange_md_tls1_2: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB0B8             SUB      SP,SP,#+224
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0x9C3F             LDR      R4,[SP, #+252]
   8688              psa_status_t status;
   8689              psa_hash_operation_t hash_operation = PSA_HASH_OPERATION_INIT;
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   8690              psa_algorithm_t hash_alg = mbedtls_md_psa_alg_from_type(md_alg);
   8691          
   8692              MBEDTLS_SSL_DEBUG_MSG(3, ("Perform PSA-based computation of digest of ServerKeyExchange"));
   8693          
   8694              if ((status = psa_hash_setup(&hash_operation,
   8695                                           hash_alg)) != PSA_SUCCESS) {
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x14   0xF044 0x7100      ORR      R1,R4,#0x2000000
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x.... 0x....      BL       psa_hash_setup
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0xD112             BNE.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_0
   8696                  MBEDTLS_SSL_DEBUG_RET(1, "psa_hash_setup", status);
   8697                  goto exit;
   8698              }
   8699          
   8700              if ((status = psa_hash_update(&hash_operation, ssl->handshake->randbytes,
   8701                                            64)) != PSA_SUCCESS) {
   \       0x22   0x6BB8             LDR      R0,[R7, #+56]
   \       0x24   0x2240             MOVS     R2,#+64
   \       0x26   0xF500 0x71FC      ADD      R1,R0,#+504
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x.... 0x....      BL       psa_hash_update
   \       0x30   0x0004             MOVS     R4,R0
   \       0x32   0xD109             BNE.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_0
   \       0x34   0x9A3E             LDR      R2,[SP, #+248]
   8702                  MBEDTLS_SSL_DEBUG_RET(1, "psa_hash_update", status);
   8703                  goto exit;
   8704              }
   8705          
   8706              if ((status = psa_hash_update(&hash_operation,
   8707                                            data, data_len)) != PSA_SUCCESS) {
   \       0x36   0x4641             MOV      R1,R8
   \       0x38   0x4668             MOV      R0,SP
   \       0x3A   0x.... 0x....      BL       psa_hash_update
   \       0x3E   0x0004             MOVS     R4,R0
   \       0x40   0xD102             BNE.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_0
   8708                  MBEDTLS_SSL_DEBUG_RET(1, "psa_hash_update", status);
   8709                  goto exit;
   8710              }
   8711          
   8712              if ((status = psa_hash_finish(&hash_operation, hash, PSA_HASH_MAX_SIZE,
   8713                                            hashlen)) != PSA_SUCCESS) {
   \       0x42   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x46   0x4604             MOV      R4,R0
   8714                  MBEDTLS_SSL_DEBUG_RET(1, "psa_hash_finish", status);
   8715                  goto exit;
   8716              }
   8717          
   8718          exit:
   8719              if (status != PSA_SUCCESS) {
   \                     ??mbedtls_ssl_get_key_exchange_md_tls1_2_0: (+1)
   \       0x48   0xB1AC             CBZ.N    R4,??mbedtls_ssl_get_key_exchange_md_tls1_2_1
   8720                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8721                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   \       0x4A   0x2250             MOVS     R2,#+80
   \       0x4C   0x2102             MOVS     R1,#+2
   \       0x4E   0x4638             MOV      R0,R7
   \       0x50   0x.... 0x....      BL       mbedtls_ssl_send_alert_message
   8722                  switch (status) {
   \       0x54   0xF06F 0x008C      MVN      R0,#+140
   \       0x58   0x1A24             SUBS     R4,R4,R0
   \       0x5A   0xD00A             BEQ.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_2
   \       0x5C   0x1EE4             SUBS     R4,R4,#+3
   \       0x5E   0x2C01             CMP      R4,#+1
   \       0x60   0xD905             BLS.N    ??mbedtls_ssl_get_key_exchange_md_tls1_2_3
   \       0x62   0x1F24             SUBS     R4,R4,#+4
   \       0x64   0xBF14             ITE      NE
   \       0x66   0xF06F 0x006F      MVNNE    R0,#+111
   \       0x6A   0x....             LDREQ.N  R0,??DataTable37_32
   8723                      case PSA_ERROR_NOT_SUPPORTED:
   8724                          return MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE;
   8725                      case PSA_ERROR_BAD_STATE: /* Intentional fallthrough */
   8726                      case PSA_ERROR_BUFFER_TOO_SMALL:
   8727                          return MBEDTLS_ERR_MD_BAD_INPUT_DATA;
   8728                      case PSA_ERROR_INSUFFICIENT_MEMORY:
   8729                          return MBEDTLS_ERR_MD_ALLOC_FAILED;
   8730                      default:
   8731                          return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x6C   0xE004             B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_4
   \                     ??mbedtls_ssl_get_key_exchange_md_tls1_2_3: (+1)
   \       0x6E   0x....             LDR.N    R0,??DataTable37_33
   \       0x70   0xE002             B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_4
   \                     ??mbedtls_ssl_get_key_exchange_md_tls1_2_2: (+1)
   \       0x72   0x....             LDR.N    R0,??DataTable37_34
   \       0x74   0xE000             B.N      ??mbedtls_ssl_get_key_exchange_md_tls1_2_4
   8732                  }
   8733              }
   8734              return 0;
   \                     ??mbedtls_ssl_get_key_exchange_md_tls1_2_1: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_get_key_exchange_md_tls1_2_4: (+1)
   \       0x78   0xB038             ADD      SP,SP,#+224
   \       0x7A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   8735          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
   \        0x8                      DS8 216
   8736          
   8737          #else
   8738          
   8739          int mbedtls_ssl_get_key_exchange_md_tls1_2(mbedtls_ssl_context *ssl,
   8740                                                     unsigned char *hash, size_t *hashlen,
   8741                                                     unsigned char *data, size_t data_len,
   8742                                                     mbedtls_md_type_t md_alg)
   8743          {
   8744              int ret = 0;
   8745              mbedtls_md_context_t ctx;
   8746              const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type(md_alg);
   8747              *hashlen = mbedtls_md_get_size(md_info);
   8748          
   8749              MBEDTLS_SSL_DEBUG_MSG(3, ("Perform mbedtls-based computation of digest of ServerKeyExchange"));
   8750          
   8751              mbedtls_md_init(&ctx);
   8752          
   8753              /*
   8754               * digitally-signed struct {
   8755               *     opaque client_random[32];
   8756               *     opaque server_random[32];
   8757               *     ServerDHParams params;
   8758               * };
   8759               */
   8760              if ((ret = mbedtls_md_setup(&ctx, md_info, 0)) != 0) {
   8761                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_setup", ret);
   8762                  goto exit;
   8763              }
   8764              if ((ret = mbedtls_md_starts(&ctx)) != 0) {
   8765                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_starts", ret);
   8766                  goto exit;
   8767              }
   8768              if ((ret = mbedtls_md_update(&ctx, ssl->handshake->randbytes, 64)) != 0) {
   8769                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_update", ret);
   8770                  goto exit;
   8771              }
   8772              if ((ret = mbedtls_md_update(&ctx, data, data_len)) != 0) {
   8773                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_update", ret);
   8774                  goto exit;
   8775              }
   8776              if ((ret = mbedtls_md_finish(&ctx, hash)) != 0) {
   8777                  MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_md_finish", ret);
   8778                  goto exit;
   8779              }
   8780          
   8781          exit:
   8782              mbedtls_md_free(&ctx);
   8783          
   8784              if (ret != 0) {
   8785                  mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8786                                                 MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR);
   8787              }
   8788          
   8789              return ret;
   8790          }
   8791          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8792          
   8793          #if defined(MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED)
   8794          
   8795          /* Find the preferred hash for a given signature algorithm. */

   \                                 In section .text, align 2, keep-with-next
   8796          unsigned int mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg(
   8797              mbedtls_ssl_context *ssl,
   8798              unsigned int sig_alg)
   8799          {
   \                     mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   8800              unsigned int i;
   8801              uint16_t *received_sig_algs = ssl->handshake->received_sig_algs;
   \        0x6   0x6BA8             LDR      R0,[R5, #+56]
   \        0x8   0x000C             MOVS     R4,R1
   \        0xA   0xF100 0x081C      ADD      R8,R0,#+28
   8802          
   8803              if (sig_alg == MBEDTLS_SSL_SIG_ANON) {
   \        0xE   0xD033             BEQ.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__0
   8804                  return MBEDTLS_SSL_HASH_NONE;
   8805              }
   8806          
   8807              for (i = 0; received_sig_algs[i] != MBEDTLS_TLS_SIG_NONE; i++) {
   \       0x10   0x2700             MOVS     R7,#+0
   \       0x12   0xE014             B.N      ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__1
   8808                  unsigned int hash_alg_received =
   8809                      MBEDTLS_SSL_TLS12_HASH_ALG_FROM_SIG_AND_HASH_ALG(
   8810                          received_sig_algs[i]);
   8811                  unsigned int sig_alg_received =
   8812                      MBEDTLS_SSL_TLS12_SIG_ALG_FROM_SIG_AND_HASH_ALG(
   8813                          received_sig_algs[i]);
   8814          
   8815                  mbedtls_md_type_t md_alg =
   8816                      mbedtls_ssl_md_alg_from_hash((unsigned char) hash_alg_received);
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__2: (+1)
   \       0x14   0x2108             MOVS     R1,#+8
   \       0x16   0xE000             B.N      ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__3
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__4: (+1)
   \       0x18   0x2105             MOVS     R1,#+5
   8817                  if (md_alg == MBEDTLS_MD_NONE) {
   8818                      continue;
   8819                  }
   8820          
   8821                  if (sig_alg == sig_alg_received) {
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__3: (+1)
   \       0x1A   0x4294             CMP      R4,R2
   \       0x1C   0xD10E             BNE.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__5
   8822          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   8823                      if (ssl->handshake->key_cert && ssl->handshake->key_cert->key) {
   \       0x1E   0x6BA8             LDR      R0,[R5, #+56]
   \       0x20   0xF8D0 0x00A4      LDR      R0,[R0, #+164]
   \       0x24   0xB330             CBZ.N    R0,??mbedtls_ssl_tls12_get_preferred_hash_for_sig__6
   \       0x26   0x6840             LDR      R0,[R0, #+4]
   \       0x28   0xB320             CBZ.N    R0,??mbedtls_ssl_tls12_get_preferred_hash_for_sig__6
   8824                          psa_algorithm_t psa_hash_alg =
   8825                              mbedtls_md_psa_alg_from_type(md_alg);
   8826          
   8827                          if (sig_alg_received == MBEDTLS_SSL_SIG_ECDSA &&
   8828                              !mbedtls_pk_can_do_ext(ssl->handshake->key_cert->key,
   8829                                                     PSA_ALG_ECDSA(psa_hash_alg),
   8830                                                     PSA_KEY_USAGE_SIGN_HASH)) {
   \       0x2A   0x2A03             CMP      R2,#+3
   \       0x2C   0xD116             BNE.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__7
   \       0x2E   0xF44F 0x5280      MOV      R2,#+4096
   \       0x32   0xF041 0x2106      ORR      R1,R1,#0x6000600
   \       0x36   0x.... 0x....      BL       mbedtls_pk_can_do_ext
   \       0x3A   0xB9D8             CBNZ.N   R0,??mbedtls_ssl_tls12_get_preferred_hash_for_sig__6
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__5: (+1)
   \       0x3C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__1: (+1)
   \       0x3E   0xF838 0x2017      LDRH     R2,[R8, R7, LSL #+1]
   \       0x42   0xB1CA             CBZ.N    R2,??mbedtls_ssl_tls12_get_preferred_hash_for_sig__0
   \       0x44   0x0A16             LSRS     R6,R2,#+8
   \       0x46   0xF002 0x02FF      AND      R2,R2,#0xFF
   \       0x4A   0x2E02             CMP      R6,#+2
   \       0x4C   0xD0E4             BEQ.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__4
   \       0x4E   0xD3F5             BCC.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__5
   \       0x50   0x2E04             CMP      R6,#+4
   \       0x52   0xD001             BEQ.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__8
   \       0x54   0xD3DE             BCC.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__2
   \       0x56   0xE7F1             B.N      ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__5
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__8: (+1)
   \       0x58   0x2109             MOVS     R1,#+9
   \       0x5A   0xE7DE             B.N      ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__3
   8831                              continue;
   8832                          }
   8833          
   8834                          if (sig_alg_received == MBEDTLS_SSL_SIG_RSA &&
   8835                              !mbedtls_pk_can_do_ext(ssl->handshake->key_cert->key,
   8836                                                     PSA_ALG_RSA_PKCS1V15_SIGN(
   8837                                                         psa_hash_alg),
   8838                                                     PSA_KEY_USAGE_SIGN_HASH)) {
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__7: (+1)
   \       0x5C   0x2A01             CMP      R2,#+1
   \       0x5E   0xD109             BNE.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__6
   \       0x60   0xF041 0x61C0      ORR      R1,R1,#0x6000000
   \       0x64   0xF44F 0x5280      MOV      R2,#+4096
   \       0x68   0xF441 0x7100      ORR      R1,R1,#0x200
   \       0x6C   0x.... 0x....      BL       mbedtls_pk_can_do_ext
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD0E3             BEQ.N    ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__5
   8839                              continue;
   8840                          }
   8841                      }
   8842          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   8843          
   8844                      return hash_alg_received;
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__6: (+1)
   \       0x74   0x4630             MOV      R0,R6
   \       0x76   0xE000             B.N      ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__9
   8845                  }
   8846              }
   8847          
   8848              return MBEDTLS_SSL_HASH_NONE;
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__0: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_tls12_get_preferred_hash_for_sig__9: (+1)
   \       0x7A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   8849          }
   8850          
   8851          #endif /* MBEDTLS_KEY_EXCHANGE_WITH_CERT_ENABLED */
   8852          
   8853          /* Serialization of TLS 1.2 sessions:
   8854           *
   8855           * struct {
   8856           *    uint64 start_time;
   8857           *    uint8 ciphersuite[2];           // defined by the standard
   8858           *    uint8 session_id_len;           // at most 32
   8859           *    opaque session_id[32];
   8860           *    opaque master[48];              // fixed length in the standard
   8861           *    uint32 verify_result;
   8862           *    opaque peer_cert<0..2^24-1>;    // length 0 means no peer cert
   8863           *    opaque ticket<0..2^24-1>;       // length 0 means no ticket
   8864           *    uint32 ticket_lifetime;
   8865           *    uint8 mfl_code;                 // up to 255 according to standard
   8866           *    uint8 encrypt_then_mac;         // 0 or 1
   8867           * } serialized_session_tls12;
   8868           *
   8869           */
   8870          static size_t ssl_tls12_session_save(const mbedtls_ssl_session *session,
   8871                                               unsigned char *buf,
   8872                                               size_t buf_len)
   8873          {
   8874              unsigned char *p = buf;
   8875              size_t used = 0;
   8876          
   8877          #if defined(MBEDTLS_HAVE_TIME)
   8878              uint64_t start;
   8879          #endif
   8880          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   8881          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   8882              size_t cert_len;
   8883          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   8884          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   8885          
   8886              /*
   8887               * Time
   8888               */
   8889          #if defined(MBEDTLS_HAVE_TIME)
   8890              used += 8;
   8891          
   8892              if (used <= buf_len) {
   8893                  start = (uint64_t) session->start;
   8894          
   8895                  MBEDTLS_PUT_UINT64_BE(start, p, 0);
   8896                  p += 8;
   8897              }
   8898          #endif /* MBEDTLS_HAVE_TIME */
   8899          
   8900              /*
   8901               * Basic mandatory fields
   8902               */
   8903              used += 2   /* ciphersuite */
   8904                      + 1 /* id_len */
   8905                      + sizeof(session->id)
   8906                      + sizeof(session->master)
   8907                      + 4; /* verify_result */
   8908          
   8909              if (used <= buf_len) {
   8910                  MBEDTLS_PUT_UINT16_BE(session->ciphersuite, p, 0);
   8911                  p += 2;
   8912          
   8913                  *p++ = MBEDTLS_BYTE_0(session->id_len);
   8914                  memcpy(p, session->id, 32);
   8915                  p += 32;
   8916          
   8917                  memcpy(p, session->master, 48);
   8918                  p += 48;
   8919          
   8920                  MBEDTLS_PUT_UINT32_BE(session->verify_result, p, 0);
   8921                  p += 4;
   8922              }
   8923          
   8924              /*
   8925               * Peer's end-entity certificate
   8926               */
   8927          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   8928          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   8929              if (session->peer_cert == NULL) {
   8930                  cert_len = 0;
   8931              } else {
   8932                  cert_len = session->peer_cert->raw.len;
   8933              }
   8934          
   8935              used += 3 + cert_len;
   8936          
   8937              if (used <= buf_len) {
   8938                  *p++ = MBEDTLS_BYTE_2(cert_len);
   8939                  *p++ = MBEDTLS_BYTE_1(cert_len);
   8940                  *p++ = MBEDTLS_BYTE_0(cert_len);
   8941          
   8942                  if (session->peer_cert != NULL) {
   8943                      memcpy(p, session->peer_cert->raw.p, cert_len);
   8944                      p += cert_len;
   8945                  }
   8946              }
   8947          #else /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   8948              if (session->peer_cert_digest != NULL) {
   8949                  used += 1 /* type */ + 1 /* length */ + session->peer_cert_digest_len;
   8950                  if (used <= buf_len) {
   8951                      *p++ = (unsigned char) session->peer_cert_digest_type;
   8952                      *p++ = (unsigned char) session->peer_cert_digest_len;
   8953                      memcpy(p, session->peer_cert_digest,
   8954                             session->peer_cert_digest_len);
   8955                      p += session->peer_cert_digest_len;
   8956                  }
   8957              } else {
   8958                  used += 2;
   8959                  if (used <= buf_len) {
   8960                      *p++ = (unsigned char) MBEDTLS_MD_NONE;
   8961                      *p++ = 0;
   8962                  }
   8963              }
   8964          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   8965          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   8966          
   8967              /*
   8968               * Session ticket if any, plus associated data
   8969               */
   8970          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   8971              used += 3 + session->ticket_len + 4; /* len + ticket + lifetime */
   8972          
   8973              if (used <= buf_len) {
   8974                  *p++ = MBEDTLS_BYTE_2(session->ticket_len);
   8975                  *p++ = MBEDTLS_BYTE_1(session->ticket_len);
   8976                  *p++ = MBEDTLS_BYTE_0(session->ticket_len);
   8977          
   8978                  if (session->ticket != NULL) {
   8979                      memcpy(p, session->ticket, session->ticket_len);
   8980                      p += session->ticket_len;
   8981                  }
   8982          
   8983                  MBEDTLS_PUT_UINT32_BE(session->ticket_lifetime, p, 0);
   8984                  p += 4;
   8985              }
   8986          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
   8987          
   8988              /*
   8989               * Misc extension-related info
   8990               */
   8991          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   8992              used += 1;
   8993          
   8994              if (used <= buf_len) {
   8995                  *p++ = session->mfl_code;
   8996              }
   8997          #endif
   8998          
   8999          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   9000              used += 1;
   9001          
   9002              if (used <= buf_len) {
   9003                  *p++ = MBEDTLS_BYTE_0(session->encrypt_then_mac);
   9004              }
   9005          #endif
   9006          
   9007              return used;
   9008          }
   9009          
   9010          MBEDTLS_CHECK_RETURN_CRITICAL
   9011          static int ssl_tls12_session_load(mbedtls_ssl_session *session,
   9012                                            const unsigned char *buf,
   9013                                            size_t len)
   9014          {
   9015          #if defined(MBEDTLS_HAVE_TIME)
   9016              uint64_t start;
   9017          #endif
   9018          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   9019          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   9020              size_t cert_len;
   9021          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   9022          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   9023          
   9024              const unsigned char *p = buf;
   9025              const unsigned char * const end = buf + len;
   9026          
   9027              /*
   9028               * Time
   9029               */
   9030          #if defined(MBEDTLS_HAVE_TIME)
   9031              if (8 > (size_t) (end - p)) {
   9032                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9033              }
   9034          
   9035              start = MBEDTLS_GET_UINT64_BE(p, 0);
   9036              p += 8;
   9037          
   9038              session->start = (time_t) start;
   9039          #endif /* MBEDTLS_HAVE_TIME */
   9040          
   9041              /*
   9042               * Basic mandatory fields
   9043               */
   9044              if (2 + 1 + 32 + 48 + 4 > (size_t) (end - p)) {
   9045                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9046              }
   9047          
   9048              session->ciphersuite = (p[0] << 8) | p[1];
   9049              p += 2;
   9050          
   9051              session->id_len = *p++;
   9052              memcpy(session->id, p, 32);
   9053              p += 32;
   9054          
   9055              memcpy(session->master, p, 48);
   9056              p += 48;
   9057          
   9058              session->verify_result = MBEDTLS_GET_UINT32_BE(p, 0);
   9059              p += 4;
   9060          
   9061              /* Immediately clear invalid pointer values that have been read, in case
   9062               * we exit early before we replaced them with valid ones. */
   9063          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   9064          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   9065              session->peer_cert = NULL;
   9066          #else
   9067              session->peer_cert_digest = NULL;
   9068          #endif /* !MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   9069          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   9070          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   9071              session->ticket = NULL;
   9072          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
   9073          
   9074              /*
   9075               * Peer certificate
   9076               */
   9077          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   9078          #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
   9079              /* Deserialize CRT from the end of the ticket. */
   9080              if (3 > (size_t) (end - p)) {
   9081                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9082              }
   9083          
   9084              cert_len = (p[0] << 16) | (p[1] << 8) | p[2];
   9085              p += 3;
   9086          
   9087              if (cert_len != 0) {
   9088                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   9089          
   9090                  if (cert_len > (size_t) (end - p)) {
   9091                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9092                  }
   9093          
   9094                  session->peer_cert = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
   9095          
   9096                  if (session->peer_cert == NULL) {
   9097                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   9098                  }
   9099          
   9100                  mbedtls_x509_crt_init(session->peer_cert);
   9101          
   9102                  if ((ret = mbedtls_x509_crt_parse_der(session->peer_cert,
   9103                                                        p, cert_len)) != 0) {
   9104                      mbedtls_x509_crt_free(session->peer_cert);
   9105                      mbedtls_free(session->peer_cert);
   9106                      session->peer_cert = NULL;
   9107                      return ret;
   9108                  }
   9109          
   9110                  p += cert_len;
   9111              }
   9112          #else /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   9113              /* Deserialize CRT digest from the end of the ticket. */
   9114              if (2 > (size_t) (end - p)) {
   9115                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9116              }
   9117          
   9118              session->peer_cert_digest_type = (mbedtls_md_type_t) *p++;
   9119              session->peer_cert_digest_len  = (size_t) *p++;
   9120          
   9121              if (session->peer_cert_digest_len != 0) {
   9122                  const mbedtls_md_info_t *md_info =
   9123                      mbedtls_md_info_from_type(session->peer_cert_digest_type);
   9124                  if (md_info == NULL) {
   9125                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9126                  }
   9127                  if (session->peer_cert_digest_len != mbedtls_md_get_size(md_info)) {
   9128                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9129                  }
   9130          
   9131                  if (session->peer_cert_digest_len > (size_t) (end - p)) {
   9132                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9133                  }
   9134          
   9135                  session->peer_cert_digest =
   9136                      mbedtls_calloc(1, session->peer_cert_digest_len);
   9137                  if (session->peer_cert_digest == NULL) {
   9138                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   9139                  }
   9140          
   9141                  memcpy(session->peer_cert_digest, p,
   9142                         session->peer_cert_digest_len);
   9143                  p += session->peer_cert_digest_len;
   9144              }
   9145          #endif /* MBEDTLS_SSL_KEEP_PEER_CERTIFICATE */
   9146          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   9147          
   9148              /*
   9149               * Session ticket and associated data
   9150               */
   9151          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   9152              if (3 > (size_t) (end - p)) {
   9153                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9154              }
   9155          
   9156              session->ticket_len = (p[0] << 16) | (p[1] << 8) | p[2];
   9157              p += 3;
   9158          
   9159              if (session->ticket_len != 0) {
   9160                  if (session->ticket_len > (size_t) (end - p)) {
   9161                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9162                  }
   9163          
   9164                  session->ticket = mbedtls_calloc(1, session->ticket_len);
   9165                  if (session->ticket == NULL) {
   9166                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   9167                  }
   9168          
   9169                  memcpy(session->ticket, p, session->ticket_len);
   9170                  p += session->ticket_len;
   9171              }
   9172          
   9173              if (4 > (size_t) (end - p)) {
   9174                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9175              }
   9176          
   9177              session->ticket_lifetime = MBEDTLS_GET_UINT32_BE(p, 0);
   9178              p += 4;
   9179          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
   9180          
   9181              /*
   9182               * Misc extension-related info
   9183               */
   9184          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   9185              if (1 > (size_t) (end - p)) {
   9186                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9187              }
   9188          
   9189              session->mfl_code = *p++;
   9190          #endif
   9191          
   9192          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   9193              if (1 > (size_t) (end - p)) {
   9194                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9195              }
   9196          
   9197              session->encrypt_then_mac = *p++;
   9198          #endif
   9199          
   9200              /* Done, should have consumed entire buffer */
   9201              if (p != end) {
   9202                  return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9203              }
   9204          
   9205              return 0;
   9206          }
   9207          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   9208          

   \                                 In section .text, align 2, keep-with-next
   9209          int mbedtls_ssl_validate_ciphersuite(
   9210              const mbedtls_ssl_context *ssl,
   9211              const mbedtls_ssl_ciphersuite_t *suite_info,
   9212              mbedtls_ssl_protocol_version min_tls_version,
   9213              mbedtls_ssl_protocol_version max_tls_version)
   9214          {
   9215              (void) ssl;
   9216          
   9217              if (suite_info == NULL) {
   \                     mbedtls_ssl_validate_ciphersuite: (+1)
   \        0x0   0xB129             CBZ.N    R1,??mbedtls_ssl_validate_ciphersuite_0
   9218                  return -1;
   9219              }
   9220          
   9221              if ((suite_info->min_tls_version > max_tls_version) ||
   9222                  (suite_info->max_tls_version < min_tls_version)) {
   \        0x2   0x8988             LDRH     R0,[R1, #+12]
   \        0x4   0x4283             CMP      R3,R0
   \        0x6   0xBFA4             ITT      GE
   \        0x8   0x89C9             LDRHGE   R1,[R1, #+14]
   \        0xA   0x4291             CMPGE    R1,R2
   \        0xC   0xDA00             BGE.N    ??mbedtls_ssl_validate_ciphersuite_1
   9223                  return -1;
   \                     ??mbedtls_ssl_validate_ciphersuite_0: (+1)
   \        0xE   0x....             B.N      ?Subroutine1
   9224              }
   9225          
   9226          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_CLI_C)
   9227          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   9228          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   9229              if (suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
   9230                  ssl->handshake->psa_pake_ctx_is_ok != 1)
   9231          #else
   9232              if (suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
   9233                  mbedtls_ecjpake_check(&ssl->handshake->ecjpake_ctx) != 0)
   9234          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   9235              {
   9236                  return -1;
   9237              }
   9238          #endif
   9239          
   9240              /* Don't suggest PSK-based ciphersuite if no PSK is available. */
   9241          #if defined(MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED)
   9242              if (mbedtls_ssl_ciphersuite_uses_psk(suite_info) &&
   9243                  mbedtls_ssl_conf_has_static_psk(ssl->conf) == 0) {
   9244                  return -1;
   9245              }
   9246          #endif /* MBEDTLS_KEY_EXCHANGE_SOME_PSK_ENABLED */
   9247          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   9248          
   9249              return 0;
   \                     ??mbedtls_ssl_validate_ciphersuite_1: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR
   9250          }
   9251          
   9252          #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
   9253          /*
   9254           * Function for writing a signature algorithm extension.
   9255           *
   9256           * The `extension_data` field of signature algorithm contains  a `SignatureSchemeList`
   9257           * value (TLS 1.3 RFC8446):
   9258           *      enum {
   9259           *         ....
   9260           *        ecdsa_secp256r1_sha256( 0x0403 ),
   9261           *        ecdsa_secp384r1_sha384( 0x0503 ),
   9262           *        ecdsa_secp521r1_sha512( 0x0603 ),
   9263           *         ....
   9264           *      } SignatureScheme;
   9265           *
   9266           *      struct {
   9267           *         SignatureScheme supported_signature_algorithms<2..2^16-2>;
   9268           *      } SignatureSchemeList;
   9269           *
   9270           * The `extension_data` field of signature algorithm contains a `SignatureAndHashAlgorithm`
   9271           * value (TLS 1.2 RFC5246):
   9272           *      enum {
   9273           *          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
   9274           *          sha512(6), (255)
   9275           *      } HashAlgorithm;
   9276           *
   9277           *      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
   9278           *        SignatureAlgorithm;
   9279           *
   9280           *      struct {
   9281           *          HashAlgorithm hash;
   9282           *          SignatureAlgorithm signature;
   9283           *      } SignatureAndHashAlgorithm;
   9284           *
   9285           *      SignatureAndHashAlgorithm
   9286           *        supported_signature_algorithms<2..2^16-2>;
   9287           *
   9288           * The TLS 1.3 signature algorithm extension was defined to be a compatible
   9289           * generalization of the TLS 1.2 signature algorithm extension.
   9290           * `SignatureAndHashAlgorithm` field of TLS 1.2 can be represented by
   9291           * `SignatureScheme` field of TLS 1.3
   9292           *
   9293           */

   \                                 In section .text, align 4, keep-with-next
   9294          int mbedtls_ssl_write_sig_alg_ext(mbedtls_ssl_context *ssl, unsigned char *buf,
   9295                                            const unsigned char *end, size_t *out_len)
   9296          {
   \                     mbedtls_ssl_write_sig_alg_ext: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x469B             MOV      R11,R3
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4692             MOV      R10,R2
   9297              unsigned char *p = buf;
   9298              unsigned char *supported_sig_alg; /* Start of supported_signature_algorithms */
   9299              size_t supported_sig_alg_len = 0; /* Length of supported_signature_algorithms */
   9300          
   9301              *out_len = 0;
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0xF8CB 0x3000      STR      R3,[R11, #+0]
   9302          
   9303              MBEDTLS_SSL_DEBUG_MSG(3, ("adding signature_algorithms extension"));
   9304          
   9305              /* Check if we have space for header and length field:
   9306               * - extension_type         (2 bytes)
   9307               * - extension_data_length  (2 bytes)
   9308               * - supported_signature_algorithms_length   (2 bytes)
   9309               */
   9310              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 6);
   \       0x12   0x2206             MOVS     R2,#+6
   \       0x14   0x4651             MOV      R1,R10
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x1C   0xBB48             CBNZ.N   R0,??mbedtls_ssl_write_sig_alg_ext_0
   9311              p += 6;
   \       0x1E   0x1DB7             ADDS     R7,R6,#+6
   9312          
   9313              /*
   9314               * Write supported_signature_algorithms
   9315               */
   9316              supported_sig_alg = p;
   9317              const uint16_t *sig_alg = mbedtls_ssl_get_sig_algs(ssl);
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x463C             MOV      R4,R7
   \       0x24   0x.... 0x....      BL       mbedtls_ssl_get_sig_algs
   9318              if (sig_alg == NULL) {
   \       0x28   0xB908             CBNZ.N   R0,??mbedtls_ssl_write_sig_alg_ext_1
   9319                  return MBEDTLS_ERR_SSL_BAD_CONFIG;
   \       0x2A   0x....             LDR.N    R0,??DataTable37_35
   \       0x2C   0xE04B             B.N      ??mbedtls_ssl_write_sig_alg_ext_2
   9320              }
   \                     ??mbedtls_ssl_write_sig_alg_ext_1: (+1)
   \       0x2E   0x4681             MOV      R9,R0
   \       0x30   0x....             ADR.N    R5,mbedtls_byte_order_detector
   \       0x32   0xE00F             B.N      ??mbedtls_ssl_write_sig_alg_ext_3
   9321          
   9322              for (; *sig_alg != MBEDTLS_TLS1_3_SIG_NONE; sig_alg++) {
   9323                  MBEDTLS_SSL_DEBUG_MSG(3, ("got signature scheme [%x] %s",
   9324                                            *sig_alg,
   9325                                            mbedtls_ssl_sig_alg_to_str(*sig_alg)));
   9326                  if (!mbedtls_ssl_sig_alg_is_supported(ssl, *sig_alg)) {
   9327                      continue;
   9328                  }
   9329                  MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
   9330                  MBEDTLS_PUT_UINT16_BE(*sig_alg, p, 0);
   \                     ??mbedtls_ssl_write_sig_alg_ext_4: (+1)
   \       0x34   0x7829             LDRB     R1,[R5, #+0]
   \       0x36   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \       0x3A   0x2901             CMP      R1,#+1
   \       0x3C   0xBF1D             ITTTE    NE
   \       0x3E   0x0A01             LSRNE    R1,R0,#+8
   \       0x40   0xEA41 0x2100      ORRNE    R1,R1,R0, LSL #+8
   \       0x44   0xB289             UXTHNE   R1,R1
   \       0x46   0x4601             MOVEQ    R1,R0
   \       0x48   0x4638             MOV      R0,R7
   \       0x4A   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   9331                  p += 2;
   \       0x4E   0x1CBF             ADDS     R7,R7,#+2
   9332                  MBEDTLS_SSL_DEBUG_MSG(3, ("sent signature scheme [%x] %s",
   9333                                            *sig_alg,
   9334                                            mbedtls_ssl_sig_alg_to_str(*sig_alg)));
   \                     ??mbedtls_ssl_write_sig_alg_ext_5: (+1)
   \       0x50   0xF109 0x0902      ADD      R9,R9,#+2
   \                     ??mbedtls_ssl_write_sig_alg_ext_3: (+1)
   \       0x54   0xF8B9 0x1000      LDRH     R1,[R9, #+0]
   \       0x58   0xB169             CBZ.N    R1,??mbedtls_ssl_write_sig_alg_ext_6
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0x.... 0x....      BL       mbedtls_ssl_sig_alg_is_supported
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD0F5             BEQ.N    ??mbedtls_ssl_write_sig_alg_ext_5
   \       0x64   0x2202             MOVS     R2,#+2
   \       0x66   0x4651             MOV      R1,R10
   \       0x68   0x4638             MOV      R0,R7
   \       0x6A   0x.... 0x....      BL       mbedtls_ssl_chk_buf_ptr
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD0E0             BEQ.N    ??mbedtls_ssl_write_sig_alg_ext_4
   \                     ??mbedtls_ssl_write_sig_alg_ext_0: (+1)
   \       0x72   0x....             LDR.N    R0,??DataTable37_25
   \       0x74   0xE027             B.N      ??mbedtls_ssl_write_sig_alg_ext_2
   9335              }
   9336          
   9337              /* Length of supported_signature_algorithms */
   9338              supported_sig_alg_len = p - supported_sig_alg;
   \                     ??mbedtls_ssl_write_sig_alg_ext_6: (+1)
   \       0x76   0x1B3C             SUBS     R4,R7,R4
   9339              if (supported_sig_alg_len == 0) {
   \       0x78   0xBF08             IT       EQ
   \       0x7A   0x....             LDREQ.N  R0,??DataTable37_2
   9340                  MBEDTLS_SSL_DEBUG_MSG(1, ("No signature algorithms defined."));
   9341                  return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
   \       0x7C   0xD023             BEQ.N    ??mbedtls_ssl_write_sig_alg_ext_2
   9342              }
   9343          
   9344              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_SIG_ALG, buf, 0);
   \       0x7E   0x7828             LDRB     R0,[R5, #+0]
   \       0x80   0x2801             CMP      R0,#+1
   \       0x82   0xBF0C             ITE      EQ
   \       0x84   0x210D             MOVEQ    R1,#+13
   \       0x86   0xF44F 0x6150      MOVNE    R1,#+3328
   \       0x8A   0x4630             MOV      R0,R6
   \       0x8C   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   9345              MBEDTLS_PUT_UINT16_BE(supported_sig_alg_len + 2, buf, 2);
   \       0x90   0x7829             LDRB     R1,[R5, #+0]
   \       0x92   0x1CA0             ADDS     R0,R4,#+2
   \       0x94   0x2901             CMP      R1,#+1
   \       0x96   0xBF08             IT       EQ
   \       0x98   0xB281             UXTHEQ   R1,R0
   \       0x9A   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x9E   0x1CB0             ADDS     R0,R6,#+2
   \       0xA0   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   9346              MBEDTLS_PUT_UINT16_BE(supported_sig_alg_len, buf, 4);
   \       0xA4   0x7828             LDRB     R0,[R5, #+0]
   \       0xA6   0x2801             CMP      R0,#+1
   \       0xA8   0xBF08             IT       EQ
   \       0xAA   0xB2A1             UXTHEQ   R1,R4
   \       0xAC   0xD004             BEQ.N    ??mbedtls_ssl_write_sig_alg_ext_7
   \       0xAE   0x0421             LSLS     R1,R4,#+16
   \       0xB0   0x0E09             LSRS     R1,R1,#+24
   \       0xB2   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
   \       0xB6   0xB289             UXTH     R1,R1
   \                     ??mbedtls_ssl_write_sig_alg_ext_7: (+1)
   \       0xB8   0x1D30             ADDS     R0,R6,#+4
   \       0xBA   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   9347          
   9348              *out_len = p - buf;
   \       0xBE   0x1BBE             SUBS     R6,R7,R6
   \       0xC0   0xF8CB 0x6000      STR      R6,[R11, #+0]
   9349          
   9350          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   9351              mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SIG_ALG);
   9352          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
   9353          
   9354              return 0;
   \       0xC4   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ssl_write_sig_alg_ext_2: (+1)
   \       0xC6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   9355          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0xD004             BEQ.N    ??Subroutine12_0
   \        0x2   0x0401             LSLS     R1,R0,#+16
   \        0x4   0x0E09             LSRS     R1,R1,#+24
   \        0x6   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \        0xA   0xB289             UXTH     R1,R1
   \                     ??Subroutine12_0: (+1)
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x54 0x4C          DC8 "TLSv1.2"
   \              0x53 0x76    
   \              0x31 0x2E    
   \              0x32 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x54 0x4C          DC8 "TLSv1.3"
   \              0x53 0x76    
   \              0x31 0x2E    
   \              0x33 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x75 0x6E          DC8 "unknown"
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     psa_generic_status_to_mbedtls

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0x....'....        DC32     psa_to_ssl_errors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \        0x0   0xFFFF'8100        DC32     0xffff8100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \        0x0   0xFFFF'8F80        DC32     0xffff8f80

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x.... 0x....      B.W      __aeabi_memcpy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x....'....        DC32     ssl_update_checksum_start

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x2164             MOVS     R1,#+100
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0xFFFF'A180        DC32     0xffffa180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \        0x0   0xFFFF'8100        DC32     0xffff8100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \        0x0   0x0550'0100        DC32     0x5500100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \        0x0   0x0550'0200        DC32     0x5500200

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x2B 0x06          DC8 "+\006\001\005\005\007\003\001"
   \              0x01 0x05    
   \              0x05 0x07    
   \              0x03 0x01    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x2B 0x06          DC8 "+\006\001\005\005\007\003\002"
   \              0x01 0x05    
   \              0x05 0x07    
   \              0x03 0x02    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x0510'0500        DC32     0x5100500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \        0x0   0x....'....        DC32     ssl_serialized_session_header

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \        0x0   0x....'....        DC32     mbedtls_byte_order_detector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \        0x0   0xFFFF'A100        DC32     0xffffa100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \        0x0   0x....'....        DC32     ssl_preset_default_groups

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \        0x0   0x....'....        DC32     mbedtls_x509_crt_profile_suiteb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x....'....        DC32     mbedtls_x509_crt_profile_default

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0xF104 0x02B8      ADD      R2,R4,#+184
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE9C2 0x0000      STRD     R0,R0,[R2, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0xFFFF'8D00        DC32     0xffff8d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \        0x0   0xFFFF'9200        DC32     0xffff9200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_2:
   \        0x0   0x....'....        DC32     `psa_key_attributes_init::v`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_3:
   \        0x0   0x0800'0209        DC32     0x8000209

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0xFFFF'8080        DC32     0xffff8080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \        0x0   0x....'....        DC32     tls_prf_sha256

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \        0x0   0xFFFF'9400        DC32     0xffff9400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \        0x0   0x0200'0003        DC32     0x2000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \        0x0   0x0200'0004        DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \        0x0   0x0200'0005        DC32     0x2000005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \        0x0   0x0200'0008        DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_7:
   \        0x0   0x0200'0009        DC32     0x2000009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_8:
   \        0x0   0x0200'000A        DC32     0x200000a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_9:
   \        0x0   0x0200'000B        DC32     0x200000b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_10:
   \        0x0   0x0200'000C        DC32     0x200000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_11:
   \        0x0   0x0200'000D        DC32     0x200000d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_12:
   \        0x0   0x0200'0010        DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_13:
   \        0x0   0x0200'0011        DC32     0x2000011

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_14:
   \        0x0   0x0200'0012        DC32     0x2000012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_15:
   \        0x0   0x0200'0013        DC32     0x2000013

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_16:
   \        0x0   0x04C0'1000        DC32     0x4c01000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_17:
   \        0x0   0x04C0'1100        DC32     0x4c01100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_18:
   \        0x0   0x04C0'1200        DC32     0x4c01200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_19:
   \        0x0   0x0440'FF00        DC32     0x440ff00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_20:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_21:
   \        0x0   0x0440'4100        DC32     0x4404100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_22:
   \        0x0   0x0480'0100        DC32     0x4800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_23:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_24:
   \        0x0   0xFFFF'8F00        DC32     0xffff8f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_25:
   \        0x0   0xFFFF'9600        DC32     0xffff9600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_26:
   \        0x0   0xFFFF'8100        DC32     0xffff8100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_27:
   \        0x0   0xFFFF'D780        DC32     0xffffd780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_28:
   \        0x0   0xFFFF'8600        DC32     0xffff8600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_29:
   \        0x0   0xFFFF'8900        DC32     0xffff8900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_30:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_31:
   \        0x0   0xFFFF'8980        DC32     0xffff8980

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_32:
   \        0x0   0xFFFF'AF80        DC32     0xffffaf80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_33:
   \        0x0   0xFFFF'AF00        DC32     0xffffaf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_34:
   \        0x0   0xFFFF'AE80        DC32     0xffffae80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_35:
   \        0x0   0xFFFF'A180        DC32     0xffffa180

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x6D 0x61          DC8 "master secret"
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x20 0x73    
   \              0x65 0x63    
   \              0x72 0x65    
   \              0x74 0x00
   \        0xE                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x63 0x6C          DC8 "client finished"
   \              0x69 0x65    
   \              0x6E 0x74    
   \              0x20 0x66    
   \              0x69 0x6E    
   \              0x69 0x73    
   \              0x68 0x65    
   \              0x64 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x73 0x65          DC8 "server finished"
   \              0x72 0x76    
   \              0x65 0x72    
   \              0x20 0x66    
   \              0x69 0x6E    
   \              0x69 0x73    
   \              0x68 0x65    
   \              0x64 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x6B 0x65          DC8 "key expansion"
   \              0x79 0x20    
   \              0x65 0x78    
   \              0x70 0x61    
   \              0x6E 0x73    
   \              0x69 0x6F    
   \              0x6E 0x00
   \        0xE                      DS8 2
   9356          #endif /* MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED */
   9357          
   9358          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   9359          /*
   9360           * mbedtls_ssl_parse_server_name_ext
   9361           *
   9362           * Structure of server_name extension:
   9363           *
   9364           *  enum {
   9365           *        host_name(0), (255)
   9366           *     } NameType;
   9367           *  opaque HostName<1..2^16-1>;
   9368           *
   9369           *  struct {
   9370           *          NameType name_type;
   9371           *          select (name_type) {
   9372           *             case host_name: HostName;
   9373           *           } name;
   9374           *     } ServerName;
   9375           *  struct {
   9376           *          ServerName server_name_list<1..2^16-1>
   9377           *     } ServerNameList;
   9378           */
   9379          MBEDTLS_CHECK_RETURN_CRITICAL
   9380          int mbedtls_ssl_parse_server_name_ext(mbedtls_ssl_context *ssl,
   9381                                                const unsigned char *buf,
   9382                                                const unsigned char *end)
   9383          {
   9384              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   9385              const unsigned char *p = buf;
   9386              size_t server_name_list_len, hostname_len;
   9387              const unsigned char *server_name_list_end;
   9388          
   9389              MBEDTLS_SSL_DEBUG_MSG(3, ("parse ServerName extension"));
   9390          
   9391              MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 2);
   9392              server_name_list_len = MBEDTLS_GET_UINT16_BE(p, 0);
   9393              p += 2;
   9394          
   9395              MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, server_name_list_len);
   9396              server_name_list_end = p + server_name_list_len;
   9397              while (p < server_name_list_end) {
   9398                  MBEDTLS_SSL_CHK_BUF_READ_PTR(p, server_name_list_end, 3);
   9399                  hostname_len = MBEDTLS_GET_UINT16_BE(p, 1);
   9400                  MBEDTLS_SSL_CHK_BUF_READ_PTR(p, server_name_list_end,
   9401                                               hostname_len + 3);
   9402          
   9403                  if (p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME) {
   9404                      /* sni_name is intended to be used only during the parsing of the
   9405                       * ClientHello message (it is reset to NULL before the end of
   9406                       * the message parsing). Thus it is ok to just point to the
   9407                       * reception buffer and not make a copy of it.
   9408                       */
   9409                      ssl->handshake->sni_name = p + 3;
   9410                      ssl->handshake->sni_name_len = hostname_len;
   9411                      if (ssl->conf->f_sni == NULL) {
   9412                          return 0;
   9413                      }
   9414                      ret = ssl->conf->f_sni(ssl->conf->p_sni,
   9415                                             ssl, p + 3, hostname_len);
   9416                      if (ret != 0) {
   9417                          MBEDTLS_SSL_DEBUG_RET(1, "ssl_sni_wrapper", ret);
   9418                          MBEDTLS_SSL_PEND_FATAL_ALERT(MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME,
   9419                                                       MBEDTLS_ERR_SSL_UNRECOGNIZED_NAME);
   9420                          return MBEDTLS_ERR_SSL_UNRECOGNIZED_NAME;
   9421                      }
   9422                      return 0;
   9423                  }
   9424          
   9425                  p += hostname_len + 3;
   9426              }
   9427          
   9428              return 0;
   9429          }
   9430          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   9431          
   9432          #if defined(MBEDTLS_SSL_ALPN)
   9433          MBEDTLS_CHECK_RETURN_CRITICAL
   9434          int mbedtls_ssl_parse_alpn_ext(mbedtls_ssl_context *ssl,
   9435                                         const unsigned char *buf,
   9436                                         const unsigned char *end)
   9437          {
   9438              const unsigned char *p = buf;
   9439              size_t protocol_name_list_len;
   9440              const unsigned char *protocol_name_list;
   9441              const unsigned char *protocol_name_list_end;
   9442              size_t protocol_name_len;
   9443          
   9444              /* If ALPN not configured, just ignore the extension */
   9445              if (ssl->conf->alpn_list == NULL) {
   9446                  return 0;
   9447              }
   9448          
   9449              /*
   9450               * RFC7301, section 3.1
   9451               *      opaque ProtocolName<1..2^8-1>;
   9452               *
   9453               *      struct {
   9454               *          ProtocolName protocol_name_list<2..2^16-1>
   9455               *      } ProtocolNameList;
   9456               */
   9457          
   9458              /*
   9459               * protocol_name_list_len    2 bytes
   9460               * protocol_name_len         1 bytes
   9461               * protocol_name             >=1 byte
   9462               */
   9463              MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 4);
   9464          
   9465              protocol_name_list_len = MBEDTLS_GET_UINT16_BE(p, 0);
   9466              p += 2;
   9467              MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, protocol_name_list_len);
   9468              protocol_name_list = p;
   9469              protocol_name_list_end = p + protocol_name_list_len;
   9470          
   9471              /* Validate peer's list (lengths) */
   9472              while (p < protocol_name_list_end) {
   9473                  protocol_name_len = *p++;
   9474                  MBEDTLS_SSL_CHK_BUF_READ_PTR(p, protocol_name_list_end,
   9475                                               protocol_name_len);
   9476                  if (protocol_name_len == 0) {
   9477                      MBEDTLS_SSL_PEND_FATAL_ALERT(
   9478                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER,
   9479                          MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER);
   9480                      return MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER;
   9481                  }
   9482          
   9483                  p += protocol_name_len;
   9484              }
   9485          
   9486              /* Use our order of preference */
   9487              for (const char **alpn = ssl->conf->alpn_list; *alpn != NULL; alpn++) {
   9488                  size_t const alpn_len = strlen(*alpn);
   9489                  p = protocol_name_list;
   9490                  while (p < protocol_name_list_end) {
   9491                      protocol_name_len = *p++;
   9492                      if (protocol_name_len == alpn_len &&
   9493                          memcmp(p, *alpn, alpn_len) == 0) {
   9494                          ssl->alpn_chosen = *alpn;
   9495                          return 0;
   9496                      }
   9497          
   9498                      p += protocol_name_len;
   9499                  }
   9500              }
   9501          
   9502              /* If we get here, no match was found */
   9503              MBEDTLS_SSL_PEND_FATAL_ALERT(
   9504                  MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL,
   9505                  MBEDTLS_ERR_SSL_NO_APPLICATION_PROTOCOL);
   9506              return MBEDTLS_ERR_SSL_NO_APPLICATION_PROTOCOL;
   9507          }
   9508          
   9509          int mbedtls_ssl_write_alpn_ext(mbedtls_ssl_context *ssl,
   9510                                         unsigned char *buf,
   9511                                         unsigned char *end,
   9512                                         size_t *out_len)
   9513          {
   9514              unsigned char *p = buf;
   9515              size_t protocol_name_len;
   9516              *out_len = 0;
   9517          
   9518              if (ssl->alpn_chosen == NULL) {
   9519                  return 0;
   9520              }
   9521          
   9522              protocol_name_len = strlen(ssl->alpn_chosen);
   9523              MBEDTLS_SSL_CHK_BUF_PTR(p, end, 7 + protocol_name_len);
   9524          
   9525              MBEDTLS_SSL_DEBUG_MSG(3, ("server side, adding alpn extension"));
   9526              /*
   9527               * 0 . 1    ext identifier
   9528               * 2 . 3    ext length
   9529               * 4 . 5    protocol list length
   9530               * 6 . 6    protocol name length
   9531               * 7 . 7+n  protocol name
   9532               */
   9533              MBEDTLS_PUT_UINT16_BE(MBEDTLS_TLS_EXT_ALPN, p, 0);
   9534          
   9535              *out_len = 7 + protocol_name_len;
   9536          
   9537              MBEDTLS_PUT_UINT16_BE(protocol_name_len + 3, p, 2);
   9538              MBEDTLS_PUT_UINT16_BE(protocol_name_len + 1, p, 4);
   9539              /* Note: the length of the chosen protocol has been checked to be less
   9540               * than 255 bytes in `mbedtls_ssl_conf_alpn_protocols`.
   9541               */
   9542              p[6] = MBEDTLS_BYTE_0(protocol_name_len);
   9543          
   9544              memcpy(p + 7, ssl->alpn_chosen, protocol_name_len);
   9545          
   9546          #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
   9547              mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_ALPN);
   9548          #endif
   9549          
   9550              return 0;
   9551          }
   9552          #endif /* MBEDTLS_SSL_ALPN */
   9553          
   9554          #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && \
   9555              defined(MBEDTLS_SSL_SESSION_TICKETS) && \
   9556              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION) && \
   9557              defined(MBEDTLS_SSL_CLI_C)
   9558          int mbedtls_ssl_session_set_hostname(mbedtls_ssl_session *session,
   9559                                               const char *hostname)
   9560          {
   9561              /* Initialize to suppress unnecessary compiler warning */
   9562              size_t hostname_len = 0;
   9563          
   9564              /* Check if new hostname is valid before
   9565               * making any change to current one */
   9566              if (hostname != NULL) {
   9567                  hostname_len = strlen(hostname);
   9568          
   9569                  if (hostname_len > MBEDTLS_SSL_MAX_HOST_NAME_LEN) {
   9570                      return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
   9571                  }
   9572              }
   9573          
   9574              /* Now it's clear that we will overwrite the old hostname,
   9575               * so we can free it safely */
   9576              if (session->hostname != NULL) {
   9577                  mbedtls_zeroize_and_free(session->hostname,
   9578                                           strlen(session->hostname));
   9579              }
   9580          
   9581              /* Passing NULL as hostname shall clear the old one */
   9582              if (hostname == NULL) {
   9583                  session->hostname = NULL;
   9584              } else {
   9585                  session->hostname = mbedtls_calloc(1, hostname_len + 1);
   9586                  if (session->hostname == NULL) {
   9587                      return MBEDTLS_ERR_SSL_ALLOC_FAILED;
   9588                  }
   9589          
   9590                  memcpy(session->hostname, hostname, hostname_len);
   9591              }
   9592          
   9593              return 0;
   9594          }
   9595          #endif /* MBEDTLS_SSL_PROTO_TLS1_3 &&
   9596                    MBEDTLS_SSL_SESSION_TICKETS &&
   9597                    MBEDTLS_SSL_SERVER_NAME_INDICATION &&
   9598                    MBEDTLS_SSL_CLI_C */
   9599          
   9600          #endif /* MBEDTLS_SSL_TLS_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   local_err_translation
         0   -> psa_status_to_mbedtls
       0   mbedtls_bswap32
       4   mbedtls_get_unaligned_uint16
       4   mbedtls_get_unaligned_uint32
       4   mbedtls_put_unaligned_uint16
       4   mbedtls_put_unaligned_uint32
      16   mbedtls_ssl_add_hs_hdr_to_checksum
        16   -- Indirect call
      16   mbedtls_ssl_add_hs_msg_to_checksum
         0   -- Indirect call
        16   -> mbedtls_ssl_add_hs_hdr_to_checksum
      24   mbedtls_ssl_check_cert_usage
        24   -> mbedtls_x509_crt_check_extended_key_usage
        24   -> mbedtls_x509_crt_check_key_usage
       8   mbedtls_ssl_check_curve
         0   -> mbedtls_ssl_check_curve_tls_id
         8   -> mbedtls_ssl_get_tls_id_from_ecp_group_id
       8   mbedtls_ssl_check_curve_tls_id
       0   mbedtls_ssl_chk_buf_ptr
      28   mbedtls_ssl_cipher_to_psa
       0   mbedtls_ssl_conf_authmode
       0   mbedtls_ssl_conf_ca_chain
       0   mbedtls_ssl_conf_cert_profile
       0   mbedtls_ssl_conf_ciphersuites
       0   mbedtls_ssl_conf_curves
       0   mbedtls_ssl_conf_dbg
       0   mbedtls_ssl_conf_dtls_badmac_limit
       0   mbedtls_ssl_conf_endpoint
       0   mbedtls_ssl_conf_groups
       0   mbedtls_ssl_conf_is_tls12_only
       0   mbedtls_ssl_conf_legacy_renegotiation
       0   mbedtls_ssl_conf_max_frag_len
       0   mbedtls_ssl_conf_max_version
       0   mbedtls_ssl_conf_min_version
      16   mbedtls_ssl_conf_own_cert
        16   -> sl_calloc
        16   -> ssl_key_cert_free
       0   mbedtls_ssl_conf_read_timeout
       0   mbedtls_ssl_conf_rng
       0   mbedtls_ssl_conf_sig_algs
       0   mbedtls_ssl_conf_sig_hashes
       0   mbedtls_ssl_conf_transport
       0   mbedtls_ssl_conf_verify
      16   mbedtls_ssl_config_defaults
        16   -> mbedtls_ssl_conf_is_tls12_only
        16   -> mbedtls_ssl_list_ciphersuites
       8   mbedtls_ssl_config_free
         0   -> mbedtls_platform_zeroize
         8   -> ssl_key_cert_free
       0   mbedtls_ssl_config_init
         0   -> __aeabi_memclr4
     368   mbedtls_ssl_derive_keys
       368   -- Indirect call
       368   -> __aeabi_memclr4
       368   -> __aeabi_memcpy
       368   -> __aeabi_memcpy4
       368   -> local_err_translation
       368   -> mbedtls_platform_zeroize
       368   -> mbedtls_ssl_cipher_to_psa
       368   -> mbedtls_ssl_ciphersuite_from_id
       368   -> mbedtls_ssl_get_mode_from_ciphersuite
       368   -> psa_import_key
       368   -> psa_set_key_type
       368   -> psa_set_key_usage_flags
      16   mbedtls_ssl_free
         0   -> mbedtls_platform_zeroize
        16   -> mbedtls_ssl_handshake_free
        16   -> mbedtls_ssl_session_free
        16   -> mbedtls_ssl_transform_free
        16   -> mbedtls_zeroize_and_free
        16   -> sl_free
        16   -> strlen
       0   mbedtls_ssl_get_base_mode
       0   mbedtls_ssl_get_ciphersuite
         0   -> mbedtls_ssl_get_ciphersuite_name
       0   mbedtls_ssl_get_ciphersuite_id_from_ssl
      12   mbedtls_ssl_get_ecp_group_id_from_tls_id
       0   mbedtls_ssl_get_extension_id
       8   mbedtls_ssl_get_extension_mask
         8   -> mbedtls_ssl_get_extension_id
     256   mbedtls_ssl_get_handshake_transcript
       256   -> __aeabi_memclr4
       256   -> local_err_translation
       256   -> psa_hash_clone
       256   -> psa_hash_finish
      20   mbedtls_ssl_get_input_max_frag_len
     248   mbedtls_ssl_get_key_exchange_md_tls1_2
       248   -> __aeabi_memclr4
       248   -> mbedtls_ssl_send_alert_message
       248   -> psa_hash_finish
       248   -> psa_hash_setup
       248   -> psa_hash_update
       8   mbedtls_ssl_get_max_in_record_payload
         8   -> mbedtls_ssl_get_input_max_frag_len
       8   mbedtls_ssl_get_max_out_record_payload
         8   -> mbedtls_ssl_get_output_max_frag_len
      32   mbedtls_ssl_get_mode_from_ciphersuite
        32   -> mbedtls_ssl_cipher_to_psa
        32   -> mbedtls_ssl_get_base_mode
       0   mbedtls_ssl_get_mode_from_transform
         0   -> mbedtls_ssl_get_base_mode
      20   mbedtls_ssl_get_output_max_frag_len
       0   mbedtls_ssl_get_peer_cert
      12   mbedtls_ssl_get_psa_curve_info_from_tls_id
       8   mbedtls_ssl_get_session
         8   -> mbedtls_ssl_session_copy
       0   mbedtls_ssl_get_sig_algs
       8   mbedtls_ssl_get_tls_id_from_ecp_group_id
       0   mbedtls_ssl_get_verify_result
       0   mbedtls_ssl_get_version
       8   mbedtls_ssl_handshake
         8   -> mbedtls_ssl_handshake_step
      16   mbedtls_ssl_handshake_free
         0   -> mbedtls_platform_zeroize
        16   -> psa_destroy_key
        16   -> psa_hash_abort
        16   -> sl_free
      16   mbedtls_ssl_handshake_step
        16   -> mbedtls_ssl_flush_output
         0   -> mbedtls_ssl_handle_pending_alert
        16   -> mbedtls_ssl_handle_pending_alert
        16   -> mbedtls_ssl_handshake_client_step
        16   -> mbedtls_ssl_write_client_hello
      16   mbedtls_ssl_handshake_wrapup
        16   -- Indirect call
        16   -> mbedtls_ssl_handshake_wrapup_free_hs_transform
        16   -> mbedtls_ssl_session_free
        16   -> sl_free
       8   mbedtls_ssl_handshake_wrapup_free_hs_transform
         8   -> mbedtls_ssl_handshake_free
         8   -> mbedtls_ssl_transform_free
         8   -> sl_free
       0   mbedtls_ssl_hash_from_md_alg
       0   mbedtls_ssl_init
         0   -> __aeabi_memclr4
       0   mbedtls_ssl_md_alg_from_hash
       0   mbedtls_ssl_optimize_checksum
     200   mbedtls_ssl_parse_certificate
       200   -> __aeabi_memclr4
       200   -> __aeabi_memcpy4
       200   -> mbedtls_ecc_group_of_psa
       200   -> mbedtls_pk_can_do
       200   -> mbedtls_pk_get_type
       200   -> mbedtls_ssl_check_cert_usage
       200   -> mbedtls_ssl_check_curve
       200   -> mbedtls_ssl_read_record
       200   -> mbedtls_ssl_send_alert_message
       200   -> mbedtls_x509_crt_free
       200   -> mbedtls_x509_crt_init
       200   -> mbedtls_x509_crt_parse_der
       200   -> mbedtls_x509_crt_verify_restartable
       200   -> psa_get_key_attributes
       200   -> psa_reset_key_attributes
       200   -> sl_calloc
       200   -> sl_free
       200   -> ssl_clear_peer_cert
      24   mbedtls_ssl_parse_finished
        24   -- Indirect call
        24   -> mbedtls_ct_memcmp
        24   -> mbedtls_platform_zeroize
        24   -> mbedtls_ssl_read_record
        24   -> mbedtls_ssl_send_alert_message
      32   mbedtls_ssl_parse_sig_alg_ext
        32   -> __aeabi_memclr4
        32   -> mbedtls_get_unaligned_uint16
        32   -> mbedtls_ssl_chk_buf_ptr
        32   -> mbedtls_ssl_get_sig_algs
        32   -> mbedtls_ssl_pend_fatal_alert
        32   -> mbedtls_ssl_sig_alg_is_supported
       0   mbedtls_ssl_pk_alg_from_sig
       8   mbedtls_ssl_reset_checksum
         0   -> mbedtls_md_error_from_psa
         8   -> psa_hash_abort
         8   -> psa_hash_setup
      16   mbedtls_ssl_session_copy
        16   -> __aeabi_memcpy4
        16   -> mbedtls_ssl_session_free
        16   -> mbedtls_x509_crt_init
        16   -> mbedtls_x509_crt_parse_der
        16   -> sl_calloc
        16   -> sl_free
       8   mbedtls_ssl_session_free
         0   -> mbedtls_platform_zeroize
         8   -> ssl_clear_peer_cert
       0   mbedtls_ssl_session_init
         0   -> __aeabi_memclr4
      32   mbedtls_ssl_session_load
        32   -> __aeabi_memcpy
        32   -> mbedtls_bswap32
        32   -> mbedtls_get_unaligned_uint32
        32   -> mbedtls_ssl_session_free
        32   -> mbedtls_x509_crt_free
        32   -> mbedtls_x509_crt_init
        32   -> mbedtls_x509_crt_parse_der
        32   -> memcmp
        32   -> sl_calloc
        32   -> sl_free
       0   mbedtls_ssl_session_reset
         0   -> mbedtls_ssl_session_reset_int
       8   mbedtls_ssl_session_reset_int
         8   -> mbedtls_ssl_session_free
         8   -> mbedtls_ssl_session_reset_msg_layer
         8   -> sl_free
         0   -> ssl_handshake_init
      16   mbedtls_ssl_session_reset_msg_layer
        16   -> __aeabi_memclr
        16   -> mbedtls_ssl_reset_in_out_pointers
        16   -> mbedtls_ssl_set_timer
        16   -> mbedtls_ssl_transform_free
        16   -> sl_free
      32   mbedtls_ssl_session_save
        32   -> __aeabi_memcpy
        32   -> mbedtls_bswap32
        32   -> mbedtls_put_unaligned_uint16
        32   -> mbedtls_put_unaligned_uint32
       8   mbedtls_ssl_set_bio
       0   mbedtls_ssl_set_calc_verify_md
       0   mbedtls_ssl_set_export_keys_cb
      24   mbedtls_ssl_set_hostname
        24   -> __aeabi_memcpy
        24   -> mbedtls_zeroize_and_free
        24   -> sl_calloc
        24   -> strlen
       8   mbedtls_ssl_set_session
         8   -> mbedtls_ssl_session_copy
       0   mbedtls_ssl_set_timer_cb
         0   -> mbedtls_ssl_set_timer
       0   mbedtls_ssl_set_verify
      16   mbedtls_ssl_setup
        16   -> mbedtls_ssl_conf_is_tls12_only
        16   -> mbedtls_ssl_reset_in_out_pointers
        16   -> sl_calloc
        16   -> sl_free
        16   -> ssl_handshake_init
       8   mbedtls_ssl_sig_alg_is_supported
       8   mbedtls_ssl_sig_from_pk
         8   -> mbedtls_pk_can_do
       0   mbedtls_ssl_sig_from_pk_alg
      24   mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg
        24   -> mbedtls_pk_can_do_ext
      24   mbedtls_ssl_tls_prf
        24   -> tls_prf_sha256
       8   mbedtls_ssl_transform_init
         8   -> __aeabi_memclr4
       0   mbedtls_ssl_validate_ciphersuite
      24   mbedtls_ssl_write_certificate
        24   -> __aeabi_memcpy
         0   -> mbedtls_ssl_write_handshake_msg
      16   mbedtls_ssl_write_finished
        16   -- Indirect call
        16   -> mbedtls_ssl_update_out_pointers
         0   -> mbedtls_ssl_write_handshake_msg
       0   mbedtls_ssl_write_handshake_msg
         0   -> mbedtls_ssl_write_handshake_msg_ext
      40   mbedtls_ssl_write_sig_alg_ext
        40   -> mbedtls_put_unaligned_uint16
        40   -> mbedtls_ssl_chk_buf_ptr
        40   -> mbedtls_ssl_get_sig_algs
        40   -> mbedtls_ssl_sig_alg_is_supported
       0   psa_set_key_type
         0   -> psa_set_key_domain_parameters
       0   psa_set_key_usage_flags
     304   ssl_calc_finished_tls_sha256
       304   -- Indirect call
       304   -> __aeabi_memclr4
       304   -> mbedtls_md_error_from_psa
       304   -> mbedtls_platform_zeroize
       304   -> psa_hash_abort
       304   -> psa_hash_clone
       304   -> psa_hash_finish
     240   ssl_calc_verify_tls_sha256
       240   -> __aeabi_memclr4
       240   -> mbedtls_md_error_from_psa
       240   -> psa_hash_abort
       240   -> psa_hash_clone
       240   -> psa_hash_finish
       8   ssl_clear_peer_cert
         8   -> mbedtls_x509_crt_free
         8   -> sl_free
      24   ssl_handshake_init
        24   -> __aeabi_memclr4
        24   -> mbedtls_ssl_conf_is_tls12_only
        24   -> mbedtls_ssl_get_tls_id_from_ecp_group_id
        24   -> mbedtls_ssl_handshake_free
        24   -> mbedtls_ssl_hash_from_md_alg
        24   -> mbedtls_ssl_reset_checksum
        24   -> mbedtls_ssl_session_free
        24   -> mbedtls_ssl_session_init
        24   -> mbedtls_ssl_transform_free
        24   -> mbedtls_ssl_transform_init
        24   -> sl_calloc
        24   -> sl_free
       8   ssl_key_cert_free
         8   -> sl_free
       8   ssl_update_checksum_sha256
         0   -> mbedtls_md_error_from_psa
         8   -> psa_hash_update
       8   ssl_update_checksum_start
         0   -> mbedtls_md_error_from_psa
         8   -> psa_hash_update
     176   tls_prf_sha256
       176   -> __aeabi_memcpy4
       176   -> psa_destroy_key
       176   -> psa_import_key
       176   -> psa_key_derivation_abort
       176   -> psa_key_derivation_input_bytes
       176   -> psa_key_derivation_input_key
       176   -> psa_key_derivation_output_bytes
       176   -> psa_key_derivation_set_capacity
       176   -> psa_key_derivation_setup
       176   -> psa_set_key_type
       176   -> psa_set_key_usage_flags
       176   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable34
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable36_2
       4  ??DataTable36_3
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_11
       4  ??DataTable37_12
       4  ??DataTable37_13
       4  ??DataTable37_14
       4  ??DataTable37_15
       4  ??DataTable37_16
       4  ??DataTable37_17
       4  ??DataTable37_18
       4  ??DataTable37_19
       4  ??DataTable37_2
       4  ??DataTable37_20
       4  ??DataTable37_21
       4  ??DataTable37_22
       4  ??DataTable37_23
       4  ??DataTable37_24
       4  ??DataTable37_25
       4  ??DataTable37_26
       4  ??DataTable37_27
       4  ??DataTable37_28
       4  ??DataTable37_29
       4  ??DataTable37_3
       4  ??DataTable37_30
       4  ??DataTable37_31
       4  ??DataTable37_32
       4  ??DataTable37_33
       4  ??DataTable37_34
       4  ??DataTable37_35
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
       6  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine10
       6  ?Subroutine11
      14  ?Subroutine12
      10  ?Subroutine13
      12  ?Subroutine14
      12  ?Subroutine15
       8  ?Subroutine16
       6  ?Subroutine17
      10  ?Subroutine18
       4  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       8  ?Subroutine5
       6  ?Subroutine6
      12  ?Subroutine7
       8  ?Subroutine8
      10  ?Subroutine9
      36  ?_1
      16  ?_10
      16  ?_11
      16  ?_12
      16  ?_13
     224  ?_2
      36  ?_3
     224  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
      12  ?_8
      12  ?_9
      14  local_err_translation
      26  mbedtls_bswap32
       2  mbedtls_byte_order_detector
      22  mbedtls_get_unaligned_uint16
      12  mbedtls_get_unaligned_uint32
      18  mbedtls_put_unaligned_uint16
       8  mbedtls_put_unaligned_uint32
      34  mbedtls_ssl_add_hs_hdr_to_checksum
      34  mbedtls_ssl_add_hs_msg_to_checksum
     112  mbedtls_ssl_check_cert_usage
      24  mbedtls_ssl_check_curve
      34  mbedtls_ssl_check_curve_tls_id
      18  mbedtls_ssl_chk_buf_ptr
     334  mbedtls_ssl_cipher_to_psa
       4  mbedtls_ssl_conf_authmode
       6  mbedtls_ssl_conf_ca_chain
       4  mbedtls_ssl_conf_cert_profile
       4  mbedtls_ssl_conf_ciphersuites
       8  mbedtls_ssl_conf_curves
       2  mbedtls_ssl_conf_dbg
       4  mbedtls_ssl_conf_dtls_badmac_limit
       4  mbedtls_ssl_conf_endpoint
       8  mbedtls_ssl_conf_groups
      28  mbedtls_ssl_conf_is_tls12_only
       4  mbedtls_ssl_conf_legacy_renegotiation
      22  mbedtls_ssl_conf_max_frag_len
       8  mbedtls_ssl_conf_max_version
       8  mbedtls_ssl_conf_min_version
      68  mbedtls_ssl_conf_own_cert
       4  mbedtls_ssl_conf_read_timeout
       6  mbedtls_ssl_conf_rng
       8  mbedtls_ssl_conf_sig_algs
       4  mbedtls_ssl_conf_sig_hashes
       4  mbedtls_ssl_conf_transport
       6  mbedtls_ssl_conf_verify
     102  mbedtls_ssl_config_defaults
      10  mbedtls_ssl_config_free
       2  mbedtls_ssl_config_init
     992  mbedtls_ssl_derive_keys
     136  mbedtls_ssl_free
      30  mbedtls_ssl_get_base_mode
      18  mbedtls_ssl_get_ciphersuite
      18  mbedtls_ssl_get_ciphersuite_id_from_ssl
      32  mbedtls_ssl_get_ecp_group_id_from_tls_id
     176  mbedtls_ssl_get_extension_id
      14  mbedtls_ssl_get_extension_mask
      74  mbedtls_ssl_get_handshake_transcript
     134  mbedtls_ssl_get_input_max_frag_len
     126  mbedtls_ssl_get_key_exchange_md_tls1_2
      22  mbedtls_ssl_get_max_in_record_payload
      22  mbedtls_ssl_get_max_out_record_payload
      38  mbedtls_ssl_get_mode_from_ciphersuite
       4  mbedtls_ssl_get_mode_from_transform
     214  mbedtls_ssl_get_output_max_frag_len
      18  mbedtls_ssl_get_peer_cert
      50  mbedtls_ssl_get_psa_curve_info_from_tls_id
      48  mbedtls_ssl_get_session
      22  mbedtls_ssl_get_sig_algs
      32  mbedtls_ssl_get_tls_id_from_ecp_group_id
      20  mbedtls_ssl_get_verify_result
      32  mbedtls_ssl_get_version
      36  mbedtls_ssl_handshake
      78  mbedtls_ssl_handshake_free
     108  mbedtls_ssl_handshake_step
      66  mbedtls_ssl_handshake_wrapup
      42  mbedtls_ssl_handshake_wrapup_free_hs_transform
      30  mbedtls_ssl_hash_from_md_alg
       6  mbedtls_ssl_init
      30  mbedtls_ssl_md_alg_from_hash
      16  mbedtls_ssl_optimize_checksum
     662  mbedtls_ssl_parse_certificate
     132  mbedtls_ssl_parse_finished
     252  mbedtls_ssl_parse_sig_alg_ext
      12  mbedtls_ssl_pk_alg_from_sig
      40  mbedtls_ssl_reset_checksum
      76  mbedtls_ssl_session_copy
      14  mbedtls_ssl_session_free
       4  mbedtls_ssl_session_init
     282  mbedtls_ssl_session_load
       4  mbedtls_ssl_session_reset
      48  mbedtls_ssl_session_reset_int
      96  mbedtls_ssl_session_reset_msg_layer
     230  mbedtls_ssl_session_save
      14  mbedtls_ssl_set_bio
      16  mbedtls_ssl_set_calc_verify_md
       8  mbedtls_ssl_set_export_keys_cb
      96  mbedtls_ssl_set_hostname
      48  mbedtls_ssl_set_session
      12  mbedtls_ssl_set_timer_cb
       2  mbedtls_ssl_set_verify
     126  mbedtls_ssl_setup
      36  mbedtls_ssl_sig_alg_is_supported
      14  mbedtls_ssl_sig_from_pk
      20  mbedtls_ssl_sig_from_pk_alg
     126  mbedtls_ssl_tls12_get_preferred_hash_for_sig_alg
      40  mbedtls_ssl_tls_prf
      22  mbedtls_ssl_transform_init
      20  mbedtls_ssl_validate_ciphersuite
     206  mbedtls_ssl_write_certificate
      90  mbedtls_ssl_write_finished
       8  mbedtls_ssl_write_handshake_msg
     202  mbedtls_ssl_write_sig_alg_ext
      16  psa_set_key_type
      20  psa_set_key_usage_flags
     124  ssl_calc_finished_tls_sha256
      50  ssl_calc_verify_tls_sha256
      24  ssl_clear_peer_cert
     392  ssl_handshake_init
      18  ssl_key_cert_free
      24  ssl_preset_default_groups
          ssl_preset_default_sig_algs
          ssl_tls12_preset_default_sig_algs
          ssl_preset_suiteb_sig_algs
          ssl_tls12_preset_suiteb_sig_algs
          ssl_preset_suiteb_groups
      12  ssl_preset_suiteb_ciphersuites
       8  ssl_serialized_session_header
       8  ssl_update_checksum_sha256
      12  ssl_update_checksum_start
      12  tls_id_match_table
     246  tls_prf_sha256
     140  v
     224  v

 
    32 bytes in section .data
   884 bytes in section .rodata
 8'112 bytes in section .text
 
 8'052 bytes of CODE  memory (+ 60 bytes shared)
   884 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: 1
