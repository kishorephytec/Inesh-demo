###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:20
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\asn1write.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\asn1write.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\asn1write.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\asn1write.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\asn1write.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\asn1write.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\asn1write.c
      1          /*
      2           * ASN.1 buffer writing functionality
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #if defined(MBEDTLS_ASN1_WRITE_C) || defined(MBEDTLS_X509_USE_C)
     23          
     24          #include "mbedtls/asn1write.h"
     25          #include "mbedtls/error.h"
     26          
     27          #include <string.h>
     28          
     29          #include "mbedtls/platform.h"
     30          
     31          #if defined(MBEDTLS_ASN1_PARSE_C)
     32          #include "mbedtls/asn1.h"
     33          #endif
     34          

   \                                 In section .text, align 2, keep-with-next
     35          int mbedtls_asn1_write_len(unsigned char **p, const unsigned char *start, size_t len)
     36          {
   \                     mbedtls_asn1_write_len: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     37          #if SIZE_MAX > 0xFFFFFFFF
     38              if (len > 0xFFFFFFFF) {
     39                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
     40              }
     41          #endif
     42          
     43              int required = 1;
   \        0x4   0x2001             MOVS     R0,#+1
     44          
     45              if (len >= 0x80) {
   \        0x6   0x2A80             CMP      R2,#+128
   \        0x8   0xD303             BCC.N    ??mbedtls_asn1_write_len_0
     46                  for (size_t l = len; l != 0; l >>= 8) {
   \        0xA   0x4613             MOV      R3,R2
     47                      required++;
   \                     ??mbedtls_asn1_write_len_1: (+1)
   \        0xC   0x1C40             ADDS     R0,R0,#+1
     48                  }
   \        0xE   0x0A1B             LSRS     R3,R3,#+8
   \       0x10   0xD1FC             BNE.N    ??mbedtls_asn1_write_len_1
     49              }
     50          
     51              if (required > (*p - start)) {
   \                     ??mbedtls_asn1_write_len_0: (+1)
   \       0x12   0x6823             LDR      R3,[R4, #+0]
   \       0x14   0x1A59             SUBS     R1,R3,R1
   \       0x16   0x4281             CMP      R1,R0
   \       0x18   0xDA00             BGE.N    ??mbedtls_asn1_write_len_2
     52                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \       0x1A   0x....             B.N      ?Subroutine0
     53              }
     54          
     55              do {
     56                  *--(*p) = MBEDTLS_BYTE_0(len);
   \                     ??mbedtls_asn1_write_len_2: (+1)
   \       0x1C   0xF803 0x2D01      STRB     R2,[R3, #-1]!
     57                  len >>= 8;
   \       0x20   0x0A12             LSRS     R2,R2,#+8
     58              } while (len);
   \       0x22   0xD1FB             BNE.N    ??mbedtls_asn1_write_len_2
     59          
     60              if (required > 1) {
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xBFC4             ITT      GT
   \       0x28   0xF100 0x017F      ADDGT    R1,R0,#+127
   \       0x2C   0xF803 0x1D01      STRBGT   R1,[R3, #-1]!
     61                  *--(*p) = (unsigned char) (0x80 + required - 1);
   \       0x30   0x6023             STR      R3,[R4, #+0]
     62              }
     63          
     64              return required;
   \       0x32   0xBD10             POP      {R4,PC}
     65          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x006B      MVN      R0,#+107
   \        0x4   0xBD10             POP      {R4,PC}
     66          

   \                                 In section .text, align 2, keep-with-next
     67          int mbedtls_asn1_write_tag(unsigned char **p, const unsigned char *start, unsigned char tag)
     68          {
     69              if (*p - start < 1) {
   \                     mbedtls_asn1_write_tag: (+1)
   \        0x0   0x6803             LDR      R3,[R0, #+0]
   \        0x2   0x1A59             SUBS     R1,R3,R1
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xDA02             BGE.N    ??mbedtls_asn1_write_tag_0
     70                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \        0x8   0xF06F 0x006B      MVN      R0,#+107
   \        0xC   0x4770             BX       LR
     71              }
     72          
     73              *--(*p) = tag;
   \                     ??mbedtls_asn1_write_tag_0: (+1)
   \        0xE   0x1E59             SUBS     R1,R3,#+1
   \       0x10   0x700A             STRB     R2,[R1, #+0]
     74          
     75              return 1;
   \       0x12   0x6001             STR      R1,[R0, #+0]
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x4770             BX       LR
     76          }
     77          #endif /* MBEDTLS_ASN1_WRITE_C || MBEDTLS_X509_USE_C */
     78          
     79          #if defined(MBEDTLS_ASN1_WRITE_C)

   \                                 In section .text, align 2, keep-with-next
     80          static int mbedtls_asn1_write_len_and_tag(unsigned char **p,
     81                                                    const unsigned char *start,
     82                                                    size_t len,
     83                                                    unsigned char tag)
     84          {
   \                     mbedtls_asn1_write_len_and_tag: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
     85              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     86          
     87              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(p, start, len));
   \        0xC   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0x10   0x0007             MOVS     R7,R0
   \       0x12   0xD408             BMI.N    ??mbedtls_asn1_write_len_and_tag_0
     88              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(p, start, tag));
   \       0x14   0x4632             MOV      R2,R6
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xBF5C             ITT      PL
   \       0x22   0x197D             ADDPL    R5,R7,R5
   \       0x24   0x1940             ADDPL    R0,R0,R5
     89          
     90              return (int) len;
   \                     ??mbedtls_asn1_write_len_and_tag_0: (+1)
   \       0x26   0xE8BD 0x81F0      POP      {R4-R8,PC}
     91          }
     92          

   \                                 In section .text, align 2, keep-with-next
     93          int mbedtls_asn1_write_raw_buffer(unsigned char **p, const unsigned char *start,
     94                                            const unsigned char *buf, size_t size)
     95          {
   \                     mbedtls_asn1_write_raw_buffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4614             MOV      R4,R2
     96              size_t len = 0;
     97          
     98              if (*p < start || (size_t) (*p - start) < size) {
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x461D             MOV      R5,R3
   \        0x8   0x428A             CMP      R2,R1
   \        0xA   0xBF24             ITT      CS
   \        0xC   0x1A51             SUBCS    R1,R2,R1
   \        0xE   0x42A9             CMPCS    R1,R5
   \       0x10   0xD202             BCS.N    ??mbedtls_asn1_write_raw_buffer_0
     99                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \       0x12   0xF06F 0x006B      MVN      R0,#+107
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}
    100              }
    101          
    102              len = size;
    103              (*p) -= len;
    104              memcpy(*p, buf, len);
   \                     ??mbedtls_asn1_write_raw_buffer_0: (+1)
   \       0x18   0x4269             RSBS     R1,R5,#+0
   \       0x1A   0x1853             ADDS     R3,R2,R1
   \       0x1C   0x6003             STR      R3,[R0, #+0]
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x4621             MOV      R1,R4
   \       0x22   0x4618             MOV      R0,R3
   \       0x24   0x.... 0x....      BL       __aeabi_memcpy
    105          
    106              return (int) len;
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
    107          }
    108          
    109          #if defined(MBEDTLS_BIGNUM_C)

   \                                 In section .text, align 2, keep-with-next
    110          int mbedtls_asn1_write_mpi(unsigned char **p, const unsigned char *start, const mbedtls_mpi *X)
    111          {
   \                     mbedtls_asn1_write_mpi: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4617             MOV      R7,R2
   \        0x6   0x460D             MOV      R5,R1
    112              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    113              size_t len = 0;
    114          
    115              // Write the MPI
    116              //
    117              len = mbedtls_mpi_size(X);
   \        0x8   0x4638             MOV      R0,R7
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_size
   \        0xE   0x0004             MOVS     R4,R0
    118          
    119              /* DER represents 0 with a sign bit (0=nonnegative) and 7 value bits, not
    120               * as 0 digits. We need to end up with 020100, not with 0200. */
    121              if (len == 0) {
   \       0x10   0xBF08             IT       EQ
   \       0x12   0x2401             MOVEQ    R4,#+1
    122                  len = 1;
    123              }
    124          
    125              if (*p < start || (size_t) (*p - start) < len) {
   \       0x14   0x6830             LDR      R0,[R6, #+0]
   \       0x16   0x42A8             CMP      R0,R5
   \       0x18   0xBF24             ITT      CS
   \       0x1A   0x1B41             SUBCS    R1,R0,R5
   \       0x1C   0x42A1             CMPCS    R1,R4
   \       0x1E   0xD312             BCC.N    ??mbedtls_asn1_write_mpi_0
    126                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
    127              }
    128          
    129              (*p) -= len;
    130              MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(X, *p, len));
   \       0x20   0x4261             RSBS     R1,R4,#+0
   \       0x22   0x4401             ADD      R1,R0,R1
   \       0x24   0x6031             STR      R1,[R6, #+0]
   \       0x26   0x4622             MOV      R2,R4
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x2E   0xB9B0             CBNZ.N   R0,??mbedtls_asn1_write_mpi_1
    131          
    132              // DER format assumes 2s complement for numbers, so the leftmost bit
    133              // should be 0 for positive numbers and 1 for negative numbers.
    134              //
    135              if (X->s == 1 && **p & 0x80) {
   \       0x30   0xF9B7 0x0004      LDRSH    R0,[R7, #+4]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD10C             BNE.N    ??mbedtls_asn1_write_mpi_2
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0x7802             LDRB     R2,[R0, #+0]
   \       0x3C   0x0611             LSLS     R1,R2,#+24
   \       0x3E   0xD508             BPL.N    ??mbedtls_asn1_write_mpi_2
    136                  if (*p - start < 1) {
   \       0x40   0x1B47             SUBS     R7,R0,R5
   \       0x42   0x2F00             CMP      R7,#+0
   \       0x44   0xDC00             BGT.N    ??mbedtls_asn1_write_mpi_3
    137                      return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \                     ??mbedtls_asn1_write_mpi_0: (+1)
   \       0x46   0x....             B.N      ?Subroutine1
    138                  }
    139          
    140                  *--(*p) = 0x00;
   \                     ??mbedtls_asn1_write_mpi_3: (+1)
   \       0x48   0x1E41             SUBS     R1,R0,#+1
   \       0x4A   0x6031             STR      R1,[R6, #+0]
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x7008             STRB     R0,[R1, #+0]
    141                  len += 1;
   \       0x50   0x1C64             ADDS     R4,R4,#+1
    142              }
    143          
    144              ret = mbedtls_asn1_write_len_and_tag(p, start, len, MBEDTLS_ASN1_INTEGER);
   \                     ??mbedtls_asn1_write_mpi_2: (+1)
   \       0x52   0x4622             MOV      R2,R4
   \       0x54   0x4629             MOV      R1,R5
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0xB001             ADD      SP,SP,#+4
   \       0x5A   0x2302             MOVS     R3,#+2
   \       0x5C   0x....             B.N      ?Subroutine2
    145          
    146          cleanup:
    147              return ret;
   \                     ??mbedtls_asn1_write_mpi_1: (+1)
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}
    148          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF06F 0x006B      MVN      R0,#+107
   \        0x4   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \        0x4   0x....             B.N      mbedtls_asn1_write_len_and_tag
    149          #endif /* MBEDTLS_BIGNUM_C */
    150          

   \                                 In section .text, align 2, keep-with-next
    151          int mbedtls_asn1_write_null(unsigned char **p, const unsigned char *start)
    152          {
    153              // Write NULL
    154              //
    155              return mbedtls_asn1_write_len_and_tag(p, start, 0, MBEDTLS_ASN1_NULL);
   \                     mbedtls_asn1_write_null: (+1)
   \        0x0   0x2305             MOVS     R3,#+5
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x....             B.N      mbedtls_asn1_write_len_and_tag
    156          }
    157          

   \                                 In section .text, align 2, keep-with-next
    158          int mbedtls_asn1_write_oid(unsigned char **p, const unsigned char *start,
    159                                     const char *oid, size_t oid_len)
    160          {
   \                     mbedtls_asn1_write_oid: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine6
    161              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    162              size_t len = 0;
    163          
    164              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_raw_buffer(p, start,
    165                                                                      (const unsigned char *) oid, oid_len));
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0x6   0x0002             MOVS     R2,R0
   \        0x8   0xD404             BMI.N    ??mbedtls_asn1_write_oid_0
    166              return mbedtls_asn1_write_len_and_tag(p, start, len, MBEDTLS_ASN1_OID);
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x2306             MOVS     R3,#+6
   \       0x12   0x....             B.N      ?Subroutine3
   \                     ??mbedtls_asn1_write_oid_0: (+1)
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
    167          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x....             B.N      mbedtls_asn1_write_raw_buffer

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xE8BD 0x4030      POP      {R4,R5,LR}
   \        0x4   0x....             B.N      mbedtls_asn1_write_len_and_tag
    168          

   \                                 In section .text, align 2, keep-with-next
    169          int mbedtls_asn1_write_algorithm_identifier(unsigned char **p, const unsigned char *start,
    170                                                      const char *oid, size_t oid_len,
    171                                                      size_t par_len)
    172          {
   \                     mbedtls_asn1_write_algorithm_identifier: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    173              return mbedtls_asn1_write_algorithm_identifier_ext(p, start, oid, oid_len, par_len, 1);
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
   \        0x4   0x2501             MOVS     R5,#+1
   \        0x6   0x9501             STR      R5,[SP, #+4]
   \        0x8   0x9400             STR      R4,[SP, #+0]
   \        0xA   0x.... 0x....      BL       mbedtls_asn1_write_algorithm_identifier_ext
   \        0xE   0xBD3E             POP      {R1-R5,PC}
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          int mbedtls_asn1_write_algorithm_identifier_ext(unsigned char **p, const unsigned char *start,
    177                                                          const char *oid, size_t oid_len,
    178                                                          size_t par_len, int has_par)
    179          {
   \                     mbedtls_asn1_write_algorithm_identifier_ext: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x9807             LDR      R0,[SP, #+28]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x461F             MOV      R7,R3
    180              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    181              size_t len = 0;
   \        0xE   0x2400             MOVS     R4,#+0
    182          
    183              if (has_par) {
   \       0x10   0xB130             CBZ.N    R0,??mbedtls_asn1_write_algorithm_identifier_ext_0
   \       0x12   0x9C06             LDR      R4,[SP, #+24]
    184                  if (par_len == 0) {
   \       0x14   0xB924             CBNZ.N   R4,??mbedtls_asn1_write_algorithm_identifier_ext_0
    185                      MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_null(p, start));
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       mbedtls_asn1_write_null
   \       0x1C   0x0004             MOVS     R4,R0
   \       0x1E   0xD40E             BMI.N    ??mbedtls_asn1_write_algorithm_identifier_ext_1
    186                  } else {
    187                      len += par_len;
    188                  }
    189              }
    190          
    191              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_oid(p, start, oid, oid_len));
   \                     ??mbedtls_asn1_write_algorithm_identifier_ext_0: (+1)
   \       0x20   0x463B             MOV      R3,R7
   \       0x22   0x4642             MOV      R2,R8
   \       0x24   0x4631             MOV      R1,R6
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       mbedtls_asn1_write_oid
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD406             BMI.N    ??mbedtls_asn1_write_algorithm_identifier_ext_1
    192          
    193              return mbedtls_asn1_write_len_and_tag(p, start, len,
    194                                                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
   \       0x30   0x1902             ADDS     R2,R0,R4
   \       0x32   0x4631             MOV      R1,R6
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x2330             MOVS     R3,#+48
   \       0x38   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x3C   0x....             B.N      mbedtls_asn1_write_len_and_tag
   \                     ??mbedtls_asn1_write_algorithm_identifier_ext_1: (+1)
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    195          }
    196          

   \                                 In section .text, align 2, keep-with-next
    197          int mbedtls_asn1_write_bool(unsigned char **p, const unsigned char *start, int boolean)
    198          {
   \                     mbedtls_asn1_write_bool: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    199              size_t len = 0;
    200          
    201              if (*p - start < 1) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0x1A63             SUBS     R3,R4,R1
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xDC00             BGT.N    ??mbedtls_asn1_write_bool_0
    202                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \        0xA   0x....             B.N      ?Subroutine0
    203              }
    204          
    205              *--(*p) = (boolean) ? 255 : 0;
   \                     ??mbedtls_asn1_write_bool_0: (+1)
   \        0xC   0x1E63             SUBS     R3,R4,#+1
   \        0xE   0x6003             STR      R3,[R0, #+0]
   \       0x10   0xB102             CBZ.N    R2,??mbedtls_asn1_write_bool_1
   \       0x12   0x22FF             MOVS     R2,#+255
   \                     ??mbedtls_asn1_write_bool_1: (+1)
   \       0x14   0x701A             STRB     R2,[R3, #+0]
    206              len++;
    207          
    208              return mbedtls_asn1_write_len_and_tag(p, start, len, MBEDTLS_ASN1_BOOLEAN);
   \       0x16   0x2301             MOVS     R3,#+1
   \       0x18   0x2201             MOVS     R2,#+1
   \       0x1A   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1E   0x....             B.N      mbedtls_asn1_write_len_and_tag
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          static int asn1_write_tagged_int(unsigned char **p, const unsigned char *start, int val, int tag)
    212          {
   \                     asn1_write_tagged_int: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    213              size_t len = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x6806             LDR      R6,[R0, #+0]
    214          
    215              do {
    216                  if (*p - start < 1) {
   \                     ??asn1_write_tagged_int_0: (+1)
   \        0x6   0x1A77             SUBS     R7,R6,R1
   \        0x8   0x2F01             CMP      R7,#+1
   \        0xA   0xDB15             BLT.N    ??asn1_write_tagged_int_1
    217                      return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
    218                  }
    219                  len += 1;
    220                  *--(*p) = val & 0xff;
   \        0xC   0xF806 0x2D01      STRB     R2,[R6, #-1]!
   \       0x10   0x1C64             ADDS     R4,R4,#+1
    221                  val >>= 8;
   \       0x12   0x1212             ASRS     R2,R2,#+8
    222              } while (val > 0);
   \       0x14   0x2A01             CMP      R2,#+1
   \       0x16   0xDAF6             BGE.N    ??asn1_write_tagged_int_0
    223          
    224              if (**p & 0x80) {
   \       0x18   0x6006             STR      R6,[R0, #+0]
   \       0x1A   0x7837             LDRB     R7,[R6, #+0]
   \       0x1C   0x063A             LSLS     R2,R7,#+24
   \       0x1E   0xD506             BPL.N    ??asn1_write_tagged_int_2
    225                  if (*p - start < 1) {
   \       0x20   0x1A75             SUBS     R5,R6,R1
   \       0x22   0x2D01             CMP      R5,#+1
   \       0x24   0xDB08             BLT.N    ??asn1_write_tagged_int_1
    226                      return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
    227                  }
    228                  *--(*p) = 0x00;
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0xF806 0x2D01      STRB     R2,[R6, #-1]!
    229                  len += 1;
   \       0x2C   0x1C64             ADDS     R4,R4,#+1
    230              }
    231          
    232              return mbedtls_asn1_write_len_and_tag(p, start, len, tag);
   \                     ??asn1_write_tagged_int_2: (+1)
   \       0x2E   0x6006             STR      R6,[R0, #+0]
   \       0x30   0x4622             MOV      R2,R4
   \       0x32   0xB001             ADD      SP,SP,#+4
   \       0x34   0xB2DB             UXTB     R3,R3
   \       0x36   0x....             B.N      ?Subroutine2
   \                     ??asn1_write_tagged_int_1: (+1)
   \       0x38   0x6006             STR      R6,[R0, #+0]
   \       0x3A                      REQUIRE ?Subroutine1
   \       0x3A                      ;; // Fall through to label ?Subroutine1
    233          }
    234          

   \                                 In section .text, align 2, keep-with-next
    235          int mbedtls_asn1_write_int(unsigned char **p, const unsigned char *start, int val)
    236          {
    237              return asn1_write_tagged_int(p, start, val, MBEDTLS_ASN1_INTEGER);
   \                     mbedtls_asn1_write_int: (+1)
   \        0x0   0x2302             MOVS     R3,#+2
   \        0x2   0x....             B.N      asn1_write_tagged_int
    238          }
    239          

   \                                 In section .text, align 2, keep-with-next
    240          int mbedtls_asn1_write_enum(unsigned char **p, const unsigned char *start, int val)
    241          {
    242              return asn1_write_tagged_int(p, start, val, MBEDTLS_ASN1_ENUMERATED);
   \                     mbedtls_asn1_write_enum: (+1)
   \        0x0   0x230A             MOVS     R3,#+10
   \        0x2   0x....             B.N      asn1_write_tagged_int
    243          }
    244          

   \                                 In section .text, align 2, keep-with-next
    245          int mbedtls_asn1_write_tagged_string(unsigned char **p, const unsigned char *start, int tag,
    246                                               const char *text, size_t text_len)
    247          {
   \                     mbedtls_asn1_write_tagged_string: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x461A             MOV      R2,R3
   \        0x6   0x9B04             LDR      R3,[SP, #+16]
   \        0x8   0x4606             MOV      R6,R0
   \        0xA   0x.... 0x....      BL       ??Subroutine6_0
    248              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    249              size_t len = 0;
    250          
    251              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_raw_buffer(p, start,
    252                                                                      (const unsigned char *) text,
    253                                                                      text_len));
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD406             BMI.N    ??mbedtls_asn1_write_tagged_string_0
    254          
    255              return mbedtls_asn1_write_len_and_tag(p, start, len, tag);
   \       0x12   0x4602             MOV      R2,R0
   \       0x14   0xB2EB             UXTB     R3,R5
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x1E   0x....             B.N      mbedtls_asn1_write_len_and_tag
   \                     ??mbedtls_asn1_write_tagged_string_0: (+1)
   \       0x20   0xBD70             POP      {R4-R6,PC}
    256          }
    257          

   \                                 In section .text, align 2, keep-with-next
    258          int mbedtls_asn1_write_utf8_string(unsigned char **p, const unsigned char *start,
    259                                             const char *text, size_t text_len)
    260          {
   \                     mbedtls_asn1_write_utf8_string: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    261              return mbedtls_asn1_write_tagged_string(p, start, MBEDTLS_ASN1_UTF8_STRING, text, text_len);
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x220C             MOVS     R2,#+12
   \        0x8   0x....             B.N      ?Subroutine4
    262          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x.... 0x....      BL       mbedtls_asn1_write_tagged_string
   \        0x4   0xBD02             POP      {R1,PC}
    263          

   \                                 In section .text, align 2, keep-with-next
    264          int mbedtls_asn1_write_printable_string(unsigned char **p, const unsigned char *start,
    265                                                  const char *text, size_t text_len)
    266          {
   \                     mbedtls_asn1_write_printable_string: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    267              return mbedtls_asn1_write_tagged_string(p, start, MBEDTLS_ASN1_PRINTABLE_STRING, text,
    268                                                      text_len);
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x2213             MOVS     R2,#+19
   \        0x8                      REQUIRE ?Subroutine4
   \        0x8                      ;; // Fall through to label ?Subroutine4
    269          }
    270          

   \                                 In section .text, align 2, keep-with-next
    271          int mbedtls_asn1_write_ia5_string(unsigned char **p, const unsigned char *start,
    272                                            const char *text, size_t text_len)
    273          {
   \                     mbedtls_asn1_write_ia5_string: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    274              return mbedtls_asn1_write_tagged_string(p, start, MBEDTLS_ASN1_IA5_STRING, text, text_len);
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x2216             MOVS     R2,#+22
   \        0x8   0x....             B.N      ?Subroutine4
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          int mbedtls_asn1_write_named_bitstring(unsigned char **p,
    278                                                 const unsigned char *start,
    279                                                 const unsigned char *buf,
    280                                                 size_t bits)
    281          {
   \                     mbedtls_asn1_write_named_bitstring: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    282              size_t unused_bits, byte_len;
    283              const unsigned char *cur_byte;
    284              unsigned char cur_byte_shifted;
    285              unsigned char bit;
    286          
    287              byte_len = (bits + 7) / 8;
   \        0x2   0x1DDE             ADDS     R6,R3,#+7
   \        0x4   0x08F6             LSRS     R6,R6,#+3
    288              unused_bits = (byte_len * 8) - bits;
    289          
    290              /*
    291               * Named bitstrings require that trailing 0s are excluded in the encoding
    292               * of the bitstring. Trailing 0s are considered part of the 'unused' bits
    293               * when encoding this value in the first content octet
    294               */
    295              if (bits != 0) {
   \        0x6   0xB18B             CBZ.N    R3,??mbedtls_asn1_write_named_bitstring_0
    296                  cur_byte = buf + byte_len - 1;
   \        0x8   0x1994             ADDS     R4,R2,R6
    297                  cur_byte_shifted = *cur_byte >> unused_bits;
   \        0xA   0xF814 0x5D01      LDRB     R5,[R4, #-1]!
   \        0xE   0xEBC3 0x06C6      RSB      R6,R3,R6, LSL #+3
   \       0x12   0x40F5             LSRS     R5,R5,R6
   \       0x14   0xE004             B.N      ??mbedtls_asn1_write_named_bitstring_1
    298          
    299                  for (;;) {
    300                      bit = cur_byte_shifted & 0x1;
    301                      cur_byte_shifted >>= 1;
    302          
    303                      if (bit != 0) {
    304                          break;
    305                      }
    306          
    307                      bits--;
    308                      if (bits == 0) {
    309                          break;
    310                      }
    311          
    312                      if (bits % 8 == 0) {
   \                     ??mbedtls_asn1_write_named_bitstring_2: (+1)
   \       0x16   0xF013 0x0F07      TST      R3,#0x7
   \       0x1A   0xBF08             IT       EQ
   \       0x1C   0xF814 0x5D01      LDRBEQ   R5,[R4, #-1]!
    313                          cur_byte_shifted = *--cur_byte;
   \                     ??mbedtls_asn1_write_named_bitstring_1: (+1)
   \       0x20   0x462E             MOV      R6,R5
   \       0x22   0x086D             LSRS     R5,R5,#+1
   \       0x24   0x07F6             LSLS     R6,R6,#+31
   \       0x26   0xD401             BMI.N    ??mbedtls_asn1_write_named_bitstring_0
   \       0x28   0x1E5B             SUBS     R3,R3,#+1
   \       0x2A   0xD1F4             BNE.N    ??mbedtls_asn1_write_named_bitstring_2
    314                      }
    315                  }
    316              }
    317          
    318              return mbedtls_asn1_write_bitstring(p, start, buf, bits);
   \                     ??mbedtls_asn1_write_named_bitstring_0: (+1)
   \       0x2C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x30                      REQUIRE mbedtls_asn1_write_bitstring
   \       0x30                      ;; // Fall through to label mbedtls_asn1_write_bitstring
    319          }
    320          

   \                                 In section .text, align 2, keep-with-next
    321          int mbedtls_asn1_write_bitstring(unsigned char **p, const unsigned char *start,
    322                                           const unsigned char *buf, size_t bits)
    323          {
   \                     mbedtls_asn1_write_bitstring: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4611             MOV      R1,R2
   \        0x8   0x461D             MOV      R5,R3
    324              size_t len = 0;
    325              size_t unused_bits, byte_len;
    326          
    327              byte_len = (bits + 7) / 8;
    328              unused_bits = (byte_len * 8) - bits;
    329          
    330              if (*p < start || (size_t) (*p - start) < byte_len + 1) {
   \        0xA   0x6838             LDR      R0,[R7, #+0]
   \        0xC   0x1DEA             ADDS     R2,R5,#+7
   \        0xE   0x08D2             LSRS     R2,R2,#+3
   \       0x10   0xEBC5 0x05C2      RSB      R5,R5,R2, LSL #+3
   \       0x14   0x42A0             CMP      R0,R4
   \       0x16   0xBF22             ITTT     CS
   \       0x18   0x1C56             ADDCS    R6,R2,#+1
   \       0x1A   0x1B03             SUBCS    R3,R0,R4
   \       0x1C   0x42B3             CMPCS    R3,R6
   \       0x1E   0xD200             BCS.N    ??mbedtls_asn1_write_bitstring_0
    331                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \       0x20   0x....             B.N      ?Subroutine1
    332              }
    333          
    334              len = byte_len + 1;
    335          
    336              /* Write the bitstring. Ensure the unused bits are zeroed */
    337              if (byte_len > 0) {
   \                     ??mbedtls_asn1_write_bitstring_0: (+1)
   \       0x22   0xB18A             CBZ.N    R2,??mbedtls_asn1_write_bitstring_1
    338                  byte_len--;
    339                  *--(*p) = buf[byte_len] & ~((0x1 << unused_bits) - 1);
   \       0x24   0x1E43             SUBS     R3,R0,#+1
   \       0x26   0x1E52             SUBS     R2,R2,#+1
   \       0x28   0x603B             STR      R3,[R7, #+0]
   \       0x2A   0xF811 0xC002      LDRB     R12,[R1, R2]
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xFA00 0xFE05      LSL      LR,R0,R5
   \       0x34   0xF1AE 0x0001      SUB      R0,LR,#+1
   \       0x38   0xEA2C 0x0000      BIC      R0,R12,R0
   \       0x3C   0x7018             STRB     R0,[R3, #+0]
    340                  (*p) -= byte_len;
    341                  memcpy(*p, buf, byte_len);
   \       0x3E   0x4250             RSBS     R0,R2,#+0
   \       0x40   0x4418             ADD      R0,R3,R0
   \       0x42   0x6038             STR      R0,[R7, #+0]
   \       0x44   0x.... 0x....      BL       __aeabi_memcpy
    342              }
    343          
    344              /* Write unused bits */
    345              *--(*p) = (unsigned char) unused_bits;
   \                     ??mbedtls_asn1_write_bitstring_1: (+1)
   \       0x48   0x683B             LDR      R3,[R7, #+0]
    346          
    347              return mbedtls_asn1_write_len_and_tag(p, start, len, MBEDTLS_ASN1_BIT_STRING);
   \       0x4A   0x4632             MOV      R2,R6
   \       0x4C   0x4621             MOV      R1,R4
   \       0x4E   0x1E58             SUBS     R0,R3,#+1
   \       0x50   0x7005             STRB     R5,[R0, #+0]
   \       0x52   0x6038             STR      R0,[R7, #+0]
   \       0x54   0x4638             MOV      R0,R7
   \       0x56   0xB001             ADD      SP,SP,#+4
   \       0x58   0x2303             MOVS     R3,#+3
   \       0x5A                      REQUIRE ?Subroutine2
   \       0x5A                      ;; // Fall through to label ?Subroutine2
    348          }
    349          

   \                                 In section .text, align 2, keep-with-next
    350          int mbedtls_asn1_write_octet_string(unsigned char **p, const unsigned char *start,
    351                                              const unsigned char *buf, size_t size)
    352          {
   \                     mbedtls_asn1_write_octet_string: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine6
    353              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    354              size_t len = 0;
    355          
    356              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_raw_buffer(p, start, buf, size));
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x6   0x0002             MOVS     R2,R0
   \        0x8   0xD404             BMI.N    ??mbedtls_asn1_write_octet_string_0
    357          
    358              return mbedtls_asn1_write_len_and_tag(p, start, len, MBEDTLS_ASN1_OCTET_STRING);
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x2304             MOVS     R3,#+4
   \       0x12   0x....             B.N      ?Subroutine3
   \                     ??mbedtls_asn1_write_octet_string_0: (+1)
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
    359          }
    360          
    361          
    362          #if !defined(MBEDTLS_ASN1_PARSE_C)
    363          /* This is a copy of the ASN.1 parsing function mbedtls_asn1_find_named_data(),
    364           * which is replicated to avoid a dependency ASN1_WRITE_C on ASN1_PARSE_C. */
    365          static mbedtls_asn1_named_data *asn1_find_named_data(
    366              mbedtls_asn1_named_data *list,
    367              const char *oid, size_t len)
    368          {
    369              while (list != NULL) {
    370                  if (list->oid.len == len &&
    371                      memcmp(list->oid.p, oid, len) == 0) {
    372                      break;
    373                  }
    374          
    375                  list = list->next;
    376              }
    377          
    378              return list;
    379          }
    380          #else
    381          #define asn1_find_named_data(list, oid, len) \
    382              ((mbedtls_asn1_named_data *) mbedtls_asn1_find_named_data(list, oid, len))
    383          #endif
    384          

   \                                 In section .text, align 2, keep-with-next
    385          mbedtls_asn1_named_data *mbedtls_asn1_store_named_data(
    386              mbedtls_asn1_named_data **head,
    387              const char *oid, size_t oid_len,
    388              const unsigned char *val,
    389              size_t val_len)
    390          {
   \                     mbedtls_asn1_store_named_data: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
    391              mbedtls_asn1_named_data *cur;
    392          
    393              if ((cur = asn1_find_named_data(*head, oid, oid_len)) == NULL) {
   \        0x6   0x6838             LDR      R0,[R7, #+0]
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0x9C08             LDR      R4,[SP, #+32]
   \       0x10   0x.... 0x....      BL       mbedtls_asn1_find_named_data
   \       0x14   0x0005             MOVS     R5,R0
   \       0x16   0xD120             BNE.N    ??mbedtls_asn1_store_named_data_0
    394                  // Add new entry if not present yet based on OID
    395                  //
    396                  cur = (mbedtls_asn1_named_data *) mbedtls_calloc(1,
    397                                                                   sizeof(mbedtls_asn1_named_data));
   \       0x18   0x2120             MOVS     R1,#+32
   \       0x1A   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x1E   0x0005             MOVS     R5,R0
    398                  if (cur == NULL) {
   \       0x20   0xD029             BEQ.N    ??mbedtls_asn1_store_named_data_1
    399                      return NULL;
    400                  }
    401          
    402                  cur->oid.len = oid_len;
   \       0x22   0xF8C5 0x8004      STR      R8,[R5, #+4]
    403                  cur->oid.p = mbedtls_calloc(1, oid_len);
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x2C   0x60A8             STR      R0,[R5, #+8]
    404                  if (cur->oid.p == NULL) {
   \       0x2E   0xB160             CBZ.N    R0,??mbedtls_asn1_store_named_data_2
    405                      mbedtls_free(cur);
    406                      return NULL;
    407                  }
    408          
    409                  memcpy(cur->oid.p, oid, oid_len);
   \       0x30   0x4642             MOV      R2,R8
   \       0x32   0x4649             MOV      R1,R9
   \       0x34   0x.... 0x....      BL       __aeabi_memcpy
    410          
    411                  cur->val.len = val_len;
   \       0x38   0x612C             STR      R4,[R5, #+16]
    412                  if (val_len != 0) {
   \       0x3A   0xB154             CBZ.N    R4,??mbedtls_asn1_store_named_data_3
    413                      cur->val.p = mbedtls_calloc(1, val_len);
   \       0x3C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x40   0x6168             STR      R0,[R5, #+20]
    414                      if (cur->val.p == NULL) {
   \       0x42   0xB930             CBNZ.N   R0,??mbedtls_asn1_store_named_data_3
    415                          mbedtls_free(cur->oid.p);
   \       0x44   0x68A8             LDR      R0,[R5, #+8]
   \       0x46   0x.... 0x....      BL       sl_free
    416                          mbedtls_free(cur);
   \                     ??mbedtls_asn1_store_named_data_2: (+1)
   \       0x4A   0x4628             MOV      R0,R5
   \       0x4C   0x.... 0x....      BL       sl_free
   \       0x50   0xE011             B.N      ??mbedtls_asn1_store_named_data_1
    417                          return NULL;
    418                      }
    419                  }
    420          
    421                  cur->next = *head;
   \                     ??mbedtls_asn1_store_named_data_3: (+1)
   \       0x52   0x6838             LDR      R0,[R7, #+0]
   \       0x54   0x61A8             STR      R0,[R5, #+24]
    422                  *head = cur;
   \       0x56   0x603D             STR      R5,[R7, #+0]
   \       0x58   0xE014             B.N      ??mbedtls_asn1_store_named_data_4
    423              } else if (val_len == 0) {
   \                     ??mbedtls_asn1_store_named_data_0: (+1)
   \       0x5A   0xB92C             CBNZ.N   R4,??mbedtls_asn1_store_named_data_5
    424                  mbedtls_free(cur->val.p);
   \       0x5C   0x6968             LDR      R0,[R5, #+20]
   \       0x5E   0x.... 0x....      BL       sl_free
    425                  cur->val.p = NULL;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x6168             STR      R0,[R5, #+20]
   \       0x66   0xE016             B.N      ??mbedtls_asn1_store_named_data_6
    426              } else if (cur->val.len != val_len) {
   \                     ??mbedtls_asn1_store_named_data_5: (+1)
   \       0x68   0x6928             LDR      R0,[R5, #+16]
   \       0x6A   0x42A0             CMP      R0,R4
   \       0x6C   0xD00A             BEQ.N    ??mbedtls_asn1_store_named_data_4
    427                  /*
    428                   * Enlarge existing value buffer if needed
    429                   * Preserve old data until the allocation succeeded, to leave list in
    430                   * a consistent state in case allocation fails.
    431                   */
    432                  void *p = mbedtls_calloc(1, val_len);
   \       0x6E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x72   0x0007             MOVS     R7,R0
    433                  if (p == NULL) {
   \       0x74   0xD101             BNE.N    ??mbedtls_asn1_store_named_data_7
    434                      return NULL;
   \                     ??mbedtls_asn1_store_named_data_1: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE00E             B.N      ??mbedtls_asn1_store_named_data_8
    435                  }
    436          
    437                  mbedtls_free(cur->val.p);
   \                     ??mbedtls_asn1_store_named_data_7: (+1)
   \       0x7A   0x6968             LDR      R0,[R5, #+20]
   \       0x7C   0x.... 0x....      BL       sl_free
    438                  cur->val.p = p;
   \       0x80   0x616F             STR      R7,[R5, #+20]
    439                  cur->val.len = val_len;
   \       0x82   0x612C             STR      R4,[R5, #+16]
    440              }
    441          
    442              if (val != NULL && val_len != 0) {
   \                     ??mbedtls_asn1_store_named_data_4: (+1)
   \       0x84   0x2E00             CMP      R6,#+0
   \       0x86   0xBF18             IT       NE
   \       0x88   0x2C00             CMPNE    R4,#+0
   \       0x8A   0xD004             BEQ.N    ??mbedtls_asn1_store_named_data_6
    443                  memcpy(cur->val.p, val, val_len);
   \       0x8C   0x6968             LDR      R0,[R5, #+20]
   \       0x8E   0x4622             MOV      R2,R4
   \       0x90   0x4631             MOV      R1,R6
   \       0x92   0x.... 0x....      BL       __aeabi_memcpy
    444              }
    445          
    446              return cur;
   \                     ??mbedtls_asn1_store_named_data_6: (+1)
   \       0x96   0x4628             MOV      R0,R5
   \                     ??mbedtls_asn1_store_named_data_8: (+1)
   \       0x98   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    447          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4621             MOV      R1,R4
   \                     ??Subroutine5_0: (+1)
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x.... 0x....      B.W      sl_calloc
    448          #endif /* MBEDTLS_ASN1_WRITE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   asn1_write_tagged_int
         0   -> mbedtls_asn1_write_len_and_tag
      32   mbedtls_asn1_store_named_data
        32   -> __aeabi_memcpy
        32   -> mbedtls_asn1_find_named_data
        32   -> sl_calloc
        32   -> sl_free
      24   mbedtls_asn1_write_algorithm_identifier
        24   -> mbedtls_asn1_write_algorithm_identifier_ext
      24   mbedtls_asn1_write_algorithm_identifier_ext
         0   -> mbedtls_asn1_write_len_and_tag
        24   -> mbedtls_asn1_write_null
        24   -> mbedtls_asn1_write_oid
      24   mbedtls_asn1_write_bitstring
        24   -> __aeabi_memcpy
         0   -> mbedtls_asn1_write_len_and_tag
       8   mbedtls_asn1_write_bool
         0   -> mbedtls_asn1_write_len_and_tag
       0   mbedtls_asn1_write_enum
         0   -> asn1_write_tagged_int
       8   mbedtls_asn1_write_ia5_string
         8   -> mbedtls_asn1_write_tagged_string
       0   mbedtls_asn1_write_int
         0   -> asn1_write_tagged_int
       8   mbedtls_asn1_write_len
      24   mbedtls_asn1_write_len_and_tag
        24   -> mbedtls_asn1_write_len
        24   -> mbedtls_asn1_write_tag
      24   mbedtls_asn1_write_mpi
         0   -> mbedtls_asn1_write_len_and_tag
        24   -> mbedtls_mpi_size
        24   -> mbedtls_mpi_write_binary
      16   mbedtls_asn1_write_named_bitstring
         0   -> mbedtls_asn1_write_bitstring
       0   mbedtls_asn1_write_null
         0   -> mbedtls_asn1_write_len_and_tag
      16   mbedtls_asn1_write_octet_string
         0   -> mbedtls_asn1_write_len_and_tag
        16   -> mbedtls_asn1_write_raw_buffer
      16   mbedtls_asn1_write_oid
         0   -> mbedtls_asn1_write_len_and_tag
        16   -> mbedtls_asn1_write_raw_buffer
       8   mbedtls_asn1_write_printable_string
         8   -> mbedtls_asn1_write_tagged_string
      16   mbedtls_asn1_write_raw_buffer
        16   -> __aeabi_memcpy
       0   mbedtls_asn1_write_tag
      16   mbedtls_asn1_write_tagged_string
         0   -> mbedtls_asn1_write_len_and_tag
        16   -> mbedtls_asn1_write_raw_buffer
       8   mbedtls_asn1_write_utf8_string
         8   -> mbedtls_asn1_write_tagged_string


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       8  ?Subroutine5
       6  ?Subroutine6
      58  asn1_write_tagged_int
     156  mbedtls_asn1_store_named_data
      16  mbedtls_asn1_write_algorithm_identifier
      66  mbedtls_asn1_write_algorithm_identifier_ext
      90  mbedtls_asn1_write_bitstring
      32  mbedtls_asn1_write_bool
       4  mbedtls_asn1_write_enum
      10  mbedtls_asn1_write_ia5_string
       4  mbedtls_asn1_write_int
      52  mbedtls_asn1_write_len
      42  mbedtls_asn1_write_len_and_tag
      96  mbedtls_asn1_write_mpi
      48  mbedtls_asn1_write_named_bitstring
       6  mbedtls_asn1_write_null
      22  mbedtls_asn1_write_octet_string
      22  mbedtls_asn1_write_oid
       8  mbedtls_asn1_write_printable_string
      44  mbedtls_asn1_write_raw_buffer
      24  mbedtls_asn1_write_tag
      34  mbedtls_asn1_write_tagged_string
      10  mbedtls_asn1_write_utf8_string

 
 888 bytes in section .text
 
 888 bytes of CODE memory

Errors: none
Warnings: none
