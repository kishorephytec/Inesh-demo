###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:34
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_aead.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_aead.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_aead.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_aead.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\psa_crypto_aead.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_aead.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_aead.c
      1          /*
      2           *  PSA AEAD entry points
      3           */
      4          /*
      5           *  Copyright The Mbed TLS Contributors
      6           *  SPDX-License-Identifier: Apache-2.0
      7           *
      8           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      9           *  not use this file except in compliance with the License.
     10           *  You may obtain a copy of the License at
     11           *
     12           *  http://www.apache.org/licenses/LICENSE-2.0
     13           *
     14           *  Unless required by applicable law or agreed to in writing, software
     15           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     16           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     17           *  See the License for the specific language governing permissions and
     18           *  limitations under the License.
     19           */
     20          
     21          #include "common.h"
     22          
     23          #if defined(MBEDTLS_PSA_CRYPTO_C)
     24          
     25          #include "psa_crypto_aead.h"
     26          #include "psa_crypto_core.h"
     27          #include "psa_crypto_cipher.h"
     28          
     29          #include <string.h>
     30          #include "mbedtls/platform.h"
     31          
     32          #include "mbedtls/ccm.h"
     33          #include "mbedtls/chachapoly.h"
     34          #include "mbedtls/cipher.h"
     35          #include "mbedtls/gcm.h"
     36          #include "mbedtls/error.h"
     37          

   \                                 In section .text, align 2, keep-with-next
     38          static psa_status_t psa_aead_setup(
     39              mbedtls_psa_aead_operation_t *operation,
     40              const psa_key_attributes_t *attributes,
     41              const uint8_t *key_buffer,
     42              size_t key_buffer_size,
     43              psa_algorithm_t alg)
     44          {
   \                     psa_aead_setup: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x9F08             LDR      R7,[SP, #+32]
     45              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
     46              size_t key_bits;
     47              const mbedtls_cipher_info_t *cipher_info;
     48              mbedtls_cipher_id_t cipher_id;
     49          
     50              (void) key_buffer_size;
     51          
     52              key_bits = attributes->core.bits;
   \        0x8   0x8874             LDRH     R4,[R6, #+2]
     53          
     54              cipher_info = mbedtls_cipher_info_from_psa(alg,
     55                                                         attributes->core.type, key_bits,
     56                                                         &cipher_id);
     57              if (cipher_info == NULL) {
   \        0xA   0x8831             LDRH     R1,[R6, #+0]
   \        0xC   0x4605             MOV      R5,R0
   \        0xE   0x4690             MOV      R8,R2
   \       0x10   0x466B             MOV      R3,SP
   \       0x12   0x4622             MOV      R2,R4
   \       0x14   0x4638             MOV      R0,R7
   \       0x16   0xF06F 0x0985      MVN      R9,#+133
   \       0x1A   0x.... 0x....      BL       mbedtls_cipher_info_from_psa
   \       0x1E   0xB370             CBZ.N    R0,??psa_aead_setup_0
     58                  return PSA_ERROR_NOT_SUPPORTED;
     59              }
     60          
     61              switch (PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0)) {
   \       0x20   0xF427 0x117E      BIC      R1,R7,#0x3F8000
   \       0x24   0x....             LDR.N    R0,??DataTable8
   \       0x26   0x4281             CMP      R1,R0
   \       0x28   0xD129             BNE.N    ??psa_aead_setup_0
     62          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
     63                  case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
     64                      operation->alg = PSA_ALG_CCM;
   \       0x2A   0x....             LDR.N    R2,??DataTable8_1
   \       0x2C   0x602A             STR      R2,[R5, #+0]
     65                      /* CCM allows the following tag lengths: 4, 6, 8, 10, 12, 14, 16.
     66                       * The call to mbedtls_ccm_encrypt_and_tag or
     67                       * mbedtls_ccm_auth_decrypt will validate the tag length. */
     68                      if (PSA_BLOCK_CIPHER_BLOCK_LENGTH(attributes->core.type) != 16) {
   \       0x2E   0x8830             LDRH     R0,[R6, #+0]
   \       0x30   0xF400 0x41E0      AND      R1,R0,#0x7000
   \       0x34   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0x38   0xD107             BNE.N    ??psa_aead_setup_1
   \       0x3A   0x0A00             LSRS     R0,R0,#+8
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0xF000 0x0007      AND      R0,R0,#0x7
   \       0x42   0xFA01 0xF000      LSL      R0,R1,R0
   \       0x46   0x2810             CMP      R0,#+16
   \       0x48   0xD002             BEQ.N    ??psa_aead_setup_2
     69                          return PSA_ERROR_INVALID_ARGUMENT;
   \                     ??psa_aead_setup_1: (+1)
   \       0x4A   0xF06F 0x0086      MVN      R0,#+134
   \       0x4E   0xE017             B.N      ??psa_aead_setup_3
     70                      }
     71          
     72                      mbedtls_ccm_init(&operation->ctx.ccm);
   \                     ??psa_aead_setup_2: (+1)
   \       0x50   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x54   0x.... 0x....      BL       mbedtls_ccm_init
     73                      status = mbedtls_to_psa_error(
     74                          mbedtls_ccm_setkey(&operation->ctx.ccm, cipher_id,
     75                                             key_buffer, (unsigned int) key_bits));
   \       0x58   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x5C   0x4623             MOV      R3,R4
   \       0x5E   0x4642             MOV      R2,R8
   \       0x60   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x64   0x.... 0x....      BL       mbedtls_ccm_setkey
   \       0x68   0x.... 0x....      BL       mbedtls_to_psa_error
   \       0x6C   0xEA5F 0x0900      MOVS     R9,R0
     76                      if (status != PSA_SUCCESS) {
   \       0x70   0xD105             BNE.N    ??psa_aead_setup_0
     77                          return status;
     78                      }
     79                      break;
     80          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
     81          
     82          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
     83                  case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
     84                      operation->alg = PSA_ALG_GCM;
     85                      /* GCM allows the following tag lengths: 4, 8, 12, 13, 14, 15, 16.
     86                       * The call to mbedtls_gcm_crypt_and_tag or
     87                       * mbedtls_gcm_auth_decrypt will validate the tag length. */
     88                      if (PSA_BLOCK_CIPHER_BLOCK_LENGTH(attributes->core.type) != 16) {
     89                          return PSA_ERROR_INVALID_ARGUMENT;
     90                      }
     91          
     92                      mbedtls_gcm_init(&operation->ctx.gcm);
     93                      status = mbedtls_to_psa_error(
     94                          mbedtls_gcm_setkey(&operation->ctx.gcm, cipher_id,
     95                                             key_buffer, (unsigned int) key_bits));
     96                      if (status != PSA_SUCCESS) {
     97                          return status;
     98                      }
     99                      break;
    100          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    101          
    102          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    103                  case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CHACHA20_POLY1305, 0):
    104                      operation->alg = PSA_ALG_CHACHA20_POLY1305;
    105                      /* We only support the default tag length. */
    106                      if (alg != PSA_ALG_CHACHA20_POLY1305) {
    107                          return PSA_ERROR_NOT_SUPPORTED;
    108                      }
    109          
    110                      mbedtls_chachapoly_init(&operation->ctx.chachapoly);
    111                      status = mbedtls_to_psa_error(
    112                          mbedtls_chachapoly_setkey(&operation->ctx.chachapoly,
    113                                                    key_buffer));
    114                      if (status != PSA_SUCCESS) {
    115                          return status;
    116                      }
    117                      break;
    118          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    119          
    120                  default:
    121                      (void) status;
    122                      (void) key_buffer;
    123                      status = PSA_ERROR_NOT_SUPPORTED;
    124              }
    125          
    126              if (status == PSA_SUCCESS) {
    127                operation->key_type = psa_get_key_type(attributes);
   \       0x72   0x8830             LDRH     R0,[R6, #+0]
    128          
    129                operation->tag_length = PSA_ALG_AEAD_GET_TAG_LENGTH(alg);
   \       0x74   0x0C3F             LSRS     R7,R7,#+16
   \       0x76   0xF007 0x073F      AND      R7,R7,#0x3F
   \       0x7A   0x80A8             STRH     R0,[R5, #+4]
   \       0x7C   0x71EF             STRB     R7,[R5, #+7]
    130              }
    131          
    132              return status;
   \                     ??psa_aead_setup_0: (+1)
   \       0x7E   0x4648             MOV      R0,R9
   \                     ??psa_aead_setup_3: (+1)
   \       0x80   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    133          }
    134          

   \                                 In section .text, align 2, keep-with-next
    135          psa_status_t mbedtls_psa_aead_encrypt(
    136              const psa_key_attributes_t *attributes,
    137              const uint8_t *key_buffer, size_t key_buffer_size,
    138              psa_algorithm_t alg,
    139              const uint8_t *nonce, size_t nonce_length,
    140              const uint8_t *additional_data, size_t additional_data_length,
    141              const uint8_t *plaintext, size_t plaintext_length,
    142              uint8_t *ciphertext, size_t ciphertext_size, size_t *ciphertext_length)
    143          {
   \                     mbedtls_psa_aead_encrypt: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0A9             SUB      SP,SP,#+164
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
    144              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    145              mbedtls_psa_aead_operation_t operation = MBEDTLS_PSA_AEAD_OPERATION_INIT;
   \        0xC   0xA806             ADD      R0,SP,#+24
   \        0xE   0x218C             MOVS     R1,#+140
   \       0x10   0x.... 0x....      BL       __aeabi_memclr4
    146              uint8_t *tag;
    147          
    148              status = psa_aead_setup(&operation, attributes, key_buffer,
    149                                      key_buffer_size, alg);
   \       0x14   0x9500             STR      R5,[SP, #+0]
   \       0x16   0x4623             MOV      R3,R4
   \       0x18   0x4632             MOV      R2,R6
   \       0x1A   0x4639             MOV      R1,R7
   \       0x1C   0xA806             ADD      R0,SP,#+24
   \       0x1E   0x.... 0x....      BL       psa_aead_setup
   \       0x22   0x0004             MOVS     R4,R0
    150          
    151              if (status != PSA_SUCCESS) {
   \       0x24   0xD127             BNE.N    ??mbedtls_psa_aead_encrypt_0
   \       0x26   0x9D33             LDR      R5,[SP, #+204]
    152                  goto exit;
    153              }
    154          
    155              /* For all currently supported modes, the tag is at the end of the
    156               * ciphertext. */
    157              if (ciphertext_size < (plaintext_length + operation.tag_length)) {
   \       0x28   0xF89D 0x101F      LDRB     R1,[SP, #+31]
   \       0x2C   0x9A35             LDR      R2,[SP, #+212]
   \       0x2E   0x1948             ADDS     R0,R1,R5
   \       0x30   0x4282             CMP      R2,R0
   \       0x32   0xBF38             IT       CC
   \       0x34   0xF06F 0x0489      MVNCC    R4,#+137
    158                  status = PSA_ERROR_BUFFER_TOO_SMALL;
    159                  goto exit;
   \       0x38   0xD31D             BCC.N    ??mbedtls_psa_aead_encrypt_0
    160              }
    161              tag = ciphertext + plaintext_length;
    162          
    163          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    164              if (operation.alg == PSA_ALG_CCM) {
   \       0x3A   0x9A06             LDR      R2,[SP, #+24]
   \       0x3C   0x....             LDR.N    R0,??DataTable8_1
   \       0x3E   0x4282             CMP      R2,R0
   \       0x40   0xD11F             BNE.N    ??mbedtls_psa_aead_encrypt_1
   \       0x42   0x9834             LDR      R0,[SP, #+208]
    165                  status = mbedtls_to_psa_error(
    166                      mbedtls_ccm_encrypt_and_tag(&operation.ctx.ccm,
    167                                                  plaintext_length,
    168                                                  nonce, nonce_length,
    169                                                  additional_data,
    170                                                  additional_data_length,
    171                                                  plaintext, ciphertext,
    172                                                  tag, operation.tag_length));
   \       0x44   0x9105             STR      R1,[SP, #+20]
   \       0x46   0x9B2F             LDR      R3,[SP, #+188]
   \       0x48   0x9003             STR      R0,[SP, #+12]
   \       0x4A   0x1941             ADDS     R1,R0,R5
   \       0x4C   0x9832             LDR      R0,[SP, #+200]
   \       0x4E   0x9104             STR      R1,[SP, #+16]
   \       0x50   0x9931             LDR      R1,[SP, #+196]
   \       0x52   0x9002             STR      R0,[SP, #+8]
   \       0x54   0x9830             LDR      R0,[SP, #+192]
   \       0x56   0x9A2E             LDR      R2,[SP, #+184]
   \       0x58   0x9101             STR      R1,[SP, #+4]
   \       0x5A   0x9000             STR      R0,[SP, #+0]
   \       0x5C   0x4629             MOV      R1,R5
   \       0x5E   0xA808             ADD      R0,SP,#+32
   \       0x60   0x.... 0x....      BL       mbedtls_ccm_encrypt_and_tag
   \       0x64   0x.... 0x....      BL       mbedtls_to_psa_error
   \       0x68   0x0004             MOVS     R4,R0
    173              } else
    174          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    175          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    176              if (operation.alg == PSA_ALG_GCM) {
    177                  status = mbedtls_to_psa_error(
    178                      mbedtls_gcm_crypt_and_tag(&operation.ctx.gcm,
    179                                                MBEDTLS_GCM_ENCRYPT,
    180                                                plaintext_length,
    181                                                nonce, nonce_length,
    182                                                additional_data, additional_data_length,
    183                                                plaintext, ciphertext,
    184                                                operation.tag_length, tag));
    185              } else
    186          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    187          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    188              if (operation.alg == PSA_ALG_CHACHA20_POLY1305) {
    189                  if (operation.tag_length != 16) {
    190                      status = PSA_ERROR_NOT_SUPPORTED;
    191                      goto exit;
    192                  }
    193                  status = mbedtls_to_psa_error(
    194                      mbedtls_chachapoly_encrypt_and_tag(&operation.ctx.chachapoly,
    195                                                         plaintext_length,
    196                                                         nonce,
    197                                                         additional_data,
    198                                                         additional_data_length,
    199                                                         plaintext,
    200                                                         ciphertext,
    201                                                         tag));
    202              } else
    203          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    204              {
    205                  (void) tag;
    206                  (void) nonce;
    207                  (void) nonce_length;
    208                  (void) additional_data;
    209                  (void) additional_data_length;
    210                  (void) plaintext;
    211                  status = PSA_ERROR_NOT_SUPPORTED;
    212              }
    213          
    214              if (status == PSA_SUCCESS) {
   \       0x6A   0xD104             BNE.N    ??mbedtls_psa_aead_encrypt_0
    215                  *ciphertext_length = plaintext_length + operation.tag_length;
   \       0x6C   0xF89D 0x101F      LDRB     R1,[SP, #+31]
   \       0x70   0x9836             LDR      R0,[SP, #+216]
   \       0x72   0x1869             ADDS     R1,R5,R1
   \       0x74   0x6001             STR      R1,[R0, #+0]
    216              }
    217          
    218          exit:
    219              mbedtls_psa_aead_abort(&operation);
   \                     ??mbedtls_psa_aead_encrypt_0: (+1)
   \       0x76   0xA806             ADD      R0,SP,#+24
   \       0x78   0x.... 0x....      BL       mbedtls_psa_aead_abort
    220          
    221              return status;
   \       0x7C   0x4620             MOV      R0,R4
   \       0x7E   0xB029             ADD      SP,SP,#+164
   \       0x80   0xBDF0             POP      {R4-R7,PC}
   \                     ??mbedtls_psa_aead_encrypt_1: (+1)
   \       0x82   0xF06F 0x0485      MVN      R4,#+133
   \       0x86   0xE7F6             B.N      ??mbedtls_psa_aead_encrypt_0
    222          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x0000             DC16 0
   \        0x6   0x00 0x00          DC8 0, 0
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 128
    223          
    224          /* Locate the tag in a ciphertext buffer containing the encrypted data
    225           * followed by the tag. Return the length of the part preceding the tag in
    226           * *plaintext_length. This is the size of the plaintext in modes where
    227           * the encrypted data has the same size as the plaintext, such as
    228           * CCM and GCM. */
    229          static psa_status_t psa_aead_unpadded_locate_tag(size_t tag_length,
    230                                                           const uint8_t *ciphertext,
    231                                                           size_t ciphertext_length,
    232                                                           size_t plaintext_size,
    233                                                           const uint8_t **p_tag)
    234          {
    235              size_t payload_length;
    236              if (tag_length > ciphertext_length) {
    237                  return PSA_ERROR_INVALID_ARGUMENT;
    238              }
    239              payload_length = ciphertext_length - tag_length;
    240              if (payload_length > plaintext_size) {
    241                  return PSA_ERROR_BUFFER_TOO_SMALL;
    242              }
    243              *p_tag = ciphertext + payload_length;
    244              return PSA_SUCCESS;
    245          }
    246          

   \                                 In section .text, align 2, keep-with-next
    247          psa_status_t mbedtls_psa_aead_decrypt(
    248              const psa_key_attributes_t *attributes,
    249              const uint8_t *key_buffer, size_t key_buffer_size,
    250              psa_algorithm_t alg,
    251              const uint8_t *nonce, size_t nonce_length,
    252              const uint8_t *additional_data, size_t additional_data_length,
    253              const uint8_t *ciphertext, size_t ciphertext_length,
    254              uint8_t *plaintext, size_t plaintext_size, size_t *plaintext_length)
    255          {
   \                     mbedtls_psa_aead_decrypt: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB0A9             SUB      SP,SP,#+164
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4614             MOV      R4,R2
   \        0xC   0x461D             MOV      R5,R3
   \        0xE   0x9F35             LDR      R7,[SP, #+212]
   \       0x10   0x9E38             LDR      R6,[SP, #+224]
    256              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    257              mbedtls_psa_aead_operation_t operation = MBEDTLS_PSA_AEAD_OPERATION_INIT;
   \       0x12   0xA806             ADD      R0,SP,#+24
   \       0x14   0x218C             MOVS     R1,#+140
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
    258              const uint8_t *tag = NULL;
    259          
    260              status = psa_aead_setup(&operation, attributes, key_buffer,
    261                                      key_buffer_size, alg);
   \       0x1A   0x9500             STR      R5,[SP, #+0]
   \       0x1C   0x4623             MOV      R3,R4
   \       0x1E   0x4642             MOV      R2,R8
   \       0x20   0x4649             MOV      R1,R9
   \       0x22   0xA806             ADD      R0,SP,#+24
   \       0x24   0x.... 0x....      BL       psa_aead_setup
   \       0x28   0x0004             MOVS     R4,R0
    262          
    263              if (status != PSA_SUCCESS) {
   \       0x2A   0xD129             BNE.N    ??mbedtls_psa_aead_decrypt_0
    264                  goto exit;
    265              }
    266          
    267              status = psa_aead_unpadded_locate_tag(operation.tag_length,
    268                                                    ciphertext, ciphertext_length,
    269                                                    plaintext_size, &tag);
   \       0x2C   0xF89D 0x001F      LDRB     R0,[SP, #+31]
   \       0x30   0x4287             CMP      R7,R0
   \       0x32   0xBF38             IT       CC
   \       0x34   0xF06F 0x0486      MVNCC    R4,#+134
   \       0x38   0xD322             BCC.N    ??mbedtls_psa_aead_decrypt_0
   \       0x3A   0x9A37             LDR      R2,[SP, #+220]
   \       0x3C   0x1A39             SUBS     R1,R7,R0
   \       0x3E   0x428A             CMP      R2,R1
   \       0x40   0xBF38             IT       CC
   \       0x42   0xF06F 0x0489      MVNCC    R4,#+137
   \       0x46   0xD31B             BCC.N    ??mbedtls_psa_aead_decrypt_0
    270              if (status != PSA_SUCCESS) {
    271                  goto exit;
    272              }
    273          
    274          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    275              if (operation.alg == PSA_ALG_CCM) {
   \       0x48   0x9B06             LDR      R3,[SP, #+24]
   \       0x4A   0x....             LDR.N    R2,??DataTable8_1
   \       0x4C   0x4293             CMP      R3,R2
   \       0x4E   0xD123             BNE.N    ??mbedtls_psa_aead_decrypt_1
    276                  status = mbedtls_to_psa_error(
    277                      mbedtls_ccm_auth_decrypt(&operation.ctx.ccm,
    278                                               ciphertext_length - operation.tag_length,
    279                                               nonce, nonce_length,
    280                                               additional_data,
    281                                               additional_data_length,
    282                                               ciphertext, plaintext,
    283                                               tag, operation.tag_length));
   \       0x50   0x9005             STR      R0,[SP, #+20]
   \       0x52   0x9836             LDR      R0,[SP, #+216]
   \       0x54   0x9C34             LDR      R4,[SP, #+208]
   \       0x56   0x9B31             LDR      R3,[SP, #+196]
   \       0x58   0x9003             STR      R0,[SP, #+12]
   \       0x5A   0x9402             STR      R4,[SP, #+8]
   \       0x5C   0x9832             LDR      R0,[SP, #+200]
   \       0x5E   0x9A30             LDR      R2,[SP, #+192]
   \       0x60   0x1865             ADDS     R5,R4,R1
   \       0x62   0x9C33             LDR      R4,[SP, #+204]
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0x9504             STR      R5,[SP, #+16]
   \       0x68   0x9401             STR      R4,[SP, #+4]
   \       0x6A   0xA808             ADD      R0,SP,#+32
   \       0x6C   0x.... 0x....      BL       mbedtls_ccm_auth_decrypt
   \       0x70   0x.... 0x....      BL       mbedtls_to_psa_error
   \       0x74   0x0004             MOVS     R4,R0
    284              } else
    285          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    286          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    287              if (operation.alg == PSA_ALG_GCM) {
    288                  status = mbedtls_to_psa_error(
    289                      mbedtls_gcm_auth_decrypt(&operation.ctx.gcm,
    290                                               ciphertext_length - operation.tag_length,
    291                                               nonce, nonce_length,
    292                                               additional_data,
    293                                               additional_data_length,
    294                                               tag, operation.tag_length,
    295                                               ciphertext, plaintext));
    296              } else
    297          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    298          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    299              if (operation.alg == PSA_ALG_CHACHA20_POLY1305) {
    300                  if (operation.tag_length != 16) {
    301                      status = PSA_ERROR_NOT_SUPPORTED;
    302                      goto exit;
    303                  }
    304                  status = mbedtls_to_psa_error(
    305                      mbedtls_chachapoly_auth_decrypt(&operation.ctx.chachapoly,
    306                                                      ciphertext_length - operation.tag_length,
    307                                                      nonce,
    308                                                      additional_data,
    309                                                      additional_data_length,
    310                                                      tag,
    311                                                      ciphertext,
    312                                                      plaintext));
    313              } else
    314          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    315              {
    316                  (void) nonce;
    317                  (void) nonce_length;
    318                  (void) additional_data;
    319                  (void) additional_data_length;
    320                  (void) plaintext;
    321                  status = PSA_ERROR_NOT_SUPPORTED;
    322              }
    323          
    324              if (status == PSA_SUCCESS) {
   \       0x76   0xD103             BNE.N    ??mbedtls_psa_aead_decrypt_0
    325                  *plaintext_length = ciphertext_length - operation.tag_length;
   \       0x78   0xF89D 0x001F      LDRB     R0,[SP, #+31]
   \       0x7C   0x1A38             SUBS     R0,R7,R0
   \       0x7E   0x6030             STR      R0,[R6, #+0]
    326              }
    327          
    328          exit:
    329              mbedtls_psa_aead_abort(&operation);
   \                     ??mbedtls_psa_aead_decrypt_0: (+1)
   \       0x80   0xA806             ADD      R0,SP,#+24
   \       0x82   0x.... 0x....      BL       mbedtls_psa_aead_abort
    330          
    331              if (status == PSA_SUCCESS) {
   \       0x86   0xB91C             CBNZ.N   R4,??mbedtls_psa_aead_decrypt_2
    332                  *plaintext_length = ciphertext_length - operation.tag_length;
   \       0x88   0xF89D 0x001F      LDRB     R0,[SP, #+31]
   \       0x8C   0x1A3F             SUBS     R7,R7,R0
   \       0x8E   0x6037             STR      R7,[R6, #+0]
    333              }
    334              return status;
   \                     ??mbedtls_psa_aead_decrypt_2: (+1)
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0xB029             ADD      SP,SP,#+164
   \       0x94   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??mbedtls_psa_aead_decrypt_1: (+1)
   \       0x98   0xF06F 0x0485      MVN      R4,#+133
   \       0x9C   0xE7F0             B.N      ??mbedtls_psa_aead_decrypt_0
    335          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x0000             DC16 0
   \        0x6   0x00 0x00          DC8 0, 0
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 128
    336          
    337          /* Set the key and algorithm for a multipart authenticated encryption
    338           * operation. */

   \                                 In section .text, align 2, keep-with-next
    339          psa_status_t mbedtls_psa_aead_encrypt_setup(
    340              mbedtls_psa_aead_operation_t *operation,
    341              const psa_key_attributes_t *attributes,
    342              const uint8_t *key_buffer,
    343              size_t key_buffer_size,
    344              psa_algorithm_t alg)
    345          {
   \                     mbedtls_psa_aead_encrypt_setup: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine2
    346              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    347          
    348              status = psa_aead_setup(operation, attributes, key_buffer,
    349                                      key_buffer_size, alg);
    350          
    351              if (status == PSA_SUCCESS) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0xB918             CBNZ.N   R0,??mbedtls_psa_aead_encrypt_setup_0
    352                  operation->is_encrypt = 1;
   \        0x8   0x6861             LDR      R1,[R4, #+4]
   \        0xA   0xF441 0x3180      ORR      R1,R1,#0x10000
   \        0xE   0x6061             STR      R1,[R4, #+4]
    353              }
    354          
    355              return status;
   \                     ??mbedtls_psa_aead_encrypt_setup_0: (+1)
   \       0x10   0xBD16             POP      {R1,R2,R4,PC}
    356          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x9804             LDR      R0,[SP, #+16]
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....             B.N      psa_aead_setup
    357          
    358          /* Set the key and algorithm for a multipart authenticated decryption
    359           * operation. */

   \                                 In section .text, align 2, keep-with-next
    360          psa_status_t mbedtls_psa_aead_decrypt_setup(
    361              mbedtls_psa_aead_operation_t *operation,
    362              const psa_key_attributes_t *attributes,
    363              const uint8_t *key_buffer,
    364              size_t key_buffer_size,
    365              psa_algorithm_t alg)
    366          {
   \                     mbedtls_psa_aead_decrypt_setup: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine2
    367              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    368          
    369              status = psa_aead_setup(operation, attributes, key_buffer,
    370                                      key_buffer_size, alg);
    371          
    372              if (status == PSA_SUCCESS) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0xB918             CBNZ.N   R0,??mbedtls_psa_aead_decrypt_setup_0
    373                  operation->is_encrypt = 0;
   \        0x8   0x6861             LDR      R1,[R4, #+4]
   \        0xA   0xF421 0x3180      BIC      R1,R1,#0x10000
   \        0xE   0x6061             STR      R1,[R4, #+4]
    374              }
    375          
    376              return status;
   \                     ??mbedtls_psa_aead_decrypt_setup_0: (+1)
   \       0x10   0xBD16             POP      {R1,R2,R4,PC}
    377          }
    378          
    379          /* Set a nonce for the multipart AEAD operation*/

   \                                 In section .text, align 2, keep-with-next
    380          psa_status_t mbedtls_psa_aead_set_nonce(
    381              mbedtls_psa_aead_operation_t *operation,
    382              const uint8_t *nonce,
    383              size_t nonce_length)
    384          {
   \                     mbedtls_psa_aead_set_nonce: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    385              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    386          
    387          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    388              if (operation->alg == PSA_ALG_GCM) {
    389                  status = mbedtls_to_psa_error(
    390                      mbedtls_gcm_starts(&operation->ctx.gcm,
    391                                         operation->is_encrypt ?
    392                                         MBEDTLS_GCM_ENCRYPT : MBEDTLS_GCM_DECRYPT,
    393                                         nonce,
    394                                         nonce_length));
    395              } else
    396          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    397          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    398              if (operation->alg == PSA_ALG_CCM) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x....             LDR.N    R2,??DataTable8_1
   \        0x8   0x4294             CMP      R4,R2
   \        0xA   0xD108             BNE.N    ??mbedtls_psa_aead_set_nonce_0
    399                  status = mbedtls_to_psa_error(
    400                      mbedtls_ccm_starts(&operation->ctx.ccm,
    401                                         operation->is_encrypt ?
    402                                         MBEDTLS_CCM_ENCRYPT : MBEDTLS_CCM_DECRYPT,
    403                                         nonce,
    404                                         nonce_length));
   \        0xC   0x460A             MOV      R2,R1
   \        0xE   0x6841             LDR      R1,[R0, #+4]
   \       0x10   0x3008             ADDS     R0,R0,#+8
   \       0x12   0x0C09             LSRS     R1,R1,#+16
   \       0x14   0xF001 0x0101      AND      R1,R1,#0x1
   \       0x18   0x.... 0x....      BL       mbedtls_ccm_starts
   \       0x1C   0x....             B.N      ?Subroutine1
    405              } else
    406          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    407          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    408              if (operation->alg == PSA_ALG_CHACHA20_POLY1305) {
    409                  /* Note - ChaChaPoly allows an 8 byte nonce, but we would have to
    410                   * allocate a buffer in the operation, copy the nonce to it and pad
    411                   * it, so for now check the nonce is 12 bytes, as
    412                   * mbedtls_chachapoly_starts() assumes it can read 12 bytes from the
    413                   * passed in buffer. */
    414                  if (nonce_length != 12) {
    415                      return PSA_ERROR_INVALID_ARGUMENT;
    416                  }
    417          
    418                  status = mbedtls_to_psa_error(
    419                      mbedtls_chachapoly_starts(&operation->ctx.chachapoly,
    420                                                nonce,
    421                                                operation->is_encrypt ?
    422                                                MBEDTLS_CHACHAPOLY_ENCRYPT :
    423                                                MBEDTLS_CHACHAPOLY_DECRYPT));
    424              } else
    425          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    426              {
    427                  (void) operation;
    428                  (void) nonce;
    429                  (void) nonce_length;
    430          
    431                  status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_psa_aead_set_nonce_0: (+1)
   \       0x1E   0x....             B.N      ?Subroutine0
    432              }
    433          
    434              return status;
    435          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xE8BD 0x4010      POP      {R4,LR}
   \        0x4   0x.... 0x....      B.W      mbedtls_to_psa_error

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x0085      MVN      R0,#+133
   \        0x4   0xBD10             POP      {R4,PC}
    436          
    437          /* Declare the lengths of the message and additional data for AEAD. */

   \                                 In section .text, align 2, keep-with-next
    438          psa_status_t mbedtls_psa_aead_set_lengths(
    439              mbedtls_psa_aead_operation_t *operation,
    440              size_t ad_length,
    441              size_t plaintext_length)
    442          {
   \                     mbedtls_psa_aead_set_lengths: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    443          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    444              if (operation->alg == PSA_ALG_CCM) {
   \        0x2   0x6803             LDR      R3,[R0, #+0]
   \        0x4   0x....             LDR.N    R4,??DataTable8_1
   \        0x6   0x42A3             CMP      R3,R4
   \        0x8   0xD104             BNE.N    ??mbedtls_psa_aead_set_lengths_0
    445                  return mbedtls_to_psa_error(
    446                      mbedtls_ccm_set_lengths(&operation->ctx.ccm,
    447                                              ad_length,
    448                                              plaintext_length,
    449                                              operation->tag_length));
   \        0xA   0x79C3             LDRB     R3,[R0, #+7]
   \        0xC   0x3008             ADDS     R0,R0,#+8
   \        0xE   0x.... 0x....      BL       mbedtls_ccm_set_lengths
   \       0x12   0x....             B.N      ?Subroutine1
    450          
    451              }
    452          #else /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    453              (void) operation;
    454              (void) ad_length;
    455              (void) plaintext_length;
    456          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    457          
    458              return PSA_SUCCESS;
   \                     ??mbedtls_psa_aead_set_lengths_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD10             POP      {R4,PC}
    459          }
    460          
    461          /* Pass additional data to an active multipart AEAD operation. */

   \                                 In section .text, align 2, keep-with-next
    462          psa_status_t mbedtls_psa_aead_update_ad(
    463              mbedtls_psa_aead_operation_t *operation,
    464              const uint8_t *input,
    465              size_t input_length)
    466          {
   \                     mbedtls_psa_aead_update_ad: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    467              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    468          
    469          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    470              if (operation->alg == PSA_ALG_GCM) {
    471                  status = mbedtls_to_psa_error(
    472                      mbedtls_gcm_update_ad(&operation->ctx.gcm, input, input_length));
    473              } else
    474          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    475          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    476              if (operation->alg == PSA_ALG_CCM) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0x....             LDR.N    R3,??DataTable8_1
   \        0x6   0x429C             CMP      R4,R3
   \        0x8   0xD103             BNE.N    ??mbedtls_psa_aead_update_ad_0
    477                  status = mbedtls_to_psa_error(
    478                      mbedtls_ccm_update_ad(&operation->ctx.ccm, input, input_length));
   \        0xA   0x3008             ADDS     R0,R0,#+8
   \        0xC   0x.... 0x....      BL       mbedtls_ccm_update_ad
   \       0x10   0x....             B.N      ?Subroutine1
    479              } else
    480          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    481          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    482              if (operation->alg == PSA_ALG_CHACHA20_POLY1305) {
    483                  status = mbedtls_to_psa_error(
    484                      mbedtls_chachapoly_update_aad(&operation->ctx.chachapoly,
    485                                                    input,
    486                                                    input_length));
    487              } else
    488          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    489              {
    490                  (void) operation;
    491                  (void) input;
    492                  (void) input_length;
    493          
    494                  status = PSA_ERROR_NOT_SUPPORTED;
   \                     ??mbedtls_psa_aead_update_ad_0: (+1)
   \       0x12                      REQUIRE ?Subroutine0
   \       0x12                      ;; // Fall through to label ?Subroutine0
    495              }
    496          
    497              return status;
    498          }
    499          
    500          /* Encrypt or decrypt a message fragment in an active multipart AEAD
    501           * operation.*/

   \                                 In section .text, align 2, keep-with-next
    502          psa_status_t mbedtls_psa_aead_update(
    503              mbedtls_psa_aead_operation_t *operation,
    504              const uint8_t *input,
    505              size_t input_length,
    506              uint8_t *output,
    507              size_t output_size,
    508              size_t *output_length)
    509          {
   \                     mbedtls_psa_aead_update: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    510              size_t update_output_length;
    511              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    512          
    513              update_output_length = input_length;
   \        0x2   0x9202             STR      R2,[SP, #+8]
    514          
    515          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    516              if (operation->alg == PSA_ALG_GCM) {
    517                  status =  mbedtls_to_psa_error(
    518                      mbedtls_gcm_update(&operation->ctx.gcm,
    519                                         input, input_length,
    520                                         output, output_size,
    521                                         &update_output_length));
    522              } else
    523          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    524          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    525              if (operation->alg == PSA_ALG_CCM) {
   \        0x4   0x6805             LDR      R5,[R0, #+0]
   \        0x6   0x....             LDR.N    R4,??DataTable8_1
   \        0x8   0x42A5             CMP      R5,R4
   \        0xA   0xD112             BNE.N    ??mbedtls_psa_aead_update_0
   \        0xC   0x9D06             LDR      R5,[SP, #+24]
    526                  if (output_size < input_length) {
   \        0xE   0x4295             CMP      R5,R2
   \       0x10   0xD202             BCS.N    ??mbedtls_psa_aead_update_1
    527                      return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x12   0xF06F 0x0089      MVN      R0,#+137
   \       0x16   0xBD3E             POP      {R1-R5,PC}
    528                  }
    529          
    530                  status = mbedtls_to_psa_error(
    531                      mbedtls_ccm_update(&operation->ctx.ccm,
    532                                         input, input_length,
    533                                         output, output_size,
    534                                         &update_output_length));
   \                     ??mbedtls_psa_aead_update_1: (+1)
   \       0x18   0xAC02             ADD      R4,SP,#+8
   \       0x1A   0x9401             STR      R4,[SP, #+4]
   \       0x1C   0x9500             STR      R5,[SP, #+0]
   \       0x1E   0x3008             ADDS     R0,R0,#+8
   \       0x20   0x.... 0x....      BL       mbedtls_ccm_update
   \       0x24   0x.... 0x....      BL       mbedtls_to_psa_error
    535              } else
    536          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    537          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    538              if (operation->alg == PSA_ALG_CHACHA20_POLY1305) {
    539                  if (output_size < input_length) {
    540                      return PSA_ERROR_BUFFER_TOO_SMALL;
    541                  }
    542          
    543                  status = mbedtls_to_psa_error(
    544                      mbedtls_chachapoly_update(&operation->ctx.chachapoly,
    545                                                input_length,
    546                                                input,
    547                                                output));
    548              } else
    549          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    550              {
    551                  (void) operation;
    552                  (void) input;
    553                  (void) output;
    554                  (void) output_size;
    555          
    556                  status = PSA_ERROR_NOT_SUPPORTED;
    557              }
    558          
    559              if (status == PSA_SUCCESS) {
   \       0x28   0xB910             CBNZ.N   R0,??mbedtls_psa_aead_update_2
   \       0x2A   0x9A07             LDR      R2,[SP, #+28]
    560                  *output_length = update_output_length;
   \       0x2C   0x9902             LDR      R1,[SP, #+8]
   \       0x2E   0x6011             STR      R1,[R2, #+0]
    561              }
    562          
    563              return status;
   \                     ??mbedtls_psa_aead_update_2: (+1)
   \       0x30   0xBD3E             POP      {R1-R5,PC}
   \                     ??mbedtls_psa_aead_update_0: (+1)
   \       0x32   0xF06F 0x0085      MVN      R0,#+133
   \       0x36   0xBD3E             POP      {R1-R5,PC}
    564          }
    565          
    566          /* Finish encrypting a message in a multipart AEAD operation. */

   \                                 In section .text, align 2, keep-with-next
    567          psa_status_t mbedtls_psa_aead_finish(
    568              mbedtls_psa_aead_operation_t *operation,
    569              uint8_t *ciphertext,
    570              size_t ciphertext_size,
    571              size_t *ciphertext_length,
    572              uint8_t *tag,
    573              size_t tag_size,
    574              size_t *tag_length)
    575          {
   \                     mbedtls_psa_aead_finish: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x9805             LDR      R0,[SP, #+20]
    576              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    577              size_t finish_output_size = 0;
    578          
    579              if (tag_size < operation->tag_length) {
   \        0x6   0x79E2             LDRB     R2,[R4, #+7]
   \        0x8   0x461D             MOV      R5,R3
   \        0xA   0x4290             CMP      R0,R2
   \        0xC   0xD311             BCC.N    ??mbedtls_psa_aead_finish_0
    580                  return PSA_ERROR_BUFFER_TOO_SMALL;
    581              }
    582          
    583          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    584              if (operation->alg == PSA_ALG_GCM) {
    585                  status =  mbedtls_to_psa_error(
    586                      mbedtls_gcm_finish(&operation->ctx.gcm,
    587                                         ciphertext, ciphertext_size, ciphertext_length,
    588                                         tag, operation->tag_length));
    589              } else
    590          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    591          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    592              if (operation->alg == PSA_ALG_CCM) {
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x....             LDR.N    R0,??DataTable8_1
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD110             BNE.N    ??mbedtls_psa_aead_finish_1
   \       0x16   0x9904             LDR      R1,[SP, #+16]
    593                  /* tag must be big enough to store a tag of size passed into set
    594                   * lengths. */
    595                  if (tag_size < operation->tag_length) {
    596                      return PSA_ERROR_BUFFER_TOO_SMALL;
    597                  }
    598          
    599                  status = mbedtls_to_psa_error(
    600                      mbedtls_ccm_finish(&operation->ctx.ccm,
    601                                         tag, operation->tag_length));
   \       0x18   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x1C   0x.... 0x....      BL       mbedtls_ccm_finish
   \       0x20   0x.... 0x....      BL       mbedtls_to_psa_error
    602              } else
    603          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    604          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    605              if (operation->alg == PSA_ALG_CHACHA20_POLY1305) {
    606                  /* Belt and braces. Although the above tag_size check should have
    607                   * already done this, if we later start supporting smaller tag sizes
    608                   * for chachapoly, then passing a tag buffer smaller than 16 into here
    609                   * could cause a buffer overflow, so better safe than sorry. */
    610                  if (tag_size < 16) {
    611                      return PSA_ERROR_BUFFER_TOO_SMALL;
    612                  }
    613          
    614                  status = mbedtls_to_psa_error(
    615                      mbedtls_chachapoly_finish(&operation->ctx.chachapoly,
    616                                                tag));
    617              } else
    618          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    619              {
    620                  (void) ciphertext;
    621                  (void) ciphertext_size;
    622                  (void) ciphertext_length;
    623                  (void) tag;
    624                  (void) tag_size;
    625                  (void) tag_length;
    626          
    627                  status = PSA_ERROR_NOT_SUPPORTED;
    628              }
    629          
    630              if (status == PSA_SUCCESS) {
   \       0x24   0xB920             CBNZ.N   R0,??mbedtls_psa_aead_finish_2
   \       0x26   0x9906             LDR      R1,[SP, #+24]
    631                  /* This will be zero for all supported algorithms currently, but left
    632                   * here for future support. */
    633                  *ciphertext_length = finish_output_size;
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x602A             STR      R2,[R5, #+0]
    634                  *tag_length = operation->tag_length;
   \       0x2C   0x79E3             LDRB     R3,[R4, #+7]
   \       0x2E   0x600B             STR      R3,[R1, #+0]
    635              }
    636          
    637              return status;
   \                     ??mbedtls_psa_aead_finish_2: (+1)
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??mbedtls_psa_aead_finish_0: (+1)
   \       0x32   0xF06F 0x0089      MVN      R0,#+137
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??mbedtls_psa_aead_finish_1: (+1)
   \       0x38   0xF06F 0x0085      MVN      R0,#+133
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}
    638          }
    639          
    640          /* Abort an AEAD operation */

   \                                 In section .text, align 2, keep-with-next
    641          psa_status_t mbedtls_psa_aead_abort(
    642              mbedtls_psa_aead_operation_t *operation)
    643          {
   \                     mbedtls_psa_aead_abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    644              switch (operation->alg) {
   \        0x4   0x6822             LDR      R2,[R4, #+0]
   \        0x6   0x....             LDR.N    R1,??DataTable8_1
   \        0x8   0x428A             CMP      R2,R1
   \        0xA   0xBF04             ITT      EQ
    645          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    646                  case PSA_ALG_CCM:
    647                      mbedtls_ccm_free(&operation->ctx.ccm);
   \        0xC   0xF104 0x0008      ADDEQ    R0,R4,#+8
   \       0x10   0x.... 0x....      BLEQ     mbedtls_ccm_free
    648                      break;
    649          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
    650          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    651                  case PSA_ALG_GCM:
    652                      mbedtls_gcm_free(&operation->ctx.gcm);
    653                      break;
    654          #endif /* MBEDTLS_PSA_BUILTIN_ALG_GCM */
    655          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    656                  case PSA_ALG_CHACHA20_POLY1305:
    657                      mbedtls_chachapoly_free(&operation->ctx.chachapoly);
    658                      break;
    659          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 */
    660              }
    661          
    662              operation->is_encrypt = 0;
   \       0x14   0x6860             LDR      R0,[R4, #+4]
   \       0x16   0xF420 0x3080      BIC      R0,R0,#0x10000
   \       0x1A   0x6060             STR      R0,[R4, #+4]
    663          
    664              return PSA_SUCCESS;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}
    665          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0540'0100        DC32     0x5400100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0550'0100        DC32     0x5500100
    666          
    667          #endif /* MBEDTLS_PSA_CRYPTO_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   mbedtls_psa_aead_abort
         8   -> mbedtls_ccm_free
     192   mbedtls_psa_aead_decrypt
       192   -> __aeabi_memclr4
       192   -> mbedtls_ccm_auth_decrypt
       192   -> mbedtls_psa_aead_abort
       192   -> mbedtls_to_psa_error
       192   -> psa_aead_setup
      16   mbedtls_psa_aead_decrypt_setup
        16   -> psa_aead_setup
     184   mbedtls_psa_aead_encrypt
       184   -> __aeabi_memclr4
       184   -> mbedtls_ccm_encrypt_and_tag
       184   -> mbedtls_psa_aead_abort
       184   -> mbedtls_to_psa_error
       184   -> psa_aead_setup
      16   mbedtls_psa_aead_encrypt_setup
        16   -> psa_aead_setup
      16   mbedtls_psa_aead_finish
        16   -> mbedtls_ccm_finish
        16   -> mbedtls_to_psa_error
       8   mbedtls_psa_aead_set_lengths
         8   -> mbedtls_ccm_set_lengths
         0   -> mbedtls_to_psa_error
       8   mbedtls_psa_aead_set_nonce
         8   -> mbedtls_ccm_starts
         0   -> mbedtls_to_psa_error
      24   mbedtls_psa_aead_update
        24   -> mbedtls_ccm_update
        24   -> mbedtls_to_psa_error
       8   mbedtls_psa_aead_update_ad
         8   -> mbedtls_ccm_update_ad
         0   -> mbedtls_to_psa_error
      32   psa_aead_setup
        32   -> mbedtls_ccm_init
        32   -> mbedtls_ccm_setkey
        32   -> mbedtls_cipher_info_from_psa
        32   -> mbedtls_to_psa_error


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       6  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
     140  ?_0
     140  ?_1
      32  mbedtls_psa_aead_abort
     158  mbedtls_psa_aead_decrypt
      18  mbedtls_psa_aead_decrypt_setup
     136  mbedtls_psa_aead_encrypt
      18  mbedtls_psa_aead_encrypt_setup
      62  mbedtls_psa_aead_finish
      24  mbedtls_psa_aead_set_lengths
      32  mbedtls_psa_aead_set_nonce
      56  mbedtls_psa_aead_update
      18  mbedtls_psa_aead_update_ad
     132  psa_aead_setup

 
 280 bytes in section .rodata
 718 bytes in section .text
 
 718 bytes of CODE  memory
 280 bytes of CONST memory

Errors: none
Warnings: none
