###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:35
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pk_wrap.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pk_wrap.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pk_wrap.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pk_wrap.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\pk_wrap.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\pk_wrap.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\pk_wrap.c
      1          /*
      2           *  Public Key abstraction layer: wrapper functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #include "mbedtls/platform_util.h"
     23          
     24          #if defined(MBEDTLS_PK_C)
     25          #include "pk_wrap.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_usage_flags(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_usage_flags: (+1)
   \        0x0   0x04CA             LSLS     R2,R1,#+19
   \        0x2   0xBF48             IT       MI
   \        0x4   0xF441 0x6180      ORRMI    R1,R1,#0x400
   \        0x8   0x048A             LSLS     R2,R1,#+18
   \        0xA   0xBF48             IT       MI
   \        0xC   0xF441 0x6100      ORRMI    R1,R1,#0x800
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_algorithm(psa_key_attributes_t *, uint32_t)
   \                     psa_set_key_algorithm: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void psa_set_key_type(psa_key_attributes_t *, uint16_t)
   \                     psa_set_key_type: (+1)
   \        0x0   0x69C2             LDR      R2,[R0, #+28]
   \        0x2   0xB90A             CBNZ.N   R2,??psa_set_key_type_0
   \        0x4   0x8001             STRH     R1,[R0, #+0]
   \        0x6   0x4770             BX       LR
   \                     ??psa_set_key_type_0: (+1)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x.... 0x....      B.W      psa_set_key_domain_parameters
     26          #include "pk_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_ecp_keypair const *mbedtls_pk_ec_ro(mbedtls_pk_context const)
   \                     mbedtls_pk_ec_ro: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xA802             ADD      R0,SP,#+8
   \        0x6   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xA   0x1E80             SUBS     R0,R0,#+2
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xBF94             ITE      LS
   \       0x10   0x9803             LDRLS    R0,[SP, #+12]
   \       0x12   0x2000             MOVHI    R0,#+0
   \       0x14   0x....             B.N      ?Subroutine6

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xBC02             POP      {R1}
   \        0x2   0xF85D 0xFB14      LDR      PC,[SP], #+20

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp mbedtls_ecp_keypair *mbedtls_pk_ec_rw(mbedtls_pk_context const)
   \                     mbedtls_pk_ec_rw: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xA802             ADD      R0,SP,#+8
   \        0x6   0x.... 0x....      BL       mbedtls_pk_get_type
   \        0xA   0x1E80             SUBS     R0,R0,#+2
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xBF94             ITE      LS
   \       0x10   0x9803             LDRLS    R0,[SP, #+12]
   \       0x12   0x2000             MOVHI    R0,#+0
   \       0x14                      REQUIRE ?Subroutine6
   \       0x14                      ;; // Fall through to label ?Subroutine6
     27          #include "mbedtls/error.h"
     28          #include "md_psa.h"
     29          
     30          /* Even if RSA not activated, for the sake of RSA-alt */
     31          #include "mbedtls/rsa.h"
     32          
     33          #if defined(MBEDTLS_ECP_C)
     34          #include "mbedtls/ecp.h"
     35          #endif
     36          
     37          #if defined(MBEDTLS_ECDSA_C)
     38          #include "mbedtls/ecdsa.h"
     39          #endif
     40          
     41          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_PSA_CRYPTO_C)
     42          #include "pkwrite.h"
     43          #endif
     44          
     45          #if defined(MBEDTLS_PSA_CRYPTO_C)
     46          #include "psa_util_internal.h"
     47          #endif
     48          
     49          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     50          #include "psa/crypto.h"
     51          
     52          #if defined(MBEDTLS_PK_CAN_ECDSA_SOME)
     53          #include "mbedtls/asn1write.h"
     54          #include "mbedtls/asn1.h"
     55          #endif
     56          #endif  /* MBEDTLS_USE_PSA_CRYPTO */
     57          
     58          #include "mbedtls/platform.h"
     59          
     60          #include <limits.h>
     61          #include <stdint.h>
     62          #include <string.h>
     63          
     64          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
     65          #if defined(MBEDTLS_PSA_CRYPTO_C)

   \                                 In section .text, align 2, keep-with-next
     66          int mbedtls_pk_error_from_psa(psa_status_t status)
     67          {
     68              switch (status) {
   \                     mbedtls_pk_error_from_psa: (+1)
   \        0x0   0xB350             CBZ.N    R0,??mbedtls_pk_error_from_psa_0
   \        0x2   0xF06F 0x0198      MVN      R1,#+152
   \        0x6   0x1A40             SUBS     R0,R0,R1
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD921             BLS.N    ??mbedtls_pk_error_from_psa_1
   \        0xC   0x1E80             SUBS     R0,R0,#+2
   \        0xE   0xD020             BEQ.N    ??mbedtls_pk_error_from_psa_2
   \       0x10   0x1F00             SUBS     R0,R0,#+4
   \       0x12   0xD01C             BEQ.N    ??mbedtls_pk_error_from_psa_3
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0xD01B             BEQ.N    ??mbedtls_pk_error_from_psa_1
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \       0x1A   0xD018             BEQ.N    ??mbedtls_pk_error_from_psa_3
   \       0x1C   0x1F00             SUBS     R0,R0,#+4
   \       0x1E   0xD014             BEQ.N    ??mbedtls_pk_error_from_psa_4
   \       0x20   0x1EC0             SUBS     R0,R0,#+3
   \       0x22   0xD00B             BEQ.N    ??mbedtls_pk_error_from_psa_5
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0xD011             BEQ.N    ??mbedtls_pk_error_from_psa_6
   \       0x28   0x1E40             SUBS     R0,R0,#+1
   \       0x2A   0xD004             BEQ.N    ??mbedtls_pk_error_from_psa_7
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0xD009             BEQ.N    ??mbedtls_pk_error_from_psa_8
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0xD006             BEQ.N    ??mbedtls_pk_error_from_psa_9
   \       0x34   0xE00E             B.N      ??mbedtls_pk_error_from_psa_10
     69                  case PSA_SUCCESS:
     70                      return 0;
     71                  case PSA_ERROR_INVALID_HANDLE:
     72                      return MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;
   \                     ??mbedtls_pk_error_from_psa_7: (+1)
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x3A   0x4770             BX       LR
     73                  case PSA_ERROR_NOT_PERMITTED:
     74                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
     75                  case PSA_ERROR_BUFFER_TOO_SMALL:
     76                      return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
   \                     ??mbedtls_pk_error_from_psa_5: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x40   0x4770             BX       LR
     77                  case PSA_ERROR_NOT_SUPPORTED:
     78                      return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_error_from_psa_9: (+1)
   \       0x42   0x....             B.N      ?Subroutine5
     79                  case PSA_ERROR_INVALID_ARGUMENT:
     80                      return MBEDTLS_ERR_PK_INVALID_ALG;
   \                     ??mbedtls_pk_error_from_psa_8: (+1)
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x48   0x4770             BX       LR
     81                  case PSA_ERROR_INSUFFICIENT_MEMORY:
     82                      return MBEDTLS_ERR_PK_ALLOC_FAILED;
   \                     ??mbedtls_pk_error_from_psa_4: (+1)
   \       0x4A   0x....             B.N      ?Subroutine4
     83                  case PSA_ERROR_BAD_STATE:
     84                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_error_from_psa_6: (+1)
   \       0x4C   0x....             B.N      ?Subroutine3
     85                  case PSA_ERROR_COMMUNICATION_FAILURE:
     86                  case PSA_ERROR_HARDWARE_FAILURE:
     87                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \                     ??mbedtls_pk_error_from_psa_3: (+1)
   \       0x4E   0x....             B.N      ?Subroutine2
     88                  case PSA_ERROR_DATA_CORRUPT:
     89                  case PSA_ERROR_DATA_INVALID:
     90                  case PSA_ERROR_STORAGE_FAILURE:
     91                      return MBEDTLS_ERR_PK_FILE_IO_ERROR;
   \                     ??mbedtls_pk_error_from_psa_1: (+1)
   \       0x50   0x....             B.N      ?Subroutine1
     92                  case PSA_ERROR_CORRUPTION_DETECTED:
     93                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_pk_error_from_psa_2: (+1)
   \       0x52   0x....             B.N      ?Subroutine0
     94                  default:
     95                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   \                     ??mbedtls_pk_error_from_psa_10: (+1)
   \       0x54   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??mbedtls_pk_error_from_psa_0: (+1)
   \       0x58   0x4770             BX       LR
     96              }
     97          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF06F 0x006F      MVN      R0,#+111
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x006D      MVN      R0,#+109
   \        0x4   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable13_16
   \        0x2   0x4770             BX       LR
     98          
     99          #if defined(PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY) ||    \
    100              defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC)
    101          int mbedtls_pk_error_from_psa_rsa(psa_status_t status)
    102          {
    103              switch (status) {
    104                  case PSA_ERROR_NOT_PERMITTED:
    105                  case PSA_ERROR_INVALID_ARGUMENT:
    106                  case PSA_ERROR_INVALID_HANDLE:
    107                      return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
    108                  case PSA_ERROR_BUFFER_TOO_SMALL:
    109                      return MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    110                  case PSA_ERROR_INSUFFICIENT_ENTROPY:
    111                      return MBEDTLS_ERR_RSA_RNG_FAILED;
    112                  case PSA_ERROR_INVALID_SIGNATURE:
    113                      return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    114                  case PSA_ERROR_INVALID_PADDING:
    115                      return MBEDTLS_ERR_RSA_INVALID_PADDING;
    116                  case PSA_SUCCESS:
    117                      return 0;
    118                  case PSA_ERROR_NOT_SUPPORTED:
    119                      return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
    120                  case PSA_ERROR_INSUFFICIENT_MEMORY:
    121                      return MBEDTLS_ERR_PK_ALLOC_FAILED;
    122                  case PSA_ERROR_BAD_STATE:
    123                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    124                  case PSA_ERROR_COMMUNICATION_FAILURE:
    125                  case PSA_ERROR_HARDWARE_FAILURE:
    126                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
    127                  case PSA_ERROR_DATA_CORRUPT:
    128                  case PSA_ERROR_DATA_INVALID:
    129                  case PSA_ERROR_STORAGE_FAILURE:
    130                      return MBEDTLS_ERR_PK_FILE_IO_ERROR;
    131                  case PSA_ERROR_CORRUPTION_DETECTED:
    132                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    133                  default:
    134                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
    135              }
    136          }
    137          #endif /* PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY || PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
    138          #endif /* MBEDTLS_PSA_CRYPTO_C */
    139          
    140          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    141          #if defined(PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY)

   \                                 In section .text, align 2, keep-with-next
    142          int mbedtls_pk_error_from_psa_ecdsa(psa_status_t status)
    143          {
    144              switch (status) {
   \                     mbedtls_pk_error_from_psa_ecdsa: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD035             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_0
   \        0x4   0xF06F 0x0198      MVN      R1,#+152
   \        0x8   0x1A40             SUBS     R0,R0,R1
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD92C             BLS.N    ??mbedtls_pk_error_from_psa_ecdsa_1
   \        0xE   0x1E80             SUBS     R0,R0,#+2
   \       0x10   0xD02B             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_2
   \       0x12   0x1E80             SUBS     R0,R0,#+2
   \       0x14   0xD021             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_3
   \       0x16   0x1E40             SUBS     R0,R0,#+1
   \       0x18   0xD01C             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_4
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0xD023             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_5
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0xD022             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_1
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0xD01F             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_5
   \       0x26   0x1F00             SUBS     R0,R0,#+4
   \       0x28   0xD01B             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_6
   \       0x2A   0x1EC0             SUBS     R0,R0,#+3
   \       0x2C   0xD00F             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_7
   \       0x2E   0x1E40             SUBS     R0,R0,#+1
   \       0x30   0xD018             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_8
   \       0x32   0x1E40             SUBS     R0,R0,#+1
   \       0x34   0xD008             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_9
   \       0x36   0x1E40             SUBS     R0,R0,#+1
   \       0x38   0xD003             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_10
   \       0x3A   0x1E40             SUBS     R0,R0,#+1
   \       0x3C   0xD010             BEQ.N    ??mbedtls_pk_error_from_psa_ecdsa_11
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0xD114             BNE.N    ??mbedtls_pk_error_from_psa_ecdsa_12
    145                  case PSA_ERROR_NOT_PERMITTED:
    146                  case PSA_ERROR_INVALID_ARGUMENT:
    147                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_10: (+1)
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \       0x46   0x4770             BX       LR
    148                  case PSA_ERROR_INVALID_HANDLE:
    149                      return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_9: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \       0x4C   0x4770             BX       LR
    150                  case PSA_ERROR_BUFFER_TOO_SMALL:
    151                      return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_7: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \       0x52   0x4770             BX       LR
    152                  case PSA_ERROR_INSUFFICIENT_ENTROPY:
    153                      return MBEDTLS_ERR_ECP_RANDOM_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_4: (+1)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \       0x58   0x4770             BX       LR
    154                  case PSA_ERROR_INVALID_SIGNATURE:
    155                      return MBEDTLS_ERR_ECP_VERIFY_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_3: (+1)
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable13_7
   \       0x5E   0x4770             BX       LR
    156                  case PSA_SUCCESS:
    157                      return 0;
    158                  case PSA_ERROR_NOT_SUPPORTED:
    159                      return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_11: (+1)
   \       0x60   0x....             B.N      ?Subroutine5
    160                  case PSA_ERROR_INSUFFICIENT_MEMORY:
    161                      return MBEDTLS_ERR_PK_ALLOC_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_6: (+1)
   \       0x62   0x....             B.N      ?Subroutine4
    162                  case PSA_ERROR_BAD_STATE:
    163                      return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_8: (+1)
   \       0x64   0x....             B.N      ?Subroutine3
    164                  case PSA_ERROR_COMMUNICATION_FAILURE:
    165                  case PSA_ERROR_HARDWARE_FAILURE:
    166                      return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_5: (+1)
   \       0x66   0x....             B.N      ?Subroutine2
    167                  case PSA_ERROR_DATA_CORRUPT:
    168                  case PSA_ERROR_DATA_INVALID:
    169                  case PSA_ERROR_STORAGE_FAILURE:
    170                      return MBEDTLS_ERR_PK_FILE_IO_ERROR;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_1: (+1)
   \       0x68   0x....             B.N      ?Subroutine1
    171                  case PSA_ERROR_CORRUPTION_DETECTED:
    172                      return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_2: (+1)
   \       0x6A   0x....             B.N      ?Subroutine0
    173                  default:
    174                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
   \                     ??mbedtls_pk_error_from_psa_ecdsa_12: (+1)
   \       0x6C   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??mbedtls_pk_error_from_psa_ecdsa_0: (+1)
   \       0x70   0x4770             BX       LR
    175              }
    176          }
    177          #endif /* PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY */
    178          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    179          #endif /* !MBEDTLS_DEPRECATED_REMOVED */
    180          
    181          #if defined(MBEDTLS_RSA_C)
    182          static int rsa_can_do(mbedtls_pk_type_t type)
    183          {
    184              return type == MBEDTLS_PK_RSA ||
    185                     type == MBEDTLS_PK_RSASSA_PSS;
    186          }
    187          
    188          static size_t rsa_get_bitlen(mbedtls_pk_context *pk)
    189          {
    190              const mbedtls_rsa_context *rsa = (const mbedtls_rsa_context *) pk->pk_ctx;
    191              return 8 * mbedtls_rsa_get_len(rsa);
    192          }
    193          
    194          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    195          static int rsa_verify_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    196                                     const unsigned char *hash, size_t hash_len,
    197                                     const unsigned char *sig, size_t sig_len)
    198          {
    199              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    200              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    201              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    202              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    203              psa_status_t status;
    204              mbedtls_pk_context key;
    205              int key_len;
    206              unsigned char buf[MBEDTLS_PK_RSA_PUB_DER_MAX_BYTES];
    207              psa_algorithm_t psa_alg_md =
    208                  PSA_ALG_RSA_PKCS1V15_SIGN(mbedtls_md_psa_alg_from_type(md_alg));
    209              size_t rsa_len = mbedtls_rsa_get_len(rsa);
    210          
    211              if (md_alg == MBEDTLS_MD_NONE
    212          #if SIZE_MAX > UINT_MAX
    213                  && UINT_MAX < hash_len
    214          #endif
    215                  ) {
    216                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    217              }
    218          
    219              if (sig_len < rsa_len) {
    220                  return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    221              }
    222          
    223              /* mbedtls_pk_write_pubkey_der() expects a full PK context;
    224               * re-construct one to make it happy */
    225              key.pk_info = &mbedtls_rsa_info;
    226              key.pk_ctx = rsa;
    227              key_len = mbedtls_pk_write_pubkey_der(&key, buf, sizeof(buf));
    228              if (key_len <= 0) {
    229                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    230              }
    231          
    232              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_VERIFY_HASH);
    233              psa_set_key_algorithm(&attributes, psa_alg_md);
    234              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_PUBLIC_KEY);
    235          
    236              status = psa_import_key(&attributes,
    237                                      buf + sizeof(buf) - key_len, key_len,
    238                                      &key_id);
    239              if (status != PSA_SUCCESS) {
    240                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    241                  goto cleanup;
    242              }
    243          
    244              status = psa_verify_hash(key_id, psa_alg_md, hash, hash_len,
    245                                       sig, sig_len);
    246              if (status != PSA_SUCCESS) {
    247                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    248                  goto cleanup;
    249              }
    250              ret = 0;
    251          
    252          cleanup:
    253              status = psa_destroy_key(key_id);
    254              if (ret == 0 && status != PSA_SUCCESS) {
    255                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    256              }
    257          
    258              return ret;
    259          }
    260          #else /* MBEDTLS_USE_PSA_CRYPTO */
    261          static int rsa_verify_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    262                                     const unsigned char *hash, size_t hash_len,
    263                                     const unsigned char *sig, size_t sig_len)
    264          {
    265              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    266              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    267              size_t rsa_len = mbedtls_rsa_get_len(rsa);
    268          
    269          #if SIZE_MAX > UINT_MAX
    270              if (md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len) {
    271                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    272              }
    273          #endif
    274          
    275              if (sig_len < rsa_len) {
    276                  return MBEDTLS_ERR_RSA_VERIFY_FAILED;
    277              }
    278          
    279              if ((ret = mbedtls_rsa_pkcs1_verify(rsa, md_alg,
    280                                                  (unsigned int) hash_len,
    281                                                  hash, sig)) != 0) {
    282                  return ret;
    283              }
    284          
    285              /* The buffer contains a valid signature followed by extra data.
    286               * We have a special error code for that so that so that callers can
    287               * use mbedtls_pk_verify() to check "Does the buffer start with a
    288               * valid signature?" and not just "Does the buffer contain a valid
    289               * signature?". */
    290              if (sig_len > rsa_len) {
    291                  return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    292              }
    293          
    294              return 0;
    295          }
    296          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    297          
    298          #if defined(MBEDTLS_PSA_CRYPTO_C)
    299          int  mbedtls_pk_psa_rsa_sign_ext(psa_algorithm_t alg,
    300                                           mbedtls_rsa_context *rsa_ctx,
    301                                           const unsigned char *hash, size_t hash_len,
    302                                           unsigned char *sig, size_t sig_size,
    303                                           size_t *sig_len)
    304          {
    305              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    306              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    307              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    308              psa_status_t status;
    309              mbedtls_pk_context key;
    310              int key_len;
    311              unsigned char *buf = NULL;
    312              buf = mbedtls_calloc(1, MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES);
    313              if (buf == NULL) {
    314                  return MBEDTLS_ERR_PK_ALLOC_FAILED;
    315              }
    316              mbedtls_pk_info_t pk_info = mbedtls_rsa_info;
    317          
    318              *sig_len = mbedtls_rsa_get_len(rsa_ctx);
    319              if (sig_size < *sig_len) {
    320                  mbedtls_free(buf);
    321                  return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
    322              }
    323          
    324              /* mbedtls_pk_write_key_der() expects a full PK context;
    325               * re-construct one to make it happy */
    326              key.pk_info = &pk_info;
    327              key.pk_ctx = rsa_ctx;
    328              key_len = mbedtls_pk_write_key_der(&key, buf, MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES);
    329              if (key_len <= 0) {
    330                  mbedtls_free(buf);
    331                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    332              }
    333              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
    334              psa_set_key_algorithm(&attributes, alg);
    335              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_KEY_PAIR);
    336          
    337              status = psa_import_key(&attributes,
    338                                      buf + MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES - key_len, key_len,
    339                                      &key_id);
    340              if (status != PSA_SUCCESS) {
    341                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    342                  goto cleanup;
    343              }
    344              status = psa_sign_hash(key_id, alg, hash, hash_len,
    345                                     sig, sig_size, sig_len);
    346              if (status != PSA_SUCCESS) {
    347                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    348                  goto cleanup;
    349              }
    350          
    351              ret = 0;
    352          
    353          cleanup:
    354              mbedtls_free(buf);
    355              status = psa_destroy_key(key_id);
    356              if (ret == 0 && status != PSA_SUCCESS) {
    357                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    358              }
    359              return ret;
    360          }
    361          #endif /* MBEDTLS_PSA_CRYPTO_C */
    362          
    363          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    364          static int rsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    365                                   const unsigned char *hash, size_t hash_len,
    366                                   unsigned char *sig, size_t sig_size, size_t *sig_len,
    367                                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    368          {
    369              ((void) f_rng);
    370              ((void) p_rng);
    371          
    372              psa_algorithm_t psa_md_alg;
    373              psa_md_alg = mbedtls_md_psa_alg_from_type(md_alg);
    374              if (psa_md_alg == 0) {
    375                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    376              }
    377          
    378              return mbedtls_pk_psa_rsa_sign_ext(PSA_ALG_RSA_PKCS1V15_SIGN(
    379                                                     psa_md_alg),
    380                                                 pk->pk_ctx, hash, hash_len,
    381                                                 sig, sig_size, sig_len);
    382          }
    383          #else /* MBEDTLS_USE_PSA_CRYPTO */
    384          static int rsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    385                                   const unsigned char *hash, size_t hash_len,
    386                                   unsigned char *sig, size_t sig_size, size_t *sig_len,
    387                                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    388          {
    389              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    390          
    391          #if SIZE_MAX > UINT_MAX
    392              if (md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len) {
    393                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    394              }
    395          #endif
    396          
    397              *sig_len = mbedtls_rsa_get_len(rsa);
    398              if (sig_size < *sig_len) {
    399                  return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
    400              }
    401          
    402              return mbedtls_rsa_pkcs1_sign(rsa, f_rng, p_rng,
    403                                            md_alg, (unsigned int) hash_len,
    404                                            hash, sig);
    405          }
    406          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    407          
    408          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    409          static int rsa_decrypt_wrap(mbedtls_pk_context *pk,
    410                                      const unsigned char *input, size_t ilen,
    411                                      unsigned char *output, size_t *olen, size_t osize,
    412                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    413          {
    414              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    415              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    416              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    417              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    418              psa_status_t status;
    419              mbedtls_pk_context key;
    420              int key_len;
    421              unsigned char buf[MBEDTLS_PK_RSA_PRV_DER_MAX_BYTES];
    422          
    423              ((void) f_rng);
    424              ((void) p_rng);
    425          
    426          #if !defined(MBEDTLS_RSA_ALT)
    427              if (rsa->padding != MBEDTLS_RSA_PKCS_V15) {
    428                  return MBEDTLS_ERR_RSA_INVALID_PADDING;
    429              }
    430          #endif /* !MBEDTLS_RSA_ALT */
    431          
    432              if (ilen != mbedtls_rsa_get_len(rsa)) {
    433                  return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
    434              }
    435          
    436              /* mbedtls_pk_write_key_der() expects a full PK context;
    437               * re-construct one to make it happy */
    438              key.pk_info = &mbedtls_rsa_info;
    439              key.pk_ctx = rsa;
    440              key_len = mbedtls_pk_write_key_der(&key, buf, sizeof(buf));
    441              if (key_len <= 0) {
    442                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    443              }
    444          
    445              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_KEY_PAIR);
    446              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);
    447              psa_set_key_algorithm(&attributes, PSA_ALG_RSA_PKCS1V15_CRYPT);
    448          
    449              status = psa_import_key(&attributes,
    450                                      buf + sizeof(buf) - key_len, key_len,
    451                                      &key_id);
    452              if (status != PSA_SUCCESS) {
    453                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    454                  goto cleanup;
    455              }
    456          
    457              status = psa_asymmetric_decrypt(key_id, PSA_ALG_RSA_PKCS1V15_CRYPT,
    458                                              input, ilen,
    459                                              NULL, 0,
    460                                              output, osize, olen);
    461              if (status != PSA_SUCCESS) {
    462                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    463                  goto cleanup;
    464              }
    465          
    466              ret = 0;
    467          
    468          cleanup:
    469              mbedtls_platform_zeroize(buf, sizeof(buf));
    470              status = psa_destroy_key(key_id);
    471              if (ret == 0 && status != PSA_SUCCESS) {
    472                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    473              }
    474          
    475              return ret;
    476          }
    477          #else /* MBEDTLS_USE_PSA_CRYPTO */
    478          static int rsa_decrypt_wrap(mbedtls_pk_context *pk,
    479                                      const unsigned char *input, size_t ilen,
    480                                      unsigned char *output, size_t *olen, size_t osize,
    481                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    482          {
    483              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    484          
    485              if (ilen != mbedtls_rsa_get_len(rsa)) {
    486                  return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
    487              }
    488          
    489              return mbedtls_rsa_pkcs1_decrypt(rsa, f_rng, p_rng,
    490                                               olen, input, output, osize);
    491          }
    492          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    493          
    494          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    495          static int rsa_encrypt_wrap(mbedtls_pk_context *pk,
    496                                      const unsigned char *input, size_t ilen,
    497                                      unsigned char *output, size_t *olen, size_t osize,
    498                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    499          {
    500              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    501              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    502              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    503              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    504              psa_status_t status;
    505              mbedtls_pk_context key;
    506              int key_len;
    507              unsigned char buf[MBEDTLS_PK_RSA_PUB_DER_MAX_BYTES];
    508          
    509              ((void) f_rng);
    510              ((void) p_rng);
    511          
    512          #if !defined(MBEDTLS_RSA_ALT)
    513              if (rsa->padding != MBEDTLS_RSA_PKCS_V15) {
    514                  return MBEDTLS_ERR_RSA_INVALID_PADDING;
    515              }
    516          #endif
    517          
    518              if (mbedtls_rsa_get_len(rsa) > osize) {
    519                  return MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    520              }
    521          
    522              /* mbedtls_pk_write_pubkey_der() expects a full PK context;
    523               * re-construct one to make it happy */
    524              key.pk_info = &mbedtls_rsa_info;
    525              key.pk_ctx = rsa;
    526              key_len = mbedtls_pk_write_pubkey_der(&key, buf, sizeof(buf));
    527              if (key_len <= 0) {
    528                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    529              }
    530          
    531              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);
    532              psa_set_key_algorithm(&attributes, PSA_ALG_RSA_PKCS1V15_CRYPT);
    533              psa_set_key_type(&attributes, PSA_KEY_TYPE_RSA_PUBLIC_KEY);
    534          
    535              status = psa_import_key(&attributes,
    536                                      buf + sizeof(buf) - key_len, key_len,
    537                                      &key_id);
    538              if (status != PSA_SUCCESS) {
    539                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    540                  goto cleanup;
    541              }
    542          
    543              status = psa_asymmetric_encrypt(key_id, PSA_ALG_RSA_PKCS1V15_CRYPT,
    544                                              input, ilen,
    545                                              NULL, 0,
    546                                              output, osize, olen);
    547              if (status != PSA_SUCCESS) {
    548                  ret = PSA_PK_RSA_TO_MBEDTLS_ERR(status);
    549                  goto cleanup;
    550              }
    551          
    552              ret = 0;
    553          
    554          cleanup:
    555              status = psa_destroy_key(key_id);
    556              if (ret == 0 && status != PSA_SUCCESS) {
    557                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
    558              }
    559          
    560              return ret;
    561          }
    562          #else /* MBEDTLS_USE_PSA_CRYPTO */
    563          static int rsa_encrypt_wrap(mbedtls_pk_context *pk,
    564                                      const unsigned char *input, size_t ilen,
    565                                      unsigned char *output, size_t *olen, size_t osize,
    566                                      int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
    567          {
    568              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    569              *olen = mbedtls_rsa_get_len(rsa);
    570          
    571              if (*olen > osize) {
    572                  return MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    573              }
    574          
    575              return mbedtls_rsa_pkcs1_encrypt(rsa, f_rng, p_rng,
    576                                               ilen, input, output);
    577          }
    578          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    579          
    580          static int rsa_check_pair_wrap(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
    581                                         int (*f_rng)(void *, unsigned char *, size_t),
    582                                         void *p_rng)
    583          {
    584              (void) f_rng;
    585              (void) p_rng;
    586              return mbedtls_rsa_check_pub_priv((const mbedtls_rsa_context *) pub->pk_ctx,
    587                                                (const mbedtls_rsa_context *) prv->pk_ctx);
    588          }
    589          
    590          static void *rsa_alloc_wrap(void)
    591          {
    592              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_rsa_context));
    593          
    594              if (ctx != NULL) {
    595                  mbedtls_rsa_init((mbedtls_rsa_context *) ctx);
    596              }
    597          
    598              return ctx;
    599          }
    600          
    601          static void rsa_free_wrap(void *ctx)
    602          {
    603              mbedtls_rsa_free((mbedtls_rsa_context *) ctx);
    604              mbedtls_free(ctx);
    605          }
    606          
    607          static void rsa_debug(mbedtls_pk_context *pk, mbedtls_pk_debug_item *items)
    608          {
    609          #if defined(MBEDTLS_RSA_ALT)
    610              /* Not supported */
    611              (void) pk;
    612              (void) items;
    613          #else
    614              mbedtls_rsa_context *rsa = (mbedtls_rsa_context *) pk->pk_ctx;
    615          
    616              items->type = MBEDTLS_PK_DEBUG_MPI;
    617              items->name = "rsa.N";
    618              items->value = &(rsa->N);
    619          
    620              items++;
    621          
    622              items->type = MBEDTLS_PK_DEBUG_MPI;
    623              items->name = "rsa.E";
    624              items->value = &(rsa->E);
    625          #endif
    626          }
    627          
    628          const mbedtls_pk_info_t mbedtls_rsa_info = {
    629              .type = MBEDTLS_PK_RSA,
    630              .name = "RSA",
    631              .get_bitlen = rsa_get_bitlen,
    632              .can_do = rsa_can_do,
    633              .verify_func = rsa_verify_wrap,
    634              .sign_func = rsa_sign_wrap,
    635          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
    636              .verify_rs_func = NULL,
    637              .sign_rs_func = NULL,
    638              .rs_alloc_func = NULL,
    639              .rs_free_func = NULL,
    640          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
    641              .decrypt_func = rsa_decrypt_wrap,
    642              .encrypt_func = rsa_encrypt_wrap,
    643              .check_pair_func = rsa_check_pair_wrap,
    644              .ctx_alloc_func = rsa_alloc_wrap,
    645              .ctx_free_func = rsa_free_wrap,
    646              .debug_func = rsa_debug,
    647          };
    648          #endif /* MBEDTLS_RSA_C */
    649          
    650          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    651          /*
    652           * Generic EC key
    653           */

   \                                 In section .text, align 2, keep-with-next
    654          static int eckey_can_do(mbedtls_pk_type_t type)
    655          {
    656              return type == MBEDTLS_PK_ECKEY ||
    657                     type == MBEDTLS_PK_ECKEY_DH ||
    658                     type == MBEDTLS_PK_ECDSA;
   \                     eckey_can_do: (+1)
   \        0x0   0x2802             CMP      R0,#+2
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x2803             CMPNE    R0,#+3
   \        0x6   0x2804             CMPNE    R0,#+4
   \        0x8   0xD101             BNE.N    ??eckey_can_do_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??eckey_can_do_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
    659          }
    660          

   \                                 In section .text, align 2, keep-with-next
    661          static size_t eckey_get_bitlen(mbedtls_pk_context *pk)
    662          {
    663          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
    664              return pk->ec_bits;
    665          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
    666              mbedtls_ecp_keypair *ecp = (mbedtls_ecp_keypair *) pk->pk_ctx;
    667              return ecp->grp.pbits;
   \                     eckey_get_bitlen: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x6BC0             LDR      R0,[R0, #+60]
   \        0x4   0x4770             BX       LR
    668          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
    669          }
    670          
    671          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
    672          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    673          /*
    674           * An ASN.1 encoded signature is a sequence of two ASN.1 integers. Parse one of
    675           * those integers and convert it to the fixed-length encoding expected by PSA.
    676           */

   \                                 In section .text, align 2, keep-with-next
    677          static int extract_ecdsa_sig_int(unsigned char **from, const unsigned char *end,
    678                                           unsigned char *to, size_t to_len)
    679          {
   \                     extract_ecdsa_sig_int: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x461E             MOV      R6,R3
   \        0x6   0x4604             MOV      R4,R0
    680              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    681              size_t unpadded_len, padding_len;
    682          
    683              if ((ret = mbedtls_asn1_get_tag(from, end, &unpadded_len,
    684                                              MBEDTLS_ASN1_INTEGER)) != 0) {
   \        0x8   0x2302             MOVS     R3,#+2
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x10   0xB128             CBZ.N    R0,??extract_ecdsa_sig_int_0
    685                  return ret;
   \       0x12   0xBD76             POP      {R1,R2,R4-R6,PC}
    686              }
    687          
    688              while (unpadded_len > 0 && **from == 0x00) {
    689                  (*from)++;
   \                     ??extract_ecdsa_sig_int_1: (+1)
   \       0x14   0x1C49             ADDS     R1,R1,#+1
   \       0x16   0x6021             STR      R1,[R4, #+0]
    690                  unpadded_len--;
   \       0x18   0x9800             LDR      R0,[SP, #+0]
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0x9000             STR      R0,[SP, #+0]
    691              }
   \                     ??extract_ecdsa_sig_int_0: (+1)
   \       0x1E   0x9800             LDR      R0,[SP, #+0]
   \       0x20   0xB1B0             CBZ.N    R0,??extract_ecdsa_sig_int_2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x7808             LDRB     R0,[R1, #+0]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD0F4             BEQ.N    ??extract_ecdsa_sig_int_1
    692          
    693              if (unpadded_len > to_len || unpadded_len == 0) {
   \       0x2A   0x9900             LDR      R1,[SP, #+0]
   \       0x2C   0x428E             CMP      R6,R1
   \       0x2E   0xD30F             BCC.N    ??extract_ecdsa_sig_int_2
    694                  return MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
    695              }
    696          
    697              padding_len = to_len - unpadded_len;
   \       0x30   0x1A76             SUBS     R6,R6,R1
    698              memset(to, 0x00, padding_len);
   \       0x32   0x4631             MOV      R1,R6
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       __aeabi_memclr
    699              memcpy(to + padding_len, *from, unpadded_len);
   \       0x3A   0x9A00             LDR      R2,[SP, #+0]
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x19A8             ADDS     R0,R5,R6
   \       0x40   0x.... 0x....      BL       __aeabi_memcpy
    700              (*from) += unpadded_len;
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x4408             ADD      R0,R1,R0
   \       0x4A   0x6020             STR      R0,[R4, #+0]
    701          
    702              return 0;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??extract_ecdsa_sig_int_2: (+1)
   \       0x50   0xF06F 0x0065      MVN      R0,#+101
   \       0x54   0xBD76             POP      {R1,R2,R4-R6,PC}
    703          }
    704          
    705          /*
    706           * Convert a signature from an ASN.1 sequence of two integers
    707           * to a raw {r,s} buffer. Note: the provided sig buffer must be at least
    708           * twice as big as int_size.
    709           */
    710          static int extract_ecdsa_sig(unsigned char **p, const unsigned char *end,
    711                                       unsigned char *sig, size_t int_size)
    712          {
    713              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    714              size_t tmp_size;
    715          
    716              if ((ret = mbedtls_asn1_get_tag(p, end, &tmp_size,
    717                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    718                  return ret;
    719              }
    720          
    721              /* Extract r */
    722              if ((ret = extract_ecdsa_sig_int(p, end, sig, int_size)) != 0) {
    723                  return ret;
    724              }
    725              /* Extract s */
    726              if ((ret = extract_ecdsa_sig_int(p, end, sig + int_size, int_size)) != 0) {
    727                  return ret;
    728              }
    729          
    730              return 0;
    731          }
    732          
    733          /* Common helper for ECDSA verify using PSA functions. */

   \                                 In section .text, align 2, keep-with-next
    734          static int ecdsa_verify_psa(unsigned char *key, size_t key_len,
    735                                      psa_ecc_family_t curve, size_t curve_bits,
    736                                      const unsigned char *hash, size_t hash_len,
    737                                      const unsigned char *sig, size_t sig_len)
    738          {
   \                     ecdsa_verify_psa: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB09D             SUB      SP,SP,#+116
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461C             MOV      R4,R3
    739              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    740              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    741              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
    742              psa_algorithm_t psa_sig_md = PSA_ALG_ECDSA_ANY;
    743              size_t signature_len = PSA_ECDSA_SIGNATURE_SIZE(curve_bits);
   \        0xE   0x1DE4             ADDS     R4,R4,#+7
   \       0x10   0xA804             ADD      R0,SP,#+16
   \       0x12   0x2124             MOVS     R1,#+36
   \       0x14   0x08E4             LSRS     R4,R4,#+3
   \       0x16   0x.... 0x....      BL       __aeabi_memclr4
   \       0x1A   0x2700             MOVS     R7,#+0
   \       0x1C   0x0066             LSLS     R6,R4,#+1
   \       0x1E   0x9703             STR      R7,[SP, #+12]
    744              unsigned char extracted_sig[PSA_VENDOR_ECDSA_SIGNATURE_MAX_SIZE];
    745              unsigned char *p;
    746              psa_status_t status;
    747          
    748              if (curve == 0) {
   \       0x20   0x.... 0x....      LDR.W    R4,??DataTable13_9
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0xD05A             BEQ.N    ??ecdsa_verify_psa_0
    749                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    750              }
    751          
    752              psa_set_key_type(&attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(curve));
   \       0x28   0xF445 0x4182      ORR      R1,R5,#0x4100
   \       0x2C   0xA804             ADD      R0,SP,#+16
   \       0x2E   0x.... 0x....      BL       psa_set_key_type
    753              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_VERIFY_HASH);
   \       0x32   0xF44F 0x5100      MOV      R1,#+8192
   \       0x36   0xA804             ADD      R0,SP,#+16
   \       0x38   0x.... 0x....      BL       psa_set_key_usage_flags
    754              psa_set_key_algorithm(&attributes, psa_sig_md);
   \       0x3C   0xF04F 0x2106      MOV      R1,#+100664832
   \       0x40   0xA804             ADD      R0,SP,#+16
   \       0x42   0x.... 0x....      BL       psa_set_key_algorithm
    755          
    756              status = psa_import_key(&attributes, key, key_len, &key_id);
   \       0x46   0xAB03             ADD      R3,SP,#+12
   \       0x48   0x464A             MOV      R2,R9
   \       0x4A   0x4641             MOV      R1,R8
   \       0x4C   0xA804             ADD      R0,SP,#+16
   \       0x4E   0x.... 0x....      BL       psa_import_key
    757              if (status != PSA_SUCCESS) {
   \       0x52   0xB110             CBZ.N    R0,??ecdsa_verify_psa_1
    758                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0x54   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0x58   0xE032             B.N      ??ecdsa_verify_psa_2
    759                  goto cleanup;
    760              }
    761          
    762              if (signature_len > sizeof(extracted_sig)) {
   \                     ??ecdsa_verify_psa_1: (+1)
   \       0x5A   0x2E41             CMP      R6,#+65
   \       0x5C   0xD237             BCS.N    ??ecdsa_verify_psa_3
    763                  ret = MBEDTLS_ERR_PK_BAD_INPUT_DATA;
    764                  goto cleanup;
   \       0x5E   0x9827             LDR      R0,[SP, #+156]
   \       0x60   0x9926             LDR      R1,[SP, #+152]
    765              }
    766          
    767              p = (unsigned char *) sig;
   \       0x62   0x9102             STR      R1,[SP, #+8]
    768              /* extract_ecdsa_sig's last parameter is the size
    769               * of each integer to be parsed, so it's actually half
    770               * the size of the signature. */
    771              if ((ret = extract_ecdsa_sig(&p, sig + sig_len, extracted_sig,
    772                                           signature_len/2)) != 0) {
   \       0x64   0x2330             MOVS     R3,#+48
   \       0x66   0x180D             ADDS     R5,R1,R0
   \       0x68   0x466A             MOV      R2,SP
   \       0x6A   0x4629             MOV      R1,R5
   \       0x6C   0xA802             ADD      R0,SP,#+8
   \       0x6E   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x72   0x0004             MOVS     R4,R0
   \       0x74   0xD12B             BNE.N    ??ecdsa_verify_psa_3
   \       0x76   0x0873             LSRS     R3,R6,#+1
   \       0x78   0xAA0D             ADD      R2,SP,#+52
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0xA802             ADD      R0,SP,#+8
   \       0x7E   0x.... 0x....      BL       extract_ecdsa_sig_int
   \       0x82   0x0004             MOVS     R4,R0
   \       0x84   0xD123             BNE.N    ??ecdsa_verify_psa_3
   \       0x86   0xA80D             ADD      R0,SP,#+52
   \       0x88   0xEB00 0x0256      ADD      R2,R0,R6, LSR #+1
   \       0x8C   0x0873             LSRS     R3,R6,#+1
   \       0x8E   0x4629             MOV      R1,R5
   \       0x90   0xA802             ADD      R0,SP,#+8
   \       0x92   0x.... 0x....      BL       extract_ecdsa_sig_int
   \       0x96   0x0004             MOVS     R4,R0
   \       0x98   0xD119             BNE.N    ??ecdsa_verify_psa_3
    773                  goto cleanup;
    774              }
    775          
    776              status = psa_verify_hash(key_id, psa_sig_md, hash, hash_len,
    777                                       extracted_sig, signature_len);
   \       0x9A   0xA80D             ADD      R0,SP,#+52
   \       0x9C   0x9000             STR      R0,[SP, #+0]
   \       0x9E   0x9B25             LDR      R3,[SP, #+148]
   \       0xA0   0x9A24             LDR      R2,[SP, #+144]
   \       0xA2   0x9803             LDR      R0,[SP, #+12]
   \       0xA4   0x9601             STR      R6,[SP, #+4]
   \       0xA6   0xF04F 0x2106      MOV      R1,#+100664832
   \       0xAA   0x2400             MOVS     R4,#+0
   \       0xAC   0x.... 0x....      BL       psa_verify_hash
    778              if (status != PSA_SUCCESS) {
   \       0xB0   0xB140             CBZ.N    R0,??ecdsa_verify_psa_4
    779                  ret = PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \       0xB2   0x.... 0x....      LDR.W    R3,??DataTable13_11
   \       0xB6   0x2207             MOVS     R2,#+7
   \       0xB8   0x.... 0x....      LDR.W    R1,??DataTable13_12
   \       0xBC   0x.... 0x....      BL       psa_status_to_mbedtls
   \                     ??ecdsa_verify_psa_2: (+1)
   \       0xC0   0x4604             MOV      R4,R0
    780                  goto cleanup;
   \       0xC2   0xE004             B.N      ??ecdsa_verify_psa_3
    781              }
    782          
    783              if (p != sig + sig_len) {
   \                     ??ecdsa_verify_psa_4: (+1)
   \       0xC4   0x9802             LDR      R0,[SP, #+8]
   \       0xC6   0x42A8             CMP      R0,R5
   \       0xC8   0xBF18             IT       NE
   \       0xCA   0x.... 0x....      LDRNE.W  R4,??DataTable13_13
    784                  ret = MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    785                  goto cleanup;
    786              }
    787              ret = 0;
    788          
    789          cleanup:
    790              status = psa_destroy_key(key_id);
   \                     ??ecdsa_verify_psa_3: (+1)
   \       0xCE   0x9803             LDR      R0,[SP, #+12]
   \       0xD0   0x.... 0x....      BL       psa_destroy_key
    791              if (ret == 0 && status != PSA_SUCCESS) {
   \       0xD4   0xB91C             CBNZ.N   R4,??ecdsa_verify_psa_0
   \       0xD6   0xB110             CBZ.N    R0,??ecdsa_verify_psa_0
    792                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xD8   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xDC   0x4604             MOV      R4,R0
    793              }
    794          
    795              return ret;
   \                     ??ecdsa_verify_psa_0: (+1)
   \       0xDE   0x4620             MOV      R0,R4
   \       0xE0   0xB01D             ADD      SP,SP,#+116
   \       0xE2   0xE8BD 0x83F0      POP      {R4-R9,PC}
    796          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    797          

   \                                 In section .text, align 2, keep-with-next
    798          static int ecdsa_opaque_verify_wrap(mbedtls_pk_context *pk,
    799                                              mbedtls_md_type_t md_alg,
    800                                              const unsigned char *hash, size_t hash_len,
    801                                              const unsigned char *sig, size_t sig_len)
    802          {
   \                     ecdsa_opaque_verify_wrap: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB09F             SUB      SP,SP,#+124
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
    803              (void) md_alg;
    804              unsigned char key[MBEDTLS_PK_MAX_EC_PUBKEY_RAW_LEN];
    805              size_t key_len;
    806              psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;
   \        0xC   0xA805             ADD      R0,SP,#+20
   \        0xE   0x.... 0x....      BL       ?Subroutine7
    807              psa_ecc_family_t curve;
    808              size_t curve_bits;
    809              psa_status_t status;
    810          
    811              status = psa_get_key_attributes(pk->priv_id, &key_attr);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x12   0x68B0             LDR      R0,[R6, #+8]
   \       0x14   0xA905             ADD      R1,SP,#+20
   \       0x16   0x.... 0x....      LDR.W    R10,??DataTable13_12
   \       0x1A   0x.... 0x....      BL       psa_get_key_attributes
    812              if (status != PSA_SUCCESS) {
   \       0x1E   0x.... 0x....      LDR.W    R8,??DataTable13_11
   \       0x22   0xB9B0             CBNZ.N   R0,??ecdsa_opaque_verify_wrap_0
    813                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
    814              }
    815              curve = PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(&key_attr));
   \       0x24   0xF8BD 0x1014      LDRH     R1,[SP, #+20]
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable13_14
   \       0x2C   0x4001             ANDS     R1,R0,R1
   \       0x2E   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x32   0xBF0C             ITE      EQ
   \       0x34   0xF8BD 0x7014      LDRHEQ   R7,[SP, #+20]
   \       0x38   0x2700             MOVNE    R7,#+0
    816              curve_bits = psa_get_key_bits(&key_attr);
   \       0x3A   0xF8BD 0x9016      LDRH     R9,[SP, #+22]
    817              psa_reset_key_attributes(&key_attr);
   \       0x3E   0xA805             ADD      R0,SP,#+20
   \       0x40   0x.... 0x....      BL       psa_reset_key_attributes
    818          
    819              status = psa_export_public_key(pk->priv_id, key, sizeof(key), &key_len);
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0xAB04             ADD      R3,SP,#+16
   \       0x48   0x2241             MOVS     R2,#+65
   \       0x4A   0xA90E             ADD      R1,SP,#+56
   \       0x4C   0x.... 0x....      BL       psa_export_public_key
    820              if (status != PSA_SUCCESS) {
   \       0x50   0xB128             CBZ.N    R0,??ecdsa_opaque_verify_wrap_1
    821                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \                     ??ecdsa_opaque_verify_wrap_0: (+1)
   \       0x52   0x4643             MOV      R3,R8
   \       0x54   0x2207             MOVS     R2,#+7
   \       0x56   0x4651             MOV      R1,R10
   \       0x58   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0x5C   0xE00B             B.N      ??ecdsa_opaque_verify_wrap_2
    822              }
    823          
    824              return ecdsa_verify_psa(key, key_len, curve, curve_bits,
    825                                      hash, hash_len, sig, sig_len);
   \                     ??ecdsa_opaque_verify_wrap_1: (+1)
   \       0x5E   0x9929             LDR      R1,[SP, #+164]
   \       0x60   0x9828             LDR      R0,[SP, #+160]
   \       0x62   0x9501             STR      R5,[SP, #+4]
   \       0x64   0x9103             STR      R1,[SP, #+12]
   \       0x66   0x9904             LDR      R1,[SP, #+16]
   \       0x68   0x9002             STR      R0,[SP, #+8]
   \       0x6A   0x9400             STR      R4,[SP, #+0]
   \       0x6C   0x464B             MOV      R3,R9
   \       0x6E   0xB2FA             UXTB     R2,R7
   \       0x70   0xA80E             ADD      R0,SP,#+56
   \       0x72   0x.... 0x....      BL       ecdsa_verify_psa
   \                     ??ecdsa_opaque_verify_wrap_2: (+1)
   \       0x76   0xB020             ADD      SP,SP,#+128
   \       0x78   0xE8BD 0x87F0      POP      {R4-R10,PC}
    826          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2124             MOVS     R1,#+36
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
    827          
    828          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
    829          static int ecdsa_verify_wrap(mbedtls_pk_context *pk,
    830                                       mbedtls_md_type_t md_alg,
    831                                       const unsigned char *hash, size_t hash_len,
    832                                       const unsigned char *sig, size_t sig_len)
    833          {
    834              (void) md_alg;
    835              psa_ecc_family_t curve = pk->ec_family;
    836              size_t curve_bits = pk->ec_bits;
    837          
    838              return ecdsa_verify_psa(pk->pub_raw, pk->pub_raw_len, curve, curve_bits,
    839                                      hash, hash_len, sig, sig_len);
    840          }
    841          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
    842          static int ecdsa_verify_wrap(mbedtls_pk_context *pk,
    843                                       mbedtls_md_type_t md_alg,
    844                                       const unsigned char *hash, size_t hash_len,
    845                                       const unsigned char *sig, size_t sig_len)
    846          {
   \                     ecdsa_verify_wrap: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB097             SUB      SP,SP,#+92
    847              (void) md_alg;
    848              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    849              mbedtls_ecp_keypair *ctx = pk->pk_ctx;
   \        0x4   0x6847             LDR      R7,[R0, #+4]
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461D             MOV      R5,R3
    850              unsigned char key[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
    851              size_t key_len;
    852              size_t curve_bits;
    853              psa_ecc_family_t curve = mbedtls_ecc_group_to_psa(ctx->grp.id, &curve_bits);
   \        0xA   0x7838             LDRB     R0,[R7, #+0]
   \        0xC   0xA904             ADD      R1,SP,#+16
   \        0xE   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   \       0x12   0x4606             MOV      R6,R0
    854          
    855              ret = mbedtls_ecp_point_write_binary(&ctx->grp, &ctx->Q,
    856                                                   MBEDTLS_ECP_PF_UNCOMPRESSED,
    857                                                   &key_len, key, sizeof(key));
   \       0x14   0x2141             MOVS     R1,#+65
   \       0x16   0xA806             ADD      R0,SP,#+24
   \       0x18   0x9101             STR      R1,[SP, #+4]
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0xAB05             ADD      R3,SP,#+20
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0xF107 0x0168      ADD      R1,R7,#+104
   \       0x24   0x4638             MOV      R0,R7
   \       0x26   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
    858              if (ret != 0) {
   \       0x2A   0xB958             CBNZ.N   R0,??ecdsa_verify_wrap_0
    859                  return ret;
    860              }
    861          
    862              return ecdsa_verify_psa(key, key_len, curve, curve_bits,
    863                                      hash, hash_len, sig, sig_len);
   \       0x2C   0x991D             LDR      R1,[SP, #+116]
   \       0x2E   0x981C             LDR      R0,[SP, #+112]
   \       0x30   0x9B04             LDR      R3,[SP, #+16]
   \       0x32   0x9103             STR      R1,[SP, #+12]
   \       0x34   0x9905             LDR      R1,[SP, #+20]
   \       0x36   0x9002             STR      R0,[SP, #+8]
   \       0x38   0x9501             STR      R5,[SP, #+4]
   \       0x3A   0x9400             STR      R4,[SP, #+0]
   \       0x3C   0x4632             MOV      R2,R6
   \       0x3E   0xA806             ADD      R0,SP,#+24
   \       0x40   0x.... 0x....      BL       ecdsa_verify_psa
   \                     ??ecdsa_verify_wrap_0: (+1)
   \       0x44   0xB017             ADD      SP,SP,#+92
   \       0x46   0xBDF0             POP      {R4-R7,PC}
    864          }
    865          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
    866          #else /* MBEDTLS_USE_PSA_CRYPTO */
    867          static int ecdsa_verify_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
    868                                       const unsigned char *hash, size_t hash_len,
    869                                       const unsigned char *sig, size_t sig_len)
    870          {
    871              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    872              ((void) md_alg);
    873          
    874              ret = mbedtls_ecdsa_read_signature((mbedtls_ecdsa_context *) pk->pk_ctx,
    875                                                 hash, hash_len, sig, sig_len);
    876          
    877              if (ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) {
    878                  return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
    879              }
    880          
    881              return ret;
    882          }
    883          #endif /* MBEDTLS_USE_PSA_CRYPTO */
    884          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
    885          
    886          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
    887          #if defined(MBEDTLS_USE_PSA_CRYPTO)
    888          /*
    889           * Simultaneously convert and move raw MPI from the beginning of a buffer
    890           * to an ASN.1 MPI at the end of the buffer.
    891           * See also mbedtls_asn1_write_mpi().
    892           *
    893           * p: pointer to the end of the output buffer
    894           * start: start of the output buffer, and also of the mpi to write at the end
    895           * n_len: length of the mpi to read from start
    896           */

   \                                 In section .text, align 2, keep-with-next
    897          static int asn1_write_mpibuf(unsigned char **p, unsigned char *start,
    898                                       size_t n_len)
    899          {
   \                     asn1_write_mpibuf: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
    900              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    901              size_t len = 0;
    902          
    903              if ((size_t) (*p - start) < n_len) {
   \        0x4   0x6828             LDR      R0,[R5, #+0]
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x1B81             SUBS     R1,R0,R6
   \        0xC   0x42A1             CMP      R1,R4
   \        0xE   0xD316             BCC.N    ??asn1_write_mpibuf_0
    904                  return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
    905              }
    906          
    907              len = n_len;
    908              *p -= len;
    909              memmove(*p, start, len);
   \       0x10   0x4261             RSBS     R1,R4,#+0
   \       0x12   0x4408             ADD      R0,R0,R1
   \       0x14   0x6028             STR      R0,[R5, #+0]
   \       0x16   0x4631             MOV      R1,R6
   \       0x18   0x.... 0x....      BL       __aeabi_memmove
   \       0x1C   0xE005             B.N      ??asn1_write_mpibuf_1
    910          
    911              /* ASN.1 DER encoding requires minimal length, so skip leading 0s.
    912               * Neither r nor s should be 0, but as a failsafe measure, still detect
    913               * that rather than overflowing the buffer in case of a PSA error. */
    914              while (len > 0 && **p == 0x00) {
   \                     ??asn1_write_mpibuf_2: (+1)
   \       0x1E   0x6829             LDR      R1,[R5, #+0]
   \       0x20   0x7808             LDRB     R0,[R1, #+0]
   \       0x22   0xB938             CBNZ.N   R0,??asn1_write_mpibuf_3
    915                  ++(*p);
   \       0x24   0x1C48             ADDS     R0,R1,#+1
   \       0x26   0x6028             STR      R0,[R5, #+0]
    916                  --len;
   \       0x28   0x1E64             SUBS     R4,R4,#+1
    917              }
   \                     ??asn1_write_mpibuf_1: (+1)
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD1F7             BNE.N    ??asn1_write_mpibuf_2
    918          
    919              /* this is only reached if the signature was invalid */
    920              if (len == 0) {
    921                  return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   \       0x2E   0xF06F 0x006F      MVN      R0,#+111
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}
    922              }
    923          
    924              /* if the msb is 1, ASN.1 requires that we prepend a 0.
    925               * Neither r nor s can be 0, so we can assume len > 0 at all times. */
    926              if (**p & 0x80) {
   \                     ??asn1_write_mpibuf_3: (+1)
   \       0x34   0x0600             LSLS     R0,R0,#+24
   \       0x36   0xD50A             BPL.N    ??asn1_write_mpibuf_4
    927                  if (*p - start < 1) {
   \       0x38   0x1B8F             SUBS     R7,R1,R6
   \       0x3A   0x2F00             CMP      R7,#+0
   \       0x3C   0xDC02             BGT.N    ??asn1_write_mpibuf_5
    928                      return MBEDTLS_ERR_ASN1_BUF_TOO_SMALL;
   \                     ??asn1_write_mpibuf_0: (+1)
   \       0x3E   0xF06F 0x006B      MVN      R0,#+107
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
    929                  }
    930          
    931                  *--(*p) = 0x00;
   \                     ??asn1_write_mpibuf_5: (+1)
   \       0x44   0x1E49             SUBS     R1,R1,#+1
   \       0x46   0x6029             STR      R1,[R5, #+0]
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x7008             STRB     R0,[R1, #+0]
    932                  len += 1;
   \       0x4C   0x1C64             ADDS     R4,R4,#+1
    933              }
    934          
    935              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(p, start, len));
   \                     ??asn1_write_mpibuf_4: (+1)
   \       0x4E   0x4622             MOV      R2,R4
   \       0x50   0x4631             MOV      R1,R6
   \       0x52   0x4628             MOV      R0,R5
   \       0x54   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0x58   0x0007             MOVS     R7,R0
   \       0x5A   0xD408             BMI.N    ??asn1_write_mpibuf_6
    936              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(p, start,
    937                                                               MBEDTLS_ASN1_INTEGER));
   \       0x5C   0x2202             MOVS     R2,#+2
   \       0x5E   0x4631             MOV      R1,R6
   \       0x60   0x4628             MOV      R0,R5
   \       0x62   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xBF5C             ITT      PL
   \       0x6A   0x193C             ADDPL    R4,R7,R4
   \       0x6C   0x1900             ADDPL    R0,R0,R4
    938          
    939              return (int) len;
   \                     ??asn1_write_mpibuf_6: (+1)
   \       0x6E   0xBDF2             POP      {R1,R4-R7,PC}
    940          }
    941          
    942          /* Transcode signature from PSA format to ASN.1 sequence.
    943           * See ecdsa_signature_to_asn1 in ecdsa.c, but with byte buffers instead of
    944           * MPIs, and in-place.
    945           *
    946           * [in/out] sig: the signature pre- and post-transcoding
    947           * [in/out] sig_len: signature length pre- and post-transcoding
    948           * [int] buf_len: the available size the in/out buffer
    949           */
    950          static int pk_ecdsa_sig_asn1_from_psa(unsigned char *sig, size_t *sig_len,
    951                                                size_t buf_len)
    952          {
    953              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    954              size_t len = 0;
    955              const size_t rs_len = *sig_len / 2;
    956              unsigned char *p = sig + buf_len;
    957          
    958              MBEDTLS_ASN1_CHK_ADD(len, asn1_write_mpibuf(&p, sig + rs_len, rs_len));
    959              MBEDTLS_ASN1_CHK_ADD(len, asn1_write_mpibuf(&p, sig, rs_len));
    960          
    961              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_len(&p, sig, len));
    962              MBEDTLS_ASN1_CHK_ADD(len, mbedtls_asn1_write_tag(&p, sig,
    963                                                               MBEDTLS_ASN1_CONSTRUCTED |
    964                                                               MBEDTLS_ASN1_SEQUENCE));
    965          
    966              memmove(sig, p, len);
    967              *sig_len = len;
    968          
    969              return 0;
    970          }
    971          
    972          /* Common helper for ECDSA sign using PSA functions. */

   \                                 In section .text, align 2, keep-with-next
    973          static int ecdsa_sign_psa(mbedtls_svc_key_id_t key_id, mbedtls_md_type_t md_alg,
    974                                    const unsigned char *hash, size_t hash_len,
    975                                    unsigned char *sig, size_t sig_size, size_t *sig_len)
    976          {
   \                     ecdsa_sign_psa: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x469B             MOV      R11,R3
    977              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    978              psa_status_t status;
    979              psa_algorithm_t psa_sig_md;
    980              psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;
   \        0xE   0xA803             ADD      R0,SP,#+12
   \       0x10   0x.... 0x....      BL       ?Subroutine7
    981              psa_algorithm_t alg;
    982          
    983              status = psa_get_key_attributes(key_id, &key_attr);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x14   0xA903             ADD      R1,SP,#+12
   \       0x16   0x4650             MOV      R0,R10
   \       0x18   0x.... 0x....      BL       psa_get_key_attributes
    984              if (status != PSA_SUCCESS) {
   \       0x1C   0x.... 0x....      LDR.W    R8,??DataTable13_12
   \       0x20   0x.... 0x....      LDR.W    R9,??DataTable13_11
   \       0x24   0xB9C8             CBNZ.N   R0,??ecdsa_sign_psa_0
    985                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
    986              }
    987              alg = psa_get_key_algorithm(&key_attr);
   \       0x26   0x9C07             LDR      R4,[SP, #+28]
    988              psa_reset_key_attributes(&key_attr);
   \       0x28   0xA803             ADD      R0,SP,#+12
   \       0x2A   0x.... 0x....      BL       psa_reset_key_attributes
    989          
    990              if (PSA_ALG_IS_DETERMINISTIC_ECDSA(alg)) {
   \       0x2E   0x0A24             LSRS     R4,R4,#+8
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable13_15
   \       0x34   0x0224             LSLS     R4,R4,#+8
   \       0x36   0x4284             CMP      R4,R0
   \       0x38   0xBF0C             ITE      EQ
   \       0x3A   0xEA40 0x0105      ORREQ    R1,R0,R5
   \       0x3E   0xF045 0x2106      ORRNE    R1,R5,#0x6000600
    991                  psa_sig_md = PSA_ALG_DETERMINISTIC_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
    992              } else {
    993                  psa_sig_md = PSA_ALG_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   \       0x42   0x9F18             LDR      R7,[SP, #+96]
   \       0x44   0x9D17             LDR      R5,[SP, #+92]
   \       0x46   0x9C16             LDR      R4,[SP, #+88]
    994              }
    995          
    996              status = psa_sign_hash(key_id, psa_sig_md, hash, hash_len,
    997                                     sig, sig_size, sig_len);
   \       0x48   0x9702             STR      R7,[SP, #+8]
   \       0x4A   0x9501             STR      R5,[SP, #+4]
   \       0x4C   0x465B             MOV      R3,R11
   \       0x4E   0x4632             MOV      R2,R6
   \       0x50   0x9400             STR      R4,[SP, #+0]
   \       0x52   0x4650             MOV      R0,R10
   \       0x54   0x.... 0x....      BL       psa_sign_hash
    998              if (status != PSA_SUCCESS) {
   \       0x58   0xB128             CBZ.N    R0,??ecdsa_sign_psa_1
    999                  return PSA_PK_ECDSA_TO_MBEDTLS_ERR(status);
   \                     ??ecdsa_sign_psa_0: (+1)
   \       0x5A   0x464B             MOV      R3,R9
   \       0x5C   0x2207             MOVS     R2,#+7
   \       0x5E   0x4641             MOV      R1,R8
   \       0x60   0x.... 0x....      BL       psa_status_to_mbedtls
   \       0x64   0xE031             B.N      ??ecdsa_sign_psa_2
   1000              }
   1001          
   1002              ret = pk_ecdsa_sig_asn1_from_psa(sig, sig_len, sig_size);
   \                     ??ecdsa_sign_psa_1: (+1)
   \       0x66   0x683E             LDR      R6,[R7, #+0]
   \       0x68   0x1960             ADDS     R0,R4,R5
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0xEB04 0x0156      ADD      R1,R4,R6, LSR #+1
   \       0x70   0x0872             LSRS     R2,R6,#+1
   \       0x72   0x4668             MOV      R0,SP
   \       0x74   0x.... 0x....      BL       asn1_write_mpibuf
   \       0x78   0xEA5F 0x0A00      MOVS     R10,R0
   \       0x7C   0xD424             BMI.N    ??ecdsa_sign_psa_3
   \       0x7E   0x0872             LSRS     R2,R6,#+1
   \       0x80   0x4621             MOV      R1,R4
   \       0x82   0x4668             MOV      R0,SP
   \       0x84   0x.... 0x....      BL       asn1_write_mpibuf
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD410             BMI.N    ??ecdsa_sign_psa_4
   \       0x8C   0x4482             ADD      R10,R0,R10
   \       0x8E   0x4652             MOV      R2,R10
   \       0x90   0x4621             MOV      R1,R4
   \       0x92   0x4668             MOV      R0,SP
   \       0x94   0x.... 0x....      BL       mbedtls_asn1_write_len
   \       0x98   0x0005             MOVS     R5,R0
   \       0x9A   0xBF48             IT       MI
   \       0x9C   0x46AA             MOVMI    R10,R5
   \       0x9E   0xD413             BMI.N    ??ecdsa_sign_psa_3
   \       0xA0   0x2230             MOVS     R2,#+48
   \       0xA2   0x4621             MOV      R1,R4
   \       0xA4   0x4668             MOV      R0,SP
   \       0xA6   0x.... 0x....      BL       mbedtls_asn1_write_tag
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD501             BPL.N    ??ecdsa_sign_psa_5
   \                     ??ecdsa_sign_psa_4: (+1)
   \       0xAE   0x4682             MOV      R10,R0
   \       0xB0   0xE00A             B.N      ??ecdsa_sign_psa_3
   \                     ??ecdsa_sign_psa_5: (+1)
   \       0xB2   0x44AA             ADD      R10,R5,R10
   \       0xB4   0x9900             LDR      R1,[SP, #+0]
   \       0xB6   0x4482             ADD      R10,R0,R10
   \       0xB8   0x4652             MOV      R2,R10
   \       0xBA   0x4620             MOV      R0,R4
   \       0xBC   0x.... 0x....      BL       __aeabi_memmove
   \       0xC0   0xF8C7 0xA000      STR      R10,[R7, #+0]
   \       0xC4   0xF04F 0x0A00      MOV      R10,#+0
   1003          
   1004              return ret;
   \                     ??ecdsa_sign_psa_3: (+1)
   \       0xC8   0x4650             MOV      R0,R10
   \                     ??ecdsa_sign_psa_2: (+1)
   \       0xCA   0xB00D             ADD      SP,SP,#+52
   \       0xCC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1005          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          static int ecdsa_opaque_sign_wrap(mbedtls_pk_context *pk,
   1008                                            mbedtls_md_type_t md_alg,
   1009                                            const unsigned char *hash, size_t hash_len,
   1010                                            unsigned char *sig, size_t sig_size,
   1011                                            size_t *sig_len,
   1012                                            int (*f_rng)(void *, unsigned char *, size_t),
   1013                                            void *p_rng)
   1014          {
   \                     ecdsa_opaque_sign_wrap: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   1015              ((void) f_rng);
   1016              ((void) p_rng);
   1017          
   1018              return ecdsa_sign_psa(pk->priv_id, md_alg, hash, hash_len, sig, sig_size,
   1019                                    sig_len);
   \        0x2   0x9C08             LDR      R4,[SP, #+32]
   \        0x4   0x9D07             LDR      R5,[SP, #+28]
   \        0x6   0x9402             STR      R4,[SP, #+8]
   \        0x8   0x9C06             LDR      R4,[SP, #+24]
   \        0xA   0x9501             STR      R5,[SP, #+4]
   \        0xC   0x9400             STR      R4,[SP, #+0]
   \        0xE   0x6880             LDR      R0,[R0, #+8]
   \       0x10   0x.... 0x....      BL       ecdsa_sign_psa
   \       0x14   0xBD3E             POP      {R1-R5,PC}
   1020          }
   1021          
   1022          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1023          /* When PK_USE_PSA_EC_DATA is defined opaque and non-opaque keys end up
   1024           * using the same function. */
   1025          #define ecdsa_sign_wrap     ecdsa_opaque_sign_wrap
   1026          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
   1027          static int ecdsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1028                                     const unsigned char *hash, size_t hash_len,
   1029                                     unsigned char *sig, size_t sig_size, size_t *sig_len,
   1030                                     int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1031          {
   \                     ecdsa_sign_wrap: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4688             MOV      R8,R1
   \        0x6   0xB096             SUB      SP,SP,#+88
   1032              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1033              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x9103             STR      R1,[SP, #+12]
   1034              psa_status_t status;
   1035              mbedtls_ecp_keypair *ctx = pk->pk_ctx;
   \        0xC   0x6844             LDR      R4,[R0, #+4]
   \        0xE   0x4691             MOV      R9,R2
   \       0x10   0x469A             MOV      R10,R3
   1036              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \       0x12   0xA80D             ADD      R0,SP,#+52
   \       0x14   0x.... 0x....      BL       ?Subroutine7
   1037              unsigned char buf[MBEDTLS_PSA_MAX_EC_KEY_PAIR_LENGTH];
   1038              size_t curve_bits;
   1039              psa_ecc_family_t curve =
   1040                  mbedtls_ecc_group_to_psa(ctx->grp.id, &curve_bits);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x18   0x7820             LDRB     R0,[R4, #+0]
   \       0x1A   0xA904             ADD      R1,SP,#+16
   \       0x1C   0xF048 0x2606      ORR      R6,R8,#0x6000600
   \       0x20   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   1041              size_t key_len = PSA_BITS_TO_BYTES(curve_bits);
   \       0x24   0x9F04             LDR      R7,[SP, #+16]
   \       0x26   0x4605             MOV      R5,R0
   \       0x28   0x1DFF             ADDS     R7,R7,#+7
   \       0x2A   0x08FF             LSRS     R7,R7,#+3
   1042          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
   1043              psa_algorithm_t psa_sig_md =
   1044                  PSA_ALG_DETERMINISTIC_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   1045          #else
   1046              psa_algorithm_t psa_sig_md =
   1047                  PSA_ALG_ECDSA(mbedtls_md_psa_alg_from_type(md_alg));
   1048          #endif
   1049              ((void) f_rng);
   1050              ((void) p_rng);
   1051          
   1052              if (curve == 0) {
   \       0x2C   0xB90D             CBNZ.N   R5,??ecdsa_sign_wrap_0
   1053                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \       0x2E   0x....             LDR.N    R0,??DataTable13_9
   \       0x30   0xE03B             B.N      ??ecdsa_sign_wrap_1
   1054              }
   1055          
   1056              if (key_len > sizeof(buf)) {
   \                     ??ecdsa_sign_wrap_0: (+1)
   \       0x32   0x2F20             CMP      R7,#+32
   \       0x34   0xBF88             IT       HI
   \       0x36   0xF06F 0x006D      MVNHI    R0,#+109
   1057                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x3A   0xD836             BHI.N    ??ecdsa_sign_wrap_1
   1058              }
   1059              ret = mbedtls_mpi_write_binary(&ctx->d, buf, key_len);
   \       0x3C   0x463A             MOV      R2,R7
   \       0x3E   0xA905             ADD      R1,SP,#+20
   \       0x40   0xF104 0x0060      ADD      R0,R4,#+96
   \       0x44   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x48   0x0004             MOVS     R4,R0
   1060              if (ret != 0) {
   \       0x4A   0xD121             BNE.N    ??ecdsa_sign_wrap_2
   1061                  goto cleanup;
   1062              }
   1063          
   1064              psa_set_key_type(&attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(curve));
   \       0x4C   0xF445 0x41E2      ORR      R1,R5,#0x7100
   \       0x50   0xA80D             ADD      R0,SP,#+52
   \       0x52   0x.... 0x....      BL       psa_set_key_type
   1065              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_SIGN_HASH);
   \       0x56   0xF44F 0x5180      MOV      R1,#+4096
   \       0x5A   0xA80D             ADD      R0,SP,#+52
   \       0x5C   0x.... 0x....      BL       psa_set_key_usage_flags
   1066              psa_set_key_algorithm(&attributes, psa_sig_md);
   \       0x60   0x9611             STR      R6,[SP, #+68]
   1067          
   1068              status = psa_import_key(&attributes, buf, key_len, &key_id);
   \       0x62   0xAB03             ADD      R3,SP,#+12
   \       0x64   0x463A             MOV      R2,R7
   \       0x66   0xA905             ADD      R1,SP,#+20
   \       0x68   0xA80D             ADD      R0,SP,#+52
   \       0x6A   0x.... 0x....      BL       psa_import_key
   1069              if (status != PSA_SUCCESS) {
   \       0x6E   0xB110             CBZ.N    R0,??ecdsa_sign_wrap_3
   1070                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0x70   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0x74   0xE00B             B.N      ??ecdsa_sign_wrap_4
   1071                  goto cleanup;
   1072              }
   1073          
   1074              ret = ecdsa_sign_psa(key_id, md_alg, hash, hash_len, sig, sig_size, sig_len);
   \                     ??ecdsa_sign_wrap_3: (+1)
   \       0x76   0x9820             LDR      R0,[SP, #+128]
   \       0x78   0x991F             LDR      R1,[SP, #+124]
   \       0x7A   0x4653             MOV      R3,R10
   \       0x7C   0x9002             STR      R0,[SP, #+8]
   \       0x7E   0x981E             LDR      R0,[SP, #+120]
   \       0x80   0x9101             STR      R1,[SP, #+4]
   \       0x82   0x464A             MOV      R2,R9
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x9803             LDR      R0,[SP, #+12]
   \       0x88   0x4641             MOV      R1,R8
   \       0x8A   0x.... 0x....      BL       ecdsa_sign_psa
   \                     ??ecdsa_sign_wrap_4: (+1)
   \       0x8E   0x4604             MOV      R4,R0
   1075          
   1076          cleanup:
   1077              mbedtls_platform_zeroize(buf, sizeof(buf));
   \                     ??ecdsa_sign_wrap_2: (+1)
   \       0x90   0x2120             MOVS     R1,#+32
   \       0x92   0xA805             ADD      R0,SP,#+20
   \       0x94   0x.... 0x....      BL       mbedtls_platform_zeroize
   1078              status = psa_destroy_key(key_id);
   \       0x98   0x9803             LDR      R0,[SP, #+12]
   \       0x9A   0x.... 0x....      BL       psa_destroy_key
   1079              if (ret == 0 && status != PSA_SUCCESS) {
   \       0x9E   0xB91C             CBNZ.N   R4,??ecdsa_sign_wrap_5
   \       0xA0   0xB110             CBZ.N    R0,??ecdsa_sign_wrap_5
   1080                  ret = PSA_PK_TO_MBEDTLS_ERR(status);
   \       0xA2   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xA6   0x4604             MOV      R4,R0
   1081              }
   1082          
   1083              return ret;
   \                     ??ecdsa_sign_wrap_5: (+1)
   \       0xA8   0x4620             MOV      R0,R4
   \                     ??ecdsa_sign_wrap_1: (+1)
   \       0xAA   0xB016             ADD      SP,SP,#+88
   \       0xAC   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1084          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1085          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1086          #else /* MBEDTLS_USE_PSA_CRYPTO */
   1087          static int ecdsa_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1088                                     const unsigned char *hash, size_t hash_len,
   1089                                     unsigned char *sig, size_t sig_size, size_t *sig_len,
   1090                                     int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1091          {
   1092              return mbedtls_ecdsa_write_signature((mbedtls_ecdsa_context *) pk->pk_ctx,
   1093                                                   md_alg, hash, hash_len,
   1094                                                   sig, sig_size, sig_len,
   1095                                                   f_rng, p_rng);
   1096          }
   1097          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1098          #endif /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1099          
   1100          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1101          /* Forward declarations */
   1102          static int ecdsa_verify_rs_wrap(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
   1103                                          const unsigned char *hash, size_t hash_len,
   1104                                          const unsigned char *sig, size_t sig_len,
   1105                                          void *rs_ctx);
   1106          
   1107          static int ecdsa_sign_rs_wrap(mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
   1108                                        const unsigned char *hash, size_t hash_len,
   1109                                        unsigned char *sig, size_t sig_size, size_t *sig_len,
   1110                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   1111                                        void *rs_ctx);
   1112          
   1113          /*
   1114           * Restart context for ECDSA operations with ECKEY context
   1115           *
   1116           * We need to store an actual ECDSA context, as we need to pass the same to
   1117           * the underlying ecdsa function, so we can't create it on the fly every time.
   1118           */
   1119          typedef struct {
   1120              mbedtls_ecdsa_restart_ctx ecdsa_rs;
   1121              mbedtls_ecdsa_context ecdsa_ctx;
   1122          } eckey_restart_ctx;
   1123          
   1124          static void *eckey_rs_alloc(void)
   1125          {
   1126              eckey_restart_ctx *rs_ctx;
   1127          
   1128              void *ctx = mbedtls_calloc(1, sizeof(eckey_restart_ctx));
   1129          
   1130              if (ctx != NULL) {
   1131                  rs_ctx = ctx;
   1132                  mbedtls_ecdsa_restart_init(&rs_ctx->ecdsa_rs);
   1133                  mbedtls_ecdsa_init(&rs_ctx->ecdsa_ctx);
   1134              }
   1135          
   1136              return ctx;
   1137          }
   1138          
   1139          static void eckey_rs_free(void *ctx)
   1140          {
   1141              eckey_restart_ctx *rs_ctx;
   1142          
   1143              if (ctx == NULL) {
   1144                  return;
   1145              }
   1146          
   1147              rs_ctx = ctx;
   1148              mbedtls_ecdsa_restart_free(&rs_ctx->ecdsa_rs);
   1149              mbedtls_ecdsa_free(&rs_ctx->ecdsa_ctx);
   1150          
   1151              mbedtls_free(ctx);
   1152          }
   1153          
   1154          static int eckey_verify_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1155                                          const unsigned char *hash, size_t hash_len,
   1156                                          const unsigned char *sig, size_t sig_len,
   1157                                          void *rs_ctx)
   1158          {
   1159              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1160              eckey_restart_ctx *rs = rs_ctx;
   1161          
   1162              /* Should never happen */
   1163              if (rs == NULL) {
   1164                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1165              }
   1166          
   1167              /* set up our own sub-context if needed (that is, on first run) */
   1168              if (rs->ecdsa_ctx.grp.pbits == 0) {
   1169                  MBEDTLS_MPI_CHK(mbedtls_ecdsa_from_keypair(&rs->ecdsa_ctx, pk->pk_ctx));
   1170              }
   1171          
   1172              MBEDTLS_MPI_CHK(ecdsa_verify_rs_wrap(pk,
   1173                                                   md_alg, hash, hash_len,
   1174                                                   sig, sig_len, &rs->ecdsa_rs));
   1175          
   1176          cleanup:
   1177              return ret;
   1178          }
   1179          
   1180          static int eckey_sign_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1181                                        const unsigned char *hash, size_t hash_len,
   1182                                        unsigned char *sig, size_t sig_size, size_t *sig_len,
   1183                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   1184                                        void *rs_ctx)
   1185          {
   1186              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1187              eckey_restart_ctx *rs = rs_ctx;
   1188          
   1189              /* Should never happen */
   1190              if (rs == NULL) {
   1191                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1192              }
   1193          
   1194              /* set up our own sub-context if needed (that is, on first run) */
   1195              if (rs->ecdsa_ctx.grp.pbits == 0) {
   1196                  MBEDTLS_MPI_CHK(mbedtls_ecdsa_from_keypair(&rs->ecdsa_ctx, pk->pk_ctx));
   1197              }
   1198          
   1199              MBEDTLS_MPI_CHK(ecdsa_sign_rs_wrap(pk, md_alg,
   1200                                                 hash, hash_len, sig, sig_size, sig_len,
   1201                                                 f_rng, p_rng, &rs->ecdsa_rs));
   1202          
   1203          cleanup:
   1204              return ret;
   1205          }
   1206          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1207          
   1208          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1209          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1210          static int eckey_check_pair_psa(mbedtls_pk_context *pub, mbedtls_pk_context *prv)
   1211          {
   1212              psa_status_t status;
   1213              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1214              uint8_t prv_key_buf[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
   1215              size_t prv_key_len;
   1216              mbedtls_svc_key_id_t key_id = prv->priv_id;
   1217          
   1218              status = psa_export_public_key(key_id, prv_key_buf, sizeof(prv_key_buf),
   1219                                             &prv_key_len);
   1220              ret = PSA_PK_TO_MBEDTLS_ERR(status);
   1221              if (ret != 0) {
   1222                  return ret;
   1223              }
   1224          
   1225              if (memcmp(prv_key_buf, pub->pub_raw, pub->pub_raw_len) != 0) {
   1226                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1227              }
   1228          
   1229              return 0;
   1230          }
   1231          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1232          static int eckey_check_pair_psa(mbedtls_pk_context *pub, mbedtls_pk_context *prv)
   1233          {
   1234              psa_status_t status;
   1235              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1236              uint8_t prv_key_buf[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
   1237              size_t prv_key_len;
   1238              psa_status_t destruction_status;
   1239              mbedtls_svc_key_id_t key_id = MBEDTLS_SVC_KEY_ID_INIT;

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1240              psa_key_attributes_t key_attr = PSA_KEY_ATTRIBUTES_INIT;
   1241              uint8_t pub_key_buf[MBEDTLS_PSA_MAX_EC_PUBKEY_LENGTH];
   1242              size_t pub_key_len;
   1243              size_t curve_bits;
   1244              const psa_ecc_family_t curve =
   1245                  mbedtls_ecc_group_to_psa(mbedtls_pk_ec_ro(*prv)->grp.id, &curve_bits);
   1246              const size_t curve_bytes = PSA_BITS_TO_BYTES(curve_bits);
   1247          
   1248              if (curve == 0) {
   1249                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1250              }
   1251          
   1252              psa_set_key_type(&key_attr, PSA_KEY_TYPE_ECC_KEY_PAIR(curve));
   1253              psa_set_key_usage_flags(&key_attr, PSA_KEY_USAGE_EXPORT);
   1254          
   1255              ret = mbedtls_mpi_write_binary(&mbedtls_pk_ec_ro(*prv)->d,
   1256                                             prv_key_buf, curve_bytes);
   1257              if (ret != 0) {
   1258                  mbedtls_platform_zeroize(prv_key_buf, sizeof(prv_key_buf));
   1259                  return ret;
   1260              }
   1261          
   1262              status = psa_import_key(&key_attr, prv_key_buf, curve_bytes, &key_id);
   1263              mbedtls_platform_zeroize(prv_key_buf, sizeof(prv_key_buf));
   1264              ret = PSA_PK_TO_MBEDTLS_ERR(status);
   1265              if (ret != 0) {
   1266                  return ret;
   1267              }
   1268          
   1269              // From now on prv_key_buf is used to store the public key of prv.
   1270              status = psa_export_public_key(key_id, prv_key_buf, sizeof(prv_key_buf),
   1271                                             &prv_key_len);
   1272              ret = PSA_PK_TO_MBEDTLS_ERR(status);
   1273              destruction_status = psa_destroy_key(key_id);
   1274              if (ret != 0) {
   1275                  return ret;
   1276              } else if (destruction_status != PSA_SUCCESS) {
   1277                  return PSA_PK_TO_MBEDTLS_ERR(destruction_status);
   1278              }
   1279          
   1280              ret = mbedtls_ecp_point_write_binary(&mbedtls_pk_ec_rw(*pub)->grp,
   1281                                                   &mbedtls_pk_ec_rw(*pub)->Q,
   1282                                                   MBEDTLS_ECP_PF_UNCOMPRESSED,
   1283                                                   &pub_key_len, pub_key_buf,
   1284                                                   sizeof(pub_key_buf));
   1285              if (ret != 0) {
   1286                  return ret;
   1287              }
   1288          
   1289              if (memcmp(prv_key_buf, pub_key_buf, curve_bytes) != 0) {
   1290                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1291              }
   1292          
   1293              return 0;
   1294          }
   1295          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1296          

   \                                 In section .text, align 2, keep-with-next
   1297          static int eckey_check_pair_wrap(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
   1298                                           int (*f_rng)(void *, unsigned char *, size_t),
   1299                                           void *p_rng)
   1300          {
   \                     eckey_check_pair_wrap: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB0D3             SUB      SP,SP,#+332
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
   1301              (void) f_rng;
   1302              (void) p_rng;
   1303              return eckey_check_pair_psa(pub, prv);
   \        0x8   0x2700             MOVS     R7,#+0
   \        0xA   0x9724             STR      R7,[SP, #+144]
   \        0xC   0xA839             ADD      R0,SP,#+228
   \        0xE   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x12   0xB084             SUB      SP,SP,#+16
   \       0x14   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x18   0xBC0F             POP      {R0-R3}
   \       0x1A   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x1E   0x7800             LDRB     R0,[R0, #+0]
   \       0x20   0xA925             ADD      R1,SP,#+148
   \       0x22   0x....             LDR.N    R6,??DataTable13_9
   \       0x24   0x.... 0x....      BL       mbedtls_ecc_group_to_psa
   \       0x28   0x9F25             LDR      R7,[SP, #+148]
   \       0x2A   0x1DFF             ADDS     R7,R7,#+7
   \       0x2C   0xB908             CBNZ.N   R0,??eckey_check_pair_wrap_0
   \                     ??eckey_check_pair_wrap_1: (+1)
   \       0x2E   0x4634             MOV      R4,R6
   \       0x30   0xE019             B.N      ??eckey_check_pair_wrap_2
   \                     ??eckey_check_pair_wrap_0: (+1)
   \       0x32   0xF440 0x41E2      ORR      R1,R0,#0x7100
   \       0x36   0xA839             ADD      R0,SP,#+228
   \       0x38   0x.... 0x....      BL       psa_set_key_type
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0xA839             ADD      R0,SP,#+228
   \       0x40   0x.... 0x....      BL       psa_set_key_usage_flags
   \       0x44   0xB084             SUB      SP,SP,#+16
   \       0x46   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x4A   0xBC0F             POP      {R0-R3}
   \       0x4C   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x50   0x08FA             LSRS     R2,R7,#+3
   \       0x52   0xA942             ADD      R1,SP,#+264
   \       0x54   0x3060             ADDS     R0,R0,#+96
   \       0x56   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x5A   0x0004             MOVS     R4,R0
   \       0x5C   0xD006             BEQ.N    ??eckey_check_pair_wrap_3
   \       0x5E   0x2141             MOVS     R1,#+65
   \       0x60   0xA842             ADD      R0,SP,#+264
   \       0x62   0x.... 0x....      BL       mbedtls_platform_zeroize
   \                     ??eckey_check_pair_wrap_2: (+1)
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0xB053             ADD      SP,SP,#+332
   \       0x6A   0xBDF0             POP      {R4-R7,PC}
   \                     ??eckey_check_pair_wrap_3: (+1)
   \       0x6C   0xAB24             ADD      R3,SP,#+144
   \       0x6E   0x08FA             LSRS     R2,R7,#+3
   \       0x70   0xA942             ADD      R1,SP,#+264
   \       0x72   0xA839             ADD      R0,SP,#+228
   \       0x74   0x.... 0x....      BL       psa_import_key
   \       0x78   0x4604             MOV      R4,R0
   \       0x7A   0x2141             MOVS     R1,#+65
   \       0x7C   0xA842             ADD      R0,SP,#+264
   \       0x7E   0x.... 0x....      BL       mbedtls_platform_zeroize
   \       0x82   0x4620             MOV      R0,R4
   \       0x84   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0x88   0x0004             MOVS     R4,R0
   \       0x8A   0xD1EC             BNE.N    ??eckey_check_pair_wrap_2
   \       0x8C   0x9824             LDR      R0,[SP, #+144]
   \       0x8E   0xAB27             ADD      R3,SP,#+156
   \       0x90   0x2241             MOVS     R2,#+65
   \       0x92   0xA942             ADD      R1,SP,#+264
   \       0x94   0x.... 0x....      BL       psa_export_public_key
   \       0x98   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0x9C   0x4604             MOV      R4,R0
   \       0x9E   0x9824             LDR      R0,[SP, #+144]
   \       0xA0   0x.... 0x....      BL       psa_destroy_key
   \       0xA4   0x2C00             CMP      R4,#+0
   \       0xA6   0xD1DE             BNE.N    ??eckey_check_pair_wrap_2
   \       0xA8   0xB118             CBZ.N    R0,??eckey_check_pair_wrap_4
   \       0xAA   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0xAE   0x4604             MOV      R4,R0
   \       0xB0   0xE7D9             B.N      ??eckey_check_pair_wrap_2
   \                     ??eckey_check_pair_wrap_4: (+1)
   \       0xB2   0xB084             SUB      SP,SP,#+16
   \       0xB4   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0xB8   0xBC0F             POP      {R0-R3}
   \       0xBA   0x.... 0x....      BL       mbedtls_pk_ec_rw
   \       0xBE   0x4604             MOV      R4,R0
   \       0xC0   0xB084             SUB      SP,SP,#+16
   \       0xC2   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0xC6   0xBC0F             POP      {R0-R3}
   \       0xC8   0x.... 0x....      BL       mbedtls_pk_ec_rw
   \       0xCC   0x2241             MOVS     R2,#+65
   \       0xCE   0xA928             ADD      R1,SP,#+160
   \       0xD0   0x9201             STR      R2,[SP, #+4]
   \       0xD2   0x9100             STR      R1,[SP, #+0]
   \       0xD4   0xAB26             ADD      R3,SP,#+152
   \       0xD6   0x2200             MOVS     R2,#+0
   \       0xD8   0xF104 0x0168      ADD      R1,R4,#+104
   \       0xDC   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   \       0xE0   0x0004             MOVS     R4,R0
   \       0xE2   0xD1C0             BNE.N    ??eckey_check_pair_wrap_2
   \       0xE4   0x08FA             LSRS     R2,R7,#+3
   \       0xE6   0xA928             ADD      R1,SP,#+160
   \       0xE8   0xA842             ADD      R0,SP,#+264
   \       0xEA   0x.... 0x....      BL       memcmp
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD19D             BNE.N    ??eckey_check_pair_wrap_1
   \       0xF2   0x2400             MOVS     R4,#+0
   \       0xF4   0xE7B7             B.N      ??eckey_check_pair_wrap_2
   1304          }
   1305          #else /* MBEDTLS_USE_PSA_CRYPTO */
   1306          static int eckey_check_pair_wrap(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
   1307                                           int (*f_rng)(void *, unsigned char *, size_t),
   1308                                           void *p_rng)
   1309          {
   1310              return mbedtls_ecp_check_pub_priv((const mbedtls_ecp_keypair *) pub->pk_ctx,
   1311                                                (const mbedtls_ecp_keypair *) prv->pk_ctx,
   1312                                                f_rng, p_rng);
   1313          }
   1314          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1315          
   1316          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   1317          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1318          /* When PK_USE_PSA_EC_DATA is defined opaque and non-opaque keys end up
   1319           * using the same function. */
   1320          #define ecdsa_opaque_check_pair_wrap    eckey_check_pair_wrap
   1321          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */

   \                                 In section .text, align 2, keep-with-next
   1322          static int ecdsa_opaque_check_pair_wrap(mbedtls_pk_context *pub,
   1323                                                  mbedtls_pk_context *prv,
   1324                                                  int (*f_rng)(void *, unsigned char *, size_t),
   1325                                                  void *p_rng)
   1326          {
   \                     ecdsa_opaque_check_pair_wrap: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB0C8             SUB      SP,SP,#+288
   1327              psa_status_t status;
   1328              uint8_t exp_pub_key[MBEDTLS_PK_MAX_EC_PUBKEY_RAW_LEN];
   1329              size_t exp_pub_key_len = 0;
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x9224             STR      R2,[SP, #+144]
   1330              uint8_t pub_key[MBEDTLS_PK_MAX_EC_PUBKEY_RAW_LEN];
   1331              size_t pub_key_len = 0;
   \        0xC   0x9225             STR      R2,[SP, #+148]
   1332              int ret;
   1333              (void) f_rng;
   1334              (void) p_rng;
   1335          
   1336              status = psa_export_public_key(prv->priv_id, exp_pub_key, sizeof(exp_pub_key),
   1337                                             &exp_pub_key_len);
   \        0xE   0x68A8             LDR      R0,[R5, #+8]
   \       0x10   0xAB24             ADD      R3,SP,#+144
   \       0x12   0x2241             MOVS     R2,#+65
   \       0x14   0xA937             ADD      R1,SP,#+220
   \       0x16   0x.... 0x....      BL       psa_export_public_key
   1338              if (status != PSA_SUCCESS) {
   \       0x1A   0xB110             CBZ.N    R0,??ecdsa_opaque_check_pair_wrap_0
   1339                  ret = psa_pk_status_to_mbedtls(status);
   1340                  return ret;
   \       0x1C   0x.... 0x....      BL       psa_pk_status_to_mbedtls
   \       0x20   0xE022             B.N      ??ecdsa_opaque_check_pair_wrap_1
   1341              }
   1342              ret = mbedtls_ecp_point_write_binary(&(mbedtls_pk_ec_ro(*pub)->grp),
   1343                                                   &(mbedtls_pk_ec_ro(*pub)->Q),
   1344                                                   MBEDTLS_ECP_PF_UNCOMPRESSED,
   1345                                                   &pub_key_len, pub_key, sizeof(pub_key));
   \                     ??ecdsa_opaque_check_pair_wrap_0: (+1)
   \       0x22   0xB084             SUB      SP,SP,#+16
   \       0x24   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x28   0xBC0F             POP      {R0-R3}
   \       0x2A   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x2E   0x4605             MOV      R5,R0
   \       0x30   0xB084             SUB      SP,SP,#+16
   \       0x32   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x36   0xBC0F             POP      {R0-R3}
   \       0x38   0x.... 0x....      BL       mbedtls_pk_ec_ro
   \       0x3C   0x2241             MOVS     R2,#+65
   \       0x3E   0xA926             ADD      R1,SP,#+152
   \       0x40   0x9201             STR      R2,[SP, #+4]
   \       0x42   0x9100             STR      R1,[SP, #+0]
   \       0x44   0xAB25             ADD      R3,SP,#+148
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0xF105 0x0168      ADD      R1,R5,#+104
   \       0x4C   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   1346              if (ret != 0) {
   \       0x50   0xB950             CBNZ.N   R0,??ecdsa_opaque_check_pair_wrap_1
   1347                  return ret;
   1348              }
   1349              if ((exp_pub_key_len != pub_key_len) ||
   1350                  memcmp(exp_pub_key, pub_key, exp_pub_key_len)) {
   \       0x52   0x9924             LDR      R1,[SP, #+144]
   \       0x54   0x9825             LDR      R0,[SP, #+148]
   \       0x56   0x4281             CMP      R1,R0
   \       0x58   0xD105             BNE.N    ??ecdsa_opaque_check_pair_wrap_2
   \       0x5A   0x460A             MOV      R2,R1
   \       0x5C   0xA926             ADD      R1,SP,#+152
   \       0x5E   0xA837             ADD      R0,SP,#+220
   \       0x60   0x.... 0x....      BL       memcmp
   \       0x64   0xB100             CBZ.N    R0,??ecdsa_opaque_check_pair_wrap_1
   1351                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   \                     ??ecdsa_opaque_check_pair_wrap_2: (+1)
   \       0x66   0x....             LDR.N    R0,??DataTable13_9
   1352              }
   1353              return 0;
   \                     ??ecdsa_opaque_check_pair_wrap_1: (+1)
   \       0x68   0xB049             ADD      SP,SP,#+292
   \       0x6A   0xBD30             POP      {R4,R5,PC}
   1354          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4621             MOV      R1,R4
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x22A0             MOVS     R2,#+160
   \        0x6   0x.... 0x....      B.W      __aeabi_memcpy4
   1355          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1356          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1357          
   1358          #if !defined(MBEDTLS_PK_USE_PSA_EC_DATA)

   \                                 In section .text, align 2, keep-with-next
   1359          static void *eckey_alloc_wrap(void)
   1360          {
   \                     eckey_alloc_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1361              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_ecp_keypair));
   \        0x2   0x2180             MOVS     R1,#+128
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x.... 0x....      BL       sl_calloc
   \        0xA   0x0004             MOVS     R4,R0
   1362          
   1363              if (ctx != NULL) {
   \        0xC   0xBF18             IT       NE
   1364                  mbedtls_ecp_keypair_init(ctx);
   \        0xE   0x.... 0x....      BLNE     mbedtls_ecp_keypair_init
   1365              }
   1366          
   1367              return ctx;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}
   1368          }
   1369          

   \                                 In section .text, align 2, keep-with-next
   1370          static void eckey_free_wrap(void *ctx)
   1371          {
   \                     eckey_free_wrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1372              mbedtls_ecp_keypair_free((mbedtls_ecp_keypair *) ctx);
   \        0x4   0x.... 0x....      BL       mbedtls_ecp_keypair_free
   1373              mbedtls_free(ctx);
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x.... 0x....      B.W      sl_free
   1374          }
   1375          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1376          

   \                                 In section .text, align 4, keep-with-next
   1377          static void eckey_debug(mbedtls_pk_context *pk, mbedtls_pk_debug_item *items)
   1378          {
   1379          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1380              items->type = MBEDTLS_PK_DEBUG_PSA_EC;
   1381              items->name = "eckey.Q";
   1382              items->value = pk;
   1383          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1384              mbedtls_ecp_keypair *ecp = (mbedtls_ecp_keypair *) pk->pk_ctx;
   \                     eckey_debug: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   1385              items->type = MBEDTLS_PK_DEBUG_ECP;
   \        0x2   0x2302             MOVS     R3,#+2
   \        0x4   0x700B             STRB     R3,[R1, #+0]
   1386              items->name = "eckey.Q";
   \        0x6   0xBF00             Nop
   \        0x8   0x....             ADR.N    R2,?_10
   1387              items->value = &(ecp->Q);
   \        0xA   0x3068             ADDS     R0,R0,#+104
   \        0xC   0x604A             STR      R2,[R1, #+4]
   \        0xE   0x6088             STR      R0,[R1, #+8]
   1388          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1389          }
   \       0x10   0x4770             BX       LR
   1390          

   \                                 In section .rodata, align 4
   1391          const mbedtls_pk_info_t mbedtls_eckey_info = {
   \                     mbedtls_eckey_info:
   \        0x0   0x02               DC8 2
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_0, eckey_get_bitlen, eckey_can_do, ecdsa_verify_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....
   \       0x14   0x....'....        DC32 ecdsa_sign_wrap, 0x0, 0x0, eckey_check_pair_wrap, eckey_alloc_wrap
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....
   \       0x28   0x....'....        DC32 eckey_free_wrap, eckey_debug
   \              0x....'....
   1392              .type = MBEDTLS_PK_ECKEY,
   1393              .name = "EC",
   1394              .get_bitlen = eckey_get_bitlen,
   1395              .can_do = eckey_can_do,
   1396          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
   1397              .verify_func = ecdsa_verify_wrap,   /* Compatible key structures */
   1398          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1399              .verify_func = NULL,
   1400          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1401          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
   1402              .sign_func = ecdsa_sign_wrap,   /* Compatible key structures */
   1403          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1404              .sign_func = NULL,
   1405          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1406          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1407              .verify_rs_func = eckey_verify_rs_wrap,
   1408              .sign_rs_func = eckey_sign_rs_wrap,
   1409              .rs_alloc_func = eckey_rs_alloc,
   1410              .rs_free_func = eckey_rs_free,
   1411          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1412              .decrypt_func = NULL,
   1413              .encrypt_func = NULL,
   1414              .check_pair_func = eckey_check_pair_wrap,
   1415          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1416              .ctx_alloc_func = NULL,
   1417              .ctx_free_func = NULL,
   1418          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1419              .ctx_alloc_func = eckey_alloc_wrap,
   1420              .ctx_free_func = eckey_free_wrap,
   1421          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1422              .debug_func = eckey_debug,
   1423          };
   1424          
   1425          /*
   1426           * EC key restricted to ECDH
   1427           */

   \                                 In section .text, align 2, keep-with-next
   1428          static int eckeydh_can_do(mbedtls_pk_type_t type)
   1429          {
   1430              return type == MBEDTLS_PK_ECKEY ||
   1431                     type == MBEDTLS_PK_ECKEY_DH;
   \                     eckeydh_can_do: (+1)
   \        0x0   0x2802             CMP      R0,#+2
   \        0x2   0xBF18             IT       NE
   \        0x4   0x2803             CMPNE    R0,#+3
   \        0x6   0xD101             BNE.N    ??eckeydh_can_do_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??eckeydh_can_do_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   1432          }
   1433          

   \                                 In section .rodata, align 4
   1434          const mbedtls_pk_info_t mbedtls_eckeydh_info = {
   \                     mbedtls_eckeydh_info:
   \        0x0   0x03               DC8 3
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_1, eckey_get_bitlen, eckeydh_can_do, 0x0, 0x0, 0x0, 0x0
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x....'....        DC32 eckey_check_pair_wrap, eckey_alloc_wrap, eckey_free_wrap
   \              0x....'....  
   \              0x....'....
   \       0x2C   0x....'....        DC32 eckey_debug
   1435              .type = MBEDTLS_PK_ECKEY_DH,
   1436              .name = "EC_DH",
   1437              .get_bitlen = eckey_get_bitlen,         /* Same underlying key structure */
   1438              .can_do = eckeydh_can_do,
   1439              .verify_func = NULL,
   1440              .sign_func = NULL,
   1441          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1442              .verify_rs_func = NULL,
   1443              .sign_rs_func = NULL,
   1444          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1445              .decrypt_func = NULL,
   1446              .encrypt_func = NULL,
   1447              .check_pair_func = eckey_check_pair_wrap,
   1448          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1449              .ctx_alloc_func = NULL,
   1450              .ctx_free_func = NULL,
   1451          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1452              .ctx_alloc_func = eckey_alloc_wrap,   /* Same underlying key structure */
   1453              .ctx_free_func = eckey_free_wrap,    /* Same underlying key structure */
   1454          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1455              .debug_func = eckey_debug,            /* Same underlying key structure */
   1456          };
   1457          
   1458          #if defined(MBEDTLS_PK_CAN_ECDSA_SOME)

   \                                 In section .text, align 2, keep-with-next
   1459          static int ecdsa_can_do(mbedtls_pk_type_t type)
   1460          {
   1461              return type == MBEDTLS_PK_ECDSA;
   \                     ecdsa_can_do: (+1)
   \        0x0   0x2804             CMP      R0,#+4
   \        0x2   0xD101             BNE.N    ??ecdsa_can_do_0
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x4770             BX       LR
   \                     ??ecdsa_can_do_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   1462          }
   1463          
   1464          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1465          static int ecdsa_verify_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1466                                          const unsigned char *hash, size_t hash_len,
   1467                                          const unsigned char *sig, size_t sig_len,
   1468                                          void *rs_ctx)
   1469          {
   1470              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1471              ((void) md_alg);
   1472          
   1473              ret = mbedtls_ecdsa_read_signature_restartable(
   1474                  (mbedtls_ecdsa_context *) pk->pk_ctx,
   1475                  hash, hash_len, sig, sig_len,
   1476                  (mbedtls_ecdsa_restart_ctx *) rs_ctx);
   1477          
   1478              if (ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) {
   1479                  return MBEDTLS_ERR_PK_SIG_LEN_MISMATCH;
   1480              }
   1481          
   1482              return ret;
   1483          }
   1484          
   1485          static int ecdsa_sign_rs_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1486                                        const unsigned char *hash, size_t hash_len,
   1487                                        unsigned char *sig, size_t sig_size, size_t *sig_len,
   1488                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   1489                                        void *rs_ctx)
   1490          {
   1491              return mbedtls_ecdsa_write_signature_restartable(
   1492                  (mbedtls_ecdsa_context *) pk->pk_ctx,
   1493                  md_alg, hash, hash_len, sig, sig_size, sig_len, f_rng, p_rng,
   1494                  (mbedtls_ecdsa_restart_ctx *) rs_ctx);
   1495          
   1496          }
   1497          
   1498          static void *ecdsa_rs_alloc(void)
   1499          {
   1500              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_ecdsa_restart_ctx));
   1501          
   1502              if (ctx != NULL) {
   1503                  mbedtls_ecdsa_restart_init(ctx);
   1504              }
   1505          
   1506              return ctx;
   1507          }
   1508          
   1509          static void ecdsa_rs_free(void *ctx)
   1510          {
   1511              mbedtls_ecdsa_restart_free(ctx);
   1512              mbedtls_free(ctx);
   1513          }
   1514          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1515          

   \                                 In section .rodata, align 4
   1516          const mbedtls_pk_info_t mbedtls_ecdsa_info = {
   \                     mbedtls_ecdsa_info:
   \        0x0   0x04               DC8 4
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_2, eckey_get_bitlen, ecdsa_can_do, ecdsa_verify_wrap
   \              0x....'....  
   \              0x....'....  
   \              0x....'....
   \       0x14   0x....'....        DC32 ecdsa_sign_wrap, 0x0, 0x0, eckey_check_pair_wrap, eckey_alloc_wrap
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x....'....  
   \              0x....'....
   \       0x28   0x....'....        DC32 eckey_free_wrap, eckey_debug
   \              0x....'....
   1517              .type = MBEDTLS_PK_ECDSA,
   1518              .name = "ECDSA",
   1519              .get_bitlen = eckey_get_bitlen,     /* Compatible key structures */
   1520              .can_do = ecdsa_can_do,
   1521          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
   1522              .verify_func = ecdsa_verify_wrap,   /* Compatible key structures */
   1523          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1524              .verify_func = NULL,
   1525          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1526          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
   1527              .sign_func = ecdsa_sign_wrap,   /* Compatible key structures */
   1528          #else /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1529              .sign_func = NULL,
   1530          #endif /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1531          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1532              .verify_rs_func = ecdsa_verify_rs_wrap,
   1533              .sign_rs_func = ecdsa_sign_rs_wrap,
   1534              .rs_alloc_func = ecdsa_rs_alloc,
   1535              .rs_free_func = ecdsa_rs_free,
   1536          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1537              .decrypt_func = NULL,
   1538              .encrypt_func = NULL,
   1539              .check_pair_func = eckey_check_pair_wrap,   /* Compatible key structures */
   1540          #if defined(MBEDTLS_PK_USE_PSA_EC_DATA)
   1541              .ctx_alloc_func = NULL,
   1542              .ctx_free_func = NULL,
   1543          #else /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1544              .ctx_alloc_func = eckey_alloc_wrap,   /* Compatible key structures */
   1545              .ctx_free_func = eckey_free_wrap,   /* Compatible key structures */
   1546          #endif /* MBEDTLS_PK_USE_PSA_EC_DATA */
   1547              .debug_func = eckey_debug,        /* Compatible key structures */
   1548          };
   1549          #endif /* MBEDTLS_PK_CAN_ECDSA_SOME */
   1550          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   1551          
   1552          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
   1553          /*
   1554           * Support for alternative RSA-private implementations
   1555           */
   1556          
   1557          static int rsa_alt_can_do(mbedtls_pk_type_t type)
   1558          {
   1559              return type == MBEDTLS_PK_RSA;
   1560          }
   1561          
   1562          static size_t rsa_alt_get_bitlen(mbedtls_pk_context *pk)
   1563          {
   1564              const mbedtls_rsa_alt_context *rsa_alt = pk->pk_ctx;
   1565          
   1566              return 8 * rsa_alt->key_len_func(rsa_alt->key);
   1567          }
   1568          
   1569          static int rsa_alt_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1570                                       const unsigned char *hash, size_t hash_len,
   1571                                       unsigned char *sig, size_t sig_size, size_t *sig_len,
   1572                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1573          {
   1574              mbedtls_rsa_alt_context *rsa_alt = pk->pk_ctx;
   1575          
   1576          #if SIZE_MAX > UINT_MAX
   1577              if (UINT_MAX < hash_len) {
   1578                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1579              }
   1580          #endif
   1581          
   1582              *sig_len = rsa_alt->key_len_func(rsa_alt->key);
   1583              if (*sig_len > MBEDTLS_PK_SIGNATURE_MAX_SIZE) {
   1584                  return MBEDTLS_ERR_PK_BAD_INPUT_DATA;
   1585              }
   1586              if (*sig_len > sig_size) {
   1587                  return MBEDTLS_ERR_PK_BUFFER_TOO_SMALL;
   1588              }
   1589          
   1590              return rsa_alt->sign_func(rsa_alt->key, f_rng, p_rng,
   1591                                        md_alg, (unsigned int) hash_len, hash, sig);
   1592          }
   1593          
   1594          static int rsa_alt_decrypt_wrap(mbedtls_pk_context *pk,
   1595                                          const unsigned char *input, size_t ilen,
   1596                                          unsigned char *output, size_t *olen, size_t osize,
   1597                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1598          {
   1599              mbedtls_rsa_alt_context *rsa_alt = pk->pk_ctx;
   1600          
   1601              ((void) f_rng);
   1602              ((void) p_rng);
   1603          
   1604              if (ilen != rsa_alt->key_len_func(rsa_alt->key)) {
   1605                  return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
   1606              }
   1607          
   1608              return rsa_alt->decrypt_func(rsa_alt->key,
   1609                                           olen, input, output, osize);
   1610          }
   1611          
   1612          #if defined(MBEDTLS_RSA_C)
   1613          static int rsa_alt_check_pair(mbedtls_pk_context *pub, mbedtls_pk_context *prv,
   1614                                        int (*f_rng)(void *, unsigned char *, size_t),
   1615                                        void *p_rng)
   1616          {
   1617              unsigned char sig[MBEDTLS_MPI_MAX_SIZE];
   1618              unsigned char hash[32];
   1619              size_t sig_len = 0;
   1620              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1621          
   1622              if (rsa_alt_get_bitlen(prv) != rsa_get_bitlen(pub)) {
   1623                  return MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
   1624              }
   1625          
   1626              memset(hash, 0x2a, sizeof(hash));
   1627          
   1628              if ((ret = rsa_alt_sign_wrap(prv, MBEDTLS_MD_NONE,
   1629                                           hash, sizeof(hash),
   1630                                           sig, sizeof(sig), &sig_len,
   1631                                           f_rng, p_rng)) != 0) {
   1632                  return ret;
   1633              }
   1634          
   1635              if (rsa_verify_wrap(pub, MBEDTLS_MD_NONE,
   1636                                  hash, sizeof(hash), sig, sig_len) != 0) {
   1637                  return MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
   1638              }
   1639          
   1640              return 0;
   1641          }
   1642          #endif /* MBEDTLS_RSA_C */
   1643          
   1644          static void *rsa_alt_alloc_wrap(void)
   1645          {
   1646              void *ctx = mbedtls_calloc(1, sizeof(mbedtls_rsa_alt_context));
   1647          
   1648              if (ctx != NULL) {
   1649                  memset(ctx, 0, sizeof(mbedtls_rsa_alt_context));
   1650              }
   1651          
   1652              return ctx;
   1653          }
   1654          
   1655          static void rsa_alt_free_wrap(void *ctx)
   1656          {
   1657              mbedtls_zeroize_and_free(ctx, sizeof(mbedtls_rsa_alt_context));
   1658          }
   1659          
   1660          const mbedtls_pk_info_t mbedtls_rsa_alt_info = {
   1661              .type = MBEDTLS_PK_RSA_ALT,
   1662              .name = "RSA-alt",
   1663              .get_bitlen = rsa_alt_get_bitlen,
   1664              .can_do = rsa_alt_can_do,
   1665              .verify_func = NULL,
   1666              .sign_func = rsa_alt_sign_wrap,
   1667          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1668              .verify_rs_func = NULL,
   1669              .sign_rs_func = NULL,
   1670              .rs_alloc_func = NULL,
   1671              .rs_free_func = NULL,
   1672          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1673              .decrypt_func = rsa_alt_decrypt_wrap,
   1674              .encrypt_func = NULL,
   1675          #if defined(MBEDTLS_RSA_C)
   1676              .check_pair_func = rsa_alt_check_pair,
   1677          #else
   1678              .check_pair_func = NULL,
   1679          #endif
   1680              .ctx_alloc_func = rsa_alt_alloc_wrap,
   1681              .ctx_free_func = rsa_alt_free_wrap,
   1682              .debug_func = NULL,
   1683          };
   1684          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
   1685          
   1686          #if defined(MBEDTLS_USE_PSA_CRYPTO)

   \                                 In section .text, align 2, keep-with-next
   1687          static size_t opaque_get_bitlen(mbedtls_pk_context *pk)
   1688          {
   \                     opaque_get_bitlen: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4604             MOV      R4,R0
   1689              size_t bits;
   1690              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x.... 0x....      BL       ?Subroutine7
   1691          
   1692              if (PSA_SUCCESS != psa_get_key_attributes(pk->priv_id, &attributes)) {
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xC   0x68A0             LDR      R0,[R4, #+8]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x.... 0x....      BL       psa_get_key_attributes
   \       0x14   0xB108             CBZ.N    R0,??opaque_get_bitlen_0
   1693                  return 0;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE005             B.N      ??opaque_get_bitlen_1
   1694              }
   1695          
   1696              bits = psa_get_key_bits(&attributes);
   \                     ??opaque_get_bitlen_0: (+1)
   \       0x1A   0xF8BD 0x4002      LDRH     R4,[SP, #+2]
   1697              psa_reset_key_attributes(&attributes);
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       psa_reset_key_attributes
   1698              return bits;
   \       0x24   0x4620             MOV      R0,R4
   \                     ??opaque_get_bitlen_1: (+1)
   \       0x26   0xB00A             ADD      SP,SP,#+40
   \       0x28   0xBD10             POP      {R4,PC}
   1699          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
   1700          
   1701          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)

   \                                 In section .text, align 2, keep-with-next
   1702          static int ecdsa_opaque_can_do(mbedtls_pk_type_t type)
   1703          {
   1704              return type == MBEDTLS_PK_ECKEY ||
   1705                     type == MBEDTLS_PK_ECDSA;
   \                     ecdsa_opaque_can_do: (+1)
   \        0x0   0x2802             CMP      R0,#+2
   \        0x2   0xBF18             IT       NE
   \        0x4   0x2804             CMPNE    R0,#+4
   \        0x6   0xD101             BNE.N    ??ecdsa_opaque_can_do_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??ecdsa_opaque_can_do_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   1706          }
   1707          

   \                                 In section .rodata, align 4
   1708          const mbedtls_pk_info_t mbedtls_ecdsa_opaque_info = {
   \                     mbedtls_ecdsa_opaque_info:
   \        0x0   0x07               DC8 7
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_3, opaque_get_bitlen, ecdsa_opaque_can_do
   \              0x....'....  
   \              0x....'....
   \       0x10   0x....'....        DC32 ecdsa_opaque_verify_wrap, ecdsa_opaque_sign_wrap, 0x0, 0x0
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x....'....        DC32 ecdsa_opaque_check_pair_wrap, 0x0, 0x0, 0x0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   1709              .type = MBEDTLS_PK_OPAQUE,
   1710              .name = "Opaque",
   1711              .get_bitlen = opaque_get_bitlen,
   1712              .can_do = ecdsa_opaque_can_do,
   1713          #if defined(MBEDTLS_PK_CAN_ECDSA_VERIFY)
   1714              .verify_func = ecdsa_opaque_verify_wrap,
   1715          #else /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1716              .verify_func = NULL,
   1717          #endif /* MBEDTLS_PK_CAN_ECDSA_VERIFY */
   1718          #if defined(MBEDTLS_PK_CAN_ECDSA_SIGN)
   1719              .sign_func = ecdsa_opaque_sign_wrap,
   1720          #else /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1721              .sign_func = NULL,
   1722          #endif /* MBEDTLS_PK_CAN_ECDSA_SIGN */
   1723          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1724              .verify_rs_func = NULL,
   1725              .sign_rs_func = NULL,
   1726              .rs_alloc_func = NULL,
   1727              .rs_free_func = NULL,
   1728          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1729              .decrypt_func = NULL,
   1730              .encrypt_func = NULL,
   1731              .check_pair_func = ecdsa_opaque_check_pair_wrap,
   1732              .ctx_alloc_func = NULL,
   1733              .ctx_free_func = NULL,
   1734              .debug_func = NULL,
   1735          };
   1736          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
   1737          

   \                                 In section .text, align 2, keep-with-next
   1738          static int rsa_opaque_can_do(mbedtls_pk_type_t type)
   1739          {
   1740              return type == MBEDTLS_PK_RSA ||
   1741                     type == MBEDTLS_PK_RSASSA_PSS;
   \                     rsa_opaque_can_do: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xBF18             IT       NE
   \        0x4   0x2806             CMPNE    R0,#+6
   \        0x6   0xD101             BNE.N    ??rsa_opaque_can_do_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??rsa_opaque_can_do_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR
   1742          }
   1743          
   1744          #if defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC)
   1745          static int rsa_opaque_decrypt(mbedtls_pk_context *pk,
   1746                                        const unsigned char *input, size_t ilen,
   1747                                        unsigned char *output, size_t *olen, size_t osize,
   1748                                        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1749          {
   1750              psa_status_t status;
   1751          
   1752              /* PSA has its own RNG */
   1753              (void) f_rng;
   1754              (void) p_rng;
   1755          
   1756              status = psa_asymmetric_decrypt(pk->priv_id, PSA_ALG_RSA_PKCS1V15_CRYPT,
   1757                                              input, ilen,
   1758                                              NULL, 0,
   1759                                              output, osize, olen);
   1760              if (status != PSA_SUCCESS) {
   1761                  return PSA_PK_RSA_TO_MBEDTLS_ERR(status);
   1762              }
   1763          
   1764              return 0;
   1765          }
   1766          #endif /* PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
   1767          

   \                                 In section .text, align 4, keep-with-next
   1768          static int rsa_opaque_sign_wrap(mbedtls_pk_context *pk, mbedtls_md_type_t md_alg,
   1769                                          const unsigned char *hash, size_t hash_len,
   1770                                          unsigned char *sig, size_t sig_size, size_t *sig_len,
   1771                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1772          {
   1773          #if defined(MBEDTLS_RSA_C)
   1774              psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
   1775              psa_algorithm_t alg;
   1776              psa_key_type_t type;
   1777              psa_status_t status;
   1778          
   1779              /* PSA has its own RNG */
   1780              (void) f_rng;
   1781              (void) p_rng;
   1782          
   1783              status = psa_get_key_attributes(pk->priv_id, &attributes);
   1784              if (status != PSA_SUCCESS) {
   1785                  return PSA_PK_TO_MBEDTLS_ERR(status);
   1786              }
   1787          
   1788              type = psa_get_key_type(&attributes);
   1789              psa_reset_key_attributes(&attributes);
   1790          
   1791              if (PSA_KEY_TYPE_IS_RSA(type)) {
   1792                  alg = PSA_ALG_RSA_PKCS1V15_SIGN(mbedtls_md_psa_alg_from_type(md_alg));
   1793              } else {
   1794                  return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   1795              }
   1796          
   1797              /* make the signature */
   1798              status = psa_sign_hash(pk->priv_id, alg, hash, hash_len,
   1799                                     sig, sig_size, sig_len);
   1800              if (status != PSA_SUCCESS) {
   1801                  if (PSA_KEY_TYPE_IS_RSA(type)) {
   1802                      return PSA_PK_RSA_TO_MBEDTLS_ERR(status);
   1803                  } else {
   1804                      return PSA_PK_TO_MBEDTLS_ERR(status);
   1805                  }
   1806              }
   1807          
   1808              return 0;
   1809          #else /* !MBEDTLS_RSA_C */
   1810              ((void) pk);
   1811              ((void) md_alg);
   1812              ((void) hash);
   1813              ((void) hash_len);
   1814              ((void) sig);
   1815              ((void) sig_size);
   1816              ((void) sig_len);
   1817              ((void) f_rng);
   1818              ((void) p_rng);
   1819              return MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE;
   \                     rsa_opaque_sign_wrap: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine5
   \        0x2                      ;; // Fall through to label ?Subroutine5
   1820          #endif /* !MBEDTLS_RSA_C */
   1821          }
   1822          

   \                                 In section .rodata, align 4
   1823          const mbedtls_pk_info_t mbedtls_rsa_opaque_info = {
   \                     mbedtls_rsa_opaque_info:
   \        0x0   0x07               DC8 7
   \        0x1                      DS8 3
   \        0x4   0x....'....        DC32 ?_3, opaque_get_bitlen, rsa_opaque_can_do, 0x0
   \              0x....'....  
   \              0x....'....  
   \              0x0000'0000
   \       0x14   0x....'....        DC32 rsa_opaque_sign_wrap, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4629             MOV      R1,R5
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x22A0             MOVS     R2,#+160
   \        0x6   0x.... 0x....      B.W      __aeabi_memcpy4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xFFFF'C300        DC32     0xffffc300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xFFFF'C780        DC32     0xffffc780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0xFFFF'C580        DC32     0xffffc580

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0xFFFF'B100        DC32     0xffffb100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0xFFFF'B300        DC32     0xffffb300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0xFFFF'B200        DC32     0xffffb200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \        0x0   0xFFFF'C080        DC32     0xffffc080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \        0x0   0xFFFF'C180        DC32     0xffffc180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \        0x0   0xFFFF'C200        DC32     0xffffc200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \        0x0   0x....'....        DC32     psa_pk_status_to_mbedtls

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \        0x0   0x....'....        DC32     psa_to_pk_ecdsa_errors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \        0x0   0xFFFF'C700        DC32     0xffffc700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \        0x0   0x0600'0700        DC32     0x6000700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \        0x0   0xFFFF'C680        DC32     0xffffc680

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x43          DC8 "EC"
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x45 0x43          DC8 "EC_DH"
   \              0x5F 0x44    
   \              0x48 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x45 0x43          DC8 "ECDSA"
   \              0x44 0x53    
   \              0x41 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x4F 0x70          DC8 "Opaque"
   \              0x61 0x71    
   \              0x75 0x65    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x65 0x63          DC8 "eckey.Q"
   \              0x6B 0x65    
   \              0x79 0x2E    
   \              0x51 0x00
   1824              .type = MBEDTLS_PK_OPAQUE,
   1825              .name = "Opaque",
   1826              .get_bitlen = opaque_get_bitlen,
   1827              .can_do = rsa_opaque_can_do,
   1828              .verify_func = NULL,
   1829              .sign_func = rsa_opaque_sign_wrap,
   1830          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   1831              .verify_rs_func = NULL,
   1832              .sign_rs_func = NULL,
   1833              .rs_alloc_func = NULL,
   1834              .rs_free_func = NULL,
   1835          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   1836          #if defined(PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC)
   1837              .decrypt_func = rsa_opaque_decrypt,
   1838          #else /* PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
   1839              .decrypt_func = NULL,
   1840          #endif /* PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC */
   1841              .encrypt_func = NULL,
   1842              .check_pair_func = NULL,
   1843              .ctx_alloc_func = NULL,
   1844              .ctx_free_func = NULL,
   1845              .debug_func = NULL,
   1846          };
   1847          
   1848          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   1849          
   1850          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   asn1_write_mpibuf
        24   -> __aeabi_memmove
        24   -> mbedtls_asn1_write_len
        24   -> mbedtls_asn1_write_tag
       0   ecdsa_can_do
       0   ecdsa_opaque_can_do
     320   ecdsa_opaque_check_pair_wrap
       320   -> __aeabi_memcpy4
       304   -> mbedtls_ecp_point_write_binary
       304   -> mbedtls_pk_ec_ro
       304   -> memcmp
       304   -> psa_export_public_key
       304   -> psa_pk_status_to_mbedtls
      24   ecdsa_opaque_sign_wrap
        24   -> ecdsa_sign_psa
     160   ecdsa_opaque_verify_wrap
       160   -> __aeabi_memclr4
       160   -> ecdsa_verify_psa
       160   -> psa_export_public_key
       160   -> psa_get_key_attributes
       160   -> psa_reset_key_attributes
       160   -> psa_status_to_mbedtls
      88   ecdsa_sign_psa
        88   -> __aeabi_memclr4
        88   -> __aeabi_memmove
        88   -> asn1_write_mpibuf
        88   -> mbedtls_asn1_write_len
        88   -> mbedtls_asn1_write_tag
        88   -> psa_get_key_attributes
        88   -> psa_reset_key_attributes
        88   -> psa_sign_hash
        88   -> psa_status_to_mbedtls
     120   ecdsa_sign_wrap
       120   -> __aeabi_memclr4
       120   -> ecdsa_sign_psa
       120   -> mbedtls_ecc_group_to_psa
       120   -> mbedtls_mpi_write_binary
       120   -> mbedtls_platform_zeroize
       120   -> psa_destroy_key
       120   -> psa_import_key
       120   -> psa_pk_status_to_mbedtls
       120   -> psa_set_key_type
       120   -> psa_set_key_usage_flags
     144   ecdsa_verify_psa
       144   -> __aeabi_memclr4
       144   -> extract_ecdsa_sig_int
       144   -> mbedtls_asn1_get_tag
       144   -> psa_destroy_key
       144   -> psa_import_key
       144   -> psa_pk_status_to_mbedtls
       144   -> psa_set_key_algorithm
       144   -> psa_set_key_type
       144   -> psa_set_key_usage_flags
       144   -> psa_status_to_mbedtls
       144   -> psa_verify_hash
     112   ecdsa_verify_wrap
       112   -> ecdsa_verify_psa
       112   -> mbedtls_ecc_group_to_psa
       112   -> mbedtls_ecp_point_write_binary
       8   eckey_alloc_wrap
         8   -> mbedtls_ecp_keypair_init
         8   -> sl_calloc
       0   eckey_can_do
     368   eckey_check_pair_wrap
       352   -> __aeabi_memclr4
       368   -> __aeabi_memcpy4
       352   -> mbedtls_ecc_group_to_psa
       352   -> mbedtls_ecp_point_write_binary
       352   -> mbedtls_mpi_write_binary
       352   -> mbedtls_pk_ec_ro
       352   -> mbedtls_pk_ec_rw
       352   -> mbedtls_platform_zeroize
       352   -> memcmp
       352   -> psa_destroy_key
       352   -> psa_export_public_key
       352   -> psa_import_key
       352   -> psa_pk_status_to_mbedtls
       352   -> psa_set_key_type
       352   -> psa_set_key_usage_flags
       0   eckey_debug
       8   eckey_free_wrap
         8   -> mbedtls_ecp_keypair_free
         0   -> sl_free
       0   eckey_get_bitlen
       0   eckeydh_can_do
      24   extract_ecdsa_sig_int
        24   -> __aeabi_memclr
        24   -> __aeabi_memcpy
        24   -> mbedtls_asn1_get_tag
      24   mbedtls_pk_ec_ro
        24   -> mbedtls_pk_get_type
      24   mbedtls_pk_ec_rw
        24   -> mbedtls_pk_get_type
       0   mbedtls_pk_error_from_psa
       0   mbedtls_pk_error_from_psa_ecdsa
      48   opaque_get_bitlen
        48   -> __aeabi_memclr4
        48   -> psa_get_key_attributes
        48   -> psa_reset_key_attributes
       0   psa_set_key_algorithm
       0   psa_set_key_type
         0   -> psa_set_key_domain_parameters
       0   psa_set_key_usage_flags
       0   rsa_opaque_can_do
       0   rsa_opaque_sign_wrap


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       4  ?Subroutine5
       6  ?Subroutine6
       6  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
       4  ?_0
       8  ?_1
       8  ?_10
       8  ?_2
       8  ?_3
      36  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
      36  ?_8
      36  ?_9
     112  asn1_write_mpibuf
      12  ecdsa_can_do
      16  ecdsa_opaque_can_do
     108  ecdsa_opaque_check_pair_wrap
      22  ecdsa_opaque_sign_wrap
     124  ecdsa_opaque_verify_wrap
     208  ecdsa_sign_psa
     176  ecdsa_sign_wrap
     230  ecdsa_verify_psa
      72  ecdsa_verify_wrap
      22  eckey_alloc_wrap
      18  eckey_can_do
     246  eckey_check_pair_wrap
      18  eckey_debug
      18  eckey_free_wrap
       6  eckey_get_bitlen
      16  eckeydh_can_do
      86  extract_ecdsa_sig_int
      48  mbedtls_ecdsa_info
      48  mbedtls_ecdsa_opaque_info
      48  mbedtls_eckey_info
      48  mbedtls_eckeydh_info
      22  mbedtls_pk_ec_ro
      20  mbedtls_pk_ec_rw
      90  mbedtls_pk_error_from_psa
     114  mbedtls_pk_error_from_psa_ecdsa
      48  mbedtls_rsa_opaque_info
      42  opaque_get_bitlen
       4  psa_set_key_algorithm
      16  psa_set_key_type
      20  psa_set_key_usage_flags
      16  rsa_opaque_can_do
       2  rsa_opaque_sign_wrap

 
   484 bytes in section .rodata
 1'998 bytes in section .text
 
 1'998 bytes of CODE  memory
   484 bytes of CONST memory

Errors: none
Warnings: none
