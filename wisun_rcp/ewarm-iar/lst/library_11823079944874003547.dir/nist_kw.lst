###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:30
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\nist_kw.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\nist_kw.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\nist_kw.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\nist_kw.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\nist_kw.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\nist_kw.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\nist_kw.c
      1          /*
      2           *  Implementation of NIST SP 800-38F key wrapping, supporting KW and KWP modes
      3           *  only
      4           *
      5           *  Copyright The Mbed TLS Contributors
      6           *  SPDX-License-Identifier: Apache-2.0
      7           *
      8           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      9           *  not use this file except in compliance with the License.
     10           *  You may obtain a copy of the License at
     11           *
     12           *  http://www.apache.org/licenses/LICENSE-2.0
     13           *
     14           *  Unless required by applicable law or agreed to in writing, software
     15           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     16           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     17           *  See the License for the specific language governing permissions and
     18           *  limitations under the License.
     19           */
     20          /*
     21           * Definition of Key Wrapping:
     22           * https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf
     23           * RFC 3394 "Advanced Encryption Standard (AES) Key Wrap Algorithm"
     24           * RFC 5649 "Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm"
     25           *
     26           * Note: RFC 3394 defines different methodology for intermediate operations for
     27           * the wrapping and unwrapping operation than the definition in NIST SP 800-38F.
     28           */
     29          
     30          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xB001             ADD      SP,SP,#+4
   \        0x8   0x4608             MOV      R0,R1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint32(void *, uint32_t)
   \                     mbedtls_put_unaligned_uint32: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0xB001             ADD      SP,SP,#+4
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_bswap32(uint32_t)
   \                     mbedtls_bswap32: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x0208             LSLS     R0,R1,#+8
   \        0x4   0xF400 0x007F      AND      R0,R0,#0xFF0000
   \        0x8   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \        0xC   0x0A0A             LSRS     R2,R1,#+8
   \        0xE   0xF402 0x427F      AND      R2,R2,#0xFF00
   \       0x12   0x4310             ORRS     R0,R2,R0
   \       0x14   0xEA40 0x6011      ORR      R0,R0,R1, LSR #+24
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     31          
     32          #if defined(MBEDTLS_NIST_KW_C)
     33          
     34          #include "mbedtls/nist_kw.h"
     35          #include "mbedtls/platform_util.h"
     36          #include "mbedtls/error.h"
     37          #include "mbedtls/constant_time.h"
     38          #include "constant_time_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_bool(uint32_t)
   \                     mbedtls_ct_bool: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable9
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x4048             EORS     R0,R1,R0
   \        0x8   0x4241             RSBS     R1,R0,#+0
   \        0xA   0x0840             LSRS     R0,R0,#+1
   \        0xC   0x4240             RSBS     R0,R0,#+0
   \        0xE   0x4308             ORRS     R0,R0,R1
   \       0x10   0x0FC0             LSRS     R0,R0,#+31
   \       0x12   0x4240             RSBS     R0,R0,#+0
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_ct_if(uint32_t, uint32_t, uint32_t)
   \                     mbedtls_ct_if: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable9
   \        0x6   0x6823             LDR      R3,[R4, #+0]
   \        0x8   0x4001             ANDS     R1,R1,R0
   \        0xA   0x4058             EORS     R0,R3,R0
   \        0xC   0xEA22 0x0000      BIC      R0,R2,R0
   \       0x10   0x4308             ORRS     R0,R0,R1
   \       0x12   0xBD10             POP      {R4,PC}
     39          
     40          #include <stdint.h>
     41          #include <string.h>
     42          
     43          #include "mbedtls/platform.h"
     44          
     45          #if !defined(MBEDTLS_NIST_KW_ALT)
     46          
     47          #define KW_SEMIBLOCK_LENGTH    8
     48          #define MIN_SEMIBLOCKS_COUNT   3
     49          
     50          /*! The 64-bit default integrity check value (ICV) for KW mode. */

   \                                 In section .text, align 4, keep-with-next
     51          static const unsigned char NIST_KW_ICV1[] = { 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
   \                     NIST_KW_ICV1:
   \        0x0   0xA6 0xA6          DC8 166, 166, 166, 166, 166, 166, 166, 166
   \              0xA6 0xA6    
   \              0xA6 0xA6    
   \              0xA6 0xA6
     52          /*! The 32-bit default integrity check value (ICV) for KWP mode. */

   \                                 In section .text, align 4, keep-with-next
     53          static const  unsigned char NIST_KW_ICV2[] = { 0xA6, 0x59, 0x59, 0xA6 };
   \                     NIST_KW_ICV2:
   \        0x0   0xA6 0x59          DC8 166, 89, 89, 166
   \              0x59 0xA6
     54          
     55          /*
     56           * Initialize context
     57           */

   \                                 In section .text, align 2, keep-with-next
     58          void mbedtls_nist_kw_init(mbedtls_nist_kw_context *ctx)
     59          {
     60              memset(ctx, 0, sizeof(mbedtls_nist_kw_context));
   \                     mbedtls_nist_kw_init: (+1)
   \        0x0   0x2148             MOVS     R1,#+72
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4
     61          }
     62          

   \                                 In section .text, align 2, keep-with-next
     63          int mbedtls_nist_kw_setkey(mbedtls_nist_kw_context *ctx,
     64                                     mbedtls_cipher_id_t cipher,
     65                                     const unsigned char *key,
     66                                     unsigned int keybits,
     67                                     const int is_wrap)
     68          {
   \                     mbedtls_nist_kw_setkey: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4698             MOV      R8,R3
     69              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     70              const mbedtls_cipher_info_t *cipher_info;
     71          
     72              cipher_info = mbedtls_cipher_info_from_values(cipher,
     73                                                            keybits,
     74                                                            MBEDTLS_MODE_ECB);
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0x4641             MOV      R1,R8
   \       0x10   0x4638             MOV      R0,R7
   \       0x12   0x.... 0x....      BL       mbedtls_cipher_info_from_values
   \       0x16   0x0004             MOVS     R4,R0
     75              if (cipher_info == NULL) {
   \       0x18   0xD004             BEQ.N    ??mbedtls_nist_kw_setkey_0
     76                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
     77              }
     78          
     79              if (mbedtls_cipher_info_get_block_size(cipher_info) != 16) {
   \       0x1A   0x7920             LDRB     R0,[R4, #+4]
   \       0x1C   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x20   0x2810             CMP      R0,#+16
   \       0x22   0xD002             BEQ.N    ??mbedtls_nist_kw_setkey_1
     80                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_nist_kw_setkey_0: (+1)
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \       0x28   0xE017             B.N      ??mbedtls_nist_kw_setkey_2
     81              }
     82          
     83              /*
     84               * SP 800-38F currently defines AES cipher as the only block cipher allowed:
     85               * "For KW and KWP, the underlying block cipher shall be approved, and the
     86               *  block size shall be 128 bits. Currently, the AES block cipher, with key
     87               *  lengths of 128, 192, or 256 bits, is the only block cipher that fits
     88               *  this profile."
     89               *  Currently we don't support other 128 bit block ciphers for key wrapping,
     90               *  such as Camellia and Aria.
     91               */
     92              if (cipher != MBEDTLS_CIPHER_ID_AES) {
   \                     ??mbedtls_nist_kw_setkey_1: (+1)
   \       0x2A   0x2F02             CMP      R7,#+2
   \       0x2C   0xBF18             IT       NE
   \       0x2E   0x.... 0x....      LDRNE.W  R0,??DataTable9_2
     93                  return MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \       0x32   0xD112             BNE.N    ??mbedtls_nist_kw_setkey_2
     94              }
     95          
     96              mbedtls_cipher_free(&ctx->cipher_ctx);
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       mbedtls_cipher_free
     97          
     98              if ((ret = mbedtls_cipher_setup(&ctx->cipher_ctx, cipher_info)) != 0) {
   \       0x3A   0x4621             MOV      R1,R4
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       mbedtls_cipher_setup
   \       0x42   0xB950             CBNZ.N   R0,??mbedtls_nist_kw_setkey_2
     99                  return ret;
   \       0x44   0x9B06             LDR      R3,[SP, #+24]
    100              }
    101          
    102              if ((ret = mbedtls_cipher_setkey(&ctx->cipher_ctx, key, keybits,
    103                                               is_wrap ? MBEDTLS_ENCRYPT :
    104                                               MBEDTLS_DECRYPT)
    105                   ) != 0) {
    106                  return ret;
   \       0x46   0xB103             CBZ.N    R3,??mbedtls_nist_kw_setkey_3
   \       0x48   0x2301             MOVS     R3,#+1
   \                     ??mbedtls_nist_kw_setkey_3: (+1)
   \       0x4A   0x4642             MOV      R2,R8
   \       0x4C   0x4631             MOV      R1,R6
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0xB25B             SXTB     R3,R3
   \       0x52   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x56   0x.... 0x....      B.W      mbedtls_cipher_setkey
   \                     ??mbedtls_nist_kw_setkey_2: (+1)
   \       0x5A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    107              }
    108          
    109              return 0;
    110          }
    111          
    112          /*
    113           * Free context
    114           */

   \                                 In section .text, align 2, keep-with-next
    115          void mbedtls_nist_kw_free(mbedtls_nist_kw_context *ctx)
    116          {
   \                     mbedtls_nist_kw_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    117              mbedtls_cipher_free(&ctx->cipher_ctx);
   \        0x4   0x.... 0x....      BL       mbedtls_cipher_free
    118              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_nist_kw_context));
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x2148             MOVS     R1,#+72
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x.... 0x....      B.W      mbedtls_platform_zeroize
    119          }
    120          
    121          /*
    122           * Helper function for Xoring the uint64_t "t" with the encrypted A.
    123           * Defined in NIST SP 800-38F section 6.1
    124           */

   \                                 In section .text, align 2, keep-with-next
    125          static void calc_a_xor_t(unsigned char A[KW_SEMIBLOCK_LENGTH], uint64_t t)
    126          {
   \                     calc_a_xor_t: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x4698             MOV      R8,R3
    127              size_t i = 0;
   \        0xA   0x2500             MOVS     R5,#+0
    128              for (i = 0; i < sizeof(t); i++) {
    129                  A[i] ^= (t >> ((sizeof(t) - 1 - i) * 8)) & 0xff;
   \                     ??calc_a_xor_t_0: (+1)
   \        0xC   0x5D77             LDRB     R7,[R6, R5]
   \        0xE   0xF1C5 0x0207      RSB      R2,R5,#+7
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x4641             MOV      R1,R8
   \       0x16   0x00D2             LSLS     R2,R2,#+3
   \       0x18   0x.... 0x....      BL       __aeabi_llsr
   \       0x1C   0x4078             EORS     R0,R0,R7
   \       0x1E   0x5570             STRB     R0,[R6, R5]
    130              }
   \       0x20   0x1C6D             ADDS     R5,R5,#+1
   \       0x22   0x2D08             CMP      R5,#+8
   \       0x24   0xD3F2             BCC.N    ??calc_a_xor_t_0
    131          }
   \       0x26   0xE8BD 0x81F0      POP      {R4-R8,PC}
    132          
    133          /*
    134           * KW-AE as defined in SP 800-38F section 6.2
    135           * KWP-AE as defined in SP 800-38F section 6.3
    136           */

   \                                 In section .text, align 2, keep-with-next
    137          int mbedtls_nist_kw_wrap(mbedtls_nist_kw_context *ctx,
    138                                   mbedtls_nist_kw_mode_t mode,
    139                                   const unsigned char *input, size_t in_len,
    140                                   unsigned char *output, size_t *out_len, size_t out_size)
    141          {
   \                     mbedtls_nist_kw_wrap: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4692             MOV      R10,R2
   \        0x6   0xB08B             SUB      SP,SP,#+44
   \        0x8   0xF8DD 0xB054      LDR      R11,[SP, #+84]
   \        0xC   0x4605             MOV      R5,R0
    142              int ret = 0;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x9F14             LDR      R7,[SP, #+80]
   \       0x12   0x9816             LDR      R0,[SP, #+88]
   \       0x14   0x9200             STR      R2,[SP, #+0]
   \       0x16   0x4688             MOV      R8,R1
    143              size_t semiblocks = 0;
    144              size_t s;
    145              size_t olen, padlen = 0;
   \       0x18   0x2600             MOVS     R6,#+0
    146              uint64_t t = 0;
    147              unsigned char outbuff[KW_SEMIBLOCK_LENGTH * 2];
    148              unsigned char inbuff[KW_SEMIBLOCK_LENGTH * 2];
    149          
    150              *out_len = 0;
   \       0x1A   0xF8CB 0x2000      STR      R2,[R11, #+0]
   \       0x1E   0x461C             MOV      R4,R3
    151              /*
    152               * Generate the String to work on
    153               */
    154              if (mode == MBEDTLS_KW_MODE_KW) {
   \       0x20   0x.... 0x....      LDR.W    R9,??DataTable9_1
   \       0x24   0xEA5F 0x0208      MOVS     R2,R8
   \       0x28   0xD116             BNE.N    ??mbedtls_nist_kw_wrap_0
    155                  if (out_size < in_len + KW_SEMIBLOCK_LENGTH) {
   \       0x2A   0xF104 0x0108      ADD      R1,R4,#+8
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xBF28             IT       CS
   \       0x32   0x2C10             CMPCS    R4,#+16
    156                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    157                  }
    158          
    159                  /*
    160                   * According to SP 800-38F Table 1, the plaintext length for KW
    161                   * must be between 2 to 2^54-1 semiblocks inclusive.
    162                   */
    163                  if (in_len < 16 ||
    164          #if SIZE_MAX > 0x1FFFFFFFFFFFFF8
    165                      in_len > 0x1FFFFFFFFFFFFF8 ||
    166          #endif
    167                      in_len % KW_SEMIBLOCK_LENGTH != 0) {
   \       0x34   0xD31A             BCC.N    ??mbedtls_nist_kw_wrap_1
   \       0x36   0xF014 0x0F07      TST      R4,#0x7
   \       0x3A   0xF040 0x80A9      BNE.W    ??mbedtls_nist_kw_wrap_2
    168                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    169                  }
    170          
    171                  memcpy(output, NIST_KW_ICV1, KW_SEMIBLOCK_LENGTH);
   \       0x3E   0x.... 0x....      ADR.W    R2,NIST_KW_ICV1
   \       0x42   0x6811             LDR      R1,[R2, #+0]
    172                  memmove(output + KW_SEMIBLOCK_LENGTH, input, in_len);
   \       0x44   0xF107 0x0008      ADD      R0,R7,#+8
   \       0x48   0x6039             STR      R1,[R7, #+0]
   \       0x4A   0x6851             LDR      R1,[R2, #+4]
   \       0x4C   0x4622             MOV      R2,R4
   \       0x4E   0x6079             STR      R1,[R7, #+4]
   \       0x50   0x4651             MOV      R1,R10
   \       0x52   0x.... 0x....      BL       __aeabi_memmove
    173              } else {
   \       0x56   0xE02C             B.N      ??mbedtls_nist_kw_wrap_3
    174                  if (in_len % 8 != 0) {
   \                     ??mbedtls_nist_kw_wrap_0: (+1)
   \       0x58   0xF014 0x0F07      TST      R4,#0x7
   \       0x5C   0xBF1C             ITT      NE
   \       0x5E   0xF004 0x0607      ANDNE    R6,R4,#0x7
   \       0x62   0xF1C6 0x0608      RSBNE    R6,R6,#+8
    175                      padlen = (8 - (in_len % 8));
    176                  }
    177          
    178                  if (out_size < in_len + KW_SEMIBLOCK_LENGTH + padlen) {
   \       0x66   0x1931             ADDS     R1,R6,R4
   \       0x68   0x3108             ADDS     R1,R1,#+8
   \       0x6A   0x4288             CMP      R0,R1
   \                     ??mbedtls_nist_kw_wrap_1: (+1)
   \       0x6C   0xF0C0 0x8090      BCC.W    ??mbedtls_nist_kw_wrap_2
    179                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    180                  }
    181          
    182                  /*
    183                   * According to SP 800-38F Table 1, the plaintext length for KWP
    184                   * must be between 1 and 2^32-1 octets inclusive.
    185                   */
    186                  if (in_len < 1
    187          #if SIZE_MAX > 0xFFFFFFFF
    188                      || in_len > 0xFFFFFFFF
    189          #endif
    190                      ) {
   \       0x70   0x2C00             CMP      R4,#+0
   \       0x72   0xF000 0x808D      BEQ.W    ??mbedtls_nist_kw_wrap_2
    191                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    192                  }
    193          
    194                  memcpy(output, NIST_KW_ICV2, KW_SEMIBLOCK_LENGTH / 2);
   \       0x76   0x.... 0x....      ADR.W    R2,NIST_KW_ICV2
   \       0x7A   0x6811             LDR      R1,[R2, #+0]
    195                  MBEDTLS_PUT_UINT32_BE((in_len & 0xffffffff), output,
    196                                        KW_SEMIBLOCK_LENGTH / 2);
   \       0x7C   0x.... 0x....      ADR.W    R0,mbedtls_byte_order_detector
   \       0x80   0x6039             STR      R1,[R7, #+0]
   \       0x82   0x7801             LDRB     R1,[R0, #+0]
   \       0x84   0x2901             CMP      R1,#+1
   \       0x86   0xBF08             IT       EQ
   \       0x88   0x4621             MOVEQ    R1,R4
   \       0x8A   0xD003             BEQ.N    ??mbedtls_nist_kw_wrap_4
   \       0x8C   0x4620             MOV      R0,R4
   \       0x8E   0x.... 0x....      BL       mbedtls_bswap32
   \       0x92   0x4601             MOV      R1,R0
   \                     ??mbedtls_nist_kw_wrap_4: (+1)
   \       0x94   0x1D38             ADDS     R0,R7,#+4
   \       0x96   0x.... 0x....      BL       mbedtls_put_unaligned_uint32
    197          
    198                  memcpy(output + KW_SEMIBLOCK_LENGTH, input, in_len);
   \       0x9A   0x4622             MOV      R2,R4
   \       0x9C   0x4651             MOV      R1,R10
   \       0x9E   0xF107 0x0008      ADD      R0,R7,#+8
   \       0xA2   0x.... 0x....      BL       __aeabi_memcpy
    199                  memset(output + KW_SEMIBLOCK_LENGTH + in_len, 0, padlen);
   \       0xA6   0xF107 0x0008      ADD      R0,R7,#+8
   \       0xAA   0x4631             MOV      R1,R6
   \       0xAC   0x4420             ADD      R0,R0,R4
   \       0xAE   0x.... 0x....      BL       __aeabi_memclr
    200              }
    201              semiblocks = ((in_len + padlen) / KW_SEMIBLOCK_LENGTH) + 1;
   \                     ??mbedtls_nist_kw_wrap_3: (+1)
   \       0xB2   0x1936             ADDS     R6,R6,R4
   \       0xB4   0x08F6             LSRS     R6,R6,#+3
   \       0xB6   0x1C71             ADDS     R1,R6,#+1
    202          
    203              s = 6 * (semiblocks - 1);
   \       0xB8   0x1E48             SUBS     R0,R1,#+1
   \       0xBA   0x2206             MOVS     R2,#+6
    204          
    205              if (mode == MBEDTLS_KW_MODE_KWP
    206                  && in_len <= KW_SEMIBLOCK_LENGTH) {
   \       0xBC   0x00CE             LSLS     R6,R1,#+3
   \       0xBE   0xFB02 0xFA00      MUL      R10,R2,R0
   \       0xC2   0xF1B8 0x0F01      CMP      R8,#+1
   \       0xC6   0xD112             BNE.N    ??mbedtls_nist_kw_wrap_5
   \       0xC8   0x2C08             CMP      R4,#+8
   \       0xCA   0xD810             BHI.N    ??mbedtls_nist_kw_wrap_5
    207                  memcpy(inbuff, output, 16);
   \       0xCC   0x2210             MOVS     R2,#+16
   \       0xCE   0x4639             MOV      R1,R7
   \       0xD0   0xA802             ADD      R0,SP,#+8
   \       0xD2   0x.... 0x....      BL       __aeabi_memcpy
    208                  ret = mbedtls_cipher_update(&ctx->cipher_ctx,
    209                                              inbuff, 16, output, &olen);
   \       0xD6   0xA801             ADD      R0,SP,#+4
   \       0xD8   0x9000             STR      R0,[SP, #+0]
   \       0xDA   0x463B             MOV      R3,R7
   \       0xDC   0x2210             MOVS     R2,#+16
   \       0xDE   0xA902             ADD      R1,SP,#+8
   \       0xE0   0x4628             MOV      R0,R5
   \       0xE2   0x.... 0x....      BL       mbedtls_cipher_update
   \       0xE6   0xEA5F 0x0900      MOVS     R9,R0
    210                  if (ret != 0) {
   \       0xEA   0xD142             BNE.N    ??mbedtls_nist_kw_wrap_6
   \       0xEC   0xE03E             B.N      ??mbedtls_nist_kw_wrap_7
    211                      goto cleanup;
    212                  }
    213              } else {
    214                  unsigned char *R2 = output + KW_SEMIBLOCK_LENGTH;
   \                     ??mbedtls_nist_kw_wrap_5: (+1)
   \       0xEE   0xF107 0x0008      ADD      R0,R7,#+8
    215                  unsigned char *A = output;
    216          
    217                  /*
    218                   * Do the wrapping function W, as defined in RFC 3394 section 2.2.1
    219                   */
    220                  if (semiblocks < MIN_SEMIBLOCKS_COUNT) {
   \       0xF2   0x2903             CMP      R1,#+3
   \       0xF4   0xD340             BCC.N    ??mbedtls_nist_kw_wrap_8
    221                      ret = MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    222                      goto cleanup;
    223                  }
    224          
    225                  /* Calculate intermediate values */
    226                  for (t = 1; t <= s; t++) {
   \       0xF6   0x950A             STR      R5,[SP, #+40]
   \       0xF8   0x2401             MOVS     R4,#+1
   \       0xFA   0xF04F 0x0800      MOV      R8,#+0
   \       0xFE   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \      0x102   0x4605             MOV      R5,R0
   \      0x104   0xE02C             B.N      ??mbedtls_nist_kw_wrap_9
    227                      memcpy(inbuff, A, KW_SEMIBLOCK_LENGTH);
   \                     ??mbedtls_nist_kw_wrap_10: (+1)
   \      0x106   0x6838             LDR      R0,[R7, #+0]
   \      0x108   0xAA02             ADD      R2,SP,#+8
    228                      memcpy(inbuff + KW_SEMIBLOCK_LENGTH, R2, KW_SEMIBLOCK_LENGTH);
    229          
    230                      ret = mbedtls_cipher_update(&ctx->cipher_ctx,
    231                                                  inbuff, 16, outbuff, &olen);
   \      0x10A   0xAB06             ADD      R3,SP,#+24
   \      0x10C   0x6010             STR      R0,[R2, #+0]
   \      0x10E   0x6878             LDR      R0,[R7, #+4]
   \      0x110   0xA902             ADD      R1,SP,#+8
   \      0x112   0x6050             STR      R0,[R2, #+4]
   \      0x114   0x6828             LDR      R0,[R5, #+0]
   \      0x116   0xAA04             ADD      R2,SP,#+16
   \      0x118   0x6010             STR      R0,[R2, #+0]
   \      0x11A   0x6868             LDR      R0,[R5, #+4]
   \      0x11C   0x6050             STR      R0,[R2, #+4]
   \      0x11E   0xA801             ADD      R0,SP,#+4
   \      0x120   0x9000             STR      R0,[SP, #+0]
   \      0x122   0x980A             LDR      R0,[SP, #+40]
   \      0x124   0x2210             MOVS     R2,#+16
   \      0x126   0x.... 0x....      BL       mbedtls_cipher_update
   \      0x12A   0xEA5F 0x0900      MOVS     R9,R0
    232                      if (ret != 0) {
   \      0x12E   0xD120             BNE.N    ??mbedtls_nist_kw_wrap_6
    233                          goto cleanup;
    234                      }
    235          
    236                      memcpy(A, outbuff, KW_SEMIBLOCK_LENGTH);
   \      0x130   0xAA06             ADD      R2,SP,#+24
   \      0x132   0x6811             LDR      R1,[R2, #+0]
    237                      calc_a_xor_t(A, t);
   \      0x134   0x4643             MOV      R3,R8
   \      0x136   0x4638             MOV      R0,R7
   \      0x138   0x6039             STR      R1,[R7, #+0]
   \      0x13A   0x6851             LDR      R1,[R2, #+4]
   \      0x13C   0x4622             MOV      R2,R4
   \      0x13E   0x6079             STR      R1,[R7, #+4]
   \      0x140   0x.... 0x....      BL       calc_a_xor_t
    238          
    239                      memcpy(R2, outbuff + KW_SEMIBLOCK_LENGTH, KW_SEMIBLOCK_LENGTH);
   \      0x144   0xAA08             ADD      R2,SP,#+32
   \      0x146   0x6811             LDR      R1,[R2, #+0]
    240                      R2 += KW_SEMIBLOCK_LENGTH;
    241                      if (R2 >= output + (semiblocks * KW_SEMIBLOCK_LENGTH)) {
   \      0x148   0x19B8             ADDS     R0,R7,R6
   \      0x14A   0x6029             STR      R1,[R5, #+0]
   \      0x14C   0x6851             LDR      R1,[R2, #+4]
   \      0x14E   0x6069             STR      R1,[R5, #+4]
   \      0x150   0x3508             ADDS     R5,R5,#+8
   \      0x152   0x4285             CMP      R5,R0
   \      0x154   0xBF28             IT       CS
   \      0x156   0xF107 0x0508      ADDCS    R5,R7,#+8
    242                          R2 = output + KW_SEMIBLOCK_LENGTH;
    243                      }
    244                  }
   \      0x15A   0x1C64             ADDS     R4,R4,#+1
   \      0x15C   0xF168 0x38FF      SBC      R8,R8,#+4294967295
   \                     ??mbedtls_nist_kw_wrap_9: (+1)
   \      0x160   0x2100             MOVS     R1,#+0
   \      0x162   0x4541             CMP      R1,R8
   \      0x164   0xD8CF             BHI.N    ??mbedtls_nist_kw_wrap_10
   \      0x166   0xBF28             IT       CS
   \      0x168   0x45A2             CMPCS    R10,R4
   \      0x16A   0xD2CC             BCS.N    ??mbedtls_nist_kw_wrap_10
   \                     ??mbedtls_nist_kw_wrap_7: (+1)
   \      0x16C   0xF8CB 0x6000      STR      R6,[R11, #+0]
   \      0x170   0xE006             B.N      ??mbedtls_nist_kw_wrap_11
    245              }
    246          
    247              *out_len = semiblocks * KW_SEMIBLOCK_LENGTH;
    248          
    249          cleanup:
    250          
    251              if (ret != 0) {
   \                     ??mbedtls_nist_kw_wrap_6: (+1)
   \      0x172   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x176   0xD003             BEQ.N    ??mbedtls_nist_kw_wrap_11
    252                  memset(output, 0, semiblocks * KW_SEMIBLOCK_LENGTH);
   \                     ??mbedtls_nist_kw_wrap_8: (+1)
   \      0x178   0x4631             MOV      R1,R6
   \      0x17A   0x4638             MOV      R0,R7
   \      0x17C   0x.... 0x....      BL       __aeabi_memclr
    253              }
    254              mbedtls_platform_zeroize(inbuff, KW_SEMIBLOCK_LENGTH * 2);
   \                     ??mbedtls_nist_kw_wrap_11: (+1)
   \      0x180   0x2110             MOVS     R1,#+16
   \      0x182   0xA802             ADD      R0,SP,#+8
   \      0x184   0x.... 0x....      BL       mbedtls_platform_zeroize
    255              mbedtls_platform_zeroize(outbuff, KW_SEMIBLOCK_LENGTH * 2);
   \      0x188   0x2110             MOVS     R1,#+16
   \      0x18A   0xA806             ADD      R0,SP,#+24
   \      0x18C   0x.... 0x....      BL       mbedtls_platform_zeroize
    256          
    257              return ret;
   \                     ??mbedtls_nist_kw_wrap_2: (+1)
   \      0x190   0x4648             MOV      R0,R9
   \      0x192   0x....             B.N      ?Subroutine0
    258          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB00B             ADD      SP,SP,#+44
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    259          
    260          /*
    261           * W-1 function as defined in RFC 3394 section 2.2.2
    262           * This function assumes the following:
    263           * 1. Output buffer is at least of size ( semiblocks - 1 ) * KW_SEMIBLOCK_LENGTH.
    264           * 2. The input buffer is of size semiblocks * KW_SEMIBLOCK_LENGTH.
    265           * 3. Minimal number of semiblocks is 3.
    266           * 4. A is a buffer to hold the first semiblock of the input buffer.
    267           */

   \                                 In section .text, align 2, keep-with-next
    268          static int unwrap(mbedtls_nist_kw_context *ctx,
    269                            const unsigned char *input, size_t semiblocks,
    270                            unsigned char A[KW_SEMIBLOCK_LENGTH],
    271                            unsigned char *output, size_t *out_len)
    272          {
   \                     unwrap: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0xF8DD 0xA05C      LDR      R10,[SP, #+92]
   \        0xA   0x4614             MOV      R4,R2
    273              int ret = 0;
   \        0xC   0xF04F 0x0B00      MOV      R11,#+0
   \       0x10   0x4607             MOV      R7,R0
    274              const size_t s = 6 * (semiblocks - 1);
    275              size_t olen;
    276              uint64_t t = 0;
    277              unsigned char outbuff[KW_SEMIBLOCK_LENGTH * 2];
    278              unsigned char inbuff[KW_SEMIBLOCK_LENGTH * 2];
    279              unsigned char *R = NULL;
    280              *out_len = 0;
   \       0x12   0xF8CA 0xB000      STR      R11,[R10, #+0]
    281          
    282              if (semiblocks < MIN_SEMIBLOCKS_COUNT) {
   \       0x16   0x2C03             CMP      R4,#+3
   \       0x18   0xBF38             IT       CC
   \       0x1A   0x....             LDRCC.N  R0,??DataTable9_1
    283                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \       0x1C   0xD353             BCC.N    ??unwrap_0
    284              }
    285          
    286              memcpy(A, input, KW_SEMIBLOCK_LENGTH);
   \       0x1E   0x680A             LDR      R2,[R1, #+0]
   \       0x20   0xF8DD 0x8058      LDR      R8,[SP, #+88]
   \       0x24   0x461E             MOV      R6,R3
   \       0x26   0x6032             STR      R2,[R6, #+0]
   \       0x28   0x684A             LDR      R2,[R1, #+4]
    287              memmove(output, input + KW_SEMIBLOCK_LENGTH, (semiblocks - 1) * KW_SEMIBLOCK_LENGTH);
   \       0x2A   0x1E65             SUBS     R5,R4,#+1
   \       0x2C   0xEA4F 0x09C5      LSL      R9,R5,#+3
   \       0x30   0x6072             STR      R2,[R6, #+4]
   \       0x32   0x464A             MOV      R2,R9
   \       0x34   0x3108             ADDS     R1,R1,#+8
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x.... 0x....      BL       __aeabi_memmove
    288              R = output + (semiblocks - 2) * KW_SEMIBLOCK_LENGTH;
   \       0x3C   0xEB08 0x03C4      ADD      R3,R8,R4, LSL #+3
   \       0x40   0xF1A3 0x0010      SUB      R0,R3,#+16
    289          
    290              /* Calculate intermediate values */
    291              for (t = s; t >= 1; t--) {
   \       0x44   0x2406             MOVS     R4,#+6
   \       0x46   0x9002             STR      R0,[SP, #+8]
   \       0x48   0x436C             MULS     R4,R4,R5
   \       0x4A   0x970B             STR      R7,[SP, #+44]
   \       0x4C   0x2500             MOVS     R5,#+0
   \       0x4E   0x4607             MOV      R7,R0
   \       0x50   0xE02A             B.N      ??unwrap_1
    292                  calc_a_xor_t(A, t);
   \                     ??unwrap_2: (+1)
   \       0x52   0x4622             MOV      R2,R4
   \       0x54   0x462B             MOV      R3,R5
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x.... 0x....      BL       calc_a_xor_t
    293          
    294                  memcpy(inbuff, A, KW_SEMIBLOCK_LENGTH);
   \       0x5C   0x6830             LDR      R0,[R6, #+0]
   \       0x5E   0xAA03             ADD      R2,SP,#+12
    295                  memcpy(inbuff + KW_SEMIBLOCK_LENGTH, R, KW_SEMIBLOCK_LENGTH);
    296          
    297                  ret = mbedtls_cipher_update(&ctx->cipher_ctx,
    298                                              inbuff, 16, outbuff, &olen);
   \       0x60   0xAB07             ADD      R3,SP,#+28
   \       0x62   0x6010             STR      R0,[R2, #+0]
   \       0x64   0x6870             LDR      R0,[R6, #+4]
   \       0x66   0xA903             ADD      R1,SP,#+12
   \       0x68   0x6050             STR      R0,[R2, #+4]
   \       0x6A   0x6838             LDR      R0,[R7, #+0]
   \       0x6C   0xAA05             ADD      R2,SP,#+20
   \       0x6E   0x6010             STR      R0,[R2, #+0]
   \       0x70   0x6878             LDR      R0,[R7, #+4]
   \       0x72   0x6050             STR      R0,[R2, #+4]
   \       0x74   0xA801             ADD      R0,SP,#+4
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0x980B             LDR      R0,[SP, #+44]
   \       0x7A   0x2210             MOVS     R2,#+16
   \       0x7C   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x80   0xEA5F 0x0B00      MOVS     R11,R0
    299                  if (ret != 0) {
   \       0x84   0xD122             BNE.N    ??unwrap_3
    300                      goto cleanup;
    301                  }
    302          
    303                  memcpy(A, outbuff, KW_SEMIBLOCK_LENGTH);
   \       0x86   0xAA07             ADD      R2,SP,#+28
   \       0x88   0x6811             LDR      R1,[R2, #+0]
    304          
    305                  /* Set R as LSB64 of outbuff */
    306                  memcpy(R, outbuff + KW_SEMIBLOCK_LENGTH, KW_SEMIBLOCK_LENGTH);
    307          
    308                  if (R == output) {
   \       0x8A   0x4547             CMP      R7,R8
   \       0x8C   0x6031             STR      R1,[R6, #+0]
   \       0x8E   0x6851             LDR      R1,[R2, #+4]
   \       0x90   0xAA09             ADD      R2,SP,#+36
   \       0x92   0x6071             STR      R1,[R6, #+4]
   \       0x94   0x6811             LDR      R1,[R2, #+0]
   \       0x96   0x6039             STR      R1,[R7, #+0]
   \       0x98   0x6851             LDR      R1,[R2, #+4]
   \       0x9A   0x6079             STR      R1,[R7, #+4]
   \       0x9C   0xBF14             ITE      NE
   \       0x9E   0x3F08             SUBNE    R7,R7,#+8
   \       0xA0   0x9F02             LDREQ    R7,[SP, #+8]
    309                      R = output + (semiblocks - 2) * KW_SEMIBLOCK_LENGTH;
    310                  } else {
    311                      R -= KW_SEMIBLOCK_LENGTH;
    312                  }
    313              }
   \       0xA2   0x1E64             SUBS     R4,R4,#+1
   \       0xA4   0xF165 0x0500      SBC      R5,R5,#+0
   \                     ??unwrap_1: (+1)
   \       0xA8   0x2D00             CMP      R5,#+0
   \       0xAA   0xBF08             IT       EQ
   \       0xAC   0x2C00             CMPEQ    R4,#+0
   \       0xAE   0xD1D0             BNE.N    ??unwrap_2
    314          
    315              *out_len = (semiblocks - 1) * KW_SEMIBLOCK_LENGTH;
   \       0xB0   0xF8CA 0x9000      STR      R9,[R10, #+0]
    316          
    317          cleanup:
    318              if (ret != 0) {
    319                  memset(output, 0, (semiblocks - 1) * KW_SEMIBLOCK_LENGTH);
    320              }
    321              mbedtls_platform_zeroize(inbuff, sizeof(inbuff));
   \                     ??unwrap_4: (+1)
   \       0xB4   0x2110             MOVS     R1,#+16
   \       0xB6   0xA803             ADD      R0,SP,#+12
   \       0xB8   0x.... 0x....      BL       mbedtls_platform_zeroize
    322              mbedtls_platform_zeroize(outbuff, sizeof(outbuff));
   \       0xBC   0x2110             MOVS     R1,#+16
   \       0xBE   0xA807             ADD      R0,SP,#+28
   \       0xC0   0x.... 0x....      BL       mbedtls_platform_zeroize
    323          
    324              return ret;
   \       0xC4   0x4658             MOV      R0,R11
   \                     ??unwrap_0: (+1)
   \       0xC6   0xB00D             ADD      SP,SP,#+52
   \       0xC8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??unwrap_3: (+1)
   \       0xCC   0x4649             MOV      R1,R9
   \       0xCE   0x4640             MOV      R0,R8
   \       0xD0   0x.... 0x....      BL       __aeabi_memclr
   \       0xD4   0xE7EE             B.N      ??unwrap_4
    325          }
    326          
    327          /*
    328           * KW-AD as defined in SP 800-38F section 6.2
    329           * KWP-AD as defined in SP 800-38F section 6.3
    330           */

   \                                 In section .text, align 4, keep-with-next
    331          int mbedtls_nist_kw_unwrap(mbedtls_nist_kw_context *ctx,
    332                                     mbedtls_nist_kw_mode_t mode,
    333                                     const unsigned char *input, size_t in_len,
    334                                     unsigned char *output, size_t *out_len, size_t out_size)
    335          {
   \                     mbedtls_nist_kw_unwrap: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x9D15             LDR      R5,[SP, #+84]
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x9A16             LDR      R2,[SP, #+88]
    336              int ret = 0;
    337              size_t olen;
    338              unsigned char A[KW_SEMIBLOCK_LENGTH];
    339              int diff;
    340          
    341              *out_len = 0;
   \        0xE   0x2600             MOVS     R6,#+0
    342              if (out_size < in_len - KW_SEMIBLOCK_LENGTH) {
   \       0x10   0xF1A3 0x0808      SUB      R8,R3,#+8
   \       0x14   0x602E             STR      R6,[R5, #+0]
   \       0x16   0x4542             CMP      R2,R8
   \       0x18   0xD31E             BCC.N    ??mbedtls_nist_kw_unwrap_0
    343                  return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    344              }
    345          
    346              if (mode == MBEDTLS_KW_MODE_KW) {
   \       0x1A   0x08DA             LSRS     R2,R3,#+3
   \       0x1C   0x.... 0x....      LDR.W    R11,??DataTable9_3
   \       0x20   0x9E14             LDR      R6,[SP, #+80]
   \       0x22   0xB994             CBNZ.N   R4,??mbedtls_nist_kw_unwrap_1
    347                  /*
    348                   * According to SP 800-38F Table 1, the ciphertext length for KW
    349                   * must be between 3 to 2^54 semiblocks inclusive.
    350                   */
    351                  if (in_len < 24 ||
    352          #if SIZE_MAX > 0x200000000000000
    353                      in_len > 0x200000000000000 ||
    354          #endif
    355                      in_len % KW_SEMIBLOCK_LENGTH != 0) {
   \       0x24   0x2B18             CMP      R3,#+24
   \       0x26   0xD317             BCC.N    ??mbedtls_nist_kw_unwrap_0
   \       0x28   0xF013 0x0F07      TST      R3,#0x7
   \       0x2C   0xD114             BNE.N    ??mbedtls_nist_kw_unwrap_0
    356                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
    357                  }
    358          
    359                  ret = unwrap(ctx, input, in_len / KW_SEMIBLOCK_LENGTH,
    360                               A, output, out_len);
   \       0x2E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x32   0x0004             MOVS     R4,R0
    361                  if (ret != 0) {
   \       0x34   0xD11B             BNE.N    ??mbedtls_nist_kw_unwrap_2
    362                      goto cleanup;
    363                  }
    364          
    365                  /* Check ICV in "constant-time" */
    366                  diff = mbedtls_ct_memcmp(NIST_KW_ICV1, A, KW_SEMIBLOCK_LENGTH);
   \       0x36   0x2208             MOVS     R2,#+8
   \       0x38   0xF10D 0x010C      ADD.W    R1,SP,#+12
   \       0x3C   0x....             ADR.N    R0,NIST_KW_ICV1
   \       0x3E   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x42   0x9002             STR      R0,[SP, #+8]
    367          
    368                  if (diff != 0) {
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD170             BNE.N    ??mbedtls_nist_kw_unwrap_3
   \       0x48   0xE081             B.N      ??mbedtls_nist_kw_unwrap_4
    369                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
    370                      goto cleanup;
    371                  }
    372          
    373              } else if (mode == MBEDTLS_KW_MODE_KWP) {
   \                     ??mbedtls_nist_kw_unwrap_1: (+1)
   \       0x4A   0x2C01             CMP      R4,#+1
   \       0x4C   0xD176             BNE.N    ??mbedtls_nist_kw_unwrap_5
    374                  size_t padlen = 0;
    375                  uint32_t Plen;
    376                  /*
    377                   * According to SP 800-38F Table 1, the ciphertext length for KWP
    378                   * must be between 2 to 2^29 semiblocks inclusive.
    379                   */
    380                  if (in_len < KW_SEMIBLOCK_LENGTH * 2 ||
    381          #if SIZE_MAX > 0x100000000
    382                      in_len > 0x100000000 ||
    383          #endif
    384                      in_len % KW_SEMIBLOCK_LENGTH != 0) {
   \       0x4E   0x2B10             CMP      R3,#+16
   \       0x50   0xD302             BCC.N    ??mbedtls_nist_kw_unwrap_0
   \       0x52   0xF013 0x0F07      TST      R3,#0x7
   \       0x56   0xD001             BEQ.N    ??mbedtls_nist_kw_unwrap_6
    385                      return MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA;
   \                     ??mbedtls_nist_kw_unwrap_0: (+1)
   \       0x58   0x....             LDR.N    R0,??DataTable9_1
   \       0x5A   0xE081             B.N      ??mbedtls_nist_kw_unwrap_7
    386                  }
    387          
    388                  if (in_len == KW_SEMIBLOCK_LENGTH * 2) {
   \                     ??mbedtls_nist_kw_unwrap_6: (+1)
   \       0x5C   0x2B10             CMP      R3,#+16
   \       0x5E   0xD119             BNE.N    ??mbedtls_nist_kw_unwrap_8
    389                      unsigned char outbuff[KW_SEMIBLOCK_LENGTH * 2];
    390                      ret = mbedtls_cipher_update(&ctx->cipher_ctx,
    391                                                  input, 16, outbuff, &olen);
   \       0x60   0xAA05             ADD      R2,SP,#+20
   \       0x62   0x9200             STR      R2,[SP, #+0]
   \       0x64   0xAB06             ADD      R3,SP,#+24
   \       0x66   0x2210             MOVS     R2,#+16
   \       0x68   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x6C   0x0004             MOVS     R4,R0
    392                      if (ret != 0) {
   \                     ??mbedtls_nist_kw_unwrap_2: (+1)
   \       0x6E   0xD167             BNE.N    ??mbedtls_nist_kw_unwrap_9
    393                          goto cleanup;
    394                      }
    395          
    396                      memcpy(A, outbuff, KW_SEMIBLOCK_LENGTH);
   \       0x70   0xAA06             ADD      R2,SP,#+24
   \       0x72   0xE9D2 0x1000      LDRD     R1,R0,[R2, #+0]
   \       0x76   0xAB03             ADD      R3,SP,#+12
   \       0x78   0xE9C3 0x1000      STRD     R1,R0,[R3, #+0]
    397                      memcpy(output, outbuff + KW_SEMIBLOCK_LENGTH, KW_SEMIBLOCK_LENGTH);
   \       0x7C   0xA908             ADD      R1,SP,#+32
   \       0x7E   0x6808             LDR      R0,[R1, #+0]
   \       0x80   0x6030             STR      R0,[R6, #+0]
   \       0x82   0x6848             LDR      R0,[R1, #+4]
    398                      mbedtls_platform_zeroize(outbuff, sizeof(outbuff));
   \       0x84   0x2110             MOVS     R1,#+16
   \       0x86   0x6070             STR      R0,[R6, #+4]
   \       0x88   0xA806             ADD      R0,SP,#+24
   \       0x8A   0x.... 0x....      BL       mbedtls_platform_zeroize
    399                      *out_len = KW_SEMIBLOCK_LENGTH;
   \       0x8E   0x2008             MOVS     R0,#+8
   \       0x90   0x6028             STR      R0,[R5, #+0]
   \       0x92   0xE003             B.N      ??mbedtls_nist_kw_unwrap_10
    400                  } else {
    401                      /* in_len >=  KW_SEMIBLOCK_LENGTH * 3 */
    402                      ret = unwrap(ctx, input, in_len / KW_SEMIBLOCK_LENGTH,
    403                                   A, output, out_len);
   \                     ??mbedtls_nist_kw_unwrap_8: (+1)
   \       0x94   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x98   0x0004             MOVS     R4,R0
    404                      if (ret != 0) {
   \       0x9A   0xD151             BNE.N    ??mbedtls_nist_kw_unwrap_9
    405                          goto cleanup;
    406                      }
    407                  }
    408          
    409                  /* Check ICV in "constant-time" */
    410                  diff = mbedtls_ct_memcmp(NIST_KW_ICV2, A, KW_SEMIBLOCK_LENGTH / 2);
   \                     ??mbedtls_nist_kw_unwrap_10: (+1)
   \       0x9C   0x2204             MOVS     R2,#+4
   \       0x9E   0xA903             ADD      R1,SP,#+12
   \       0xA0   0x....             ADR.N    R0,NIST_KW_ICV2
   \       0xA2   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0xA6   0x9002             STR      R0,[SP, #+8]
    411          
    412                  if (diff != 0) {
   \       0xA8   0xB100             CBZ.N    R0,??mbedtls_nist_kw_unwrap_11
    413                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   \       0xAA   0x465C             MOV      R4,R11
    414                  }
    415          
    416                  Plen = MBEDTLS_GET_UINT32_BE(A, KW_SEMIBLOCK_LENGTH / 2);
   \                     ??mbedtls_nist_kw_unwrap_11: (+1)
   \       0xAC   0x....             ADR.N    R1,mbedtls_byte_order_detector
   \       0xAE   0x7808             LDRB     R0,[R1, #+0]
   \       0xB0   0x2801             CMP      R0,#+1
   \       0xB2   0xA804             ADD      R0,SP,#+16
   \       0xB4   0xD102             BNE.N    ??mbedtls_nist_kw_unwrap_12
   \       0xB6   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0xBA   0xE003             B.N      ??mbedtls_nist_kw_unwrap_13
   \                     ??mbedtls_nist_kw_unwrap_12: (+1)
   \       0xBC   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0xC0   0x.... 0x....      BL       mbedtls_bswap32
   \                     ??mbedtls_nist_kw_unwrap_13: (+1)
   \       0xC4   0x4607             MOV      R7,R0
    417          
    418                  /*
    419                   * Plen is the length of the plaintext, when the input is valid.
    420                   * If Plen is larger than the plaintext and padding, padlen will be
    421                   * larger than 8, because of the type wrap around.
    422                   */
    423                  padlen = in_len - KW_SEMIBLOCK_LENGTH - Plen;
    424                  ret = mbedtls_ct_error_if(mbedtls_ct_uint_gt(padlen, 7),
    425                                            MBEDTLS_ERR_CIPHER_AUTH_FAILED, ret);
   \       0xC6   0x....             LDR.N    R0,??DataTable9
   \       0xC8   0xF8D0 0x9000      LDR      R9,[R0, #+0]
   \       0xCC   0xF8D0 0xA000      LDR      R10,[R0, #+0]
   \       0xD0   0xEBA8 0x0807      SUB      R8,R8,R7
   \       0xD4   0xF089 0x0907      EOR      R9,R9,#0x7
   \       0xD8   0xEA8A 0x0A08      EOR      R10,R10,R8
   \       0xDC   0xEA8A 0x0009      EOR      R0,R10,R9
   \       0xE0   0x0FC0             LSRS     R0,R0,#+31
   \       0xE2   0x.... 0x....      BL       mbedtls_ct_bool
   \       0xE6   0xEBA9 0x020A      SUB      R2,R9,R10
   \       0xEA   0x4651             MOV      R1,R10
   \       0xEC   0x.... 0x....      BL       mbedtls_ct_if
   \       0xF0   0x0FC0             LSRS     R0,R0,#+31
   \       0xF2   0x.... 0x....      BL       mbedtls_ct_bool
   \       0xF6   0x4264             RSBS     R4,R4,#+0
   \       0xF8   0x4622             MOV      R2,R4
   \       0xFA   0xF44F 0x41C6      MOV      R1,#+25344
    426                  padlen &= 7;
   \       0xFE   0xF008 0x0807      AND      R8,R8,#0x7
   \      0x102   0x.... 0x....      BL       mbedtls_ct_if
   \      0x106   0xAA06             ADD      R2,SP,#+24
    427          
    428                  /* Check padding in "constant-time" */
    429                  const uint8_t zero[KW_SEMIBLOCK_LENGTH] = { 0 };
    430                  diff = mbedtls_ct_memcmp_partial(
    431                      &output[*out_len - KW_SEMIBLOCK_LENGTH], zero,
    432                      KW_SEMIBLOCK_LENGTH, KW_SEMIBLOCK_LENGTH - padlen, 0);
   \      0x108   0xF1C8 0x0308      RSB      R3,R8,#+8
   \      0x10C   0xA906             ADD      R1,SP,#+24
   \      0x10E   0x4604             MOV      R4,R0
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0x9000             STR      R0,[SP, #+0]
   \      0x114   0xE9C2 0x0000      STRD     R0,R0,[R2, #+0]
   \      0x118   0x6828             LDR      R0,[R5, #+0]
   \      0x11A   0x2208             MOVS     R2,#+8
   \      0x11C   0x4264             RSBS     R4,R4,#+0
   \      0x11E   0x4430             ADD      R0,R6,R0
   \      0x120   0x3808             SUBS     R0,R0,#+8
   \      0x122   0x.... 0x....      BL       mbedtls_ct_memcmp_partial
   \      0x126   0x9002             STR      R0,[SP, #+8]
    433          
    434                  if (diff != 0) {
   \      0x128   0xB108             CBZ.N    R0,??mbedtls_nist_kw_unwrap_14
    435                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   \                     ??mbedtls_nist_kw_unwrap_3: (+1)
   \      0x12A   0x465C             MOV      R4,R11
   \      0x12C   0xE009             B.N      ??mbedtls_nist_kw_unwrap_15
    436                  }
    437          
    438                  if (ret != 0) {
   \                     ??mbedtls_nist_kw_unwrap_14: (+1)
   \      0x12E   0xB93C             CBNZ.N   R4,??mbedtls_nist_kw_unwrap_9
    439                      goto cleanup;
    440                  }
    441                  memset(output + Plen, 0, padlen);
   \      0x130   0x4641             MOV      R1,R8
   \      0x132   0x19F0             ADDS     R0,R6,R7
   \      0x134   0x.... 0x....      BL       __aeabi_memclr
    442                  *out_len = Plen;
   \      0x138   0x602F             STR      R7,[R5, #+0]
   \      0x13A   0xE008             B.N      ??mbedtls_nist_kw_unwrap_4
    443              } else {
    444                  ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
   \                     ??mbedtls_nist_kw_unwrap_5: (+1)
   \      0x13C   0x....             LDR.N    R4,??DataTable9_2
    445                  goto cleanup;
   \      0x13E   0xE000             B.N      ??mbedtls_nist_kw_unwrap_15
    446              }
    447          
    448          cleanup:
    449              if (ret != 0) {
   \                     ??mbedtls_nist_kw_unwrap_9: (+1)
   \      0x140   0xB12C             CBZ.N    R4,??mbedtls_nist_kw_unwrap_4
    450                  memset(output, 0, *out_len);
   \                     ??mbedtls_nist_kw_unwrap_15: (+1)
   \      0x142   0x6829             LDR      R1,[R5, #+0]
   \      0x144   0x4630             MOV      R0,R6
   \      0x146   0x.... 0x....      BL       __aeabi_memclr
    451                  *out_len = 0;
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0x6028             STR      R0,[R5, #+0]
    452              }
    453          
    454              mbedtls_platform_zeroize(&diff, sizeof(diff));
   \                     ??mbedtls_nist_kw_unwrap_4: (+1)
   \      0x14E   0x2104             MOVS     R1,#+4
   \      0x150   0xA802             ADD      R0,SP,#+8
   \      0x152   0x.... 0x....      BL       mbedtls_platform_zeroize
    455              mbedtls_platform_zeroize(A, sizeof(A));
   \      0x156   0x2108             MOVS     R1,#+8
   \      0x158   0xA803             ADD      R0,SP,#+12
   \      0x15A   0x.... 0x....      BL       mbedtls_platform_zeroize
    456          
    457              return ret;
   \      0x15E   0x4620             MOV      R0,R4
   \                     ??mbedtls_nist_kw_unwrap_7: (+1)
   \      0x160                      REQUIRE ?Subroutine0
   \      0x160                      ;; // Fall through to label ?Subroutine0
    458          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x9501             STR      R5,[SP, #+4]
   \        0x2   0x9600             STR      R6,[SP, #+0]
   \        0x4   0xAB03             ADD      R3,SP,#+12
   \        0x6   0x....             B.N      unwrap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     mbedtls_ct_zero

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0xFFFF'9F00        DC32     0xffff9f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0xFFFF'9F80        DC32     0xffff9f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0xFFFF'9D00        DC32     0xffff9d00
    459          
    460          #endif /* !MBEDTLS_NIST_KW_ALT */
    461          
    462          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
    463          
    464          /*
    465           * Test vectors taken from NIST
    466           * https://csrc.nist.gov/Projects/Cryptographic-Algorithm-Validation-Program/CAVP-TESTING-BLOCK-CIPHER-MODES#KW
    467           */
    468          static const unsigned int key_len[] = {
    469              16,
    470          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    471              24,
    472              32
    473          #endif
    474          };
    475          
    476          static const unsigned char kw_key[][32] = {
    477              { 0x75, 0x75, 0xda, 0x3a, 0x93, 0x60, 0x7c, 0xc2,
    478                0xbf, 0xd8, 0xce, 0xc7, 0xaa, 0xdf, 0xd9, 0xa6 },
    479          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    480              { 0x2d, 0x85, 0x26, 0x08, 0x1d, 0x02, 0xfb, 0x5b,
    481                0x85, 0xf6, 0x9a, 0xc2, 0x86, 0xec, 0xd5, 0x7d,
    482                0x40, 0xdf, 0x5d, 0xf3, 0x49, 0x47, 0x44, 0xd3 },
    483              { 0x11, 0x2a, 0xd4, 0x1b, 0x48, 0x56, 0xc7, 0x25,
    484                0x4a, 0x98, 0x48, 0xd3, 0x0f, 0xdd, 0x78, 0x33,
    485                0x5b, 0x03, 0x9a, 0x48, 0xa8, 0x96, 0x2c, 0x4d,
    486                0x1c, 0xb7, 0x8e, 0xab, 0xd5, 0xda, 0xd7, 0x88 }
    487          #endif
    488          };
    489          
    490          static const unsigned char kw_msg[][40] = {
    491              { 0x42, 0x13, 0x6d, 0x3c, 0x38, 0x4a, 0x3e, 0xea,
    492                0xc9, 0x5a, 0x06, 0x6f, 0xd2, 0x8f, 0xed, 0x3f },
    493          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    494              { 0x95, 0xc1, 0x1b, 0xf5, 0x35, 0x3a, 0xfe, 0xdb,
    495                0x98, 0xfd, 0xd6, 0xc8, 0xca, 0x6f, 0xdb, 0x6d,
    496                0xa5, 0x4b, 0x74, 0xb4, 0x99, 0x0f, 0xdc, 0x45,
    497                0xc0, 0x9d, 0x15, 0x8f, 0x51, 0xce, 0x62, 0x9d,
    498                0xe2, 0xaf, 0x26, 0xe3, 0x25, 0x0e, 0x6b, 0x4c },
    499              { 0x1b, 0x20, 0xbf, 0x19, 0x90, 0xb0, 0x65, 0xd7,
    500                0x98, 0xe1, 0xb3, 0x22, 0x64, 0xad, 0x50, 0xa8,
    501                0x74, 0x74, 0x92, 0xba, 0x09, 0xa0, 0x4d, 0xd1 }
    502          #endif
    503          };
    504          
    505          static const size_t kw_msg_len[] = {
    506              16,
    507          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    508              40,
    509              24
    510          #endif
    511          };
    512          static const size_t kw_out_len[] = {
    513              24,
    514          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    515              48,
    516              32
    517          #endif
    518          };
    519          static const unsigned char kw_res[][48] = {
    520              { 0x03, 0x1f, 0x6b, 0xd7, 0xe6, 0x1e, 0x64, 0x3d,
    521                0xf6, 0x85, 0x94, 0x81, 0x6f, 0x64, 0xca, 0xa3,
    522                0xf5, 0x6f, 0xab, 0xea, 0x25, 0x48, 0xf5, 0xfb },
    523          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    524              { 0x44, 0x3c, 0x6f, 0x15, 0x09, 0x83, 0x71, 0x91,
    525                0x3e, 0x5c, 0x81, 0x4c, 0xa1, 0xa0, 0x42, 0xec,
    526                0x68, 0x2f, 0x7b, 0x13, 0x6d, 0x24, 0x3a, 0x4d,
    527                0x6c, 0x42, 0x6f, 0xc6, 0x97, 0x15, 0x63, 0xe8,
    528                0xa1, 0x4a, 0x55, 0x8e, 0x09, 0x64, 0x16, 0x19,
    529                0xbf, 0x03, 0xfc, 0xaf, 0x90, 0xb1, 0xfc, 0x2d },
    530              { 0xba, 0x8a, 0x25, 0x9a, 0x47, 0x1b, 0x78, 0x7d,
    531                0xd5, 0xd5, 0x40, 0xec, 0x25, 0xd4, 0x3d, 0x87,
    532                0x20, 0x0f, 0xda, 0xdc, 0x6d, 0x1f, 0x05, 0xd9,
    533                0x16, 0x58, 0x4f, 0xa9, 0xf6, 0xcb, 0xf5, 0x12 }
    534          #endif
    535          };
    536          
    537          static const unsigned char kwp_key[][32] = {
    538              { 0x78, 0x65, 0xe2, 0x0f, 0x3c, 0x21, 0x65, 0x9a,
    539                0xb4, 0x69, 0x0b, 0x62, 0x9c, 0xdf, 0x3c, 0xc4 },
    540          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    541              { 0xf5, 0xf8, 0x96, 0xa3, 0xbd, 0x2f, 0x4a, 0x98,
    542                0x23, 0xef, 0x16, 0x2b, 0x00, 0xb8, 0x05, 0xd7,
    543                0xde, 0x1e, 0xa4, 0x66, 0x26, 0x96, 0xa2, 0x58 },
    544              { 0x95, 0xda, 0x27, 0x00, 0xca, 0x6f, 0xd9, 0xa5,
    545                0x25, 0x54, 0xee, 0x2a, 0x8d, 0xf1, 0x38, 0x6f,
    546                0x5b, 0x94, 0xa1, 0xa6, 0x0e, 0xd8, 0xa4, 0xae,
    547                0xf6, 0x0a, 0x8d, 0x61, 0xab, 0x5f, 0x22, 0x5a }
    548          #endif
    549          };
    550          
    551          static const unsigned char kwp_msg[][31] = {
    552              { 0xbd, 0x68, 0x43, 0xd4, 0x20, 0x37, 0x8d, 0xc8,
    553                0x96 },
    554          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    555              { 0x6c, 0xcd, 0xd5, 0x85, 0x18, 0x40, 0x97, 0xeb,
    556                0xd5, 0xc3, 0xaf, 0x3e, 0x47, 0xd0, 0x2c, 0x19,
    557                0x14, 0x7b, 0x4d, 0x99, 0x5f, 0x96, 0x43, 0x66,
    558                0x91, 0x56, 0x75, 0x8c, 0x13, 0x16, 0x8f },
    559              { 0xd1 }
    560          #endif
    561          };
    562          static const size_t kwp_msg_len[] = {
    563              9,
    564          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    565              31,
    566              1
    567          #endif
    568          };
    569          
    570          static const unsigned char kwp_res[][48] = {
    571              { 0x41, 0xec, 0xa9, 0x56, 0xd4, 0xaa, 0x04, 0x7e,
    572                0xb5, 0xcf, 0x4e, 0xfe, 0x65, 0x96, 0x61, 0xe7,
    573                0x4d, 0xb6, 0xf8, 0xc5, 0x64, 0xe2, 0x35, 0x00 },
    574          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    575              { 0x4e, 0x9b, 0xc2, 0xbc, 0xbc, 0x6c, 0x1e, 0x13,
    576                0xd3, 0x35, 0xbc, 0xc0, 0xf7, 0x73, 0x6a, 0x88,
    577                0xfa, 0x87, 0x53, 0x66, 0x15, 0xbb, 0x8e, 0x63,
    578                0x8b, 0xcc, 0x81, 0x66, 0x84, 0x68, 0x17, 0x90,
    579                0x67, 0xcf, 0xa9, 0x8a, 0x9d, 0x0e, 0x33, 0x26 },
    580              { 0x06, 0xba, 0x7a, 0xe6, 0xf3, 0x24, 0x8c, 0xfd,
    581                0xcf, 0x26, 0x75, 0x07, 0xfa, 0x00, 0x1b, 0xc4  }
    582          #endif
    583          };
    584          static const size_t kwp_out_len[] = {
    585              24,
    586          #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)
    587              40,
    588              16
    589          #endif
    590          };
    591          
    592          int mbedtls_nist_kw_self_test(int verbose)
    593          {
    594              mbedtls_nist_kw_context ctx;
    595              unsigned char out[48];
    596              size_t olen;
    597              int i;
    598              int ret = 0;
    599              mbedtls_nist_kw_init(&ctx);
    600          
    601              /*
    602               * KW mode
    603               */
    604              {
    605                  static const int num_tests = sizeof(kw_key) / sizeof(*kw_key);
    606          
    607                  for (i = 0; i < num_tests; i++) {
    608                      if (verbose != 0) {
    609                          mbedtls_printf("  KW-AES-%u ", (unsigned int) key_len[i] * 8);
    610                      }
    611          
    612                      ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
    613                                                   kw_key[i], key_len[i] * 8, 1);
    614                      if (ret != 0) {
    615                          if (verbose != 0) {
    616                              mbedtls_printf("  KW: setup failed ");
    617                          }
    618          
    619                          goto end;
    620                      }
    621          
    622                      ret = mbedtls_nist_kw_wrap(&ctx, MBEDTLS_KW_MODE_KW, kw_msg[i],
    623                                                 kw_msg_len[i], out, &olen, sizeof(out));
    624                      if (ret != 0 || kw_out_len[i] != olen ||
    625                          memcmp(out, kw_res[i], kw_out_len[i]) != 0) {
    626                          if (verbose != 0) {
    627                              mbedtls_printf("failed. ");
    628                          }
    629          
    630                          ret = 1;
    631                          goto end;
    632                      }
    633          
    634                      if ((ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
    635                                                        kw_key[i], key_len[i] * 8, 0))
    636                          != 0) {
    637                          if (verbose != 0) {
    638                              mbedtls_printf("  KW: setup failed ");
    639                          }
    640          
    641                          goto end;
    642                      }
    643          
    644                      ret = mbedtls_nist_kw_unwrap(&ctx, MBEDTLS_KW_MODE_KW,
    645                                                   out, olen, out, &olen, sizeof(out));
    646          
    647                      if (ret != 0 || olen != kw_msg_len[i] ||
    648                          memcmp(out, kw_msg[i], kw_msg_len[i]) != 0) {
    649                          if (verbose != 0) {
    650                              mbedtls_printf("failed\n");
    651                          }
    652          
    653                          ret = 1;
    654                          goto end;
    655                      }
    656          
    657                      if (verbose != 0) {
    658                          mbedtls_printf(" passed\n");
    659                      }
    660                  }
    661              }
    662          
    663              /*
    664               * KWP mode
    665               */
    666              {
    667                  static const int num_tests = sizeof(kwp_key) / sizeof(*kwp_key);
    668          
    669                  for (i = 0; i < num_tests; i++) {
    670                      olen = sizeof(out);
    671                      if (verbose != 0) {
    672                          mbedtls_printf("  KWP-AES-%u ", (unsigned int) key_len[i] * 8);
    673                      }
    674          
    675                      ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES, kwp_key[i],
    676                                                   key_len[i] * 8, 1);
    677                      if (ret  != 0) {
    678                          if (verbose != 0) {
    679                              mbedtls_printf("  KWP: setup failed ");
    680                          }
    681          
    682                          goto end;
    683                      }
    684                      ret = mbedtls_nist_kw_wrap(&ctx, MBEDTLS_KW_MODE_KWP, kwp_msg[i],
    685                                                 kwp_msg_len[i], out, &olen, sizeof(out));
    686          
    687                      if (ret != 0 || kwp_out_len[i] != olen ||
    688                          memcmp(out, kwp_res[i], kwp_out_len[i]) != 0) {
    689                          if (verbose != 0) {
    690                              mbedtls_printf("failed. ");
    691                          }
    692          
    693                          ret = 1;
    694                          goto end;
    695                      }
    696          
    697                      if ((ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
    698                                                        kwp_key[i], key_len[i] * 8, 0))
    699                          != 0) {
    700                          if (verbose != 0) {
    701                              mbedtls_printf("  KWP: setup failed ");
    702                          }
    703          
    704                          goto end;
    705                      }
    706          
    707                      ret = mbedtls_nist_kw_unwrap(&ctx, MBEDTLS_KW_MODE_KWP, out,
    708                                                   olen, out, &olen, sizeof(out));
    709          
    710                      if (ret != 0 || olen != kwp_msg_len[i] ||
    711                          memcmp(out, kwp_msg[i], kwp_msg_len[i]) != 0) {
    712                          if (verbose != 0) {
    713                              mbedtls_printf("failed. ");
    714                          }
    715          
    716                          ret = 1;
    717                          goto end;
    718                      }
    719          
    720                      if (verbose != 0) {
    721                          mbedtls_printf(" passed\n");
    722                      }
    723                  }
    724              }
    725          end:
    726              mbedtls_nist_kw_free(&ctx);
    727          
    728              if (verbose != 0) {
    729                  mbedtls_printf("\n");
    730              }
    731          
    732              return ret;
    733          }
    734          
    735          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
    736          
    737          #endif /* MBEDTLS_NIST_KW_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   calc_a_xor_t
        24 __aeabi_llsr
       0   mbedtls_bswap32
       0   mbedtls_ct_bool
       8   mbedtls_ct_if
       4   mbedtls_get_unaligned_uint32
       8   mbedtls_nist_kw_free
         8   -> mbedtls_cipher_free
         0   -> mbedtls_platform_zeroize
       0   mbedtls_nist_kw_init
         0   -> __aeabi_memclr4
      24   mbedtls_nist_kw_setkey
        24   -> mbedtls_cipher_free
        24   -> mbedtls_cipher_info_from_values
         0   -> mbedtls_cipher_setkey
        24   -> mbedtls_cipher_setup
      80   mbedtls_nist_kw_unwrap
        80   -> __aeabi_memclr
        80   -> mbedtls_bswap32
        80   -> mbedtls_cipher_update
        80   -> mbedtls_ct_bool
        80   -> mbedtls_ct_if
        80   -> mbedtls_ct_memcmp
        80   -> mbedtls_ct_memcmp_partial
        80   -> mbedtls_get_unaligned_uint32
        80   -> mbedtls_platform_zeroize
        80   -> unwrap
      80   mbedtls_nist_kw_wrap
        80   -> __aeabi_memclr
        80   -> __aeabi_memcpy
        80   -> __aeabi_memmove
        80   -> calc_a_xor_t
        80   -> mbedtls_bswap32
        80   -> mbedtls_cipher_update
        80   -> mbedtls_platform_zeroize
        80   -> mbedtls_put_unaligned_uint32
       4   mbedtls_put_unaligned_uint32
      88   unwrap
        88   -> __aeabi_memclr
        88   -> __aeabi_memmove
        88   -> calc_a_xor_t
        88   -> mbedtls_cipher_update
        88   -> mbedtls_platform_zeroize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       6  ?Subroutine0
       8  ?Subroutine1
       8  NIST_KW_ICV1
       4  NIST_KW_ICV2
      42  calc_a_xor_t
      26  mbedtls_bswap32
       2  mbedtls_byte_order_detector
      22  mbedtls_ct_bool
      20  mbedtls_ct_if
      12  mbedtls_get_unaligned_uint32
      20  mbedtls_nist_kw_free
       6  mbedtls_nist_kw_init
      94  mbedtls_nist_kw_setkey
     352  mbedtls_nist_kw_unwrap
     404  mbedtls_nist_kw_wrap
       8  mbedtls_put_unaligned_uint32
     214  unwrap

 
 1'264 bytes in section .text
 
 1'244 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
