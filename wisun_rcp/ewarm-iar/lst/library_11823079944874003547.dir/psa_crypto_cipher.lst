###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:31
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_cipher.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_cipher.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_cipher.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_cipher.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\psa_crypto_cipher.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\psa_crypto_cipher.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\psa_crypto_cipher.c
      1          /*
      2           *  PSA cipher driver entry points
      3           */
      4          /*
      5           *  Copyright The Mbed TLS Contributors
      6           *  SPDX-License-Identifier: Apache-2.0
      7           *
      8           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      9           *  not use this file except in compliance with the License.
     10           *  You may obtain a copy of the License at
     11           *
     12           *  http://www.apache.org/licenses/LICENSE-2.0
     13           *
     14           *  Unless required by applicable law or agreed to in writing, software
     15           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     16           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     17           *  See the License for the specific language governing permissions and
     18           *  limitations under the License.
     19           */
     20          
     21          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp unsigned char *mbedtls_buffer_offset(unsigned char *, size_t)
   \                     mbedtls_buffer_offset: (+1)
   \        0x0   0xB100             CBZ.N    R0,??mbedtls_buffer_offset_0
   \        0x2   0x4408             ADD      R0,R0,R1
   \                     ??mbedtls_buffer_offset_0: (+1)
   \        0x4   0x4770             BX       LR
     22          
     23          #if defined(MBEDTLS_PSA_CRYPTO_C)
     24          
     25          #include "psa_crypto_cipher.h"
     26          #include "psa_crypto_core.h"
     27          #include "psa_crypto_random_impl.h"
     28          
     29          #include "mbedtls/cipher.h"
     30          #include "mbedtls/error.h"
     31          
     32          #include <string.h>
     33          

   \                                 In section .text, align 2, keep-with-next
     34          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_psa(
     35              psa_algorithm_t alg,
     36              psa_key_type_t key_type,
     37              size_t key_bits,
     38              mbedtls_cipher_id_t *cipher_id)
     39          {
   \                     mbedtls_cipher_info_from_psa: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4614             MOV      R4,R2
     40          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES) || \
     41              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA) || \
     42              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES) || \
     43              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_CAMELLIA) || \
     44              defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20)
     45          
     46              mbedtls_cipher_mode_t mode;
     47              mbedtls_cipher_id_t cipher_id_tmp;
     48          
     49              if (PSA_ALG_IS_AEAD(alg)) {
   \        0x4   0xF000 0x42FE      AND      R2,R0,#0x7F000000
   \        0x8   0xF1B2 0x6FA0      CMP      R2,#+83886080
   \        0xC   0xBF08             IT       EQ
   \        0xE   0xF420 0x107E      BICEQ    R0,R0,#0x3F8000
     50                  alg = PSA_ALG_AEAD_WITH_SHORTENED_TAG(alg, 0);
     51              }
     52          
     53              if (PSA_ALG_IS_CIPHER(alg) || PSA_ALG_IS_AEAD(alg)) {
   \       0x12   0xF000 0x45FE      AND      R5,R0,#0x7F000000
   \       0x16   0xF1B5 0x6F80      CMP      R5,#+67108864
   \       0x1A   0xBF1C             ITT      NE
   \       0x1C   0xF000 0x42FE      ANDNE    R2,R0,#0x7F000000
   \       0x20   0xF1B2 0x6FA0      CMPNE    R2,#+83886080
   \       0x24   0xD10A             BNE.N    ??mbedtls_cipher_info_from_psa_0
     54                  switch (alg) {
   \       0x26   0x....             LDR.N    R2,??DataTable3
   \       0x28   0x4290             CMP      R0,R2
   \       0x2A   0xD003             BEQ.N    ??mbedtls_cipher_info_from_psa_1
   \       0x2C   0x....             LDR.N    R2,??DataTable3_1
   \       0x2E   0x4290             CMP      R0,R2
   \       0x30   0xD002             BEQ.N    ??mbedtls_cipher_info_from_psa_2
   \       0x32   0xE013             B.N      ??mbedtls_cipher_info_from_psa_3
     55          #if defined(MBEDTLS_PSA_BUILTIN_ALG_STREAM_CIPHER)
     56                      case PSA_ALG_STREAM_CIPHER:
     57                          mode = MBEDTLS_MODE_STREAM;
     58                          break;
     59          #endif
     60          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CTR)
     61                      case PSA_ALG_CTR:
     62                          mode = MBEDTLS_MODE_CTR;
     63                          break;
     64          #endif
     65          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CFB)
     66                      case PSA_ALG_CFB:
     67                          mode = MBEDTLS_MODE_CFB;
     68                          break;
     69          #endif
     70          #if defined(MBEDTLS_PSA_BUILTIN_ALG_OFB)
     71                      case PSA_ALG_OFB:
     72                          mode = MBEDTLS_MODE_OFB;
     73                          break;
     74          #endif
     75          #if defined(MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING)
     76                      case PSA_ALG_ECB_NO_PADDING:
     77                          mode = MBEDTLS_MODE_ECB;
     78                          break;
     79          #endif
     80          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING)
     81                      case PSA_ALG_CBC_NO_PADDING:
     82                          mode = MBEDTLS_MODE_CBC;
   \                     ??mbedtls_cipher_info_from_psa_1: (+1)
   \       0x34   0x2202             MOVS     R2,#+2
     83                          break;
   \       0x36   0xE005             B.N      ??mbedtls_cipher_info_from_psa_4
     84          #endif
     85          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7)
     86                      case PSA_ALG_CBC_PKCS7:
     87                          mode = MBEDTLS_MODE_CBC;
     88                          break;
     89          #endif
     90          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM_STAR_NO_TAG)
     91                      case PSA_ALG_CCM_STAR_NO_TAG:
     92                          mode = MBEDTLS_MODE_CCM_STAR_NO_TAG;
     93                          break;
     94          #endif
     95          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
     96                      case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, 0):
     97                          mode = MBEDTLS_MODE_CCM;
   \                     ??mbedtls_cipher_info_from_psa_2: (+1)
   \       0x38   0x2208             MOVS     R2,#+8
     98                          break;
   \       0x3A   0xE003             B.N      ??mbedtls_cipher_info_from_psa_4
     99          #endif
    100          #if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    101                      case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_GCM, 0):
    102                          mode = MBEDTLS_MODE_GCM;
    103                          break;
    104          #endif
    105          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305)
    106                      case PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CHACHA20_POLY1305, 0):
    107                          mode = MBEDTLS_MODE_CHACHAPOLY;
    108                          break;
    109          #endif
    110                      default:
    111                          return NULL;
    112                  }
    113              } else if (alg == PSA_ALG_CMAC) {
   \                     ??mbedtls_cipher_info_from_psa_0: (+1)
   \       0x3C   0x....             LDR.N    R2,??DataTable3_2
   \       0x3E   0x4290             CMP      R0,R2
   \       0x40   0xD10C             BNE.N    ??mbedtls_cipher_info_from_psa_3
    114                  mode = MBEDTLS_MODE_ECB;
   \       0x42   0x2201             MOVS     R2,#+1
    115              } else {
    116                  return NULL;
    117              }
    118          
    119              switch (key_type) {
   \                     ??mbedtls_cipher_info_from_psa_4: (+1)
   \       0x44   0xF5B1 0x5F10      CMP      R1,#+9216
   \       0x48   0xD108             BNE.N    ??mbedtls_cipher_info_from_psa_3
    120          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES)
    121                  case PSA_KEY_TYPE_AES:
    122                      cipher_id_tmp = MBEDTLS_CIPHER_ID_AES;
    123                      break;
    124          #endif
    125          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA)
    126                  case PSA_KEY_TYPE_ARIA:
    127                      cipher_id_tmp = MBEDTLS_CIPHER_ID_ARIA;
    128                      break;
    129          #endif
    130          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES)
    131                  case PSA_KEY_TYPE_DES:
    132                      /* key_bits is 64 for Single-DES, 128 for two-key Triple-DES,
    133                       * and 192 for three-key Triple-DES. */
    134                      if (key_bits == 64) {
    135                          cipher_id_tmp = MBEDTLS_CIPHER_ID_DES;
    136                      } else {
    137                          cipher_id_tmp = MBEDTLS_CIPHER_ID_3DES;
    138                      }
    139                      /* mbedtls doesn't recognize two-key Triple-DES as an algorithm,
    140                       * but two-key Triple-DES is functionally three-key Triple-DES
    141                       * with K1=K3, so that's how we present it to mbedtls. */
    142                      if (key_bits == 128) {
    143                          key_bits = 192;
    144                      }
    145                      break;
    146          #endif
    147          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_CAMELLIA)
    148                  case PSA_KEY_TYPE_CAMELLIA:
    149                      cipher_id_tmp = MBEDTLS_CIPHER_ID_CAMELLIA;
    150                      break;
    151          #endif
    152          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20)
    153                  case PSA_KEY_TYPE_CHACHA20:
    154                      cipher_id_tmp = MBEDTLS_CIPHER_ID_CHACHA20;
    155                      break;
    156          #endif
    157                  default:
    158                      return NULL;
    159              }
    160              if (cipher_id != NULL) {
   \       0x4A   0xB10B             CBZ.N    R3,??mbedtls_cipher_info_from_psa_5
    161                  *cipher_id = cipher_id_tmp;
   \       0x4C   0x2102             MOVS     R1,#+2
   \       0x4E   0x7019             STRB     R1,[R3, #+0]
    162              }
    163          
    164              return mbedtls_cipher_info_from_values(cipher_id_tmp,
    165                                                     (int) key_bits, mode);
   \                     ??mbedtls_cipher_info_from_psa_5: (+1)
   \       0x50   0x4621             MOV      R1,R4
   \       0x52   0x2002             MOVS     R0,#+2
   \       0x54   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x58   0x.... 0x....      B.W      mbedtls_cipher_info_from_values
   \                     ??mbedtls_cipher_info_from_psa_3: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}
    166          #else
    167              (void) alg;
    168              (void) key_type;
    169              (void) key_bits;
    170              (void) cipher_id;
    171          
    172              return NULL;
    173          #endif
    174          }
    175          
    176          #if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
    177          

   \                                 In section .text, align 2, keep-with-next
    178          static psa_status_t psa_cipher_setup(
    179              mbedtls_psa_cipher_operation_t *operation,
    180              const psa_key_attributes_t *attributes,
    181              const uint8_t *key_buffer, size_t key_buffer_size,
    182              psa_algorithm_t alg,
    183              mbedtls_operation_t cipher_operation)
    184          {
   \                     psa_cipher_setup: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x9E06             LDR      R6,[SP, #+24]
    185              int ret = 0;
    186              size_t key_bits;
    187              const mbedtls_cipher_info_t *cipher_info = NULL;
    188              psa_key_type_t key_type = attributes->core.type;
   \        0xC   0xF8B8 0x7000      LDRH     R7,[R8, #+0]
    189          
    190              (void) key_buffer_size;
    191          
    192              mbedtls_cipher_init(&operation->ctx.cipher);
   \       0x10   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x14   0x.... 0x....      BL       mbedtls_cipher_init
    193          
    194              operation->alg = alg;
   \       0x18   0x6026             STR      R6,[R4, #+0]
    195              key_bits = attributes->core.bits;
   \       0x1A   0xF8B8 0x8002      LDRH     R8,[R8, #+2]
    196              cipher_info = mbedtls_cipher_info_from_psa(alg, key_type,
    197                                                         key_bits, NULL);
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x4639             MOV      R1,R7
   \       0x22   0x4642             MOV      R2,R8
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x.... 0x....      BL       mbedtls_cipher_info_from_psa
    198              if (cipher_info == NULL) {
   \       0x2A   0xB910             CBNZ.N   R0,??psa_cipher_setup_0
    199                  return PSA_ERROR_NOT_SUPPORTED;
   \       0x2C   0xF06F 0x0085      MVN      R0,#+133
   \       0x30   0xE062             B.N      ??psa_cipher_setup_1
    200              }
    201          
    202              ret = mbedtls_cipher_setup(&operation->ctx.cipher, cipher_info);
   \                     ??psa_cipher_setup_0: (+1)
   \       0x32   0x4601             MOV      R1,R0
   \       0x34   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x38   0x.... 0x....      BL       mbedtls_cipher_setup
    203              if (ret != 0) {
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD157             BNE.N    ??psa_cipher_setup_2
   \       0x40   0xF99D 0x301C      LDRSB    R3,[SP, #+28]
    204                  goto exit;
    205              }
    206          
    207          #if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES)
    208              if (key_type == PSA_KEY_TYPE_DES && key_bits == 128) {
    209                  /* Two-key Triple-DES is 3-key Triple-DES with K1=K3 */
    210                  uint8_t keys[24];
    211                  memcpy(keys, key_buffer, 16);
    212                  memcpy(keys + 16, key_buffer, 8);
    213                  ret = mbedtls_cipher_setkey(&operation->ctx.cipher,
    214                                              keys,
    215                                              192, cipher_operation);
    216              } else
    217          #endif
    218              {
    219                  ret = mbedtls_cipher_setkey(&operation->ctx.cipher, key_buffer,
    220                                              (int) key_bits, cipher_operation);
   \       0x44   0x4642             MOV      R2,R8
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x4C   0x.... 0x....      BL       mbedtls_cipher_setkey
    221              }
    222              if (ret != 0) {
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD14D             BNE.N    ??psa_cipher_setup_2
    223                  goto exit;
    224              }
    225          
    226          #if defined(MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING) || \
    227              defined(MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7)
    228              switch (alg) {
   \       0x54   0x....             LDR.N    R1,??DataTable3
   \       0x56   0x428E             CMP      R6,R1
   \       0x58   0xD003             BEQ.N    ??psa_cipher_setup_3
   \       0x5A   0x....             LDR.N    R1,??DataTable3_3
   \       0x5C   0x428E             CMP      R6,R1
   \       0x5E   0xD002             BEQ.N    ??psa_cipher_setup_4
   \       0x60   0xE006             B.N      ??psa_cipher_setup_5
    229                  case PSA_ALG_CBC_NO_PADDING:
    230                      ret = mbedtls_cipher_set_padding_mode(&operation->ctx.cipher,
    231                                                            MBEDTLS_PADDING_NONE);
   \                     ??psa_cipher_setup_3: (+1)
   \       0x62   0x2104             MOVS     R1,#+4
   \       0x64   0xE000             B.N      ??psa_cipher_setup_6
    232                      break;
    233                  case PSA_ALG_CBC_PKCS7:
    234                      ret = mbedtls_cipher_set_padding_mode(&operation->ctx.cipher,
    235                                                            MBEDTLS_PADDING_PKCS7);
   \                     ??psa_cipher_setup_4: (+1)
   \       0x66   0x2100             MOVS     R1,#+0
   \                     ??psa_cipher_setup_6: (+1)
   \       0x68   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x6C   0x.... 0x....      BL       mbedtls_cipher_set_padding_mode
    236                      break;
    237                  default:
    238                      /* The algorithm doesn't involve padding. */
    239                      ret = 0;
    240                      break;
    241              }
    242              if (ret != 0) {
   \                     ??psa_cipher_setup_5: (+1)
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD13D             BNE.N    ??psa_cipher_setup_2
    243                  goto exit;
    244              }
    245          #endif /* MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING ||
    246                    MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7 */
    247          
    248              operation->block_length = (PSA_ALG_IS_STREAM_CIPHER(alg) ? 1 :
    249                                         PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type));
   \       0x74   0x0A39             LSRS     R1,R7,#+8
   \       0x76   0xF001 0x0107      AND      R1,R1,#0x7
   \       0x7A   0x2201             MOVS     R2,#+1
   \       0x7C   0xF006 0x45FF      AND      R5,R6,#0x7F800000
   \       0x80   0xFA02 0xF301      LSL      R3,R2,R1
   \       0x84   0xF1B5 0x6F90      CMP      R5,#+75497472
   \       0x88   0xBF08             IT       EQ
   \       0x8A   0x2501             MOVEQ    R5,#+1
   \       0x8C   0xD006             BEQ.N    ??psa_cipher_setup_7
   \       0x8E   0xF407 0x45E0      AND      R5,R7,#0x7000
   \       0x92   0xF5B5 0x5F00      CMP      R5,#+8192
   \       0x96   0xBF0C             ITE      EQ
   \       0x98   0x461D             MOVEQ    R5,R3
   \       0x9A   0x2500             MOVNE    R5,#+0
   \                     ??psa_cipher_setup_7: (+1)
   \       0x9C   0x7165             STRB     R5,[R4, #+5]
    250              operation->iv_length = PSA_CIPHER_IV_LENGTH(key_type, alg);
   \       0x9E   0xF407 0x45E0      AND      R5,R7,#0x7000
   \       0xA2   0xF5B5 0x5F00      CMP      R5,#+8192
   \       0xA6   0xD115             BNE.N    ??psa_cipher_setup_8
   \       0xA8   0xFA02 0xF101      LSL      R1,R2,R1
   \       0xAC   0x2901             CMP      R1,#+1
   \       0xAE   0xD911             BLS.N    ??psa_cipher_setup_8
   \       0xB0   0x....             LDR.N    R2,??DataTable3_4
   \       0xB2   0x4296             CMP      R6,R2
   \       0xB4   0xBF1C             ITT      NE
   \       0xB6   0x....             LDRNE.N  R1,??DataTable3_5
   \       0xB8   0x428E             CMPNE    R6,R1
   \       0xBA   0xD018             BEQ.N    ??psa_cipher_setup_9
   \       0xBC   0x....             LDR.N    R2,??DataTable3_6
   \       0xBE   0x4296             CMP      R6,R2
   \       0xC0   0xBF1C             ITT      NE
   \       0xC2   0x....             LDRNE.N  R1,??DataTable3_7
   \       0xC4   0x428E             CMPNE    R6,R1
   \       0xC6   0xD012             BEQ.N    ??psa_cipher_setup_9
   \       0xC8   0x....             LDR.N    R2,??DataTable3
   \       0xCA   0x4296             CMP      R6,R2
   \       0xCC   0xBF1C             ITT      NE
   \       0xCE   0x....             LDRNE.N  R1,??DataTable3_3
   \       0xD0   0x428E             CMPNE    R6,R1
   \       0xD2   0xD00C             BEQ.N    ??psa_cipher_setup_9
   \                     ??psa_cipher_setup_8: (+1)
   \       0xD4   0xF242 0x0204      MOVW     R2,#+8196
   \       0xD8   0x4297             CMP      R7,R2
   \       0xDA   0xBF02             ITTT     EQ
   \       0xDC   0x....             LDREQ.N  R1,??DataTable3_8
   \       0xDE   0x428E             CMPEQ    R6,R1
   \       0xE0   0x230C             MOVEQ    R3,#+12
   \       0xE2   0xD004             BEQ.N    ??psa_cipher_setup_9
   \       0xE4   0x....             LDR.N    R1,??DataTable3_9
   \       0xE6   0x428E             CMP      R6,R1
   \       0xE8   0xBF0C             ITE      EQ
   \       0xEA   0x230D             MOVEQ    R3,#+13
   \       0xEC   0x2300             MOVNE    R3,#+0
   \                     ??psa_cipher_setup_9: (+1)
   \       0xEE   0x7123             STRB     R3,[R4, #+4]
    251          
    252          exit:
    253              return mbedtls_to_psa_error(ret);
   \                     ??psa_cipher_setup_2: (+1)
   \       0xF0   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xF4   0x.... 0x....      B.W      mbedtls_to_psa_error
   \                     ??psa_cipher_setup_1: (+1)
   \       0xF8   0xE8BD 0x81F0      POP      {R4-R8,PC}
    254          }
    255          

   \                                 In section .text, align 2, keep-with-next
    256          psa_status_t mbedtls_psa_cipher_encrypt_setup(
    257              mbedtls_psa_cipher_operation_t *operation,
    258              const psa_key_attributes_t *attributes,
    259              const uint8_t *key_buffer, size_t key_buffer_size,
    260              psa_algorithm_t alg)
    261          {
   \                     mbedtls_psa_cipher_encrypt_setup: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    262              return psa_cipher_setup(operation, attributes,
    263                                      key_buffer, key_buffer_size,
    264                                      alg, MBEDTLS_ENCRYPT);
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
   \        0x4   0x2501             MOVS     R5,#+1
   \        0x6   0x....             B.N      ?Subroutine0
    265          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x9501             STR      R5,[SP, #+4]
   \        0x2   0x9400             STR      R4,[SP, #+0]
   \        0x4   0x.... 0x....      BL       psa_cipher_setup
   \        0x8   0xBD3E             POP      {R1-R5,PC}
    266          

   \                                 In section .text, align 2, keep-with-next
    267          psa_status_t mbedtls_psa_cipher_decrypt_setup(
    268              mbedtls_psa_cipher_operation_t *operation,
    269              const psa_key_attributes_t *attributes,
    270              const uint8_t *key_buffer, size_t key_buffer_size,
    271              psa_algorithm_t alg)
    272          {
   \                     mbedtls_psa_cipher_decrypt_setup: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    273              return psa_cipher_setup(operation, attributes,
    274                                      key_buffer, key_buffer_size,
    275                                      alg, MBEDTLS_DECRYPT);
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6                      REQUIRE ?Subroutine0
   \        0x6                      ;; // Fall through to label ?Subroutine0
    276          }
    277          

   \                                 In section .text, align 2, keep-with-next
    278          psa_status_t mbedtls_psa_cipher_set_iv(
    279              mbedtls_psa_cipher_operation_t *operation,
    280              const uint8_t *iv, size_t iv_length)
    281          {
   \                     mbedtls_psa_cipher_set_iv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    282              if (iv_length != operation->iv_length) {
   \        0x2   0x7903             LDRB     R3,[R0, #+4]
   \        0x4   0x429A             CMP      R2,R3
   \        0x6   0xD002             BEQ.N    ??mbedtls_psa_cipher_set_iv_0
    283                  return PSA_ERROR_INVALID_ARGUMENT;
   \        0x8   0xF06F 0x0086      MVN      R0,#+134
   \        0xC   0xBD02             POP      {R1,PC}
    284              }
    285          
    286              return mbedtls_to_psa_error(
    287                  mbedtls_cipher_set_iv(&operation->ctx.cipher,
    288                                        iv, iv_length));
   \                     ??mbedtls_psa_cipher_set_iv_0: (+1)
   \        0xE   0x3008             ADDS     R0,R0,#+8
   \       0x10   0x.... 0x....      BL       mbedtls_cipher_set_iv
   \       0x14   0xE8BD 0x4002      POP      {R1,LR}
   \       0x18   0x.... 0x....      B.W      mbedtls_to_psa_error
    289          }
    290          
    291          #if defined(MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING)
    292          /** Process input for which the algorithm is set to ECB mode.
    293           *
    294           * This requires manual processing, since the PSA API is defined as being
    295           * able to process arbitrary-length calls to psa_cipher_update() with ECB mode,
    296           * but the underlying mbedtls_cipher_update only takes full blocks.
    297           *
    298           * \param ctx           The mbedtls cipher context to use. It must have been
    299           *                      set up for ECB.
    300           * \param[in] input     The input plaintext or ciphertext to process.
    301           * \param input_length  The number of bytes to process from \p input.
    302           *                      This does not need to be aligned to a block boundary.
    303           *                      If there is a partial block at the end of the input,
    304           *                      it is stored in \p ctx for future processing.
    305           * \param output        The buffer where the output is written. It must be
    306           *                      at least `BS * floor((p + input_length) / BS)` bytes
    307           *                      long, where `p` is the number of bytes in the
    308           *                      unprocessed partial block in \p ctx (with
    309           *                      `0 <= p <= BS - 1`) and `BS` is the block size.
    310           * \param output_length On success, the number of bytes written to \p output.
    311           *                      \c 0 on error.
    312           *
    313           * \return #PSA_SUCCESS or an error from a hardware accelerator
    314           */
    315          static psa_status_t psa_cipher_update_ecb(
    316              mbedtls_cipher_context_t *ctx,
    317              const uint8_t *input,
    318              size_t input_length,
    319              uint8_t *output,
    320              size_t *output_length)
    321          {
    322              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    323              size_t block_size = mbedtls_cipher_info_get_block_size(ctx->cipher_info);
    324              size_t internal_output_length = 0;
    325              *output_length = 0;
    326          
    327              if (input_length == 0) {
    328                  status = PSA_SUCCESS;
    329                  goto exit;
    330              }
    331          
    332              if (ctx->unprocessed_len > 0) {
    333                  /* Fill up to block size, and run the block if there's a full one. */
    334                  size_t bytes_to_copy = block_size - ctx->unprocessed_len;
    335          
    336                  if (input_length < bytes_to_copy) {
    337                      bytes_to_copy = input_length;
    338                  }
    339          
    340                  memcpy(&(ctx->unprocessed_data[ctx->unprocessed_len]),
    341                         input, bytes_to_copy);
    342                  input_length -= bytes_to_copy;
    343                  input += bytes_to_copy;
    344                  ctx->unprocessed_len += bytes_to_copy;
    345          
    346                  if (ctx->unprocessed_len == block_size) {
    347                      status = mbedtls_to_psa_error(
    348                          mbedtls_cipher_update(ctx,
    349                                                ctx->unprocessed_data,
    350                                                block_size,
    351                                                output, &internal_output_length));
    352          
    353                      if (status != PSA_SUCCESS) {
    354                          goto exit;
    355                      }
    356          
    357                      output += internal_output_length;
    358                      *output_length += internal_output_length;
    359                      ctx->unprocessed_len = 0;
    360                  }
    361              }
    362          
    363              while (input_length >= block_size) {
    364                  /* Run all full blocks we have, one by one */
    365                  status = mbedtls_to_psa_error(
    366                      mbedtls_cipher_update(ctx, input,
    367                                            block_size,
    368                                            output, &internal_output_length));
    369          
    370                  if (status != PSA_SUCCESS) {
    371                      goto exit;
    372                  }
    373          
    374                  input_length -= block_size;
    375                  input += block_size;
    376          
    377                  output += internal_output_length;
    378                  *output_length += internal_output_length;
    379              }
    380          
    381              if (input_length > 0) {
    382                  /* Save unprocessed bytes for later processing */
    383                  memcpy(&(ctx->unprocessed_data[ctx->unprocessed_len]),
    384                         input, input_length);
    385                  ctx->unprocessed_len += input_length;
    386              }
    387          
    388              status = PSA_SUCCESS;
    389          
    390          exit:
    391              return status;
    392          }
    393          #endif /* MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING */
    394          

   \                                 In section .text, align 2, keep-with-next
    395          psa_status_t mbedtls_psa_cipher_update(
    396              mbedtls_psa_cipher_operation_t *operation,
    397              const uint8_t *input, size_t input_length,
    398              uint8_t *output, size_t output_size, size_t *output_length)
    399          {
   \                     mbedtls_psa_cipher_update: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    400              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    401              size_t expected_output_size;
    402          
    403              if (!PSA_ALG_IS_STREAM_CIPHER(operation->alg)) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0xF004 0x44FF      AND      R4,R4,#0x7F800000
   \        0x8   0xF1B4 0x6F90      CMP      R4,#+75497472
   \        0xC   0xD006             BEQ.N    ??mbedtls_psa_cipher_update_0
    404                  /* Take the unprocessed partial block left over from previous
    405                   * update calls, if any, plus the input to this call. Remove
    406                   * the last partial block, if any. You get the data that will be
    407                   * output in this call. */
    408                  expected_output_size =
    409                      (operation->ctx.cipher.unprocessed_len + input_length)
    410                      / operation->block_length * operation->block_length;
   \        0xE   0x6AC5             LDR      R5,[R0, #+44]
   \       0x10   0x7944             LDRB     R4,[R0, #+5]
   \       0x12   0x1955             ADDS     R5,R2,R5
   \       0x14   0xFBB5 0xF5F4      UDIV     R5,R5,R4
   \       0x18   0x436C             MULS     R4,R4,R5
   \       0x1A   0xE000             B.N      ??mbedtls_psa_cipher_update_1
    411              } else {
    412                  expected_output_size = input_length;
   \                     ??mbedtls_psa_cipher_update_0: (+1)
   \       0x1C   0x4614             MOV      R4,R2
   \                     ??mbedtls_psa_cipher_update_1: (+1)
   \       0x1E   0x9D04             LDR      R5,[SP, #+16]
    413              }
    414          
    415              if (output_size < expected_output_size) {
   \       0x20   0x42A5             CMP      R5,R4
   \       0x22   0xD202             BCS.N    ??mbedtls_psa_cipher_update_2
    416                  return PSA_ERROR_BUFFER_TOO_SMALL;
   \       0x24   0xF06F 0x0089      MVN      R0,#+137
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
    417              }
   \                     ??mbedtls_psa_cipher_update_2: (+1)
   \       0x2A   0x9C05             LDR      R4,[SP, #+20]
    418          
    419          #if defined(MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING)
    420              if (operation->alg == PSA_ALG_ECB_NO_PADDING) {
    421                  /* mbedtls_cipher_update has an API inconsistency: it will only
    422                   * process a single block at a time in ECB mode. Abstract away that
    423                   * inconsistency here to match the PSA API behaviour. */
    424                  status = psa_cipher_update_ecb(&operation->ctx.cipher,
    425                                                 input,
    426                                                 input_length,
    427                                                 output,
    428                                                 output_length);
    429              } else
    430          #endif /* MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING */
    431              {
    432                  status = mbedtls_to_psa_error(
    433                      mbedtls_cipher_update(&operation->ctx.cipher, input,
    434                                            input_length, output, output_length));
   \       0x2C   0x3008             ADDS     R0,R0,#+8
   \       0x2E   0x9400             STR      R4,[SP, #+0]
   \       0x30   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x34   0x.... 0x....      BL       mbedtls_to_psa_error
    435          
    436                  if (*output_length > output_size) {
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x428D             CMP      R5,R1
   \       0x3C   0xBF38             IT       CC
   \       0x3E   0xF06F 0x0096      MVNCC    R0,#+150
    437                      return PSA_ERROR_CORRUPTION_DETECTED;
    438                  }
    439              }
    440          
    441              return status;
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    442          }
    443          

   \                                 In section .text, align 2, keep-with-next
    444          psa_status_t mbedtls_psa_cipher_finish(
    445              mbedtls_psa_cipher_operation_t *operation,
    446              uint8_t *output, size_t output_size, size_t *output_length)
    447          {
   \                     mbedtls_psa_cipher_finish: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x460D             MOV      R5,R1
    448              psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    449              uint8_t temp_output_buffer[MBEDTLS_MAX_BLOCK_LENGTH];
    450          
    451              if (operation->ctx.cipher.unprocessed_len != 0) {
   \        0x6   0x6AC1             LDR      R1,[R0, #+44]
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   \        0xC   0xB141             CBZ.N    R1,??mbedtls_psa_cipher_finish_0
    452                  if (operation->alg == PSA_ALG_ECB_NO_PADDING ||
    453                      operation->alg == PSA_ALG_CBC_NO_PADDING) {
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x....             LDR.N    R3,??DataTable3_10
   \       0x12   0x4299             CMP      R1,R3
   \       0x14   0xBF1A             ITTE     NE
   \       0x16   0x....             LDRNE.N  R2,??DataTable3
   \       0x18   0x4291             CMPNE    R1,R2
   \       0x1A   0xF06F 0x0486      MVNEQ    R4,#+134
    454                      status = PSA_ERROR_INVALID_ARGUMENT;
    455                      goto exit;
   \       0x1E   0xD013             BEQ.N    ??mbedtls_psa_cipher_finish_1
    456                  }
    457              }
    458          
    459              status = mbedtls_to_psa_error(
    460                  mbedtls_cipher_finish(&operation->ctx.cipher,
    461                                        temp_output_buffer,
    462                                        output_length));
   \                     ??mbedtls_psa_cipher_finish_0: (+1)
   \       0x20   0x463A             MOV      R2,R7
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x3008             ADDS     R0,R0,#+8
   \       0x26   0x.... 0x....      BL       mbedtls_cipher_finish
   \       0x2A   0x.... 0x....      BL       mbedtls_to_psa_error
   \       0x2E   0x0004             MOVS     R4,R0
    463              if (status != PSA_SUCCESS) {
   \       0x30   0xD10A             BNE.N    ??mbedtls_psa_cipher_finish_1
    464                  goto exit;
    465              }
    466          
    467              if (*output_length == 0) {
   \       0x32   0x683A             LDR      R2,[R7, #+0]
   \       0x34   0xB142             CBZ.N    R2,??mbedtls_psa_cipher_finish_1
    468                  ; /* Nothing to copy. Note that output may be NULL in this case. */
    469              } else if (output_size >= *output_length) {
   \       0x36   0x4296             CMP      R6,R2
   \       0x38   0xD304             BCC.N    ??mbedtls_psa_cipher_finish_2
    470                  memcpy(output, temp_output_buffer, *output_length);
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       __aeabi_memcpy
    471              } else {
   \       0x42   0xE001             B.N      ??mbedtls_psa_cipher_finish_1
    472                  status = PSA_ERROR_BUFFER_TOO_SMALL;
   \                     ??mbedtls_psa_cipher_finish_2: (+1)
   \       0x44   0xF06F 0x0489      MVN      R4,#+137
    473              }
    474          
    475          exit:
    476              mbedtls_platform_zeroize(temp_output_buffer,
    477                                       sizeof(temp_output_buffer));
   \                     ??mbedtls_psa_cipher_finish_1: (+1)
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4668             MOV      R0,SP
   \       0x4C   0x.... 0x....      BL       mbedtls_platform_zeroize
    478          
    479              return status;
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0xB005             ADD      SP,SP,#+20
   \       0x54   0xBDF0             POP      {R4-R7,PC}
    480          }
    481          

   \                                 In section .text, align 2, keep-with-next
    482          psa_status_t mbedtls_psa_cipher_abort(
    483              mbedtls_psa_cipher_operation_t *operation)
    484          {
   \                     mbedtls_psa_cipher_abort: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    485              /* Sanity check (shouldn't happen: operation->alg should
    486               * always have been initialized to a valid value). */
    487              if (!PSA_ALG_IS_CIPHER(operation->alg)) {
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF001 0x41FE      AND      R1,R1,#0x7F000000
   \        0x8   0xF1B1 0x6F80      CMP      R1,#+67108864
   \        0xC   0xD002             BEQ.N    ??mbedtls_psa_cipher_abort_0
    488                  return PSA_ERROR_BAD_STATE;
   \        0xE   0xF06F 0x0088      MVN      R0,#+136
   \       0x12   0xBD02             POP      {R1,PC}
    489              }
    490          
    491              mbedtls_cipher_free(&operation->ctx.cipher);
   \                     ??mbedtls_psa_cipher_abort_0: (+1)
   \       0x14   0x3008             ADDS     R0,R0,#+8
   \       0x16   0x.... 0x....      BL       mbedtls_cipher_free
    492          
    493              return PSA_SUCCESS;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD02             POP      {R1,PC}
    494          }
    495          

   \                                 In section .text, align 2, keep-with-next
    496          psa_status_t mbedtls_psa_cipher_encrypt(
    497              const psa_key_attributes_t *attributes,
    498              const uint8_t *key_buffer,
    499              size_t key_buffer_size,
    500              psa_algorithm_t alg,
    501              const uint8_t *iv,
    502              size_t iv_length,
    503              const uint8_t *input,
    504              size_t input_length,
    505              uint8_t *output,
    506              size_t output_size,
    507              size_t *output_length)
    508          {
   \                     mbedtls_psa_cipher_encrypt: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB098             SUB      SP,SP,#+96
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
    509              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    510              mbedtls_psa_cipher_operation_t operation = MBEDTLS_PSA_CIPHER_OPERATION_INIT;
   \        0xC   0xA804             ADD      R0,SP,#+16
   \        0xE   0x2150             MOVS     R1,#+80
   \       0x10   0x.... 0x....      BL       __aeabi_memclr4
    511              size_t update_output_length, finish_output_length;
    512          
    513              status = mbedtls_psa_cipher_encrypt_setup(&operation, attributes,
    514                                                        key_buffer, key_buffer_size,
    515                                                        alg);
   \       0x14   0x9500             STR      R5,[SP, #+0]
   \       0x16   0x4623             MOV      R3,R4
   \       0x18   0x4632             MOV      R2,R6
   \       0x1A   0x4639             MOV      R1,R7
   \       0x1C   0xA804             ADD      R0,SP,#+16
   \       0x1E   0x.... 0x....      BL       mbedtls_psa_cipher_encrypt_setup
   \       0x22   0x0004             MOVS     R4,R0
    516              if (status != PSA_SUCCESS) {
   \       0x24   0xD127             BNE.N    ??mbedtls_psa_cipher_encrypt_0
   \       0x26   0x9A1F             LDR      R2,[SP, #+124]
    517                  goto exit;
    518              }
    519          
    520              if (iv_length > 0) {
   \       0x28   0xB12A             CBZ.N    R2,??mbedtls_psa_cipher_encrypt_1
   \       0x2A   0x991E             LDR      R1,[SP, #+120]
    521                  status = mbedtls_psa_cipher_set_iv(&operation, iv, iv_length);
   \       0x2C   0xA804             ADD      R0,SP,#+16
   \       0x2E   0x.... 0x....      BL       mbedtls_psa_cipher_set_iv
   \       0x32   0x0004             MOVS     R4,R0
    522                  if (status != PSA_SUCCESS) {
   \       0x34   0xD11F             BNE.N    ??mbedtls_psa_cipher_encrypt_0
   \                     ??mbedtls_psa_cipher_encrypt_1: (+1)
   \       0x36   0x9D23             LDR      R5,[SP, #+140]
   \       0x38   0x9E22             LDR      R6,[SP, #+136]
   \       0x3A   0x9A21             LDR      R2,[SP, #+132]
   \       0x3C   0x9920             LDR      R1,[SP, #+128]
    523                      goto exit;
    524                  }
    525              }
    526          
    527              status = mbedtls_psa_cipher_update(&operation, input, input_length,
    528                                                 output, output_size,
    529                                                 &update_output_length);
   \       0x3E   0xA802             ADD      R0,SP,#+8
   \       0x40   0x9001             STR      R0,[SP, #+4]
   \       0x42   0x9500             STR      R5,[SP, #+0]
   \       0x44   0x4633             MOV      R3,R6
   \       0x46   0xA804             ADD      R0,SP,#+16
   \       0x48   0x.... 0x....      BL       mbedtls_psa_cipher_update
   \       0x4C   0x0004             MOVS     R4,R0
    530              if (status != PSA_SUCCESS) {
   \       0x4E   0xD112             BNE.N    ??mbedtls_psa_cipher_encrypt_0
    531                  goto exit;
    532              }
    533          
    534              status = mbedtls_psa_cipher_finish(
    535                  &operation,
    536                  mbedtls_buffer_offset(output, update_output_length),
    537                  output_size - update_output_length, &finish_output_length);
   \       0x50   0x9902             LDR      R1,[SP, #+8]
   \       0x52   0x4630             MOV      R0,R6
   \       0x54   0x.... 0x....      BL       mbedtls_buffer_offset
   \       0x58   0x9902             LDR      R1,[SP, #+8]
   \       0x5A   0xAB03             ADD      R3,SP,#+12
   \       0x5C   0x1A6A             SUBS     R2,R5,R1
   \       0x5E   0x4601             MOV      R1,R0
   \       0x60   0xA804             ADD      R0,SP,#+16
   \       0x62   0x.... 0x....      BL       mbedtls_psa_cipher_finish
   \       0x66   0x0004             MOVS     R4,R0
    538              if (status != PSA_SUCCESS) {
   \       0x68   0xD105             BNE.N    ??mbedtls_psa_cipher_encrypt_0
    539                  goto exit;
    540              }
    541          
    542              *output_length = update_output_length + finish_output_length;
   \       0x6A   0x9902             LDR      R1,[SP, #+8]
   \       0x6C   0x9803             LDR      R0,[SP, #+12]
   \       0x6E   0x9A24             LDR      R2,[SP, #+144]
   \       0x70   0x1841             ADDS     R1,R0,R1
   \       0x72   0x6011             STR      R1,[R2, #+0]
   \       0x74   0xE000             B.N      ??mbedtls_psa_cipher_encrypt_2
    543          
    544          exit:
    545              if (status == PSA_SUCCESS) {
   \                     ??mbedtls_psa_cipher_encrypt_0: (+1)
   \       0x76   0xB924             CBNZ.N   R4,??mbedtls_psa_cipher_encrypt_3
    546                  status = mbedtls_psa_cipher_abort(&operation);
   \                     ??mbedtls_psa_cipher_encrypt_2: (+1)
   \       0x78   0xA804             ADD      R0,SP,#+16
   \       0x7A   0x.... 0x....      BL       mbedtls_psa_cipher_abort
   \       0x7E   0x4604             MOV      R4,R0
   \       0x80   0xE002             B.N      ??mbedtls_psa_cipher_encrypt_4
    547              } else {
    548                  mbedtls_psa_cipher_abort(&operation);
   \                     ??mbedtls_psa_cipher_encrypt_3: (+1)
   \       0x82   0xA804             ADD      R0,SP,#+16
   \       0x84   0x.... 0x....      BL       mbedtls_psa_cipher_abort
    549              }
    550          
    551              return status;
   \                     ??mbedtls_psa_cipher_encrypt_4: (+1)
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0xB019             ADD      SP,SP,#+100
   \       0x8C   0xBDF0             POP      {R4-R7,PC}
    552          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 68
    553          

   \                                 In section .text, align 2, keep-with-next
    554          psa_status_t mbedtls_psa_cipher_decrypt(
    555              const psa_key_attributes_t *attributes,
    556              const uint8_t *key_buffer,
    557              size_t key_buffer_size,
    558              psa_algorithm_t alg,
    559              const uint8_t *input,
    560              size_t input_length,
    561              uint8_t *output,
    562              size_t output_size,
    563              size_t *output_length)
    564          {
   \                     mbedtls_psa_cipher_decrypt: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB097             SUB      SP,SP,#+92
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
    565              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    566              mbedtls_psa_cipher_operation_t operation = MBEDTLS_PSA_CIPHER_OPERATION_INIT;
   \        0xC   0xA803             ADD      R0,SP,#+12
   \        0xE   0x2150             MOVS     R1,#+80
   \       0x10   0x.... 0x....      BL       __aeabi_memclr4
    567              size_t olength, accumulated_length;
    568          
    569              status = mbedtls_psa_cipher_decrypt_setup(&operation, attributes,
    570                                                        key_buffer, key_buffer_size,
    571                                                        alg);
   \       0x14   0x9500             STR      R5,[SP, #+0]
   \       0x16   0x4623             MOV      R3,R4
   \       0x18   0x4632             MOV      R2,R6
   \       0x1A   0x4639             MOV      R1,R7
   \       0x1C   0xA803             ADD      R0,SP,#+12
   \       0x1E   0x.... 0x....      BL       mbedtls_psa_cipher_decrypt_setup
   \       0x22   0x0004             MOVS     R4,R0
    572              if (status != PSA_SUCCESS) {
   \       0x24   0xD12E             BNE.N    ??mbedtls_psa_cipher_decrypt_0
    573                  goto exit;
    574              }
    575          
    576              if (operation.iv_length > 0) {
   \       0x26   0xF89D 0x2010      LDRB     R2,[SP, #+16]
   \       0x2A   0x9D1C             LDR      R5,[SP, #+112]
   \       0x2C   0xB12A             CBZ.N    R2,??mbedtls_psa_cipher_decrypt_1
    577                  status = mbedtls_psa_cipher_set_iv(&operation,
    578                                                     input, operation.iv_length);
   \       0x2E   0x4629             MOV      R1,R5
   \       0x30   0xA803             ADD      R0,SP,#+12
   \       0x32   0x.... 0x....      BL       mbedtls_psa_cipher_set_iv
   \       0x36   0x0004             MOVS     R4,R0
    579                  if (status != PSA_SUCCESS) {
   \       0x38   0xD124             BNE.N    ??mbedtls_psa_cipher_decrypt_0
    580                      goto exit;
    581                  }
    582              }
    583          
    584              status = mbedtls_psa_cipher_update(
    585                  &operation,
    586                  mbedtls_buffer_offset_const(input, operation.iv_length),
    587                  input_length - operation.iv_length,
    588                  output, output_size, &olength);
   \                     ??mbedtls_psa_cipher_decrypt_1: (+1)
   \       0x3A   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \       0x3E   0x2D00             CMP      R5,#+0
   \       0x40   0xBF0C             ITE      EQ
   \       0x42   0x2100             MOVEQ    R1,#+0
   \       0x44   0x1829             ADDNE    R1,R5,R0
   \       0x46   0x9A1D             LDR      R2,[SP, #+116]
   \       0x48   0x9D1F             LDR      R5,[SP, #+124]
   \       0x4A   0x9E1E             LDR      R6,[SP, #+120]
   \       0x4C   0xAB02             ADD      R3,SP,#+8
   \       0x4E   0x9301             STR      R3,[SP, #+4]
   \       0x50   0x1A12             SUBS     R2,R2,R0
   \       0x52   0x9500             STR      R5,[SP, #+0]
   \       0x54   0x4633             MOV      R3,R6
   \       0x56   0xA803             ADD      R0,SP,#+12
   \       0x58   0x.... 0x....      BL       mbedtls_psa_cipher_update
   \       0x5C   0x0004             MOVS     R4,R0
    589              if (status != PSA_SUCCESS) {
   \       0x5E   0xD111             BNE.N    ??mbedtls_psa_cipher_decrypt_0
    590                  goto exit;
    591              }
    592          
    593              accumulated_length = olength;
   \       0x60   0x9F02             LDR      R7,[SP, #+8]
    594          
    595              status = mbedtls_psa_cipher_finish(
    596                  &operation,
    597                  mbedtls_buffer_offset(output, accumulated_length),
    598                  output_size - accumulated_length, &olength);
   \       0x62   0x4630             MOV      R0,R6
   \       0x64   0x4639             MOV      R1,R7
   \       0x66   0x.... 0x....      BL       mbedtls_buffer_offset
   \       0x6A   0x4601             MOV      R1,R0
   \       0x6C   0xAB02             ADD      R3,SP,#+8
   \       0x6E   0x1BEA             SUBS     R2,R5,R7
   \       0x70   0xA803             ADD      R0,SP,#+12
   \       0x72   0x.... 0x....      BL       mbedtls_psa_cipher_finish
   \       0x76   0x0004             MOVS     R4,R0
    599              if (status != PSA_SUCCESS) {
   \       0x78   0xD104             BNE.N    ??mbedtls_psa_cipher_decrypt_0
    600                  goto exit;
    601              }
    602          
    603              *output_length = accumulated_length + olength;
   \       0x7A   0x9802             LDR      R0,[SP, #+8]
   \       0x7C   0x9920             LDR      R1,[SP, #+128]
   \       0x7E   0x19C7             ADDS     R7,R0,R7
   \       0x80   0x600F             STR      R7,[R1, #+0]
   \       0x82   0xE000             B.N      ??mbedtls_psa_cipher_decrypt_2
    604          
    605          exit:
    606              if (status == PSA_SUCCESS) {
   \                     ??mbedtls_psa_cipher_decrypt_0: (+1)
   \       0x84   0xB924             CBNZ.N   R4,??mbedtls_psa_cipher_decrypt_3
    607                  status = mbedtls_psa_cipher_abort(&operation);
   \                     ??mbedtls_psa_cipher_decrypt_2: (+1)
   \       0x86   0xA803             ADD      R0,SP,#+12
   \       0x88   0x.... 0x....      BL       mbedtls_psa_cipher_abort
   \       0x8C   0x4604             MOV      R4,R0
   \       0x8E   0xE002             B.N      ??mbedtls_psa_cipher_decrypt_4
    608              } else {
    609                  mbedtls_psa_cipher_abort(&operation);
   \                     ??mbedtls_psa_cipher_decrypt_3: (+1)
   \       0x90   0xA803             ADD      R0,SP,#+12
   \       0x92   0x.... 0x....      BL       mbedtls_psa_cipher_abort
    610              }
    611          
    612              return status;
   \                     ??mbedtls_psa_cipher_decrypt_4: (+1)
   \       0x96   0x4620             MOV      R0,R4
   \       0x98   0xB017             ADD      SP,SP,#+92
   \       0x9A   0xBDF0             POP      {R4-R7,PC}
    613          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'0000        DC32 0
   \        0xC                      DS8 68

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x0440'4000        DC32     0x4404000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x0540'0100        DC32     0x5400100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x03C0'0200        DC32     0x3c00200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x0440'4100        DC32     0x4404100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x04C0'1000        DC32     0x4c01000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x04C0'1100        DC32     0x4c01100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x04C0'1200        DC32     0x4c01200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x0440'FF00        DC32     0x440ff00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x0480'0100        DC32     0x4800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x04C0'1300        DC32     0x4c01300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \        0x0   0x0440'4400        DC32     0x4404400
    614          #endif /* MBEDTLS_PSA_BUILTIN_CIPHER */
    615          
    616          #endif /* MBEDTLS_PSA_CRYPTO_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_buffer_offset
      16   mbedtls_cipher_info_from_psa
         0   -> mbedtls_cipher_info_from_values
       8   mbedtls_psa_cipher_abort
         8   -> mbedtls_cipher_free
     112   mbedtls_psa_cipher_decrypt
       112   -> __aeabi_memclr4
       112   -> mbedtls_buffer_offset
       112   -> mbedtls_psa_cipher_abort
       112   -> mbedtls_psa_cipher_decrypt_setup
       112   -> mbedtls_psa_cipher_finish
       112   -> mbedtls_psa_cipher_set_iv
       112   -> mbedtls_psa_cipher_update
      24   mbedtls_psa_cipher_decrypt_setup
        24   -> psa_cipher_setup
     120   mbedtls_psa_cipher_encrypt
       120   -> __aeabi_memclr4
       120   -> mbedtls_buffer_offset
       120   -> mbedtls_psa_cipher_abort
       120   -> mbedtls_psa_cipher_encrypt_setup
       120   -> mbedtls_psa_cipher_finish
       120   -> mbedtls_psa_cipher_set_iv
       120   -> mbedtls_psa_cipher_update
      24   mbedtls_psa_cipher_encrypt_setup
        24   -> psa_cipher_setup
      40   mbedtls_psa_cipher_finish
        40   -> __aeabi_memcpy
        40   -> mbedtls_cipher_finish
        40   -> mbedtls_platform_zeroize
        40   -> mbedtls_to_psa_error
       8   mbedtls_psa_cipher_set_iv
         8   -> mbedtls_cipher_set_iv
         0   -> mbedtls_to_psa_error
      16   mbedtls_psa_cipher_update
        16   -> mbedtls_cipher_update
        16   -> mbedtls_to_psa_error
      24   psa_cipher_setup
        24   -> mbedtls_cipher_info_from_psa
        24   -> mbedtls_cipher_init
        24   -> mbedtls_cipher_set_padding_mode
        24   -> mbedtls_cipher_setkey
        24   -> mbedtls_cipher_setup
         0   -> mbedtls_to_psa_error


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      10  ?Subroutine0
      80  ?_0
      80  ?_1
       6  mbedtls_buffer_offset
      96  mbedtls_cipher_info_from_psa
      30  mbedtls_psa_cipher_abort
     156  mbedtls_psa_cipher_decrypt
       6  mbedtls_psa_cipher_decrypt_setup
     142  mbedtls_psa_cipher_encrypt
       8  mbedtls_psa_cipher_encrypt_setup
      86  mbedtls_psa_cipher_finish
      28  mbedtls_psa_cipher_set_iv
      68  mbedtls_psa_cipher_update
     252  psa_cipher_setup

 
 160 bytes in section .rodata
 932 bytes in section .text
 
 932 bytes of CODE  memory
 160 bytes of CONST memory

Errors: none
Warnings: none
