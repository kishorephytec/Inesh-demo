###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:24
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecdh.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecdh.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecdh.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecdh.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ecdh.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecdh.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecdh.c
      1          /*
      2           *  Elliptic curve Diffie-Hellman
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * References:
     22           *
     23           * SEC1 https://www.secg.org/sec1-v2.pdf
     24           * RFC 4492
     25           */
     26          
     27          #include "common.h"
     28          
     29          #if defined(MBEDTLS_ECDH_C)
     30          
     31          #include "mbedtls/ecdh.h"
     32          #include "mbedtls/platform_util.h"
     33          #include "mbedtls/error.h"
     34          
     35          #include <string.h>
     36          
     37          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
     38          typedef mbedtls_ecdh_context mbedtls_ecdh_context_mbed;
     39          #endif
     40          
     41          static mbedtls_ecp_group_id mbedtls_ecdh_grp_id(
     42              const mbedtls_ecdh_context *ctx)
     43          {
     44          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
     45              return ctx->grp.id;
     46          #else
     47              return ctx->grp_id;
     48          #endif
     49          }
     50          

   \                                 In section .text, align 2, keep-with-next
     51          int mbedtls_ecdh_can_do(mbedtls_ecp_group_id gid)
     52          {
     53              /* At this time, all groups support ECDH. */
     54              (void) gid;
     55              return 1;
   \                     mbedtls_ecdh_can_do: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR
     56          }
     57          
     58          #if !defined(MBEDTLS_ECDH_GEN_PUBLIC_ALT)
     59          /*
     60           * Generate public key (restartable version)
     61           *
     62           * Note: this internal function relies on its caller preserving the value of
     63           * the output parameter 'd' across continuation calls. This would not be
     64           * acceptable for a public function but is OK here as we control call sites.
     65           */
     66          static int ecdh_gen_public_restartable(mbedtls_ecp_group *grp,
     67                                                 mbedtls_mpi *d, mbedtls_ecp_point *Q,
     68                                                 int (*f_rng)(void *, unsigned char *, size_t),
     69                                                 void *p_rng,
     70                                                 mbedtls_ecp_restart_ctx *rs_ctx)
     71          {
     72              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     73          
     74              int restarting = 0;
     75          #if defined(MBEDTLS_ECP_RESTARTABLE)
     76              restarting = (rs_ctx != NULL && rs_ctx->rsm != NULL);
     77          #endif
     78              /* If multiplication is in progress, we already generated a privkey */
     79              if (!restarting) {
     80                  MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, d, f_rng, p_rng));
     81              }
     82          
     83              MBEDTLS_MPI_CHK(mbedtls_ecp_mul_restartable(grp, Q, d, &grp->G,
     84                                                          f_rng, p_rng, rs_ctx));
     85          
     86          cleanup:
     87              return ret;
     88          }
     89          
     90          /*
     91           * Generate public key
     92           */
     93          int mbedtls_ecdh_gen_public(mbedtls_ecp_group *grp, mbedtls_mpi *d, mbedtls_ecp_point *Q,
     94                                      int (*f_rng)(void *, unsigned char *, size_t),
     95                                      void *p_rng)
     96          {
     97              return ecdh_gen_public_restartable(grp, d, Q, f_rng, p_rng, NULL);
     98          }
     99          #endif /* !MBEDTLS_ECDH_GEN_PUBLIC_ALT */
    100          
    101          #if !defined(MBEDTLS_ECDH_COMPUTE_SHARED_ALT)
    102          /*
    103           * Compute shared secret (SEC1 3.3.1)
    104           */
    105          static int ecdh_compute_shared_restartable(mbedtls_ecp_group *grp,
    106                                                     mbedtls_mpi *z,
    107                                                     const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
    108                                                     int (*f_rng)(void *, unsigned char *, size_t),
    109                                                     void *p_rng,
    110                                                     mbedtls_ecp_restart_ctx *rs_ctx)
    111          {
    112              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    113              mbedtls_ecp_point P;
    114          
    115              mbedtls_ecp_point_init(&P);
    116          
    117              MBEDTLS_MPI_CHK(mbedtls_ecp_mul_restartable(grp, &P, d, Q,
    118                                                          f_rng, p_rng, rs_ctx));
    119          
    120              if (mbedtls_ecp_is_zero(&P)) {
    121                  ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    122                  goto cleanup;
    123              }
    124          
    125              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(z, &P.X));
    126          
    127          cleanup:
    128              mbedtls_ecp_point_free(&P);
    129          
    130              return ret;
    131          }
    132          
    133          /*
    134           * Compute shared secret (SEC1 3.3.1)
    135           */
    136          int mbedtls_ecdh_compute_shared(mbedtls_ecp_group *grp, mbedtls_mpi *z,
    137                                          const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
    138                                          int (*f_rng)(void *, unsigned char *, size_t),
    139                                          void *p_rng)
    140          {
    141              return ecdh_compute_shared_restartable(grp, z, Q, d,
    142                                                     f_rng, p_rng, NULL);
    143          }
    144          #endif /* !MBEDTLS_ECDH_COMPUTE_SHARED_ALT */
    145          
    146          static void ecdh_init_internal(mbedtls_ecdh_context_mbed *ctx)
    147          {
    148              mbedtls_ecp_group_init(&ctx->grp);
    149              mbedtls_mpi_init(&ctx->d);
    150              mbedtls_ecp_point_init(&ctx->Q);
    151              mbedtls_ecp_point_init(&ctx->Qp);
    152              mbedtls_mpi_init(&ctx->z);
    153          
    154          #if defined(MBEDTLS_ECP_RESTARTABLE)
    155              mbedtls_ecp_restart_init(&ctx->rs);
    156          #endif
    157          }
    158          
    159          /*
    160           * Initialize context
    161           */

   \                                 In section .text, align 2, keep-with-next
    162          void mbedtls_ecdh_init(mbedtls_ecdh_context *ctx)
    163          {
   \                     mbedtls_ecdh_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    164          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    165              ecdh_init_internal(ctx);
    166              mbedtls_ecp_point_init(&ctx->Vi);
    167              mbedtls_ecp_point_init(&ctx->Vf);
    168              mbedtls_mpi_init(&ctx->_d);
    169          #else
    170              memset(ctx, 0, sizeof(mbedtls_ecdh_context));
   \        0x4   0x21A4             MOVS     R1,#+164
   \        0x6   0x.... 0x....      BL       __aeabi_memclr4
    171          
    172              ctx->var = MBEDTLS_ECDH_VARIANT_NONE;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x70A2             STRB     R2,[R4, #+2]
    173          #endif
    174              ctx->point_format = MBEDTLS_ECP_PF_UNCOMPRESSED;
   \        0xE   0x7022             STRB     R2,[R4, #+0]
    175          #if defined(MBEDTLS_ECP_RESTARTABLE)
    176              ctx->restart_enabled = 0;
    177          #endif
    178          }
   \       0x10   0xBD10             POP      {R4,PC}
    179          
    180          static int ecdh_setup_internal(mbedtls_ecdh_context_mbed *ctx,
    181                                         mbedtls_ecp_group_id grp_id)
    182          {
    183              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    184          
    185              ret = mbedtls_ecp_group_load(&ctx->grp, grp_id);
    186              if (ret != 0) {
    187                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
    188              }
    189          
    190              return 0;
    191          }
    192          
    193          /*
    194           * Setup context
    195           */

   \                                 In section .text, align 2, keep-with-next
    196          int mbedtls_ecdh_setup(mbedtls_ecdh_context *ctx, mbedtls_ecp_group_id grp_id)
    197          {
   \                     mbedtls_ecdh_setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    198          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    199              return ecdh_setup_internal(ctx, grp_id);
    200          #else
    201              switch (grp_id) {
    202          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    203                  case MBEDTLS_ECP_DP_CURVE25519:
    204                      ctx->point_format = MBEDTLS_ECP_PF_COMPRESSED;
    205                      ctx->var = MBEDTLS_ECDH_VARIANT_EVEREST;
    206                      ctx->grp_id = grp_id;
    207                      return mbedtls_everest_setup(&ctx->ctx.everest_ecdh, grp_id);
    208          #endif
    209                  default:
    210                      ctx->point_format = MBEDTLS_ECP_PF_UNCOMPRESSED;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x7020             STRB     R0,[R4, #+0]
    211                      ctx->var = MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0;
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x70A1             STRB     R1,[R4, #+2]
    212                      ctx->grp_id = grp_id;
   \        0xE   0x7065             STRB     R5,[R4, #+1]
    213                      ecdh_init_internal(&ctx->ctx.mbed_ecdh);
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x.... 0x....      BL       mbedtls_ecp_group_init
   \       0x16   0xF104 0x0064      ADD      R0,R4,#+100
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x1E   0xF104 0x006C      ADD      R0,R4,#+108
   \       0x22   0x.... 0x....      BL       mbedtls_ecp_point_init
   \       0x26   0xF104 0x0084      ADD      R0,R4,#+132
   \       0x2A   0x.... 0x....      BL       mbedtls_ecp_point_init
   \       0x2E   0xF104 0x009C      ADD      R0,R4,#+156
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_init
    214                      return ecdh_setup_internal(&ctx->ctx.mbed_ecdh, grp_id);
   \       0x36   0x4629             MOV      R1,R5
   \       0x38   0x1D20             ADDS     R0,R4,#+4
   \       0x3A   0x.... 0x....      BL       mbedtls_ecp_group_load
   \       0x3E   0xB100             CBZ.N    R0,??mbedtls_ecdh_setup_0
   \       0x40   0x....             LDR.N    R0,??DataTable7
    215              }
   \                     ??mbedtls_ecdh_setup_0: (+1)
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    216          #endif
    217          }
    218          
    219          static void ecdh_free_internal(mbedtls_ecdh_context_mbed *ctx)
    220          {
    221              mbedtls_ecp_group_free(&ctx->grp);
    222              mbedtls_mpi_free(&ctx->d);
    223              mbedtls_ecp_point_free(&ctx->Q);
    224              mbedtls_ecp_point_free(&ctx->Qp);
    225              mbedtls_mpi_free(&ctx->z);
    226          
    227          #if defined(MBEDTLS_ECP_RESTARTABLE)
    228              mbedtls_ecp_restart_free(&ctx->rs);
    229          #endif
    230          }
    231          
    232          #if defined(MBEDTLS_ECP_RESTARTABLE)
    233          /*
    234           * Enable restartable operations for context
    235           */
    236          void mbedtls_ecdh_enable_restart(mbedtls_ecdh_context *ctx)
    237          {
    238              ctx->restart_enabled = 1;
    239          }
    240          #endif
    241          
    242          /*
    243           * Free context
    244           */

   \                                 In section .text, align 2, keep-with-next
    245          void mbedtls_ecdh_free(mbedtls_ecdh_context *ctx)
    246          {
   \                     mbedtls_ecdh_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    247              if (ctx == NULL) {
   \        0x4   0xD019             BEQ.N    ??mbedtls_ecdh_free_0
    248                  return;
    249              }
    250          
    251          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    252              mbedtls_ecp_point_free(&ctx->Vi);
    253              mbedtls_ecp_point_free(&ctx->Vf);
    254              mbedtls_mpi_free(&ctx->_d);
    255              ecdh_free_internal(ctx);
    256          #else
    257              switch (ctx->var) {
   \        0x6   0x78A1             LDRB     R1,[R4, #+2]
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0xD112             BNE.N    ??mbedtls_ecdh_free_1
    258          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    259                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    260                      mbedtls_everest_free(&ctx->ctx.everest_ecdh);
    261                      break;
    262          #endif
    263                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    264                      ecdh_free_internal(&ctx->ctx.mbed_ecdh);
   \        0xC   0x1D20             ADDS     R0,R4,#+4
   \        0xE   0x.... 0x....      BL       mbedtls_ecp_group_free
   \       0x12   0xF104 0x0064      ADD      R0,R4,#+100
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_free
   \       0x1A   0xF104 0x006C      ADD      R0,R4,#+108
   \       0x1E   0x.... 0x....      BL       mbedtls_ecp_point_free
   \       0x22   0xF104 0x0084      ADD      R0,R4,#+132
   \       0x26   0x.... 0x....      BL       mbedtls_ecp_point_free
   \       0x2A   0xF104 0x009C      ADD      R0,R4,#+156
   \       0x2E   0x.... 0x....      BL       mbedtls_mpi_free
    265                      break;
    266                  default:
    267                      break;
    268              }
    269          
    270              ctx->point_format = MBEDTLS_ECP_PF_UNCOMPRESSED;
   \                     ??mbedtls_ecdh_free_1: (+1)
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x7022             STRB     R2,[R4, #+0]
    271              ctx->var = MBEDTLS_ECDH_VARIANT_NONE;
   \       0x36   0x70A2             STRB     R2,[R4, #+2]
    272              ctx->grp_id = MBEDTLS_ECP_DP_NONE;
   \       0x38   0x7062             STRB     R2,[R4, #+1]
    273          #endif
    274          }
   \                     ??mbedtls_ecdh_free_0: (+1)
   \       0x3A   0xBD10             POP      {R4,PC}
    275          
    276          static int ecdh_make_params_internal(mbedtls_ecdh_context_mbed *ctx,
    277                                               size_t *olen, int point_format,
    278                                               unsigned char *buf, size_t blen,
    279                                               int (*f_rng)(void *,
    280                                                            unsigned char *,
    281                                                            size_t),
    282                                               void *p_rng,
    283                                               int restart_enabled)
    284          {
    285              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    286              size_t grp_len, pt_len;
    287          #if defined(MBEDTLS_ECP_RESTARTABLE)
    288              mbedtls_ecp_restart_ctx *rs_ctx = NULL;
    289          #endif
    290          
    291              if (ctx->grp.pbits == 0) {
    292                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    293              }
    294          
    295          #if defined(MBEDTLS_ECP_RESTARTABLE)
    296              if (restart_enabled) {
    297                  rs_ctx = &ctx->rs;
    298              }
    299          #else
    300              (void) restart_enabled;
    301          #endif
    302          
    303          
    304          #if defined(MBEDTLS_ECP_RESTARTABLE)
    305              if ((ret = ecdh_gen_public_restartable(&ctx->grp, &ctx->d, &ctx->Q,
    306                                                     f_rng, p_rng, rs_ctx)) != 0) {
    307                  return ret;
    308              }
    309          #else
    310              if ((ret = mbedtls_ecdh_gen_public(&ctx->grp, &ctx->d, &ctx->Q,
    311                                                 f_rng, p_rng)) != 0) {
    312                  return ret;
    313              }
    314          #endif /* MBEDTLS_ECP_RESTARTABLE */
    315          
    316              if ((ret = mbedtls_ecp_tls_write_group(&ctx->grp, &grp_len, buf,
    317                                                     blen)) != 0) {
    318                  return ret;
    319              }
    320          
    321              buf += grp_len;
    322              blen -= grp_len;
    323          
    324              if ((ret = mbedtls_ecp_tls_write_point(&ctx->grp, &ctx->Q, point_format,
    325                                                     &pt_len, buf, blen)) != 0) {
    326                  return ret;
    327              }
    328          
    329              *olen = grp_len + pt_len;
    330              return 0;
    331          }
    332          
    333          /*
    334           * Setup and write the ServerKeyExchange parameters (RFC 4492)
    335           *      struct {
    336           *          ECParameters    curve_params;
    337           *          ECPoint         public;
    338           *      } ServerECDHParams;
    339           */

   \                                 In section .text, align 2, keep-with-next
    340          int mbedtls_ecdh_make_params(mbedtls_ecdh_context *ctx, size_t *olen,
    341                                       unsigned char *buf, size_t blen,
    342                                       int (*f_rng)(void *, unsigned char *, size_t),
    343                                       void *p_rng)
    344          {
   \                     mbedtls_ecdh_make_params: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4604             MOV      R4,R0
    345              int restart_enabled = 0;
    346          #if defined(MBEDTLS_ECP_RESTARTABLE)
    347              restart_enabled = ctx->restart_enabled;
    348          #else
    349              (void) restart_enabled;
    350          #endif
    351          
    352          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    353              return ecdh_make_params_internal(ctx, olen, ctx->point_format, buf, blen,
    354                                               f_rng, p_rng, restart_enabled);
    355          #else
    356              switch (ctx->var) {
   \        0x8   0x78A1             LDRB     R1,[R4, #+2]
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0x....             LDR.N    R0,??DataTable7_1
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD121             BNE.N    ??mbedtls_ecdh_make_params_0
    357          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    358                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    359                      return mbedtls_everest_make_params(&ctx->ctx.everest_ecdh, olen,
    360                                                         buf, blen, f_rng, p_rng);
    361          #endif
    362                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    363                      return ecdh_make_params_internal(&ctx->ctx.mbed_ecdh, olen,
    364                                                       ctx->point_format, buf, blen,
    365                                                       f_rng, p_rng,
    366                                                       restart_enabled);
   \       0x14   0x6C21             LDR      R1,[R4, #+64]
   \       0x16   0x7827             LDRB     R7,[R4, #+0]
   \       0x18   0xB1F1             CBZ.N    R1,??mbedtls_ecdh_make_params_0
   \       0x1A   0x980B             LDR      R0,[SP, #+44]
   \       0x1C   0x9B0A             LDR      R3,[SP, #+40]
   \       0x1E   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x22   0xB9C8             CBNZ.N   R0,??mbedtls_ecdh_make_params_0
   \       0x24   0x4633             MOV      R3,R6
   \       0x26   0x4642             MOV      R2,R8
   \       0x28   0xA902             ADD      R1,SP,#+8
   \       0x2A   0x1D20             ADDS     R0,R4,#+4
   \       0x2C   0x.... 0x....      BL       mbedtls_ecp_tls_write_group
   \       0x30   0xB990             CBNZ.N   R0,??mbedtls_ecdh_make_params_0
   \       0x32   0x9802             LDR      R0,[SP, #+8]
   \       0x34   0xAB03             ADD      R3,SP,#+12
   \       0x36   0x463A             MOV      R2,R7
   \       0x38   0x1A36             SUBS     R6,R6,R0
   \       0x3A   0x9601             STR      R6,[SP, #+4]
   \       0x3C   0x9902             LDR      R1,[SP, #+8]
   \       0x3E   0x1D20             ADDS     R0,R4,#+4
   \       0x40   0x4441             ADD      R1,R8,R1
   \       0x42   0x9100             STR      R1,[SP, #+0]
   \       0x44   0xF104 0x016C      ADD      R1,R4,#+108
   \       0x48   0x.... 0x....      BL       mbedtls_ecp_tls_write_point
   \       0x4C   0xB920             CBNZ.N   R0,??mbedtls_ecdh_make_params_0
   \       0x4E   0x9902             LDR      R1,[SP, #+8]
   \       0x50   0x9803             LDR      R0,[SP, #+12]
   \       0x52   0x1841             ADDS     R1,R0,R1
   \       0x54   0x6029             STR      R1,[R5, #+0]
   \       0x56   0x2000             MOVS     R0,#+0
    367                  default:
    368                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdh_make_params_0: (+1)
   \       0x58   0xB004             ADD      SP,SP,#+16
   \       0x5A   0xE8BD 0x81F0      POP      {R4-R8,PC}
    369              }
    370          #endif
    371          }
    372          
    373          static int ecdh_read_params_internal(mbedtls_ecdh_context_mbed *ctx,
    374                                               const unsigned char **buf,
    375                                               const unsigned char *end)
    376          {
    377              return mbedtls_ecp_tls_read_point(&ctx->grp, &ctx->Qp, buf,
    378                                                end - *buf);
    379          }
    380          
    381          /*
    382           * Read the ServerKeyExchange parameters (RFC 4492)
    383           *      struct {
    384           *          ECParameters    curve_params;
    385           *          ECPoint         public;
    386           *      } ServerECDHParams;
    387           */

   \                                 In section .text, align 2, keep-with-next
    388          int mbedtls_ecdh_read_params(mbedtls_ecdh_context *ctx,
    389                                       const unsigned char **buf,
    390                                       const unsigned char *end)
    391          {
   \                     mbedtls_ecdh_read_params: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4616             MOV      R6,R2
    392              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    393              mbedtls_ecp_group_id grp_id;
    394              if ((ret = mbedtls_ecp_tls_read_group_id(&grp_id, buf, end - *buf))
    395                  != 0) {
   \        0x6   0x682A             LDR      R2,[R5, #+0]
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x1AB2             SUBS     R2,R6,R2
   \        0xE   0x.... 0x....      BL       mbedtls_ecp_tls_read_group_id
   \       0x12   0xB990             CBNZ.N   R0,??mbedtls_ecdh_read_params_0
    396                  return ret;
    397              }
    398          
    399              if ((ret = mbedtls_ecdh_setup(ctx, grp_id)) != 0) {
   \       0x14   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_ecdh_setup
   \       0x1E   0xB960             CBNZ.N   R0,??mbedtls_ecdh_read_params_0
    400                  return ret;
    401              }
    402          
    403          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    404              return ecdh_read_params_internal(ctx, buf, end);
    405          #else
    406              switch (ctx->var) {
   \       0x20   0x78A1             LDRB     R1,[R4, #+2]
   \       0x22   0x2901             CMP      R1,#+1
   \       0x24   0xD108             BNE.N    ??mbedtls_ecdh_read_params_1
    407          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    408                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    409                      return mbedtls_everest_read_params(&ctx->ctx.everest_ecdh,
    410                                                         buf, end);
    411          #endif
    412                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    413                      return ecdh_read_params_internal(&ctx->ctx.mbed_ecdh,
    414                                                       buf, end);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x462A             MOV      R2,R5
   \       0x2A   0xF104 0x0184      ADD      R1,R4,#+132
   \       0x2E   0x1A33             SUBS     R3,R6,R0
   \       0x30   0x1D20             ADDS     R0,R4,#+4
   \       0x32   0x.... 0x....      BL       mbedtls_ecp_tls_read_point
   \       0x36   0xBD76             POP      {R1,R2,R4-R6,PC}
    415                  default:
    416                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdh_read_params_1: (+1)
   \       0x38   0x....             LDR.N    R0,??DataTable7_1
   \                     ??mbedtls_ecdh_read_params_0: (+1)
   \       0x3A   0xBD76             POP      {R1,R2,R4-R6,PC}
    417              }
    418          #endif
    419          }
    420          
    421          static int ecdh_get_params_internal(mbedtls_ecdh_context_mbed *ctx,
    422                                              const mbedtls_ecp_keypair *key,
    423                                              mbedtls_ecdh_side side)
    424          {
    425              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    426          
    427              /* If it's not our key, just import the public part as Qp */
    428              if (side == MBEDTLS_ECDH_THEIRS) {
    429                  return mbedtls_ecp_copy(&ctx->Qp, &key->Q);
    430              }
    431          
    432              /* Our key: import public (as Q) and private parts */
    433              if (side != MBEDTLS_ECDH_OURS) {
    434                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    435              }
    436          
    437              if ((ret = mbedtls_ecp_copy(&ctx->Q, &key->Q)) != 0 ||
    438                  (ret = mbedtls_mpi_copy(&ctx->d, &key->d)) != 0) {
    439                  return ret;
    440              }
    441          
    442              return 0;
    443          }
    444          
    445          /*
    446           * Get parameters from a keypair
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          int mbedtls_ecdh_get_params(mbedtls_ecdh_context *ctx,
    449                                      const mbedtls_ecp_keypair *key,
    450                                      mbedtls_ecdh_side side)
    451          {
   \                     mbedtls_ecdh_get_params: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x460F             MOV      R7,R1
    452              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    453              if (side != MBEDTLS_ECDH_OURS && side != MBEDTLS_ECDH_THEIRS) {
   \        0x8   0x....             LDR.N    R4,??DataTable7_1
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E01             CMPNE    R6,#+1
   \       0x10   0xD128             BNE.N    ??mbedtls_ecdh_get_params_0
    454                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    455              }
    456          
    457              if (mbedtls_ecdh_grp_id(ctx) == MBEDTLS_ECP_DP_NONE) {
   \       0x12   0x7868             LDRB     R0,[R5, #+1]
   \       0x14   0x7839             LDRB     R1,[R7, #+0]
   \       0x16   0xB920             CBNZ.N   R0,??mbedtls_ecdh_get_params_1
    458                  /* This is the first call to get_params(). Set up the context
    459                   * for use with the group. */
    460                  if ((ret = mbedtls_ecdh_setup(ctx, key->grp.id)) != 0) {
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x.... 0x....      BL       mbedtls_ecdh_setup
   \       0x1E   0xB110             CBZ.N    R0,??mbedtls_ecdh_get_params_2
    461                      return ret;
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
    462                  }
    463              } else {
    464                  /* This is not the first call to get_params(). Check that the
    465                   * current key's group is the same as the context's, which was set
    466                   * from the first key's group. */
    467                  if (mbedtls_ecdh_grp_id(ctx) != key->grp.id) {
   \                     ??mbedtls_ecdh_get_params_1: (+1)
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD11E             BNE.N    ??mbedtls_ecdh_get_params_0
    468                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    469                  }
    470              }
    471          
    472          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    473              return ecdh_get_params_internal(ctx, key, side);
    474          #else
    475              switch (ctx->var) {
   \                     ??mbedtls_ecdh_get_params_2: (+1)
   \       0x26   0x78A8             LDRB     R0,[R5, #+2]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD11B             BNE.N    ??mbedtls_ecdh_get_params_0
    476          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    477                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    478                  {
    479                      mbedtls_everest_ecdh_side s = side == MBEDTLS_ECDH_OURS ?
    480                                                    MBEDTLS_EVEREST_ECDH_OURS :
    481                                                    MBEDTLS_EVEREST_ECDH_THEIRS;
    482                      return mbedtls_everest_get_params(&ctx->ctx.everest_ecdh,
    483                                                        key, s);
    484                  }
    485          #endif
    486                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    487                      return ecdh_get_params_internal(&ctx->ctx.mbed_ecdh,
    488                                                      key, side);
   \       0x2C   0x2E01             CMP      R6,#+1
   \       0x2E   0xD107             BNE.N    ??mbedtls_ecdh_get_params_3
   \       0x30   0xF107 0x0168      ADD      R1,R7,#+104
   \       0x34   0xF105 0x0084      ADD      R0,R5,#+132
   \       0x38   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x3C   0x4604             MOV      R4,R0
   \       0x3E   0xE011             B.N      ??mbedtls_ecdh_get_params_0
   \                     ??mbedtls_ecdh_get_params_3: (+1)
   \       0x40   0xB986             CBNZ.N   R6,??mbedtls_ecdh_get_params_0
   \       0x42   0xF107 0x0168      ADD      R1,R7,#+104
   \       0x46   0xF105 0x006C      ADD      R0,R5,#+108
   \       0x4A   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x4E   0x0004             MOVS     R4,R0
   \       0x50   0xD108             BNE.N    ??mbedtls_ecdh_get_params_0
   \       0x52   0xF107 0x0160      ADD      R1,R7,#+96
   \       0x56   0xF105 0x0064      ADD      R0,R5,#+100
   \       0x5A   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x5E   0x0004             MOVS     R4,R0
   \       0x60   0xBF08             IT       EQ
   \       0x62   0x2400             MOVEQ    R4,#+0
    489                  default:
    490                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdh_get_params_0: (+1)
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}
    491              }
    492          #endif
    493          }
    494          
    495          static int ecdh_make_public_internal(mbedtls_ecdh_context_mbed *ctx,
    496                                               size_t *olen, int point_format,
    497                                               unsigned char *buf, size_t blen,
    498                                               int (*f_rng)(void *,
    499                                                            unsigned char *,
    500                                                            size_t),
    501                                               void *p_rng,
    502                                               int restart_enabled)
    503          {
    504              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    505          #if defined(MBEDTLS_ECP_RESTARTABLE)
    506              mbedtls_ecp_restart_ctx *rs_ctx = NULL;
    507          #endif
    508          
    509              if (ctx->grp.pbits == 0) {
    510                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    511              }
    512          
    513          #if defined(MBEDTLS_ECP_RESTARTABLE)
    514              if (restart_enabled) {
    515                  rs_ctx = &ctx->rs;
    516              }
    517          #else
    518              (void) restart_enabled;
    519          #endif
    520          
    521          #if defined(MBEDTLS_ECP_RESTARTABLE)
    522              if ((ret = ecdh_gen_public_restartable(&ctx->grp, &ctx->d, &ctx->Q,
    523                                                     f_rng, p_rng, rs_ctx)) != 0) {
    524                  return ret;
    525              }
    526          #else
    527              if ((ret = mbedtls_ecdh_gen_public(&ctx->grp, &ctx->d, &ctx->Q,
    528                                                 f_rng, p_rng)) != 0) {
    529                  return ret;
    530              }
    531          #endif /* MBEDTLS_ECP_RESTARTABLE */
    532          
    533              return mbedtls_ecp_tls_write_point(&ctx->grp, &ctx->Q, point_format, olen,
    534                                                 buf, blen);
    535          }
    536          
    537          /*
    538           * Setup and export the client public value
    539           */

   \                                 In section .text, align 2, keep-with-next
    540          int mbedtls_ecdh_make_public(mbedtls_ecdh_context *ctx, size_t *olen,
    541                                       unsigned char *buf, size_t blen,
    542                                       int (*f_rng)(void *, unsigned char *, size_t),
    543                                       void *p_rng)
    544          {
   \                     mbedtls_ecdh_make_public: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4688             MOV      R8,R1
   \        0x6   0x4604             MOV      R4,R0
    545              int restart_enabled = 0;
    546          #if defined(MBEDTLS_ECP_RESTARTABLE)
    547              restart_enabled = ctx->restart_enabled;
    548          #endif
    549          
    550          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    551              return ecdh_make_public_internal(ctx, olen, ctx->point_format, buf, blen,
    552                                               f_rng, p_rng, restart_enabled);
    553          #else
    554              switch (ctx->var) {
   \        0x8   0x78A1             LDRB     R1,[R4, #+2]
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0x....             LDR.N    R0,??DataTable7_1
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD110             BNE.N    ??mbedtls_ecdh_make_public_0
    555          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    556                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    557                      return mbedtls_everest_make_public(&ctx->ctx.everest_ecdh, olen,
    558                                                         buf, blen, f_rng, p_rng);
    559          #endif
    560                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    561                      return ecdh_make_public_internal(&ctx->ctx.mbed_ecdh, olen,
    562                                                       ctx->point_format, buf, blen,
    563                                                       f_rng, p_rng,
    564                                                       restart_enabled);
   \       0x14   0x6C21             LDR      R1,[R4, #+64]
   \       0x16   0x7827             LDRB     R7,[R4, #+0]
   \       0x18   0xB169             CBZ.N    R1,??mbedtls_ecdh_make_public_0
   \       0x1A   0x9809             LDR      R0,[SP, #+36]
   \       0x1C   0x9B08             LDR      R3,[SP, #+32]
   \       0x1E   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x22   0xB940             CBNZ.N   R0,??mbedtls_ecdh_make_public_0
   \       0x24   0x9601             STR      R6,[SP, #+4]
   \       0x26   0x9500             STR      R5,[SP, #+0]
   \       0x28   0x4643             MOV      R3,R8
   \       0x2A   0x463A             MOV      R2,R7
   \       0x2C   0xF104 0x016C      ADD      R1,R4,#+108
   \       0x30   0x1D20             ADDS     R0,R4,#+4
   \       0x32   0x.... 0x....      BL       mbedtls_ecp_tls_write_point
    565                  default:
    566                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdh_make_public_0: (+1)
   \       0x36   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    567              }
    568          #endif
    569          }
    570          
    571          static int ecdh_read_public_internal(mbedtls_ecdh_context_mbed *ctx,
    572                                               const unsigned char *buf, size_t blen)
    573          {
    574              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    575              const unsigned char *p = buf;
    576          
    577              if ((ret = mbedtls_ecp_tls_read_point(&ctx->grp, &ctx->Qp, &p,
    578                                                    blen)) != 0) {
    579                  return ret;
    580              }
    581          
    582              if ((size_t) (p - buf) != blen) {
    583                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    584              }
    585          
    586              return 0;
    587          }
    588          
    589          /*
    590           * Parse and import the client's public value
    591           */

   \                                 In section .text, align 2, keep-with-next
    592          int mbedtls_ecdh_read_public(mbedtls_ecdh_context *ctx,
    593                                       const unsigned char *buf, size_t blen)
    594          {
   \                     mbedtls_ecdh_read_public: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
    595          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    596              return ecdh_read_public_internal(ctx, buf, blen);
    597          #else
    598              switch (ctx->var) {
   \        0x4   0x7881             LDRB     R1,[R0, #+2]
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x....             LDR.N    R6,??DataTable7_1
   \        0xA   0x2901             CMP      R1,#+1
   \        0xC   0xD10F             BNE.N    ??mbedtls_ecdh_read_public_0
    599          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    600                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    601                      return mbedtls_everest_read_public(&ctx->ctx.everest_ecdh,
    602                                                         buf, blen);
    603          #endif
    604                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    605                      return ecdh_read_public_internal(&ctx->ctx.mbed_ecdh,
    606                                                       buf, blen);
   \        0xE   0xF100 0x0184      ADD      R1,R0,#+132
   \       0x12   0x9400             STR      R4,[SP, #+0]
   \       0x14   0x462B             MOV      R3,R5
   \       0x16   0x466A             MOV      R2,SP
   \       0x18   0x1D00             ADDS     R0,R0,#+4
   \       0x1A   0x.... 0x....      BL       mbedtls_ecp_tls_read_point
   \       0x1E   0xB108             CBZ.N    R0,??mbedtls_ecdh_read_public_1
   \       0x20   0x4606             MOV      R6,R0
   \       0x22   0xE004             B.N      ??mbedtls_ecdh_read_public_0
   \                     ??mbedtls_ecdh_read_public_1: (+1)
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x1B04             SUBS     R4,R0,R4
   \       0x28   0x42AC             CMP      R4,R5
   \       0x2A   0xBF08             IT       EQ
   \       0x2C   0x2600             MOVEQ    R6,#+0
    607                  default:
    608                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdh_read_public_0: (+1)
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}
    609              }
    610          #endif
    611          }
    612          
    613          static int ecdh_calc_secret_internal(mbedtls_ecdh_context_mbed *ctx,
    614                                               size_t *olen, unsigned char *buf,
    615                                               size_t blen,
    616                                               int (*f_rng)(void *,
    617                                                            unsigned char *,
    618                                                            size_t),
    619                                               void *p_rng,
    620                                               int restart_enabled)
    621          {
    622              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    623          #if defined(MBEDTLS_ECP_RESTARTABLE)
    624              mbedtls_ecp_restart_ctx *rs_ctx = NULL;
    625          #endif
    626          
    627              if (ctx == NULL || ctx->grp.pbits == 0) {
    628                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    629              }
    630          
    631          #if defined(MBEDTLS_ECP_RESTARTABLE)
    632              if (restart_enabled) {
    633                  rs_ctx = &ctx->rs;
    634              }
    635          #else
    636              (void) restart_enabled;
    637          #endif
    638          
    639          #if defined(MBEDTLS_ECP_RESTARTABLE)
    640              if ((ret = ecdh_compute_shared_restartable(&ctx->grp, &ctx->z, &ctx->Qp,
    641                                                         &ctx->d, f_rng, p_rng,
    642                                                         rs_ctx)) != 0) {
    643                  return ret;
    644              }
    645          #else
    646              if ((ret = mbedtls_ecdh_compute_shared(&ctx->grp, &ctx->z, &ctx->Qp,
    647                                                     &ctx->d, f_rng, p_rng)) != 0) {
    648                  return ret;
    649              }
    650          #endif /* MBEDTLS_ECP_RESTARTABLE */
    651          
    652              if (mbedtls_mpi_size(&ctx->z) > blen) {
    653                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    654              }
    655          
    656              *olen = ctx->grp.pbits / 8 + ((ctx->grp.pbits % 8) != 0);
    657          
    658              if (mbedtls_ecp_get_type(&ctx->grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
    659                  return mbedtls_mpi_write_binary_le(&ctx->z, buf, *olen);
    660              }
    661          
    662              return mbedtls_mpi_write_binary(&ctx->z, buf, *olen);
    663          }
    664          
    665          /*
    666           * Derive and export the shared secret
    667           */

   \                                 In section .text, align 2, keep-with-next
    668          int mbedtls_ecdh_calc_secret(mbedtls_ecdh_context *ctx, size_t *olen,
    669                                       unsigned char *buf, size_t blen,
    670                                       int (*f_rng)(void *, unsigned char *, size_t),
    671                                       void *p_rng)
    672          {
   \                     mbedtls_ecdh_calc_secret: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460C             MOV      R4,R1
    673              int restart_enabled = 0;
    674          #if defined(MBEDTLS_ECP_RESTARTABLE)
    675              restart_enabled = ctx->restart_enabled;
    676          #endif
    677          
    678          #if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    679              return ecdh_calc_secret_internal(ctx, olen, buf, blen, f_rng, p_rng,
    680                                               restart_enabled);
    681          #else
    682              switch (ctx->var) {
   \        0x8   0x78B9             LDRB     R1,[R7, #+2]
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0x.... 0x....      LDR.W    R8,??DataTable7_1
   \       0x12   0x2901             CMP      R1,#+1
   \       0x14   0xD12E             BNE.N    ??mbedtls_ecdh_calc_secret_0
    683          #if defined(MBEDTLS_ECDH_VARIANT_EVEREST_ENABLED)
    684                  case MBEDTLS_ECDH_VARIANT_EVEREST:
    685                      return mbedtls_everest_calc_secret(&ctx->ctx.everest_ecdh, olen,
    686                                                         buf, blen, f_rng, p_rng);
    687          #endif
    688                  case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
    689                      return ecdh_calc_secret_internal(&ctx->ctx.mbed_ecdh, olen, buf,
    690                                                       blen, f_rng, p_rng,
    691                                                       restart_enabled);
   \       0x16   0x1D38             ADDS     R0,R7,#+4
   \       0x18   0xBF1C             ITT      NE
   \       0x1A   0x6C38             LDRNE    R0,[R7, #+64]
   \       0x1C   0x2800             CMPNE    R0,#+0
   \       0x1E   0xD029             BEQ.N    ??mbedtls_ecdh_calc_secret_0
   \       0x20   0x980B             LDR      R0,[SP, #+44]
   \       0x22   0xF107 0x099C      ADD      R9,R7,#+156
   \       0x26   0xF107 0x0364      ADD      R3,R7,#+100
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   \       0x2C   0x980A             LDR      R0,[SP, #+40]
   \       0x2E   0xF107 0x0284      ADD      R2,R7,#+132
   \       0x32   0x4649             MOV      R1,R9
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x1D38             ADDS     R0,R7,#+4
   \       0x38   0x.... 0x....      BL       mbedtls_ecdh_compute_shared
   \       0x3C   0xB9C8             CBNZ.N   R0,??mbedtls_ecdh_calc_secret_1
   \       0x3E   0x4648             MOV      R0,R9
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_size
   \       0x44   0x4286             CMP      R6,R0
   \       0x46   0xD315             BCC.N    ??mbedtls_ecdh_calc_secret_0
   \       0x48   0x6C38             LDR      R0,[R7, #+64]
   \       0x4A   0xF010 0x0107      ANDS     R1,R0,#0x7
   \       0x4E   0xBF18             IT       NE
   \       0x50   0x2101             MOVNE    R1,#+1
   \       0x52   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \       0x56   0x6020             STR      R0,[R4, #+0]
   \       0x58   0x1D38             ADDS     R0,R7,#+4
   \       0x5A   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x5E   0x2802             CMP      R0,#+2
   \       0x60   0x6822             LDR      R2,[R4, #+0]
   \       0x62   0x4629             MOV      R1,R5
   \       0x64   0x4648             MOV      R0,R9
   \       0x66   0xD102             BNE.N    ??mbedtls_ecdh_calc_secret_2
   \       0x68   0x.... 0x....      BL       mbedtls_mpi_write_binary_le
   \       0x6C   0xE001             B.N      ??mbedtls_ecdh_calc_secret_1
   \                     ??mbedtls_ecdh_calc_secret_2: (+1)
   \       0x6E   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \                     ??mbedtls_ecdh_calc_secret_1: (+1)
   \       0x72   0x4680             MOV      R8,R0
    692                  default:
    693                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecdh_calc_secret_0: (+1)
   \       0x74   0x4640             MOV      R0,R8
   \       0x76   0xE8BD 0x83FE      POP      {R1-R9,PC}
    694              }
    695          #endif
    696          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF104 0x026C      ADD      R2,R4,#+108
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0xF104 0x0164      ADD      R1,R4,#+100
   \        0xA   0x1D20             ADDS     R0,R4,#+4
   \        0xC   0x.... 0x....      B.W      mbedtls_ecdh_gen_public

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0xFFFF'B080        DC32     0xffffb080
    697          #endif /* MBEDTLS_ECDH_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   mbedtls_ecdh_calc_secret
        40   -> mbedtls_ecdh_compute_shared
        40   -> mbedtls_ecp_get_type
        40   -> mbedtls_mpi_size
        40   -> mbedtls_mpi_write_binary
        40   -> mbedtls_mpi_write_binary_le
       0   mbedtls_ecdh_can_do
       8   mbedtls_ecdh_free
         8   -> mbedtls_ecp_group_free
         8   -> mbedtls_ecp_point_free
         8   -> mbedtls_mpi_free
      24   mbedtls_ecdh_get_params
        24   -> mbedtls_ecdh_setup
        24   -> mbedtls_ecp_copy
        24   -> mbedtls_mpi_copy
       8   mbedtls_ecdh_init
         8   -> __aeabi_memclr4
      40   mbedtls_ecdh_make_params
        40   -> mbedtls_ecdh_gen_public
        40   -> mbedtls_ecp_tls_write_group
        40   -> mbedtls_ecp_tls_write_point
      32   mbedtls_ecdh_make_public
        32   -> mbedtls_ecdh_gen_public
        32   -> mbedtls_ecp_tls_write_point
      24   mbedtls_ecdh_read_params
        24   -> mbedtls_ecdh_setup
        24   -> mbedtls_ecp_tls_read_group_id
        24   -> mbedtls_ecp_tls_read_point
      24   mbedtls_ecdh_read_public
        24   -> mbedtls_ecp_tls_read_point
      16   mbedtls_ecdh_setup
        16   -> mbedtls_ecp_group_init
        16   -> mbedtls_ecp_group_load
        16   -> mbedtls_ecp_point_init
        16   -> mbedtls_mpi_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
      16  ?Subroutine0
     122  mbedtls_ecdh_calc_secret
       4  mbedtls_ecdh_can_do
      60  mbedtls_ecdh_free
     104  mbedtls_ecdh_get_params
      18  mbedtls_ecdh_init
      94  mbedtls_ecdh_make_params
      58  mbedtls_ecdh_make_public
      60  mbedtls_ecdh_read_params
      50  mbedtls_ecdh_read_public
      68  mbedtls_ecdh_setup

 
 662 bytes in section .text
 
 662 bytes of CODE memory

Errors: none
Warnings: none
