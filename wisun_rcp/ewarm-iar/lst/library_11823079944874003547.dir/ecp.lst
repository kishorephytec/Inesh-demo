###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:28
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecp.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecp.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecp.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecp.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ecp.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ecp.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ecp.c
      1          /*
      2           *  Elliptic curves over GF(p): generic functions
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * References:
     22           *
     23           * SEC1 https://www.secg.org/sec1-v2.pdf
     24           * GECC = Guide to Elliptic Curve Cryptography - Hankerson, Menezes, Vanstone
     25           * FIPS 186-3 http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
     26           * RFC 4492 for the related TLS structures and constants
     27           * - https://www.rfc-editor.org/rfc/rfc4492
     28           * RFC 7748 for the Curve448 and Curve25519 curve definitions
     29           * - https://www.rfc-editor.org/rfc/rfc7748
     30           *
     31           * [Curve25519] https://cr.yp.to/ecdh/curve25519-20060209.pdf
     32           *
     33           * [2] CORON, Jean-S'ebastien. Resistance against differential power analysis
     34           *     for elliptic curve cryptosystems. In : Cryptographic Hardware and
     35           *     Embedded Systems. Springer Berlin Heidelberg, 1999. p. 292-302.
     36           *     <http://link.springer.com/chapter/10.1007/3-540-48059-5_25>
     37           *
     38           * [3] HEDABOU, Mustapha, PINEL, Pierre, et B'EN'ETEAU, Lucien. A comb method to
     39           *     render ECC resistant against Side Channel Attacks. IACR Cryptology
     40           *     ePrint Archive, 2004, vol. 2004, p. 342.
     41           *     <http://eprint.iacr.org/2004/342.pdf>
     42           */
     43          
     44          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint16_t mbedtls_get_unaligned_uint16(void const *)
   \                     mbedtls_get_unaligned_uint16: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \        0x8   0x7841             LDRB     R1,[R0, #+1]
   \        0xA   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \        0xE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \        0x6   0x7002             STRB     R2,[R0, #+0]
   \        0x8   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \        0xC   0x7042             STRB     R2,[R0, #+1]
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     45          
     46          /**
     47           * \brief Function level alternative implementation.
     48           *
     49           * The MBEDTLS_ECP_INTERNAL_ALT macro enables alternative implementations to
     50           * replace certain functions in this module. The alternative implementations are
     51           * typically hardware accelerators and need to activate the hardware before the
     52           * computation starts and deactivate it after it finishes. The
     53           * mbedtls_internal_ecp_init() and mbedtls_internal_ecp_free() functions serve
     54           * this purpose.
     55           *
     56           * To preserve the correct functionality the following conditions must hold:
     57           *
     58           * - The alternative implementation must be activated by
     59           *   mbedtls_internal_ecp_init() before any of the replaceable functions is
     60           *   called.
     61           * - mbedtls_internal_ecp_free() must \b only be called when the alternative
     62           *   implementation is activated.
     63           * - mbedtls_internal_ecp_init() must \b not be called when the alternative
     64           *   implementation is activated.
     65           * - Public functions must not return while the alternative implementation is
     66           *   activated.
     67           * - Replaceable functions are guarded by \c MBEDTLS_ECP_XXX_ALT macros and
     68           *   before calling them an \code if( mbedtls_internal_ecp_grp_capable( grp ) )
     69           *   \endcode ensures that the alternative implementation supports the current
     70           *   group.
     71           */
     72          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
     73          #endif
     74          
     75          #if defined(MBEDTLS_ECP_LIGHT)
     76          
     77          #include "mbedtls/ecp.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int mbedtls_ecp_group_a_is_minus_3(mbedtls_ecp_group const *)
   \                     mbedtls_ecp_group_a_is_minus_3: (+1)
   \        0x0   0x68C0             LDR      R0,[R0, #+12]
   \        0x2   0xB908             CBNZ.N   R0,??mbedtls_ecp_group_a_is_minus_3_0
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x4770             BX       LR
   \                     ??mbedtls_ecp_group_a_is_minus_3_0: (+1)
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
     78          #include "mbedtls/threading.h"
     79          #include "mbedtls/platform_util.h"
     80          #include "mbedtls/error.h"
     81          
     82          #include "bn_mul.h"
     83          #include "ecp_invasive.h"
     84          
     85          #include <string.h>
     86          
     87          #if !defined(MBEDTLS_ECP_ALT)
     88          
     89          #include "mbedtls/platform.h"
     90          
     91          #include "ecp_internal_alt.h"
     92          
     93          #if defined(MBEDTLS_SELF_TEST)
     94          /*
     95           * Counts of point addition and doubling, and field multiplications.
     96           * Used to test resistance of point multiplication to simple timing attacks.
     97           */
     98          #if defined(MBEDTLS_ECP_C)
     99          static unsigned long add_count, dbl_count;
    100          #endif /* MBEDTLS_ECP_C */
    101          static unsigned long mul_count;
    102          #endif
    103          
    104          #if defined(MBEDTLS_ECP_RESTARTABLE)
    105          /*
    106           * Maximum number of "basic operations" to be done in a row.
    107           *
    108           * Default value 0 means that ECC operations will not yield.
    109           * Note that regardless of the value of ecp_max_ops, always at
    110           * least one step is performed before yielding.
    111           *
    112           * Setting ecp_max_ops=1 can be suitable for testing purposes
    113           * as it will interrupt computation at all possible points.
    114           */
    115          static unsigned ecp_max_ops = 0;
    116          
    117          /*
    118           * Set ecp_max_ops
    119           */
    120          void mbedtls_ecp_set_max_ops(unsigned max_ops)
    121          {
    122              ecp_max_ops = max_ops;
    123          }
    124          
    125          /*
    126           * Check if restart is enabled
    127           */
    128          int mbedtls_ecp_restart_is_enabled(void)
    129          {
    130              return ecp_max_ops != 0;
    131          }
    132          
    133          /*
    134           * Restart sub-context for ecp_mul_comb()
    135           */
    136          struct mbedtls_ecp_restart_mul {
    137              mbedtls_ecp_point R;    /* current intermediate result                  */
    138              size_t i;               /* current index in various loops, 0 outside    */
    139              mbedtls_ecp_point *T;   /* table for precomputed points                 */
    140              unsigned char T_size;   /* number of points in table T                  */
    141              enum {                  /* what were we doing last time we returned?    */
    142                  ecp_rsm_init = 0,       /* nothing so far, dummy initial state      */
    143                  ecp_rsm_pre_dbl,        /* precompute 2^n multiples                 */
    144                  ecp_rsm_pre_norm_dbl,   /* normalize precomputed 2^n multiples      */
    145                  ecp_rsm_pre_add,        /* precompute remaining points by adding    */
    146                  ecp_rsm_pre_norm_add,   /* normalize all precomputed points         */
    147                  ecp_rsm_comb_core,      /* ecp_mul_comb_core()                      */
    148                  ecp_rsm_final_norm,     /* do the final normalization               */
    149              } state;
    150          };
    151          
    152          /*
    153           * Init restart_mul sub-context
    154           */
    155          static void ecp_restart_rsm_init(mbedtls_ecp_restart_mul_ctx *ctx)
    156          {
    157              mbedtls_ecp_point_init(&ctx->R);
    158              ctx->i = 0;
    159              ctx->T = NULL;
    160              ctx->T_size = 0;
    161              ctx->state = ecp_rsm_init;
    162          }
    163          
    164          /*
    165           * Free the components of a restart_mul sub-context
    166           */
    167          static void ecp_restart_rsm_free(mbedtls_ecp_restart_mul_ctx *ctx)
    168          {
    169              unsigned char i;
    170          
    171              if (ctx == NULL) {
    172                  return;
    173              }
    174          
    175              mbedtls_ecp_point_free(&ctx->R);
    176          
    177              if (ctx->T != NULL) {
    178                  for (i = 0; i < ctx->T_size; i++) {
    179                      mbedtls_ecp_point_free(ctx->T + i);
    180                  }
    181                  mbedtls_free(ctx->T);
    182              }
    183          
    184              ecp_restart_rsm_init(ctx);
    185          }
    186          
    187          /*
    188           * Restart context for ecp_muladd()
    189           */
    190          struct mbedtls_ecp_restart_muladd {
    191              mbedtls_ecp_point mP;       /* mP value                             */
    192              mbedtls_ecp_point R;        /* R intermediate result                */
    193              enum {                      /* what should we do next?              */
    194                  ecp_rsma_mul1 = 0,      /* first multiplication                 */
    195                  ecp_rsma_mul2,          /* second multiplication                */
    196                  ecp_rsma_add,           /* addition                             */
    197                  ecp_rsma_norm,          /* normalization                        */
    198              } state;
    199          };
    200          
    201          /*
    202           * Init restart_muladd sub-context
    203           */
    204          static void ecp_restart_ma_init(mbedtls_ecp_restart_muladd_ctx *ctx)
    205          {
    206              mbedtls_ecp_point_init(&ctx->mP);
    207              mbedtls_ecp_point_init(&ctx->R);
    208              ctx->state = ecp_rsma_mul1;
    209          }
    210          
    211          /*
    212           * Free the components of a restart_muladd sub-context
    213           */
    214          static void ecp_restart_ma_free(mbedtls_ecp_restart_muladd_ctx *ctx)
    215          {
    216              if (ctx == NULL) {
    217                  return;
    218              }
    219          
    220              mbedtls_ecp_point_free(&ctx->mP);
    221              mbedtls_ecp_point_free(&ctx->R);
    222          
    223              ecp_restart_ma_init(ctx);
    224          }
    225          
    226          /*
    227           * Initialize a restart context
    228           */
    229          void mbedtls_ecp_restart_init(mbedtls_ecp_restart_ctx *ctx)
    230          {
    231              ctx->ops_done = 0;
    232              ctx->depth = 0;
    233              ctx->rsm = NULL;
    234              ctx->ma = NULL;
    235          }
    236          
    237          /*
    238           * Free the components of a restart context
    239           */
    240          void mbedtls_ecp_restart_free(mbedtls_ecp_restart_ctx *ctx)
    241          {
    242              if (ctx == NULL) {
    243                  return;
    244              }
    245          
    246              ecp_restart_rsm_free(ctx->rsm);
    247              mbedtls_free(ctx->rsm);
    248          
    249              ecp_restart_ma_free(ctx->ma);
    250              mbedtls_free(ctx->ma);
    251          
    252              mbedtls_ecp_restart_init(ctx);
    253          }
    254          
    255          /*
    256           * Check if we can do the next step
    257           */
    258          int mbedtls_ecp_check_budget(const mbedtls_ecp_group *grp,
    259                                       mbedtls_ecp_restart_ctx *rs_ctx,
    260                                       unsigned ops)
    261          {
    262              if (rs_ctx != NULL && ecp_max_ops != 0) {
    263                  /* scale depending on curve size: the chosen reference is 256-bit,
    264                   * and multiplication is quadratic. Round to the closest integer. */
    265                  if (grp->pbits >= 512) {
    266                      ops *= 4;
    267                  } else if (grp->pbits >= 384) {
    268                      ops *= 2;
    269                  }
    270          
    271                  /* Avoid infinite loops: always allow first step.
    272                   * Because of that, however, it's not generally true
    273                   * that ops_done <= ecp_max_ops, so the check
    274                   * ops_done > ecp_max_ops below is mandatory. */
    275                  if ((rs_ctx->ops_done != 0) &&
    276                      (rs_ctx->ops_done > ecp_max_ops ||
    277                       ops > ecp_max_ops - rs_ctx->ops_done)) {
    278                      return MBEDTLS_ERR_ECP_IN_PROGRESS;
    279                  }
    280          
    281                  /* update running count */
    282                  rs_ctx->ops_done += ops;
    283              }
    284          
    285              return 0;
    286          }
    287          
    288          /* Call this when entering a function that needs its own sub-context */
    289          #define ECP_RS_ENTER(SUB)   do {                                      \
    290                  /* reset ops count for this call if top-level */                    \
    291                  if (rs_ctx != NULL && rs_ctx->depth++ == 0)                        \
    292                  rs_ctx->ops_done = 0;                                           \
    293                                                                                  \
    294                  /* set up our own sub-context if needed */                          \
    295                  if (mbedtls_ecp_restart_is_enabled() &&                             \
    296                      rs_ctx != NULL && rs_ctx->SUB == NULL)                         \
    297                  {                                                                   \
    298                      rs_ctx->SUB = mbedtls_calloc(1, sizeof(*rs_ctx->SUB));      \
    299                      if (rs_ctx->SUB == NULL)                                       \
    300                      return MBEDTLS_ERR_ECP_ALLOC_FAILED;                     \
    301                                                                                \
    302                      ecp_restart_## SUB ##_init(rs_ctx->SUB);                      \
    303                  }                                                                   \
    304          } while (0)
    305          
    306          /* Call this when leaving a function that needs its own sub-context */
    307          #define ECP_RS_LEAVE(SUB)   do {                                      \
    308                  /* clear our sub-context when not in progress (done or error) */    \
    309                  if (rs_ctx != NULL && rs_ctx->SUB != NULL &&                        \
    310                      ret != MBEDTLS_ERR_ECP_IN_PROGRESS)                            \
    311                  {                                                                   \
    312                      ecp_restart_## SUB ##_free(rs_ctx->SUB);                      \
    313                      mbedtls_free(rs_ctx->SUB);                                    \
    314                      rs_ctx->SUB = NULL;                                             \
    315                  }                                                                   \
    316                                                                                  \
    317                  if (rs_ctx != NULL)                                                \
    318                  rs_ctx->depth--;                                                \
    319          } while (0)
    320          
    321          #else /* MBEDTLS_ECP_RESTARTABLE */
    322          
    323          #define ECP_RS_ENTER(sub)     (void) rs_ctx;
    324          #define ECP_RS_LEAVE(sub)     (void) rs_ctx;
    325          
    326          #endif /* MBEDTLS_ECP_RESTARTABLE */
    327          
    328          #if defined(MBEDTLS_ECP_C)

   \                                 In section .text, align 2, keep-with-next
    329          static void mpi_init_many(mbedtls_mpi *arr, size_t size)
    330          {
   \                     mpi_init_many: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xE003             B.N      ??mpi_init_many_0
    331              while (size--) {
    332                  mbedtls_mpi_init(arr++);
   \                     ??mpi_init_many_1: (+1)
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_init
   \        0xE   0x3508             ADDS     R5,R5,#+8
    333              }
   \                     ??mpi_init_many_0: (+1)
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x1E44             SUBS     R4,R0,#+1
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F7             BNE.N    ??mpi_init_many_1
    334          }
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}
    335          

   \                                 In section .text, align 2, keep-with-next
    336          static void mpi_free_many(mbedtls_mpi *arr, size_t size)
    337          {
   \                     mpi_free_many: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xE003             B.N      ??mpi_free_many_0
    338              while (size--) {
    339                  mbedtls_mpi_free(arr++);
   \                     ??mpi_free_many_1: (+1)
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_free
   \        0xE   0x3508             ADDS     R5,R5,#+8
    340              }
   \                     ??mpi_free_many_0: (+1)
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x1E44             SUBS     R4,R0,#+1
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F7             BNE.N    ??mpi_free_many_1
    341          }
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}
    342          #endif /* MBEDTLS_ECP_C */
    343          
    344          /*
    345           * List of supported curves:
    346           *  - internal ID
    347           *  - TLS NamedCurve ID (RFC 4492 sec. 5.1.1, RFC 7071 sec. 2, RFC 8446 sec. 4.2.7)
    348           *  - size in bits
    349           *  - readable name
    350           *
    351           * Curves are listed in order: largest curves first, and for a given size,
    352           * fastest curves first.
    353           *
    354           * Reminder: update profiles in x509_crt.c and ssl_tls.c when adding a new curve!
    355           */

   \                                 In section .text, align 4, keep-with-next
    356          static const mbedtls_ecp_curve_info ecp_supported_curves[] =
   \                     ecp_supported_curves:
   \        0x0   0x03               DC8 3
   \        0x1                      DS8 1
   \        0x2   0x0017 0x0100      DC16 23, 256
   \        0x6                      DS8 2
   \        0x8   0x....'....        DC32 ?_0
   \        0xC   0x00               DC8 0
   \        0xD                      DS8 1
   \        0xE   0x0000 0x0000      DC16 0, 0
   \       0x12                      DS8 2
   \       0x14   0x0000'0000        DC32 0x0
    357          {
    358          #if defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED)
    359              { MBEDTLS_ECP_DP_SECP521R1,    25,     521,    "secp521r1"         },
    360          #endif
    361          #if defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)
    362              { MBEDTLS_ECP_DP_BP512R1,      28,     512,    "brainpoolP512r1"   },
    363          #endif
    364          #if defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)
    365              { MBEDTLS_ECP_DP_SECP384R1,    24,     384,    "secp384r1"         },
    366          #endif
    367          #if defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)
    368              { MBEDTLS_ECP_DP_BP384R1,      27,     384,    "brainpoolP384r1"   },
    369          #endif
    370          #if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
    371              { MBEDTLS_ECP_DP_SECP256R1,    23,     256,    "secp256r1"         },
    372          #endif
    373          #if defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
    374              { MBEDTLS_ECP_DP_SECP256K1,    22,     256,    "secp256k1"         },
    375          #endif
    376          #if defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)
    377              { MBEDTLS_ECP_DP_BP256R1,      26,     256,    "brainpoolP256r1"   },
    378          #endif
    379          #if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)
    380              { MBEDTLS_ECP_DP_SECP224R1,    21,     224,    "secp224r1"         },
    381          #endif
    382          #if defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED)
    383              { MBEDTLS_ECP_DP_SECP224K1,    20,     224,    "secp224k1"         },
    384          #endif
    385          #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
    386              { MBEDTLS_ECP_DP_SECP192R1,    19,     192,    "secp192r1"         },
    387          #endif
    388          #if defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED)
    389              { MBEDTLS_ECP_DP_SECP192K1,    18,     192,    "secp192k1"         },
    390          #endif
    391          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
    392              { MBEDTLS_ECP_DP_CURVE25519,   29,     256,    "x25519"            },
    393          #endif
    394          #if defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
    395              { MBEDTLS_ECP_DP_CURVE448,     30,     448,    "x448"              },
    396          #endif
    397              { MBEDTLS_ECP_DP_NONE,          0,     0,      NULL                },
    398          };
    399          
    400          #define ECP_NB_CURVES   sizeof(ecp_supported_curves) /    \
    401              sizeof(ecp_supported_curves[0])
    402          
    403          static mbedtls_ecp_group_id ecp_supported_grp_id[ECP_NB_CURVES];
    404          
    405          /*
    406           * List of supported curves and associated info
    407           */

   \                                 In section .text, align 4, keep-with-next
    408          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_list(void)
    409          {
    410              return ecp_supported_curves;
   \                     mbedtls_ecp_curve_list: (+1)
   \        0x0   0x....             ADR.N    R0,ecp_supported_curves
   \        0x2   0x4770             BX       LR
    411          }
    412          
    413          /*
    414           * List of supported curves, group ID only
    415           */

   \                                 In section .text, align 4, keep-with-next
    416          const mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list(void)
    417          {
   \                     mbedtls_ecp_grp_id_list: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable14
   \        0x4   0x6841             LDR      R1,[R0, #+4]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD000             BEQ.N    ??mbedtls_ecp_grp_id_list_0
   \        0xA   0x4770             BX       LR
   \                     ??mbedtls_ecp_grp_id_list_0: (+1)
   \        0xC   0xB510             PUSH     {R4,LR}
    418              static int init_done = 0;
    419          
    420              if (!init_done) {
    421                  size_t i = 0;
   \        0xE   0x2200             MOVS     R2,#+0
    422                  const mbedtls_ecp_curve_info *curve_info;
    423          
    424                  for (curve_info = mbedtls_ecp_curve_list();
   \       0x10   0x....             ADR.N    R3,ecp_supported_curves
   \       0x12   0xE003             B.N      ??mbedtls_ecp_grp_id_list_1
    425                       curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
    426                       curve_info++) {
    427                      ecp_supported_grp_id[i++] = curve_info->grp_id;
   \                     ??mbedtls_ecp_grp_id_list_2: (+1)
   \       0x14   0xF813 0x4B0C      LDRB     R4,[R3], #+12
   \       0x18   0x5484             STRB     R4,[R0, R2]
   \       0x1A   0x1C52             ADDS     R2,R2,#+1
    428                  }
   \                     ??mbedtls_ecp_grp_id_list_1: (+1)
   \       0x1C   0x7819             LDRB     R1,[R3, #+0]
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD1F8             BNE.N    ??mbedtls_ecp_grp_id_list_2
    429                  ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x5483             STRB     R3,[R0, R2]
    430          
    431                  init_done = 1;
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x6041             STR      R1,[R0, #+4]
    432              }
    433          
    434              return ecp_supported_grp_id;
   \       0x2A   0xBD10             POP      {R4,PC}
    435          }

   \                                 In section .bss, align 4
   \                     ecp_supported_grp_id:
   \        0x0                      DS8 2
   \        0x2                      DS8 2
   \        0x4                      DS8 4
    436          
    437          /*
    438           * Get the curve info for the internal identifier
    439           */

   \                                 In section .text, align 4, keep-with-next
    440          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id(mbedtls_ecp_group_id grp_id)
    441          {
   \                     mbedtls_ecp_curve_info_from_grp_id: (+1)
   \        0x0   0x4603             MOV      R3,R0
    442              const mbedtls_ecp_curve_info *curve_info;
    443          
    444              for (curve_info = mbedtls_ecp_curve_list();
   \        0x2   0xBF00             Nop
   \        0x4   0x....             ADR.N    R0,ecp_supported_curves
   \        0x6   0xE000             B.N      ??mbedtls_ecp_curve_info_from_grp_id_0
    445                   curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
    446                   curve_info++) {
   \                     ??mbedtls_ecp_curve_info_from_grp_id_1: (+1)
   \        0x8   0x300C             ADDS     R0,R0,#+12
   \                     ??mbedtls_ecp_curve_info_from_grp_id_0: (+1)
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xB111             CBZ.N    R1,??mbedtls_ecp_curve_info_from_grp_id_2
    447                  if (curve_info->grp_id == grp_id) {
   \        0xE   0x4299             CMP      R1,R3
   \       0x10   0xD1FA             BNE.N    ??mbedtls_ecp_curve_info_from_grp_id_1
    448                      return curve_info;
   \       0x12   0x4770             BX       LR
    449                  }
    450              }
    451          
    452              return NULL;
   \                     ??mbedtls_ecp_curve_info_from_grp_id_2: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x4770             BX       LR
    453          }
    454          
    455          /*
    456           * Get the curve info from the TLS identifier
    457           */

   \                                 In section .text, align 4, keep-with-next
    458          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id(uint16_t tls_id)
    459          {
   \                     mbedtls_ecp_curve_info_from_tls_id: (+1)
   \        0x0   0x4602             MOV      R2,R0
    460              const mbedtls_ecp_curve_info *curve_info;
    461          
    462              for (curve_info = mbedtls_ecp_curve_list();
   \        0x2   0xBF00             Nop
   \        0x4   0x....             ADR.N    R0,ecp_supported_curves
   \        0x6   0xE000             B.N      ??mbedtls_ecp_curve_info_from_tls_id_0
    463                   curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
    464                   curve_info++) {
   \                     ??mbedtls_ecp_curve_info_from_tls_id_1: (+1)
   \        0x8   0x300C             ADDS     R0,R0,#+12
   \                     ??mbedtls_ecp_curve_info_from_tls_id_0: (+1)
   \        0xA   0x7801             LDRB     R1,[R0, #+0]
   \        0xC   0xB119             CBZ.N    R1,??mbedtls_ecp_curve_info_from_tls_id_2
    465                  if (curve_info->tls_id == tls_id) {
   \        0xE   0x8843             LDRH     R3,[R0, #+2]
   \       0x10   0x4293             CMP      R3,R2
   \       0x12   0xD1F9             BNE.N    ??mbedtls_ecp_curve_info_from_tls_id_1
    466                      return curve_info;
   \       0x14   0x4770             BX       LR
    467                  }
    468              }
    469          
    470              return NULL;
   \                     ??mbedtls_ecp_curve_info_from_tls_id_2: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR
    471          }
    472          
    473          /*
    474           * Get the curve info from the name
    475           */

   \                                 In section .text, align 4, keep-with-next
    476          const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name(const char *name)
    477          {
   \                     mbedtls_ecp_curve_info_from_name: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    478              const mbedtls_ecp_curve_info *curve_info;
    479          
    480              if (name == NULL) {
   \        0x4   0xD00D             BEQ.N    ??mbedtls_ecp_curve_info_from_name_0
    481                  return NULL;
    482              }
    483          
    484              for (curve_info = mbedtls_ecp_curve_list();
   \        0x6   0xBF00             Nop
   \        0x8   0x....             ADR.N    R5,ecp_supported_curves
   \        0xA   0xE000             B.N      ??mbedtls_ecp_curve_info_from_name_1
    485                   curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
    486                   curve_info++) {
   \                     ??mbedtls_ecp_curve_info_from_name_2: (+1)
   \        0xC   0x350C             ADDS     R5,R5,#+12
   \                     ??mbedtls_ecp_curve_info_from_name_1: (+1)
   \        0xE   0x7828             LDRB     R0,[R5, #+0]
   \       0x10   0xB138             CBZ.N    R0,??mbedtls_ecp_curve_info_from_name_0
    487                  if (strcmp(curve_info->name, name) == 0) {
   \       0x12   0x68A8             LDR      R0,[R5, #+8]
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x.... 0x....      BL       strcmp
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD1F6             BNE.N    ??mbedtls_ecp_curve_info_from_name_2
    488                      return curve_info;
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
    489                  }
    490              }
    491          
    492              return NULL;
   \                     ??mbedtls_ecp_curve_info_from_name_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    493          }
    494          
    495          /*
    496           * Get the type of a curve
    497           */

   \                                 In section .text, align 2, keep-with-next
    498          mbedtls_ecp_curve_type mbedtls_ecp_get_type(const mbedtls_ecp_group *grp)
    499          {
    500              if (grp->G.X.p == NULL) {
   \                     mbedtls_ecp_get_type: (+1)
   \        0x0   0x69C1             LDR      R1,[R0, #+28]
   \        0x2   0xB909             CBNZ.N   R1,??mbedtls_ecp_get_type_0
    501                  return MBEDTLS_ECP_TYPE_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
    502              }
    503          
    504              if (grp->G.Y.p == NULL) {
   \                     ??mbedtls_ecp_get_type_0: (+1)
   \        0x8   0x6A40             LDR      R0,[R0, #+36]
   \        0xA   0xB908             CBNZ.N   R0,??mbedtls_ecp_get_type_1
    505                  return MBEDTLS_ECP_TYPE_MONTGOMERY;
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0x4770             BX       LR
    506              } else {
    507                  return MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS;
   \                     ??mbedtls_ecp_get_type_1: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x4770             BX       LR
    508              }
    509          }
    510          
    511          /*
    512           * Initialize (the components of) a point
    513           */

   \                                 In section .text, align 2, keep-with-next
    514          void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)
    515          {
   \                     mbedtls_ecp_point_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    516              mbedtls_mpi_init(&pt->X);
   \        0x4   0x.... 0x....      BL       mbedtls_mpi_init
    517              mbedtls_mpi_init(&pt->Y);
   \        0x8   0xF104 0x0008      ADD      R0,R4,#+8
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_init
    518              mbedtls_mpi_init(&pt->Z);
   \       0x10   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x.... 0x....      B.W      mbedtls_mpi_init
    519          }
    520          
    521          /*
    522           * Initialize (the components of) a group
    523           */

   \                                 In section .text, align 2, keep-with-next
    524          void mbedtls_ecp_group_init(mbedtls_ecp_group *grp)
    525          {
   \                     mbedtls_ecp_group_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    526              grp->id = MBEDTLS_ECP_DP_NONE;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7021             STRB     R1,[R4, #+0]
    527              mbedtls_mpi_init(&grp->P);
   \        0x8   0x1D20             ADDS     R0,R4,#+4
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_init
    528              mbedtls_mpi_init(&grp->A);
   \        0xE   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_init
    529              mbedtls_mpi_init(&grp->B);
   \       0x16   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_init
    530              mbedtls_ecp_point_init(&grp->G);
   \       0x1E   0xF104 0x001C      ADD      R0,R4,#+28
   \       0x22   0x.... 0x....      BL       mbedtls_ecp_point_init
    531              mbedtls_mpi_init(&grp->N);
   \       0x26   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x2A   0x.... 0x....      BL       mbedtls_mpi_init
    532              grp->pbits = 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x63E0             STR      R0,[R4, #+60]
    533              grp->nbits = 0;
   \       0x32   0x6420             STR      R0,[R4, #+64]
    534              grp->h = 0;
   \       0x34   0x6460             STR      R0,[R4, #+68]
    535              grp->modp = NULL;
   \       0x36   0x64A0             STR      R0,[R4, #+72]
    536              grp->t_pre = NULL;
   \       0x38   0x64E0             STR      R0,[R4, #+76]
    537              grp->t_post = NULL;
   \       0x3A   0x6520             STR      R0,[R4, #+80]
    538              grp->t_data = NULL;
   \       0x3C   0x6560             STR      R0,[R4, #+84]
    539              grp->T = NULL;
   \       0x3E   0x65A0             STR      R0,[R4, #+88]
    540              grp->T_size = 0;
   \       0x40   0x65E0             STR      R0,[R4, #+92]
    541          }
   \       0x42   0xBD10             POP      {R4,PC}
    542          
    543          /*
    544           * Initialize (the components of) a key pair
    545           */

   \                                 In section .text, align 2, keep-with-next
    546          void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *key)
    547          {
   \                     mbedtls_ecp_keypair_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    548              mbedtls_ecp_group_init(&key->grp);
   \        0x4   0x.... 0x....      BL       mbedtls_ecp_group_init
    549              mbedtls_mpi_init(&key->d);
   \        0x8   0xF104 0x0060      ADD      R0,R4,#+96
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_init
    550              mbedtls_ecp_point_init(&key->Q);
   \       0x10   0xF104 0x0068      ADD      R0,R4,#+104
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x....             B.N      mbedtls_ecp_point_init
    551          }
    552          
    553          /*
    554           * Unallocate (the components of) a point
    555           */

   \                                 In section .text, align 2, keep-with-next
    556          void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)
    557          {
   \                     mbedtls_ecp_point_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    558              if (pt == NULL) {
   \        0x4   0xD00B             BEQ.N    ??mbedtls_ecp_point_free_0
    559                  return;
    560              }
    561          
    562              mbedtls_mpi_free(&(pt->X));
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_free
    563              mbedtls_mpi_free(&(pt->Y));
   \        0xA   0xF104 0x0008      ADD      R0,R4,#+8
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_free
    564              mbedtls_mpi_free(&(pt->Z));
   \       0x12   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x.... 0x....      B.W      mbedtls_mpi_free
   \                     ??mbedtls_ecp_point_free_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}
    565          }
    566          
    567          /*
    568           * Check that the comb table (grp->T) is static initialized.
    569           */
    570          static int ecp_group_is_static_comb_table(const mbedtls_ecp_group *grp)
    571          {
    572          #if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
    573              return grp->T != NULL && grp->T_size == 0;
    574          #else
    575              (void) grp;
    576              return 0;
    577          #endif
    578          }
    579          
    580          /*
    581           * Unallocate (the components of) a group
    582           */

   \                                 In section .text, align 2, keep-with-next
    583          void mbedtls_ecp_group_free(mbedtls_ecp_group *grp)
    584          {
   \                     mbedtls_ecp_group_free: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    585              size_t i;
    586          
    587              if (grp == NULL) {
   \        0x4   0xD02B             BEQ.N    ??mbedtls_ecp_group_free_0
    588                  return;
    589              }
    590          
    591              if (grp->h != 1) {
   \        0x6   0x6C61             LDR      R1,[R4, #+68]
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0xD012             BEQ.N    ??mbedtls_ecp_group_free_1
    592                  mbedtls_mpi_free(&grp->A);
   \        0xC   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x10   0x.... 0x....      BL       mbedtls_mpi_free
    593                  mbedtls_mpi_free(&grp->B);
   \       0x14   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x18   0x.... 0x....      BL       mbedtls_mpi_free
    594                  mbedtls_ecp_point_free(&grp->G);
   \       0x1C   0xF104 0x001C      ADD      R0,R4,#+28
   \       0x20   0x.... 0x....      BL       mbedtls_ecp_point_free
    595          
    596          #if !defined(MBEDTLS_ECP_WITH_MPI_UINT)
    597                  mbedtls_mpi_free(&grp->N);
   \       0x24   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x28   0x.... 0x....      BL       mbedtls_mpi_free
    598                  mbedtls_mpi_free(&grp->P);
   \       0x2C   0x1D20             ADDS     R0,R4,#+4
   \       0x2E   0x.... 0x....      BL       mbedtls_mpi_free
    599          #endif
    600              }
    601          
    602              if (!ecp_group_is_static_comb_table(grp) && grp->T != NULL) {
   \                     ??mbedtls_ecp_group_free_1: (+1)
   \       0x32   0x6DA0             LDR      R0,[R4, #+88]
   \       0x34   0xB168             CBZ.N    R0,??mbedtls_ecp_group_free_2
    603                  for (i = 0; i < grp->T_size; i++) {
   \       0x36   0x2500             MOVS     R5,#+0
   \       0x38   0xE005             B.N      ??mbedtls_ecp_group_free_3
    604                      mbedtls_ecp_point_free(&grp->T[i]);
   \                     ??mbedtls_ecp_group_free_4: (+1)
   \       0x3A   0x2118             MOVS     R1,#+24
   \       0x3C   0x4369             MULS     R1,R1,R5
   \       0x3E   0x4408             ADD      R0,R0,R1
   \       0x40   0x.... 0x....      BL       mbedtls_ecp_point_free
    605                  }
   \       0x44   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mbedtls_ecp_group_free_3: (+1)
   \       0x46   0x6DE1             LDR      R1,[R4, #+92]
   \       0x48   0x6DA0             LDR      R0,[R4, #+88]
   \       0x4A   0x428D             CMP      R5,R1
   \       0x4C   0xD3F5             BCC.N    ??mbedtls_ecp_group_free_4
    606                  mbedtls_free(grp->T);
   \       0x4E   0x.... 0x....      BL       sl_free
    607              }
    608          
    609              mbedtls_platform_zeroize(grp, sizeof(mbedtls_ecp_group));
   \                     ??mbedtls_ecp_group_free_2: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x2160             MOVS     R1,#+96
   \       0x56   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x5A   0x.... 0x....      B.W      mbedtls_platform_zeroize
   \                     ??mbedtls_ecp_group_free_0: (+1)
   \       0x5E   0xBD31             POP      {R0,R4,R5,PC}
    610          }
    611          
    612          /*
    613           * Unallocate (the components of) a key pair
    614           */

   \                                 In section .text, align 2, keep-with-next
    615          void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *key)
    616          {
   \                     mbedtls_ecp_keypair_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    617              if (key == NULL) {
   \        0x4   0xD00A             BEQ.N    ??mbedtls_ecp_keypair_free_0
    618                  return;
    619              }
    620          
    621              mbedtls_ecp_group_free(&key->grp);
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_group_free
    622              mbedtls_mpi_free(&key->d);
   \        0xA   0xF104 0x0060      ADD      R0,R4,#+96
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_free
    623              mbedtls_ecp_point_free(&key->Q);
   \       0x12   0xF104 0x0068      ADD      R0,R4,#+104
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x....             B.N      mbedtls_ecp_point_free
   \                     ??mbedtls_ecp_keypair_free_0: (+1)
   \       0x1C   0xBD10             POP      {R4,PC}
    624          }
    625          
    626          /*
    627           * Copy the contents of a point
    628           */

   \                                 In section .text, align 2, keep-with-next
    629          int mbedtls_ecp_copy(mbedtls_ecp_point *P, const mbedtls_ecp_point *Q)
    630          {
   \                     mbedtls_ecp_copy: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    631              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    632              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->X, &Q->X));
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_copy
   \        0xA   0xB970             CBNZ.N   R0,??mbedtls_ecp_copy_0
    633              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Y, &Q->Y));
   \        0xC   0xF104 0x0108      ADD      R1,R4,#+8
   \       0x10   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x18   0xB938             CBNZ.N   R0,??mbedtls_ecp_copy_0
    634              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&P->Z, &Q->Z));
   \       0x1A   0xF104 0x0110      ADD      R1,R4,#+16
   \       0x1E   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x22   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x26   0x.... 0x....      B.W      mbedtls_mpi_copy
    635          
    636          cleanup:
    637              return ret;
   \                     ??mbedtls_ecp_copy_0: (+1)
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
    638          }
    639          
    640          /*
    641           * Copy the contents of a group object
    642           */

   \                                 In section .text, align 2, keep-with-next
    643          int mbedtls_ecp_group_copy(mbedtls_ecp_group *dst, const mbedtls_ecp_group *src)
    644          {
    645              return mbedtls_ecp_group_load(dst, src->id);
   \                     mbedtls_ecp_group_copy: (+1)
   \        0x0   0x7809             LDRB     R1,[R1, #+0]
   \        0x2   0x.... 0x....      B.W      mbedtls_ecp_group_load
    646          }
    647          
    648          /*
    649           * Set point to zero
    650           */

   \                                 In section .text, align 2, keep-with-next
    651          int mbedtls_ecp_set_zero(mbedtls_ecp_point *pt)
    652          {
   \                     mbedtls_ecp_set_zero: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    653              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    654              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->X, 1));
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_lset
   \        0xA   0xB960             CBNZ.N   R0,??mbedtls_ecp_set_zero_0
    655              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Y, 1));
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x12   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x16   0xB930             CBNZ.N   R0,??mbedtls_ecp_set_zero_0
    656              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 0));
   \       0x18   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x.... 0x....      B.W      mbedtls_mpi_lset
    657          
    658          cleanup:
    659              return ret;
   \                     ??mbedtls_ecp_set_zero_0: (+1)
   \       0x26   0xBD10             POP      {R4,PC}
    660          }
    661          
    662          /*
    663           * Tell if a point is zero
    664           */

   \                                 In section .text, align 2, keep-with-next
    665          int mbedtls_ecp_is_zero(mbedtls_ecp_point *pt)
    666          {
   \                     mbedtls_ecp_is_zero: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    667              return mbedtls_mpi_cmp_int(&pt->Z, 0) == 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x3010             ADDS     R0,R0,#+16
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \        0xA   0x1E40             SUBS     R0,R0,#+1
   \        0xC   0x4180             SBCS     R0,R0,R0
   \        0xE   0x0FC0             LSRS     R0,R0,#+31
   \       0x10   0xBD02             POP      {R1,PC}
    668          }
    669          
    670          /*
    671           * Compare two points lazily
    672           */

   \                                 In section .text, align 2, keep-with-next
    673          int mbedtls_ecp_point_cmp(const mbedtls_ecp_point *P,
    674                                    const mbedtls_ecp_point *Q)
    675          {
   \                     mbedtls_ecp_point_cmp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    676              if (mbedtls_mpi_cmp_mpi(&P->X, &Q->X) == 0 &&
    677                  mbedtls_mpi_cmp_mpi(&P->Y, &Q->Y) == 0 &&
    678                  mbedtls_mpi_cmp_mpi(&P->Z, &Q->Z) == 0) {
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \        0xA   0xB968             CBNZ.N   R0,??mbedtls_ecp_point_cmp_0
   \        0xC   0xF104 0x0108      ADD      R1,R4,#+8
   \       0x10   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x18   0xB930             CBNZ.N   R0,??mbedtls_ecp_point_cmp_0
   \       0x1A   0xF104 0x0110      ADD      R1,R4,#+16
   \       0x1E   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x22   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x26   0xB108             CBZ.N    R0,??mbedtls_ecp_point_cmp_1
    679                  return 0;
    680              }
    681          
    682              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_point_cmp_0: (+1)
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \                     ??mbedtls_ecp_point_cmp_1: (+1)
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    683          }
    684          
    685          /*
    686           * Import a non-zero point from ASCII strings
    687           */

   \                                 In section .text, align 2, keep-with-next
    688          int mbedtls_ecp_point_read_string(mbedtls_ecp_point *P, int radix,
    689                                            const char *x, const char *y)
    690          {
   \                     mbedtls_ecp_point_read_string: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x461D             MOV      R5,R3
    691              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    692              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&P->X, radix, x));
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_read_string
   \        0xC   0xB968             CBNZ.N   R0,??mbedtls_ecp_point_read_string_0
    693              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(&P->Y, radix, y));
   \        0xE   0x462A             MOV      R2,R5
   \       0x10   0x4621             MOV      R1,R4
   \       0x12   0xF106 0x0008      ADD      R0,R6,#+8
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_read_string
   \       0x1A   0xB930             CBNZ.N   R0,??mbedtls_ecp_point_read_string_0
    694              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&P->Z, 1));
   \       0x1C   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x26   0x.... 0x....      B.W      mbedtls_mpi_lset
    695          
    696          cleanup:
    697              return ret;
   \                     ??mbedtls_ecp_point_read_string_0: (+1)
   \       0x2A   0xBD70             POP      {R4-R6,PC}
    698          }
    699          
    700          /*
    701           * Export a point into unsigned binary data (SEC1 2.3.3 and RFC7748)
    702           */

   \                                 In section .text, align 2, keep-with-next
    703          int mbedtls_ecp_point_write_binary(const mbedtls_ecp_group *grp,
    704                                             const mbedtls_ecp_point *P,
    705                                             int format, size_t *olen,
    706                                             unsigned char *buf, size_t buflen)
    707          {
   \                     mbedtls_ecp_point_write_binary: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x469A             MOV      R10,R3
    708              int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \        0xC   0x.... 0x....      LDR.W    R9,??DataTable14_2
    709              size_t plen;
    710              if (format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
    711                  format != MBEDTLS_ECP_PF_COMPRESSED) {
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2C01             CMPNE    R4,#+1
   \       0x14   0x.... 0x....      LDRNE.W  R0,??DataTable14_1
    712                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x18   0xD146             BNE.N    ??mbedtls_ecp_point_write_binary_0
    713              }
    714          
    715              plen = mbedtls_mpi_size(&grp->P);
   \       0x1A   0x1D28             ADDS     R0,R5,#+4
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_size
   \       0x20   0x4607             MOV      R7,R0
    716          
    717          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    718              (void) format; /* Montgomery curves always use the same point format */
    719              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
    720                  *olen = plen;
    721                  if (buflen < *olen) {
    722                      return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
    723                  }
    724          
    725                  MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&P->X, buf, plen));
    726              }
    727          #endif
    728          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    729              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD13C             BNE.N    ??mbedtls_ecp_point_write_binary_1
    730                  /*
    731                   * Common case: P == 0
    732                   */
    733                  if (mbedtls_mpi_cmp_int(&P->Z, 0) == 0) {
   \       0x2C   0x9E0A             LDR      R6,[SP, #+40]
   \       0x2E   0x9D0B             LDR      R5,[SP, #+44]
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0xF108 0x0010      ADD      R0,R8,#+16
   \       0x36   0x.... 0x....      LDR.W    R11,??DataTable14_3
   \       0x3A   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x3E   0xB928             CBNZ.N   R0,??mbedtls_ecp_point_write_binary_2
    734                      if (buflen < 1) {
   \       0x40   0xB315             CBZ.N    R5,??mbedtls_ecp_point_write_binary_3
    735                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
    736                      }
    737          
    738                      buf[0] = 0x00;
   \       0x42   0x7030             STRB     R0,[R6, #+0]
    739                      *olen = 1;
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0xF8CA 0x1000      STR      R1,[R10, #+0]
    740          
    741                      return 0;
   \       0x4A   0xE02D             B.N      ??mbedtls_ecp_point_write_binary_0
    742                  }
    743          
    744                  if (format == MBEDTLS_ECP_PF_UNCOMPRESSED) {
   \                     ??mbedtls_ecp_point_write_binary_2: (+1)
   \       0x4C   0xB9AC             CBNZ.N   R4,??mbedtls_ecp_point_write_binary_4
    745                      *olen = 2 * plen + 1;
   \       0x4E   0x0078             LSLS     R0,R7,#+1
   \       0x50   0x1C40             ADDS     R0,R0,#+1
   \       0x52   0xF8CA 0x0000      STR      R0,[R10, #+0]
    746          
    747                      if (buflen < *olen) {
   \       0x56   0x4285             CMP      R5,R0
   \       0x58   0xD316             BCC.N    ??mbedtls_ecp_point_write_binary_3
    748                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
    749                      }
    750          
    751                      buf[0] = 0x04;
   \       0x5A   0x2004             MOVS     R0,#+4
   \       0x5C   0x7030             STRB     R0,[R6, #+0]
    752                      MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   \       0x5E   0x463A             MOV      R2,R7
   \       0x60   0x1C71             ADDS     R1,R6,#+1
   \       0x62   0x4640             MOV      R0,R8
   \       0x64   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x68   0xEA5F 0x0900      MOVS     R9,R0
   \       0x6C   0xD11B             BNE.N    ??mbedtls_ecp_point_write_binary_1
    753                      MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->Y, buf + 1 + plen, plen));
   \       0x6E   0x1C70             ADDS     R0,R6,#+1
   \       0x70   0x19C1             ADDS     R1,R0,R7
   \       0x72   0x463A             MOV      R2,R7
   \       0x74   0xF108 0x0008      ADD      R0,R8,#+8
   \       0x78   0xE012             B.N      ??mbedtls_ecp_point_write_binary_5
    754                  } else if (format == MBEDTLS_ECP_PF_COMPRESSED) {
   \                     ??mbedtls_ecp_point_write_binary_4: (+1)
   \       0x7A   0x2C01             CMP      R4,#+1
   \       0x7C   0xD113             BNE.N    ??mbedtls_ecp_point_write_binary_1
    755                      *olen = plen + 1;
   \       0x7E   0x1C78             ADDS     R0,R7,#+1
   \       0x80   0xF8CA 0x0000      STR      R0,[R10, #+0]
    756          
    757                      if (buflen < *olen) {
   \       0x84   0x4285             CMP      R5,R0
   \       0x86   0xD201             BCS.N    ??mbedtls_ecp_point_write_binary_6
    758                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \                     ??mbedtls_ecp_point_write_binary_3: (+1)
   \       0x88   0x4658             MOV      R0,R11
   \       0x8A   0xE00D             B.N      ??mbedtls_ecp_point_write_binary_0
    759                      }
    760          
    761                      buf[0] = 0x02 + mbedtls_mpi_get_bit(&P->Y, 0);
   \                     ??mbedtls_ecp_point_write_binary_6: (+1)
   \       0x8C   0x2100             MOVS     R1,#+0
   \       0x8E   0xF108 0x0008      ADD      R0,R8,#+8
   \       0x92   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \       0x96   0x1C80             ADDS     R0,R0,#+2
   \       0x98   0x7030             STRB     R0,[R6, #+0]
    762                      MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&P->X, buf + 1, plen));
   \       0x9A   0x463A             MOV      R2,R7
   \       0x9C   0x1C71             ADDS     R1,R6,#+1
   \       0x9E   0x4640             MOV      R0,R8
   \                     ??mbedtls_ecp_point_write_binary_5: (+1)
   \       0xA0   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0xA4   0x4681             MOV      R9,R0
    763                  }
    764              }
    765          #endif
    766          
    767          cleanup:
    768              return ret;
   \                     ??mbedtls_ecp_point_write_binary_1: (+1)
   \       0xA6   0x4648             MOV      R0,R9
   \                     ??mbedtls_ecp_point_write_binary_0: (+1)
   \       0xA8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    769          }
    770          
    771          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED) \
    772              && defined(MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING)
    773          static int mbedtls_ecp_sw_derive_y(const mbedtls_ecp_group *grp,
    774                                             const mbedtls_mpi *X,
    775                                             mbedtls_mpi *Y,
    776                                             int parity_bit);
    777          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
    778          
    779          /*
    780           * Import a point from unsigned binary data (SEC1 2.3.4 and RFC7748)
    781           */

   \                                 In section .text, align 2, keep-with-next
    782          int mbedtls_ecp_point_read_binary(const mbedtls_ecp_group *grp,
    783                                            mbedtls_ecp_point *pt,
    784                                            const unsigned char *buf, size_t ilen)
    785          {
   \                     mbedtls_ecp_point_read_binary: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x001D             MOVS     R5,R3
    786              int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \        0xC   0x.... 0x....      LDR.W    R9,??DataTable14_2
    787              size_t plen;
    788              if (ilen < 1) {
   \       0x10   0x.... 0x....      LDR.W    R8,??DataTable14_1
   \       0x14   0xD033             BEQ.N    ??mbedtls_ecp_point_read_binary_0
    789                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    790              }
    791          
    792              plen = mbedtls_mpi_size(&grp->P);
   \       0x16   0x1D30             ADDS     R0,R6,#+4
   \       0x18   0x.... 0x....      BL       mbedtls_mpi_size
   \       0x1C   0x4604             MOV      R4,R0
    793          
    794          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    795              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
    796                  if (plen != ilen) {
    797                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    798                  }
    799          
    800                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary_le(&pt->X, buf, plen));
    801                  mbedtls_mpi_free(&pt->Y);
    802          
    803                  if (grp->id == MBEDTLS_ECP_DP_CURVE25519) {
    804                      /* Set most significant bit to 0 as prescribed in RFC7748 §5 */
    805                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&pt->X, plen * 8 - 1, 0));
    806                  }
    807          
    808                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
    809              }
    810          #endif
    811          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    812              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD12C             BNE.N    ??mbedtls_ecp_point_read_binary_1
    813                  if (buf[0] == 0x00) {
   \       0x28   0x7838             LDRB     R0,[R7, #+0]
   \       0x2A   0xB928             CBNZ.N   R0,??mbedtls_ecp_point_read_binary_2
    814                      if (ilen == 1) {
   \       0x2C   0x2D01             CMP      R5,#+1
   \       0x2E   0xD126             BNE.N    ??mbedtls_ecp_point_read_binary_0
    815                          return mbedtls_ecp_set_zero(pt);
   \       0x30   0x4650             MOV      R0,R10
   \       0x32   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0x36   0x....             B.N      mbedtls_ecp_set_zero
    816                      } else {
    817                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    818                      }
    819                  }
    820          
    821                  if (ilen < 1 + plen) {
   \                     ??mbedtls_ecp_point_read_binary_2: (+1)
   \       0x38   0x1C60             ADDS     R0,R4,#+1
   \       0x3A   0x4285             CMP      R5,R0
   \       0x3C   0xD31F             BCC.N    ??mbedtls_ecp_point_read_binary_0
    822                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    823                  }
    824          
    825                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&pt->X, buf + 1, plen));
   \       0x3E   0x4622             MOV      R2,R4
   \       0x40   0x1C79             ADDS     R1,R7,#+1
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       mbedtls_mpi_read_binary
   \       0x48   0xEA5F 0x0900      MOVS     R9,R0
   \       0x4C   0xD119             BNE.N    ??mbedtls_ecp_point_read_binary_1
    826                  MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&pt->Z, 1));
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0xF10A 0x0010      ADD      R0,R10,#+16
   \       0x54   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x58   0xEA5F 0x0900      MOVS     R9,R0
   \       0x5C   0xD111             BNE.N    ??mbedtls_ecp_point_read_binary_1
    827          
    828                  if (buf[0] == 0x04) {
   \       0x5E   0x7838             LDRB     R0,[R7, #+0]
   \       0x60   0x2804             CMP      R0,#+4
   \       0x62   0xBF04             ITT      EQ
   \       0x64   0x1E6D             SUBEQ    R5,R5,#+1
   \       0x66   0xEBB5 0x0F44      CMPEQ    R5,R4, LSL #+1
    829                      /* format == MBEDTLS_ECP_PF_UNCOMPRESSED */
    830                      if (ilen != 1 + plen * 2) {
   \       0x6A   0xD108             BNE.N    ??mbedtls_ecp_point_read_binary_0
    831                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    832                      }
    833                      return mbedtls_mpi_read_binary(&pt->Y, buf + 1 + plen, plen);
   \       0x6C   0x1C78             ADDS     R0,R7,#+1
   \       0x6E   0x1901             ADDS     R1,R0,R4
   \       0x70   0x4622             MOV      R2,R4
   \       0x72   0xF10A 0x0008      ADD      R0,R10,#+8
   \       0x76   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0x7A   0x.... 0x....      B.W      mbedtls_mpi_read_binary
    834          #if defined(MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING)
    835                  } else if (buf[0] == 0x02 || buf[0] == 0x03) {
    836                      /* format == MBEDTLS_ECP_PF_COMPRESSED */
    837                      if (ilen != 1 + plen) {
    838                          return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    839                      }
    840                      return mbedtls_ecp_sw_derive_y(grp, &pt->X, &pt->Y,
    841                                                     (buf[0] & 1));
    842          #endif
    843                  } else {
    844                      return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_point_read_binary_0: (+1)
   \       0x7E   0x4640             MOV      R0,R8
   \       0x80   0xE000             B.N      ??mbedtls_ecp_point_read_binary_3
    845                  }
    846              }
    847          #endif
    848          
    849          cleanup:
    850              return ret;
   \                     ??mbedtls_ecp_point_read_binary_1: (+1)
   \       0x82   0x4648             MOV      R0,R9
   \                     ??mbedtls_ecp_point_read_binary_3: (+1)
   \       0x84   0xE8BD 0x87F0      POP      {R4-R10,PC}
    851          }
    852          
    853          /*
    854           * Import a point from a TLS ECPoint record (RFC 4492)
    855           *      struct {
    856           *          opaque point <1..2^8-1>;
    857           *      } ECPoint;
    858           */

   \                                 In section .text, align 2, keep-with-next
    859          int mbedtls_ecp_tls_read_point(const mbedtls_ecp_group *grp,
    860                                         mbedtls_ecp_point *pt,
    861                                         const unsigned char **buf, size_t buf_len)
    862          {
   \                     mbedtls_ecp_tls_read_point: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x461C             MOV      R4,R3
    863              unsigned char data_len;
    864              const unsigned char *buf_start;
    865              /*
    866               * We must have at least two bytes (1 for length, at least one for data)
    867               */
    868              if (buf_len < 2) {
   \        0x4   0x2C02             CMP      R4,#+2
   \        0x6   0xD307             BCC.N    ??mbedtls_ecp_tls_read_point_0
    869                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    870              }
    871          
    872              data_len = *(*buf)++;
   \        0x8   0x6815             LDR      R5,[R2, #+0]
   \        0xA   0x1C6B             ADDS     R3,R5,#+1
   \        0xC   0x6013             STR      R3,[R2, #+0]
   \        0xE   0x782B             LDRB     R3,[R5, #+0]
    873              if (data_len < 1 || data_len > buf_len - 1) {
   \       0x10   0xB113             CBZ.N    R3,??mbedtls_ecp_tls_read_point_0
   \       0x12   0x1E64             SUBS     R4,R4,#+1
   \       0x14   0x429C             CMP      R4,R3
   \       0x16   0xD201             BCS.N    ??mbedtls_ecp_tls_read_point_1
    874                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_tls_read_point_0: (+1)
   \       0x18   0x.... 0x....      B.W      ?Subroutine0
    875              }
    876          
    877              /*
    878               * Save buffer start for read_binary and update buf
    879               */
    880              buf_start = *buf;
   \                     ??mbedtls_ecp_tls_read_point_1: (+1)
   \       0x1C   0x6814             LDR      R4,[R2, #+0]
    881              *buf += data_len;
   \       0x1E   0x18E5             ADDS     R5,R4,R3
   \       0x20   0x6015             STR      R5,[R2, #+0]
    882          
    883              return mbedtls_ecp_point_read_binary(grp, pt, buf_start, data_len);
   \       0x22   0x4622             MOV      R2,R4
   \       0x24   0xB001             ADD      SP,SP,#+4
   \       0x26   0xE8BD 0x4030      POP      {R4,R5,LR}
   \       0x2A   0x....             B.N      mbedtls_ecp_point_read_binary
    884          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22_1
   \        0x2   0xBD32             POP      {R1,R4,R5,PC}
    885          
    886          /*
    887           * Export a point as a TLS ECPoint record (RFC 4492)
    888           *      struct {
    889           *          opaque point <1..2^8-1>;
    890           *      } ECPoint;
    891           */

   \                                 In section .text, align 2, keep-with-next
    892          int mbedtls_ecp_tls_write_point(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt,
    893                                          int format, size_t *olen,
    894                                          unsigned char *buf, size_t blen)
    895          {
   \                     mbedtls_ecp_tls_write_point: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x461D             MOV      R5,R3
    896              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    897              if (format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
    898                  format != MBEDTLS_ECP_PF_COMPRESSED) {
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2A01             CMPNE    R2,#+1
   \        0xA   0xD101             BNE.N    ??mbedtls_ecp_tls_write_point_0
   \        0xC   0x9B07             LDR      R3,[SP, #+28]
    899                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    900              }
    901          
    902              /*
    903               * buffer length must be at least one, for our length byte
    904               */
    905              if (blen < 1) {
   \        0xE   0xB913             CBNZ.N   R3,??mbedtls_ecp_tls_write_point_1
    906                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_tls_write_point_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x14   0xBD3E             POP      {R1-R5,PC}
    907              }
   \                     ??mbedtls_ecp_tls_write_point_1: (+1)
   \       0x16   0x9C06             LDR      R4,[SP, #+24]
    908          
    909              if ((ret = mbedtls_ecp_point_write_binary(grp, pt, format,
    910                                                        olen, buf + 1, blen - 1)) != 0) {
   \       0x18   0x1E5B             SUBS     R3,R3,#+1
   \       0x1A   0x9301             STR      R3,[SP, #+4]
   \       0x1C   0x1C63             ADDS     R3,R4,#+1
   \       0x1E   0x9300             STR      R3,[SP, #+0]
   \       0x20   0x462B             MOV      R3,R5
   \       0x22   0x.... 0x....      BL       mbedtls_ecp_point_write_binary
   \       0x26   0xB928             CBNZ.N   R0,??mbedtls_ecp_tls_write_point_2
    911                  return ret;
    912              }
    913          
    914              /*
    915               * write length to the first byte and update total length
    916               */
    917              buf[0] = (unsigned char) *olen;
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0x7020             STRB     R0,[R4, #+0]
    918              ++*olen;
   \       0x2C   0x6829             LDR      R1,[R5, #+0]
    919          
    920              return 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x1C49             ADDS     R1,R1,#+1
   \       0x32   0x6029             STR      R1,[R5, #+0]
   \                     ??mbedtls_ecp_tls_write_point_2: (+1)
   \       0x34   0xBD3E             POP      {R1-R5,PC}
    921          }
    922          
    923          /*
    924           * Set a group from an ECParameters record (RFC 4492)
    925           */

   \                                 In section .text, align 2, keep-with-next
    926          int mbedtls_ecp_tls_read_group(mbedtls_ecp_group *grp,
    927                                         const unsigned char **buf, size_t len)
    928          {
   \                     mbedtls_ecp_tls_read_group: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    929              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    930              mbedtls_ecp_group_id grp_id;
    931              if ((ret = mbedtls_ecp_tls_read_group_id(&grp_id, buf, len)) != 0) {
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_tls_read_group_id
   \        0xA   0xB920             CBNZ.N   R0,??mbedtls_ecp_tls_read_group_0
    932                  return ret;
    933              }
    934          
    935              return mbedtls_ecp_group_load(grp, grp_id);
   \        0xC   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       mbedtls_ecp_group_load
   \                     ??mbedtls_ecp_tls_read_group_0: (+1)
   \       0x16   0xBD16             POP      {R1,R2,R4,PC}
    936          }
    937          
    938          /*
    939           * Read a group id from an ECParameters record (RFC 4492) and convert it to
    940           * mbedtls_ecp_group_id.
    941           */

   \                                 In section .text, align 4, keep-with-next
    942          int mbedtls_ecp_tls_read_group_id(mbedtls_ecp_group_id *grp,
    943                                            const unsigned char **buf, size_t len)
    944          {
   \                     mbedtls_ecp_tls_read_group_id: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    945              uint16_t tls_id;
    946              const mbedtls_ecp_curve_info *curve_info;
    947              /*
    948               * We expect at least three bytes (see below)
    949               */
    950              if (len < 3) {
   \        0x6   0x2A03             CMP      R2,#+3
   \        0x8   0xD305             BCC.N    ??mbedtls_ecp_tls_read_group_id_0
    951                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    952              }
    953          
    954              /*
    955               * First byte is curve_type; only named_curve is handled
    956               */
    957              if (*(*buf)++ != MBEDTLS_ECP_TLS_NAMED_CURVE) {
   \        0xA   0x6829             LDR      R1,[R5, #+0]
   \        0xC   0x1C48             ADDS     R0,R1,#+1
   \        0xE   0x6028             STR      R0,[R5, #+0]
   \       0x10   0x7809             LDRB     R1,[R1, #+0]
   \       0x12   0x2903             CMP      R1,#+3
   \       0x14   0xD001             BEQ.N    ??mbedtls_ecp_tls_read_group_id_1
    958                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_tls_read_group_id_0: (+1)
   \       0x16   0x.... 0x....      B.W      ?Subroutine0
    959              }
    960          
    961              /*
    962               * Next two bytes are the namedcurve value
    963               */
    964              tls_id = MBEDTLS_GET_UINT16_BE(*buf, 0);
   \                     ??mbedtls_ecp_tls_read_group_id_1: (+1)
   \       0x1A   0xBF00             Nop
   \       0x1C   0x....             ADR.N    R2,mbedtls_byte_order_detector
   \       0x1E   0x7811             LDRB     R1,[R2, #+0]
   \       0x20   0x2901             CMP      R1,#+1
   \       0x22   0xD102             BNE.N    ??mbedtls_ecp_tls_read_group_id_2
   \       0x24   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x28   0xE005             B.N      ??mbedtls_ecp_tls_read_group_id_3
   \                     ??mbedtls_ecp_tls_read_group_id_2: (+1)
   \       0x2A   0x.... 0x....      BL       mbedtls_get_unaligned_uint16
   \       0x2E   0x4601             MOV      R1,R0
   \       0x30   0x0A00             LSRS     R0,R0,#+8
   \       0x32   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    965              *buf += 2;
   \                     ??mbedtls_ecp_tls_read_group_id_3: (+1)
   \       0x36   0x682A             LDR      R2,[R5, #+0]
    966          
    967              if ((curve_info = mbedtls_ecp_curve_info_from_tls_id(tls_id)) == NULL) {
   \       0x38   0xB280             UXTH     R0,R0
   \       0x3A   0x1C91             ADDS     R1,R2,#+2
   \       0x3C   0x6029             STR      R1,[R5, #+0]
   \       0x3E   0x.... 0x....      BL       mbedtls_ecp_curve_info_from_tls_id
   \       0x42   0xB910             CBNZ.N   R0,??mbedtls_ecp_tls_read_group_id_4
    968                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}
    969              }
    970          
    971              *grp = curve_info->grp_id;
   \                     ??mbedtls_ecp_tls_read_group_id_4: (+1)
   \       0x4A   0x7800             LDRB     R0,[R0, #+0]
   \       0x4C   0x7020             STRB     R0,[R4, #+0]
    972          
    973              return 0;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
    974          }
    975          
    976          /*
    977           * Write the ECParameters record corresponding to a group (RFC 4492)
    978           */

   \                                 In section .text, align 4, keep-with-next
    979          int mbedtls_ecp_tls_write_group(const mbedtls_ecp_group *grp, size_t *olen,
    980                                          unsigned char *buf, size_t blen)
    981          {
   \                     mbedtls_ecp_tls_write_group: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    982              const mbedtls_ecp_curve_info *curve_info;
    983              if ((curve_info = mbedtls_ecp_curve_info_from_grp_id(grp->id)) == NULL) {
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461E             MOV      R6,R3
   \        0xA   0x.... 0x....      BL       mbedtls_ecp_curve_info_from_grp_id
   \        0xE   0xB910             CBNZ.N   R0,??mbedtls_ecp_tls_write_group_0
    984                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x14   0xBD70             POP      {R4-R6,PC}
    985              }
    986          
    987              /*
    988               * We are going to write 3 bytes (see below)
    989               */
    990              *olen = 3;
   \                     ??mbedtls_ecp_tls_write_group_0: (+1)
   \       0x16   0x2103             MOVS     R1,#+3
   \       0x18   0x6029             STR      R1,[R5, #+0]
    991              if (blen < *olen) {
   \       0x1A   0x2E03             CMP      R6,#+3
   \       0x1C   0xD202             BCS.N    ??mbedtls_ecp_tls_write_group_1
    992                  return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \       0x22   0xBD70             POP      {R4-R6,PC}
    993              }
    994          
    995              /*
    996               * First byte is curve_type, always named_curve
    997               */
    998              *buf++ = MBEDTLS_ECP_TLS_NAMED_CURVE;
    999          
   1000              /*
   1001               * Next two bytes are the namedcurve value
   1002               */
   1003              MBEDTLS_PUT_UINT16_BE(curve_info->tls_id, buf, 0);
   \                     ??mbedtls_ecp_tls_write_group_1: (+1)
   \       0x24   0x....             ADR.N    R2,mbedtls_byte_order_detector
   \       0x26   0xF804 0x1B01      STRB     R1,[R4], #+1
   \       0x2A   0x7811             LDRB     R1,[R2, #+0]
   \       0x2C   0x8840             LDRH     R0,[R0, #+2]
   \       0x2E   0x2901             CMP      R1,#+1
   \       0x30   0xBF0F             ITEEE    EQ
   \       0x32   0x4601             MOVEQ    R1,R0
   \       0x34   0x0A01             LSRNE    R1,R0,#+8
   \       0x36   0xEA41 0x2100      ORRNE    R1,R1,R0, LSL #+8
   \       0x3A   0xB289             UXTHNE   R1,R1
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   1004          
   1005              return 0;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD70             POP      {R4-R6,PC}
   1006          }
   1007          
   1008          /*
   1009           * Wrapper around fast quasi-modp functions, with fall-back to mbedtls_mpi_mod_mpi.
   1010           * See the documentation of struct mbedtls_ecp_group.
   1011           *
   1012           * This function is in the critial loop for mbedtls_ecp_mul, so pay attention to perf.
   1013           */
   1014          static int ecp_modp(mbedtls_mpi *N, const mbedtls_ecp_group *grp)
   1015          {
   1016              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1017          
   1018              if (grp->modp == NULL) {
   1019                  return mbedtls_mpi_mod_mpi(N, N, &grp->P);
   1020              }
   1021          
   1022              /* N->s < 0 is a much faster test, which fails only if N is 0 */
   1023              if ((N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) ||
   1024                  mbedtls_mpi_bitlen(N) > 2 * grp->pbits) {
   1025                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   1026              }
   1027          
   1028              MBEDTLS_MPI_CHK(grp->modp(N));
   1029          
   1030              /* N->s < 0 is a much faster test, which fails only if N is 0 */
   1031              while (N->s < 0 && mbedtls_mpi_cmp_int(N, 0) != 0) {
   1032                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(N, N, &grp->P));
   1033              }
   1034          
   1035              while (mbedtls_mpi_cmp_mpi(N, &grp->P) >= 0) {
   1036                  /* we known P, N and the result are positive */
   1037                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs(N, N, &grp->P));
   1038              }
   1039          
   1040          cleanup:
   1041              return ret;
   1042          }
   1043          
   1044          /*
   1045           * Fast mod-p functions expect their argument to be in the 0..p^2 range.
   1046           *
   1047           * In order to guarantee that, we need to ensure that operands of
   1048           * mbedtls_mpi_mul_mpi are in the 0..p range. So, after each operation we will
   1049           * bring the result back to this range.
   1050           *
   1051           * The following macros are shortcuts for doing that.
   1052           */
   1053          
   1054          /*
   1055           * Reduce a mbedtls_mpi mod p in-place, general case, to use after mbedtls_mpi_mul_mpi
   1056           */
   1057          #if defined(MBEDTLS_SELF_TEST)
   1058          #define INC_MUL_COUNT   mul_count++;
   1059          #else
   1060          #define INC_MUL_COUNT
   1061          #endif
   1062          
   1063          #define MOD_MUL(N)                                                    \
   1064              do                                                                  \
   1065              {                                                                   \
   1066                  MBEDTLS_MPI_CHK(ecp_modp(&(N), grp));                       \
   1067                  INC_MUL_COUNT                                                   \
   1068              } while (0)
   1069          

   \                                 In section .text, align 2, keep-with-next
   1070          static inline int mbedtls_mpi_mul_mod(const mbedtls_ecp_group *grp,
   1071                                                mbedtls_mpi *X,
   1072                                                const mbedtls_mpi *A,
   1073                                                const mbedtls_mpi *B)
   1074          {
   \                     mbedtls_mpi_mul_mod: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1075              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1076              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(X, A, B));
   \                     ??CrossCallReturnLabel_16: (+1)
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_mul_mpi
   \        0xA   0x0004             MOVS     R4,R0
   \        0xC   0xD12C             BNE.N    ??mbedtls_mpi_mul_mod_0
   1077              MOD_MUL(*X);
   \        0xE   0x6CB0             LDR      R0,[R6, #+72]
   \       0x10   0xB930             CBNZ.N   R0,??mbedtls_mpi_mul_mod_1
   \       0x12   0x1D32             ADDS     R2,R6,#+4
   \       0x14   0x4629             MOV      R1,R5
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       mbedtls_mpi_mod_mpi
   \       0x1C   0x4604             MOV      R4,R0
   \       0x1E   0xE023             B.N      ??mbedtls_mpi_mul_mod_0
   \                     ??mbedtls_mpi_mul_mod_1: (+1)
   \       0x20   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD502             BPL.N    ??mbedtls_mpi_mul_mod_2
   \       0x28   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x2C   0xB930             CBNZ.N   R0,??mbedtls_mpi_mul_mod_3
   \                     ??mbedtls_mpi_mul_mod_2: (+1)
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_bitlen
   \       0x34   0x6BF1             LDR      R1,[R6, #+60]
   \       0x36   0x0049             LSLS     R1,R1,#+1
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD202             BCS.N    ??mbedtls_mpi_mul_mod_4
   \                     ??mbedtls_mpi_mul_mod_3: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R4,??DataTable14_1
   \       0x40   0xE012             B.N      ??mbedtls_mpi_mul_mod_0
   \                     ??mbedtls_mpi_mul_mod_4: (+1)
   \       0x42   0x6CB1             LDR      R1,[R6, #+72]
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x4788             BLX      R1
   \       0x48   0x0004             MOVS     R4,R0
   \       0x4A   0xD10D             BNE.N    ??mbedtls_mpi_mul_mod_0
   \                     ??mbedtls_mpi_mul_mod_5: (+1)
   \       0x4C   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD50B             BPL.N    ??mbedtls_mpi_mul_mod_6
   \       0x54   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x58   0xB140             CBZ.N    R0,??mbedtls_mpi_mul_mod_6
   \       0x5A   0x1D32             ADDS     R2,R6,#+4
   \       0x5C   0x4629             MOV      R1,R5
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x64   0x0004             MOVS     R4,R0
   \       0x66   0xD0F1             BEQ.N    ??mbedtls_mpi_mul_mod_5
   1078          cleanup:
   1079              return ret;
   \                     ??mbedtls_mpi_mul_mod_0: (+1)
   \       0x68   0x4620             MOV      R0,R4
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   \                     ??mbedtls_mpi_mul_mod_6: (+1)
   \       0x6C   0x1D31             ADDS     R1,R6,#+4
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD4F7             BMI.N    ??mbedtls_mpi_mul_mod_0
   \       0x78   0x1D32             ADDS     R2,R6,#+4
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x82   0x0004             MOVS     R4,R0
   \       0x84   0xD0F2             BEQ.N    ??mbedtls_mpi_mul_mod_6
   \       0x86   0xE7EF             B.N      ??mbedtls_mpi_mul_mod_0
   1080          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x460D             MOV      R5,R1
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4611             MOV      R1,R2
   \        0x6   0x461A             MOV      R2,R3
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      mbedtls_mpi_cmp_int
   1081          
   1082          /*
   1083           * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_sub_mpi
   1084           * N->s < 0 is a very fast test, which fails only if N is 0
   1085           */
   1086          #define MOD_SUB(N)                                                          \
   1087              do {                                                                      \
   1088                  while ((N)->s < 0 && mbedtls_mpi_cmp_int((N), 0) != 0)             \
   1089                  MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi((N), (N), &grp->P));      \
   1090              } while (0)
   1091          
   1092          #if (defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED) && \
   1093              !(defined(MBEDTLS_ECP_NO_FALLBACK) && \
   1094              defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) && \
   1095              defined(MBEDTLS_ECP_ADD_MIXED_ALT))) || \
   1096              (defined(MBEDTLS_ECP_MONTGOMERY_ENABLED) && \
   1097              !(defined(MBEDTLS_ECP_NO_FALLBACK) && \
   1098              defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)))

   \                                 In section .text, align 2, keep-with-next
   1099          static inline int mbedtls_mpi_sub_mod(const mbedtls_ecp_group *grp,
   1100                                                mbedtls_mpi *X,
   1101                                                const mbedtls_mpi *A,
   1102                                                const mbedtls_mpi *B)
   1103          {
   \                     mbedtls_mpi_sub_mod: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4611             MOV      R1,R2
   1104              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1105              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(X, A, B));
   \        0x8   0x461A             MOV      R2,R3
   \        0xA   0x4630             MOV      R0,R6
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x10   0x0004             MOVS     R4,R0
   \       0x12   0xD10F             BNE.N    ??mbedtls_mpi_sub_mod_0
   1106              MOD_SUB(X);
   \                     ??mbedtls_mpi_sub_mod_1: (+1)
   \       0x14   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD50B             BPL.N    ??mbedtls_mpi_sub_mod_0
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x24   0xB130             CBZ.N    R0,??mbedtls_mpi_sub_mod_0
   \       0x26   0x1D2A             ADDS     R2,R5,#+4
   \       0x28   0x4631             MOV      R1,R6
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0x30   0x0004             MOVS     R4,R0
   \       0x32   0xD0EF             BEQ.N    ??mbedtls_mpi_sub_mod_1
   1107          cleanup:
   1108              return ret;
   \                     ??mbedtls_mpi_sub_mod_0: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0xBD70             POP      {R4-R6,PC}
   1109          }
   1110          #endif /* All functions referencing mbedtls_mpi_sub_mod() are alt-implemented without fallback */
   1111          
   1112          /*
   1113           * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_add_mpi and mbedtls_mpi_mul_int.
   1114           * We known P, N and the result are positive, so sub_abs is correct, and
   1115           * a bit faster.
   1116           */
   1117          #define MOD_ADD(N)                                                   \
   1118              while (mbedtls_mpi_cmp_mpi((N), &grp->P) >= 0)                  \
   1119              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_abs((N), (N), &grp->P))
   1120          

   \                                 In section .text, align 2, keep-with-next
   1121          static inline int mbedtls_mpi_add_mod(const mbedtls_ecp_group *grp,
   1122                                                mbedtls_mpi *X,
   1123                                                const mbedtls_mpi *A,
   1124                                                const mbedtls_mpi *B)
   1125          {
   \                     mbedtls_mpi_add_mod: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1126              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1127              MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(X, A, B));
   \                     ??CrossCallReturnLabel_17: (+1)
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \        0xA   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x0004             MOVS     R4,R0
   \        0x2   0xD10C             BNE.N    ??Subroutine1_0
   1128              MOD_ADD(X);
   \                     ??Subroutine1_1: (+1)
   \        0x4   0x1D31             ADDS     R1,R6,#+4
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD406             BMI.N    ??Subroutine1_0
   \       0x10   0x1D32             ADDS     R2,R6,#+4
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_sub_abs
   \       0x1A   0x0004             MOVS     R4,R0
   \       0x1C   0xD0F2             BEQ.N    ??Subroutine1_1
   1129          cleanup:
   1130              return ret;
   \                     ??Subroutine1_0: (+1)
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0xBD70             POP      {R4-R6,PC}
   1131          }
   1132          
   1133          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   1134          
   1135          #if !(defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_JAC_ALT))

   \                                 In section .text, align 2, keep-with-next
   1136          static inline int mbedtls_mpi_mul_int_mod(const mbedtls_ecp_group *grp,
   1137                                                    mbedtls_mpi *X,
   1138                                                    const mbedtls_mpi *A,
   1139                                                    mbedtls_mpi_uint c)
   1140          {
   \                     mbedtls_mpi_mul_int_mod: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   1141              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1142          
   1143              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int(X, A, c));
   \                     ??CrossCallReturnLabel_18: (+1)
   \        0x6   0x.... 0x....      BL       mbedtls_mpi_mul_int
   \        0xA                      REQUIRE ?Subroutine1
   \        0xA                      ;; // Fall through to label ?Subroutine1
   1144              MOD_ADD(X);
   1145          cleanup:
   1146              return ret;
   1147          }
   1148          #endif /* !(MBEDTLS_ECP_NO_FALLBACK && MBEDTLS_ECP_DOUBLE_JAC_ALT) */
   1149          
   1150          static inline int mbedtls_mpi_sub_int_mod(const mbedtls_ecp_group *grp,
   1151                                                    mbedtls_mpi *X,
   1152                                                    const mbedtls_mpi *A,
   1153                                                    mbedtls_mpi_uint c)
   1154          {
   1155              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1156          
   1157              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(X, A, c));
   1158              MOD_SUB(X);
   1159          cleanup:
   1160              return ret;
   1161          }
   1162          
   1163          #define MPI_ECP_SUB_INT(X, A, c)             \
   1164              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int_mod(grp, X, A, c))
   1165          
   1166          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   1167          
   1168          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED) && \
   1169              !(defined(MBEDTLS_ECP_NO_FALLBACK) && \
   1170              defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) && \
   1171              defined(MBEDTLS_ECP_ADD_MIXED_ALT))

   \                                 In section .text, align 2, keep-with-next
   1172          static inline int mbedtls_mpi_shift_l_mod(const mbedtls_ecp_group *grp,
   1173                                                    mbedtls_mpi *X,
   1174                                                    size_t count)
   1175          {
   \                     mbedtls_mpi_shift_l_mod: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4611             MOV      R1,R2
   1176              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1177              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l(X, count));
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x.... 0x....      BL       mbedtls_mpi_shift_l
   \        0xE   0x....             B.N      ?Subroutine1
   1178              MOD_ADD(X);
   1179          cleanup:
   1180              return ret;
   1181          }
   1182          #endif \
   1183              /* All functions referencing mbedtls_mpi_shift_l_mod() are alt-implemented without fallback */
   1184          
   1185          /*
   1186           * Macro wrappers around ECP modular arithmetic
   1187           *
   1188           * Currently, these wrappers are defined via the bignum module.
   1189           */
   1190          
   1191          #define MPI_ECP_ADD(X, A, B)                                                  \
   1192              MBEDTLS_MPI_CHK(mbedtls_mpi_add_mod(grp, X, A, B))
   1193          
   1194          #define MPI_ECP_SUB(X, A, B)                                                  \
   1195              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mod(grp, X, A, B))
   1196          
   1197          #define MPI_ECP_MUL(X, A, B)                                                  \
   1198              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mod(grp, X, A, B))
   1199          
   1200          #define MPI_ECP_SQR(X, A)                                                     \
   1201              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mod(grp, X, A, A))
   1202          
   1203          #define MPI_ECP_MUL_INT(X, A, c)                                              \
   1204              MBEDTLS_MPI_CHK(mbedtls_mpi_mul_int_mod(grp, X, A, c))
   1205          
   1206          #define MPI_ECP_INV(dst, src)                                                 \
   1207              MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod((dst), (src), &grp->P))
   1208          
   1209          #define MPI_ECP_MOV(X, A)                                                     \
   1210              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(X, A))
   1211          
   1212          #define MPI_ECP_SHIFT_L(X, count)                                             \
   1213              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_l_mod(grp, X, count))
   1214          
   1215          #define MPI_ECP_LSET(X, c)                                                    \
   1216              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(X, c))
   1217          
   1218          #define MPI_ECP_CMP_INT(X, c)                                                 \
   1219              mbedtls_mpi_cmp_int(X, c)
   1220          
   1221          #define MPI_ECP_CMP(X, Y)                                                     \
   1222              mbedtls_mpi_cmp_mpi(X, Y)
   1223          
   1224          /* Needs f_rng, p_rng to be defined. */
   1225          #define MPI_ECP_RAND(X)                                                       \
   1226              MBEDTLS_MPI_CHK(mbedtls_mpi_random((X), 2, &grp->P, f_rng, p_rng))
   1227          
   1228          /* Conditional negation
   1229           * Needs grp and a temporary MPI tmp to be defined. */
   1230          #define MPI_ECP_COND_NEG(X, cond)                                        \
   1231              do                                                                     \
   1232              {                                                                      \
   1233                  unsigned char nonzero = mbedtls_mpi_cmp_int((X), 0) != 0;        \
   1234                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&tmp, &grp->P, (X)));      \
   1235                  MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign((X), &tmp,          \
   1236                                                               nonzero & cond)); \
   1237              } while (0)
   1238          
   1239          #define MPI_ECP_NEG(X) MPI_ECP_COND_NEG((X), 1)
   1240          
   1241          #define MPI_ECP_VALID(X)                      \
   1242              ((X)->p != NULL)
   1243          
   1244          #define MPI_ECP_COND_ASSIGN(X, Y, cond)       \
   1245              MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign((X), (Y), (cond)))
   1246          
   1247          #define MPI_ECP_COND_SWAP(X, Y, cond)       \
   1248              MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_swap((X), (Y), (cond)))
   1249          
   1250          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   1251          
   1252          /*
   1253           * Computes the right-hand side of the Short Weierstrass equation
   1254           * RHS = X^3 + A X + B
   1255           */
   1256          static int ecp_sw_rhs(const mbedtls_ecp_group *grp,
   1257                                mbedtls_mpi *rhs,
   1258                                const mbedtls_mpi *X)
   1259          {
   1260              int ret;
   1261          
   1262              /* Compute X^3 + A X + B as X (X^2 + A) + B */
   1263              MPI_ECP_SQR(rhs, X);
   1264          
   1265              /* Special case for A = -3 */
   1266              if (mbedtls_ecp_group_a_is_minus_3(grp)) {
   1267                  MPI_ECP_SUB_INT(rhs, rhs, 3);
   1268              } else {
   1269                  MPI_ECP_ADD(rhs, rhs, &grp->A);
   1270              }
   1271          
   1272              MPI_ECP_MUL(rhs, rhs, X);
   1273              MPI_ECP_ADD(rhs, rhs, &grp->B);
   1274          
   1275          cleanup:
   1276              return ret;
   1277          }
   1278          
   1279          #if defined(MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING)
   1280          /*
   1281           * Derive Y from X and a parity bit
   1282           */
   1283          static int mbedtls_ecp_sw_derive_y(const mbedtls_ecp_group *grp,
   1284                                             const mbedtls_mpi *X,
   1285                                             mbedtls_mpi *Y,
   1286                                             int parity_bit)
   1287          {
   1288              /* w = y^2 = x^3 + ax + b
   1289               * y = sqrt(w) = w^((p+1)/4) mod p   (for prime p where p = 3 mod 4)
   1290               *
   1291               * Note: this method for extracting square root does not validate that w
   1292               * was indeed a square so this function will return garbage in Y if X
   1293               * does not correspond to a point on the curve.
   1294               */
   1295          
   1296              /* Check prerequisite p = 3 mod 4 */
   1297              if (mbedtls_mpi_get_bit(&grp->P, 0) != 1 ||
   1298                  mbedtls_mpi_get_bit(&grp->P, 1) != 1) {
   1299                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1300              }
   1301          
   1302              int ret;
   1303              mbedtls_mpi exp;
   1304              mbedtls_mpi_init(&exp);
   1305          
   1306              /* use Y to store intermediate result, actually w above */
   1307              MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, Y, X));
   1308          
   1309              /* w = y^2 */ /* Y contains y^2 intermediate result */
   1310              /* exp = ((p+1)/4) */
   1311              MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&exp, &grp->P, 1));
   1312              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&exp, 2));
   1313              /* sqrt(w) = w^((p+1)/4) mod p   (for prime p where p = 3 mod 4) */
   1314              MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(Y, Y /*y^2*/, &exp, &grp->P, NULL));
   1315          
   1316              /* check parity bit match or else invert Y */
   1317              /* This quick inversion implementation is valid because Y != 0 for all
   1318               * Short Weierstrass curves supported by mbedtls, as each supported curve
   1319               * has an order that is a large prime, so each supported curve does not
   1320               * have any point of order 2, and a point with Y == 0 would be of order 2 */
   1321              if (mbedtls_mpi_get_bit(Y, 0) != parity_bit) {
   1322                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(Y, &grp->P, Y));
   1323              }
   1324          
   1325          cleanup:
   1326          
   1327              mbedtls_mpi_free(&exp);
   1328              return ret;
   1329          }
   1330          #endif /* MBEDTLS_ECP_ENABLE_COMPRESSED_CURVE_PARSING */
   1331          
   1332          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   1333          
   1334          #if defined(MBEDTLS_ECP_C)
   1335          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   1336          /*
   1337           * For curves in short Weierstrass form, we do all the internal operations in
   1338           * Jacobian coordinates.
   1339           *
   1340           * For multiplication, we'll use a comb method with countermeasures against
   1341           * SPA, hence timing attacks.
   1342           */
   1343          
   1344          /*
   1345           * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
   1346           * Cost: 1N := 1I + 3M + 1S
   1347           */

   \                                 In section .text, align 2, keep-with-next
   1348          static int ecp_normalize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt)
   1349          {
   \                     ecp_normalize_jac: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   1350              if (MPI_ECP_CMP_INT(&pt->Z, 0) == 0) {
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xF105 0x0010      ADD      R0,R5,#+16
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x10   0xB360             CBZ.N    R0,??ecp_normalize_jac_0
   1351                  return 0;
   1352              }
   1353          
   1354          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
   1355              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1356                  return mbedtls_internal_ecp_normalize_jac(grp, pt);
   1357              }
   1358          #endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */
   1359          
   1360          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
   1361              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1362          #else
   1363              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1364              mbedtls_mpi T;
   1365              mbedtls_mpi_init(&T);
   \       0x12   0x.... 0x....      BL       ?Subroutine11
   1366          
   1367              MPI_ECP_INV(&T,       &pt->Z);            /* T   <-          1 / Z   */
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x16   0x1D32             ADDS     R2,R6,#+4
   \       0x18   0xF105 0x0110      ADD      R1,R5,#+16
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_inv_mod
   \       0x22   0x0004             MOVS     R4,R0
   \       0x24   0xD11F             BNE.N    ??ecp_normalize_jac_1
   1368              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'  <- Y*T    = Y / Z   */
   \       0x26   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x2A   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x2E   0x0004             MOVS     R4,R0
   \       0x30   0xD119             BNE.N    ??ecp_normalize_jac_1
   1369              MPI_ECP_SQR(&T,       &T);                /* T   <- T^2    = 1 / Z^2 */
   \       0x32   0x466B             MOV      R3,SP
   \       0x34   0x466A             MOV      R2,SP
   \       0x36   0x4669             MOV      R1,SP
   \       0x38   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x3C   0x0004             MOVS     R4,R0
   \       0x3E   0xD112             BNE.N    ??ecp_normalize_jac_1
   1370              MPI_ECP_MUL(&pt->X,   &pt->X,     &T);    /* X   <- X  * T = X / Z^2 */
   \       0x40   0x466B             MOV      R3,SP
   \       0x42   0x462A             MOV      R2,R5
   \       0x44   0x4629             MOV      R1,R5
   \       0x46   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0xD10B             BNE.N    ??ecp_normalize_jac_1
   1371              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &T);    /* Y'' <- Y' * T = Y / Z^3 */
   \       0x4E   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x52   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x56   0x0004             MOVS     R4,R0
   \       0x58   0xD105             BNE.N    ??ecp_normalize_jac_1
   1372          
   1373              MPI_ECP_LSET(&pt->Z, 1);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x60   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0x64   0x4604             MOV      R4,R0
   1374          
   1375          cleanup:
   1376          
   1377              mbedtls_mpi_free(&T);
   \                     ??ecp_normalize_jac_1: (+1)
   \       0x66   0x.... 0x....      BL       ?Subroutine12
   1378          
   1379              return ret;
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x6A   0x4620             MOV      R0,R4
   \                     ??ecp_normalize_jac_0: (+1)
   \       0x6C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1380          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT) */
   1381          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x466B             MOV      R3,SP
   \        0x2   0xF105 0x0208      ADD      R2,R5,#+8
   \        0x6   0xF105 0x0108      ADD      R1,R5,#+8
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine26_0: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x....             B.N      mbedtls_mpi_mul_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4668             MOV      R0,SP
   \        0x2   0x.... 0x....      B.W      mbedtls_mpi_free

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x4668             MOV      R0,SP
   \        0x2   0x.... 0x....      B.W      mbedtls_mpi_init
   1382          
   1383          /*
   1384           * Normalize jacobian coordinates of an array of (pointers to) points,
   1385           * using Montgomery's trick to perform only one inversion mod P.
   1386           * (See for example Cohen's "A Course in Computational Algebraic Number
   1387           * Theory", Algorithm 10.3.4.)
   1388           *
   1389           * Warning: fails (returning an error) if one of the points is zero!
   1390           * This should never happen, see choice of w in ecp_mul_comb().
   1391           *
   1392           * Cost: 1N(t) := 1I + (6t - 3)M + 1S
   1393           */

   \                                 In section .text, align 2, keep-with-next
   1394          static int ecp_normalize_jac_many(const mbedtls_ecp_group *grp,
   1395                                            mbedtls_ecp_point *T[], size_t T_size)
   1396          {
   \                     ecp_normalize_jac_many: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460F             MOV      R7,R1
   1397              if (T_size < 2) {
   \        0xA   0x2D01             CMP      R5,#+1
   \        0xC   0xD803             BHI.N    ??ecp_normalize_jac_many_0
   1398                  return ecp_normalize_jac(grp, *T);
   \        0xE   0x6839             LDR      R1,[R7, #+0]
   \       0x10   0x.... 0x....      BL       ecp_normalize_jac
   \       0x14   0xE084             B.N      ??ecp_normalize_jac_many_1
   1399              }
   1400          
   1401          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT)
   1402              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1403                  return mbedtls_internal_ecp_normalize_jac_many(grp, T, T_size);
   1404              }
   1405          #endif
   1406          
   1407          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT)
   1408              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1409          #else
   1410              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1411              size_t i;
   1412              mbedtls_mpi *c, t;
   1413          
   1414              if ((c = mbedtls_calloc(T_size, sizeof(mbedtls_mpi))) == NULL) {
   \                     ??ecp_normalize_jac_many_0: (+1)
   \       0x16   0x2108             MOVS     R1,#+8
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x.... 0x....      BL       sl_calloc
   \       0x1E   0xEA5F 0x0800      MOVS     R8,R0
   \       0x22   0xBF08             IT       EQ
   \       0x24   0x.... 0x....      LDREQ.W  R0,??DataTable20
   1415                  return MBEDTLS_ERR_ECP_ALLOC_FAILED;
   \       0x28   0xD07A             BEQ.N    ??ecp_normalize_jac_many_1
   1416              }
   1417          
   1418              mbedtls_mpi_init(&t);
   \       0x2A   0x.... 0x....      BL       ?Subroutine11
   1419          
   1420              mpi_init_many(c, T_size);
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x2E   0x4629             MOV      R1,R5
   \       0x30   0x4640             MOV      R0,R8
   \       0x32   0x.... 0x....      BL       mpi_init_many
   1421              /*
   1422               * c[i] = Z_0 * ... * Z_i,   i = 0,..,n := T_size-1
   1423               */
   1424              MPI_ECP_MOV(&c[0], &T[0]->Z);
   \       0x36   0x6838             LDR      R0,[R7, #+0]
   \       0x38   0xF100 0x0110      ADD      R1,R0,#+16
   \       0x3C   0x4640             MOV      R0,R8
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x42   0x0004             MOVS     R4,R0
   \       0x44   0xD162             BNE.N    ??ecp_normalize_jac_many_2
   1425              for (i = 1; i < T_size; i++) {
   \       0x46   0x2401             MOVS     R4,#+1
   \       0x48   0xF1A8 0x0B08      SUB      R11,R8,#+8
   \       0x4C   0xE00A             B.N      ??ecp_normalize_jac_many_3
   1426                  MPI_ECP_MUL(&c[i], &c[i-1], &T[i]->Z);
   \                     ??ecp_normalize_jac_many_4: (+1)
   \       0x4E   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \       0x52   0xEB0B 0x02C4      ADD      R2,R11,R4, LSL #+3
   \       0x56   0xEB08 0x01C4      ADD      R1,R8,R4, LSL #+3
   \       0x5A   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD153             BNE.N    ??ecp_normalize_jac_many_5
   1427              }
   \       0x62   0x1C64             ADDS     R4,R4,#+1
   \                     ??ecp_normalize_jac_many_3: (+1)
   \       0x64   0x42AC             CMP      R4,R5
   \       0x66   0xD3F2             BCC.N    ??ecp_normalize_jac_many_4
   1428          
   1429              /*
   1430               * c[n] = 1 / (Z_0 * ... * Z_n) mod P
   1431               */
   1432              MPI_ECP_INV(&c[T_size-1], &c[T_size-1]);
   \       0x68   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x6C   0x1D32             ADDS     R2,R6,#+4
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0x.... 0x....      BL       mbedtls_mpi_inv_mod
   \       0x74   0x0004             MOVS     R4,R0
   \       0x76   0xD149             BNE.N    ??ecp_normalize_jac_many_2
   1433          
   1434              for (i = T_size - 1;; i--) {
   \       0x78   0x1E6C             SUBS     R4,R5,#+1
   \       0x7A   0xE032             B.N      ??ecp_normalize_jac_many_6
   1435                  /* At the start of iteration i (note that i decrements), we have
   1436                   * - c[j] = Z_0 * .... * Z_j        for j  < i,
   1437                   * - c[j] = 1 / (Z_0 * .... * Z_j)  for j == i,
   1438                   *
   1439                   * This is maintained via
   1440                   * - c[i-1] <- c[i] * Z_i
   1441                   *
   1442                   * We also derive 1/Z_i = c[i] * c[i-1] for i>0 and use that
   1443                   * to do the actual normalization. For i==0, we already have
   1444                   * c[0] = 1 / Z_0.
   1445                   */
   1446          
   1447                  if (i > 0) {
   1448                      /* Compute 1/Z_i and establish invariant for the next iteration. */
   1449                      MPI_ECP_MUL(&t,      &c[i], &c[i-1]);
   1450                      MPI_ECP_MUL(&c[i-1], &c[i], &T[i]->Z);
   1451                  } else {
   1452                      MPI_ECP_MOV(&t, &c[0]);
   \                     ??ecp_normalize_jac_many_7: (+1)
   \       0x7C   0x4641             MOV      R1,R8
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD140             BNE.N    ??ecp_normalize_jac_many_5
   1453                  }
   1454          
   1455                  /* Now t holds 1 / Z_i; normalize as in ecp_normalize_jac() */
   1456                  MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   \                     ??ecp_normalize_jac_many_8: (+1)
   \       0x88   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD13C             BNE.N    ??ecp_normalize_jac_many_5
   1457                  MPI_ECP_SQR(&t,       &t);
   \       0x90   0x466B             MOV      R3,SP
   \       0x92   0x466A             MOV      R2,SP
   \       0x94   0x4669             MOV      R1,SP
   \       0x96   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD135             BNE.N    ??ecp_normalize_jac_many_5
   1458                  MPI_ECP_MUL(&T[i]->X, &T[i]->X, &t);
   \       0x9E   0xF857 0x1024      LDR      R1,[R7, R4, LSL #+2]
   \       0xA2   0x466B             MOV      R3,SP
   \       0xA4   0x4630             MOV      R0,R6
   \       0xA6   0x460A             MOV      R2,R1
   \       0xA8   0x.... 0x....      BL       mbedtls_mpi_mul_mod
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD12C             BNE.N    ??ecp_normalize_jac_many_5
   1459                  MPI_ECP_MUL(&T[i]->Y, &T[i]->Y, &t);
   \       0xB0   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0xB4   0xBB48             CBNZ.N   R0,??ecp_normalize_jac_many_5
   1460          
   1461                  /*
   1462                   * Post-precessing: reclaim some memory by shrinking coordinates
   1463                   * - not storing Z (always 1)
   1464                   * - shrinking other coordinates, but still keeping the same number of
   1465                   *   limbs as P, as otherwise it will too likely be regrown too fast.
   1466                   */
   1467                  MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->X, grp->P.n));
   \       0xB6   0x8971             LDRH     R1,[R6, #+10]
   \       0xB8   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \       0xBC   0x.... 0x....      BL       mbedtls_mpi_shrink
   \       0xC0   0xBB18             CBNZ.N   R0,??ecp_normalize_jac_many_5
   1468                  MBEDTLS_MPI_CHK(mbedtls_mpi_shrink(&T[i]->Y, grp->P.n));
   \       0xC2   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \       0xC6   0x8971             LDRH     R1,[R6, #+10]
   \       0xC8   0x3008             ADDS     R0,R0,#+8
   \       0xCA   0x.... 0x....      BL       mbedtls_mpi_shrink
   \       0xCE   0xB9E0             CBNZ.N   R0,??ecp_normalize_jac_many_5
   1469          
   1470                  MPI_ECP_LSET(&T[i]->Z, 1);
   \       0xD0   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \       0xD4   0x2101             MOVS     R1,#+1
   \       0xD6   0x3010             ADDS     R0,R0,#+16
   \       0xD8   0x.... 0x....      BL       mbedtls_mpi_lset
   \       0xDC   0xB9A8             CBNZ.N   R0,??ecp_normalize_jac_many_5
   1471          
   1472                  if (i == 0) {
   \       0xDE   0xB1A4             CBZ.N    R4,??ecp_normalize_jac_many_5
   \       0xE0   0x1E64             SUBS     R4,R4,#+1
   \                     ??ecp_normalize_jac_many_6: (+1)
   \       0xE2   0x2C00             CMP      R4,#+0
   \       0xE4   0xD0CA             BEQ.N    ??ecp_normalize_jac_many_7
   \       0xE6   0xEB0B 0x09C4      ADD      R9,R11,R4, LSL #+3
   \       0xEA   0xEB08 0x0AC4      ADD      R10,R8,R4, LSL #+3
   \       0xEE   0x464B             MOV      R3,R9
   \       0xF0   0x4652             MOV      R2,R10
   \       0xF2   0x4669             MOV      R1,SP
   \       0xF4   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0xF8   0xB938             CBNZ.N   R0,??ecp_normalize_jac_many_5
   \       0xFA   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \       0xFE   0x4652             MOV      R2,R10
   \      0x100   0x4649             MOV      R1,R9
   \      0x102   0x.... 0x....      BL       ?Subroutine17
   1473                      break;
   1474                  }
   1475              }
   \                     ??CrossCallReturnLabel_34: (+1)
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD0BE             BEQ.N    ??ecp_normalize_jac_many_8
   \                     ??ecp_normalize_jac_many_5: (+1)
   \      0x10A   0x4604             MOV      R4,R0
   1476          
   1477          cleanup:
   1478          
   1479              mbedtls_mpi_free(&t);
   \                     ??ecp_normalize_jac_many_2: (+1)
   \      0x10C   0x.... 0x....      BL       ?Subroutine12
   1480              mpi_free_many(c, T_size);
   \                     ??CrossCallReturnLabel_25: (+1)
   \      0x110   0x4629             MOV      R1,R5
   \      0x112   0x4640             MOV      R0,R8
   \      0x114   0x.... 0x....      BL       mpi_free_many
   1481              mbedtls_free(c);
   \      0x118   0x4640             MOV      R0,R8
   \      0x11A   0x.... 0x....      BL       sl_free
   1482          
   1483              return ret;
   \      0x11E   0x4620             MOV      R0,R4
   \                     ??ecp_normalize_jac_many_1: (+1)
   \      0x120   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1484          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT) */
   1485          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0xF100 0x0310      ADD      R3,R0,#+16
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....             B.N      mbedtls_mpi_mul_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \        0x4   0xF100 0x0208      ADD      R2,R0,#+8
   \        0x8   0x466B             MOV      R3,SP
   \        0xA   0xF100 0x0108      ADD      R1,R0,#+8
   \        0xE                      REQUIRE ??Subroutine26_0
   \        0xE                      ;; // Fall through to label ??Subroutine26_0
   1486          
   1487          /*
   1488           * Conditional point inversion: Q -> -Q = (Q.X, -Q.Y, Q.Z) without leak.
   1489           * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid
   1490           */

   \                                 In section .text, align 2, keep-with-next
   1491          static int ecp_safe_invert_jac(const mbedtls_ecp_group *grp,
   1492                                         mbedtls_ecp_point *Q,
   1493                                         unsigned char inv)
   1494          {
   \                     ecp_safe_invert_jac: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   1495              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1496              mbedtls_mpi tmp;
   1497              mbedtls_mpi_init(&tmp);
   \        0x8   0x.... 0x....      BL       ?Subroutine11
   1498          
   1499              MPI_ECP_COND_NEG(&Q->Y, inv);
   \                     ??CrossCallReturnLabel_20: (+1)
   \        0xC   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x10   0x0007             MOVS     R7,R0
   \       0x12   0xBF18             IT       NE
   \       0x14   0x2701             MOVNE    R7,#+1
   \       0x16   0xF105 0x0208      ADD      R2,R5,#+8
   \       0x1A   0x1D21             ADDS     R1,R4,#+4
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x22   0x0004             MOVS     R4,R0
   \       0x24   0xD107             BNE.N    ??ecp_safe_invert_jac_0
   \       0x26   0xEA06 0x0207      AND      R2,R6,R7
   \       0x2A   0x4669             MOV      R1,SP
   \       0x2C   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x30   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x34   0x4604             MOV      R4,R0
   1500          
   1501          cleanup:
   1502              mbedtls_mpi_free(&tmp);
   \                     ??ecp_safe_invert_jac_0: (+1)
   \       0x36   0x.... 0x....      BL       ?Subroutine12
   1503              return ret;
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0xBDFE             POP      {R1-R7,PC}
   1504          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0xF105 0x0008      ADD      R0,R5,#+8
   \        0x6   0x.... 0x....      B.W      mbedtls_mpi_cmp_int
   1505          
   1506          /*
   1507           * Point doubling R = 2 P, Jacobian coordinates
   1508           *
   1509           * Based on http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2 .
   1510           *
   1511           * We follow the variable naming fairly closely. The formula variations that trade a MUL for a SQR
   1512           * (plus a few ADDs) aren't useful as our bignum implementation doesn't distinguish squaring.
   1513           *
   1514           * Standard optimizations are applied when curve parameter A is one of { 0, -3 }.
   1515           *
   1516           * Cost: 1D := 3M + 4S          (A ==  0)
   1517           *             4M + 4S          (A == -3)
   1518           *             3M + 6S + 1a     otherwise
   1519           */

   \                                 In section .text, align 2, keep-with-next
   1520          static int ecp_double_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   1521                                    const mbedtls_ecp_point *P,
   1522                                    mbedtls_mpi tmp[4])
   1523          {
   \                     ecp_double_jac: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461E             MOV      R6,R3
   1524          #if defined(MBEDTLS_SELF_TEST)
   1525              dbl_count++;
   1526          #endif
   1527          
   1528          #if defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)
   1529              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1530                  return mbedtls_internal_ecp_double_jac(grp, R, P);
   1531              }
   1532          #endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */
   1533          
   1534          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)
   1535              (void)tmp;
   1536              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1537          #else
   1538              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1539          
   1540              /* Special case for A = -3 */
   1541              if (mbedtls_ecp_group_a_is_minus_3(grp)) {
   \        0xA   0x.... 0x....      BL       mbedtls_ecp_group_a_is_minus_3
   \        0xE   0xB320             CBZ.N    R0,??ecp_double_jac_0
   1542                  /* tmp[0] <- M = 3(X + Z^2)(X - Z^2) */
   1543                  MPI_ECP_SQR(&tmp[1],  &P->Z);
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD13A             BNE.N    ??ecp_double_jac_1
   1544                  MPI_ECP_ADD(&tmp[2],  &P->X,  &tmp[1]);
   \       0x18   0xF106 0x0308      ADD      R3,R6,#+8
   \       0x1C   0x462A             MOV      R2,R5
   \       0x1E   0xF106 0x0110      ADD      R1,R6,#+16
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_add_mod
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD130             BNE.N    ??ecp_double_jac_1
   1545                  MPI_ECP_SUB(&tmp[3],  &P->X,  &tmp[1]);
   \       0x2C   0xF106 0x0308      ADD      R3,R6,#+8
   \       0x30   0x462A             MOV      R2,R5
   \       0x32   0xF106 0x0118      ADD      R1,R6,#+24
   \       0x36   0x4638             MOV      R0,R7
   \       0x38   0x.... 0x....      BL       mbedtls_mpi_sub_mod
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD126             BNE.N    ??ecp_double_jac_1
   1546                  MPI_ECP_MUL(&tmp[1],  &tmp[2],     &tmp[3]);
   \       0x40   0xF106 0x0318      ADD      R3,R6,#+24
   \       0x44   0xF106 0x0210      ADD      R2,R6,#+16
   \       0x48   0x.... 0x....      BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD11E             BNE.N    ??ecp_double_jac_1
   1547                  MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],     3);
   \       0x50   0x.... 0x....      BL       ?Subroutine21
   1548              } else {
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD11A             BNE.N    ??ecp_double_jac_1
   \       0x58   0xE02B             B.N      ??ecp_double_jac_2
   1549                  /* tmp[0] <- M = 3.X^2 + A.Z^4 */
   1550                  MPI_ECP_SQR(&tmp[1],  &P->X);
   \                     ??ecp_double_jac_0: (+1)
   \       0x5A   0x462B             MOV      R3,R5
   \       0x5C   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD114             BNE.N    ??ecp_double_jac_1
   1551                  MPI_ECP_MUL_INT(&tmp[0],  &tmp[1],  3);
   \       0x64   0x.... 0x....      BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD110             BNE.N    ??ecp_double_jac_1
   1552          
   1553                  /* Optimize away for "koblitz" curves with A = 0 */
   1554                  if (MPI_ECP_CMP_INT(&grp->A, 0) != 0) {
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0xF107 0x000C      ADD      R0,R7,#+12
   \       0x72   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x76   0xB1E0             CBZ.N    R0,??ecp_double_jac_2
   1555                      /* M += A.Z^4 */
   1556                      MPI_ECP_SQR(&tmp[1],  &P->Z);
   \       0x78   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD106             BNE.N    ??ecp_double_jac_1
   1557                      MPI_ECP_SQR(&tmp[2],  &tmp[1]);
   \       0x80   0xF106 0x0308      ADD      R3,R6,#+8
   \       0x84   0xF106 0x0208      ADD      R2,R6,#+8
   \       0x88   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x8C   0x2800             CMP      R0,#+0
   \                     ??ecp_double_jac_1: (+1)
   \       0x8E   0xD17A             BNE.N    ??ecp_double_jac_3
   1558                      MPI_ECP_MUL(&tmp[1],  &tmp[2],     &grp->A);
   \       0x90   0xF107 0x030C      ADD      R3,R7,#+12
   \       0x94   0xF106 0x0210      ADD      R2,R6,#+16
   \       0x98   0x.... 0x....      BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD172             BNE.N    ??ecp_double_jac_3
   1559                      MPI_ECP_ADD(&tmp[0],  &tmp[0],     &tmp[1]);
   \       0xA0   0xF106 0x0308      ADD      R3,R6,#+8
   \       0xA4   0x4632             MOV      R2,R6
   \       0xA6   0x4631             MOV      R1,R6
   \       0xA8   0x4638             MOV      R0,R7
   \       0xAA   0x.... 0x....      BL       mbedtls_mpi_add_mod
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD169             BNE.N    ??ecp_double_jac_3
   1560                  }
   1561              }
   1562          
   1563              /* tmp[1] <- S = 4.X.Y^2 */
   1564              MPI_ECP_SQR(&tmp[2],  &P->Y);
   \                     ??ecp_double_jac_2: (+1)
   \       0xB2   0xF105 0x0308      ADD      R3,R5,#+8
   \       0xB6   0xF105 0x0208      ADD      R2,R5,#+8
   \       0xBA   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD161             BNE.N    ??ecp_double_jac_3
   1565              MPI_ECP_SHIFT_L(&tmp[2],  1);
   \       0xC2   0x2201             MOVS     R2,#+1
   \       0xC4   0xF106 0x0110      ADD      R1,R6,#+16
   \       0xC8   0x.... 0x....      BL       ??Subroutine22_0
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD15A             BNE.N    ??ecp_double_jac_3
   1566              MPI_ECP_MUL(&tmp[1],  &P->X, &tmp[2]);
   \       0xD0   0xF106 0x0310      ADD      R3,R6,#+16
   \       0xD4   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD154             BNE.N    ??ecp_double_jac_3
   1567              MPI_ECP_SHIFT_L(&tmp[1],  1);
   \       0xDC   0x2201             MOVS     R2,#+1
   \       0xDE   0xF106 0x0108      ADD      R1,R6,#+8
   \       0xE2   0x.... 0x....      BL       ??Subroutine22_0
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD14D             BNE.N    ??ecp_double_jac_3
   1568          
   1569              /* tmp[3] <- U = 8.Y^4 */
   1570              MPI_ECP_SQR(&tmp[3],  &tmp[2]);
   \       0xEA   0xF106 0x0310      ADD      R3,R6,#+16
   \       0xEE   0xF106 0x0210      ADD      R2,R6,#+16
   \       0xF2   0xF106 0x0118      ADD      R1,R6,#+24
   \       0xF6   0x.... 0x....      BL       ??Subroutine19_0
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD143             BNE.N    ??ecp_double_jac_3
   1571              MPI_ECP_SHIFT_L(&tmp[3],  1);
   \       0xFE   0x.... 0x....      BL       ?Subroutine22
   \                     ??CrossCallReturnLabel_50: (+1)
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD13F             BNE.N    ??ecp_double_jac_3
   1572          
   1573              /* tmp[2] <- T = M^2 - 2.S */
   1574              MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   \      0x106   0x4633             MOV      R3,R6
   \      0x108   0x4632             MOV      R2,R6
   \      0x10A   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_40: (+1)
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD139             BNE.N    ??ecp_double_jac_3
   1575              MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   \      0x112   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_44: (+1)
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD135             BNE.N    ??ecp_double_jac_3
   1576              MPI_ECP_SUB(&tmp[2],  &tmp[2], &tmp[1]);
   \      0x11A   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_43: (+1)
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD131             BNE.N    ??ecp_double_jac_3
   1577          
   1578              /* tmp[1] <- S = M(S - T) - U */
   1579              MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[2]);
   \      0x122   0xF106 0x0310      ADD      R3,R6,#+16
   \      0x126   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_37: (+1)
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD12B             BNE.N    ??ecp_double_jac_3
   1580              MPI_ECP_MUL(&tmp[1],  &tmp[1],     &tmp[0]);
   \      0x12E   0x4633             MOV      R3,R6
   \      0x130   0xF106 0x0208      ADD      R2,R6,#+8
   \      0x134   0x.... 0x....      BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_66: (+1)
   \      0x138   0xBB28             CBNZ.N   R0,??ecp_double_jac_3
   1581              MPI_ECP_SUB(&tmp[1],  &tmp[1],     &tmp[3]);
   \      0x13A   0xF106 0x0318      ADD      R3,R6,#+24
   \      0x13E   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_36: (+1)
   \      0x142   0xBB00             CBNZ.N   R0,??ecp_double_jac_3
   1582          
   1583              /* tmp[3] <- U = 2.Y.Z */
   1584              MPI_ECP_MUL(&tmp[3],  &P->Y,  &P->Z);
   \      0x144   0xF105 0x0310      ADD      R3,R5,#+16
   \      0x148   0xF105 0x0208      ADD      R2,R5,#+8
   \      0x14C   0xF106 0x0118      ADD      R1,R6,#+24
   \      0x150   0x.... 0x....      BL       ??Subroutine19_0
   \                     ??CrossCallReturnLabel_38: (+1)
   \      0x154   0xB9B8             CBNZ.N   R0,??ecp_double_jac_3
   1585              MPI_ECP_SHIFT_L(&tmp[3],  1);
   \      0x156   0x.... 0x....      BL       ?Subroutine22
   \                     ??CrossCallReturnLabel_49: (+1)
   \      0x15A   0xB9A0             CBNZ.N   R0,??ecp_double_jac_3
   1586          
   1587              /* Store results */
   1588              MPI_ECP_MOV(&R->X, &tmp[2]);
   \      0x15C   0xF106 0x0110      ADD      R1,R6,#+16
   \      0x160   0x4620             MOV      R0,R4
   \      0x162   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x166   0xB970             CBNZ.N   R0,??ecp_double_jac_3
   1589              MPI_ECP_MOV(&R->Y, &tmp[1]);
   \      0x168   0xF106 0x0108      ADD      R1,R6,#+8
   \      0x16C   0xF104 0x0008      ADD      R0,R4,#+8
   \      0x170   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x174   0xB938             CBNZ.N   R0,??ecp_double_jac_3
   1590              MPI_ECP_MOV(&R->Z, &tmp[3]);
   \      0x176   0xF106 0x0118      ADD      R1,R6,#+24
   \      0x17A   0xF104 0x0010      ADD      R0,R4,#+16
   \      0x17E   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \      0x182   0x.... 0x....      B.W      mbedtls_mpi_copy
   1591          
   1592          cleanup:
   1593          
   1594              return ret;
   \                     ??ecp_double_jac_3: (+1)
   \      0x186   0xBDF2             POP      {R1,R4-R7,PC}
   1595          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_DOUBLE_JAC_ALT) */
   1596          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF106 0x0118      ADD      R1,R6,#+24
   \                     ??Subroutine22_0: (+1)
   \        0x6   0x4638             MOV      R0,R7
   \        0x8   0x....             B.N      mbedtls_mpi_shift_l_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x2303             MOVS     R3,#+3
   \        0x2   0xF106 0x0208      ADD      R2,R6,#+8
   \        0x6   0x4631             MOV      R1,R6
   \        0x8   0x4638             MOV      R0,R7
   \        0xA   0x....             B.N      mbedtls_mpi_mul_int_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0xF106 0x0308      ADD      R3,R6,#+8
   \        0x4   0xF106 0x0210      ADD      R2,R6,#+16
   \        0x8   0xF106 0x0110      ADD      R1,R6,#+16
   \        0xC   0x4638             MOV      R0,R7
   \        0xE   0x....             B.N      mbedtls_mpi_sub_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0xF106 0x0110      ADD      R1,R6,#+16
   \                     ??Subroutine19_0: (+1)
   \        0x4   0x4638             MOV      R0,R7
   \        0x6   0x....             B.N      mbedtls_mpi_mul_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0xF106 0x0208      ADD      R2,R6,#+8
   \        0x4   0xF106 0x0108      ADD      R1,R6,#+8
   \        0x8   0x4638             MOV      R0,R7
   \        0xA   0x....             B.N      mbedtls_mpi_sub_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0xF105 0x0310      ADD      R3,R5,#+16
   \        0x4   0xF105 0x0210      ADD      R2,R5,#+16
   \        0x8                      REQUIRE ??Subroutine27_0
   \        0x8                      ;; // Fall through to label ??Subroutine27_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine27_0: (+1)
   \        0x0   0xF106 0x0108      ADD      R1,R6,#+8
   \        0x4   0x4638             MOV      R0,R7
   \        0x6   0x....             B.N      mbedtls_mpi_mul_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x462A             MOV      R2,R5
   \        0x2   0xF106 0x0108      ADD      R1,R6,#+8
   \        0x6   0x4638             MOV      R0,R7
   \        0x8   0x....             B.N      mbedtls_mpi_mul_mod
   1597          
   1598          /*
   1599           * Addition: R = P + Q, mixed affine-Jacobian coordinates (GECC 3.22)
   1600           *
   1601           * The coordinates of Q must be normalized (= affine),
   1602           * but those of P don't need to. R is not normalized.
   1603           *
   1604           * P,Q,R may alias, but only at the level of EC points: they must be either
   1605           * equal as pointers, or disjoint (including the coordinate data buffers).
   1606           * Fine-grained aliasing at the level of coordinates is not supported.
   1607           *
   1608           * Special cases: (1) P or Q is zero, (2) R is zero, (3) P == Q.
   1609           * None of these cases can happen as intermediate step in ecp_mul_comb():
   1610           * - at each step, P, Q and R are multiples of the base point, the factor
   1611           *   being less than its order, so none of them is zero;
   1612           * - Q is an odd multiple of the base point, P an even multiple,
   1613           *   due to the choice of precomputed points in the modified comb method.
   1614           * So branches for these cases do not leak secret information.
   1615           *
   1616           * Cost: 1A := 8M + 3S
   1617           */

   \                                 In section .text, align 2, keep-with-next
   1618          static int ecp_add_mixed(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   1619                                   const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,
   1620                                   mbedtls_mpi tmp[4])
   1621          {
   \                     ecp_add_mixed: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x461E             MOV      R6,R3
   1622          #if defined(MBEDTLS_SELF_TEST)
   1623              add_count++;
   1624          #endif
   1625          
   1626          #if defined(MBEDTLS_ECP_ADD_MIXED_ALT)
   1627              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1628                  return mbedtls_internal_ecp_add_mixed(grp, R, P, Q);
   1629              }
   1630          #endif /* MBEDTLS_ECP_ADD_MIXED_ALT */
   1631          
   1632          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_ADD_MIXED_ALT)
   1633              (void)tmp;
   1634              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1635          #else
   1636              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1637          
   1638              /* NOTE: Aliasing between input and output is allowed, so one has to make
   1639               *       sure that at the point X,Y,Z are written, {P,Q}->{X,Y,Z} are no
   1640               *       longer read from. */
   1641              mbedtls_mpi * const X = &R->X;
   1642              mbedtls_mpi * const Y = &R->Y;
   1643              mbedtls_mpi * const Z = &R->Z;
   1644          
   1645              if (!MPI_ECP_VALID(&Q->Z)) {
   \        0x8   0x6930             LDR      R0,[R6, #+16]
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x4690             MOV      R8,R2
   \        0xE   0xB1C8             CBZ.N    R0,??ecp_add_mixed_0
   1646                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   1647              }
   1648          
   1649              /*
   1650               * Trivial cases: P == 0 or Q == 0 (case 1)
   1651               */
   1652              if (MPI_ECP_CMP_INT(&P->Z, 0) == 0) {
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0xF108 0x0010      ADD      R0,R8,#+16
   \       0x16   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x1A   0xB908             CBNZ.N   R0,??ecp_add_mixed_1
   1653                  return mbedtls_ecp_copy(R, Q);
   \       0x1C   0x4631             MOV      R1,R6
   \       0x1E   0xE006             B.N      ??ecp_add_mixed_2
   1654              }
   1655          
   1656              if (MPI_ECP_CMP_INT(&Q->Z, 0) == 0) {
   \                     ??ecp_add_mixed_1: (+1)
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x26   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x2A   0xB928             CBNZ.N   R0,??ecp_add_mixed_3
   1657                  return mbedtls_ecp_copy(R, P);
   \       0x2C   0x4641             MOV      R1,R8
   \                     ??ecp_add_mixed_2: (+1)
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x34   0x.... 0x....      B.W      mbedtls_ecp_copy
   1658              }
   1659          
   1660              /*
   1661               * Make sure Q coordinates are normalized
   1662               */
   1663              if (MPI_ECP_CMP_INT(&Q->Z, 1) != 0) {
   \                     ??ecp_add_mixed_3: (+1)
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x42   0xB108             CBZ.N    R0,??ecp_add_mixed_4
   1664                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??ecp_add_mixed_0: (+1)
   \       0x44   0x....             LDR.N    R0,??DataTable14_1
   \                     ??ecp_add_mixed_5: (+1)
   \       0x46   0xE0A7             B.N      ??ecp_add_mixed_6
   1665              }
   \                     ??ecp_add_mixed_4: (+1)
   \       0x48   0x9F06             LDR      R7,[SP, #+24]
   1666          
   1667              MPI_ECP_SQR(&tmp[0], &P->Z);
   \       0x4A   0xF108 0x0310      ADD      R3,R8,#+16
   \       0x4E   0xF108 0x0210      ADD      R2,R8,#+16
   \       0x52   0x4639             MOV      R1,R7
   \       0x54   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD1F4             BNE.N    ??ecp_add_mixed_5
   1668              MPI_ECP_MUL(&tmp[1], &tmp[0], &P->Z);
   \       0x5C   0xF108 0x0310      ADD      R3,R8,#+16
   \       0x60   0x463A             MOV      R2,R7
   \       0x62   0xF107 0x0108      ADD      R1,R7,#+8
   \       0x66   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD1EB             BNE.N    ??ecp_add_mixed_5
   1669              MPI_ECP_MUL(&tmp[0], &tmp[0], &Q->X);
   \       0x6E   0x4633             MOV      R3,R6
   \       0x70   0x463A             MOV      R2,R7
   \       0x72   0x4639             MOV      R1,R7
   \       0x74   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD10F             BNE.N    ??ecp_add_mixed_7
   1670              MPI_ECP_MUL(&tmp[1], &tmp[1], &Q->Y);
   \       0x7C   0xF106 0x0308      ADD      R3,R6,#+8
   \       0x80   0xF107 0x0208      ADD      R2,R7,#+8
   \       0x84   0xF107 0x0108      ADD      R1,R7,#+8
   \       0x88   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD105             BNE.N    ??ecp_add_mixed_7
   1671              MPI_ECP_SUB(&tmp[0], &tmp[0], &P->X);
   \       0x90   0x4643             MOV      R3,R8
   \       0x92   0x463A             MOV      R2,R7
   \       0x94   0x4639             MOV      R1,R7
   \       0x96   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x9A   0x2800             CMP      R0,#+0
   \                     ??ecp_add_mixed_7: (+1)
   \       0x9C   0xD17C             BNE.N    ??ecp_add_mixed_6
   1672              MPI_ECP_SUB(&tmp[1], &tmp[1], &P->Y);
   \       0x9E   0xF108 0x0308      ADD      R3,R8,#+8
   \       0xA2   0xF107 0x0208      ADD      R2,R7,#+8
   \       0xA6   0xF107 0x0108      ADD      R1,R7,#+8
   \       0xAA   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD172             BNE.N    ??ecp_add_mixed_6
   1673          
   1674              /* Special cases (2) and (3) */
   1675              if (MPI_ECP_CMP_INT(&tmp[0], 0) == 0) {
   \       0xB2   0x2100             MOVS     R1,#+0
   \       0xB4   0x4638             MOV      R0,R7
   \       0xB6   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0xBA   0xB988             CBNZ.N   R0,??ecp_add_mixed_8
   1676                  if (MPI_ECP_CMP_INT(&tmp[1], 0) == 0) {
   \       0xBC   0x2100             MOVS     R1,#+0
   \       0xBE   0xF107 0x0008      ADD      R0,R7,#+8
   \       0xC2   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0xC6   0xB930             CBNZ.N   R0,??ecp_add_mixed_9
   1677                      ret = ecp_double_jac(grp, R, P, tmp);
   \       0xC8   0x463B             MOV      R3,R7
   \       0xCA   0x4642             MOV      R2,R8
   \       0xCC   0x4629             MOV      R1,R5
   \       0xCE   0x4620             MOV      R0,R4
   \       0xD0   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xD4   0x....             B.N      ecp_double_jac
   1678                      goto cleanup;
   1679                  } else {
   1680                      ret = mbedtls_ecp_set_zero(R);
   \                     ??ecp_add_mixed_9: (+1)
   \       0xD6   0x4628             MOV      R0,R5
   \       0xD8   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xDC   0x.... 0x....      B.W      mbedtls_ecp_set_zero
   1681                      goto cleanup;
   1682                  }
   1683              }
   1684          
   1685              /* {P,Q}->Z no longer used, so OK to write to Z even if there's aliasing. */
   1686              MPI_ECP_MUL(Z,        &P->Z,    &tmp[0]);
   \                     ??ecp_add_mixed_8: (+1)
   \       0xE0   0x463B             MOV      R3,R7
   \       0xE2   0xF108 0x0210      ADD      R2,R8,#+16
   \       0xE6   0xF105 0x0110      ADD      R1,R5,#+16
   \       0xEA   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD152             BNE.N    ??ecp_add_mixed_6
   1687              MPI_ECP_SQR(&tmp[2],  &tmp[0]);
   \       0xF2   0x463B             MOV      R3,R7
   \       0xF4   0x463A             MOV      R2,R7
   \       0xF6   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD14C             BNE.N    ??ecp_add_mixed_6
   1688              MPI_ECP_MUL(&tmp[3],  &tmp[2],  &tmp[0]);
   \       0xFE   0x463B             MOV      R3,R7
   \      0x100   0xF107 0x0210      ADD      R2,R7,#+16
   \      0x104   0xF107 0x0118      ADD      R1,R7,#+24
   \      0x108   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_73: (+1)
   \      0x10C   0x2800             CMP      R0,#+0
   \      0x10E   0xD143             BNE.N    ??ecp_add_mixed_6
   1689              MPI_ECP_MUL(&tmp[2],  &tmp[2],  &P->X);
   \      0x110   0x4643             MOV      R3,R8
   \      0x112   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_81: (+1)
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD13E             BNE.N    ??ecp_add_mixed_6
   1690          
   1691              MPI_ECP_MOV(&tmp[0], &tmp[2]);
   \      0x11A   0xF107 0x0110      ADD      R1,R7,#+16
   \      0x11E   0x4638             MOV      R0,R7
   \      0x120   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x124   0x2800             CMP      R0,#+0
   \      0x126   0xD137             BNE.N    ??ecp_add_mixed_6
   1692              MPI_ECP_SHIFT_L(&tmp[0], 1);
   \      0x128   0x2201             MOVS     R2,#+1
   \      0x12A   0x4639             MOV      R1,R7
   \      0x12C   0x4620             MOV      R0,R4
   \      0x12E   0x.... 0x....      BL       mbedtls_mpi_shift_l_mod
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD130             BNE.N    ??ecp_add_mixed_6
   1693          
   1694              /* {P,Q}->X no longer used, so OK to write to X even if there's aliasing. */
   1695              MPI_ECP_SQR(X,        &tmp[1]);
   \      0x136   0xF107 0x0308      ADD      R3,R7,#+8
   \      0x13A   0xF107 0x0208      ADD      R2,R7,#+8
   \      0x13E   0x4629             MOV      R1,R5
   \      0x140   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_72: (+1)
   \      0x144   0xBB40             CBNZ.N   R0,??ecp_add_mixed_6
   1696              MPI_ECP_SUB(X,        X,        &tmp[0]);
   \      0x146   0x463B             MOV      R3,R7
   \      0x148   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x14C   0xBB20             CBNZ.N   R0,??ecp_add_mixed_6
   1697              MPI_ECP_SUB(X,        X,        &tmp[3]);
   \      0x14E   0xF107 0x0318      ADD      R3,R7,#+24
   \      0x152   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x156   0xB9F8             CBNZ.N   R0,??ecp_add_mixed_6
   1698              MPI_ECP_SUB(&tmp[2],  &tmp[2],  X);
   \      0x158   0x462B             MOV      R3,R5
   \      0x15A   0xF107 0x0210      ADD      R2,R7,#+16
   \      0x15E   0xF107 0x0110      ADD      R1,R7,#+16
   \      0x162   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \      0x166   0xB9B8             CBNZ.N   R0,??ecp_add_mixed_6
   1699              MPI_ECP_MUL(&tmp[2],  &tmp[2],  &tmp[1]);
   \      0x168   0xF107 0x0308      ADD      R3,R7,#+8
   \      0x16C   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_80: (+1)
   \      0x170   0xB990             CBNZ.N   R0,??ecp_add_mixed_6
   1700              MPI_ECP_MUL(&tmp[3],  &tmp[3],  &P->Y);
   \      0x172   0xF108 0x0308      ADD      R3,R8,#+8
   \      0x176   0xF107 0x0218      ADD      R2,R7,#+24
   \      0x17A   0xF107 0x0118      ADD      R1,R7,#+24
   \      0x17E   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_71: (+1)
   \      0x182   0xB948             CBNZ.N   R0,??ecp_add_mixed_6
   1701              /* {P,Q}->Y no longer used, so OK to write to Y even if there's aliasing. */
   1702              MPI_ECP_SUB(Y,     &tmp[2],     &tmp[3]);
   \      0x184   0xF107 0x0318      ADD      R3,R7,#+24
   \      0x188   0xF107 0x0210      ADD      R2,R7,#+16
   \      0x18C   0xF105 0x0108      ADD      R1,R5,#+8
   \      0x190   0x4620             MOV      R0,R4
   \      0x192   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x196   0x....             B.N      mbedtls_mpi_sub_mod
   1703          
   1704          cleanup:
   1705          
   1706              return ret;
   \                     ??ecp_add_mixed_6: (+1)
   \      0x198   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1707          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_ADD_MIXED_ALT) */
   1708          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x462A             MOV      R2,R5
   \        0x2   0x4629             MOV      R1,R5
   \                     ??Subroutine4_0: (+1)
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....             B.N      mbedtls_mpi_sub_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF107 0x0210      ADD      R2,R7,#+16
   \                     ??Subroutine2_0: (+1)
   \        0x4   0xF107 0x0110      ADD      R1,R7,#+16
   \        0x8                      REQUIRE ??Subroutine28_0
   \        0x8                      ;; // Fall through to label ??Subroutine28_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine28_0: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x....             B.N      mbedtls_mpi_mul_mod
   1709          
   1710          /*
   1711           * Randomize jacobian coordinates:
   1712           * (X, Y, Z) -> (l^2 X, l^3 Y, l Z) for random l
   1713           * This is sort of the reverse operation of ecp_normalize_jac().
   1714           *
   1715           * This countermeasure was first suggested in [2].
   1716           */

   \                                 In section .text, align 2, keep-with-next
   1717          static int ecp_randomize_jac(const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt,
   1718                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   1719          {
   \                     ecp_randomize_jac: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0x461C             MOV      R4,R3
   1720          #if defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT)
   1721              if (mbedtls_internal_ecp_grp_capable(grp)) {
   1722                  return mbedtls_internal_ecp_randomize_jac(grp, pt, f_rng, p_rng);
   1723              }
   1724          #endif /* MBEDTLS_ECP_RANDOMIZE_JAC_ALT */
   1725          
   1726          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT)
   1727              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   1728          #else
   1729              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1730              mbedtls_mpi l;
   1731          
   1732              mbedtls_mpi_init(&l);
   \        0xA   0xA801             ADD      R0,SP,#+4
   \        0xC   0x.... 0x....      BL       mbedtls_mpi_init
   1733          
   1734              /* Generate l such that 1 < l < p */
   1735              MPI_ECP_RAND(&l);
   \       0x10   0x9400             STR      R4,[SP, #+0]
   \       0x12   0x463B             MOV      R3,R7
   \       0x14   0x1D2A             ADDS     R2,R5,#+4
   \       0x16   0x2102             MOVS     R1,#+2
   \       0x18   0xA801             ADD      R0,SP,#+4
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_random
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0xD11D             BNE.N    ??ecp_randomize_jac_0
   1736          
   1737              /* Z' = l * Z */
   1738              MPI_ECP_MUL(&pt->Z,   &pt->Z,     &l);
   \       0x22   0xAB01             ADD      R3,SP,#+4
   \       0x24   0xF106 0x0210      ADD      R2,R6,#+16
   \       0x28   0xF106 0x0110      ADD      R1,R6,#+16
   \       0x2C   0x.... 0x....      BL       ??Subroutine29_0
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0x30   0x0004             MOVS     R4,R0
   \       0x32   0xD114             BNE.N    ??ecp_randomize_jac_0
   1739          
   1740              /* Y' = l * Y */
   1741              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   \       0x34   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x38   0x0004             MOVS     R4,R0
   \       0x3A   0xD110             BNE.N    ??ecp_randomize_jac_0
   1742          
   1743              /* X' = l^2 * X */
   1744              MPI_ECP_SQR(&l,       &l);
   \       0x3C   0xAB01             ADD      R3,SP,#+4
   \       0x3E   0xAA01             ADD      R2,SP,#+4
   \       0x40   0xA901             ADD      R1,SP,#+4
   \       0x42   0x.... 0x....      BL       ??Subroutine29_0
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x46   0x0004             MOVS     R4,R0
   \       0x48   0xD109             BNE.N    ??ecp_randomize_jac_0
   1745              MPI_ECP_MUL(&pt->X,   &pt->X,     &l);
   \       0x4A   0xAB01             ADD      R3,SP,#+4
   \       0x4C   0x4632             MOV      R2,R6
   \       0x4E   0x4631             MOV      R1,R6
   \       0x50   0x.... 0x....      BL       ??Subroutine29_0
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x54   0x0004             MOVS     R4,R0
   \       0x56   0xD102             BNE.N    ??ecp_randomize_jac_0
   1746          
   1747              /* Y'' = l^2 * Y' = l^3 * Y */
   1748              MPI_ECP_MUL(&pt->Y,   &pt->Y,     &l);
   \       0x58   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x5C   0x4604             MOV      R4,R0
   1749          
   1750          cleanup:
   1751              mbedtls_mpi_free(&l);
   \                     ??ecp_randomize_jac_0: (+1)
   \       0x5E   0xA801             ADD      R0,SP,#+4
   \       0x60   0x.... 0x....      BL       mbedtls_mpi_free
   1752          
   1753              if (ret == MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   \       0x64   0xF114 0x0F0E      CMN      R4,#+14
   \       0x68   0xBF08             IT       EQ
   \       0x6A   0x.... 0x....      LDREQ.W  R4,??DataTable22
   1754                  ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   1755              }
   1756              return ret;
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0xBDFE             POP      {R1-R7,PC}
   1757          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT) */
   1758          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xAB01             ADD      R3,SP,#+4
   \        0x2   0xF106 0x0208      ADD      R2,R6,#+8
   \        0x6   0xF106 0x0108      ADD      R1,R6,#+8
   \        0xA                      REQUIRE ??Subroutine29_0
   \        0xA                      ;; // Fall through to label ??Subroutine29_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine29_0: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x....             B.N      mbedtls_mpi_mul_mod
   1759          
   1760          /*
   1761           * Check and define parameters used by the comb method (see below for details)
   1762           */
   1763          #if MBEDTLS_ECP_WINDOW_SIZE < 2 || MBEDTLS_ECP_WINDOW_SIZE > 7
   1764          #error "MBEDTLS_ECP_WINDOW_SIZE out of bounds"
   1765          #endif
   1766          
   1767          /* d = ceil( n / w ) */
   1768          #define COMB_MAX_D      (MBEDTLS_ECP_MAX_BITS + 1) / 2
   1769          
   1770          /* number of precomputed points */
   1771          #define COMB_MAX_PRE    (1 << (MBEDTLS_ECP_WINDOW_SIZE - 1))
   1772          
   1773          /*
   1774           * Compute the representation of m that will be used with our comb method.
   1775           *
   1776           * The basic comb method is described in GECC 3.44 for example. We use a
   1777           * modified version that provides resistance to SPA by avoiding zero
   1778           * digits in the representation as in [3]. We modify the method further by
   1779           * requiring that all K_i be odd, which has the small cost that our
   1780           * representation uses one more K_i, due to carries, but saves on the size of
   1781           * the precomputed table.
   1782           *
   1783           * Summary of the comb method and its modifications:
   1784           *
   1785           * - The goal is to compute m*P for some w*d-bit integer m.
   1786           *
   1787           * - The basic comb method splits m into the w-bit integers
   1788           *   x[0] .. x[d-1] where x[i] consists of the bits in m whose
   1789           *   index has residue i modulo d, and computes m * P as
   1790           *   S[x[0]] + 2 * S[x[1]] + .. + 2^(d-1) S[x[d-1]], where
   1791           *   S[i_{w-1} .. i_0] := i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + i_0 P.
   1792           *
   1793           * - If it happens that, say, x[i+1]=0 (=> S[x[i+1]]=0), one can replace the sum by
   1794           *    .. + 2^{i-1} S[x[i-1]] - 2^i S[x[i]] + 2^{i+1} S[x[i]] + 2^{i+2} S[x[i+2]] ..,
   1795           *   thereby successively converting it into a form where all summands
   1796           *   are nonzero, at the cost of negative summands. This is the basic idea of [3].
   1797           *
   1798           * - More generally, even if x[i+1] != 0, we can first transform the sum as
   1799           *   .. - 2^i S[x[i]] + 2^{i+1} ( S[x[i]] + S[x[i+1]] ) + 2^{i+2} S[x[i+2]] ..,
   1800           *   and then replace S[x[i]] + S[x[i+1]] = S[x[i] ^ x[i+1]] + 2 S[x[i] & x[i+1]].
   1801           *   Performing and iterating this procedure for those x[i] that are even
   1802           *   (keeping track of carry), we can transform the original sum into one of the form
   1803           *   S[x'[0]] +- 2 S[x'[1]] +- .. +- 2^{d-1} S[x'[d-1]] + 2^d S[x'[d]]
   1804           *   with all x'[i] odd. It is therefore only necessary to know S at odd indices,
   1805           *   which is why we are only computing half of it in the first place in
   1806           *   ecp_precompute_comb and accessing it with index abs(i) / 2 in ecp_select_comb.
   1807           *
   1808           * - For the sake of compactness, only the seven low-order bits of x[i]
   1809           *   are used to represent its absolute value (K_i in the paper), and the msb
   1810           *   of x[i] encodes the sign (s_i in the paper): it is set if and only if
   1811           *   if s_i == -1;
   1812           *
   1813           * Calling conventions:
   1814           * - x is an array of size d + 1
   1815           * - w is the size, ie number of teeth, of the comb, and must be between
   1816           *   2 and 7 (in practice, between 2 and MBEDTLS_ECP_WINDOW_SIZE)
   1817           * - m is the MPI, expected to be odd and such that bitlength(m) <= w * d
   1818           *   (the result will be incorrect if these assumptions are not satisfied)
   1819           */
   1820          static void ecp_comb_recode_core(unsigned char x[], size_t d,
   1821                                           unsigned char w, const mbedtls_mpi *m)
   1822          {
   1823              size_t i, j;
   1824              unsigned char c, cc, adjust;
   1825          
   1826              memset(x, 0, d+1);
   1827          
   1828              /* First get the classical comb values (except for x_d = 0) */
   1829              for (i = 0; i < d; i++) {
   1830                  for (j = 0; j < w; j++) {
   1831                      x[i] |= mbedtls_mpi_get_bit(m, i + d * j) << j;
   1832                  }
   1833              }
   1834          
   1835              /* Now make sure x_1 .. x_d are odd */
   1836              c = 0;
   1837              for (i = 1; i <= d; i++) {
   1838                  /* Add carry and update it */
   1839                  cc   = x[i] & c;
   1840                  x[i] = x[i] ^ c;
   1841                  c = cc;
   1842          
   1843                  /* Adjust if needed, avoiding branches */
   1844                  adjust = 1 - (x[i] & 0x01);
   1845                  c   |= x[i] & (x[i-1] * adjust);
   1846                  x[i] = x[i] ^ (x[i-1] * adjust);
   1847                  x[i-1] |= adjust << 7;
   1848              }
   1849          }
   1850          
   1851          /*
   1852           * Precompute points for the adapted comb method
   1853           *
   1854           * Assumption: T must be able to hold 2^{w - 1} elements.
   1855           *
   1856           * Operation: If i = i_{w-1} ... i_1 is the binary representation of i,
   1857           *            sets T[i] = i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + P.
   1858           *
   1859           * Cost: d(w-1) D + (2^{w-1} - 1) A + 1 N(w-1) + 1 N(2^{w-1} - 1)
   1860           *
   1861           * Note: Even comb values (those where P would be omitted from the
   1862           *       sum defining T[i] above) are not needed in our adaption
   1863           *       the comb method. See ecp_comb_recode_core().
   1864           *
   1865           * This function currently works in four steps:
   1866           * (1) [dbl]      Computation of intermediate T[i] for 2-power values of i
   1867           * (2) [norm_dbl] Normalization of coordinates of these T[i]
   1868           * (3) [add]      Computation of all T[i]
   1869           * (4) [norm_add] Normalization of all T[i]
   1870           *
   1871           * Step 1 can be interrupted but not the others; together with the final
   1872           * coordinate normalization they are the largest steps done at once, depending
   1873           * on the window size. Here are operation counts for P-256:
   1874           *
   1875           * step     (2)     (3)     (4)
   1876           * w = 5    142     165     208
   1877           * w = 4    136      77     160
   1878           * w = 3    130      33     136
   1879           * w = 2    124      11     124
   1880           *
   1881           * So if ECC operations are blocking for too long even with a low max_ops
   1882           * value, it's useful to set MBEDTLS_ECP_WINDOW_SIZE to a lower value in order
   1883           * to minimize maximum blocking time.
   1884           */
   1885          static int ecp_precompute_comb(const mbedtls_ecp_group *grp,
   1886                                         mbedtls_ecp_point T[], const mbedtls_ecp_point *P,
   1887                                         unsigned char w, size_t d,
   1888                                         mbedtls_ecp_restart_ctx *rs_ctx)
   1889          {
   1890              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1891              unsigned char i;
   1892              size_t j = 0;
   1893              const unsigned char T_size = 1U << (w - 1);

   \                                 In section .rodata, align 4, keep-with-next
   1894              mbedtls_ecp_point *cur, *TT[COMB_MAX_PRE - 1] = { NULL };
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0x0
   1895          
   1896              mbedtls_mpi tmp[4];
   1897          
   1898              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   1899          
   1900          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1901              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1902                  if (rs_ctx->rsm->state == ecp_rsm_pre_dbl) {
   1903                      goto dbl;
   1904                  }
   1905                  if (rs_ctx->rsm->state == ecp_rsm_pre_norm_dbl) {
   1906                      goto norm_dbl;
   1907                  }
   1908                  if (rs_ctx->rsm->state == ecp_rsm_pre_add) {
   1909                      goto add;
   1910                  }
   1911                  if (rs_ctx->rsm->state == ecp_rsm_pre_norm_add) {
   1912                      goto norm_add;
   1913                  }
   1914              }
   1915          #else
   1916              (void) rs_ctx;
   1917          #endif
   1918          
   1919          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1920              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1921                  rs_ctx->rsm->state = ecp_rsm_pre_dbl;
   1922          
   1923                  /* initial state for the loop */
   1924                  rs_ctx->rsm->i = 0;
   1925              }
   1926          
   1927          dbl:
   1928          #endif
   1929              /*
   1930               * Set T[0] = P and
   1931               * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)
   1932               */
   1933              MBEDTLS_MPI_CHK(mbedtls_ecp_copy(&T[0], P));
   1934          
   1935          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1936              if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->i != 0) {
   1937                  j = rs_ctx->rsm->i;
   1938              } else
   1939          #endif
   1940              j = 0;
   1941          
   1942              for (; j < d * (w - 1); j++) {
   1943                  MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL);
   1944          
   1945                  i = 1U << (j / d);
   1946                  cur = T + i;
   1947          
   1948                  if (j % d == 0) {
   1949                      MBEDTLS_MPI_CHK(mbedtls_ecp_copy(cur, T + (i >> 1)));
   1950                  }
   1951          
   1952                  MBEDTLS_MPI_CHK(ecp_double_jac(grp, cur, cur, tmp));
   1953              }
   1954          
   1955          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1956              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1957                  rs_ctx->rsm->state = ecp_rsm_pre_norm_dbl;
   1958              }
   1959          
   1960          norm_dbl:
   1961          #endif
   1962              /*
   1963               * Normalize current elements in T to allow them to be used in
   1964               * ecp_add_mixed() below, which requires one normalized input.
   1965               *
   1966               * As T has holes, use an auxiliary array of pointers to elements in T.
   1967               *
   1968               */
   1969              j = 0;
   1970              for (i = 1; i < T_size; i <<= 1) {
   1971                  TT[j++] = T + i;
   1972              }
   1973          
   1974              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   1975          
   1976              MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   1977          
   1978          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1979              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   1980                  rs_ctx->rsm->state = ecp_rsm_pre_add;
   1981              }
   1982          
   1983          add:
   1984          #endif
   1985              /*
   1986               * Compute the remaining ones using the minimal number of additions
   1987               * Be careful to update T[2^l] only after using it!
   1988               */
   1989              MBEDTLS_ECP_BUDGET((T_size - 1) * MBEDTLS_ECP_OPS_ADD);
   1990          
   1991              for (i = 1; i < T_size; i <<= 1) {
   1992                  j = i;
   1993                  while (j--) {
   1994                      MBEDTLS_MPI_CHK(ecp_add_mixed(grp, &T[i + j], &T[j], &T[i], tmp));
   1995                  }
   1996              }
   1997          
   1998          #if defined(MBEDTLS_ECP_RESTARTABLE)
   1999              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2000                  rs_ctx->rsm->state = ecp_rsm_pre_norm_add;
   2001              }
   2002          
   2003          norm_add:
   2004          #endif
   2005              /*
   2006               * Normalize final elements in T. Even though there are no holes now, we
   2007               * still need the auxiliary array for homogeneity with the previous
   2008               * call. Also, skip T[0] which is already normalised, being a copy of P.
   2009               */
   2010              for (j = 0; j + 1 < T_size; j++) {
   2011                  TT[j] = T + j + 1;
   2012              }
   2013          
   2014              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV + 6 * j - 2);
   2015          
   2016              MBEDTLS_MPI_CHK(ecp_normalize_jac_many(grp, TT, j));
   2017          
   2018              /* Free Z coordinate (=1 after normalization) to save RAM.
   2019               * This makes T[i] invalid as mbedtls_ecp_points, but this is OK
   2020               * since from this point onwards, they are only accessed indirectly
   2021               * via the getter function ecp_select_comb() which does set the
   2022               * target's Z coordinate to 1. */
   2023              for (i = 0; i < T_size; i++) {
   2024                  mbedtls_mpi_free(&T[i].Z);
   2025              }
   2026          
   2027          cleanup:
   2028          
   2029              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2030          
   2031          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2032              if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   2033                  ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2034                  if (rs_ctx->rsm->state == ecp_rsm_pre_dbl) {
   2035                      rs_ctx->rsm->i = j;
   2036                  }
   2037              }
   2038          #endif
   2039          
   2040              return ret;
   2041          }
   2042          
   2043          /*
   2044           * Select precomputed point: R = sign(i) * T[ abs(i) / 2 ]
   2045           *
   2046           * See ecp_comb_recode_core() for background
   2047           */

   \                                 In section .text, align 2, keep-with-next
   2048          static int ecp_select_comb(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2049                                     const mbedtls_ecp_point T[], unsigned char T_size,
   2050                                     unsigned char i)
   2051          {
   \                     ecp_select_comb: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x9C0A             LDR      R4,[SP, #+40]
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x4699             MOV      R9,R3
   2052              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2053              unsigned char ii, j;
   2054          
   2055              /* Ignore the "sign" bit and scale down */
   2056              ii =  (i & 0x7Fu) >> 1;
   \        0xE   0xF3C4 0x0A45      UBFX     R10,R4,#+1,#+6
   2057          
   2058              /* Read the whole table to thwart cache-based timing attacks */
   2059              for (j = 0; j < T_size; j++) {
   \       0x12   0x2500             MOVS     R5,#+0
   \       0x14   0xE013             B.N      ??ecp_select_comb_0
   2060                  MPI_ECP_COND_ASSIGN(&R->X, &T[j].X, j == ii);
   \                     ??ecp_select_comb_1: (+1)
   \       0x16   0x2018             MOVS     R0,#+24
   \       0x18   0x4368             MULS     R0,R0,R5
   \       0x1A   0x1837             ADDS     R7,R6,R0
   \       0x1C   0x4639             MOV      R1,R7
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x24   0xB9F8             CBNZ.N   R0,??ecp_select_comb_2
   2061                  MPI_ECP_COND_ASSIGN(&R->Y, &T[j].Y, j == ii);
   \       0x26   0x4555             CMP      R5,R10
   \       0x28   0xBF14             ITE      NE
   \       0x2A   0x2200             MOVNE    R2,#+0
   \       0x2C   0x2201             MOVEQ    R2,#+1
   \       0x2E   0xF107 0x0108      ADD      R1,R7,#+8
   \       0x32   0xF108 0x0008      ADD      R0,R8,#+8
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x3A   0xB9A0             CBNZ.N   R0,??ecp_select_comb_2
   \       0x3C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ecp_select_comb_0: (+1)
   \       0x3E   0x454D             CMP      R5,R9
   \       0x40   0xDA04             BGE.N    ??ecp_select_comb_3
   \       0x42   0x4555             CMP      R5,R10
   \       0x44   0xBF0C             ITE      EQ
   \       0x46   0x2201             MOVEQ    R2,#+1
   \       0x48   0x2200             MOVNE    R2,#+0
   \       0x4A   0xE7E4             B.N      ??ecp_select_comb_1
   2062              }
   \                     ??ecp_select_comb_3: (+1)
   \       0x4C   0x4658             MOV      R0,R11
   2063          
   2064              /* Safely invert result if i is "negative" */
   2065              MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, R, i >> 7));
   \       0x4E   0x09E2             LSRS     R2,R4,#+7
   \       0x50   0x4641             MOV      R1,R8
   \       0x52   0x.... 0x....      BL       ecp_safe_invert_jac
   \       0x56   0xB930             CBNZ.N   R0,??ecp_select_comb_2
   2066          
   2067              MPI_ECP_LSET(&R->Z, 1);
   \       0x58   0xF108 0x0010      ADD      R0,R8,#+16
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \       0x62   0x.... 0x....      B.W      mbedtls_mpi_lset
   2068          
   2069          cleanup:
   2070              return ret;
   \                     ??ecp_select_comb_2: (+1)
   \       0x66   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2071          }
   2072          
   2073          /*
   2074           * Core multiplication algorithm for the (modified) comb method.
   2075           * This part is actually common with the basic comb method (GECC 3.44)
   2076           *
   2077           * Cost: d A + d D + 1 R
   2078           */
   2079          static int ecp_mul_comb_core(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2080                                       const mbedtls_ecp_point T[], unsigned char T_size,
   2081                                       const unsigned char x[], size_t d,
   2082                                       int (*f_rng)(void *, unsigned char *, size_t),
   2083                                       void *p_rng,
   2084                                       mbedtls_ecp_restart_ctx *rs_ctx)
   2085          {
   2086              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2087              mbedtls_ecp_point Txi;
   2088              mbedtls_mpi tmp[4];
   2089              size_t i;
   2090          
   2091              mbedtls_ecp_point_init(&Txi);
   2092              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2093          
   2094          #if !defined(MBEDTLS_ECP_RESTARTABLE)
   2095              (void) rs_ctx;
   2096          #endif
   2097          
   2098          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2099              if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   2100                  rs_ctx->rsm->state != ecp_rsm_comb_core) {
   2101                  rs_ctx->rsm->i = 0;
   2102                  rs_ctx->rsm->state = ecp_rsm_comb_core;
   2103              }
   2104          
   2105              /* new 'if' instead of nested for the sake of the 'else' branch */
   2106              if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->i != 0) {
   2107                  /* restore current index (R already pointing to rs_ctx->rsm->R) */
   2108                  i = rs_ctx->rsm->i;
   2109              } else
   2110          #endif
   2111              {
   2112                  /* Start with a non-zero point and randomize its coordinates */
   2113                  i = d;
   2114                  MBEDTLS_MPI_CHK(ecp_select_comb(grp, R, T, T_size, x[i]));
   2115                  if (f_rng != 0) {
   2116                      MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, R, f_rng, p_rng));
   2117                  }
   2118              }
   2119          
   2120              while (i != 0) {
   2121                  MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD);
   2122                  --i;
   2123          
   2124                  MBEDTLS_MPI_CHK(ecp_double_jac(grp, R, R, tmp));
   2125                  MBEDTLS_MPI_CHK(ecp_select_comb(grp, &Txi, T, T_size, x[i]));
   2126                  MBEDTLS_MPI_CHK(ecp_add_mixed(grp, R, R, &Txi, tmp));
   2127              }
   2128          
   2129          cleanup:
   2130          
   2131              mbedtls_ecp_point_free(&Txi);
   2132              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2133          
   2134          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2135              if (rs_ctx != NULL && rs_ctx->rsm != NULL &&
   2136                  ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2137                  rs_ctx->rsm->i = i;
   2138                  /* no need to save R, already pointing to rs_ctx->rsm->R */
   2139              }
   2140          #endif
   2141          
   2142              return ret;
   2143          }
   2144          
   2145          /*
   2146           * Recode the scalar to get constant-time comb multiplication
   2147           *
   2148           * As the actual scalar recoding needs an odd scalar as a starting point,
   2149           * this wrapper ensures that by replacing m by N - m if necessary, and
   2150           * informs the caller that the result of multiplication will be negated.
   2151           *
   2152           * This works because we only support large prime order for Short Weierstrass
   2153           * curves, so N is always odd hence either m or N - m is.
   2154           *
   2155           * See ecp_comb_recode_core() for background.
   2156           */
   2157          static int ecp_comb_recode_scalar(const mbedtls_ecp_group *grp,
   2158                                            const mbedtls_mpi *m,
   2159                                            unsigned char k[COMB_MAX_D + 1],
   2160                                            size_t d,
   2161                                            unsigned char w,
   2162                                            unsigned char *parity_trick)
   2163          {
   2164              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2165              mbedtls_mpi M, mm;
   2166          
   2167              mbedtls_mpi_init(&M);
   2168              mbedtls_mpi_init(&mm);
   2169          
   2170              /* N is always odd (see above), just make extra sure */
   2171              if (mbedtls_mpi_get_bit(&grp->N, 0) != 1) {
   2172                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2173              }
   2174          
   2175              /* do we need the parity trick? */
   2176              *parity_trick = (mbedtls_mpi_get_bit(m, 0) == 0);
   2177          
   2178              /* execute parity fix in constant time */
   2179              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&M, m));
   2180              MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&mm, &grp->N, m));
   2181              MBEDTLS_MPI_CHK(mbedtls_mpi_safe_cond_assign(&M, &mm, *parity_trick));
   2182          
   2183              /* actual scalar recoding */
   2184              ecp_comb_recode_core(k, d, w, &M);
   2185          
   2186          cleanup:
   2187              mbedtls_mpi_free(&mm);
   2188              mbedtls_mpi_free(&M);
   2189          
   2190              return ret;
   2191          }
   2192          
   2193          /*
   2194           * Perform comb multiplication (for short Weierstrass curves)
   2195           * once the auxiliary table has been pre-computed.
   2196           *
   2197           * Scalar recoding may use a parity trick that makes us compute -m * P,
   2198           * if that is the case we'll need to recover m * P at the end.
   2199           */
   2200          static int ecp_mul_comb_after_precomp(const mbedtls_ecp_group *grp,
   2201                                                mbedtls_ecp_point *R,
   2202                                                const mbedtls_mpi *m,
   2203                                                const mbedtls_ecp_point *T,
   2204                                                unsigned char T_size,
   2205                                                unsigned char w,
   2206                                                size_t d,
   2207                                                int (*f_rng)(void *, unsigned char *, size_t),
   2208                                                void *p_rng,
   2209                                                mbedtls_ecp_restart_ctx *rs_ctx)
   2210          {
   2211              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2212              unsigned char parity_trick;
   2213              unsigned char k[COMB_MAX_D + 1];
   2214              mbedtls_ecp_point *RR = R;
   2215          
   2216          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2217              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2218                  RR = &rs_ctx->rsm->R;
   2219          
   2220                  if (rs_ctx->rsm->state == ecp_rsm_final_norm) {
   2221                      goto final_norm;
   2222                  }
   2223              }
   2224          #endif
   2225          
   2226              MBEDTLS_MPI_CHK(ecp_comb_recode_scalar(grp, m, k, d, w,
   2227                                                     &parity_trick));
   2228              MBEDTLS_MPI_CHK(ecp_mul_comb_core(grp, RR, T, T_size, k, d,
   2229                                                f_rng, p_rng, rs_ctx));
   2230              MBEDTLS_MPI_CHK(ecp_safe_invert_jac(grp, RR, parity_trick));
   2231          
   2232          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2233              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2234                  rs_ctx->rsm->state = ecp_rsm_final_norm;
   2235              }
   2236          
   2237          final_norm:
   2238              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV);
   2239          #endif
   2240              /*
   2241               * Knowledge of the jacobian coordinates may leak the last few bits of the
   2242               * scalar [1], and since our MPI implementation isn't constant-flow,
   2243               * inversion (used for coordinate normalization) may leak the full value
   2244               * of its input via side-channels [2].
   2245               *
   2246               * [1] https://eprint.iacr.org/2003/191
   2247               * [2] https://eprint.iacr.org/2020/055
   2248               *
   2249               * Avoid the leak by randomizing coordinates before we normalize them.
   2250               */
   2251              if (f_rng != 0) {
   2252                  MBEDTLS_MPI_CHK(ecp_randomize_jac(grp, RR, f_rng, p_rng));
   2253              }
   2254          
   2255              MBEDTLS_MPI_CHK(ecp_normalize_jac(grp, RR));
   2256          
   2257          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2258              if (rs_ctx != NULL && rs_ctx->rsm != NULL) {
   2259                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, RR));
   2260              }
   2261          #endif
   2262          
   2263          cleanup:
   2264              return ret;
   2265          }
   2266          
   2267          /*
   2268           * Pick window size based on curve size and whether we optimize for base point
   2269           */
   2270          static unsigned char ecp_pick_window_size(const mbedtls_ecp_group *grp,
   2271                                                    unsigned char p_eq_g)
   2272          {
   2273              unsigned char w;
   2274          
   2275              /*
   2276               * Minimize the number of multiplications, that is minimize
   2277               * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )
   2278               * (see costs of the various parts, with 1S = 1M)
   2279               */
   2280              w = grp->nbits >= 384 ? 5 : 4;
   2281          
   2282              /*
   2283               * If P == G, pre-compute a bit more, since this may be re-used later.
   2284               * Just adding one avoids upping the cost of the first mul too much,
   2285               * and the memory cost too.
   2286               */
   2287              if (p_eq_g) {
   2288                  w++;
   2289              }
   2290          
   2291              /*
   2292               * If static comb table may not be used (!p_eq_g) or static comb table does
   2293               * not exists, make sure w is within bounds.
   2294               * (The last test is useful only for very small curves in the test suite.)
   2295               *
   2296               * The user reduces MBEDTLS_ECP_WINDOW_SIZE does not changes the size of
   2297               * static comb table, because the size of static comb table is fixed when
   2298               * it is generated.
   2299               */
   2300          #if (MBEDTLS_ECP_WINDOW_SIZE < 6)
   2301              if ((!p_eq_g || !ecp_group_is_static_comb_table(grp)) && w > MBEDTLS_ECP_WINDOW_SIZE) {
   2302                  w = MBEDTLS_ECP_WINDOW_SIZE;
   2303              }
   2304          #endif
   2305              if (w >= grp->nbits) {
   2306                  w = 2;
   2307              }
   2308          
   2309              return w;
   2310          }
   2311          
   2312          /*
   2313           * Multiplication using the comb method - for curves in short Weierstrass form
   2314           *
   2315           * This function is mainly responsible for administrative work:
   2316           * - managing the restart context if enabled
   2317           * - managing the table of precomputed points (passed between the below two
   2318           *   functions): allocation, computation, ownership transfer, freeing.
   2319           *
   2320           * It delegates the actual arithmetic work to:
   2321           *      ecp_precompute_comb() and ecp_mul_comb_with_precomp()
   2322           *
   2323           * See comments on ecp_comb_recode_core() regarding the computation strategy.
   2324           */
   2325          static int ecp_mul_comb(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2326                                  const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2327                                  int (*f_rng)(void *, unsigned char *, size_t),
   2328                                  void *p_rng,
   2329                                  mbedtls_ecp_restart_ctx *rs_ctx)
   2330          {
   2331              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2332              unsigned char w, p_eq_g, i;
   2333              size_t d;
   2334              unsigned char T_size = 0, T_ok = 0;
   2335              mbedtls_ecp_point *T = NULL;
   2336          
   2337              ECP_RS_ENTER(rsm);
   2338          
   2339              /* Is P the base point ? */
   2340          #if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
   2341              p_eq_g = (MPI_ECP_CMP(&P->Y, &grp->G.Y) == 0 &&
   2342                        MPI_ECP_CMP(&P->X, &grp->G.X) == 0);
   2343          #else
   2344              p_eq_g = 0;
   2345          #endif
   2346          
   2347              /* Pick window size and deduce related sizes */
   2348              w = ecp_pick_window_size(grp, p_eq_g);
   2349              T_size = 1U << (w - 1);
   2350              d = (grp->nbits + w - 1) / w;
   2351          
   2352              /* Pre-computed table: do we have it already for the base point? */
   2353              if (p_eq_g && grp->T != NULL) {
   2354                  /* second pointer to the same table, will be deleted on exit */
   2355                  T = grp->T;
   2356                  T_ok = 1;
   2357              } else
   2358          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2359              /* Pre-computed table: do we have one in progress? complete? */
   2360              if (rs_ctx != NULL && rs_ctx->rsm != NULL && rs_ctx->rsm->T != NULL) {
   2361                  /* transfer ownership of T from rsm to local function */
   2362                  T = rs_ctx->rsm->T;
   2363                  rs_ctx->rsm->T = NULL;
   2364                  rs_ctx->rsm->T_size = 0;
   2365          
   2366                  /* This effectively jumps to the call to mul_comb_after_precomp() */
   2367                  T_ok = rs_ctx->rsm->state >= ecp_rsm_comb_core;
   2368              } else
   2369          #endif
   2370              /* Allocate table if we didn't have any */
   2371              {
   2372                  T = mbedtls_calloc(T_size, sizeof(mbedtls_ecp_point));
   2373                  if (T == NULL) {
   2374                      ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
   2375                      goto cleanup;
   2376                  }
   2377          
   2378                  for (i = 0; i < T_size; i++) {
   2379                      mbedtls_ecp_point_init(&T[i]);
   2380                  }
   2381          
   2382                  T_ok = 0;
   2383              }
   2384          
   2385              /* Compute table (or finish computing it) if not done already */
   2386              if (!T_ok) {
   2387                  MBEDTLS_MPI_CHK(ecp_precompute_comb(grp, T, P, w, d, rs_ctx));
   2388          
   2389                  if (p_eq_g) {
   2390                      /* almost transfer ownership of T to the group, but keep a copy of
   2391                       * the pointer to use for calling the next function more easily */
   2392                      grp->T = T;
   2393                      grp->T_size = T_size;
   2394                  }
   2395              }
   2396          
   2397              /* Actual comb multiplication using precomputed points */
   2398              MBEDTLS_MPI_CHK(ecp_mul_comb_after_precomp(grp, R, m,
   2399                                                         T, T_size, w, d,
   2400                                                         f_rng, p_rng, rs_ctx));
   2401          
   2402          cleanup:
   2403          
   2404              /* does T belong to the group? */
   2405              if (T == grp->T) {
   2406                  T = NULL;
   2407              }
   2408          
   2409              /* does T belong to the restart context? */
   2410          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2411              if (rs_ctx != NULL && rs_ctx->rsm != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS && T != NULL) {
   2412                  /* transfer ownership of T from local function to rsm */
   2413                  rs_ctx->rsm->T_size = T_size;
   2414                  rs_ctx->rsm->T = T;
   2415                  T = NULL;
   2416              }
   2417          #endif
   2418          
   2419              /* did T belong to us? then let's destroy it! */
   2420              if (T != NULL) {
   2421                  for (i = 0; i < T_size; i++) {
   2422                      mbedtls_ecp_point_free(&T[i]);
   2423                  }
   2424                  mbedtls_free(T);
   2425              }
   2426          
   2427              /* prevent caller from using invalid value */
   2428              int should_free_R = (ret != 0);
   2429          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2430              /* don't free R while in progress in case R == P */
   2431              if (ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2432                  should_free_R = 0;
   2433              }
   2434          #endif
   2435              if (should_free_R) {
   2436                  mbedtls_ecp_point_free(R);
   2437              }
   2438          
   2439              ECP_RS_LEAVE(rsm);
   2440          
   2441              return ret;
   2442          }
   2443          
   2444          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   2445          
   2446          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   2447          /*
   2448           * For Montgomery curves, we do all the internal arithmetic in projective
   2449           * coordinates. Import/export of points uses only the x coordinates, which is
   2450           * internally represented as X / Z.
   2451           *
   2452           * For scalar multiplication, we'll use a Montgomery ladder.
   2453           */
   2454          
   2455          /*
   2456           * Normalize Montgomery x/z coordinates: X = X/Z, Z = 1
   2457           * Cost: 1M + 1I
   2458           */
   2459          static int ecp_normalize_mxz(const mbedtls_ecp_group *grp, mbedtls_ecp_point *P)
   2460          {
   2461          #if defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT)
   2462              if (mbedtls_internal_ecp_grp_capable(grp)) {
   2463                  return mbedtls_internal_ecp_normalize_mxz(grp, P);
   2464              }
   2465          #endif /* MBEDTLS_ECP_NORMALIZE_MXZ_ALT */
   2466          
   2467          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT)
   2468              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2469          #else
   2470              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2471              MPI_ECP_INV(&P->Z, &P->Z);
   2472              MPI_ECP_MUL(&P->X, &P->X, &P->Z);
   2473              MPI_ECP_LSET(&P->Z, 1);
   2474          
   2475          cleanup:
   2476              return ret;
   2477          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT) */
   2478          }
   2479          
   2480          /*
   2481           * Randomize projective x/z coordinates:
   2482           * (X, Z) -> (l X, l Z) for random l
   2483           * This is sort of the reverse operation of ecp_normalize_mxz().
   2484           *
   2485           * This countermeasure was first suggested in [2].
   2486           * Cost: 2M
   2487           */
   2488          static int ecp_randomize_mxz(const mbedtls_ecp_group *grp, mbedtls_ecp_point *P,
   2489                                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   2490          {
   2491          #if defined(MBEDTLS_ECP_RANDOMIZE_MXZ_ALT)
   2492              if (mbedtls_internal_ecp_grp_capable(grp)) {
   2493                  return mbedtls_internal_ecp_randomize_mxz(grp, P, f_rng, p_rng);
   2494              }
   2495          #endif /* MBEDTLS_ECP_RANDOMIZE_MXZ_ALT */
   2496          
   2497          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_RANDOMIZE_MXZ_ALT)
   2498              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2499          #else
   2500              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2501              mbedtls_mpi l;
   2502              mbedtls_mpi_init(&l);
   2503          
   2504              /* Generate l such that 1 < l < p */
   2505              MPI_ECP_RAND(&l);
   2506          
   2507              MPI_ECP_MUL(&P->X, &P->X, &l);
   2508              MPI_ECP_MUL(&P->Z, &P->Z, &l);
   2509          
   2510          cleanup:
   2511              mbedtls_mpi_free(&l);
   2512          
   2513              if (ret == MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) {
   2514                  ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
   2515              }
   2516              return ret;
   2517          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_RANDOMIZE_MXZ_ALT) */
   2518          }
   2519          
   2520          /*
   2521           * Double-and-add: R = 2P, S = P + Q, with d = X(P - Q),
   2522           * for Montgomery curves in x/z coordinates.
   2523           *
   2524           * http://www.hyperelliptic.org/EFD/g1p/auto-code/montgom/xz/ladder/mladd-1987-m.op3
   2525           * with
   2526           * d =  X1
   2527           * P = (X2, Z2)
   2528           * Q = (X3, Z3)
   2529           * R = (X4, Z4)
   2530           * S = (X5, Z5)
   2531           * and eliminating temporary variables tO, ..., t4.
   2532           *
   2533           * Cost: 5M + 4S
   2534           */
   2535          static int ecp_double_add_mxz(const mbedtls_ecp_group *grp,
   2536                                        mbedtls_ecp_point *R, mbedtls_ecp_point *S,
   2537                                        const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,
   2538                                        const mbedtls_mpi *d,
   2539                                        mbedtls_mpi T[4])
   2540          {
   2541          #if defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)
   2542              if (mbedtls_internal_ecp_grp_capable(grp)) {
   2543                  return mbedtls_internal_ecp_double_add_mxz(grp, R, S, P, Q, d);
   2544              }
   2545          #endif /* MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT */
   2546          
   2547          #if defined(MBEDTLS_ECP_NO_FALLBACK) && defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT)
   2548              return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   2549          #else
   2550              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2551          
   2552              MPI_ECP_ADD(&T[0], &P->X,   &P->Z);   /* Pp := PX + PZ                    */
   2553              MPI_ECP_SUB(&T[1], &P->X,   &P->Z);   /* Pm := PX - PZ                    */
   2554              MPI_ECP_ADD(&T[2], &Q->X,   &Q->Z);   /* Qp := QX + XZ                    */
   2555              MPI_ECP_SUB(&T[3], &Q->X,   &Q->Z);   /* Qm := QX - QZ                    */
   2556              MPI_ECP_MUL(&T[3], &T[3],   &T[0]);   /* Qm * Pp                          */
   2557              MPI_ECP_MUL(&T[2], &T[2],   &T[1]);   /* Qp * Pm                          */
   2558              MPI_ECP_SQR(&T[0], &T[0]);            /* Pp^2                             */
   2559              MPI_ECP_SQR(&T[1], &T[1]);            /* Pm^2                             */
   2560              MPI_ECP_MUL(&R->X, &T[0],   &T[1]);   /* Pp^2 * Pm^2                      */
   2561              MPI_ECP_SUB(&T[0], &T[0],   &T[1]);   /* Pp^2 - Pm^2                      */
   2562              MPI_ECP_MUL(&R->Z, &grp->A, &T[0]);   /* A * (Pp^2 - Pm^2)                */
   2563              MPI_ECP_ADD(&R->Z, &T[1],   &R->Z);   /* [ A * (Pp^2-Pm^2) ] + Pm^2       */
   2564              MPI_ECP_ADD(&S->X, &T[3],   &T[2]);   /* Qm*Pp + Qp*Pm                    */
   2565              MPI_ECP_SQR(&S->X, &S->X);            /* (Qm*Pp + Qp*Pm)^2                */
   2566              MPI_ECP_SUB(&S->Z, &T[3],   &T[2]);   /* Qm*Pp - Qp*Pm                    */
   2567              MPI_ECP_SQR(&S->Z, &S->Z);            /* (Qm*Pp - Qp*Pm)^2                */
   2568              MPI_ECP_MUL(&S->Z, d,       &S->Z);   /* d * ( Qm*Pp - Qp*Pm )^2          */
   2569              MPI_ECP_MUL(&R->Z, &T[0],   &R->Z);   /* [A*(Pp^2-Pm^2)+Pm^2]*(Pp^2-Pm^2) */
   2570          
   2571          cleanup:
   2572          
   2573              return ret;
   2574          #endif /* !defined(MBEDTLS_ECP_NO_FALLBACK) || !defined(MBEDTLS_ECP_DOUBLE_ADD_MXZ_ALT) */
   2575          }
   2576          
   2577          /*
   2578           * Multiplication with Montgomery ladder in x/z coordinates,
   2579           * for curves in Montgomery form
   2580           */
   2581          static int ecp_mul_mxz(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2582                                 const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2583                                 int (*f_rng)(void *, unsigned char *, size_t),
   2584                                 void *p_rng)
   2585          {
   2586              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2587              size_t i;
   2588              unsigned char b;
   2589              mbedtls_ecp_point RP;
   2590              mbedtls_mpi PX;
   2591              mbedtls_mpi tmp[4];
   2592              mbedtls_ecp_point_init(&RP); mbedtls_mpi_init(&PX);
   2593          
   2594              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2595          
   2596              if (f_rng == NULL) {
   2597                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2598              }
   2599          
   2600              /* Save PX and read from P before writing to R, in case P == R */
   2601              MPI_ECP_MOV(&PX, &P->X);
   2602              MBEDTLS_MPI_CHK(mbedtls_ecp_copy(&RP, P));
   2603          
   2604              /* Set R to zero in modified x/z coordinates */
   2605              MPI_ECP_LSET(&R->X, 1);
   2606              MPI_ECP_LSET(&R->Z, 0);
   2607              mbedtls_mpi_free(&R->Y);
   2608          
   2609              /* RP.X might be slightly larger than P, so reduce it */
   2610              MOD_ADD(&RP.X);
   2611          
   2612              /* Randomize coordinates of the starting point */
   2613              MBEDTLS_MPI_CHK(ecp_randomize_mxz(grp, &RP, f_rng, p_rng));
   2614          
   2615              /* Loop invariant: R = result so far, RP = R + P */
   2616              i = grp->nbits + 1; /* one past the (zero-based) required msb for private keys */
   2617              while (i-- > 0) {
   2618                  b = mbedtls_mpi_get_bit(m, i);
   2619                  /*
   2620                   *  if (b) R = 2R + P else R = 2R,
   2621                   * which is:
   2622                   *  if (b) double_add( RP, R, RP, R )
   2623                   *  else   double_add( R, RP, R, RP )
   2624                   * but using safe conditional swaps to avoid leaks
   2625                   */
   2626                  MPI_ECP_COND_SWAP(&R->X, &RP.X, b);
   2627                  MPI_ECP_COND_SWAP(&R->Z, &RP.Z, b);
   2628                  MBEDTLS_MPI_CHK(ecp_double_add_mxz(grp, R, &RP, R, &RP, &PX, tmp));
   2629                  MPI_ECP_COND_SWAP(&R->X, &RP.X, b);
   2630                  MPI_ECP_COND_SWAP(&R->Z, &RP.Z, b);
   2631              }
   2632          
   2633              /*
   2634               * Knowledge of the projective coordinates may leak the last few bits of the
   2635               * scalar [1], and since our MPI implementation isn't constant-flow,
   2636               * inversion (used for coordinate normalization) may leak the full value
   2637               * of its input via side-channels [2].
   2638               *
   2639               * [1] https://eprint.iacr.org/2003/191
   2640               * [2] https://eprint.iacr.org/2020/055
   2641               *
   2642               * Avoid the leak by randomizing coordinates before we normalize them.
   2643               */
   2644              MBEDTLS_MPI_CHK(ecp_randomize_mxz(grp, R, f_rng, p_rng));
   2645              MBEDTLS_MPI_CHK(ecp_normalize_mxz(grp, R));
   2646          
   2647          cleanup:
   2648              mbedtls_ecp_point_free(&RP); mbedtls_mpi_free(&PX);
   2649          
   2650              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   2651              return ret;
   2652          }
   2653          
   2654          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   2655          
   2656          /*
   2657           * Restartable multiplication R = m * P
   2658           *
   2659           * This internal function can be called without an RNG in case where we know
   2660           * the inputs are not sensitive.
   2661           */

   \                                 In section .text, align 2, keep-with-next
   2662          static int ecp_mul_restartable_internal(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2663                                                  const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2664                                                  int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   2665                                                  mbedtls_ecp_restart_ctx *rs_ctx)
   2666          {
   \                     ecp_mul_restartable_internal: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xB0B2             SUB      SP,SP,#+200
   \        0x8   0x4680             MOV      R8,R0
   \        0xA   0x461E             MOV      R6,R3
   2667              int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2668              int restarting = 0;
   2669          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2670              char is_grp_capable = 0;
   2671          #endif
   2672          
   2673          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2674              /* reset ops count for this call if top-level */
   2675              if (rs_ctx != NULL && rs_ctx->depth++ == 0) {
   2676                  rs_ctx->ops_done = 0;
   2677              }
   2678          #else
   2679              (void) rs_ctx;
   2680          #endif
   2681          
   2682          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2683              if ((is_grp_capable = mbedtls_internal_ecp_grp_capable(grp))) {
   2684                  MBEDTLS_MPI_CHK(mbedtls_internal_ecp_init(grp));
   2685              }
   2686          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2687          
   2688          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2689              restarting = (rs_ctx != NULL && rs_ctx->rsm != NULL);
   2690          #endif
   2691              /* skip argument check when restarting */
   2692              if (!restarting) {
   2693                  /* check_privkey is free */
   2694                  MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_CHK);
   2695          
   2696                  /* Common sanity checks */
   2697                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(grp, m));
   \        0xC   0x4611             MOV      R1,R2
   \        0xE   0x.... 0x....      BL       mbedtls_ecp_check_privkey
   \       0x12   0x0005             MOVS     R5,R0
   \       0x14   0xD10C             BNE.N    ??ecp_mul_restartable_internal_0
   2698                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x16   0x4631             MOV      R1,R6
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x.... 0x....      BL       mbedtls_ecp_check_pubkey
   \       0x1E   0x0005             MOVS     R5,R0
   \       0x20   0xD106             BNE.N    ??ecp_mul_restartable_internal_0
   2699              }
   2700          
   2701              ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   2702          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   2703              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   2704                  MBEDTLS_MPI_CHK(ecp_mul_mxz(grp, R, m, P, f_rng, p_rng));
   2705              }
   2706          #endif
   2707          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   2708              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x.... 0x....      LDR.W    R11,??DataTable22_1
   \       0x28   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x2C   0x465D             MOV      R5,R11
   \       0x2E   0x2801             CMP      R0,#+1
   \                     ??ecp_mul_restartable_internal_0: (+1)
   \       0x30   0xF040 0x8181      BNE.W    ??ecp_mul_restartable_internal_1
   \       0x34   0xF8D8 0x7040      LDR      R7,[R8, #+64]
   \       0x38   0x2118             MOVS     R1,#+24
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0x1C7F             ADDS     R7,R7,#+1
   \       0x3E   0x087F             LSRS     R7,R7,#+1
   \       0x40   0x.... 0x....      BL       sl_calloc
   \       0x44   0xEA5F 0x0900      MOVS     R9,R0
   \       0x48   0x9402             STR      R4,[SP, #+8]
   \       0x4A   0xBF08             IT       EQ
   \       0x4C   0x.... 0x....      LDREQ.W  R5,??DataTable20
   \       0x50   0xF000 0x816E      BEQ.W    ??ecp_mul_restartable_internal_2
   \       0x54   0x2500             MOVS     R5,#+0
   \       0x56   0xF04F 0x0A18      MOV      R10,#+24
   \                     ??ecp_mul_restartable_internal_3: (+1)
   \       0x5A   0xB2E8             UXTB     R0,R5
   \       0x5C   0xFB1A 0xF000      SMULBB   R0,R10,R0
   \       0x60   0x1C6D             ADDS     R5,R5,#+1
   \       0x62   0x4448             ADD      R0,R9,R0
   \       0x64   0x.... 0x....      BL       mbedtls_ecp_point_init
   \       0x68   0xB2E8             UXTB     R0,R5
   \       0x6A   0x2802             CMP      R0,#+2
   \       0x6C   0xDBF5             BLT.N    ??ecp_mul_restartable_internal_3
   \       0x6E   0x2500             MOVS     R5,#+0
   \       0x70   0xA801             ADD      R0,SP,#+4
   \       0x72   0x6005             STR      R5,[R0, #+0]
   \       0x74   0x2104             MOVS     R1,#+4
   \       0x76   0xA803             ADD      R0,SP,#+12
   \       0x78   0x.... 0x....      BL       mpi_init_many
   \       0x7C   0x4631             MOV      R1,R6
   \       0x7E   0x4648             MOV      R0,R9
   \       0x80   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x84   0x0006             MOVS     R6,R0
   \       0x86   0xD16F             BNE.N    ??ecp_mul_restartable_internal_4
   \       0x88   0xE01D             B.N      ??ecp_mul_restartable_internal_5
   \                     ??ecp_mul_restartable_internal_6: (+1)
   \       0x8A   0xFBB5 0xF0F7      UDIV     R0,R5,R7
   \       0x8E   0x2101             MOVS     R1,#+1
   \       0x90   0x4081             LSLS     R1,R1,R0
   \       0x92   0xB2C9             UXTB     R1,R1
   \       0x94   0xFB1A 0xF201      SMULBB   R2,R10,R1
   \       0x98   0xFB07 0x5010      MLS      R0,R7,R0,R5
   \       0x9C   0xEB09 0x0602      ADD      R6,R9,R2
   \       0xA0   0xB940             CBNZ.N   R0,??ecp_mul_restartable_internal_7
   \       0xA2   0x0849             LSRS     R1,R1,#+1
   \       0xA4   0xFB1A 0xF101      SMULBB   R1,R10,R1
   \       0xA8   0x4630             MOV      R0,R6
   \       0xAA   0x4449             ADD      R1,R9,R1
   \       0xAC   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD158             BNE.N    ??ecp_mul_restartable_internal_8
   \                     ??ecp_mul_restartable_internal_7: (+1)
   \       0xB4   0xAB03             ADD      R3,SP,#+12
   \       0xB6   0x4632             MOV      R2,R6
   \       0xB8   0x4631             MOV      R1,R6
   \       0xBA   0x4640             MOV      R0,R8
   \       0xBC   0x.... 0x....      BL       ecp_double_jac
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD150             BNE.N    ??ecp_mul_restartable_internal_8
   \       0xC4   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ecp_mul_restartable_internal_5: (+1)
   \       0xC6   0x42BD             CMP      R5,R7
   \       0xC8   0xD3DF             BCC.N    ??ecp_mul_restartable_internal_6
   \       0xCA   0x2200             MOVS     R2,#+0
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xAD01             ADD      R5,SP,#+4
   \                     ??ecp_mul_restartable_internal_9: (+1)
   \       0xD0   0xFB1A 0xF100      SMULBB   R1,R10,R0
   \       0xD4   0x0640             LSLS     R0,R0,#+25
   \       0xD6   0x0E00             LSRS     R0,R0,#+24
   \       0xD8   0x4449             ADD      R1,R9,R1
   \       0xDA   0xF845 0x1022      STR      R1,[R5, R2, LSL #+2]
   \       0xDE   0x1C52             ADDS     R2,R2,#+1
   \       0xE0   0x2802             CMP      R0,#+2
   \       0xE2   0xDBF5             BLT.N    ??ecp_mul_restartable_internal_9
   \       0xE4   0xA901             ADD      R1,SP,#+4
   \       0xE6   0x4640             MOV      R0,R8
   \       0xE8   0x.... 0x....      BL       ecp_normalize_jac_many
   \       0xEC   0x0006             MOVS     R6,R0
   \       0xEE   0xD13B             BNE.N    ??ecp_mul_restartable_internal_4
   \       0xF0   0x2601             MOVS     R6,#+1
   \                     ??ecp_mul_restartable_internal_10: (+1)
   \       0xF2   0x4634             MOV      R4,R6
   \                     ??ecp_mul_restartable_internal_11: (+1)
   \       0xF4   0x4620             MOV      R0,R4
   \       0xF6   0x1E44             SUBS     R4,R0,#+1
   \       0xF8   0xB1A0             CBZ.N    R0,??ecp_mul_restartable_internal_12
   \       0xFA   0xA803             ADD      R0,SP,#+12
   \       0xFC   0x9000             STR      R0,[SP, #+0]
   \       0xFE   0xFB1A 0xF006      SMULBB   R0,R10,R6
   \      0x102   0xEB09 0x0300      ADD      R3,R9,R0
   \      0x106   0xFB0A 0xF004      MUL      R0,R10,R4
   \      0x10A   0xEB09 0x0200      ADD      R2,R9,R0
   \      0x10E   0x19A0             ADDS     R0,R4,R6
   \      0x110   0xFB0A 0xF000      MUL      R0,R10,R0
   \      0x114   0xEB09 0x0100      ADD      R1,R9,R0
   \      0x118   0x4640             MOV      R0,R8
   \      0x11A   0x.... 0x....      BL       ecp_add_mixed
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD0E8             BEQ.N    ??ecp_mul_restartable_internal_11
   \      0x122   0xE020             B.N      ??ecp_mul_restartable_internal_8
   \                     ??ecp_mul_restartable_internal_12: (+1)
   \      0x124   0x0676             LSLS     R6,R6,#+25
   \      0x126   0x0E36             LSRS     R6,R6,#+24
   \      0x128   0x2E02             CMP      R6,#+2
   \      0x12A   0xDBE2             BLT.N    ??ecp_mul_restartable_internal_10
   \      0x12C   0x2200             MOVS     R2,#+0
   \      0x12E   0xE006             B.N      ??ecp_mul_restartable_internal_13
   \                     ??ecp_mul_restartable_internal_14: (+1)
   \      0x130   0xFB0A 0xF102      MUL      R1,R10,R2
   \      0x134   0x4449             ADD      R1,R9,R1
   \      0x136   0x3118             ADDS     R1,R1,#+24
   \      0x138   0xF845 0x1022      STR      R1,[R5, R2, LSL #+2]
   \      0x13C   0x4602             MOV      R2,R0
   \                     ??ecp_mul_restartable_internal_13: (+1)
   \      0x13E   0x1C50             ADDS     R0,R2,#+1
   \      0x140   0x2801             CMP      R0,#+1
   \      0x142   0xD9F5             BLS.N    ??ecp_mul_restartable_internal_14
   \      0x144   0xA901             ADD      R1,SP,#+4
   \      0x146   0x4640             MOV      R0,R8
   \      0x148   0x.... 0x....      BL       ecp_normalize_jac_many
   \      0x14C   0x0006             MOVS     R6,R0
   \      0x14E   0xD10B             BNE.N    ??ecp_mul_restartable_internal_4
   \      0x150   0x2500             MOVS     R5,#+0
   \                     ??ecp_mul_restartable_internal_15: (+1)
   \      0x152   0xFB0A 0xF005      MUL      R0,R10,R5
   \      0x156   0x1C6D             ADDS     R5,R5,#+1
   \      0x158   0x4448             ADD      R0,R9,R0
   \      0x15A   0x3010             ADDS     R0,R0,#+16
   \      0x15C   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x160   0x2D02             CMP      R5,#+2
   \      0x162   0xDBF6             BLT.N    ??ecp_mul_restartable_internal_15
   \      0x164   0xE000             B.N      ??ecp_mul_restartable_internal_4
   \                     ??ecp_mul_restartable_internal_8: (+1)
   \      0x166   0x4606             MOV      R6,R0
   \                     ??ecp_mul_restartable_internal_4: (+1)
   \      0x168   0x2104             MOVS     R1,#+4
   \      0x16A   0xA803             ADD      R0,SP,#+12
   \      0x16C   0x.... 0x....      BL       mpi_free_many
   \      0x170   0x0035             MOVS     R5,R6
   \      0x172   0xF040 0x80CA      BNE.W    ??ecp_mul_restartable_internal_16
   \      0x176   0xA803             ADD      R0,SP,#+12
   \      0x178   0x.... 0x....      BL       mbedtls_mpi_init
   \      0x17C   0xA805             ADD      R0,SP,#+20
   \      0x17E   0x.... 0x....      BL       mbedtls_mpi_init
   \      0x182   0x2100             MOVS     R1,#+0
   \      0x184   0xF108 0x0034      ADD      R0,R8,#+52
   \      0x188   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \      0x18C   0x2801             CMP      R0,#+1
   \      0x18E   0xBF18             IT       NE
   \      0x190   0x4658             MOVNE    R0,R11
   \      0x192   0xD165             BNE.N    ??ecp_mul_restartable_internal_17
   \      0x194   0x9832             LDR      R0,[SP, #+200]
   \      0x196   0x2100             MOVS     R1,#+0
   \      0x198   0xAD11             ADD      R5,SP,#+68
   \      0x19A   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \      0x19E   0x1E40             SUBS     R0,R0,#+1
   \      0x1A0   0x4180             SBCS     R0,R0,R0
   \      0x1A2   0x0FC0             LSRS     R0,R0,#+31
   \      0x1A4   0x9932             LDR      R1,[SP, #+200]
   \      0x1A6   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \      0x1AA   0xA803             ADD      R0,SP,#+12
   \      0x1AC   0x.... 0x....      BL       mbedtls_mpi_copy
   \      0x1B0   0x9000             STR      R0,[SP, #+0]
   \      0x1B2   0x2800             CMP      R0,#+0
   \      0x1B4   0xD14C             BNE.N    ??ecp_mul_restartable_internal_18
   \      0x1B6   0x9A32             LDR      R2,[SP, #+200]
   \      0x1B8   0xF108 0x0134      ADD      R1,R8,#+52
   \      0x1BC   0xA805             ADD      R0,SP,#+20
   \      0x1BE   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \      0x1C2   0x9000             STR      R0,[SP, #+0]
   \      0x1C4   0x2800             CMP      R0,#+0
   \      0x1C6   0xD143             BNE.N    ??ecp_mul_restartable_internal_18
   \      0x1C8   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \      0x1CC   0xA905             ADD      R1,SP,#+20
   \      0x1CE   0xA803             ADD      R0,SP,#+12
   \      0x1D0   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \      0x1D4   0x9000             STR      R0,[SP, #+0]
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD13A             BNE.N    ??ecp_mul_restartable_internal_18
   \      0x1DA   0x1C79             ADDS     R1,R7,#+1
   \      0x1DC   0xA811             ADD      R0,SP,#+68
   \      0x1DE   0x.... 0x....      BL       __aeabi_memclr4
   \      0x1E2   0xF04F 0x0B00      MOV      R11,#+0
   \      0x1E6   0xE010             B.N      ??ecp_mul_restartable_internal_19
   \                     ??ecp_mul_restartable_internal_20: (+1)
   \      0x1E8   0x2600             MOVS     R6,#+0
   \                     ??ecp_mul_restartable_internal_21: (+1)
   \      0x1EA   0xFB06 0xB107      MLA      R1,R6,R7,R11
   \      0x1EE   0xF815 0x400B      LDRB     R4,[R5, R11]
   \      0x1F2   0xA803             ADD      R0,SP,#+12
   \      0x1F4   0x.... 0x....      BL       mbedtls_mpi_get_bit
   \      0x1F8   0x40B0             LSLS     R0,R0,R6
   \      0x1FA   0x4304             ORRS     R4,R0,R4
   \      0x1FC   0x1C76             ADDS     R6,R6,#+1
   \      0x1FE   0xF805 0x400B      STRB     R4,[R5, R11]
   \      0x202   0x2E01             CMP      R6,#+1
   \      0x204   0xD9F1             BLS.N    ??ecp_mul_restartable_internal_21
   \      0x206   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??ecp_mul_restartable_internal_19: (+1)
   \      0x20A   0x45BB             CMP      R11,R7
   \      0x20C   0xD3EC             BCC.N    ??ecp_mul_restartable_internal_20
   \      0x20E   0x2100             MOVS     R1,#+0
   \      0x210   0x2001             MOVS     R0,#+1
   \      0x212   0xE01B             B.N      ??ecp_mul_restartable_internal_22
   \                     ??ecp_mul_restartable_internal_23: (+1)
   \      0x214   0x5C2B             LDRB     R3,[R5, R0]
   \      0x216   0xEA01 0x0203      AND      R2,R1,R3
   \      0x21A   0x404B             EORS     R3,R1,R3
   \      0x21C   0xA911             ADD      R1,SP,#+68
   \      0x21E   0x4401             ADD      R1,R1,R0
   \      0x220   0xF811 0x4C01      LDRB     R4,[R1, #-1]
   \      0x224   0xF003 0x0601      AND      R6,R3,#0x1
   \      0x228   0xF1C6 0x0601      RSB      R6,R6,#+1
   \      0x22C   0xFB16 0xFC04      SMULBB   R12,R6,R4
   \      0x230   0x542B             STRB     R3,[R5, R0]
   \      0x232   0xEA0C 0x0103      AND      R1,R12,R3
   \      0x236   0xEA8C 0x0303      EOR      R3,R12,R3
   \      0x23A   0x542B             STRB     R3,[R5, R0]
   \      0x23C   0x4311             ORRS     R1,R1,R2
   \      0x23E   0xEA44 0x13C6      ORR      R3,R4,R6, LSL #+7
   \      0x242   0xAA11             ADD      R2,SP,#+68
   \      0x244   0x4402             ADD      R2,R2,R0
   \      0x246   0xF802 0x3C01      STRB     R3,[R2, #-1]
   \      0x24A   0x1C40             ADDS     R0,R0,#+1
   \                     ??ecp_mul_restartable_internal_22: (+1)
   \      0x24C   0x4287             CMP      R7,R0
   \      0x24E   0xD2E1             BCS.N    ??ecp_mul_restartable_internal_23
   \                     ??ecp_mul_restartable_internal_18: (+1)
   \      0x250   0xA805             ADD      R0,SP,#+20
   \      0x252   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x256   0xA803             ADD      R0,SP,#+12
   \      0x258   0x.... 0x....      BL       mbedtls_mpi_free
   \      0x25C   0x9800             LDR      R0,[SP, #+0]
   \      0x25E   0x2800             CMP      R0,#+0
   \                     ??ecp_mul_restartable_internal_17: (+1)
   \      0x260   0xD152             BNE.N    ??ecp_mul_restartable_internal_24
   \      0x262   0xA803             ADD      R0,SP,#+12
   \      0x264   0x.... 0x....      BL       mbedtls_ecp_point_init
   \      0x268   0x2104             MOVS     R1,#+4
   \      0x26A   0xA809             ADD      R0,SP,#+36
   \      0x26C   0x.... 0x....      BL       mpi_init_many
   \      0x270   0x5DE8             LDRB     R0,[R5, R7]
   \      0x272   0x9902             LDR      R1,[SP, #+8]
   \      0x274   0x2302             MOVS     R3,#+2
   \      0x276   0x9000             STR      R0,[SP, #+0]
   \      0x278   0x464A             MOV      R2,R9
   \      0x27A   0x4640             MOV      R0,R8
   \      0x27C   0x.... 0x....      BL       ecp_select_comb
   \      0x280   0x9000             STR      R0,[SP, #+0]
   \      0x282   0x9E3C             LDR      R6,[SP, #+240]
   \      0x284   0xF8DD 0xB0F4      LDR      R11,[SP, #+244]
   \      0x288   0xBB28             CBNZ.N   R0,??ecp_mul_restartable_internal_25
   \      0x28A   0x0030             MOVS     R0,R6
   \      0x28C   0xD003             BEQ.N    ??ecp_mul_restartable_internal_26
   \      0x28E   0x.... 0x....      BL       ?Subroutine25
   \                     ??CrossCallReturnLabel_56: (+1)
   \      0x292   0x9000             STR      R0,[SP, #+0]
   \      0x294   0xB9F8             CBNZ.N   R0,??ecp_mul_restartable_internal_25
   \                     ??ecp_mul_restartable_internal_26: (+1)
   \      0x296   0x9C02             LDR      R4,[SP, #+8]
   \      0x298   0x9800             LDR      R0,[SP, #+0]
   \                     ??ecp_mul_restartable_internal_27: (+1)
   \      0x29A   0xB1D7             CBZ.N    R7,??ecp_mul_restartable_internal_28
   \      0x29C   0xAB09             ADD      R3,SP,#+36
   \      0x29E   0x4622             MOV      R2,R4
   \      0x2A0   0x4621             MOV      R1,R4
   \      0x2A2   0x4640             MOV      R0,R8
   \      0x2A4   0x1E7F             SUBS     R7,R7,#+1
   \      0x2A6   0x.... 0x....      BL       ecp_double_jac
   \      0x2AA   0xB990             CBNZ.N   R0,??ecp_mul_restartable_internal_28
   \      0x2AC   0x5DE8             LDRB     R0,[R5, R7]
   \      0x2AE   0x2302             MOVS     R3,#+2
   \      0x2B0   0x464A             MOV      R2,R9
   \      0x2B2   0x9000             STR      R0,[SP, #+0]
   \      0x2B4   0xA903             ADD      R1,SP,#+12
   \      0x2B6   0x4640             MOV      R0,R8
   \      0x2B8   0x.... 0x....      BL       ecp_select_comb
   \      0x2BC   0xB948             CBNZ.N   R0,??ecp_mul_restartable_internal_28
   \      0x2BE   0xA809             ADD      R0,SP,#+36
   \      0x2C0   0x9000             STR      R0,[SP, #+0]
   \      0x2C2   0xAB03             ADD      R3,SP,#+12
   \      0x2C4   0x4622             MOV      R2,R4
   \      0x2C6   0x4621             MOV      R1,R4
   \      0x2C8   0x4640             MOV      R0,R8
   \      0x2CA   0x.... 0x....      BL       ecp_add_mixed
   \      0x2CE   0x2800             CMP      R0,#+0
   \      0x2D0   0xD0E3             BEQ.N    ??ecp_mul_restartable_internal_27
   \                     ??ecp_mul_restartable_internal_28: (+1)
   \      0x2D2   0x9402             STR      R4,[SP, #+8]
   \      0x2D4   0x9000             STR      R0,[SP, #+0]
   \                     ??ecp_mul_restartable_internal_25: (+1)
   \      0x2D6   0xA803             ADD      R0,SP,#+12
   \      0x2D8   0x.... 0x....      BL       mbedtls_ecp_point_free
   \      0x2DC   0x2104             MOVS     R1,#+4
   \      0x2DE   0xA809             ADD      R0,SP,#+36
   \      0x2E0   0x.... 0x....      BL       mpi_free_many
   \      0x2E4   0x9800             LDR      R0,[SP, #+0]
   \      0x2E6   0xB978             CBNZ.N   R0,??ecp_mul_restartable_internal_24
   \      0x2E8   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \      0x2EC   0x9902             LDR      R1,[SP, #+8]
   \      0x2EE   0x4640             MOV      R0,R8
   \      0x2F0   0x.... 0x....      BL       ecp_safe_invert_jac
   \      0x2F4   0xB940             CBNZ.N   R0,??ecp_mul_restartable_internal_24
   \      0x2F6   0x0030             MOVS     R0,R6
   \      0x2F8   0xD002             BEQ.N    ??ecp_mul_restartable_internal_29
   \      0x2FA   0x.... 0x....      BL       ?Subroutine25
   \                     ??CrossCallReturnLabel_57: (+1)
   \      0x2FE   0xB918             CBNZ.N   R0,??ecp_mul_restartable_internal_24
   \                     ??ecp_mul_restartable_internal_29: (+1)
   \      0x300   0x9902             LDR      R1,[SP, #+8]
   \      0x302   0x4640             MOV      R0,R8
   \      0x304   0x.... 0x....      BL       ecp_normalize_jac
   \                     ??ecp_mul_restartable_internal_24: (+1)
   \      0x308   0x4605             MOV      R5,R0
   \                     ??ecp_mul_restartable_internal_16: (+1)
   \      0x30A   0xF8D8 0x0058      LDR      R0,[R8, #+88]
   \      0x30E   0x4581             CMP      R9,R0
   \      0x310   0xD00D             BEQ.N    ??ecp_mul_restartable_internal_30
   \      0x312   0x2600             MOVS     R6,#+0
   \                     ??ecp_mul_restartable_internal_31: (+1)
   \      0x314   0xB2F0             UXTB     R0,R6
   \      0x316   0xFB1A 0xF000      SMULBB   R0,R10,R0
   \      0x31A   0x1C76             ADDS     R6,R6,#+1
   \      0x31C   0x4448             ADD      R0,R9,R0
   \      0x31E   0x.... 0x....      BL       mbedtls_ecp_point_free
   \      0x322   0xB2F0             UXTB     R0,R6
   \      0x324   0x2802             CMP      R0,#+2
   \      0x326   0xDBF5             BLT.N    ??ecp_mul_restartable_internal_31
   \      0x328   0x4648             MOV      R0,R9
   \      0x32A   0x.... 0x....      BL       sl_free
   \                     ??ecp_mul_restartable_internal_30: (+1)
   \      0x32E   0xB115             CBZ.N    R5,??ecp_mul_restartable_internal_1
   \                     ??ecp_mul_restartable_internal_2: (+1)
   \      0x330   0x9802             LDR      R0,[SP, #+8]
   \      0x332   0x.... 0x....      BL       mbedtls_ecp_point_free
   2709                  MBEDTLS_MPI_CHK(ecp_mul_comb(grp, R, m, P, f_rng, p_rng, rs_ctx));
   2710              }
   2711          #endif
   2712          
   2713          cleanup:
   2714          
   2715          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2716              if (is_grp_capable) {
   2717                  mbedtls_internal_ecp_free(grp);
   2718              }
   2719          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2720          
   2721          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2722              if (rs_ctx != NULL) {
   2723                  rs_ctx->depth--;
   2724              }
   2725          #endif
   2726          
   2727              return ret;
   \                     ??ecp_mul_restartable_internal_1: (+1)
   \      0x336   0x4628             MOV      R0,R5
   \      0x338   0xB033             ADD      SP,SP,#+204
   \      0x33A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2728          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x9902             LDR      R1,[SP, #+8]
   \        0x2   0x465B             MOV      R3,R11
   \        0x4   0x4632             MOV      R2,R6
   \        0x6   0x4640             MOV      R0,R8
   \        0x8   0x....             B.N      ecp_randomize_jac
   2729          
   2730          /*
   2731           * Restartable multiplication R = m * P
   2732           */

   \                                 In section .text, align 2, keep-with-next
   2733          int mbedtls_ecp_mul_restartable(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2734                                          const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2735                                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
   2736                                          mbedtls_ecp_restart_ctx *rs_ctx)
   2737          {
   \                     mbedtls_ecp_mul_restartable: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x9C08             LDR      R4,[SP, #+32]
   2738              if (f_rng == NULL) {
   \        0x4   0x0025             MOVS     R5,R4
   \        0x6   0xBF08             IT       EQ
   \        0x8   0x.... 0x....      LDREQ.W  R0,??DataTable22_1
   2739                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \        0xC   0xD006             BEQ.N    ??mbedtls_ecp_mul_restartable_0
   2740              }
   2741          
   2742              return ecp_mul_restartable_internal(grp, R, m, P, f_rng, p_rng, rs_ctx);
   \        0xE   0x9E0A             LDR      R6,[SP, #+40]
   \       0x10   0x9D09             LDR      R5,[SP, #+36]
   \       0x12   0x9400             STR      R4,[SP, #+0]
   \       0x14   0x9602             STR      R6,[SP, #+8]
   \       0x16   0x9501             STR      R5,[SP, #+4]
   \       0x18   0x.... 0x....      BL       ecp_mul_restartable_internal
   \                     ??mbedtls_ecp_mul_restartable_0: (+1)
   \       0x1C   0xB004             ADD      SP,SP,#+16
   \       0x1E   0xBD70             POP      {R4-R6,PC}
   2743          }
   2744          
   2745          /*
   2746           * Multiplication R = m * P
   2747           */

   \                                 In section .text, align 2, keep-with-next
   2748          int mbedtls_ecp_mul(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2749                              const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2750                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   2751          {
   \                     mbedtls_ecp_mul: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   2752              return mbedtls_ecp_mul_restartable(grp, R, m, P, f_rng, p_rng, NULL);
   \        0x2   0x.... 0x....      BL       ?Subroutine24
   \                     ??CrossCallReturnLabel_54: (+1)
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_mul_restartable
   \        0xA   0xBD3E             POP      {R1-R5,PC}
   2753          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0x2400             MOVS     R4,#+0
   \        0x2   0x9402             STR      R4,[SP, #+8]
   \        0x4   0x9D07             LDR      R5,[SP, #+28]
   \        0x6   0x9C06             LDR      R4,[SP, #+24]
   \        0x8   0x9501             STR      R5,[SP, #+4]
   \        0xA   0x9400             STR      R4,[SP, #+0]
   \        0xC   0x4770             BX       LR
   2754          #endif /* MBEDTLS_ECP_C */
   2755          
   2756          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   2757          /*
   2758           * Check that an affine point is valid as a public key,
   2759           * short weierstrass curves (SEC1 3.2.3.1)
   2760           */
   2761          static int ecp_check_pubkey_sw(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt)
   2762          {
   2763              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2764              mbedtls_mpi YY, RHS;
   2765          
   2766              /* pt coordinates must be normalized for our checks */
   2767              if (mbedtls_mpi_cmp_int(&pt->X, 0) < 0 ||
   2768                  mbedtls_mpi_cmp_int(&pt->Y, 0) < 0 ||
   2769                  mbedtls_mpi_cmp_mpi(&pt->X, &grp->P) >= 0 ||
   2770                  mbedtls_mpi_cmp_mpi(&pt->Y, &grp->P) >= 0) {
   2771                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   2772              }
   2773          
   2774              mbedtls_mpi_init(&YY); mbedtls_mpi_init(&RHS);
   2775          
   2776              /*
   2777               * YY = Y^2
   2778               * RHS = X^3 + A X + B
   2779               */
   2780              MPI_ECP_SQR(&YY,  &pt->Y);
   2781              MBEDTLS_MPI_CHK(ecp_sw_rhs(grp, &RHS, &pt->X));
   2782          
   2783              if (MPI_ECP_CMP(&YY, &RHS) != 0) {
   2784                  ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   2785              }
   2786          
   2787          cleanup:
   2788          
   2789              mbedtls_mpi_free(&YY); mbedtls_mpi_free(&RHS);
   2790          
   2791              return ret;
   2792          }
   2793          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   2794          
   2795          #if defined(MBEDTLS_ECP_C)
   2796          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   2797          /*
   2798           * R = m * P with shortcuts for m == 0, m == 1 and m == -1
   2799           * NOT constant-time - ONLY for short Weierstrass!
   2800           */

   \                                 In section .text, align 2, keep-with-next
   2801          static int mbedtls_ecp_mul_shortcuts(mbedtls_ecp_group *grp,
   2802                                               mbedtls_ecp_point *R,
   2803                                               const mbedtls_mpi *m,
   2804                                               const mbedtls_ecp_point *P,
   2805                                               mbedtls_ecp_restart_ctx *rs_ctx)
   2806          {
   \                     mbedtls_ecp_mul_shortcuts: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461F             MOV      R7,R3
   2807              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2808              mbedtls_mpi tmp;
   2809              mbedtls_mpi_init(&tmp);
   \        0xC   0xA803             ADD      R0,SP,#+12
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_init
   2810          
   2811              if (mbedtls_mpi_cmp_int(m, 0) == 0) {
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x18   0xB938             CBNZ.N   R0,??mbedtls_ecp_mul_shortcuts_0
   2812                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x1A   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0xD141             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2813                  MBEDTLS_MPI_CHK(mbedtls_ecp_set_zero(R));
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x.... 0x....      BL       mbedtls_ecp_set_zero
   \       0x28   0xE03C             B.N      ??mbedtls_ecp_mul_shortcuts_2
   2814              } else if (mbedtls_mpi_cmp_int(m, 1) == 0) {
   \                     ??mbedtls_ecp_mul_shortcuts_0: (+1)
   \       0x2A   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x2E   0xB940             CBNZ.N   R0,??mbedtls_ecp_mul_shortcuts_3
   2815                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x30   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x34   0x0004             MOVS     R4,R0
   \       0x36   0xD136             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2816                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, P));
   \       0x38   0x4639             MOV      R1,R7
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x40   0xE030             B.N      ??mbedtls_ecp_mul_shortcuts_2
   2817              } else if (mbedtls_mpi_cmp_int(m, -1) == 0) {
   \                     ??mbedtls_ecp_mul_shortcuts_3: (+1)
   \       0x42   0xF04F 0x31FF      MOV      R1,#+4294967295
   \       0x46   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x4A   0xBB00             CBNZ.N   R0,??mbedtls_ecp_mul_shortcuts_4
   2818                  MBEDTLS_MPI_CHK(mbedtls_ecp_check_pubkey(grp, P));
   \       0x4C   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x50   0x0004             MOVS     R4,R0
   \       0x52   0xD128             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2819                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, P));
   \       0x54   0x4639             MOV      R1,R7
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x.... 0x....      BL       mbedtls_ecp_copy
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0xD122             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   2820                  MPI_ECP_NEG(&R->Y);
   \       0x60   0x2100             MOVS     R1,#+0
   \       0x62   0xF106 0x0008      ADD      R0,R6,#+8
   \       0x66   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x6A   0x0007             MOVS     R7,R0
   \       0x6C   0xBF18             IT       NE
   \       0x6E   0x2701             MOVNE    R7,#+1
   \       0x70   0xF106 0x0208      ADD      R2,R6,#+8
   \       0x74   0x1D29             ADDS     R1,R5,#+4
   \       0x76   0xA803             ADD      R0,SP,#+12
   \       0x78   0x.... 0x....      BL       mbedtls_mpi_sub_mpi
   \       0x7C   0x0004             MOVS     R4,R0
   \       0x7E   0xD112             BNE.N    ??mbedtls_ecp_mul_shortcuts_1
   \       0x80   0xB2FA             UXTB     R2,R7
   \       0x82   0xA903             ADD      R1,SP,#+12
   \       0x84   0xF106 0x0008      ADD      R0,R6,#+8
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_safe_cond_assign
   \       0x8C   0xE00A             B.N      ??mbedtls_ecp_mul_shortcuts_2
   2821              } else {
   2822                  MBEDTLS_MPI_CHK(ecp_mul_restartable_internal(grp, R, m, P,
   2823                                                               NULL, NULL, rs_ctx));
   \                     ??mbedtls_ecp_mul_shortcuts_4: (+1)
   \       0x8E   0x9A0A             LDR      R2,[SP, #+40]
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0x9101             STR      R1,[SP, #+4]
   \       0x94   0x9202             STR      R2,[SP, #+8]
   \       0x96   0x9100             STR      R1,[SP, #+0]
   \       0x98   0x463B             MOV      R3,R7
   \       0x9A   0x4622             MOV      R2,R4
   \       0x9C   0x4631             MOV      R1,R6
   \       0x9E   0x4628             MOV      R0,R5
   \       0xA0   0x.... 0x....      BL       ecp_mul_restartable_internal
   \                     ??mbedtls_ecp_mul_shortcuts_2: (+1)
   \       0xA4   0x4604             MOV      R4,R0
   2824              }
   2825          
   2826          cleanup:
   2827              mbedtls_mpi_free(&tmp);
   \                     ??mbedtls_ecp_mul_shortcuts_1: (+1)
   \       0xA6   0xA803             ADD      R0,SP,#+12
   \       0xA8   0x.... 0x....      BL       mbedtls_mpi_free
   2828          
   2829              return ret;
   \       0xAC   0x4620             MOV      R0,R4
   \       0xAE   0xB005             ADD      SP,SP,#+20
   \       0xB0   0xBDF0             POP      {R4-R7,PC}
   2830          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x4639             MOV      R1,R7
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....             B.N      mbedtls_ecp_check_pubkey

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \                     ??Subroutine5_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      mbedtls_mpi_cmp_int
   2831          
   2832          /*
   2833           * Restartable linear combination
   2834           * NOT constant-time
   2835           */

   \                                 In section .text, align 2, keep-with-next
   2836          int mbedtls_ecp_muladd_restartable(
   2837              mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2838              const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2839              const mbedtls_mpi *n, const mbedtls_ecp_point *Q,
   2840              mbedtls_ecp_restart_ctx *rs_ctx)
   2841          {
   \                     mbedtls_ecp_muladd_restartable: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x461C             MOV      R4,R3
   2842              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2843              mbedtls_ecp_point mP;
   2844              mbedtls_ecp_point *pmP = &mP;
   2845              mbedtls_ecp_point *pR = R;
   2846              mbedtls_mpi tmp[4];
   2847          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2848              char is_grp_capable = 0;
   2849          #endif
   2850              if (mbedtls_ecp_get_type(grp) != MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0xE   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xBF18             IT       NE
   \       0x16   0x.... 0x....      LDRNE.W  R0,??DataTable22_2
   2851                  return MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   \       0x1A   0xD130             BNE.N    ??mbedtls_ecp_muladd_restartable_0
   \       0x1C   0x9F18             LDR      R7,[SP, #+96]
   2852              }
   2853          
   2854              mbedtls_ecp_point_init(&mP);
   \       0x1E   0xA809             ADD      R0,SP,#+36
   \       0x20   0x.... 0x....      BL       mbedtls_ecp_point_init
   2855              mpi_init_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \       0x24   0x2104             MOVS     R1,#+4
   \       0x26   0xA801             ADD      R0,SP,#+4
   \       0x28   0x.... 0x....      BL       mpi_init_many
   2856          
   2857              ECP_RS_ENTER(ma);
   2858          
   2859          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2860              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2861                  /* redirect intermediate results to restart context */
   2862                  pmP = &rs_ctx->ma->mP;
   2863                  pR  = &rs_ctx->ma->R;
   2864          
   2865                  /* jump to next operation */
   2866                  if (rs_ctx->ma->state == ecp_rsma_mul2) {
   2867                      goto mul2;
   2868                  }
   2869                  if (rs_ctx->ma->state == ecp_rsma_add) {
   2870                      goto add;
   2871                  }
   2872                  if (rs_ctx->ma->state == ecp_rsma_norm) {
   2873                      goto norm;
   2874                  }
   2875              }
   2876          #endif /* MBEDTLS_ECP_RESTARTABLE */
   2877          
   2878              MBEDTLS_MPI_CHK(mbedtls_ecp_mul_shortcuts(grp, pmP, m, P, rs_ctx));
   \       0x2C   0x9700             STR      R7,[SP, #+0]
   \       0x2E   0x4623             MOV      R3,R4
   \       0x30   0x4642             MOV      R2,R8
   \       0x32   0xA909             ADD      R1,SP,#+36
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       mbedtls_ecp_mul_shortcuts
   \       0x3A   0x0004             MOVS     R4,R0
   \       0x3C   0xD117             BNE.N    ??mbedtls_ecp_muladd_restartable_1
   \       0x3E   0x9B17             LDR      R3,[SP, #+92]
   \       0x40   0x9A16             LDR      R2,[SP, #+88]
   2879          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2880              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2881                  rs_ctx->ma->state = ecp_rsma_mul2;
   2882              }
   2883          
   2884          mul2:
   2885          #endif
   2886              MBEDTLS_MPI_CHK(mbedtls_ecp_mul_shortcuts(grp, pR,  n, Q, rs_ctx));
   \       0x42   0x9700             STR      R7,[SP, #+0]
   \       0x44   0x4631             MOV      R1,R6
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x.... 0x....      BL       mbedtls_ecp_mul_shortcuts
   \       0x4C   0x0004             MOVS     R4,R0
   \       0x4E   0xD10E             BNE.N    ??mbedtls_ecp_muladd_restartable_1
   2887          
   2888          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2889              if ((is_grp_capable = mbedtls_internal_ecp_grp_capable(grp))) {
   2890                  MBEDTLS_MPI_CHK(mbedtls_internal_ecp_init(grp));
   2891              }
   2892          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2893          
   2894          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2895              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2896                  rs_ctx->ma->state = ecp_rsma_add;
   2897              }
   2898          
   2899          add:
   2900          #endif
   2901              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_ADD);
   2902              MBEDTLS_MPI_CHK(ecp_add_mixed(grp, pR, pmP, pR, tmp));
   \       0x50   0xA801             ADD      R0,SP,#+4
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x4633             MOV      R3,R6
   \       0x56   0xAA09             ADD      R2,SP,#+36
   \       0x58   0x4631             MOV      R1,R6
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x.... 0x....      BL       ecp_add_mixed
   \       0x60   0x0004             MOVS     R4,R0
   \       0x62   0xD104             BNE.N    ??mbedtls_ecp_muladd_restartable_1
   2903          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2904              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2905                  rs_ctx->ma->state = ecp_rsma_norm;
   2906              }
   2907          
   2908          norm:
   2909          #endif
   2910              MBEDTLS_ECP_BUDGET(MBEDTLS_ECP_OPS_INV);
   2911              MBEDTLS_MPI_CHK(ecp_normalize_jac(grp, pR));
   \       0x64   0x4631             MOV      R1,R6
   \       0x66   0x4628             MOV      R0,R5
   \       0x68   0x.... 0x....      BL       ecp_normalize_jac
   \       0x6C   0x4604             MOV      R4,R0
   2912          
   2913          #if defined(MBEDTLS_ECP_RESTARTABLE)
   2914              if (rs_ctx != NULL && rs_ctx->ma != NULL) {
   2915                  MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, pR));
   2916              }
   2917          #endif
   2918          
   2919          cleanup:
   2920          
   2921              mpi_free_many(tmp, sizeof(tmp) / sizeof(mbedtls_mpi));
   \                     ??mbedtls_ecp_muladd_restartable_1: (+1)
   \       0x6E   0x2104             MOVS     R1,#+4
   \       0x70   0xA801             ADD      R0,SP,#+4
   \       0x72   0x.... 0x....      BL       mpi_free_many
   2922          
   2923          #if defined(MBEDTLS_ECP_INTERNAL_ALT)
   2924              if (is_grp_capable) {
   2925                  mbedtls_internal_ecp_free(grp);
   2926              }
   2927          #endif /* MBEDTLS_ECP_INTERNAL_ALT */
   2928          
   2929              mbedtls_ecp_point_free(&mP);
   \       0x76   0xA809             ADD      R0,SP,#+36
   \       0x78   0x.... 0x....      BL       mbedtls_ecp_point_free
   2930          
   2931              ECP_RS_LEAVE(ma);
   2932          
   2933              return ret;
   \       0x7C   0x4620             MOV      R0,R4
   \                     ??mbedtls_ecp_muladd_restartable_0: (+1)
   \       0x7E   0xB010             ADD      SP,SP,#+64
   \       0x80   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2934          }
   2935          
   2936          /*
   2937           * Linear combination
   2938           * NOT constant-time
   2939           */

   \                                 In section .text, align 2, keep-with-next
   2940          int mbedtls_ecp_muladd(mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
   2941                                 const mbedtls_mpi *m, const mbedtls_ecp_point *P,
   2942                                 const mbedtls_mpi *n, const mbedtls_ecp_point *Q)
   2943          {
   \                     mbedtls_ecp_muladd: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   2944              return mbedtls_ecp_muladd_restartable(grp, R, m, P, n, Q, NULL);
   \        0x2   0x.... 0x....      BL       ?Subroutine24
   \                     ??CrossCallReturnLabel_55: (+1)
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_muladd_restartable
   \        0xA   0xBD3E             POP      {R1-R5,PC}
   2945          }
   2946          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   2947          #endif /* MBEDTLS_ECP_C */
   2948          
   2949          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   2950          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   2951          #define ECP_MPI_INIT(_p, _n) { .p = (mbedtls_mpi_uint *) (_p), .s = 1, .n = (_n) }
   2952          #define ECP_MPI_INIT_ARRAY(x)   \
   2953              ECP_MPI_INIT(x, sizeof(x) / sizeof(mbedtls_mpi_uint))
   2954          /*
   2955           * Constants for the two points other than 0, 1, -1 (mod p) in
   2956           * https://cr.yp.to/ecdh.html#validate
   2957           * See ecp_check_pubkey_x25519().
   2958           */
   2959          static const mbedtls_mpi_uint x25519_bad_point_1[] = {
   2960              MBEDTLS_BYTES_TO_T_UINT_8(0xe0, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae),
   2961              MBEDTLS_BYTES_TO_T_UINT_8(0x16, 0x56, 0xe3, 0xfa, 0xf1, 0x9f, 0xc4, 0x6a),
   2962              MBEDTLS_BYTES_TO_T_UINT_8(0xda, 0x09, 0x8d, 0xeb, 0x9c, 0x32, 0xb1, 0xfd),
   2963              MBEDTLS_BYTES_TO_T_UINT_8(0x86, 0x62, 0x05, 0x16, 0x5f, 0x49, 0xb8, 0x00),
   2964          };
   2965          static const mbedtls_mpi_uint x25519_bad_point_2[] = {
   2966              MBEDTLS_BYTES_TO_T_UINT_8(0x5f, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24),
   2967              MBEDTLS_BYTES_TO_T_UINT_8(0xb1, 0xd0, 0xb1, 0x55, 0x9c, 0x83, 0xef, 0x5b),
   2968              MBEDTLS_BYTES_TO_T_UINT_8(0x04, 0x44, 0x5c, 0xc4, 0x58, 0x1c, 0x8e, 0x86),
   2969              MBEDTLS_BYTES_TO_T_UINT_8(0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0x57),
   2970          };
   2971          static const mbedtls_mpi ecp_x25519_bad_point_1 = ECP_MPI_INIT_ARRAY(
   2972              x25519_bad_point_1);
   2973          static const mbedtls_mpi ecp_x25519_bad_point_2 = ECP_MPI_INIT_ARRAY(
   2974              x25519_bad_point_2);
   2975          #endif /* MBEDTLS_ECP_DP_CURVE25519_ENABLED */
   2976          
   2977          /*
   2978           * Check that the input point is not one of the low-order points.
   2979           * This is recommended by the "May the Fourth" paper:
   2980           * https://eprint.iacr.org/2017/806.pdf
   2981           * Those points are never sent by an honest peer.
   2982           */
   2983          static int ecp_check_bad_points_mx(const mbedtls_mpi *X, const mbedtls_mpi *P,
   2984                                             const mbedtls_ecp_group_id grp_id)
   2985          {
   2986              int ret;
   2987              mbedtls_mpi XmP;
   2988          
   2989              mbedtls_mpi_init(&XmP);
   2990          
   2991              /* Reduce X mod P so that we only need to check values less than P.
   2992               * We know X < 2^256 so we can proceed by subtraction. */
   2993              MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&XmP, X));
   2994              while (mbedtls_mpi_cmp_mpi(&XmP, P) >= 0) {
   2995                  MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&XmP, &XmP, P));
   2996              }
   2997          
   2998              /* Check against the known bad values that are less than P. For Curve448
   2999               * these are 0, 1 and -1. For Curve25519 we check the values less than P
   3000               * from the following list: https://cr.yp.to/ecdh.html#validate */
   3001              if (mbedtls_mpi_cmp_int(&XmP, 1) <= 0) {  /* takes care of 0 and 1 */
   3002                  ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3003                  goto cleanup;
   3004              }
   3005          
   3006          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   3007              if (grp_id == MBEDTLS_ECP_DP_CURVE25519) {
   3008                  if (mbedtls_mpi_cmp_mpi(&XmP, &ecp_x25519_bad_point_1) == 0) {
   3009                      ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3010                      goto cleanup;
   3011                  }
   3012          
   3013                  if (mbedtls_mpi_cmp_mpi(&XmP, &ecp_x25519_bad_point_2) == 0) {
   3014                      ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3015                      goto cleanup;
   3016                  }
   3017              }
   3018          #else
   3019              (void) grp_id;
   3020          #endif
   3021          
   3022              /* Final check: check if XmP + 1 is P (final because it changes XmP!) */
   3023              MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&XmP, &XmP, 1));
   3024              if (mbedtls_mpi_cmp_mpi(&XmP, P) == 0) {
   3025                  ret = MBEDTLS_ERR_ECP_INVALID_KEY;
   3026                  goto cleanup;
   3027              }
   3028          
   3029              ret = 0;
   3030          
   3031          cleanup:
   3032              mbedtls_mpi_free(&XmP);
   3033          
   3034              return ret;
   3035          }
   3036          
   3037          /*
   3038           * Check validity of a public key for Montgomery curves with x-only schemes
   3039           */
   3040          static int ecp_check_pubkey_mx(const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt)
   3041          {
   3042              /* [Curve25519 p. 5] Just check X is the correct number of bytes */
   3043              /* Allow any public value, if it's too big then we'll just reduce it mod p
   3044               * (RFC 7748 sec. 5 para. 3). */
   3045              if (mbedtls_mpi_size(&pt->X) > (grp->nbits + 7) / 8) {
   3046                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   3047              }
   3048          
   3049              /* Implicit in all standards (as they don't consider negative numbers):
   3050               * X must be non-negative. This is normally ensured by the way it's
   3051               * encoded for transmission, but let's be extra sure. */
   3052              if (mbedtls_mpi_cmp_int(&pt->X, 0) < 0) {
   3053                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   3054              }
   3055          
   3056              return ecp_check_bad_points_mx(&pt->X, &grp->P, grp->id);
   3057          }
   3058          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3059          
   3060          /*
   3061           * Check that a point is valid as a public key
   3062           */

   \                                 In section .text, align 2, keep-with-next
   3063          int mbedtls_ecp_check_pubkey(const mbedtls_ecp_group *grp,
   3064                                       const mbedtls_ecp_point *pt)
   3065          {
   \                     mbedtls_ecp_check_pubkey: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0xB084             SUB      SP,SP,#+16
   3066              /* Must use affine coordinates */
   3067              if (mbedtls_mpi_cmp_int(&pt->Z, 1) != 0) {
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0xF105 0x0010      ADD      R0,R5,#+16
   \        0xE   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x12   0x....             LDR.N    R6,??DataTable22_3
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD168             BNE.N    ??mbedtls_ecp_check_pubkey_0
   3068                  return MBEDTLS_ERR_ECP_INVALID_KEY;
   3069              }
   3070          
   3071          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3072              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3073                  return ecp_check_pubkey_mx(grp, pt);
   3074              }
   3075          #endif
   3076          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3077              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x18   0x4638             MOV      R0,R7
   \       0x1A   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD165             BNE.N    ??mbedtls_ecp_check_pubkey_1
   3078                  return ecp_check_pubkey_sw(grp, pt);
   \       0x22   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD45F             BMI.N    ??mbedtls_ecp_check_pubkey_0
   \       0x2A   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD45B             BMI.N    ??mbedtls_ecp_check_pubkey_0
   \       0x32   0x1D39             ADDS     R1,R7,#+4
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD555             BPL.N    ??mbedtls_ecp_check_pubkey_0
   \       0x3E   0x1D39             ADDS     R1,R7,#+4
   \       0x40   0xF105 0x0008      ADD      R0,R5,#+8
   \       0x44   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD54E             BPL.N    ??mbedtls_ecp_check_pubkey_0
   \       0x4C   0xA802             ADD      R0,SP,#+8
   \       0x4E   0x.... 0x....      BL       mbedtls_mpi_init
   \       0x52   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x56   0xF105 0x0308      ADD      R3,R5,#+8
   \       0x5A   0xF105 0x0208      ADD      R2,R5,#+8
   \       0x5E   0xA902             ADD      R1,SP,#+8
   \       0x60   0x.... 0x....      BL       ??Subroutine15_0
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x64   0x0004             MOVS     R4,R0
   \       0x66   0xD132             BNE.N    ??mbedtls_ecp_check_pubkey_2
   \       0x68   0x462B             MOV      R3,R5
   \       0x6A   0x462A             MOV      R2,R5
   \       0x6C   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x70   0x0004             MOVS     R4,R0
   \       0x72   0xD125             BNE.N    ??mbedtls_ecp_check_pubkey_3
   \       0x74   0x68F8             LDR      R0,[R7, #+12]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD130             BNE.N    ??mbedtls_ecp_check_pubkey_4
   \       0x7A   0x2203             MOVS     R2,#+3
   \       0x7C   0x4669             MOV      R1,SP
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0x.... 0x....      BL       mbedtls_mpi_sub_int
   \       0x84   0x0004             MOVS     R4,R0
   \       0x86   0xD10F             BNE.N    ??mbedtls_ecp_check_pubkey_5
   \                     ??mbedtls_ecp_check_pubkey_6: (+1)
   \       0x88   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD50B             BPL.N    ??mbedtls_ecp_check_pubkey_5
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0x4668             MOV      R0,SP
   \       0x94   0x.... 0x....      BL       mbedtls_mpi_cmp_int
   \       0x98   0xB130             CBZ.N    R0,??mbedtls_ecp_check_pubkey_5
   \       0x9A   0x1D3A             ADDS     R2,R7,#+4
   \       0x9C   0x4669             MOV      R1,SP
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x.... 0x....      BL       mbedtls_mpi_add_mpi
   \       0xA4   0x0004             MOVS     R4,R0
   \       0xA6   0xD0EF             BEQ.N    ??mbedtls_ecp_check_pubkey_6
   \                     ??mbedtls_ecp_check_pubkey_5: (+1)
   \       0xA8   0xB98C             CBNZ.N   R4,??mbedtls_ecp_check_pubkey_2
   \                     ??mbedtls_ecp_check_pubkey_7: (+1)
   \       0xAA   0x462B             MOV      R3,R5
   \       0xAC   0x466A             MOV      R2,SP
   \       0xAE   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0xB2   0x0004             MOVS     R4,R0
   \       0xB4   0xD104             BNE.N    ??mbedtls_ecp_check_pubkey_3
   \       0xB6   0xF107 0x0314      ADD      R3,R7,#+20
   \       0xBA   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0xBE   0x4604             MOV      R4,R0
   \                     ??mbedtls_ecp_check_pubkey_3: (+1)
   \       0xC0   0xB92C             CBNZ.N   R4,??mbedtls_ecp_check_pubkey_2
   \       0xC2   0x4669             MOV      R1,SP
   \       0xC4   0xA802             ADD      R0,SP,#+8
   \       0xC6   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0xCA   0xB100             CBZ.N    R0,??mbedtls_ecp_check_pubkey_2
   \       0xCC   0x4634             MOV      R4,R6
   \                     ??mbedtls_ecp_check_pubkey_2: (+1)
   \       0xCE   0xA802             ADD      R0,SP,#+8
   \       0xD0   0x.... 0x....      BL       mbedtls_mpi_free
   \       0xD4   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xD8   0x4626             MOV      R6,R4
   \       0xDA   0xE006             B.N      ??mbedtls_ecp_check_pubkey_0
   \                     ??mbedtls_ecp_check_pubkey_4: (+1)
   \       0xDC   0xF107 0x030C      ADD      R3,R7,#+12
   \       0xE0   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0xE4   0x0004             MOVS     R4,R0
   \       0xE6   0xD1EB             BNE.N    ??mbedtls_ecp_check_pubkey_3
   \       0xE8   0xE7DF             B.N      ??mbedtls_ecp_check_pubkey_7
   3079              }
   \                     ??mbedtls_ecp_check_pubkey_0: (+1)
   \       0xEA   0x4630             MOV      R0,R6
   \       0xEC   0xE000             B.N      ??mbedtls_ecp_check_pubkey_8
   3080          #endif
   3081              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_pubkey_1: (+1)
   \       0xEE   0x....             LDR.N    R0,??DataTable22_1
   \                     ??mbedtls_ecp_check_pubkey_8: (+1)
   \       0xF0   0xB005             ADD      SP,SP,#+20
   \       0xF2   0xBDF0             POP      {R4-R7,PC}
   3082          }
   3083          
   3084          /*
   3085           * Check that an mbedtls_mpi is valid as a private key
   3086           */

   \                                 In section .text, align 2, keep-with-next
   3087          int mbedtls_ecp_check_privkey(const mbedtls_ecp_group *grp,
   3088                                        const mbedtls_mpi *d)
   3089          {
   \                     mbedtls_ecp_check_privkey: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   3090          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3091              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3092                  /* see RFC 7748 sec. 5 para. 5 */
   3093                  if (mbedtls_mpi_get_bit(d, 0) != 0 ||
   3094                      mbedtls_mpi_get_bit(d, 1) != 0 ||
   3095                      mbedtls_mpi_bitlen(d) - 1 != grp->nbits) {  /* mbedtls_mpi_bitlen is one-based! */
   3096                      return MBEDTLS_ERR_ECP_INVALID_KEY;
   3097                  }
   3098          
   3099                  /* see [Curve25519] page 5 */
   3100                  if (grp->nbits == 254 && mbedtls_mpi_get_bit(d, 2) != 0) {
   3101                      return MBEDTLS_ERR_ECP_INVALID_KEY;
   3102                  }
   3103          
   3104                  return 0;
   3105              }
   3106          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3107          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3108              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0x6   0x.... 0x....      BL       mbedtls_ecp_get_type
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD10E             BNE.N    ??mbedtls_ecp_check_privkey_0
   3109                  /* see SEC1 3.2 */
   3110                  if (mbedtls_mpi_cmp_int(d, 1) < 0 ||
   3111                      mbedtls_mpi_cmp_mpi(d, &grp->N) >= 0) {
   \        0xE   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD406             BMI.N    ??mbedtls_ecp_check_privkey_1
   \       0x16   0xF105 0x0134      ADD      R1,R5,#+52
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD401             BMI.N    ??mbedtls_ecp_check_privkey_2
   3112                      return MBEDTLS_ERR_ECP_INVALID_KEY;
   \                     ??mbedtls_ecp_check_privkey_1: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable22_3
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
   3113                  } else {
   3114                      return 0;
   \                     ??mbedtls_ecp_check_privkey_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
   3115                  }
   3116              }
   3117          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3118          
   3119              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_privkey_0: (+1)
   \       0x2C                      REQUIRE ?Subroutine0
   \       0x2C                      ;; // Fall through to label ?Subroutine0
   3120          }
   3121          
   3122          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3123          MBEDTLS_STATIC_TESTABLE
   3124          int mbedtls_ecp_gen_privkey_mx(size_t high_bit,
   3125                                         mbedtls_mpi *d,
   3126                                         int (*f_rng)(void *, unsigned char *, size_t),
   3127                                         void *p_rng)
   3128          {
   3129              int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   3130              size_t n_random_bytes = high_bit / 8 + 1;
   3131          
   3132              /* [Curve25519] page 5 */
   3133              /* Generate a (high_bit+1)-bit random number by generating just enough
   3134               * random bytes, then shifting out extra bits from the top (necessary
   3135               * when (high_bit+1) is not a multiple of 8). */
   3136              MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(d, n_random_bytes,
   3137                                                      f_rng, p_rng));
   3138              MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(d, 8 * n_random_bytes - high_bit - 1));
   3139          
   3140              MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, high_bit, 1));
   3141          
   3142              /* Make sure the last two bits are unset for Curve448, three bits for
   3143                 Curve25519 */
   3144              MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 0, 0));
   3145              MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 1, 0));
   3146              if (high_bit == 254) {
   3147                  MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(d, 2, 0));
   3148              }
   3149          
   3150          cleanup:
   3151              return ret;
   3152          }
   3153          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3154          
   3155          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3156          static int mbedtls_ecp_gen_privkey_sw(
   3157              const mbedtls_mpi *N, mbedtls_mpi *d,
   3158              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   3159          {
   3160              int ret = mbedtls_mpi_random(d, 1, N, f_rng, p_rng);
   3161              switch (ret) {
   3162                  case MBEDTLS_ERR_MPI_NOT_ACCEPTABLE:
   3163                      return MBEDTLS_ERR_ECP_RANDOM_FAILED;
   3164                  default:
   3165                      return ret;
   3166              }
   3167          }
   3168          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3169          
   3170          /*
   3171           * Generate a private key
   3172           */

   \                                 In section .text, align 2, keep-with-next
   3173          int mbedtls_ecp_gen_privkey(const mbedtls_ecp_group *grp,
   3174                                      mbedtls_mpi *d,
   3175                                      int (*f_rng)(void *, unsigned char *, size_t),
   3176                                      void *p_rng)
   3177          {
   \                     mbedtls_ecp_gen_privkey: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461E             MOV      R6,R3
   3178          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3179              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3180                  return mbedtls_ecp_gen_privkey_mx(grp->nbits, d, f_rng, p_rng);
   3181              }
   3182          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3183          
   3184          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3185              if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0xA   0x.... 0x....      BL       mbedtls_ecp_get_type
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD10C             BNE.N    ??mbedtls_ecp_gen_privkey_0
   3186                  return mbedtls_ecp_gen_privkey_sw(&grp->N, d, f_rng, p_rng);
   \       0x12   0x9600             STR      R6,[SP, #+0]
   \       0x14   0x462B             MOV      R3,R5
   \       0x16   0xF107 0x0234      ADD      R2,R7,#+52
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       mbedtls_mpi_random
   \       0x22   0xF110 0x0F0E      CMN      R0,#+14
   \       0x26   0xD102             BNE.N    ??mbedtls_ecp_gen_privkey_1
   \       0x28   0x....             LDR.N    R0,??DataTable22
   3187              }
   \       0x2A   0xBDF2             POP      {R1,R4-R7,PC}
   3188          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3189          
   3190              return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_gen_privkey_0: (+1)
   \       0x2C   0x....             LDR.N    R0,??DataTable22_1
   \                     ??mbedtls_ecp_gen_privkey_1: (+1)
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}
   3191          }
   3192          
   3193          #if defined(MBEDTLS_ECP_C)
   3194          /*
   3195           * Generate a keypair with configurable base point
   3196           */

   \                                 In section .text, align 2, keep-with-next
   3197          int mbedtls_ecp_gen_keypair_base(mbedtls_ecp_group *grp,
   3198                                           const mbedtls_ecp_point *G,
   3199                                           mbedtls_mpi *d, mbedtls_ecp_point *Q,
   3200                                           int (*f_rng)(void *, unsigned char *, size_t),
   3201                                           void *p_rng)
   3202          {
   \                     mbedtls_ecp_gen_keypair_base: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x9F0A             LDR      R7,[SP, #+40]
   \        0x6   0x9E0B             LDR      R6,[SP, #+44]
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x4698             MOV      R8,R3
   \        0xE   0x4681             MOV      R9,R0
   3203              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3204              MBEDTLS_MPI_CHK(mbedtls_ecp_gen_privkey(grp, d, f_rng, p_rng));
   \       0x10   0x4633             MOV      R3,R6
   \       0x12   0x463A             MOV      R2,R7
   \       0x14   0x4629             MOV      R1,R5
   \       0x16   0x.... 0x....      BL       mbedtls_ecp_gen_privkey
   \       0x1A   0xB938             CBNZ.N   R0,??mbedtls_ecp_gen_keypair_base_0
   3205              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(grp, Q, d, G, f_rng, p_rng));
   \       0x1C   0x9601             STR      R6,[SP, #+4]
   \       0x1E   0x9700             STR      R7,[SP, #+0]
   \       0x20   0x4623             MOV      R3,R4
   \       0x22   0x462A             MOV      R2,R5
   \       0x24   0x4641             MOV      R1,R8
   \       0x26   0x4648             MOV      R0,R9
   \       0x28   0x.... 0x....      BL       mbedtls_ecp_mul
   3206          
   3207          cleanup:
   3208              return ret;
   \                     ??mbedtls_ecp_gen_keypair_base_0: (+1)
   \       0x2C   0xE8BD 0x83FE      POP      {R1-R9,PC}
   3209          }
   3210          
   3211          /*
   3212           * Generate key pair, wrapper for conventional base point
   3213           */

   \                                 In section .text, align 2, keep-with-next
   3214          int mbedtls_ecp_gen_keypair(mbedtls_ecp_group *grp,
   3215                                      mbedtls_mpi *d, mbedtls_ecp_point *Q,
   3216                                      int (*f_rng)(void *, unsigned char *, size_t),
   3217                                      void *p_rng)
   3218          {
   \                     mbedtls_ecp_gen_keypair: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   3219              return mbedtls_ecp_gen_keypair_base(grp, &grp->G, d, Q, f_rng, p_rng);
   \        0x2   0x9C04             LDR      R4,[SP, #+16]
   \        0x4   0x9300             STR      R3,[SP, #+0]
   \        0x6   0x4613             MOV      R3,R2
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x9401             STR      R4,[SP, #+4]
   \        0xC   0xF100 0x011C      ADD      R1,R0,#+28
   \       0x10   0x.... 0x....      BL       mbedtls_ecp_gen_keypair_base
   \       0x14   0xBD16             POP      {R1,R2,R4,PC}
   3220          }
   3221          
   3222          /*
   3223           * Generate a keypair, prettier wrapper
   3224           */

   \                                 In section .text, align 2, keep-with-next
   3225          int mbedtls_ecp_gen_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
   3226                                  int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   3227          {
   \                     mbedtls_ecp_gen_key: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460E             MOV      R6,R1
   3228              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3229              if ((ret = mbedtls_ecp_group_load(&key->grp, grp_id)) != 0) {
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461D             MOV      R5,R3
   \        0xA   0x4630             MOV      R0,R6
   \        0xC   0x.... 0x....      BL       mbedtls_ecp_group_load
   \       0x10   0xB940             CBNZ.N   R0,??mbedtls_ecp_gen_key_0
   3230                  return ret;
   3231              }
   3232          
   3233              return mbedtls_ecp_gen_keypair(&key->grp, &key->d, &key->Q, f_rng, p_rng);
   \       0x12   0x9500             STR      R5,[SP, #+0]
   \       0x14   0x4623             MOV      R3,R4
   \       0x16   0xF106 0x0268      ADD      R2,R6,#+104
   \       0x1A   0xF106 0x0160      ADD      R1,R6,#+96
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       mbedtls_ecp_gen_keypair
   \                     ??mbedtls_ecp_gen_key_0: (+1)
   \       0x24   0xBD76             POP      {R1,R2,R4-R6,PC}
   3234          }
   3235          #endif /* MBEDTLS_ECP_C */
   3236          
   3237          #define ECP_CURVE25519_KEY_SIZE 32
   3238          #define ECP_CURVE448_KEY_SIZE   56
   3239          /*
   3240           * Read a private key.
   3241           */

   \                                 In section .text, align 2, keep-with-next
   3242          int mbedtls_ecp_read_key(mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
   3243                                   const unsigned char *buf, size_t buflen)
   3244          {
   \                     mbedtls_ecp_read_key: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460D             MOV      R5,R1
   3245              int ret = 0;
   3246          
   3247              if ((ret = mbedtls_ecp_group_load(&key->grp, grp_id)) != 0) {
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461C             MOV      R4,R3
   \        0xA   0x4628             MOV      R0,R5
   \        0xC   0x.... 0x....      BL       mbedtls_ecp_group_load
   \       0x10   0xB9C0             CBNZ.N   R0,??mbedtls_ecp_read_key_0
   3248                  return ret;
   3249              }
   3250          
   3251              ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   3252          
   3253          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3254              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3255                  /*
   3256                   * Mask the key as mandated by RFC7748 for Curve25519 and Curve448.
   3257                   */
   3258                  if (grp_id == MBEDTLS_ECP_DP_CURVE25519) {
   3259                      if (buflen != ECP_CURVE25519_KEY_SIZE) {
   3260                          return MBEDTLS_ERR_ECP_INVALID_KEY;
   3261                      }
   3262          
   3263                      MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary_le(&key->d, buf, buflen));
   3264          
   3265                      /* Set the three least significant bits to 0 */
   3266                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 0, 0));
   3267                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 1, 0));
   3268                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 2, 0));
   3269          
   3270                      /* Set the most significant bit to 0 */
   3271                      MBEDTLS_MPI_CHK(
   3272                          mbedtls_mpi_set_bit(&key->d,
   3273                                              ECP_CURVE25519_KEY_SIZE * 8 - 1, 0)
   3274                          );
   3275          
   3276                      /* Set the second most significant bit to 1 */
   3277                      MBEDTLS_MPI_CHK(
   3278                          mbedtls_mpi_set_bit(&key->d,
   3279                                              ECP_CURVE25519_KEY_SIZE * 8 - 2, 1)
   3280                          );
   3281                  } else if (grp_id == MBEDTLS_ECP_DP_CURVE448) {
   3282                      if (buflen != ECP_CURVE448_KEY_SIZE) {
   3283                          return MBEDTLS_ERR_ECP_INVALID_KEY;
   3284                      }
   3285          
   3286                      MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary_le(&key->d, buf, buflen));
   3287          
   3288                      /* Set the two least significant bits to 0 */
   3289                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 0, 0));
   3290                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(&key->d, 1, 0));
   3291          
   3292                      /* Set the most significant bit to 1 */
   3293                      MBEDTLS_MPI_CHK(
   3294                          mbedtls_mpi_set_bit(&key->d,
   3295                                              ECP_CURVE448_KEY_SIZE * 8 - 1, 1)
   3296                          );
   3297                  }
   3298              }
   3299          #endif
   3300          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3301              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       mbedtls_ecp_get_type
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD107             BNE.N    ??mbedtls_ecp_read_key_1
   3302                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&key->d, buf, buflen));
   \       0x1C   0x4622             MOV      R2,R4
   \       0x1E   0x4631             MOV      R1,R6
   \       0x20   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_read_binary
   \       0x28   0x0004             MOVS     R4,R0
   \       0x2A   0xD105             BNE.N    ??mbedtls_ecp_read_key_2
   3303              }
   3304          #endif
   3305              MBEDTLS_MPI_CHK(mbedtls_ecp_check_privkey(&key->grp, &key->d));
   \                     ??mbedtls_ecp_read_key_1: (+1)
   \       0x2C   0xF105 0x0160      ADD      R1,R5,#+96
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x.... 0x....      BL       mbedtls_ecp_check_privkey
   \       0x36   0x4604             MOV      R4,R0
   3306          
   3307          cleanup:
   3308          
   3309              if (ret != 0) {
   \                     ??mbedtls_ecp_read_key_2: (+1)
   \       0x38   0xB11C             CBZ.N    R4,??mbedtls_ecp_read_key_3
   3310                  mbedtls_mpi_free(&key->d);
   \       0x3A   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x3E   0x.... 0x....      BL       mbedtls_mpi_free
   3311              }
   3312          
   3313              return ret;
   \                     ??mbedtls_ecp_read_key_3: (+1)
   \       0x42   0x4620             MOV      R0,R4
   \                     ??mbedtls_ecp_read_key_0: (+1)
   \       0x44   0xBD70             POP      {R4-R6,PC}
   3314          }
   3315          
   3316          /*
   3317           * Write a private key.
   3318           */

   \                                 In section .text, align 2, keep-with-next
   3319          int mbedtls_ecp_write_key(mbedtls_ecp_keypair *key,
   3320                                    unsigned char *buf, size_t buflen)
   3321          {
   \                     mbedtls_ecp_write_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   3322              int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
   3323          
   3324          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3325              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
   3326                  if (key->grp.id == MBEDTLS_ECP_DP_CURVE25519) {
   3327                      if (buflen < ECP_CURVE25519_KEY_SIZE) {
   3328                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   3329                      }
   3330          
   3331                  } else if (key->grp.id == MBEDTLS_ECP_DP_CURVE448) {
   3332                      if (buflen < ECP_CURVE448_KEY_SIZE) {
   3333                          return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
   3334                      }
   3335                  }
   3336                  MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary_le(&key->d, buf, buflen));
   3337              }
   3338          #endif
   3339          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3340              if (mbedtls_ecp_get_type(&key->grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
   \        0x8   0x.... 0x....      BL       mbedtls_ecp_get_type
   \        0xC   0x....             LDR.N    R6,??DataTable22_2
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD106             BNE.N    ??mbedtls_ecp_write_key_0
   3341                  MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&key->d, buf, buflen));
   \       0x12   0x462A             MOV      R2,R5
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0xF107 0x0060      ADD      R0,R7,#+96
   \       0x1A   0x.... 0x....      BL       mbedtls_mpi_write_binary
   \       0x1E   0x4606             MOV      R6,R0
   3342              }
   3343          
   3344          #endif
   3345          cleanup:
   3346          
   3347              return ret;
   \                     ??mbedtls_ecp_write_key_0: (+1)
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}
   3348          }
   3349          
   3350          #if defined(MBEDTLS_ECP_C)
   3351          /*
   3352           * Check a public-private key pair
   3353           */

   \                                 In section .text, align 2, keep-with-next
   3354          int mbedtls_ecp_check_pub_priv(
   3355              const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv,
   3356              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
   3357          {
   \                     mbedtls_ecp_check_pub_priv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB0A0             SUB      SP,SP,#+128
   \        0x6   0x4604             MOV      R4,R0
   3358              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3359              mbedtls_ecp_point Q;
   3360              mbedtls_ecp_group grp;
   3361              if (pub->grp.id == MBEDTLS_ECP_DP_NONE ||
   3362                  pub->grp.id != prv->grp.id ||
   3363                  mbedtls_mpi_cmp_mpi(&pub->Q.X, &prv->Q.X) ||
   3364                  mbedtls_mpi_cmp_mpi(&pub->Q.Y, &prv->Q.Y) ||
   3365                  mbedtls_mpi_cmp_mpi(&pub->Q.Z, &prv->Q.Z)) {
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0x461E             MOV      R6,R3
   \       0x10   0x.... 0x....      LDR.W    R8,??DataTable22_1
   \       0x14   0xB1B8             CBZ.N    R0,??mbedtls_ecp_check_pub_priv_0
   \       0x16   0x782A             LDRB     R2,[R5, #+0]
   \       0x18   0x4290             CMP      R0,R2
   \       0x1A   0xD114             BNE.N    ??mbedtls_ecp_check_pub_priv_0
   \       0x1C   0xF105 0x0168      ADD      R1,R5,#+104
   \       0x20   0xF104 0x0068      ADD      R0,R4,#+104
   \       0x24   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x28   0xB968             CBNZ.N   R0,??mbedtls_ecp_check_pub_priv_0
   \       0x2A   0xF105 0x0170      ADD      R1,R5,#+112
   \       0x2E   0xF104 0x0070      ADD      R0,R4,#+112
   \       0x32   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x36   0xB930             CBNZ.N   R0,??mbedtls_ecp_check_pub_priv_0
   \       0x38   0xF105 0x0178      ADD      R1,R5,#+120
   \       0x3C   0xF104 0x0078      ADD      R0,R4,#+120
   \       0x40   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x44   0xB108             CBZ.N    R0,??mbedtls_ecp_check_pub_priv_1
   3366                  return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_pub_priv_0: (+1)
   \       0x46   0x4640             MOV      R0,R8
   \       0x48   0xE02F             B.N      ??mbedtls_ecp_check_pub_priv_2
   3367              }
   3368          
   3369              mbedtls_ecp_point_init(&Q);
   \                     ??mbedtls_ecp_check_pub_priv_1: (+1)
   \       0x4A   0xA802             ADD      R0,SP,#+8
   \       0x4C   0x.... 0x....      BL       mbedtls_ecp_point_init
   3370              mbedtls_ecp_group_init(&grp);
   \       0x50   0xA808             ADD      R0,SP,#+32
   \       0x52   0x.... 0x....      BL       mbedtls_ecp_group_init
   3371          
   3372              /* mbedtls_ecp_mul() needs a non-const group... */
   3373              mbedtls_ecp_group_copy(&grp, &prv->grp);
   \       0x56   0x4629             MOV      R1,R5
   \       0x58   0xA808             ADD      R0,SP,#+32
   \       0x5A   0x.... 0x....      BL       mbedtls_ecp_group_copy
   3374          
   3375              /* Also checks d is valid */
   3376              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&grp, &Q, &prv->d, &prv->grp.G, f_rng, p_rng));
   \       0x5E   0x9601             STR      R6,[SP, #+4]
   \       0x60   0x9700             STR      R7,[SP, #+0]
   \       0x62   0xF105 0x031C      ADD      R3,R5,#+28
   \       0x66   0xF105 0x0260      ADD      R2,R5,#+96
   \       0x6A   0xA902             ADD      R1,SP,#+8
   \       0x6C   0xA808             ADD      R0,SP,#+32
   \       0x6E   0x.... 0x....      BL       mbedtls_ecp_mul
   \       0x72   0x0004             MOVS     R4,R0
   \       0x74   0xD112             BNE.N    ??mbedtls_ecp_check_pub_priv_3
   3377          
   3378              if (mbedtls_mpi_cmp_mpi(&Q.X, &prv->Q.X) ||
   3379                  mbedtls_mpi_cmp_mpi(&Q.Y, &prv->Q.Y) ||
   3380                  mbedtls_mpi_cmp_mpi(&Q.Z, &prv->Q.Z)) {
   \       0x76   0xF105 0x0168      ADD      R1,R5,#+104
   \       0x7A   0xA802             ADD      R0,SP,#+8
   \       0x7C   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x80   0xB958             CBNZ.N   R0,??mbedtls_ecp_check_pub_priv_4
   \       0x82   0xF105 0x0170      ADD      R1,R5,#+112
   \       0x86   0xA804             ADD      R0,SP,#+16
   \       0x88   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x8C   0xB928             CBNZ.N   R0,??mbedtls_ecp_check_pub_priv_4
   \       0x8E   0xF105 0x0178      ADD      R1,R5,#+120
   \       0x92   0xA806             ADD      R0,SP,#+24
   \       0x94   0x.... 0x....      BL       mbedtls_mpi_cmp_mpi
   \       0x98   0xB100             CBZ.N    R0,??mbedtls_ecp_check_pub_priv_3
   3381                  ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
   \                     ??mbedtls_ecp_check_pub_priv_4: (+1)
   \       0x9A   0x4644             MOV      R4,R8
   3382                  goto cleanup;
   3383              }
   3384          
   3385          cleanup:
   3386              mbedtls_ecp_point_free(&Q);
   \                     ??mbedtls_ecp_check_pub_priv_3: (+1)
   \       0x9C   0xA802             ADD      R0,SP,#+8
   \       0x9E   0x.... 0x....      BL       mbedtls_ecp_point_free
   3387              mbedtls_ecp_group_free(&grp);
   \       0xA2   0xA808             ADD      R0,SP,#+32
   \       0xA4   0x.... 0x....      BL       mbedtls_ecp_group_free
   3388          
   3389              return ret;
   \       0xA8   0x4620             MOV      R0,R4
   \                     ??mbedtls_ecp_check_pub_priv_2: (+1)
   \       0xAA   0xB020             ADD      SP,SP,#+128
   \       0xAC   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3390          }
   3391          #endif /* MBEDTLS_ECP_C */
   3392          
   3393          /*
   3394           * Export generic key-pair parameters.
   3395           */

   \                                 In section .text, align 2, keep-with-next
   3396          int mbedtls_ecp_export(const mbedtls_ecp_keypair *key, mbedtls_ecp_group *grp,
   3397                                 mbedtls_mpi *d, mbedtls_ecp_point *Q)
   3398          {
   \                     mbedtls_ecp_export: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461D             MOV      R5,R3
   3399              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3400          
   3401              if ((ret = mbedtls_ecp_group_copy(grp, &key->grp)) != 0) {
   \        0xA   0x4631             MOV      R1,R6
   \        0xC   0x.... 0x....      BL       mbedtls_ecp_group_copy
   \       0x10   0xB960             CBNZ.N   R0,??mbedtls_ecp_export_0
   3402                  return ret;
   3403              }
   3404          
   3405              if ((ret = mbedtls_mpi_copy(d, &key->d)) != 0) {
   \       0x12   0xF106 0x0160      ADD      R1,R6,#+96
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_mpi_copy
   \       0x1C   0xB930             CBNZ.N   R0,??mbedtls_ecp_export_0
   3406                  return ret;
   3407              }
   3408          
   3409              if ((ret = mbedtls_ecp_copy(Q, &key->Q)) != 0) {
   3410                  return ret;
   \       0x1E   0xF106 0x0168      ADD      R1,R6,#+104
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x28   0x.... 0x....      B.W      mbedtls_ecp_copy
   \                     ??mbedtls_ecp_export_0: (+1)
   \       0x2C   0xBD70             POP      {R4-R6,PC}
   3411              }
   3412          
   3413              return 0;
   3414          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     ecp_supported_grp_id

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0xFFFF'B100        DC32     0xffffb100

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \                     ??Subroutine15_0: (+1)
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      mbedtls_mpi_mul_mod

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x466A             MOV      R2,SP
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x4638             MOV      R0,R7
   \        0x6   0x.... 0x....      B.W      mbedtls_mpi_add_mod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xFFFF'B280        DC32     0xffffb280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0xFFFF'B300        DC32     0xffffb300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0xFFFF'B080        DC32     0xffffb080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0xFFFF'B180        DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0xFFFF'B380        DC32     0xffffb380

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x65          DC8 "secp256r1"
   \              0x63 0x70    
   \              0x32 0x35    
   \              0x36 0x72    
   \              0x31 0x00
   \        0xA                      DS8 2
   3415          
   3416          #if defined(MBEDTLS_SELF_TEST)
   3417          
   3418          #if defined(MBEDTLS_ECP_C)
   3419          /*
   3420           * PRNG for test - !!!INSECURE NEVER USE IN PRODUCTION!!!
   3421           *
   3422           * This is the linear congruential generator from numerical recipes,
   3423           * except we only use the low byte as the output. See
   3424           * https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
   3425           */
   3426          static int self_test_rng(void *ctx, unsigned char *out, size_t len)
   3427          {
   3428              static uint32_t state = 42;
   3429          
   3430              (void) ctx;
   3431          
   3432              for (size_t i = 0; i < len; i++) {
   3433                  state = state * 1664525u + 1013904223u;
   3434                  out[i] = (unsigned char) state;
   3435              }
   3436          
   3437              return 0;
   3438          }
   3439          
   3440          /* Adjust the exponent to be a valid private point for the specified curve.
   3441           * This is sometimes necessary because we use a single set of exponents
   3442           * for all curves but the validity of values depends on the curve. */
   3443          static int self_test_adjust_exponent(const mbedtls_ecp_group *grp,
   3444                                               mbedtls_mpi *m)
   3445          {
   3446              int ret = 0;
   3447              switch (grp->id) {
   3448              /* If Curve25519 is available, then that's what we use for the
   3449               * Montgomery test, so we don't need the adjustment code. */
   3450          #if !defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   3451          #if defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
   3452                  case MBEDTLS_ECP_DP_CURVE448:
   3453                      /* Move highest bit from 254 to N-1. Setting bit N-1 is
   3454                       * necessary to enforce the highest-bit-set constraint. */
   3455                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(m, 254, 0));
   3456                      MBEDTLS_MPI_CHK(mbedtls_mpi_set_bit(m, grp->nbits, 1));
   3457                      /* Copy second-highest bit from 253 to N-2. This is not
   3458                       * necessary but improves the test variety a bit. */
   3459                      MBEDTLS_MPI_CHK(
   3460                          mbedtls_mpi_set_bit(m, grp->nbits - 1,
   3461                                              mbedtls_mpi_get_bit(m, 253)));
   3462                      break;
   3463          #endif
   3464          #endif /* ! defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED) */
   3465                  default:
   3466                      /* Non-Montgomery curves and Curve25519 need no adjustment. */
   3467                      (void) grp;
   3468                      (void) m;
   3469                      goto cleanup;
   3470              }
   3471          cleanup:
   3472              return ret;
   3473          }
   3474          
   3475          /* Calculate R = m.P for each m in exponents. Check that the number of
   3476           * basic operations doesn't depend on the value of m. */
   3477          static int self_test_point(int verbose,
   3478                                     mbedtls_ecp_group *grp,
   3479                                     mbedtls_ecp_point *R,
   3480                                     mbedtls_mpi *m,
   3481                                     const mbedtls_ecp_point *P,
   3482                                     const char *const *exponents,
   3483                                     size_t n_exponents)
   3484          {
   3485              int ret = 0;
   3486              size_t i = 0;
   3487              unsigned long add_c_prev, dbl_c_prev, mul_c_prev;
   3488              add_count = 0;
   3489              dbl_count = 0;
   3490              mul_count = 0;
   3491          
   3492              MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(m, 16, exponents[0]));
   3493              MBEDTLS_MPI_CHK(self_test_adjust_exponent(grp, m));
   3494              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(grp, R, m, P, self_test_rng, NULL));
   3495          
   3496              for (i = 1; i < n_exponents; i++) {
   3497                  add_c_prev = add_count;
   3498                  dbl_c_prev = dbl_count;
   3499                  mul_c_prev = mul_count;
   3500                  add_count = 0;
   3501                  dbl_count = 0;
   3502                  mul_count = 0;
   3503          
   3504                  MBEDTLS_MPI_CHK(mbedtls_mpi_read_string(m, 16, exponents[i]));
   3505                  MBEDTLS_MPI_CHK(self_test_adjust_exponent(grp, m));
   3506                  MBEDTLS_MPI_CHK(mbedtls_ecp_mul(grp, R, m, P, self_test_rng, NULL));
   3507          
   3508                  if (add_count != add_c_prev ||
   3509                      dbl_count != dbl_c_prev ||
   3510                      mul_count != mul_c_prev) {
   3511                      ret = 1;
   3512                      break;
   3513                  }
   3514              }
   3515          
   3516          cleanup:
   3517              if (verbose != 0) {
   3518                  if (ret != 0) {
   3519                      mbedtls_printf("failed (%u)\n", (unsigned int) i);
   3520                  } else {
   3521                      mbedtls_printf("passed\n");
   3522                  }
   3523              }
   3524              return ret;
   3525          }
   3526          #endif /* MBEDTLS_ECP_C */
   3527          
   3528          /*
   3529           * Checkup routine
   3530           */
   3531          int mbedtls_ecp_self_test(int verbose)
   3532          {
   3533          #if defined(MBEDTLS_ECP_C)
   3534              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3535              mbedtls_ecp_group grp;
   3536              mbedtls_ecp_point R, P;
   3537              mbedtls_mpi m;
   3538          
   3539          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3540              /* Exponents especially adapted for secp192k1, which has the lowest
   3541               * order n of all supported curves (secp192r1 is in a slightly larger
   3542               * field but the order of its base point is slightly smaller). */
   3543              const char *sw_exponents[] =
   3544              {
   3545                  "000000000000000000000000000000000000000000000001", /* one */
   3546                  "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8C", /* n - 1 */
   3547                  "5EA6F389A38B8BC81E767753B15AA5569E1782E30ABE7D25", /* random */
   3548                  "400000000000000000000000000000000000000000000000", /* one and zeros */
   3549                  "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", /* all ones */
   3550                  "555555555555555555555555555555555555555555555555", /* 101010... */
   3551              };
   3552          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3553          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3554              const char *m_exponents[] =
   3555              {
   3556                  /* Valid private values for Curve25519. In a build with Curve448
   3557                   * but not Curve25519, they will be adjusted in
   3558                   * self_test_adjust_exponent(). */
   3559                  "4000000000000000000000000000000000000000000000000000000000000000",
   3560                  "5C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C30",
   3561                  "5715ECCE24583F7A7023C24164390586842E816D7280A49EF6DF4EAE6B280BF8",
   3562                  "41A2B017516F6D254E1F002BCCBADD54BE30F8CEC737A0E912B4963B6BA74460",
   3563                  "5555555555555555555555555555555555555555555555555555555555555550",
   3564                  "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8",
   3565              };
   3566          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3567          
   3568              mbedtls_ecp_group_init(&grp);
   3569              mbedtls_ecp_point_init(&R);
   3570              mbedtls_ecp_point_init(&P);
   3571              mbedtls_mpi_init(&m);
   3572          
   3573          #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
   3574              /* Use secp192r1 if available, or any available curve */
   3575          #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
   3576              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_SECP192R1));
   3577          #else
   3578              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, mbedtls_ecp_curve_list()->grp_id));
   3579          #endif
   3580          
   3581              if (verbose != 0) {
   3582                  mbedtls_printf("  ECP SW test #1 (constant op_count, base point G): ");
   3583              }
   3584              /* Do a dummy multiplication first to trigger precomputation */
   3585              MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&m, 2));
   3586              MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&grp, &P, &m, &grp.G, self_test_rng, NULL));
   3587              ret = self_test_point(verbose,
   3588                                    &grp, &R, &m, &grp.G,
   3589                                    sw_exponents,
   3590                                    sizeof(sw_exponents) / sizeof(sw_exponents[0]));
   3591              if (ret != 0) {
   3592                  goto cleanup;
   3593              }
   3594          
   3595              if (verbose != 0) {
   3596                  mbedtls_printf("  ECP SW test #2 (constant op_count, other point): ");
   3597              }
   3598              /* We computed P = 2G last time, use it */
   3599              ret = self_test_point(verbose,
   3600                                    &grp, &R, &m, &P,
   3601                                    sw_exponents,
   3602                                    sizeof(sw_exponents) / sizeof(sw_exponents[0]));
   3603              if (ret != 0) {
   3604                  goto cleanup;
   3605              }
   3606          
   3607              mbedtls_ecp_group_free(&grp);
   3608              mbedtls_ecp_point_free(&R);
   3609          #endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
   3610          
   3611          #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
   3612              if (verbose != 0) {
   3613                  mbedtls_printf("  ECP Montgomery test (constant op_count): ");
   3614              }
   3615          #if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
   3616              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_CURVE25519));
   3617          #elif defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
   3618              MBEDTLS_MPI_CHK(mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_CURVE448));
   3619          #else
   3620          #error "MBEDTLS_ECP_MONTGOMERY_ENABLED is defined, but no curve is supported for self-test"
   3621          #endif
   3622              ret = self_test_point(verbose,
   3623                                    &grp, &R, &m, &grp.G,
   3624                                    m_exponents,
   3625                                    sizeof(m_exponents) / sizeof(m_exponents[0]));
   3626              if (ret != 0) {
   3627                  goto cleanup;
   3628              }
   3629          #endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
   3630          
   3631          cleanup:
   3632          
   3633              if (ret < 0 && verbose != 0) {
   3634                  mbedtls_printf("Unexpected error, return code = %08X\n", (unsigned int) ret);
   3635              }
   3636          
   3637              mbedtls_ecp_group_free(&grp);
   3638              mbedtls_ecp_point_free(&R);
   3639              mbedtls_ecp_point_free(&P);
   3640              mbedtls_mpi_free(&m);
   3641          
   3642              if (verbose != 0) {
   3643                  mbedtls_printf("\n");
   3644              }
   3645          
   3646              return ret;
   3647          #else /* MBEDTLS_ECP_C */
   3648              (void) verbose;
   3649              return 0;
   3650          #endif /* MBEDTLS_ECP_C */
   3651          }
   3652          
   3653          #endif /* MBEDTLS_SELF_TEST */
   3654          
   3655          #endif /* !MBEDTLS_ECP_ALT */
   3656          
   3657          #endif /* MBEDTLS_ECP_LIGHT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   ecp_add_mixed
         0   -> ecp_double_jac
         0   -> mbedtls_ecp_copy
         0   -> mbedtls_ecp_set_zero
        24   -> mbedtls_mpi_cmp_int
        24   -> mbedtls_mpi_copy
        24   -> mbedtls_mpi_mul_mod
        24   -> mbedtls_mpi_shift_l_mod
         0   -> mbedtls_mpi_sub_mod
        24   -> mbedtls_mpi_sub_mod
      24   ecp_double_jac
        24   -> mbedtls_ecp_group_a_is_minus_3
        24   -> mbedtls_mpi_add_mod
        24   -> mbedtls_mpi_cmp_int
         0   -> mbedtls_mpi_copy
        24   -> mbedtls_mpi_copy
        24   -> mbedtls_mpi_mul_int_mod
        24   -> mbedtls_mpi_mul_mod
        24   -> mbedtls_mpi_shift_l_mod
        24   -> mbedtls_mpi_sub_mod
     240   ecp_mul_restartable_internal
       240   -> __aeabi_memclr4
       240   -> ecp_add_mixed
       240   -> ecp_double_jac
       240   -> ecp_normalize_jac
       240   -> ecp_normalize_jac_many
       240   -> ecp_randomize_jac
       240   -> ecp_safe_invert_jac
       240   -> ecp_select_comb
       240   -> mbedtls_ecp_check_privkey
       240   -> mbedtls_ecp_check_pubkey
       240   -> mbedtls_ecp_copy
       240   -> mbedtls_ecp_get_type
       240   -> mbedtls_ecp_point_free
       240   -> mbedtls_ecp_point_init
       240   -> mbedtls_mpi_copy
       240   -> mbedtls_mpi_free
       240   -> mbedtls_mpi_get_bit
       240   -> mbedtls_mpi_init
       240   -> mbedtls_mpi_safe_cond_assign
       240   -> mbedtls_mpi_sub_mpi
       240   -> mpi_free_many
       240   -> mpi_init_many
       240   -> sl_calloc
       240   -> sl_free
      24   ecp_normalize_jac
        24   -> mbedtls_mpi_cmp_int
        24   -> mbedtls_mpi_free
        24   -> mbedtls_mpi_init
        24   -> mbedtls_mpi_inv_mod
        24   -> mbedtls_mpi_lset
        24   -> mbedtls_mpi_mul_mod
      48   ecp_normalize_jac_many
        48   -> ecp_normalize_jac
        48   -> mbedtls_mpi_copy
        48   -> mbedtls_mpi_free
        48   -> mbedtls_mpi_init
        48   -> mbedtls_mpi_inv_mod
        48   -> mbedtls_mpi_lset
        48   -> mbedtls_mpi_mul_mod
        48   -> mbedtls_mpi_shrink
        48   -> mpi_free_many
        48   -> mpi_init_many
        48   -> sl_calloc
        48   -> sl_free
      32   ecp_randomize_jac
        32   -> mbedtls_mpi_free
        32   -> mbedtls_mpi_init
        32   -> mbedtls_mpi_mul_mod
        32   -> mbedtls_mpi_random
      32   ecp_safe_invert_jac
        32   -> mbedtls_mpi_cmp_int
        32   -> mbedtls_mpi_free
        32   -> mbedtls_mpi_init
        32   -> mbedtls_mpi_safe_cond_assign
        32   -> mbedtls_mpi_sub_mpi
      40   ecp_select_comb
        40   -> ecp_safe_invert_jac
         0   -> mbedtls_mpi_lset
        40   -> mbedtls_mpi_safe_cond_assign
      16   mbedtls_ecp_check_privkey
        16   -> mbedtls_ecp_get_type
        16   -> mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_cmp_mpi
     152   mbedtls_ecp_check_pub_priv
       152   -> mbedtls_ecp_group_copy
       152   -> mbedtls_ecp_group_free
       152   -> mbedtls_ecp_group_init
       152   -> mbedtls_ecp_mul
       152   -> mbedtls_ecp_point_free
       152   -> mbedtls_ecp_point_init
       152   -> mbedtls_mpi_cmp_mpi
      40   mbedtls_ecp_check_pubkey
        40   -> mbedtls_ecp_get_type
        40   -> mbedtls_mpi_add_mod
        40   -> mbedtls_mpi_add_mpi
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_cmp_mpi
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_mul_mod
        40   -> mbedtls_mpi_sub_int
      16   mbedtls_ecp_copy
         0   -> mbedtls_mpi_copy
        16   -> mbedtls_mpi_copy
       0   mbedtls_ecp_curve_info_from_grp_id
      16   mbedtls_ecp_curve_info_from_name
        16   -> strcmp
       0   mbedtls_ecp_curve_info_from_tls_id
       0   mbedtls_ecp_curve_list
      16   mbedtls_ecp_export
         0   -> mbedtls_ecp_copy
        16   -> mbedtls_ecp_group_copy
        16   -> mbedtls_mpi_copy
      24   mbedtls_ecp_gen_key
        24   -> mbedtls_ecp_gen_keypair
        24   -> mbedtls_ecp_group_load
      16   mbedtls_ecp_gen_keypair
        16   -> mbedtls_ecp_gen_keypair_base
      40   mbedtls_ecp_gen_keypair_base
        40   -> mbedtls_ecp_gen_privkey
        40   -> mbedtls_ecp_mul
      24   mbedtls_ecp_gen_privkey
        24   -> mbedtls_ecp_get_type
        24   -> mbedtls_mpi_random
       0   mbedtls_ecp_get_type
       0   mbedtls_ecp_group_a_is_minus_3
       0   mbedtls_ecp_group_copy
         0   -> mbedtls_ecp_group_load
      16   mbedtls_ecp_group_free
        16   -> mbedtls_ecp_point_free
        16   -> mbedtls_mpi_free
         0   -> mbedtls_platform_zeroize
        16   -> sl_free
       8   mbedtls_ecp_group_init
         8   -> mbedtls_ecp_point_init
         8   -> mbedtls_mpi_init
       8   mbedtls_ecp_grp_id_list
       8   mbedtls_ecp_is_zero
         8   -> mbedtls_mpi_cmp_int
       8   mbedtls_ecp_keypair_free
         8   -> mbedtls_ecp_group_free
         0   -> mbedtls_ecp_point_free
         8   -> mbedtls_mpi_free
       8   mbedtls_ecp_keypair_init
         8   -> mbedtls_ecp_group_init
         0   -> mbedtls_ecp_point_init
         8   -> mbedtls_mpi_init
      24   mbedtls_ecp_mul
        24   -> mbedtls_ecp_mul_restartable
      32   mbedtls_ecp_mul_restartable
        32   -> ecp_mul_restartable_internal
      40   mbedtls_ecp_mul_shortcuts
        40   -> ecp_mul_restartable_internal
        40   -> mbedtls_ecp_check_pubkey
        40   -> mbedtls_ecp_copy
        40   -> mbedtls_ecp_set_zero
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_free
        40   -> mbedtls_mpi_init
        40   -> mbedtls_mpi_safe_cond_assign
        40   -> mbedtls_mpi_sub_mpi
      24   mbedtls_ecp_muladd
        24   -> mbedtls_ecp_muladd_restartable
      88   mbedtls_ecp_muladd_restartable
        88   -> ecp_add_mixed
        88   -> ecp_normalize_jac
        88   -> mbedtls_ecp_get_type
        88   -> mbedtls_ecp_mul_shortcuts
        88   -> mbedtls_ecp_point_free
        88   -> mbedtls_ecp_point_init
        88   -> mpi_free_many
        88   -> mpi_init_many
      16   mbedtls_ecp_point_cmp
        16   -> mbedtls_mpi_cmp_mpi
       8   mbedtls_ecp_point_free
         0   -> mbedtls_mpi_free
         8   -> mbedtls_mpi_free
       8   mbedtls_ecp_point_init
         0   -> mbedtls_mpi_init
         8   -> mbedtls_mpi_init
      32   mbedtls_ecp_point_read_binary
        32   -> mbedtls_ecp_get_type
         0   -> mbedtls_ecp_set_zero
        32   -> mbedtls_mpi_lset
         0   -> mbedtls_mpi_read_binary
        32   -> mbedtls_mpi_read_binary
        32   -> mbedtls_mpi_size
      16   mbedtls_ecp_point_read_string
         0   -> mbedtls_mpi_lset
        16   -> mbedtls_mpi_read_string
      40   mbedtls_ecp_point_write_binary
        40   -> mbedtls_ecp_get_type
        40   -> mbedtls_mpi_cmp_int
        40   -> mbedtls_mpi_get_bit
        40   -> mbedtls_mpi_size
        40   -> mbedtls_mpi_write_binary
      16   mbedtls_ecp_read_key
        16   -> mbedtls_ecp_check_privkey
        16   -> mbedtls_ecp_get_type
        16   -> mbedtls_ecp_group_load
        16   -> mbedtls_mpi_free
        16   -> mbedtls_mpi_read_binary
       8   mbedtls_ecp_set_zero
         0   -> mbedtls_mpi_lset
         8   -> mbedtls_mpi_lset
      16   mbedtls_ecp_tls_read_group
        16   -> mbedtls_ecp_group_load
        16   -> mbedtls_ecp_tls_read_group_id
      16   mbedtls_ecp_tls_read_group_id
        16   -> mbedtls_ecp_curve_info_from_tls_id
        16   -> mbedtls_get_unaligned_uint16
      16   mbedtls_ecp_tls_read_point
         0   -> mbedtls_ecp_point_read_binary
      16   mbedtls_ecp_tls_write_group
        16   -> mbedtls_ecp_curve_info_from_grp_id
        16   -> mbedtls_put_unaligned_uint16
      24   mbedtls_ecp_tls_write_point
        24   -> mbedtls_ecp_point_write_binary
      24   mbedtls_ecp_write_key
        24   -> mbedtls_ecp_get_type
        24   -> mbedtls_mpi_write_binary
       4   mbedtls_get_unaligned_uint16
      16   mbedtls_mpi_add_mod
        16   -> mbedtls_mpi_add_mpi
        16   -> mbedtls_mpi_cmp_mpi
        16   -> mbedtls_mpi_sub_abs
      16   mbedtls_mpi_mul_int_mod
        16   -> mbedtls_mpi_cmp_mpi
        16   -> mbedtls_mpi_mul_int
        16   -> mbedtls_mpi_sub_abs
      16   mbedtls_mpi_mul_mod
        16   -- Indirect call
        16   -> mbedtls_mpi_add_mpi
        16   -> mbedtls_mpi_bitlen
        16   -> mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_cmp_mpi
        16   -> mbedtls_mpi_mod_mpi
        16   -> mbedtls_mpi_mul_mpi
        16   -> mbedtls_mpi_sub_abs
      16   mbedtls_mpi_shift_l_mod
        16   -> mbedtls_mpi_cmp_mpi
        16   -> mbedtls_mpi_shift_l
        16   -> mbedtls_mpi_sub_abs
      16   mbedtls_mpi_sub_mod
        16   -> mbedtls_mpi_add_mpi
        16   -> mbedtls_mpi_cmp_int
        16   -> mbedtls_mpi_sub_mpi
       4   mbedtls_put_unaligned_uint16
      16   mpi_free_many
        16   -> mbedtls_mpi_free
      16   mpi_init_many
        16   -> mbedtls_mpi_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable20
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??Subroutine26_0
       8  ??Subroutine27_0
       4  ??Subroutine28_0
       4  ??Subroutine29_0
       4  ?Subroutine0
      34  ?Subroutine1
      14  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
      10  ?Subroutine13
      12  ?Subroutine14
       8  ?Subroutine15
       8  ?Subroutine16
       8  ?Subroutine17
      12  ?Subroutine18
       8  ?Subroutine19
       8  ?Subroutine2
      16  ?Subroutine20
      12  ?Subroutine21
      10  ?Subroutine22
       6  ?Subroutine23
      14  ?Subroutine24
      10  ?Subroutine25
      10  ?Subroutine3
       8  ?Subroutine4
       8  ?Subroutine5
       8  ?Subroutine6
      10  ?Subroutine7
      10  ?Subroutine8
      12  ?Subroutine9
      12  ?_0
       4  ?_1
     412  ecp_add_mixed
     392  ecp_double_jac
     830  ecp_mul_restartable_internal
     110  ecp_normalize_jac
     292  ecp_normalize_jac_many
     114  ecp_randomize_jac
      62  ecp_safe_invert_jac
     106  ecp_select_comb
      24  ecp_supported_curves
       8  ecp_supported_grp_id
          init_done
       2  mbedtls_byte_order_detector
      44  mbedtls_ecp_check_privkey
     176  mbedtls_ecp_check_pub_priv
     244  mbedtls_ecp_check_pubkey
      44  mbedtls_ecp_copy
      24  mbedtls_ecp_curve_info_from_grp_id
      38  mbedtls_ecp_curve_info_from_name
      26  mbedtls_ecp_curve_info_from_tls_id
       4  mbedtls_ecp_curve_list
      46  mbedtls_ecp_export
      38  mbedtls_ecp_gen_key
      22  mbedtls_ecp_gen_keypair
      48  mbedtls_ecp_gen_keypair_base
      48  mbedtls_ecp_gen_privkey
      20  mbedtls_ecp_get_type
      12  mbedtls_ecp_group_a_is_minus_3
       6  mbedtls_ecp_group_copy
      96  mbedtls_ecp_group_free
      68  mbedtls_ecp_group_init
      44  mbedtls_ecp_grp_id_list
      18  mbedtls_ecp_is_zero
      30  mbedtls_ecp_keypair_free
      26  mbedtls_ecp_keypair_init
      12  mbedtls_ecp_mul
      32  mbedtls_ecp_mul_restartable
     178  mbedtls_ecp_mul_shortcuts
      12  mbedtls_ecp_muladd
     132  mbedtls_ecp_muladd_restartable
      46  mbedtls_ecp_point_cmp
      32  mbedtls_ecp_point_free
      28  mbedtls_ecp_point_init
     136  mbedtls_ecp_point_read_binary
      44  mbedtls_ecp_point_read_string
     172  mbedtls_ecp_point_write_binary
      70  mbedtls_ecp_read_key
      40  mbedtls_ecp_set_zero
      24  mbedtls_ecp_tls_read_group
      82  mbedtls_ecp_tls_read_group_id
      44  mbedtls_ecp_tls_read_point
      70  mbedtls_ecp_tls_write_group
      54  mbedtls_ecp_tls_write_point
      36  mbedtls_ecp_write_key
      22  mbedtls_get_unaligned_uint16
      12  mbedtls_mpi_add_mod
      10  mbedtls_mpi_mul_int_mod
     136  mbedtls_mpi_mul_mod
      16  mbedtls_mpi_shift_l_mod
      56  mbedtls_mpi_sub_mod
      18  mbedtls_put_unaligned_uint16
      26  mpi_free_many
      26  mpi_init_many

 
     8 bytes in section .bss
    16 bytes in section .rodata
 5'360 bytes in section .text
 
 5'320 bytes of CODE  memory (+ 40 bytes shared)
    16 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
