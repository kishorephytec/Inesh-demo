###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:44
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\sha256.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\sha256.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\sha256.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\sha256.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\sha256.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\sha256.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\sha256.c
      1          /*
      2           *  FIPS-180-2 compliant SHA-256 implementation
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           *  The SHA-256 Secure Hash Standard was published by NIST in 2002.
     21           *
     22           *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
     23           */
     24          
     25          #if defined(__aarch64__) && !defined(__ARM_FEATURE_CRYPTO) && \
     26              defined(__clang__) && __clang_major__ >= 4
     27          /* TODO: Re-consider above after https://reviews.llvm.org/D131064 merged.
     28           *
     29           * The intrinsic declaration are guarded by predefined ACLE macros in clang:
     30           * these are normally only enabled by the -march option on the command line.
     31           * By defining the macros ourselves we gain access to those declarations without
     32           * requiring -march on the command line.
     33           *
     34           * `arm_neon.h` could be included by any header file, so we put these defines
     35           * at the top of this file, before any includes.
     36           */
     37          #define __ARM_FEATURE_CRYPTO 1
     38          /* See: https://arm-software.github.io/acle/main/acle.html#cryptographic-extensions
     39           *
     40           * `__ARM_FEATURE_CRYPTO` is deprecated, but we need to continue to specify it
     41           * for older compilers.
     42           */
     43          #define __ARM_FEATURE_SHA2   1
     44          #define MBEDTLS_ENABLE_ARM_CRYPTO_EXTENSIONS_COMPILER_FLAG
     45          #endif
     46          
     47          #include "common.h"
     48          
     49          #if defined(MBEDTLS_SHA256_C) || defined(MBEDTLS_SHA224_C)
     50          
     51          #include "mbedtls/sha256.h"
     52          #include "mbedtls/platform_util.h"
     53          #include "mbedtls/error.h"
     54          
     55          #include <string.h>
     56          
     57          #include "mbedtls/platform.h"
     58          
     59          #if defined(__aarch64__)
     60          
     61          #  if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT) || \
     62              defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)
     63          
     64          /* *INDENT-OFF* */
     65          
     66          #   ifdef __ARM_NEON
     67          #       include <arm_neon.h>
     68          #   else
     69          #       error "Target does not support NEON instructions"
     70          #   endif
     71          
     72          #    if !defined(__ARM_FEATURE_CRYPTO) || defined(MBEDTLS_ENABLE_ARM_CRYPTO_EXTENSIONS_COMPILER_FLAG)
     73          #      if defined(__ARMCOMPILER_VERSION)
     74          #        if __ARMCOMPILER_VERSION <= 6090000
     75          #          error "Must use minimum -march=armv8-a+crypto for MBEDTLS_SHA256_USE_A64_CRYPTO_*"
     76          #        endif
     77          #          pragma clang attribute push (__attribute__((target("sha2"))), apply_to=function)
     78          #          define MBEDTLS_POP_TARGET_PRAGMA
     79          #      elif defined(__clang__)
     80          #        if __clang_major__ < 4
     81          #          error "A more recent Clang is required for MBEDTLS_SHA256_USE_A64_CRYPTO_*"
     82          #        endif
     83          #        pragma clang attribute push (__attribute__((target("crypto"))), apply_to=function)
     84          #        define MBEDTLS_POP_TARGET_PRAGMA
     85          #      elif defined(__GNUC__)
     86                   /* FIXME: GCC 5 claims to support Armv8 Crypto Extensions, but some
     87                    *        intrinsics are missing. Missing intrinsics could be worked around.
     88                    */
     89          #        if __GNUC__ < 6
     90          #          error "A more recent GCC is required for MBEDTLS_SHA256_USE_A64_CRYPTO_*"
     91          #        else
     92          #          pragma GCC push_options
     93          #          pragma GCC target ("arch=armv8-a+crypto")
     94          #          define MBEDTLS_POP_TARGET_PRAGMA
     95          #        endif
     96          #      else
     97          #        error "Only GCC and Clang supported for MBEDTLS_SHA256_USE_A64_CRYPTO_*"
     98          #      endif
     99          #    endif
    100          /* *INDENT-ON* */
    101          
    102          #  endif
    103          #  if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT)
    104          #    if defined(__unix__)
    105          #      if defined(__linux__)
    106          /* Our preferred method of detection is getauxval() */
    107          #        include <sys/auxv.h>
    108          #      endif
    109          /* Use SIGILL on Unix, and fall back to it on Linux */
    110          #      include <signal.h>
    111          #    endif
    112          #  endif
    113          #elif defined(_M_ARM64)
    114          #  if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT) || \
    115              defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)
    116          #    include <arm64_neon.h>
    117          #  endif
    118          #else
    119          #  undef MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY
    120          #  undef MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT
    121          #endif
    122          
    123          #if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT)
    124          /*
    125           * Capability detection code comes early, so we can disable
    126           * MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT if no detection mechanism found
    127           */
    128          #if defined(HWCAP_SHA2)
    129          static int mbedtls_a64_crypto_sha256_determine_support(void)
    130          {
    131              return (getauxval(AT_HWCAP) & HWCAP_SHA2) ? 1 : 0;
    132          }
    133          #elif defined(__APPLE__)
    134          static int mbedtls_a64_crypto_sha256_determine_support(void)
    135          {
    136              return 1;
    137          }
    138          #elif defined(_M_ARM64)
    139          #define WIN32_LEAN_AND_MEAN
    140          #include <Windows.h>
    141          #include <processthreadsapi.h>
    142          
    143          static int mbedtls_a64_crypto_sha256_determine_support(void)
    144          {
    145              return IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE) ?
    146                     1 : 0;
    147          }
    148          #elif defined(__unix__) && defined(SIG_SETMASK)
    149          /* Detection with SIGILL, setjmp() and longjmp() */
    150          #include <signal.h>
    151          #include <setjmp.h>
    152          
    153          static jmp_buf return_from_sigill;
    154          
    155          /*
    156           * A64 SHA256 support detection via SIGILL
    157           */
    158          static void sigill_handler(int signal)
    159          {
    160              (void) signal;
    161              longjmp(return_from_sigill, 1);
    162          }
    163          
    164          static int mbedtls_a64_crypto_sha256_determine_support(void)
    165          {
    166              struct sigaction old_action, new_action;
    167          
    168              sigset_t old_mask;
    169              if (sigprocmask(0, NULL, &old_mask)) {
    170                  return 0;
    171              }
    172          
    173              sigemptyset(&new_action.sa_mask);
    174              new_action.sa_flags = 0;
    175              new_action.sa_handler = sigill_handler;
    176          
    177              sigaction(SIGILL, &new_action, &old_action);
    178          
    179              static int ret = 0;
    180          
    181              if (setjmp(return_from_sigill) == 0) {         /* First return only */
    182                  /* If this traps, we will return a second time from setjmp() with 1 */
    183                  asm ("sha256h q0, q0, v0.4s" : : : "v0");
    184                  ret = 1;
    185              }
    186          
    187              sigaction(SIGILL, &old_action, NULL);
    188              sigprocmask(SIG_SETMASK, &old_mask, NULL);
    189          
    190              return ret;
    191          }
    192          #else
    193          #warning "No mechanism to detect A64_CRYPTO found, using C code only"
    194          #undef MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT
    195          #endif  /* HWCAP_SHA2, __APPLE__, __unix__ && SIG_SETMASK */
    196          
    197          #endif  /* MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT */
    198          
    199          #if !defined(MBEDTLS_SHA256_ALT)
    200          
    201          #define SHA256_BLOCK_SIZE 64
    202          
    203          void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
    204          {
    205              memset(ctx, 0, sizeof(mbedtls_sha256_context));
    206          }
    207          
    208          void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
    209          {
    210              if (ctx == NULL) {
    211                  return;
    212              }
    213          
    214              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_sha256_context));
    215          }
    216          
    217          void mbedtls_sha256_clone(mbedtls_sha256_context *dst,
    218                                    const mbedtls_sha256_context *src)
    219          {
    220              *dst = *src;
    221          }
    222          
    223          /*
    224           * SHA-256 context setup
    225           */
    226          int mbedtls_sha256_starts(mbedtls_sha256_context *ctx, int is224)
    227          {
    228          #if defined(MBEDTLS_SHA224_C) && defined(MBEDTLS_SHA256_C)
    229              if (is224 != 0 && is224 != 1) {
    230                  return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
    231              }
    232          #elif defined(MBEDTLS_SHA256_C)
    233              if (is224 != 0) {
    234                  return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
    235              }
    236          #else /* defined MBEDTLS_SHA224_C only */
    237              if (is224 == 0) {
    238                  return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
    239              }
    240          #endif
    241          
    242              ctx->total[0] = 0;
    243              ctx->total[1] = 0;
    244          
    245              if (is224 == 0) {
    246          #if defined(MBEDTLS_SHA256_C)
    247                  ctx->state[0] = 0x6A09E667;
    248                  ctx->state[1] = 0xBB67AE85;
    249                  ctx->state[2] = 0x3C6EF372;
    250                  ctx->state[3] = 0xA54FF53A;
    251                  ctx->state[4] = 0x510E527F;
    252                  ctx->state[5] = 0x9B05688C;
    253                  ctx->state[6] = 0x1F83D9AB;
    254                  ctx->state[7] = 0x5BE0CD19;
    255          #endif
    256              } else {
    257          #if defined(MBEDTLS_SHA224_C)
    258                  ctx->state[0] = 0xC1059ED8;
    259                  ctx->state[1] = 0x367CD507;
    260                  ctx->state[2] = 0x3070DD17;
    261                  ctx->state[3] = 0xF70E5939;
    262                  ctx->state[4] = 0xFFC00B31;
    263                  ctx->state[5] = 0x68581511;
    264                  ctx->state[6] = 0x64F98FA7;
    265                  ctx->state[7] = 0xBEFA4FA4;
    266          #endif
    267              }
    268          
    269          #if defined(MBEDTLS_SHA224_C)
    270              ctx->is224 = is224;
    271          #endif
    272          
    273              return 0;
    274          }
    275          
    276          #if !defined(MBEDTLS_SHA256_PROCESS_ALT)
    277          static const uint32_t K[] =
    278          {
    279              0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
    280              0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
    281              0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
    282              0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
    283              0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
    284              0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
    285              0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
    286              0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
    287              0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
    288              0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
    289              0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
    290              0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
    291              0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
    292              0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
    293              0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
    294              0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2,
    295          };
    296          
    297          #endif
    298          
    299          #if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT) || \
    300              defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)
    301          
    302          #if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)
    303          #  define mbedtls_internal_sha256_process_many_a64_crypto mbedtls_internal_sha256_process_many
    304          #  define mbedtls_internal_sha256_process_a64_crypto      mbedtls_internal_sha256_process
    305          #endif
    306          
    307          static size_t mbedtls_internal_sha256_process_many_a64_crypto(
    308              mbedtls_sha256_context *ctx, const uint8_t *msg, size_t len)
    309          {
    310              uint32x4_t abcd = vld1q_u32(&ctx->state[0]);
    311              uint32x4_t efgh = vld1q_u32(&ctx->state[4]);
    312          
    313              size_t processed = 0;
    314          
    315              for (;
    316                   len >= SHA256_BLOCK_SIZE;
    317                   processed += SHA256_BLOCK_SIZE,
    318                   msg += SHA256_BLOCK_SIZE,
    319                   len -= SHA256_BLOCK_SIZE) {
    320                  uint32x4_t tmp, abcd_prev;
    321          
    322                  uint32x4_t abcd_orig = abcd;
    323                  uint32x4_t efgh_orig = efgh;
    324          
    325                  uint32x4_t sched0 = (uint32x4_t) vld1q_u8(msg + 16 * 0);
    326                  uint32x4_t sched1 = (uint32x4_t) vld1q_u8(msg + 16 * 1);
    327                  uint32x4_t sched2 = (uint32x4_t) vld1q_u8(msg + 16 * 2);
    328                  uint32x4_t sched3 = (uint32x4_t) vld1q_u8(msg + 16 * 3);
    329          
    330          #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__  /* Will be true if not defined */
    331                                                         /* Untested on BE */
    332                  sched0 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(sched0)));
    333                  sched1 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(sched1)));
    334                  sched2 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(sched2)));
    335                  sched3 = vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(sched3)));
    336          #endif
    337          
    338                  /* Rounds 0 to 3 */
    339                  tmp = vaddq_u32(sched0, vld1q_u32(&K[0]));
    340                  abcd_prev = abcd;
    341                  abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    342                  efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    343          
    344                  /* Rounds 4 to 7 */
    345                  tmp = vaddq_u32(sched1, vld1q_u32(&K[4]));
    346                  abcd_prev = abcd;
    347                  abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    348                  efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    349          
    350                  /* Rounds 8 to 11 */
    351                  tmp = vaddq_u32(sched2, vld1q_u32(&K[8]));
    352                  abcd_prev = abcd;
    353                  abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    354                  efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    355          
    356                  /* Rounds 12 to 15 */
    357                  tmp = vaddq_u32(sched3, vld1q_u32(&K[12]));
    358                  abcd_prev = abcd;
    359                  abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    360                  efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    361          
    362                  for (int t = 16; t < 64; t += 16) {
    363                      /* Rounds t to t + 3 */
    364                      sched0 = vsha256su1q_u32(vsha256su0q_u32(sched0, sched1), sched2, sched3);
    365                      tmp = vaddq_u32(sched0, vld1q_u32(&K[t]));
    366                      abcd_prev = abcd;
    367                      abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    368                      efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    369          
    370                      /* Rounds t + 4 to t + 7 */
    371                      sched1 = vsha256su1q_u32(vsha256su0q_u32(sched1, sched2), sched3, sched0);
    372                      tmp = vaddq_u32(sched1, vld1q_u32(&K[t + 4]));
    373                      abcd_prev = abcd;
    374                      abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    375                      efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    376          
    377                      /* Rounds t + 8 to t + 11 */
    378                      sched2 = vsha256su1q_u32(vsha256su0q_u32(sched2, sched3), sched0, sched1);
    379                      tmp = vaddq_u32(sched2, vld1q_u32(&K[t + 8]));
    380                      abcd_prev = abcd;
    381                      abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    382                      efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    383          
    384                      /* Rounds t + 12 to t + 15 */
    385                      sched3 = vsha256su1q_u32(vsha256su0q_u32(sched3, sched0), sched1, sched2);
    386                      tmp = vaddq_u32(sched3, vld1q_u32(&K[t + 12]));
    387                      abcd_prev = abcd;
    388                      abcd = vsha256hq_u32(abcd_prev, efgh, tmp);
    389                      efgh = vsha256h2q_u32(efgh, abcd_prev, tmp);
    390                  }
    391          
    392                  abcd = vaddq_u32(abcd, abcd_orig);
    393                  efgh = vaddq_u32(efgh, efgh_orig);
    394              }
    395          
    396              vst1q_u32(&ctx->state[0], abcd);
    397              vst1q_u32(&ctx->state[4], efgh);
    398          
    399              return processed;
    400          }
    401          
    402          #if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT)
    403          /*
    404           * This function is for internal use only if we are building both C and A64
    405           * versions, otherwise it is renamed to be the public mbedtls_internal_sha256_process()
    406           */
    407          static
    408          #endif
    409          int mbedtls_internal_sha256_process_a64_crypto(mbedtls_sha256_context *ctx,
    410                                                         const unsigned char data[SHA256_BLOCK_SIZE])
    411          {
    412              return (mbedtls_internal_sha256_process_many_a64_crypto(ctx, data,
    413                                                                      SHA256_BLOCK_SIZE) ==
    414                      SHA256_BLOCK_SIZE) ? 0 : -1;
    415          }
    416          
    417          #endif /* MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT || MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY */
    418          
    419          #if defined(MBEDTLS_POP_TARGET_PRAGMA)
    420          #if defined(__clang__)
    421          #pragma clang attribute pop
    422          #elif defined(__GNUC__)
    423          #pragma GCC pop_options
    424          #endif
    425          #undef MBEDTLS_POP_TARGET_PRAGMA
    426          #endif
    427          
    428          #if !defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT)
    429          #define mbedtls_internal_sha256_process_many_c mbedtls_internal_sha256_process_many
    430          #define mbedtls_internal_sha256_process_c      mbedtls_internal_sha256_process
    431          #endif
    432          
    433          
    434          #if !defined(MBEDTLS_SHA256_PROCESS_ALT) && \
    435              !defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)
    436          
    437          #define  SHR(x, n) (((x) & 0xFFFFFFFF) >> (n))
    438          #define ROTR(x, n) (SHR(x, n) | ((x) << (32 - (n))))
    439          
    440          #define S0(x) (ROTR(x, 7) ^ ROTR(x, 18) ^  SHR(x, 3))
    441          #define S1(x) (ROTR(x, 17) ^ ROTR(x, 19) ^  SHR(x, 10))
    442          
    443          #define S2(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
    444          #define S3(x) (ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
    445          
    446          #define F0(x, y, z) (((x) & (y)) | ((z) & ((x) | (y))))
    447          #define F1(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
    448          
    449          #define R(t)                                                        \
    450              (                                                               \
    451                  local.W[t] = S1(local.W[(t) -  2]) + local.W[(t) -  7] +    \
    452                               S0(local.W[(t) - 15]) + local.W[(t) - 16]      \
    453              )
    454          
    455          #define P(a, b, c, d, e, f, g, h, x, K)                                      \
    456              do                                                              \
    457              {                                                               \
    458                  local.temp1 = (h) + S3(e) + F1((e), (f), (g)) + (K) + (x);    \
    459                  local.temp2 = S2(a) + F0((a), (b), (c));                      \
    460                  (d) += local.temp1; (h) = local.temp1 + local.temp2;        \
    461              } while (0)
    462          
    463          #if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT)
    464          /*
    465           * This function is for internal use only if we are building both C and A64
    466           * versions, otherwise it is renamed to be the public mbedtls_internal_sha256_process()
    467           */
    468          static
    469          #endif
    470          int mbedtls_internal_sha256_process_c(mbedtls_sha256_context *ctx,
    471                                                const unsigned char data[SHA256_BLOCK_SIZE])
    472          {
    473              struct {
    474                  uint32_t temp1, temp2, W[64];
    475                  uint32_t A[8];
    476              } local;
    477          
    478              unsigned int i;
    479          
    480              for (i = 0; i < 8; i++) {
    481                  local.A[i] = ctx->state[i];
    482              }
    483          
    484          #if defined(MBEDTLS_SHA256_SMALLER)
    485              for (i = 0; i < 64; i++) {
    486                  if (i < 16) {
    487                      local.W[i] = MBEDTLS_GET_UINT32_BE(data, 4 * i);
    488                  } else {
    489                      R(i);
    490                  }
    491          
    492                  P(local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
    493                    local.A[5], local.A[6], local.A[7], local.W[i], K[i]);
    494          
    495                  local.temp1 = local.A[7]; local.A[7] = local.A[6];
    496                  local.A[6] = local.A[5]; local.A[5] = local.A[4];
    497                  local.A[4] = local.A[3]; local.A[3] = local.A[2];
    498                  local.A[2] = local.A[1]; local.A[1] = local.A[0];
    499                  local.A[0] = local.temp1;
    500              }
    501          #else /* MBEDTLS_SHA256_SMALLER */
    502              for (i = 0; i < 16; i++) {
    503                  local.W[i] = MBEDTLS_GET_UINT32_BE(data, 4 * i);
    504              }
    505          
    506              for (i = 0; i < 16; i += 8) {
    507                  P(local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
    508                    local.A[5], local.A[6], local.A[7], local.W[i+0], K[i+0]);
    509                  P(local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
    510                    local.A[4], local.A[5], local.A[6], local.W[i+1], K[i+1]);
    511                  P(local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
    512                    local.A[3], local.A[4], local.A[5], local.W[i+2], K[i+2]);
    513                  P(local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
    514                    local.A[2], local.A[3], local.A[4], local.W[i+3], K[i+3]);
    515                  P(local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
    516                    local.A[1], local.A[2], local.A[3], local.W[i+4], K[i+4]);
    517                  P(local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
    518                    local.A[0], local.A[1], local.A[2], local.W[i+5], K[i+5]);
    519                  P(local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
    520                    local.A[7], local.A[0], local.A[1], local.W[i+6], K[i+6]);
    521                  P(local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
    522                    local.A[6], local.A[7], local.A[0], local.W[i+7], K[i+7]);
    523              }
    524          
    525              for (i = 16; i < 64; i += 8) {
    526                  P(local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
    527                    local.A[5], local.A[6], local.A[7], R(i+0), K[i+0]);
    528                  P(local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
    529                    local.A[4], local.A[5], local.A[6], R(i+1), K[i+1]);
    530                  P(local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
    531                    local.A[3], local.A[4], local.A[5], R(i+2), K[i+2]);
    532                  P(local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
    533                    local.A[2], local.A[3], local.A[4], R(i+3), K[i+3]);
    534                  P(local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
    535                    local.A[1], local.A[2], local.A[3], R(i+4), K[i+4]);
    536                  P(local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
    537                    local.A[0], local.A[1], local.A[2], R(i+5), K[i+5]);
    538                  P(local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
    539                    local.A[7], local.A[0], local.A[1], R(i+6), K[i+6]);
    540                  P(local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
    541                    local.A[6], local.A[7], local.A[0], R(i+7), K[i+7]);
    542              }
    543          #endif /* MBEDTLS_SHA256_SMALLER */
    544          
    545              for (i = 0; i < 8; i++) {
    546                  ctx->state[i] += local.A[i];
    547              }
    548          
    549              /* Zeroise buffers and variables to clear sensitive data from memory. */
    550              mbedtls_platform_zeroize(&local, sizeof(local));
    551          
    552              return 0;
    553          }
    554          
    555          #endif /* !MBEDTLS_SHA256_PROCESS_ALT && !MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY */
    556          
    557          
    558          #if !defined(MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY)
    559          
    560          static size_t mbedtls_internal_sha256_process_many_c(
    561              mbedtls_sha256_context *ctx, const uint8_t *data, size_t len)
    562          {
    563              size_t processed = 0;
    564          
    565              while (len >= SHA256_BLOCK_SIZE) {
    566                  if (mbedtls_internal_sha256_process_c(ctx, data) != 0) {
    567                      return 0;
    568                  }
    569          
    570                  data += SHA256_BLOCK_SIZE;
    571                  len  -= SHA256_BLOCK_SIZE;
    572          
    573                  processed += SHA256_BLOCK_SIZE;
    574              }
    575          
    576              return processed;
    577          }
    578          
    579          #endif /* !MBEDTLS_SHA256_USE_A64_CRYPTO_ONLY */
    580          
    581          
    582          #if defined(MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT)
    583          
    584          static int mbedtls_a64_crypto_sha256_has_support(void)
    585          {
    586              static int done = 0;
    587              static int supported = 0;
    588          
    589              if (!done) {
    590                  supported = mbedtls_a64_crypto_sha256_determine_support();
    591                  done = 1;
    592              }
    593          
    594              return supported;
    595          }
    596          
    597          static size_t mbedtls_internal_sha256_process_many(mbedtls_sha256_context *ctx,
    598                                                             const uint8_t *msg, size_t len)
    599          {
    600              if (mbedtls_a64_crypto_sha256_has_support()) {
    601                  return mbedtls_internal_sha256_process_many_a64_crypto(ctx, msg, len);
    602              } else {
    603                  return mbedtls_internal_sha256_process_many_c(ctx, msg, len);
    604              }
    605          }
    606          
    607          int mbedtls_internal_sha256_process(mbedtls_sha256_context *ctx,
    608                                              const unsigned char data[SHA256_BLOCK_SIZE])
    609          {
    610              if (mbedtls_a64_crypto_sha256_has_support()) {
    611                  return mbedtls_internal_sha256_process_a64_crypto(ctx, data);
    612              } else {
    613                  return mbedtls_internal_sha256_process_c(ctx, data);
    614              }
    615          }
    616          
    617          #endif /* MBEDTLS_SHA256_USE_A64_CRYPTO_IF_PRESENT */
    618          
    619          
    620          /*
    621           * SHA-256 process buffer
    622           */
    623          int mbedtls_sha256_update(mbedtls_sha256_context *ctx,
    624                                    const unsigned char *input,
    625                                    size_t ilen)
    626          {
    627              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    628              size_t fill;
    629              uint32_t left;
    630          
    631              if (ilen == 0) {
    632                  return 0;
    633              }
    634          
    635              left = ctx->total[0] & 0x3F;
    636              fill = SHA256_BLOCK_SIZE - left;
    637          
    638              ctx->total[0] += (uint32_t) ilen;
    639              ctx->total[0] &= 0xFFFFFFFF;
    640          
    641              if (ctx->total[0] < (uint32_t) ilen) {
    642                  ctx->total[1]++;
    643              }
    644          
    645              if (left && ilen >= fill) {
    646                  memcpy((void *) (ctx->buffer + left), input, fill);
    647          
    648                  if ((ret = mbedtls_internal_sha256_process(ctx, ctx->buffer)) != 0) {
    649                      return ret;
    650                  }
    651          
    652                  input += fill;
    653                  ilen  -= fill;
    654                  left = 0;
    655              }
    656          
    657              while (ilen >= SHA256_BLOCK_SIZE) {
    658                  size_t processed =
    659                      mbedtls_internal_sha256_process_many(ctx, input, ilen);
    660                  if (processed < SHA256_BLOCK_SIZE) {
    661                      return MBEDTLS_ERR_ERROR_GENERIC_ERROR;
    662                  }
    663          
    664                  input += processed;
    665                  ilen  -= processed;
    666              }
    667          
    668              if (ilen > 0) {
    669                  memcpy((void *) (ctx->buffer + left), input, ilen);
    670              }
    671          
    672              return 0;
    673          }
    674          
    675          /*
    676           * SHA-256 final digest
    677           */
    678          int mbedtls_sha256_finish(mbedtls_sha256_context *ctx,
    679                                    unsigned char *output)
    680          {
    681              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    682              uint32_t used;
    683              uint32_t high, low;
    684              int truncated = 0;
    685          
    686              /*
    687               * Add padding: 0x80 then 0x00 until 8 bytes remain for the length
    688               */
    689              used = ctx->total[0] & 0x3F;
    690          
    691              ctx->buffer[used++] = 0x80;
    692          
    693              if (used <= 56) {
    694                  /* Enough room for padding + length in current block */
    695                  memset(ctx->buffer + used, 0, 56 - used);
    696              } else {
    697                  /* We'll need an extra block */
    698                  memset(ctx->buffer + used, 0, SHA256_BLOCK_SIZE - used);
    699          
    700                  if ((ret = mbedtls_internal_sha256_process(ctx, ctx->buffer)) != 0) {
    701                      goto exit;
    702                  }
    703          
    704                  memset(ctx->buffer, 0, 56);
    705              }
    706          
    707              /*
    708               * Add message length
    709               */
    710              high = (ctx->total[0] >> 29)
    711                     | (ctx->total[1] <<  3);
    712              low  = (ctx->total[0] <<  3);
    713          
    714              MBEDTLS_PUT_UINT32_BE(high, ctx->buffer, 56);
    715              MBEDTLS_PUT_UINT32_BE(low,  ctx->buffer, 60);
    716          
    717              if ((ret = mbedtls_internal_sha256_process(ctx, ctx->buffer)) != 0) {
    718                  goto exit;
    719              }
    720          
    721              /*
    722               * Output final state
    723               */
    724              MBEDTLS_PUT_UINT32_BE(ctx->state[0], output,  0);
    725              MBEDTLS_PUT_UINT32_BE(ctx->state[1], output,  4);
    726              MBEDTLS_PUT_UINT32_BE(ctx->state[2], output,  8);
    727              MBEDTLS_PUT_UINT32_BE(ctx->state[3], output, 12);
    728              MBEDTLS_PUT_UINT32_BE(ctx->state[4], output, 16);
    729              MBEDTLS_PUT_UINT32_BE(ctx->state[5], output, 20);
    730              MBEDTLS_PUT_UINT32_BE(ctx->state[6], output, 24);
    731          
    732          #if defined(MBEDTLS_SHA224_C)
    733              truncated = ctx->is224;
    734          #endif
    735              if (!truncated) {
    736                  MBEDTLS_PUT_UINT32_BE(ctx->state[7], output, 28);
    737              }
    738          
    739              ret = 0;
    740          
    741          exit:
    742              mbedtls_sha256_free(ctx);
    743              return ret;
    744          }
    745          
    746          #endif /* !MBEDTLS_SHA256_ALT */
    747          
    748          /*
    749           * output = SHA-256( input buffer )
    750           */

   \                                 In section .text, align 2, keep-with-next
    751          int mbedtls_sha256(const unsigned char *input,
    752                             size_t ilen,
    753                             unsigned char *output,
    754                             int is224)
    755          {
   \                     mbedtls_sha256: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0B6             SUB      SP,SP,#+216
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x001C             MOVS     R4,R3
    756              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    757              mbedtls_sha256_context ctx;
    758          
    759          #if defined(MBEDTLS_SHA224_C) && defined(MBEDTLS_SHA256_C)
    760              if (is224 != 0 && is224 != 1) {
   \        0xC   0xBF1C             ITT      NE
   \        0xE   0x2C01             CMPNE    R4,#+1
   \       0x10   0xF06F 0x0073      MVNNE    R0,#+115
    761                  return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
   \       0x14   0xD118             BNE.N    ??mbedtls_sha256_0
    762              }
    763          #elif defined(MBEDTLS_SHA256_C)
    764              if (is224 != 0) {
    765                  return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
    766              }
    767          #else /* defined MBEDTLS_SHA224_C only */
    768              if (is224 == 0) {
    769                  return MBEDTLS_ERR_SHA256_BAD_INPUT_DATA;
    770              }
    771          #endif
    772          
    773              mbedtls_sha256_init(&ctx);
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x.... 0x....      BL       mbedtls_sha256_init
    774          
    775              if ((ret = mbedtls_sha256_starts(&ctx, is224)) != 0) {
   \       0x1C   0x4621             MOV      R1,R4
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       mbedtls_sha256_starts
   \       0x24   0x0004             MOVS     R4,R0
   \       0x26   0xD10B             BNE.N    ??mbedtls_sha256_1
    776                  goto exit;
    777              }
    778          
    779              if ((ret = mbedtls_sha256_update(&ctx, input, ilen)) != 0) {
   \       0x28   0x462A             MOV      R2,R5
   \       0x2A   0x4639             MOV      R1,R7
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x.... 0x....      BL       mbedtls_sha256_update
   \       0x32   0x0004             MOVS     R4,R0
   \       0x34   0xD104             BNE.N    ??mbedtls_sha256_1
    780                  goto exit;
    781              }
    782          
    783              if ((ret = mbedtls_sha256_finish(&ctx, output)) != 0) {
   \       0x36   0x4631             MOV      R1,R6
   \       0x38   0x4668             MOV      R0,SP
   \       0x3A   0x.... 0x....      BL       mbedtls_sha256_finish
   \       0x3E   0x4604             MOV      R4,R0
    784                  goto exit;
    785              }
    786          
    787          exit:
    788              mbedtls_sha256_free(&ctx);
   \                     ??mbedtls_sha256_1: (+1)
   \       0x40   0x4668             MOV      R0,SP
   \       0x42   0x.... 0x....      BL       mbedtls_sha256_free
    789          
    790              return ret;
   \       0x46   0x4620             MOV      R0,R4
   \                     ??mbedtls_sha256_0: (+1)
   \       0x48   0xB037             ADD      SP,SP,#+220
   \       0x4A   0xBDF0             POP      {R4-R7,PC}
    791          }
    792          
    793          #if defined(MBEDTLS_SELF_TEST)
    794          /*
    795           * FIPS-180-2 test vectors
    796           */
    797          static const unsigned char sha_test_buf[3][57] =
    798          {
    799              { "abc" },
    800              { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
    801              { "" }
    802          };
    803          
    804          static const size_t sha_test_buflen[3] =
    805          {
    806              3, 56, 1000
    807          };
    808          
    809          typedef const unsigned char (sha_test_sum_t)[32];
    810          
    811          /*
    812           * SHA-224 test vectors
    813           */
    814          #if defined(MBEDTLS_SHA224_C)
    815          static sha_test_sum_t sha224_test_sum[] =
    816          {
    817              { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22,
    818                0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3,
    819                0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7,
    820                0xE3, 0x6C, 0x9D, 0xA7 },
    821              { 0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC,
    822                0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50,
    823                0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19,
    824                0x52, 0x52, 0x25, 0x25 },
    825              { 0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8,
    826                0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B,
    827                0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE,
    828                0x4E, 0xE7, 0xAD, 0x67 }
    829          };
    830          #endif
    831          
    832          /*
    833           * SHA-256 test vectors
    834           */
    835          #if defined(MBEDTLS_SHA256_C)
    836          static sha_test_sum_t sha256_test_sum[] =
    837          {
    838              { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
    839                0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
    840                0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
    841                0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
    842              { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
    843                0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
    844                0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
    845                0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
    846              { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
    847                0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
    848                0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
    849                0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
    850          };
    851          #endif
    852          
    853          /*
    854           * Checkup routine
    855           */
    856          static int mbedtls_sha256_common_self_test(int verbose, int is224)
    857          {
    858              int i, buflen, ret = 0;
    859              unsigned char *buf;
    860              unsigned char sha256sum[32];
    861              mbedtls_sha256_context ctx;
    862          
    863          #if defined(MBEDTLS_SHA224_C) && defined(MBEDTLS_SHA256_C)
    864              sha_test_sum_t *sha_test_sum = (is224) ? sha224_test_sum : sha256_test_sum;
    865          #elif defined(MBEDTLS_SHA256_C)
    866              sha_test_sum_t *sha_test_sum = sha256_test_sum;
    867          #else
    868              sha_test_sum_t *sha_test_sum = sha224_test_sum;
    869          #endif
    870          
    871              buf = mbedtls_calloc(1024, sizeof(unsigned char));
    872              if (NULL == buf) {
    873                  if (verbose != 0) {
    874                      mbedtls_printf("Buffer allocation failed\n");
    875                  }
    876          
    877                  return 1;
    878              }
    879          
    880              mbedtls_sha256_init(&ctx);
    881          
    882              for (i = 0; i < 3; i++) {
    883                  if (verbose != 0) {
    884                      mbedtls_printf("  SHA-%d test #%d: ", 256 - is224 * 32, i + 1);
    885                  }
    886          
    887                  if ((ret = mbedtls_sha256_starts(&ctx, is224)) != 0) {
    888                      goto fail;
    889                  }
    890          
    891                  if (i == 2) {
    892                      memset(buf, 'a', buflen = 1000);
    893          
    894                      for (int j = 0; j < 1000; j++) {
    895                          ret = mbedtls_sha256_update(&ctx, buf, buflen);
    896                          if (ret != 0) {
    897                              goto fail;
    898                          }
    899                      }
    900          
    901                  } else {
    902                      ret = mbedtls_sha256_update(&ctx, sha_test_buf[i],
    903                                                  sha_test_buflen[i]);
    904                      if (ret != 0) {
    905                          goto fail;
    906                      }
    907                  }
    908          
    909                  if ((ret = mbedtls_sha256_finish(&ctx, sha256sum)) != 0) {
    910                      goto fail;
    911                  }
    912          
    913          
    914                  if (memcmp(sha256sum, sha_test_sum[i], 32 - is224 * 4) != 0) {
    915                      ret = 1;
    916                      goto fail;
    917                  }
    918          
    919                  if (verbose != 0) {
    920                      mbedtls_printf("passed\n");
    921                  }
    922              }
    923          
    924              if (verbose != 0) {
    925                  mbedtls_printf("\n");
    926              }
    927          
    928              goto exit;
    929          
    930          fail:
    931              if (verbose != 0) {
    932                  mbedtls_printf("failed\n");
    933              }
    934          
    935          exit:
    936              mbedtls_sha256_free(&ctx);
    937              mbedtls_free(buf);
    938          
    939              return ret;
    940          }
    941          
    942          #if defined(MBEDTLS_SHA256_C)
    943          int mbedtls_sha256_self_test(int verbose)
    944          {
    945              return mbedtls_sha256_common_self_test(verbose, 0);
    946          }
    947          #endif /* MBEDTLS_SHA256_C */
    948          
    949          #if defined(MBEDTLS_SHA224_C)
    950          int mbedtls_sha224_self_test(int verbose)
    951          {
    952              return mbedtls_sha256_common_self_test(verbose, 1);
    953          }
    954          #endif /* MBEDTLS_SHA224_C */
    955          
    956          #endif /* MBEDTLS_SELF_TEST */
    957          
    958          #endif /* MBEDTLS_SHA256_C || MBEDTLS_SHA224_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     240   mbedtls_sha256
       240   -> mbedtls_sha256_finish
       240   -> mbedtls_sha256_free
       240   -> mbedtls_sha256_init
       240   -> mbedtls_sha256_starts
       240   -> mbedtls_sha256_update


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      76  mbedtls_sha256

 
 76 bytes in section .text
 
 76 bytes of CODE memory

Errors: none
Warnings: none
