###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:18:07
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\x509_crt.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\x509_crt.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\x509_crt.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\x509_crt.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\x509_crt.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\x509_crt.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf      =  flags,widths
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\x509_crt.c
      1          /*
      2           *  X.509 certificate parsing and verification
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          /*
     20           *  The ITU-T X.509 standard defines a certificate format for PKI.
     21           *
     22           *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)
     23           *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)
     24           *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)
     25           *
     26           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf
     27           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
     28           *
     29           *  [SIRO] https://cabforum.org/wp-content/uploads/Chunghwatelecom201503cabforumV4.pdf
     30           */
     31          
     32          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp void mbedtls_put_unaligned_uint16(void *, uint16_t)
   \                     mbedtls_put_unaligned_uint16: (+1)
   \        0x0   0xB402             PUSH     {R1}
   \        0x2   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \        0x6   0x7002             STRB     R2,[R0, #+0]
   \        0x8   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \        0xC   0x7042             STRB     R2,[R0, #+1]
   \        0xE   0xB001             ADD      SP,SP,#+4
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint16_t const mbedtls_byte_order_detector
   \                     mbedtls_byte_order_detector:
   \        0x0   0x0100             DC16 256
     33          
     34          #if defined(MBEDTLS_X509_CRT_PARSE_C)
     35          
     36          #include "mbedtls/x509_crt.h"
     37          #include "mbedtls/error.h"
     38          #include "mbedtls/oid.h"
     39          #include "mbedtls/platform_util.h"
     40          
     41          #include <string.h>
     42          
     43          #if defined(MBEDTLS_PEM_PARSE_C)
     44          #include "mbedtls/pem.h"
     45          #endif
     46          
     47          #if defined(MBEDTLS_USE_PSA_CRYPTO)
     48          #include "psa/crypto.h"
     49          #include "psa_util_internal.h"
     50          #include "md_psa.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp uint32_t mbedtls_md_psa_alg_from_type(mbedtls_md_type_t)
   \                     mbedtls_md_psa_alg_from_type: (+1)
   \        0x0   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \        0x4   0x4770             BX       LR
     51          #endif /* MBEDTLS_USE_PSA_CRYPTO */
     52          #include "pk_internal.h"

   \                                 In section .rodata, align 4
   \        0x0   0x0000 0x0000      DC16 0, 0
   \        0x4   0x0000'0000        DC32 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x18   0x0000             DC16 0
   \       0x1A                      DS8 2
   \       0x1C   0x0000'0000        DC32 0x0, 0
   \              0x0000'0000
     53          
     54          #include "mbedtls/platform.h"
     55          
     56          #if defined(MBEDTLS_THREADING_C)
     57          #include "mbedtls/threading.h"
     58          #endif
     59          
     60          #if defined(MBEDTLS_HAVE_TIME)
     61          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
     62          #define WIN32_LEAN_AND_MEAN
     63          #include <windows.h>
     64          #else
     65          #include <time.h>
     66          #endif
     67          #endif
     68          
     69          #if !defined( MBEDTLS_X509_CRT_PARSE_PATH_ALT )
     70          #if defined(MBEDTLS_FS_IO)
     71          #include <stdio.h>
     72          #if !defined(_WIN32) || defined(EFIX64) || defined(EFI32)
     73          #include <sys/types.h>
     74          #include <sys/stat.h>
     75          #if defined(__MBED__)
     76          #include <platform/mbed_retarget.h>
     77          #else
     78          #include <dirent.h>
     79          #endif /* __MBED__ */
     80          #include <errno.h>
     81          #endif /* !_WIN32 || EFIX64 || EFI32 */
     82          #endif
     83          #endif
     84          
     85          /*
     86           * Item in a verification chain: cert and flags for it
     87           */
     88          typedef struct {
     89              mbedtls_x509_crt *crt;
     90              uint32_t flags;
     91          } x509_crt_verify_chain_item;
     92          
     93          /*
     94           * Max size of verification chain: end-entity + intermediates + trusted root
     95           */
     96          #define X509_MAX_VERIFY_CHAIN_SIZE    (MBEDTLS_X509_MAX_INTERMEDIATE_CA + 2)
     97          
     98          /* Default profile. Do not remove items unless there are serious security
     99           * concerns. */

   \                                 In section .text, align 4, keep-with-next
    100          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default =
   \                     mbedtls_x509_crt_profile_default:
   \        0x0   0x0000'0700        DC32 1'792, 268'435'455, 252, 2'048
   \              0x0FFF'FFFF  
   \              0x0000'00FC  
   \              0x0000'0800
    101          {
    102              /* Hashes from SHA-256 and above. Note that this selection
    103               * should be aligned with ssl_preset_default_hashes in ssl_tls.c. */
    104              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
    105              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |
    106              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),
    107              0xFFFFFFF, /* Any PK alg    */
    108          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    109              /* Curves at or above 128-bit security level. Note that this selection
    110               * should be aligned with ssl_preset_default_curves in ssl_tls.c. */
    111              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
    112              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP384R1) |
    113              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP521R1) |
    114              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP256R1) |
    115              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP384R1) |
    116              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP512R1) |
    117              0,
    118          #else /* MBEDTLS_PK_HAVE_ECC_KEYS */
    119              0,
    120          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    121              2048,
    122          };
    123          
    124          /* Next-generation profile. Currently identical to the default, but may
    125           * be tightened at any time. */

   \                                 In section .rodata, align 4
    126          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =
   \                     mbedtls_x509_crt_profile_next:
   \        0x0   0x0000'0700        DC32 1'792, 268'435'455, 2'300, 2'048
   \              0x0FFF'FFFF  
   \              0x0000'08FC  
   \              0x0000'0800
    127          {
    128              /* Hashes from SHA-256 and above. */
    129              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
    130              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |
    131              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),
    132              0xFFFFFFF, /* Any PK alg    */
    133          #if defined(MBEDTLS_ECP_C)
    134              /* Curves at or above 128-bit security level. */
    135              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
    136              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP384R1) |
    137              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP521R1) |
    138              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP256R1) |
    139              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP384R1) |
    140              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_BP512R1) |
    141              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256K1),
    142          #else
    143              0,
    144          #endif
    145              2048,
    146          };
    147          
    148          /*
    149           * NSA Suite B Profile
    150           */

   \                                 In section .rodata, align 4
    151          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =
   \                     mbedtls_x509_crt_profile_suiteb:
   \        0x0   0x0000'0300        DC32 768, 10, 12, 0
   \              0x0000'000A  
   \              0x0000'000C  
   \              0x0000'0000
    152          {
    153              /* Only SHA-256 and 384 */
    154              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
    155              MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384),
    156              /* Only ECDSA */
    157              MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECDSA) |
    158              MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECKEY),
    159          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    160              /* Only NIST P-256 and P-384 */
    161              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
    162              MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP384R1),
    163          #else /* MBEDTLS_PK_HAVE_ECC_KEYS */
    164              0,
    165          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    166              0,
    167          };
    168          
    169          /*
    170           * Empty / all-forbidden profile
    171           */

   \                                 In section .rodata, align 4
    172          const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_none =
   \                     mbedtls_x509_crt_profile_none:
   \        0x0   0x0000'0000        DC32 0, 0, 0, 4'294'967'295
   \              0x0000'0000  
   \              0x0000'0000  
   \              0xFFFF'FFFF
    173          {
    174              0,
    175              0,
    176              0,
    177              (uint32_t) -1,
    178          };
    179          
    180          /*
    181           * Check md_alg against profile
    182           * Return 0 if md_alg is acceptable for this profile, -1 otherwise
    183           */

   \                                 In section .text, align 2, keep-with-next
    184          static int x509_profile_check_md_alg(const mbedtls_x509_crt_profile *profile,
    185                                               mbedtls_md_type_t md_alg)
    186          {
    187              if (md_alg == MBEDTLS_MD_NONE) {
   \                     x509_profile_check_md_alg: (+1)
   \        0x0   0x000A             MOVS     R2,R1
   \        0x2   0xD006             BEQ.N    ??x509_profile_check_md_alg_0
    188                  return -1;
    189              }
    190          
    191              if ((profile->allowed_mds & MBEDTLS_X509_ID_FLAG(md_alg)) != 0) {
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x1E49             SUBS     R1,R1,#+1
   \        0x8   0x40C8             LSRS     R0,R0,R1
   \        0xA   0x07C2             LSLS     R2,R0,#+31
   \        0xC   0xD501             BPL.N    ??x509_profile_check_md_alg_0
    192                  return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
    193              }
    194          
    195              return -1;
   \                     ??x509_profile_check_md_alg_0: (+1)
   \       0x12   0x....             B.N      ?Subroutine0
    196          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#+4294967295
   \        0x4   0x4770             BX       LR
    197          
    198          /*
    199           * Check pk_alg against profile
    200           * Return 0 if pk_alg is acceptable for this profile, -1 otherwise
    201           */

   \                                 In section .text, align 2, keep-with-next
    202          static int x509_profile_check_pk_alg(const mbedtls_x509_crt_profile *profile,
    203                                               mbedtls_pk_type_t pk_alg)
    204          {
    205              if (pk_alg == MBEDTLS_PK_NONE) {
   \                     x509_profile_check_pk_alg: (+1)
   \        0x0   0x000A             MOVS     R2,R1
   \        0x2   0xD006             BEQ.N    ??x509_profile_check_pk_alg_0
    206                  return -1;
    207              }
    208          
    209              if ((profile->allowed_pks & MBEDTLS_X509_ID_FLAG(pk_alg)) != 0) {
   \        0x4   0x6840             LDR      R0,[R0, #+4]
   \        0x6   0x1E49             SUBS     R1,R1,#+1
   \        0x8   0x40C8             LSRS     R0,R0,R1
   \        0xA   0x07C2             LSLS     R2,R0,#+31
   \        0xC   0xD501             BPL.N    ??x509_profile_check_pk_alg_0
    210                  return 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
    211              }
    212          
    213              return -1;
   \                     ??x509_profile_check_pk_alg_0: (+1)
   \       0x12                      REQUIRE ?Subroutine0
   \       0x12                      ;; // Fall through to label ?Subroutine0
    214          }
    215          
    216          /*
    217           * Check key against profile
    218           * Return 0 if pk is acceptable for this profile, -1 otherwise
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          static int x509_profile_check_key(const mbedtls_x509_crt_profile *profile,
    221                                            const mbedtls_pk_context *pk)
    222          {
   \                     x509_profile_check_key: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xB0A8             SUB      SP,SP,#+160
    223              const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type(pk);
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x.... 0x....      BL       mbedtls_pk_get_type
    224          
    225          #if defined(MBEDTLS_RSA_C)
    226              if (pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS) {
    227                  if (mbedtls_pk_get_bitlen(pk) >= profile->rsa_min_bitlen) {
    228                      return 0;
    229                  }
    230          
    231                  return -1;
    232              }
    233          #endif /* MBEDTLS_RSA_C */
    234          
    235          #if defined(MBEDTLS_PK_HAVE_ECC_KEYS)
    236              if (pk_alg == MBEDTLS_PK_ECDSA ||
    237                  pk_alg == MBEDTLS_PK_ECKEY ||
    238                  pk_alg == MBEDTLS_PK_ECKEY_DH) {
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2802             CMPNE    R0,#+2
   \       0x14   0x2803             CMPNE    R0,#+3
   \       0x16   0xD136             BNE.N    ??x509_profile_check_key_0
    239                  const mbedtls_ecp_group_id gid = mbedtls_pk_get_group_id(pk);
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       mbedtls_pk_get_type
   \       0x1E   0x2807             CMP      R0,#+7
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0xD11B             BNE.N    ??x509_profile_check_key_1
   \       0x24   0x2124             MOVS     R1,#+36
   \       0x26   0x.... 0x....      BL       __aeabi_memclr4
   \       0x2A   0x68A0             LDR      R0,[R4, #+8]
   \       0x2C   0x4669             MOV      R1,SP
   \       0x2E   0x.... 0x....      BL       psa_get_key_attributes
   \       0x32   0xBB40             CBNZ.N   R0,??x509_profile_check_key_0
   \       0x34   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x38   0x.... 0x....      LDR.W    R1,??DataTable33
   \       0x3C   0x4001             ANDS     R1,R1,R0
   \       0x3E   0xF5B1 0x4F82      CMP      R1,#+16640
   \       0x42   0xBF18             IT       NE
   \       0x44   0x2000             MOVNE    R0,#+0
   \       0x46   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0xB2C0             UXTB     R0,R0
   \       0x4E   0x.... 0x....      BL       mbedtls_ecc_group_of_psa
   \       0x52   0x4604             MOV      R4,R0
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x.... 0x....      BL       psa_reset_key_attributes
   \       0x5A   0xE00C             B.N      ??x509_profile_check_key_2
   \                     ??x509_profile_check_key_1: (+1)
   \       0x5C   0x4621             MOV      R1,R4
   \       0x5E   0x22A0             MOVS     R2,#+160
   \       0x60   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x.... 0x....      BL       mbedtls_pk_get_type
   \       0x6A   0x1E80             SUBS     R0,R0,#+2
   \       0x6C   0x2802             CMP      R0,#+2
   \       0x6E   0xBF94             ITE      LS
   \       0x70   0x9801             LDRLS    R0,[SP, #+4]
   \       0x72   0x2000             MOVHI    R0,#+0
   \       0x74   0x7804             LDRB     R4,[R0, #+0]
    240          
    241                  if (gid == MBEDTLS_ECP_DP_NONE) {
   \                     ??x509_profile_check_key_2: (+1)
   \       0x76   0xB134             CBZ.N    R4,??x509_profile_check_key_0
    242                      return -1;
    243                  }
    244          
    245                  if ((profile->allowed_curves & MBEDTLS_X509_ID_FLAG(gid)) != 0) {
   \       0x78   0x68A8             LDR      R0,[R5, #+8]
   \       0x7A   0x1E61             SUBS     R1,R4,#+1
   \       0x7C   0x40C8             LSRS     R0,R0,R1
   \       0x7E   0x07C2             LSLS     R2,R0,#+31
   \       0x80   0xBF48             IT       MI
   \       0x82   0x2000             MOVMI    R0,#+0
    246                      return 0;
   \       0x84   0xD401             BMI.N    ??x509_profile_check_key_3
    247                  }
    248          
    249                  return -1;
    250              }
    251          #endif /* MBEDTLS_PK_HAVE_ECC_KEYS */
    252          
    253              return -1;
   \                     ??x509_profile_check_key_0: (+1)
   \       0x86   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??x509_profile_check_key_3: (+1)
   \       0x8A   0xB029             ADD      SP,SP,#+164
   \       0x8C   0xBD30             POP      {R4,R5,PC}
    254          }
    255          
    256          /*
    257           * Like memcmp, but case-insensitive and always returns -1 if different
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          static int x509_memcasecmp(const void *s1, const void *s2, size_t len)
    260          {
   \                     x509_memcasecmp: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    261              size_t i;
    262              unsigned char diff;
    263              const unsigned char *n1 = s1, *n2 = s2;
    264          
    265              for (i = 0; i < len; i++) {
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0xE000             B.N      ??x509_memcasecmp_0
   \                     ??x509_memcasecmp_1: (+1)
   \        0x6   0x1C6D             ADDS     R5,R5,#+1
   \                     ??x509_memcasecmp_0: (+1)
   \        0x8   0x4295             CMP      R5,R2
   \        0xA   0xD20F             BCS.N    ??x509_memcasecmp_2
    266                  diff = n1[i] ^ n2[i];
   \        0xC   0x5D44             LDRB     R4,[R0, R5]
   \        0xE   0x5D4B             LDRB     R3,[R1, R5]
   \       0x10   0x4063             EORS     R3,R3,R4
    267          
    268                  if (diff == 0) {
   \       0x12   0xD0F8             BEQ.N    ??x509_memcasecmp_1
    269                      continue;
    270                  }
    271          
    272                  if (diff == 32 &&
    273                      ((n1[i] >= 'a' && n1[i] <= 'z') ||
    274                       (n1[i] >= 'A' && n1[i] <= 'Z'))) {
   \       0x14   0x2B20             CMP      R3,#+32
   \       0x16   0xD106             BNE.N    ??x509_memcasecmp_3
   \       0x18   0xF1A4 0x0361      SUB      R3,R4,#+97
   \       0x1C   0x2B1A             CMP      R3,#+26
   \       0x1E   0xBF24             ITT      CS
   \       0x20   0x3C41             SUBCS    R4,R4,#+65
   \       0x22   0x2C1A             CMPCS    R4,#+26
   \       0x24   0xD3EF             BCC.N    ??x509_memcasecmp_1
    275                      continue;
    276                  }
    277          
    278                  return -1;
   \                     ??x509_memcasecmp_3: (+1)
   \       0x26   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x2A   0xBD30             POP      {R4,R5,PC}
    279              }
    280          
    281              return 0;
   \                     ??x509_memcasecmp_2: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD30             POP      {R4,R5,PC}
    282          }
    283          
    284          /*
    285           * Return 0 if name matches wildcard, -1 otherwise
    286           */
    287          static int x509_check_wildcard(const char *cn, const mbedtls_x509_buf *name)
    288          {
    289              size_t i;
    290              size_t cn_idx = 0, cn_len = strlen(cn);
    291          
    292              /* We can't have a match if there is no wildcard to match */
    293              if (name->len < 3 || name->p[0] != '*' || name->p[1] != '.') {
    294                  return -1;
    295              }
    296          
    297              for (i = 0; i < cn_len; ++i) {
    298                  if (cn[i] == '.') {
    299                      cn_idx = i;
    300                      break;
    301                  }
    302              }
    303          
    304              if (cn_idx == 0) {
    305                  return -1;
    306              }
    307          
    308              if (cn_len - cn_idx == name->len - 1 &&
    309                  x509_memcasecmp(name->p + 1, cn + cn_idx, name->len - 1) == 0) {
    310                  return 0;
    311              }
    312          
    313              return -1;
    314          }
    315          
    316          /*
    317           * Compare two X.509 strings, case-insensitive, and allowing for some encoding
    318           * variations (but not all).
    319           *
    320           * Return 0 if equal, -1 otherwise.
    321           */
    322          static int x509_string_cmp(const mbedtls_x509_buf *a, const mbedtls_x509_buf *b)
    323          {
    324              if (a->tag == b->tag &&
    325                  a->len == b->len &&
    326                  memcmp(a->p, b->p, b->len) == 0) {
    327                  return 0;
    328              }
    329          
    330              if ((a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
    331                  (b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
    332                  a->len == b->len &&
    333                  x509_memcasecmp(a->p, b->p, b->len) == 0) {
    334                  return 0;
    335              }
    336          
    337              return -1;
    338          }
    339          
    340          /*
    341           * Compare two X.509 Names (aka rdnSequence).
    342           *
    343           * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
    344           * we sometimes return unequal when the full algorithm would return equal,
    345           * but never the other way. (In particular, we don't do Unicode normalisation
    346           * or space folding.)
    347           *
    348           * Return 0 if equal, -1 otherwise.
    349           */

   \                                 In section .text, align 2, keep-with-next
    350          static int x509_name_cmp(const mbedtls_x509_name *a, const mbedtls_x509_name *b)
    351          {
   \                     x509_name_cmp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xE030             B.N      ??x509_name_cmp_0
    352              /* Avoid recursion, it might not be optimised by the compiler */
    353              while (a != NULL || b != NULL) {
    354                  if (a == NULL || b == NULL) {
   \                     ??x509_name_cmp_1: (+1)
   \        0x8   0xB3A4             CBZ.N    R4,??x509_name_cmp_2
    355                      return -1;
    356                  }
    357          
    358                  /* type */
    359                  if (a->oid.tag != b->oid.tag ||
    360                      a->oid.len != b->oid.len ||
    361                      memcmp(a->oid.p, b->oid.p, b->oid.len) != 0) {
   \        0xA   0x6829             LDR      R1,[R5, #+0]
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xBF02             ITTT     EQ
   \       0x12   0x6862             LDREQ    R2,[R4, #+4]
   \       0x14   0x6868             LDREQ    R0,[R5, #+4]
   \       0x16   0x4290             CMPEQ    R0,R2
   \       0x18   0xD12C             BNE.N    ??x509_name_cmp_2
   \       0x1A   0x68A1             LDR      R1,[R4, #+8]
   \       0x1C   0x68A8             LDR      R0,[R5, #+8]
   \       0x1E   0x.... 0x....      BL       memcmp
   \       0x22   0xBB38             CBNZ.N   R0,??x509_name_cmp_2
    362                      return -1;
    363                  }
    364          
    365                  /* value */
    366                  if (x509_string_cmp(&a->val, &b->val) != 0) {
   \       0x24   0x68E6             LDR      R6,[R4, #+12]
   \       0x26   0x68EF             LDR      R7,[R5, #+12]
   \       0x28   0x42B7             CMP      R7,R6
   \       0x2A   0xBF02             ITTT     EQ
   \       0x2C   0x6922             LDREQ    R2,[R4, #+16]
   \       0x2E   0x6928             LDREQ    R0,[R5, #+16]
   \       0x30   0x4290             CMPEQ    R0,R2
   \       0x32   0xD104             BNE.N    ??x509_name_cmp_3
   \       0x34   0x6961             LDR      R1,[R4, #+20]
   \       0x36   0x6968             LDR      R0,[R5, #+20]
   \       0x38   0x.... 0x....      BL       memcmp
   \       0x3C   0xB178             CBZ.N    R0,??x509_name_cmp_4
   \                     ??x509_name_cmp_3: (+1)
   \       0x3E   0x2F0C             CMP      R7,#+12
   \       0x40   0xBF18             IT       NE
   \       0x42   0x2F13             CMPNE    R7,#+19
   \       0x44   0xD116             BNE.N    ??x509_name_cmp_2
   \       0x46   0x2E0C             CMP      R6,#+12
   \       0x48   0xBF11             ITEEE    NE
   \       0x4A   0x2E13             CMPNE    R6,#+19
   \       0x4C   0x6922             LDREQ    R2,[R4, #+16]
   \       0x4E   0x6928             LDREQ    R0,[R5, #+16]
   \       0x50   0x4290             CMPEQ    R0,R2
   \       0x52   0xD10F             BNE.N    ??x509_name_cmp_2
   \       0x54   0x6961             LDR      R1,[R4, #+20]
   \       0x56   0x6968             LDR      R0,[R5, #+20]
   \       0x58   0x.... 0x....      BL       x509_memcasecmp
   \       0x5C   0xB950             CBNZ.N   R0,??x509_name_cmp_2
    367                      return -1;
    368                  }
    369          
    370                  /* structure of the list of sets */
    371                  if (a->next_merged != b->next_merged) {
   \                     ??x509_name_cmp_4: (+1)
   \       0x5E   0x7F29             LDRB     R1,[R5, #+28]
   \       0x60   0x7F20             LDRB     R0,[R4, #+28]
   \       0x62   0x4281             CMP      R1,R0
   \       0x64   0xD106             BNE.N    ??x509_name_cmp_2
    372                      return -1;
    373                  }
    374          
    375                  a = a->next;
   \       0x66   0x69AD             LDR      R5,[R5, #+24]
    376                  b = b->next;
   \       0x68   0x69A4             LDR      R4,[R4, #+24]
   \                     ??x509_name_cmp_0: (+1)
   \       0x6A   0x2D00             CMP      R5,#+0
   \       0x6C   0xD1CC             BNE.N    ??x509_name_cmp_1
   \       0x6E   0xB90C             CBNZ.N   R4,??x509_name_cmp_2
    377              }
    378          
    379              /* a == NULL == b */
    380              return 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??x509_name_cmp_2: (+1)
   \       0x74   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x78   0xBDF2             POP      {R1,R4-R7,PC}
    381          }
    382          
    383          /*
    384           * Reset (init or clear) a verify_chain
    385           */
    386          static void x509_crt_verify_chain_reset(
    387              mbedtls_x509_crt_verify_chain *ver_chain)
    388          {
    389              size_t i;
    390          
    391              for (i = 0; i < MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE; i++) {
    392                  ver_chain->items[i].crt = NULL;
    393                  ver_chain->items[i].flags = (uint32_t) -1;
    394              }
    395          
    396              ver_chain->len = 0;
    397          
    398          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
    399              ver_chain->trust_ca_cb_result = NULL;
    400          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
    401          }
    402          
    403          /*
    404           *  Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
    405           */
    406          static int x509_get_version(unsigned char **p,
    407                                      const unsigned char *end,
    408                                      int *ver)
    409          {
    410              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    411              size_t len;
    412          
    413              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    414                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    415                                              0)) != 0) {
    416                  if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    417                      *ver = 0;
    418                      return 0;
    419                  }
    420          
    421                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
    422              }
    423          
    424              end = *p + len;
    425          
    426              if ((ret = mbedtls_asn1_get_int(p, end, ver)) != 0) {
    427                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_VERSION, ret);
    428              }
    429          
    430              if (*p != end) {
    431                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_VERSION,
    432                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    433              }
    434          
    435              return 0;
    436          }
    437          
    438          /*
    439           *  Validity ::= SEQUENCE {
    440           *       notBefore      Time,
    441           *       notAfter       Time }
    442           */
    443          static int x509_get_dates(unsigned char **p,
    444                                    const unsigned char *end,
    445                                    mbedtls_x509_time *from,
    446                                    mbedtls_x509_time *to)
    447          {
    448              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    449              size_t len;
    450          
    451              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    452                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    453                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE, ret);
    454              }
    455          
    456              end = *p + len;
    457          
    458              if ((ret = mbedtls_x509_get_time(p, end, from)) != 0) {
    459                  return ret;
    460              }
    461          
    462              if ((ret = mbedtls_x509_get_time(p, end, to)) != 0) {
    463                  return ret;
    464              }
    465          
    466              if (*p != end) {
    467                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_DATE,
    468                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    469              }
    470          
    471              return 0;
    472          }
    473          
    474          /*
    475           * X.509 v2/v3 unique identifier (not parsed)
    476           */

   \                                 In section .text, align 2, keep-with-next
    477          static int x509_get_uid(unsigned char **p,
    478                                  const unsigned char *end,
    479                                  mbedtls_x509_buf *uid, int n)
    480          {
   \                     x509_get_uid: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    481              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    482          
    483              if (*p == end) {
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x4288             CMP      R0,R1
   \        0xA   0xD014             BEQ.N    ??x509_get_uid_0
    484                  return 0;
    485              }
    486          
    487              uid->tag = **p;
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
    488          
    489              if ((ret = mbedtls_asn1_get_tag(p, end, &uid->len,
    490                                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    491                                              n)) != 0) {
   \        0xE   0xF043 0x03A0      ORR      R3,R3,#0xA0
   \       0x12   0x1D2A             ADDS     R2,R5,#+4
   \       0x14   0x6028             STR      R0,[R5, #+0]
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x1C   0xB128             CBZ.N    R0,??x509_get_uid_1
    492                  if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
   \       0x1E   0xF110 0x0F62      CMN      R0,#+98
   \       0x22   0xD008             BEQ.N    ??x509_get_uid_0
    493                      return 0;
    494                  }
    495          
    496                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
    497              }
   \       0x24   0xF5A0 0x5006      SUB      R0,R0,#+8576
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
    498          
    499              uid->p = *p;
   \                     ??x509_get_uid_1: (+1)
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x60A9             STR      R1,[R5, #+8]
    500              *p += uid->len;
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6869             LDR      R1,[R5, #+4]
   \       0x32   0x4401             ADD      R1,R0,R1
   \       0x34   0x6021             STR      R1,[R4, #+0]
    501          
    502              return 0;
   \                     ??x509_get_uid_0: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
    503          }
    504          
    505          static int x509_get_basic_constraints(unsigned char **p,
    506                                                const unsigned char *end,
    507                                                int *ca_istrue,
    508                                                int *max_pathlen)
    509          {
    510              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    511              size_t len;
    512          
    513              /*
    514               * BasicConstraints ::= SEQUENCE {
    515               *      cA                      BOOLEAN DEFAULT FALSE,
    516               *      pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
    517               */
    518              *ca_istrue = 0; /* DEFAULT FALSE */
    519              *max_pathlen = 0; /* endless */
    520          
    521              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    522                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    523                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    524              }
    525          
    526              if (*p == end) {
    527                  return 0;
    528              }
    529          
    530              if ((ret = mbedtls_asn1_get_bool(p, end, ca_istrue)) != 0) {
    531                  if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    532                      ret = mbedtls_asn1_get_int(p, end, ca_istrue);
    533                  }
    534          
    535                  if (ret != 0) {
    536                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    537                  }
    538          
    539                  if (*ca_istrue != 0) {
    540                      *ca_istrue = 1;
    541                  }
    542              }
    543          
    544              if (*p == end) {
    545                  return 0;
    546              }
    547          
    548              if ((ret = mbedtls_asn1_get_int(p, end, max_pathlen)) != 0) {
    549                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    550              }
    551          
    552              if (*p != end) {
    553                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    554                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    555              }
    556          
    557              /* Do not accept max_pathlen equal to INT_MAX to avoid a signed integer
    558               * overflow, which is an undefined behavior. */
    559              if (*max_pathlen == INT_MAX) {
    560                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    561                                           MBEDTLS_ERR_ASN1_INVALID_LENGTH);
    562              }
    563          
    564              (*max_pathlen)++;
    565          
    566              return 0;
    567          }
    568          
    569          /*
    570           * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
    571           *
    572           * KeyPurposeId ::= OBJECT IDENTIFIER
    573           */
    574          static int x509_get_ext_key_usage(unsigned char **p,
    575                                            const unsigned char *end,
    576                                            mbedtls_x509_sequence *ext_key_usage)
    577          {
    578              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    579          
    580              if ((ret = mbedtls_asn1_get_sequence_of(p, end, ext_key_usage, MBEDTLS_ASN1_OID)) != 0) {
    581                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    582              }
    583          
    584              /* Sequence length must be >= 1 */
    585              if (ext_key_usage->buf.p == NULL) {
    586                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    587                                           MBEDTLS_ERR_ASN1_INVALID_LENGTH);
    588              }
    589          
    590              return 0;
    591          }
    592          
    593          /*
    594           * SubjectKeyIdentifier ::= KeyIdentifier
    595           *
    596           * KeyIdentifier ::= OCTET STRING
    597           */
    598          static int x509_get_subject_key_id(unsigned char **p,
    599                                             const unsigned char *end,
    600                                             mbedtls_x509_buf *subject_key_id)
    601          {
    602              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    603              size_t len = 0u;
    604          
    605              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    606                                              MBEDTLS_ASN1_OCTET_STRING)) != 0) {
    607                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    608              }
    609          
    610              subject_key_id->len = len;
    611              subject_key_id->tag = MBEDTLS_ASN1_OCTET_STRING;
    612              subject_key_id->p = *p;
    613              *p += len;
    614          
    615              if (*p != end) {
    616                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    617                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    618              }
    619          
    620              return 0;
    621          }
    622          
    623          /*
    624           * AuthorityKeyIdentifier ::= SEQUENCE {
    625           *        keyIdentifier [0] KeyIdentifier OPTIONAL,
    626           *        authorityCertIssuer [1] GeneralNames OPTIONAL,
    627           *        authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL }
    628           *
    629           *    KeyIdentifier ::= OCTET STRING
    630           */
    631          static int x509_get_authority_key_id(unsigned char **p,
    632                                               unsigned char *end,
    633                                               mbedtls_x509_authority *authority_key_id)
    634          {
    635              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    636              size_t len = 0u;
    637          
    638              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    639                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    640                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    641              }
    642          
    643              if (*p + len != end) {
    644                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    645                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    646              }
    647          
    648              ret = mbedtls_asn1_get_tag(p, end, &len,
    649                                         MBEDTLS_ASN1_CONTEXT_SPECIFIC);
    650          
    651              /* KeyIdentifier is an OPTIONAL field */
    652              if (ret == 0) {
    653                  authority_key_id->keyIdentifier.len = len;
    654                  authority_key_id->keyIdentifier.p = *p;
    655                  /* Setting tag of the keyIdentfier intentionally to 0x04.
    656                   * Although the .keyIdentfier field is CONTEXT_SPECIFIC ([0] OPTIONAL),
    657                   * its tag with the content is the payload of on OCTET STRING primitive */
    658                  authority_key_id->keyIdentifier.tag = MBEDTLS_ASN1_OCTET_STRING;
    659          
    660                  *p += len;
    661              } else if (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) {
    662                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    663              }
    664          
    665              if (*p < end) {
    666                  /* Getting authorityCertIssuer using the required specific class tag [1] */
    667                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    668                                                  MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
    669                                                  1)) != 0) {
    670                      /* authorityCertIssuer and authorityCertSerialNumber MUST both
    671                         be present or both be absent. At this point we expect to have both. */
    672                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    673                  }
    674                  /* "end" also includes the CertSerialNumber field so "len" shall be used */
    675                  ret = mbedtls_x509_get_subject_alt_name_ext(p,
    676                                                              (*p+len),
    677                                                              &authority_key_id->authorityCertIssuer);
    678                  if (ret != 0) {
    679                      return ret;
    680                  }
    681          
    682                  /* Getting authorityCertSerialNumber using the required specific class tag [2] */
    683                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    684                                                  MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2)) != 0) {
    685                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    686                  }
    687                  authority_key_id->authorityCertSerialNumber.len = len;
    688                  authority_key_id->authorityCertSerialNumber.p = *p;
    689                  authority_key_id->authorityCertSerialNumber.tag = MBEDTLS_ASN1_INTEGER;
    690                  *p += len;
    691              }
    692          
    693              if (*p != end) {
    694                  return MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
    695                         MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
    696              }
    697          
    698              return 0;
    699          }
    700          
    701          /*
    702           * id-ce-certificatePolicies OBJECT IDENTIFIER ::=  { id-ce 32 }
    703           *
    704           * anyPolicy OBJECT IDENTIFIER ::= { id-ce-certificatePolicies 0 }
    705           *
    706           * certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
    707           *
    708           * PolicyInformation ::= SEQUENCE {
    709           *     policyIdentifier   CertPolicyId,
    710           *     policyQualifiers   SEQUENCE SIZE (1..MAX) OF
    711           *                             PolicyQualifierInfo OPTIONAL }
    712           *
    713           * CertPolicyId ::= OBJECT IDENTIFIER
    714           *
    715           * PolicyQualifierInfo ::= SEQUENCE {
    716           *      policyQualifierId  PolicyQualifierId,
    717           *      qualifier          ANY DEFINED BY policyQualifierId }
    718           *
    719           * -- policyQualifierIds for Internet policy qualifiers
    720           *
    721           * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
    722           * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
    723           * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
    724           *
    725           * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
    726           *
    727           * Qualifier ::= CHOICE {
    728           *      cPSuri           CPSuri,
    729           *      userNotice       UserNotice }
    730           *
    731           * CPSuri ::= IA5String
    732           *
    733           * UserNotice ::= SEQUENCE {
    734           *      noticeRef        NoticeReference OPTIONAL,
    735           *      explicitText     DisplayText OPTIONAL }
    736           *
    737           * NoticeReference ::= SEQUENCE {
    738           *      organization     DisplayText,
    739           *      noticeNumbers    SEQUENCE OF INTEGER }
    740           *
    741           * DisplayText ::= CHOICE {
    742           *      ia5String        IA5String      (SIZE (1..200)),
    743           *      visibleString    VisibleString  (SIZE (1..200)),
    744           *      bmpString        BMPString      (SIZE (1..200)),
    745           *      utf8String       UTF8String     (SIZE (1..200)) }
    746           *
    747           * NOTE: we only parse and use anyPolicy without qualifiers at this point
    748           * as defined in RFC 5280.
    749           */
    750          static int x509_get_certificate_policies(unsigned char **p,
    751                                                   const unsigned char *end,
    752                                                   mbedtls_x509_sequence *certificate_policies)
    753          {
    754              int ret, parse_ret = 0;
    755              size_t len;
    756              mbedtls_asn1_buf *buf;
    757              mbedtls_asn1_sequence *cur = certificate_policies;
    758          
    759              /* Get main sequence tag */
    760              ret = mbedtls_asn1_get_tag(p, end, &len,
    761                                         MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
    762              if (ret != 0) {
    763                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    764              }
    765          
    766              if (*p + len != end) {
    767                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    768                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    769              }
    770          
    771              /*
    772               * Cannot be an empty sequence.
    773               */
    774              if (len == 0) {
    775                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    776                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    777              }
    778          
    779              while (*p < end) {
    780                  mbedtls_x509_buf policy_oid;
    781                  const unsigned char *policy_end;
    782          
    783                  /*
    784                   * Get the policy sequence
    785                   */
    786                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    787                                                  MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    788                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    789                  }
    790          
    791                  policy_end = *p + len;
    792          
    793                  if ((ret = mbedtls_asn1_get_tag(p, policy_end, &len,
    794                                                  MBEDTLS_ASN1_OID)) != 0) {
    795                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    796                  }
    797          
    798                  policy_oid.tag = MBEDTLS_ASN1_OID;
    799                  policy_oid.len = len;
    800                  policy_oid.p = *p;
    801          
    802                  /*
    803                   * Only AnyPolicy is currently supported when enforcing policy.
    804                   */
    805                  if (MBEDTLS_OID_CMP(MBEDTLS_OID_ANY_POLICY, &policy_oid) != 0) {
    806                      /*
    807                       * Set the parsing return code but continue parsing, in case this
    808                       * extension is critical.
    809                       */
    810                      parse_ret = MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
    811                  }
    812          
    813                  /* Allocate and assign next pointer */
    814                  if (cur->buf.p != NULL) {
    815                      if (cur->next != NULL) {
    816                          return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
    817                      }
    818          
    819                      cur->next = mbedtls_calloc(1, sizeof(mbedtls_asn1_sequence));
    820          
    821                      if (cur->next == NULL) {
    822                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    823                                                   MBEDTLS_ERR_ASN1_ALLOC_FAILED);
    824                      }
    825          
    826                      cur = cur->next;
    827                  }
    828          
    829                  buf = &(cur->buf);
    830                  buf->tag = policy_oid.tag;
    831                  buf->p = policy_oid.p;
    832                  buf->len = policy_oid.len;
    833          
    834                  *p += len;
    835          
    836                  /*
    837                   * If there is an optional qualifier, then *p < policy_end
    838                   * Check the Qualifier len to verify it doesn't exceed policy_end.
    839                   */
    840                  if (*p < policy_end) {
    841                      if ((ret = mbedtls_asn1_get_tag(p, policy_end, &len,
    842                                                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) !=
    843                          0) {
    844                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    845                      }
    846                      /*
    847                       * Skip the optional policy qualifiers.
    848                       */
    849                      *p += len;
    850                  }
    851          
    852                  if (*p != policy_end) {
    853                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    854                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    855                  }
    856              }
    857          
    858              /* Set final sequence entry's next pointer to NULL */
    859              cur->next = NULL;
    860          
    861              if (*p != end) {
    862                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    863                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    864              }
    865          
    866              return parse_ret;
    867          }
    868          
    869          /*
    870           * X.509 v3 extensions
    871           *
    872           */
    873          static int x509_get_crt_ext(unsigned char **p,
    874                                      const unsigned char *end,
    875                                      mbedtls_x509_crt *crt,
    876                                      mbedtls_x509_crt_ext_cb_t cb,
    877                                      void *p_ctx)
    878          {
    879              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    880              size_t len;
    881              unsigned char *end_ext_data, *start_ext_octet, *end_ext_octet;
    882          
    883              if (*p == end) {
    884                  return 0;
    885              }
    886          
    887              if ((ret = mbedtls_x509_get_ext(p, end, &crt->v3_ext, 3)) != 0) {
    888                  return ret;
    889              }
    890          
    891              end = crt->v3_ext.p + crt->v3_ext.len;
    892              while (*p < end) {
    893                  /*
    894                   * Extension  ::=  SEQUENCE  {
    895                   *      extnID      OBJECT IDENTIFIER,
    896                   *      critical    BOOLEAN DEFAULT FALSE,
    897                   *      extnValue   OCTET STRING  }
    898                   */

   \                                 In section .rodata, align 4, keep-with-next
    899                  mbedtls_x509_buf extn_oid = { 0, 0, NULL };
   \                     ?_51:
   \        0x0   0x0000'0000        DC32 0, 0, 0x0
   \              0x0000'0000  
   \              0x0000'0000
    900                  int is_critical = 0; /* DEFAULT FALSE */
    901                  int ext_type = 0;
    902          
    903                  if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    904                                                  MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
    905                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    906                  }
    907          
    908                  end_ext_data = *p + len;
    909          
    910                  /* Get extension ID */
    911                  if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &extn_oid.len,
    912                                                  MBEDTLS_ASN1_OID)) != 0) {
    913                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    914                  }
    915          
    916                  extn_oid.tag = MBEDTLS_ASN1_OID;
    917                  extn_oid.p = *p;
    918                  *p += extn_oid.len;
    919          
    920                  /* Get optional critical */
    921                  if ((ret = mbedtls_asn1_get_bool(p, end_ext_data, &is_critical)) != 0 &&
    922                      (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG)) {
    923                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    924                  }
    925          
    926                  /* Data should be octet string type */
    927                  if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &len,
    928                                                  MBEDTLS_ASN1_OCTET_STRING)) != 0) {
    929                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS, ret);
    930                  }
    931          
    932                  start_ext_octet = *p;
    933                  end_ext_octet = *p + len;
    934          
    935                  if (end_ext_octet != end_ext_data) {
    936                      return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    937                                               MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
    938                  }
    939          
    940                  /*
    941                   * Detect supported extensions
    942                   */
    943                  ret = mbedtls_oid_get_x509_ext_type(&extn_oid, &ext_type);
    944          
    945                  if (ret != 0) {
    946                      /* Give the callback (if any) a chance to handle the extension */
    947                      if (cb != NULL) {
    948                          ret = cb(p_ctx, crt, &extn_oid, is_critical, *p, end_ext_octet);
    949                          if (ret != 0 && is_critical) {
    950                              return ret;
    951                          }
    952                          *p = end_ext_octet;
    953                          continue;
    954                      }
    955          
    956                      /* No parser found, skip extension */
    957                      *p = end_ext_octet;
    958          
    959                      if (is_critical) {
    960                          /* Data is marked as critical: fail */
    961                          return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
    962                                                   MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
    963                      }
    964                      continue;
    965                  }
    966          
    967                  /* Forbid repeated extensions */
    968                  if ((crt->ext_types & ext_type) != 0) {
    969                      return MBEDTLS_ERR_X509_INVALID_EXTENSIONS;
    970                  }
    971          
    972                  crt->ext_types |= ext_type;
    973          
    974                  switch (ext_type) {
    975                      case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:
    976                          /* Parse basic constraints */
    977                          if ((ret = x509_get_basic_constraints(p, end_ext_octet,
    978                                                                &crt->ca_istrue, &crt->max_pathlen)) != 0) {
    979                              return ret;
    980                          }
    981                          break;
    982          
    983                      case MBEDTLS_X509_EXT_KEY_USAGE:
    984                          /* Parse key usage */
    985                          if ((ret = mbedtls_x509_get_key_usage(p, end_ext_octet,
    986                                                                &crt->key_usage)) != 0) {
    987                              return ret;
    988                          }
    989                          break;
    990          
    991                      case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:
    992                          /* Parse extended key usage */
    993                          if ((ret = x509_get_ext_key_usage(p, end_ext_octet,
    994                                                            &crt->ext_key_usage)) != 0) {
    995                              return ret;
    996                          }
    997                          break;
    998          
    999                      case MBEDTLS_X509_EXT_SUBJECT_KEY_IDENTIFIER:
   1000                          /* Parse subject key identifier */
   1001                          if ((ret = x509_get_subject_key_id(p, end_ext_data,
   1002                                                             &crt->subject_key_id)) != 0) {
   1003                              return ret;
   1004                          }
   1005                          break;
   1006          
   1007                      case MBEDTLS_X509_EXT_AUTHORITY_KEY_IDENTIFIER:
   1008                          /* Parse authority key identifier */
   1009                          if ((ret = x509_get_authority_key_id(p, end_ext_octet,
   1010                                                               &crt->authority_key_id)) != 0) {
   1011                              return ret;
   1012                          }
   1013                          break;
   1014                      case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:
   1015                          /* Parse subject alt name
   1016                           * SubjectAltName ::= GeneralNames
   1017                           */
   1018                          if ((ret = mbedtls_x509_get_subject_alt_name(p, end_ext_octet,
   1019                                                                       &crt->subject_alt_names)) != 0) {
   1020                              return ret;
   1021                          }
   1022                          break;
   1023          
   1024                      case MBEDTLS_X509_EXT_NS_CERT_TYPE:
   1025                          /* Parse netscape certificate type */
   1026                          if ((ret = mbedtls_x509_get_ns_cert_type(p, end_ext_octet,
   1027                                                                   &crt->ns_cert_type)) != 0) {
   1028                              return ret;
   1029                          }
   1030                          break;
   1031          
   1032                      case MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES:
   1033                          /* Parse certificate policies type */
   1034                          if ((ret = x509_get_certificate_policies(p, end_ext_octet,
   1035                                                                   &crt->certificate_policies)) != 0) {
   1036                              /* Give the callback (if any) a chance to handle the extension
   1037                               * if it contains unsupported policies */
   1038                              if (ret == MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE && cb != NULL &&
   1039                                  cb(p_ctx, crt, &extn_oid, is_critical,
   1040                                     start_ext_octet, end_ext_octet) == 0) {
   1041                                  break;
   1042                              }
   1043          
   1044                              if (is_critical) {
   1045                                  return ret;
   1046                              } else
   1047                              /*
   1048                               * If MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE is returned, then we
   1049                               * cannot interpret or enforce the policy. However, it is up to
   1050                               * the user to choose how to enforce the policies,
   1051                               * unless the extension is critical.
   1052                               */
   1053                              if (ret != MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) {
   1054                                  return ret;
   1055                              }
   1056                          }
   1057                          break;
   1058          
   1059                      default:
   1060                          /*
   1061                           * If this is a non-critical extension, which the oid layer
   1062                           * supports, but there isn't an x509 parser for it,
   1063                           * skip the extension.
   1064                           */
   1065                          if (is_critical) {
   1066                              return MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE;
   1067                          } else {
   1068                              *p = end_ext_octet;
   1069                          }
   1070                  }
   1071              }
   1072          
   1073              if (*p != end) {
   1074                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_EXTENSIONS,
   1075                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1076              }
   1077          
   1078              return 0;
   1079          }
   1080          
   1081          /*
   1082           * Parse and fill a single X.509 certificate in DER format
   1083           */
   1084          static int x509_crt_parse_der_core(mbedtls_x509_crt *crt,
   1085                                             const unsigned char *buf,
   1086                                             size_t buflen,
   1087                                             int make_copy,
   1088                                             mbedtls_x509_crt_ext_cb_t cb,
   1089                                             void *p_ctx)
   1090          {
   1091              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1092              size_t len;
   1093              unsigned char *p, *end, *crt_end;
   1094              mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;
   1095          
   1096              memset(&sig_params1, 0, sizeof(mbedtls_x509_buf));
   1097              memset(&sig_params2, 0, sizeof(mbedtls_x509_buf));
   1098              memset(&sig_oid2, 0, sizeof(mbedtls_x509_buf));
   1099          
   1100              /*
   1101               * Check for valid input
   1102               */
   1103              if (crt == NULL || buf == NULL) {
   1104                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1105              }
   1106          
   1107              /* Use the original buffer until we figure out actual length. */
   1108              p = (unsigned char *) buf;
   1109              len = buflen;
   1110              end = p + len;
   1111          
   1112              /*
   1113               * Certificate  ::=  SEQUENCE  {
   1114               *      tbsCertificate       TBSCertificate,
   1115               *      signatureAlgorithm   AlgorithmIdentifier,
   1116               *      signatureValue       BIT STRING  }
   1117               */
   1118              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1119                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   1120                  mbedtls_x509_crt_free(crt);
   1121                  return MBEDTLS_ERR_X509_INVALID_FORMAT;
   1122              }
   1123          
   1124              end = crt_end = p + len;
   1125              crt->raw.len = crt_end - buf;
   1126              if (make_copy != 0) {
   1127                  /* Create and populate a new buffer for the raw field. */
   1128                  crt->raw.p = p = mbedtls_calloc(1, crt->raw.len);
   1129                  if (crt->raw.p == NULL) {
   1130                      return MBEDTLS_ERR_X509_ALLOC_FAILED;
   1131                  }
   1132          
   1133                  memcpy(crt->raw.p, buf, crt->raw.len);
   1134                  crt->own_buffer = 1;
   1135          
   1136                  p += crt->raw.len - len;
   1137                  end = crt_end = p + len;
   1138              } else {
   1139                  crt->raw.p = (unsigned char *) buf;
   1140                  crt->own_buffer = 0;
   1141              }
   1142          
   1143              /*
   1144               * TBSCertificate  ::=  SEQUENCE  {
   1145               */
   1146              crt->tbs.p = p;
   1147          
   1148              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1149                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   1150                  mbedtls_x509_crt_free(crt);
   1151                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   1152              }
   1153          
   1154              end = p + len;
   1155              crt->tbs.len = end - crt->tbs.p;
   1156          
   1157              /*
   1158               * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
   1159               *
   1160               * CertificateSerialNumber  ::=  INTEGER
   1161               *
   1162               * signature            AlgorithmIdentifier
   1163               */
   1164              if ((ret = x509_get_version(&p, end, &crt->version)) != 0 ||
   1165                  (ret = mbedtls_x509_get_serial(&p, end, &crt->serial)) != 0 ||
   1166                  (ret = mbedtls_x509_get_alg(&p, end, &crt->sig_oid,
   1167                                              &sig_params1)) != 0) {
   1168                  mbedtls_x509_crt_free(crt);
   1169                  return ret;
   1170              }
   1171          
   1172              if (crt->version < 0 || crt->version > 2) {
   1173                  mbedtls_x509_crt_free(crt);
   1174                  return MBEDTLS_ERR_X509_UNKNOWN_VERSION;
   1175              }
   1176          
   1177              crt->version++;
   1178          
   1179              if ((ret = mbedtls_x509_get_sig_alg(&crt->sig_oid, &sig_params1,
   1180                                                  &crt->sig_md, &crt->sig_pk,
   1181                                                  &crt->sig_opts)) != 0) {
   1182                  mbedtls_x509_crt_free(crt);
   1183                  return ret;
   1184              }
   1185          
   1186              /*
   1187               * issuer               Name
   1188               */
   1189              crt->issuer_raw.p = p;
   1190          
   1191              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1192                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   1193                  mbedtls_x509_crt_free(crt);
   1194                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   1195              }
   1196          
   1197              if ((ret = mbedtls_x509_get_name(&p, p + len, &crt->issuer)) != 0) {
   1198                  mbedtls_x509_crt_free(crt);
   1199                  return ret;
   1200              }
   1201          
   1202              crt->issuer_raw.len = p - crt->issuer_raw.p;
   1203          
   1204              /*
   1205               * Validity ::= SEQUENCE {
   1206               *      notBefore      Time,
   1207               *      notAfter       Time }
   1208               *
   1209               */
   1210              if ((ret = x509_get_dates(&p, end, &crt->valid_from,
   1211                                        &crt->valid_to)) != 0) {
   1212                  mbedtls_x509_crt_free(crt);
   1213                  return ret;
   1214              }
   1215          
   1216              /*
   1217               * subject              Name
   1218               */
   1219              crt->subject_raw.p = p;
   1220          
   1221              if ((ret = mbedtls_asn1_get_tag(&p, end, &len,
   1222                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   1223                  mbedtls_x509_crt_free(crt);
   1224                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT, ret);
   1225              }
   1226          
   1227              if (len && (ret = mbedtls_x509_get_name(&p, p + len, &crt->subject)) != 0) {
   1228                  mbedtls_x509_crt_free(crt);
   1229                  return ret;
   1230              }
   1231          
   1232              crt->subject_raw.len = p - crt->subject_raw.p;
   1233          
   1234              /*
   1235               * SubjectPublicKeyInfo
   1236               */
   1237              crt->pk_raw.p = p;
   1238              if ((ret = mbedtls_pk_parse_subpubkey(&p, end, &crt->pk)) != 0) {
   1239                  mbedtls_x509_crt_free(crt);
   1240                  return ret;
   1241              }
   1242              crt->pk_raw.len = p - crt->pk_raw.p;
   1243          
   1244              /*
   1245               *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
   1246               *                       -- If present, version shall be v2 or v3
   1247               *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
   1248               *                       -- If present, version shall be v2 or v3
   1249               *  extensions      [3]  EXPLICIT Extensions OPTIONAL
   1250               *                       -- If present, version shall be v3
   1251               */
   1252              if (crt->version == 2 || crt->version == 3) {
   1253                  ret = x509_get_uid(&p, end, &crt->issuer_id,  1);
   1254                  if (ret != 0) {
   1255                      mbedtls_x509_crt_free(crt);
   1256                      return ret;
   1257                  }
   1258              }
   1259          
   1260              if (crt->version == 2 || crt->version == 3) {
   1261                  ret = x509_get_uid(&p, end, &crt->subject_id,  2);
   1262                  if (ret != 0) {
   1263                      mbedtls_x509_crt_free(crt);
   1264                      return ret;
   1265                  }
   1266              }
   1267          
   1268              if (crt->version == 3) {
   1269                  ret = x509_get_crt_ext(&p, end, crt, cb, p_ctx);
   1270                  if (ret != 0) {
   1271                      mbedtls_x509_crt_free(crt);
   1272                      return ret;
   1273                  }
   1274              }
   1275          
   1276              if (p != end) {
   1277                  mbedtls_x509_crt_free(crt);
   1278                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT,
   1279                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1280              }
   1281          
   1282              end = crt_end;
   1283          
   1284              /*
   1285               *  }
   1286               *  -- end of TBSCertificate
   1287               *
   1288               *  signatureAlgorithm   AlgorithmIdentifier,
   1289               *  signatureValue       BIT STRING
   1290               */
   1291              if ((ret = mbedtls_x509_get_alg(&p, end, &sig_oid2, &sig_params2)) != 0) {
   1292                  mbedtls_x509_crt_free(crt);
   1293                  return ret;
   1294              }
   1295          
   1296              if (crt->sig_oid.len != sig_oid2.len ||
   1297                  memcmp(crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len) != 0 ||
   1298                  sig_params1.tag != sig_params2.tag ||
   1299                  sig_params1.len != sig_params2.len ||
   1300                  (sig_params1.len != 0 &&
   1301                   memcmp(sig_params1.p, sig_params2.p, sig_params1.len) != 0)) {
   1302                  mbedtls_x509_crt_free(crt);
   1303                  return MBEDTLS_ERR_X509_SIG_MISMATCH;
   1304              }
   1305          
   1306              if ((ret = mbedtls_x509_get_sig(&p, end, &crt->sig)) != 0) {
   1307                  mbedtls_x509_crt_free(crt);
   1308                  return ret;
   1309              }
   1310          
   1311              if (p != end) {
   1312                  mbedtls_x509_crt_free(crt);
   1313                  return MBEDTLS_ERROR_ADD(MBEDTLS_ERR_X509_INVALID_FORMAT,
   1314                                           MBEDTLS_ERR_ASN1_LENGTH_MISMATCH);
   1315              }
   1316          
   1317              return 0;
   1318          }
   1319          
   1320          /*
   1321           * Parse one X.509 certificate in DER format from a buffer and add them to a
   1322           * chained list
   1323           */

   \                                 In section .text, align 2, keep-with-next
   1324          static int mbedtls_x509_crt_parse_der_internal(mbedtls_x509_crt *chain,
   1325                                                         const unsigned char *buf,
   1326                                                         size_t buflen,
   1327                                                         int make_copy,
   1328                                                         mbedtls_x509_crt_ext_cb_t cb,
   1329                                                         void *p_ctx)
   1330          {
   \                     mbedtls_x509_crt_parse_der_internal: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0x460E             MOV      R6,R1
   1331              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1332              mbedtls_x509_crt *crt = chain, *prev = NULL;
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0xB09A             SUB      SP,SP,#+104
   \        0xC   0x4690             MOV      R8,R2
   \        0xE   0x461F             MOV      R7,R3
   1333          
   1334              /*
   1335               * Check for valid input
   1336               */
   1337              if (crt == NULL || buf == NULL) {
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xBF14             ITE      NE
   \       0x14   0x2E00             CMPNE    R6,#+0
   \       0x16   0x.... 0x....      LDREQ.W  R0,??DataTable33_1
   1338                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \       0x1A   0xF000 0x8379      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_0
   \       0x1E   0x9109             STR      R1,[SP, #+36]
   \       0x20   0xE001             B.N      ??mbedtls_x509_crt_parse_der_internal_1
   1339              }
   1340          
   1341              while (crt->version != 0 && crt->next != NULL) {
   1342                  prev = crt;
   \                     ??mbedtls_x509_crt_parse_der_internal_2: (+1)
   \       0x22   0x9509             STR      R5,[SP, #+36]
   1343                  crt = crt->next;
   \       0x24   0x4605             MOV      R5,R0
   1344              }
   \                     ??mbedtls_x509_crt_parse_der_internal_1: (+1)
   \       0x26   0x69E8             LDR      R0,[R5, #+28]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xBF1C             ITT      NE
   \       0x2C   0xF8D5 0x0228      LDRNE    R0,[R5, #+552]
   \       0x30   0x2800             CMPNE    R0,#+0
   \       0x32   0xD1F6             BNE.N    ??mbedtls_x509_crt_parse_der_internal_2
   1345          
   1346              /*
   1347               * Add new certificate on the end of the chain if needed.
   1348               */
   1349              if (crt->version != 0 && crt->next == NULL) {
   \       0x34   0x69E8             LDR      R0,[R5, #+28]
   \       0x36   0x.... 0x....      LDR.W    R4,??DataTable33_2
   \       0x3A   0xB180             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_3
   \       0x3C   0xF8D5 0x0228      LDR      R0,[R5, #+552]
   \       0x40   0xB968             CBNZ.N   R0,??mbedtls_x509_crt_parse_der_internal_3
   1350                  crt->next = mbedtls_calloc(1, sizeof(mbedtls_x509_crt));
   \       0x42   0xF44F 0x710B      MOV      R1,#+556
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x.... 0x....      BL       sl_calloc
   \       0x4C   0xF8C5 0x0228      STR      R0,[R5, #+552]
   1351          
   1352                  if (crt->next == NULL) {
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD060             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_4
   1353                      return MBEDTLS_ERR_X509_ALLOC_FAILED;
   1354                  }
   1355          
   1356                  prev = crt;
   \       0x54   0x9509             STR      R5,[SP, #+36]
   1357                  mbedtls_x509_crt_init(crt->next);
   \       0x56   0x.... 0x....      BL       mbedtls_x509_crt_init
   1358                  crt = crt->next;
   \       0x5A   0xF8D5 0x5228      LDR      R5,[R5, #+552]
   1359              }
   1360          
   1361              ret = x509_crt_parse_der_core(crt, buf, buflen, make_copy, cb, p_ctx);
   \                     ??mbedtls_x509_crt_parse_der_internal_3: (+1)
   \       0x5E   0xA80A             ADD      R0,SP,#+40
   \       0x60   0x2300             MOVS     R3,#+0
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x2200             MOVS     R2,#+0
   \       0x66   0xE880 0x000E      STM      R0,{R1-R3}
   \       0x6A   0xA810             ADD      R0,SP,#+64
   \       0x6C   0xE880 0x000E      STM      R0,{R1-R3}
   \       0x70   0xA80D             ADD      R0,SP,#+52
   \       0x72   0xE880 0x000E      STM      R0,{R1-R3}
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xF000 0x8347      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_5
   \       0x7C   0x9602             STR      R6,[SP, #+8]
   \       0x7E   0x9902             LDR      R1,[SP, #+8]
   \       0x80   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \       0x84   0x2330             MOVS     R3,#+48
   \       0x86   0xAA03             ADD      R2,SP,#+12
   \       0x88   0x4441             ADD      R1,R1,R8
   \       0x8A   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x8E   0xB120             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_6
   \       0x90   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x94   0x.... 0x....      LDR.W    R4,??DataTable34
   \       0x98   0xE032             B.N      ??mbedtls_x509_crt_parse_der_internal_7
   \                     ??mbedtls_x509_crt_parse_der_internal_6: (+1)
   \       0x9A   0x9902             LDR      R1,[SP, #+8]
   \       0x9C   0x9803             LDR      R0,[SP, #+12]
   \       0x9E   0x4408             ADD      R0,R1,R0
   \       0xA0   0x9008             STR      R0,[SP, #+32]
   \       0xA2   0x4601             MOV      R1,R0
   \       0xA4   0x1B80             SUBS     R0,R0,R6
   \       0xA6   0x60A8             STR      R0,[R5, #+8]
   \       0xA8   0xB1C7             CBZ.N    R7,??mbedtls_x509_crt_parse_der_internal_8
   \       0xAA   0x4601             MOV      R1,R0
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0x.... 0x....      BL       sl_calloc
   \       0xB2   0x9002             STR      R0,[SP, #+8]
   \       0xB4   0x60E8             STR      R0,[R5, #+12]
   \       0xB6   0xB318             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_7
   \       0xB8   0x68AA             LDR      R2,[R5, #+8]
   \       0xBA   0x4631             MOV      R1,R6
   \       0xBC   0x.... 0x....      BL       __aeabi_memcpy
   \       0xC0   0x2001             MOVS     R0,#+1
   \       0xC2   0x6028             STR      R0,[R5, #+0]
   \       0xC4   0x68A9             LDR      R1,[R5, #+8]
   \       0xC6   0x9803             LDR      R0,[SP, #+12]
   \       0xC8   0x9A02             LDR      R2,[SP, #+8]
   \       0xCA   0x1A09             SUBS     R1,R1,R0
   \       0xCC   0x1850             ADDS     R0,R2,R1
   \       0xCE   0x9002             STR      R0,[SP, #+8]
   \       0xD0   0x4601             MOV      R1,R0
   \       0xD2   0x9803             LDR      R0,[SP, #+12]
   \       0xD4   0x4408             ADD      R0,R1,R0
   \       0xD6   0x9008             STR      R0,[SP, #+32]
   \       0xD8   0x4601             MOV      R1,R0
   \       0xDA   0xE002             B.N      ??mbedtls_x509_crt_parse_der_internal_9
   \                     ??mbedtls_x509_crt_parse_der_internal_8: (+1)
   \       0xDC   0x60EE             STR      R6,[R5, #+12]
   \       0xDE   0x2200             MOVS     R2,#+0
   \       0xE0   0x602A             STR      R2,[R5, #+0]
   \                     ??mbedtls_x509_crt_parse_der_internal_9: (+1)
   \       0xE2   0x9802             LDR      R0,[SP, #+8]
   \       0xE4   0x2330             MOVS     R3,#+48
   \       0xE6   0xAA03             ADD      R2,SP,#+12
   \       0xE8   0x61A8             STR      R0,[R5, #+24]
   \       0xEA   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0xEE   0x0004             MOVS     R4,R0
   \       0xF0   0xD013             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_10
   \                     ??mbedtls_x509_crt_parse_der_internal_11: (+1)
   \       0xF2   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0xF6   0xF5A4 0x5406      SUB      R4,R4,#+8576
   1362              if (ret != 0) {
   \                     ??mbedtls_x509_crt_parse_der_internal_12: (+1)
   \       0xFA   0x2C00             CMP      R4,#+0
   \       0xFC   0xF000 0x8307      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_13
   1363                  if (prev) {
   \                     ??mbedtls_x509_crt_parse_der_internal_7: (+1)
   \      0x100   0x9809             LDR      R0,[SP, #+36]
   \      0x102   0xB110             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_14
   1364                      prev->next = NULL;
   \      0x104   0x2100             MOVS     R1,#+0
   \      0x106   0xF8C0 0x1228      STR      R1,[R0, #+552]
   1365                  }
   1366          
   1367                  if (crt != chain) {
   \                     ??mbedtls_x509_crt_parse_der_internal_14: (+1)
   \      0x10A   0x981A             LDR      R0,[SP, #+104]
   \      0x10C   0x4285             CMP      R5,R0
   \      0x10E   0xBF1C             ITT      NE
   1368                      mbedtls_free(crt);
   \      0x110   0x4628             MOVNE    R0,R5
   \      0x112   0x.... 0x....      BLNE     sl_free
   1369                  }
   1370          
   1371                  return ret;
   \                     ??mbedtls_x509_crt_parse_der_internal_4: (+1)
   \      0x116   0x4620             MOV      R0,R4
   \      0x118   0xE2FA             B.N      ??mbedtls_x509_crt_parse_der_internal_0
   1372              }
   \                     ??mbedtls_x509_crt_parse_der_internal_10: (+1)
   \      0x11A   0x9902             LDR      R1,[SP, #+8]
   \      0x11C   0x9803             LDR      R0,[SP, #+12]
   \      0x11E   0x23A0             MOVS     R3,#+160
   \      0x120   0x466A             MOV      R2,SP
   \      0x122   0x4408             ADD      R0,R1,R0
   \      0x124   0x9005             STR      R0,[SP, #+20]
   \      0x126   0x4601             MOV      R1,R0
   \      0x128   0x69A8             LDR      R0,[R5, #+24]
   \      0x12A   0x1A09             SUBS     R1,R1,R0
   \      0x12C   0x6169             STR      R1,[R5, #+20]
   \      0x12E   0x9905             LDR      R1,[SP, #+20]
   \      0x130   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_11: (+1)
   \      0x134   0x0004             MOVS     R4,R0
   \      0x136   0xD021             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_15
   \      0x138   0xF110 0x0F62      CMN      R0,#+98
   \      0x13C   0xD102             BNE.N    ??mbedtls_x509_crt_parse_der_internal_16
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x61E8             STR      R0,[R5, #+28]
   \      0x142   0xE002             B.N      ??mbedtls_x509_crt_parse_der_internal_17
   \                     ??mbedtls_x509_crt_parse_der_internal_16: (+1)
   \      0x144   0xF5A0 0x5406      SUB      R4,R0,#+8576
   \                     ??mbedtls_x509_crt_parse_der_internal_18: (+1)
   \      0x148   0xBB54             CBNZ.N   R4,??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_17: (+1)
   \      0x14A   0x9905             LDR      R1,[SP, #+20]
   \      0x14C   0xF105 0x0220      ADD      R2,R5,#+32
   \      0x150   0xA802             ADD      R0,SP,#+8
   \      0x152   0x.... 0x....      BL       mbedtls_x509_get_serial
   \      0x156   0x0004             MOVS     R4,R0
   \      0x158   0xD122             BNE.N    ??mbedtls_x509_crt_parse_der_internal_19
   \      0x15A   0x9905             LDR      R1,[SP, #+20]
   \      0x15C   0xAB0A             ADD      R3,SP,#+40
   \      0x15E   0xF105 0x022C      ADD      R2,R5,#+44
   \      0x162   0xA802             ADD      R0,SP,#+8
   \      0x164   0x.... 0x....      BL       mbedtls_x509_get_alg
   \      0x168   0x0004             MOVS     R4,R0
   \      0x16A   0xD119             BNE.N    ??mbedtls_x509_crt_parse_der_internal_19
   \      0x16C   0x69E8             LDR      R0,[R5, #+28]
   \      0x16E   0x2803             CMP      R0,#+3
   \      0x170   0xD319             BCC.N    ??mbedtls_x509_crt_parse_der_internal_20
   \      0x172   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_26: (+1)
   \      0x176   0x.... 0x....      LDR.W    R4,??DataTable34_1
   \      0x17A   0xE7C1             B.N      ??mbedtls_x509_crt_parse_der_internal_7
   \                     ??mbedtls_x509_crt_parse_der_internal_15: (+1)
   \      0x17C   0x9802             LDR      R0,[SP, #+8]
   \      0x17E   0x9900             LDR      R1,[SP, #+0]
   \      0x180   0xF105 0x021C      ADD      R2,R5,#+28
   \      0x184   0x1846             ADDS     R6,R0,R1
   \      0x186   0x4631             MOV      R1,R6
   \      0x188   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_31: (+1)
   \      0x18C   0x0004             MOVS     R4,R0
   \      0x18E   0xBF18             IT       NE
   \      0x190   0xF5A0 0x5408      SUBNE    R4,R0,#+8704
   \      0x194   0xD1D8             BNE.N    ??mbedtls_x509_crt_parse_der_internal_18
   \      0x196   0x9802             LDR      R0,[SP, #+8]
   \      0x198   0x42B0             CMP      R0,R6
   \      0x19A   0xD0D6             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_17
   \      0x19C   0x.... 0x....      LDR.W    R4,??DataTable34_2
   \                     ??mbedtls_x509_crt_parse_der_internal_19: (+1)
   \      0x1A0   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_27: (+1)
   \      0x1A4   0xE7A9             B.N      ??mbedtls_x509_crt_parse_der_internal_12
   \                     ??mbedtls_x509_crt_parse_der_internal_20: (+1)
   \      0x1A6   0x1C40             ADDS     R0,R0,#+1
   \      0x1A8   0x61E8             STR      R0,[R5, #+28]
   \      0x1AA   0xF505 0x7009      ADD      R0,R5,#+548
   \      0x1AE   0x9000             STR      R0,[SP, #+0]
   \      0x1B0   0xF205 0x2321      ADDW     R3,R5,#+545
   \      0x1B4   0xF505 0x7208      ADD      R2,R5,#+544
   \      0x1B8   0xA90A             ADD      R1,SP,#+40
   \      0x1BA   0xF105 0x002C      ADD      R0,R5,#+44
   \      0x1BE   0x.... 0x....      BL       mbedtls_x509_get_sig_alg
   \      0x1C2   0x0004             MOVS     R4,R0
   \      0x1C4   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_21
   \                     ??mbedtls_x509_crt_parse_der_internal_22: (+1)
   \      0x1C6   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_28: (+1)
   \      0x1CA   0xE799             B.N      ??mbedtls_x509_crt_parse_der_internal_7
   \                     ??mbedtls_x509_crt_parse_der_internal_21: (+1)
   \      0x1CC   0x9802             LDR      R0,[SP, #+8]
   \      0x1CE   0x2330             MOVS     R3,#+48
   \      0x1D0   0xAA03             ADD      R2,SP,#+12
   \      0x1D2   0x6428             STR      R0,[R5, #+64]
   \      0x1D4   0x9905             LDR      R1,[SP, #+20]
   \      0x1D6   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_12: (+1)
   \      0x1DA   0x0004             MOVS     R4,R0
   \      0x1DC   0xD189             BNE.N    ??mbedtls_x509_crt_parse_der_internal_11
   \      0x1DE   0x9902             LDR      R1,[SP, #+8]
   \      0x1E0   0x9803             LDR      R0,[SP, #+12]
   \      0x1E2   0xF105 0x0250      ADD      R2,R5,#+80
   \      0x1E6   0x4401             ADD      R1,R1,R0
   \      0x1E8   0xA802             ADD      R0,SP,#+8
   \      0x1EA   0x.... 0x....      BL       mbedtls_x509_get_name
   \      0x1EE   0x0004             MOVS     R4,R0
   \      0x1F0   0xD1E9             BNE.N    ??mbedtls_x509_crt_parse_der_internal_22
   \      0x1F2   0x9902             LDR      R1,[SP, #+8]
   \      0x1F4   0x6C28             LDR      R0,[R5, #+64]
   \      0x1F6   0x2330             MOVS     R3,#+48
   \      0x1F8   0x466A             MOV      R2,SP
   \      0x1FA   0x1A09             SUBS     R1,R1,R0
   \      0x1FC   0x63E9             STR      R1,[R5, #+60]
   \      0x1FE   0x9905             LDR      R1,[SP, #+20]
   \      0x200   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \      0x204   0x0004             MOVS     R4,R0
   \      0x206   0xD00C             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_23
   \      0x208   0xF5B0 0x5410      SUBS     R4,R0,#+9216
   \      0x20C   0xD1C8             BNE.N    ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_24: (+1)
   \      0x20E   0x9802             LDR      R0,[SP, #+8]
   \      0x210   0x2330             MOVS     R3,#+48
   \      0x212   0xAA03             ADD      R2,SP,#+12
   \      0x214   0x64E8             STR      R0,[R5, #+76]
   \      0x216   0x9905             LDR      R1,[SP, #+20]
   \      0x218   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \      0x21C   0x0004             MOVS     R4,R0
   \      0x21E   0xD019             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_25
   \      0x220   0xE767             B.N      ??mbedtls_x509_crt_parse_der_internal_11
   \                     ??mbedtls_x509_crt_parse_der_internal_23: (+1)
   \      0x222   0x9902             LDR      R1,[SP, #+8]
   \      0x224   0x9800             LDR      R0,[SP, #+0]
   \      0x226   0xF105 0x0290      ADD      R2,R5,#+144
   \      0x22A   0x180E             ADDS     R6,R1,R0
   \      0x22C   0x4631             MOV      R1,R6
   \      0x22E   0xA802             ADD      R0,SP,#+8
   \      0x230   0x.... 0x....      BL       mbedtls_x509_get_time
   \      0x234   0x0004             MOVS     R4,R0
   \      0x236   0xD1B3             BNE.N    ??mbedtls_x509_crt_parse_der_internal_19
   \      0x238   0xF105 0x02A8      ADD      R2,R5,#+168
   \      0x23C   0x4631             MOV      R1,R6
   \      0x23E   0xA802             ADD      R0,SP,#+8
   \      0x240   0x.... 0x....      BL       mbedtls_x509_get_time
   \      0x244   0x0004             MOVS     R4,R0
   \      0x246   0xD1AB             BNE.N    ??mbedtls_x509_crt_parse_der_internal_19
   \      0x248   0x9802             LDR      R0,[SP, #+8]
   \      0x24A   0x42B0             CMP      R0,R6
   \      0x24C   0xD0DF             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_24
   \      0x24E   0x.... 0x....      LDR.W    R4,??DataTable37_1
   \                     ??mbedtls_x509_crt_parse_der_internal_26: (+1)
   \      0x252   0xE7A5             B.N      ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_25: (+1)
   \      0x254   0x9803             LDR      R0,[SP, #+12]
   \      0x256   0xB140             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_27
   \      0x258   0x9902             LDR      R1,[SP, #+8]
   \      0x25A   0xF105 0x0270      ADD      R2,R5,#+112
   \      0x25E   0x4401             ADD      R1,R1,R0
   \      0x260   0xA802             ADD      R0,SP,#+8
   \      0x262   0x.... 0x....      BL       mbedtls_x509_get_name
   \      0x266   0x0004             MOVS     R4,R0
   \      0x268   0xD1AD             BNE.N    ??mbedtls_x509_crt_parse_der_internal_22
   \                     ??mbedtls_x509_crt_parse_der_internal_27: (+1)
   \      0x26A   0x9902             LDR      R1,[SP, #+8]
   \      0x26C   0x6CE8             LDR      R0,[R5, #+76]
   \      0x26E   0xF105 0x06C4      ADD      R6,R5,#+196
   \      0x272   0xF105 0x02CC      ADD      R2,R5,#+204
   \      0x276   0x1A09             SUBS     R1,R1,R0
   \      0x278   0x64A9             STR      R1,[R5, #+72]
   \      0x27A   0x9802             LDR      R0,[SP, #+8]
   \      0x27C   0x6070             STR      R0,[R6, #+4]
   \      0x27E   0x9905             LDR      R1,[SP, #+20]
   \      0x280   0xA802             ADD      R0,SP,#+8
   \      0x282   0x.... 0x....      BL       mbedtls_pk_parse_subpubkey
   \      0x286   0x0004             MOVS     R4,R0
   \      0x288   0xD19D             BNE.N    ??mbedtls_x509_crt_parse_der_internal_22
   \      0x28A   0x9902             LDR      R1,[SP, #+8]
   \      0x28C   0x6870             LDR      R0,[R6, #+4]
   \      0x28E   0x1A09             SUBS     R1,R1,R0
   \      0x290   0x6031             STR      R1,[R6, #+0]
   \      0x292   0x69E8             LDR      R0,[R5, #+28]
   \      0x294   0x2802             CMP      R0,#+2
   \      0x296   0xBF18             IT       NE
   \      0x298   0x2803             CMPNE    R0,#+3
   \      0x29A   0xD10B             BNE.N    ??mbedtls_x509_crt_parse_der_internal_28
   \      0x29C   0x9905             LDR      R1,[SP, #+20]
   \      0x29E   0x2301             MOVS     R3,#+1
   \      0x2A0   0xF505 0x72B6      ADD      R2,R5,#+364
   \      0x2A4   0xA802             ADD      R0,SP,#+8
   \      0x2A6   0x.... 0x....      BL       x509_get_uid
   \      0x2AA   0x0004             MOVS     R4,R0
   \      0x2AC   0xD1D1             BNE.N    ??mbedtls_x509_crt_parse_der_internal_26
   \      0x2AE   0x69E8             LDR      R0,[R5, #+28]
   \      0x2B0   0x2802             CMP      R0,#+2
   \      0x2B2   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_29
   \                     ??mbedtls_x509_crt_parse_der_internal_28: (+1)
   \      0x2B4   0x69E8             LDR      R0,[R5, #+28]
   \      0x2B6   0x2803             CMP      R0,#+3
   \      0x2B8   0xD108             BNE.N    ??mbedtls_x509_crt_parse_der_internal_30
   \                     ??mbedtls_x509_crt_parse_der_internal_29: (+1)
   \      0x2BA   0x9905             LDR      R1,[SP, #+20]
   \      0x2BC   0x2302             MOVS     R3,#+2
   \      0x2BE   0xF505 0x72BC      ADD      R2,R5,#+376
   \      0x2C2   0xA802             ADD      R0,SP,#+8
   \      0x2C4   0x.... 0x....      BL       x509_get_uid
   \      0x2C8   0x0004             MOVS     R4,R0
   \      0x2CA   0xD1C2             BNE.N    ??mbedtls_x509_crt_parse_der_internal_26
   \                     ??mbedtls_x509_crt_parse_der_internal_30: (+1)
   \      0x2CC   0x69E8             LDR      R0,[R5, #+28]
   \      0x2CE   0x2803             CMP      R0,#+3
   \      0x2D0   0xF040 0x8092      BNE.W    ??mbedtls_x509_crt_parse_der_internal_31
   \      0x2D4   0x9802             LDR      R0,[SP, #+8]
   \      0x2D6   0x9905             LDR      R1,[SP, #+20]
   \      0x2D8   0x4288             CMP      R0,R1
   \      0x2DA   0xF000 0x808D      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_31
   \      0x2DE   0x2303             MOVS     R3,#+3
   \      0x2E0   0xF505 0x72C2      ADD      R2,R5,#+388
   \      0x2E4   0xA802             ADD      R0,SP,#+8
   \      0x2E6   0x.... 0x....      BL       mbedtls_x509_get_ext
   \      0x2EA   0x0004             MOVS     R4,R0
   \      0x2EC   0xD1B1             BNE.N    ??mbedtls_x509_crt_parse_der_internal_26
   \      0x2EE   0xF505 0x76C4      ADD      R6,R5,#+392
   \      0x2F2   0x6870             LDR      R0,[R6, #+4]
   \      0x2F4   0x6831             LDR      R1,[R6, #+0]
   \      0x2F6   0x.... 0x....      LDR.W    R2,??DataTable37_4
   \      0x2FA   0x9217             STR      R2,[SP, #+92]
   \      0x2FC   0x4401             ADD      R1,R0,R1
   \      0x2FE   0x9116             STR      R1,[SP, #+88]
   \      0x300   0xE025             B.N      ??mbedtls_x509_crt_parse_der_internal_32
   \                     ??mbedtls_x509_crt_parse_der_internal_33: (+1)
   \      0x302   0x4301             ORRS     R1,R0,R1
   \      0x304   0x66B1             STR      R1,[R6, #+104]
   \      0x306   0x9906             LDR      R1,[SP, #+24]
   \      0x308   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \      0x30C   0x2901             CMP      R1,#+1
   \      0x30E   0xF000 0x811F      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_34
   \      0x312   0x2902             CMP      R1,#+2
   \      0x314   0xF000 0x8161      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_35
   \      0x318   0x2904             CMP      R1,#+4
   \      0x31A   0xF000 0x817F      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_36
   \      0x31E   0x2908             CMP      R1,#+8
   \      0x320   0xF000 0x8088      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_37
   \      0x324   0x2920             CMP      R1,#+32
   \      0x326   0xF000 0x810C      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_38
   \      0x32A   0xF5B1 0x7F80      CMP      R1,#+256
   \      0x32E   0xF000 0x817C      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_39
   \      0x332   0xF5B1 0x6F00      CMP      R1,#+2048
   \      0x336   0xF000 0x8163      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_40
   \      0x33A   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x33E   0xF000 0x80F6      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_41
   \      0x342   0x9804             LDR      R0,[SP, #+16]
   \      0x344   0x2800             CMP      R0,#+0
   \      0x346   0xF040 0x81A9      BNE.W    ??mbedtls_x509_crt_parse_der_internal_42
   \                     ??mbedtls_x509_crt_parse_der_internal_43: (+1)
   \      0x34A   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \                     ??mbedtls_x509_crt_parse_der_internal_32: (+1)
   \      0x34E   0x9802             LDR      R0,[SP, #+8]
   \      0x350   0x9C16             LDR      R4,[SP, #+88]
   \      0x352   0x42A0             CMP      R0,R4
   \      0x354   0xF080 0x81A5      BCS.W    ??mbedtls_x509_crt_parse_der_internal_44
   \      0x358   0xAA13             ADD      R2,SP,#+76
   \      0x35A   0x2100             MOVS     R1,#+0
   \      0x35C   0x2000             MOVS     R0,#+0
   \      0x35E   0x2300             MOVS     R3,#+0
   \      0x360   0xE882 0x000B      STM      R2,{R0,R1,R3}
   \      0x364   0x9916             LDR      R1,[SP, #+88]
   \      0x366   0x9004             STR      R0,[SP, #+16]
   \      0x368   0x9006             STR      R0,[SP, #+24]
   \      0x36A   0x2330             MOVS     R3,#+48
   \      0x36C   0xAA07             ADD      R2,SP,#+28
   \      0x36E   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_15: (+1)
   \      0x372   0x0004             MOVS     R4,R0
   \      0x374   0xD13C             BNE.N    ??mbedtls_x509_crt_parse_der_internal_45
   \      0x376   0x9802             LDR      R0,[SP, #+8]
   \      0x378   0x9907             LDR      R1,[SP, #+28]
   \      0x37A   0x2306             MOVS     R3,#+6
   \      0x37C   0xAA14             ADD      R2,SP,#+80
   \      0x37E   0x1847             ADDS     R7,R0,R1
   \      0x380   0x4639             MOV      R1,R7
   \      0x382   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_16: (+1)
   \      0x386   0x2800             CMP      R0,#+0
   \      0x388   0xD132             BNE.N    ??mbedtls_x509_crt_parse_der_internal_45
   \      0x38A   0x9902             LDR      R1,[SP, #+8]
   \      0x38C   0x2006             MOVS     R0,#+6
   \      0x38E   0x9013             STR      R0,[SP, #+76]
   \      0x390   0x9115             STR      R1,[SP, #+84]
   \      0x392   0x9902             LDR      R1,[SP, #+8]
   \      0x394   0x9814             LDR      R0,[SP, #+80]
   \      0x396   0xAA04             ADD      R2,SP,#+16
   \      0x398   0x4408             ADD      R0,R1,R0
   \      0x39A   0x9002             STR      R0,[SP, #+8]
   \      0x39C   0x4639             MOV      R1,R7
   \      0x39E   0xA802             ADD      R0,SP,#+8
   \      0x3A0   0x.... 0x....      BL       mbedtls_asn1_get_bool
   \      0x3A4   0x2800             CMP      R0,#+0
   \      0x3A6   0xBF18             IT       NE
   \      0x3A8   0xF110 0x0F62      CMNNE    R0,#+98
   \      0x3AC   0xD120             BNE.N    ??mbedtls_x509_crt_parse_der_internal_45
   \      0x3AE   0x2304             MOVS     R3,#+4
   \      0x3B0   0xAA07             ADD      R2,SP,#+28
   \      0x3B2   0x4639             MOV      R1,R7
   \      0x3B4   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_17: (+1)
   \      0x3B8   0xB9D0             CBNZ.N   R0,??mbedtls_x509_crt_parse_der_internal_45
   \      0x3BA   0x9802             LDR      R0,[SP, #+8]
   \      0x3BC   0x9902             LDR      R1,[SP, #+8]
   \      0x3BE   0x9018             STR      R0,[SP, #+96]
   \      0x3C0   0x9807             LDR      R0,[SP, #+28]
   \      0x3C2   0xEB01 0x0800      ADD      R8,R1,R0
   \      0x3C6   0x45B8             CMP      R8,R7
   \      0x3C8   0xF040 0x816D      BNE.W    ??mbedtls_x509_crt_parse_der_internal_46
   \      0x3CC   0xA906             ADD      R1,SP,#+24
   \      0x3CE   0xA813             ADD      R0,SP,#+76
   \      0x3D0   0x.... 0x....      BL       mbedtls_oid_get_x509_ext_type
   \      0x3D4   0xB338             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_47
   \      0x3D6   0x9824             LDR      R0,[SP, #+144]
   \      0x3D8   0xB1E8             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_48
   \      0x3DA   0x9802             LDR      R0,[SP, #+8]
   \      0x3DC   0x9B04             LDR      R3,[SP, #+16]
   \      0x3DE   0x9C24             LDR      R4,[SP, #+144]
   \      0x3E0   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_45: (+1)
   \      0x3E4   0x47A0             BLX      R4
   \      0x3E6   0x0004             MOVS     R4,R0
   \      0x3E8   0xD0AF             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_43
   \      0x3EA   0x9804             LDR      R0,[SP, #+16]
   \      0x3EC   0xB910             CBNZ.N   R0,??mbedtls_x509_crt_parse_der_internal_49
   \      0x3EE   0xE7AC             B.N      ??mbedtls_x509_crt_parse_der_internal_43
   \                     ??mbedtls_x509_crt_parse_der_internal_45: (+1)
   \      0x3F0   0xF5A0 0x5414      SUB      R4,R0,#+9472
   \                     ??mbedtls_x509_crt_parse_der_internal_49: (+1)
   \      0x3F4   0x2C00             CMP      R4,#+0
   \      0x3F6   0xD115             BNE.N    ??mbedtls_x509_crt_parse_der_internal_50
   \                     ??mbedtls_x509_crt_parse_der_internal_31: (+1)
   \      0x3F8   0x9802             LDR      R0,[SP, #+8]
   \      0x3FA   0x9905             LDR      R1,[SP, #+20]
   \      0x3FC   0x4288             CMP      R0,R1
   \      0x3FE   0xF040 0x817A      BNE.W    ??mbedtls_x509_crt_parse_der_internal_51
   \      0x402   0x9908             LDR      R1,[SP, #+32]
   \      0x404   0xAB10             ADD      R3,SP,#+64
   \      0x406   0xAA0D             ADD      R2,SP,#+52
   \      0x408   0xA802             ADD      R0,SP,#+8
   \      0x40A   0x.... 0x....      BL       mbedtls_x509_get_alg
   \      0x40E   0x0004             MOVS     R4,R0
   \      0x410   0xF000 0x814C      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_52
   \      0x414   0xE6D7             B.N      ??mbedtls_x509_crt_parse_der_internal_22
   \                     ??mbedtls_x509_crt_parse_der_internal_48: (+1)
   \      0x416   0x9804             LDR      R0,[SP, #+16]
   \      0x418   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x41C   0x2800             CMP      R0,#+0
   \                     ??mbedtls_x509_crt_parse_der_internal_53: (+1)
   \      0x41E   0xD096             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_32
   \      0x420   0x.... 0x....      LDR.W    R4,??DataTable37_6
   \                     ??mbedtls_x509_crt_parse_der_internal_50: (+1)
   \      0x424   0xE6BC             B.N      ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_47: (+1)
   \      0x426   0x6EB1             LDR      R1,[R6, #+104]
   \      0x428   0x9806             LDR      R0,[SP, #+24]
   \      0x42A   0x4201             TST      R1,R0
   \      0x42C   0xF43F 0xAF69      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_33
   \      0x430   0x9C17             LDR      R4,[SP, #+92]
   \      0x432   0xE6B5             B.N      ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_37: (+1)
   \      0x434   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_0: (+1)
   \      0x438   0xF505 0x77F0      ADD      R7,R5,#+480
   \      0x43C   0x0004             MOVS     R4,R0
   \      0x43E   0xBF18             IT       NE
   \      0x440   0xF5A0 0x5414      SUBNE    R4,R0,#+9472
   \      0x444   0xD153             BNE.N    ??mbedtls_x509_crt_parse_der_internal_54
   \      0x446   0x9802             LDR      R0,[SP, #+8]
   \      0x448   0x9900             LDR      R1,[SP, #+0]
   \      0x44A   0x4401             ADD      R1,R0,R1
   \      0x44C   0x4541             CMP      R1,R8
   \      0x44E   0xD165             BNE.N    ??mbedtls_x509_crt_parse_der_internal_55
   \      0x450   0x9800             LDR      R0,[SP, #+0]
   \      0x452   0x2800             CMP      R0,#+0
   \      0x454   0xD062             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_55
   \      0x456   0x2400             MOVS     R4,#+0
   \                     ??mbedtls_x509_crt_parse_der_internal_56: (+1)
   \      0x458   0x9802             LDR      R0,[SP, #+8]
   \      0x45A   0x9901             LDR      R1,[SP, #+4]
   \      0x45C   0x4288             CMP      R0,R1
   \      0x45E   0xD260             BCS.N    ??mbedtls_x509_crt_parse_der_internal_57
   \      0x460   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_1: (+1)
   \      0x464   0x2800             CMP      R0,#+0
   \      0x466   0xD140             BNE.N    ??mbedtls_x509_crt_parse_der_internal_58
   \      0x468   0x9902             LDR      R1,[SP, #+8]
   \      0x46A   0x9800             LDR      R0,[SP, #+0]
   \      0x46C   0x2306             MOVS     R3,#+6
   \      0x46E   0x466A             MOV      R2,SP
   \      0x470   0xEB01 0x0900      ADD      R9,R1,R0
   \      0x474   0x4649             MOV      R1,R9
   \      0x476   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_18: (+1)
   \      0x47A   0x2800             CMP      R0,#+0
   \      0x47C   0xD135             BNE.N    ??mbedtls_x509_crt_parse_der_internal_58
   \      0x47E   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \      0x482   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \      0x486   0xF1BB 0x0F04      CMP      R11,#+4
   \      0x48A   0xD106             BNE.N    ??mbedtls_x509_crt_parse_der_internal_59
   \      0x48C   0x2204             MOVS     R2,#+4
   \      0x48E   0x4651             MOV      R1,R10
   \      0x490   0x.... 0x....      ADR.W    R0,?_24
   \      0x494   0x.... 0x....      BL       memcmp
   \      0x498   0xB108             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_60
   \                     ??mbedtls_x509_crt_parse_der_internal_59: (+1)
   \      0x49A   0x.... 0x....      LDR.W    R4,??DataTable38
   \                     ??mbedtls_x509_crt_parse_der_internal_60: (+1)
   \      0x49E   0x68B8             LDR      R0,[R7, #+8]
   \      0x4A0   0xB140             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_61
   \      0x4A2   0x68F8             LDR      R0,[R7, #+12]
   \      0x4A4   0xB9E0             CBNZ.N   R0,??mbedtls_x509_crt_parse_der_internal_62
   \      0x4A6   0x2110             MOVS     R1,#+16
   \      0x4A8   0x2001             MOVS     R0,#+1
   \      0x4AA   0x.... 0x....      BL       sl_calloc
   \      0x4AE   0x60F8             STR      R0,[R7, #+12]
   \      0x4B0   0x0007             MOVS     R7,R0
   \      0x4B2   0xD017             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_63
   \                     ??mbedtls_x509_crt_parse_der_internal_61: (+1)
   \      0x4B4   0x2006             MOVS     R0,#+6
   \      0x4B6   0x6038             STR      R0,[R7, #+0]
   \      0x4B8   0xF8C7 0xA008      STR      R10,[R7, #+8]
   \      0x4BC   0xF8C7 0xB004      STR      R11,[R7, #+4]
   \      0x4C0   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x4C4   0x4548             CMP      R0,R9
   \      0x4C6   0xD207             BCS.N    ??CrossCallReturnLabel_5
   \      0x4C8   0x2330             MOVS     R3,#+48
   \      0x4CA   0x466A             MOV      R2,SP
   \      0x4CC   0x4649             MOV      R1,R9
   \      0x4CE   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_19: (+1)
   \      0x4D2   0xB950             CBNZ.N   R0,??mbedtls_x509_crt_parse_der_internal_58
   \      0x4D4   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x4D8   0x9802             LDR      R0,[SP, #+8]
   \      0x4DA   0x4548             CMP      R0,R9
   \      0x4DC   0xD0BC             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_56
   \      0x4DE   0xE01D             B.N      ??mbedtls_x509_crt_parse_der_internal_55
   \                     ??mbedtls_x509_crt_parse_der_internal_62: (+1)
   \      0x4E0   0x9C17             LDR      R4,[SP, #+92]
   \      0x4E2   0xE787             B.N      ??mbedtls_x509_crt_parse_der_internal_49
   \                     ??mbedtls_x509_crt_parse_der_internal_63: (+1)
   \      0x4E4   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \      0x4E8   0xE784             B.N      ??mbedtls_x509_crt_parse_der_internal_49
   \                     ??mbedtls_x509_crt_parse_der_internal_58: (+1)
   \      0x4EA   0xF5A0 0x5414      SUB      R4,R0,#+9472
   \                     ??mbedtls_x509_crt_parse_der_internal_54: (+1)
   \      0x4EE   0x2C00             CMP      R4,#+0
   \      0x4F0   0xD095             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_53
   \      0x4F2   0x.... 0x....      LDR.W    R7,??DataTable38
   \      0x4F6   0x42BC             CMP      R4,R7
   \      0x4F8   0xD10A             BNE.N    ??mbedtls_x509_crt_parse_der_internal_64
   \      0x4FA   0x9824             LDR      R0,[SP, #+144]
   \      0x4FC   0xB140             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_64
   \      0x4FE   0x9818             LDR      R0,[SP, #+96]
   \      0x500   0x9B04             LDR      R3,[SP, #+16]
   \      0x502   0xF8DD 0xC090      LDR      R12,[SP, #+144]
   \      0x506   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_46: (+1)
   \      0x50A   0x47E0             BLX      R12
   \      0x50C   0x2800             CMP      R0,#+0
   \      0x50E   0xD086             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_53
   \                     ??mbedtls_x509_crt_parse_der_internal_64: (+1)
   \      0x510   0x9804             LDR      R0,[SP, #+16]
   \      0x512   0x2800             CMP      R0,#+0
   \      0x514   0xD101             BNE.N    ??mbedtls_x509_crt_parse_der_internal_65
   \      0x516   0x42BC             CMP      R4,R7
   \                     ??mbedtls_x509_crt_parse_der_internal_66: (+1)
   \      0x518   0xD010             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_67
   \                     ??mbedtls_x509_crt_parse_der_internal_65: (+1)
   \      0x51A   0xE76B             B.N      ??mbedtls_x509_crt_parse_der_internal_49
   \                     ??mbedtls_x509_crt_parse_der_internal_55: (+1)
   \      0x51C   0x.... 0x....      LDR.W    R4,??DataTable38_2
   \                     ??mbedtls_x509_crt_parse_der_internal_68: (+1)
   \      0x520   0xE768             B.N      ??mbedtls_x509_crt_parse_der_internal_49
   \                     ??mbedtls_x509_crt_parse_der_internal_57: (+1)
   \      0x522   0x2000             MOVS     R0,#+0
   \      0x524   0x60F8             STR      R0,[R7, #+12]
   \      0x526   0x9902             LDR      R1,[SP, #+8]
   \      0x528   0x4541             CMP      R1,R8
   \      0x52A   0xD1F7             BNE.N    ??mbedtls_x509_crt_parse_der_internal_55
   \      0x52C   0xE7DF             B.N      ??mbedtls_x509_crt_parse_der_internal_54
   \                     ??mbedtls_x509_crt_parse_der_internal_41: (+1)
   \      0x52E   0xF505 0x7204      ADD      R2,R5,#+528
   \      0x532   0x4641             MOV      R1,R8
   \      0x534   0xA802             ADD      R0,SP,#+8
   \      0x536   0x.... 0x....      BL       mbedtls_x509_get_ns_cert_type
   \                     ??mbedtls_x509_crt_parse_der_internal_69: (+1)
   \      0x53A   0x0004             MOVS     R4,R0
   \                     ??mbedtls_x509_crt_parse_der_internal_67: (+1)
   \      0x53C   0xF43F 0xAF07      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_32
   \      0x540   0xE62E             B.N      ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_38: (+1)
   \      0x542   0xF505 0x72C8      ADD      R2,R5,#+400
   \      0x546   0x4641             MOV      R1,R8
   \      0x548   0xA802             ADD      R0,SP,#+8
   \      0x54A   0x.... 0x....      BL       mbedtls_x509_get_subject_alt_name
   \      0x54E   0xE7F4             B.N      ??mbedtls_x509_crt_parse_der_internal_69
   \                     ??mbedtls_x509_crt_parse_der_internal_34: (+1)
   \      0x550   0x2000             MOVS     R0,#+0
   \      0x552   0x9000             STR      R0,[SP, #+0]
   \      0x554   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x558   0x0004             MOVS     R4,R0
   \      0x55A   0xD003             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_70
   \                     ??mbedtls_x509_crt_parse_der_internal_71: (+1)
   \      0x55C   0xF5A0 0x5414      SUB      R4,R0,#+9472
   \                     ??mbedtls_x509_crt_parse_der_internal_72: (+1)
   \      0x560   0x2C00             CMP      R4,#+0
   \      0x562   0xE7D9             B.N      ??mbedtls_x509_crt_parse_der_internal_66
   \                     ??mbedtls_x509_crt_parse_der_internal_70: (+1)
   \      0x564   0x9902             LDR      R1,[SP, #+8]
   \      0x566   0x9800             LDR      R0,[SP, #+0]
   \      0x568   0x4408             ADD      R0,R1,R0
   \      0x56A   0x4540             CMP      R0,R8
   \      0x56C   0xD1D6             BNE.N    ??mbedtls_x509_crt_parse_der_internal_55
   \      0x56E   0x2380             MOVS     R3,#+128
   \      0x570   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x574   0x0004             MOVS     R4,R0
   \      0x576   0xD111             BNE.N    ??mbedtls_x509_crt_parse_der_internal_73
   \      0x578   0x9900             LDR      R1,[SP, #+0]
   \      0x57A   0x2204             MOVS     R2,#+4
   \      0x57C   0x62B1             STR      R1,[R6, #+40]
   \      0x57E   0x9802             LDR      R0,[SP, #+8]
   \      0x580   0x6272             STR      R2,[R6, #+36]
   \      0x582   0x62F0             STR      R0,[R6, #+44]
   \      0x584   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \      0x588   0x9902             LDR      R1,[SP, #+8]
   \      0x58A   0x9801             LDR      R0,[SP, #+4]
   \      0x58C   0x4281             CMP      R1,R0
   \      0x58E   0xD220             BCS.N    ??CrossCallReturnLabel_7
   \      0x590   0x23A1             MOVS     R3,#+161
   \      0x592   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_21: (+1)
   \      0x596   0x0004             MOVS     R4,R0
   \      0x598   0xD004             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_74
   \      0x59A   0xE7DF             B.N      ??mbedtls_x509_crt_parse_der_internal_71
   \                     ??mbedtls_x509_crt_parse_der_internal_73: (+1)
   \      0x59C   0xF110 0x0F62      CMN      R0,#+98
   \      0x5A0   0xD0F2             BEQ.N    ??CrossCallReturnLabel_6
   \      0x5A2   0xE7DB             B.N      ??mbedtls_x509_crt_parse_der_internal_71
   \                     ??mbedtls_x509_crt_parse_der_internal_74: (+1)
   \      0x5A4   0x9802             LDR      R0,[SP, #+8]
   \      0x5A6   0x9900             LDR      R1,[SP, #+0]
   \      0x5A8   0xF505 0x72DC      ADD      R2,R5,#+440
   \      0x5AC   0x4401             ADD      R1,R0,R1
   \      0x5AE   0xA802             ADD      R0,SP,#+8
   \      0x5B0   0x.... 0x....      BL       mbedtls_x509_get_subject_alt_name_ext
   \      0x5B4   0x0004             MOVS     R4,R0
   \      0x5B6   0xD1B3             BNE.N    ??mbedtls_x509_crt_parse_der_internal_68
   \      0x5B8   0x2382             MOVS     R3,#+130
   \      0x5BA   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_22: (+1)
   \      0x5BE   0x0004             MOVS     R4,R0
   \      0x5C0   0xD1CC             BNE.N    ??mbedtls_x509_crt_parse_der_internal_71
   \      0x5C2   0x9800             LDR      R0,[SP, #+0]
   \      0x5C4   0x6470             STR      R0,[R6, #+68]
   \      0x5C6   0x9902             LDR      R1,[SP, #+8]
   \      0x5C8   0x2002             MOVS     R0,#+2
   \      0x5CA   0x6430             STR      R0,[R6, #+64]
   \      0x5CC   0x64B1             STR      R1,[R6, #+72]
   \      0x5CE   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \      0x5D2   0x9902             LDR      R1,[SP, #+8]
   \      0x5D4   0x4541             CMP      R1,R8
   \                     ??mbedtls_x509_crt_parse_der_internal_75: (+1)
   \      0x5D6   0xD05D             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_76
   \                     ??mbedtls_x509_crt_parse_der_internal_77: (+1)
   \      0x5D8   0xE7A0             B.N      ??mbedtls_x509_crt_parse_der_internal_55
   \                     ??mbedtls_x509_crt_parse_der_internal_35: (+1)
   \      0x5DA   0x2000             MOVS     R0,#+0
   \      0x5DC   0x9000             STR      R0,[SP, #+0]
   \      0x5DE   0x2304             MOVS     R3,#+4
   \      0x5E0   0x466A             MOV      R2,SP
   \      0x5E2   0x4639             MOV      R1,R7
   \      0x5E4   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_23: (+1)
   \      0x5E8   0x0004             MOVS     R4,R0
   \      0x5EA   0xD1B7             BNE.N    ??mbedtls_x509_crt_parse_der_internal_71
   \      0x5EC   0x9800             LDR      R0,[SP, #+0]
   \      0x5EE   0x2104             MOVS     R1,#+4
   \      0x5F0   0x61B1             STR      R1,[R6, #+24]
   \      0x5F2   0x61F0             STR      R0,[R6, #+28]
   \      0x5F4   0x9802             LDR      R0,[SP, #+8]
   \      0x5F6   0x6230             STR      R0,[R6, #+32]
   \      0x5F8   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x5FC   0x42B8             CMP      R0,R7
   \      0x5FE   0xE7EA             B.N      ??mbedtls_x509_crt_parse_der_internal_75
   \                     ??mbedtls_x509_crt_parse_der_internal_40: (+1)
   \      0x600   0x2306             MOVS     R3,#+6
   \      0x602   0xF505 0x7200      ADD      R2,R5,#+512
   \      0x606   0x4641             MOV      R1,R8
   \      0x608   0xA802             ADD      R0,SP,#+8
   \      0x60A   0x.... 0x....      BL       mbedtls_asn1_get_sequence_of
   \      0x60E   0x0004             MOVS     R4,R0
   \      0x610   0xD1A4             BNE.N    ??mbedtls_x509_crt_parse_der_internal_71
   \      0x612   0xF8D5 0x0208      LDR      R0,[R5, #+520]
   \      0x616   0x2800             CMP      R0,#+0
   \      0x618   0xD13C             BNE.N    ??mbedtls_x509_crt_parse_der_internal_76
   \      0x61A   0xE03C             B.N      ??mbedtls_x509_crt_parse_der_internal_78
   \                     ??mbedtls_x509_crt_parse_der_internal_36: (+1)
   \      0x61C   0xF505 0x72FE      ADD      R2,R5,#+508
   \      0x620   0x4641             MOV      R1,R8
   \      0x622   0xA802             ADD      R0,SP,#+8
   \      0x624   0x.... 0x....      BL       mbedtls_x509_get_key_usage
   \      0x628   0xE787             B.N      ??mbedtls_x509_crt_parse_der_internal_69
   \                     ??mbedtls_x509_crt_parse_der_internal_39: (+1)
   \      0x62A   0x2000             MOVS     R0,#+0
   \      0x62C   0x66F0             STR      R0,[R6, #+108]
   \      0x62E   0x6730             STR      R0,[R6, #+112]
   \      0x630   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x634   0x0004             MOVS     R4,R0
   \                     ??mbedtls_x509_crt_parse_der_internal_79: (+1)
   \      0x636   0xD191             BNE.N    ??mbedtls_x509_crt_parse_der_internal_71
   \      0x638   0x9802             LDR      R0,[SP, #+8]
   \      0x63A   0x4540             CMP      R0,R8
   \      0x63C   0xD02A             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_76
   \      0x63E   0xF505 0x72FA      ADD      R2,R5,#+500
   \      0x642   0x4641             MOV      R1,R8
   \      0x644   0xA802             ADD      R0,SP,#+8
   \      0x646   0x.... 0x....      BL       mbedtls_asn1_get_bool
   \      0x64A   0x0004             MOVS     R4,R0
   \      0x64C   0xD00F             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_80
   \      0x64E   0xF114 0x0F62      CMN      R4,#+98
   \      0x652   0xD105             BNE.N    ??mbedtls_x509_crt_parse_der_internal_81
   \      0x654   0xF505 0x72FA      ADD      R2,R5,#+500
   \      0x658   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_32: (+1)
   \      0x65C   0x0004             MOVS     R4,R0
   \      0x65E   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_82
   \                     ??mbedtls_x509_crt_parse_der_internal_81: (+1)
   \      0x660   0xF5A4 0x5414      SUB      R4,R4,#+9472
   \      0x664   0xE77C             B.N      ??mbedtls_x509_crt_parse_der_internal_72
   \                     ??mbedtls_x509_crt_parse_der_internal_82: (+1)
   \      0x666   0x6EF0             LDR      R0,[R6, #+108]
   \      0x668   0xB108             CBZ.N    R0,??mbedtls_x509_crt_parse_der_internal_80
   \      0x66A   0x2101             MOVS     R1,#+1
   \      0x66C   0x66F1             STR      R1,[R6, #+108]
   \                     ??mbedtls_x509_crt_parse_der_internal_80: (+1)
   \      0x66E   0x9802             LDR      R0,[SP, #+8]
   \      0x670   0x4540             CMP      R0,R8
   \      0x672   0xD00F             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_76
   \      0x674   0xF505 0x72FC      ADD      R2,R5,#+504
   \      0x678   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_33: (+1)
   \      0x67C   0x0004             MOVS     R4,R0
   \      0x67E   0xD1DA             BNE.N    ??mbedtls_x509_crt_parse_der_internal_79
   \      0x680   0x9802             LDR      R0,[SP, #+8]
   \      0x682   0x4540             CMP      R0,R8
   \      0x684   0xD1A8             BNE.N    ??mbedtls_x509_crt_parse_der_internal_77
   \      0x686   0x6F31             LDR      R1,[R6, #+112]
   \      0x688   0xF06F 0x4000      MVN      R0,#+2147483648
   \      0x68C   0x4281             CMP      R1,R0
   \      0x68E   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_78
   \      0x690   0x1C49             ADDS     R1,R1,#+1
   \      0x692   0x6731             STR      R1,[R6, #+112]
   \                     ??mbedtls_x509_crt_parse_der_internal_76: (+1)
   \      0x694   0xE65B             B.N      ??mbedtls_x509_crt_parse_der_internal_32
   \                     ??mbedtls_x509_crt_parse_der_internal_78: (+1)
   \      0x696   0x.... 0x....      LDR.W    R4,??DataTable38_4
   \      0x69A   0xE6AB             B.N      ??mbedtls_x509_crt_parse_der_internal_49
   \                     ??mbedtls_x509_crt_parse_der_internal_42: (+1)
   \      0x69C   0x.... 0x....      LDR.W    R4,??DataTable38
   \      0x6A0   0xE57E             B.N      ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_44: (+1)
   \      0x6A2   0xF43F 0xAEA9      BEQ.W    ??mbedtls_x509_crt_parse_der_internal_31
   \                     ??mbedtls_x509_crt_parse_der_internal_46: (+1)
   \      0x6A6   0x.... 0x....      LDR.W    R4,??DataTable38_2
   \      0x6AA   0xE579             B.N      ??mbedtls_x509_crt_parse_der_internal_19
   \                     ??mbedtls_x509_crt_parse_der_internal_52: (+1)
   \      0x6AC   0x6B2A             LDR      R2,[R5, #+48]
   \      0x6AE   0x980E             LDR      R0,[SP, #+56]
   \      0x6B0   0x4282             CMP      R2,R0
   \      0x6B2   0xD125             BNE.N    ??mbedtls_x509_crt_parse_der_internal_83
   \      0x6B4   0x990F             LDR      R1,[SP, #+60]
   \      0x6B6   0x6B68             LDR      R0,[R5, #+52]
   \      0x6B8   0x.... 0x....      BL       memcmp
   \      0x6BC   0x2800             CMP      R0,#+0
   \      0x6BE   0xBF02             ITTT     EQ
   \      0x6C0   0x980A             LDREQ    R0,[SP, #+40]
   \      0x6C2   0x9910             LDREQ    R1,[SP, #+64]
   \      0x6C4   0x4288             CMPEQ    R0,R1
   \      0x6C6   0xBF02             ITTT     EQ
   \      0x6C8   0x9A0B             LDREQ    R2,[SP, #+44]
   \      0x6CA   0x9811             LDREQ    R0,[SP, #+68]
   \      0x6CC   0x4282             CMPEQ    R2,R0
   \      0x6CE   0xD117             BNE.N    ??mbedtls_x509_crt_parse_der_internal_83
   \      0x6D0   0xB122             CBZ.N    R2,??mbedtls_x509_crt_parse_der_internal_84
   \      0x6D2   0x9912             LDR      R1,[SP, #+72]
   \      0x6D4   0x980C             LDR      R0,[SP, #+48]
   \      0x6D6   0x.... 0x....      BL       memcmp
   \      0x6DA   0xB988             CBNZ.N   R0,??mbedtls_x509_crt_parse_der_internal_83
   \                     ??mbedtls_x509_crt_parse_der_internal_84: (+1)
   \      0x6DC   0x9908             LDR      R1,[SP, #+32]
   \      0x6DE   0xF505 0x7205      ADD      R2,R5,#+532
   \      0x6E2   0xA802             ADD      R0,SP,#+8
   \      0x6E4   0x.... 0x....      BL       mbedtls_x509_get_sig
   \      0x6E8   0x0004             MOVS     R4,R0
   \      0x6EA   0xF47F 0xAD6C      BNE.W    ??mbedtls_x509_crt_parse_der_internal_22
   \      0x6EE   0x9902             LDR      R1,[SP, #+8]
   \      0x6F0   0x9808             LDR      R0,[SP, #+32]
   \      0x6F2   0x4281             CMP      R1,R0
   \      0x6F4   0xD00B             BEQ.N    ??mbedtls_x509_crt_parse_der_internal_13
   \                     ??mbedtls_x509_crt_parse_der_internal_51: (+1)
   \      0x6F6   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_29: (+1)
   \      0x6FA   0x.... 0x....      LDR.W    R4,??DataTable38_5
   \      0x6FE   0xE4FF             B.N      ??mbedtls_x509_crt_parse_der_internal_7
   \                     ??mbedtls_x509_crt_parse_der_internal_83: (+1)
   \      0x700   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_30: (+1)
   \      0x704   0x.... 0x....      LDR.W    R4,??DataTable38_6
   \      0x708   0xE4FA             B.N      ??mbedtls_x509_crt_parse_der_internal_7
   \                     ??mbedtls_x509_crt_parse_der_internal_5: (+1)
   \      0x70A   0x....             LDR.N    R4,??DataTable33_1
   \      0x70C   0xE4F8             B.N      ??mbedtls_x509_crt_parse_der_internal_7
   1373          
   1374              return 0;
   \                     ??mbedtls_x509_crt_parse_der_internal_13: (+1)
   \      0x70E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_parse_der_internal_0: (+1)
   \      0x710   0xB01B             ADD      SP,SP,#+108
   \      0x712   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1375          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0x9825             LDR      R0,[SP, #+148]
   \        0x4   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \        0x8   0xAA13             ADD      R2,SP,#+76
   \        0xA   0x4629             MOV      R1,R5
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \                     ??Subroutine7_0: (+1)
   \        0x2   0xA802             ADD      R0,SP,#+8
   \        0x4   0x.... 0x....      B.W      mbedtls_asn1_get_int

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x.... 0x....      B.W      mbedtls_x509_crt_free

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x466A             MOV      R2,SP
   \        0x2   0x4641             MOV      R1,R8
   \                     ??Subroutine5_0: (+1)
   \        0x4   0xA802             ADD      R0,SP,#+8
   \        0x6   0x.... 0x....      B.W      mbedtls_asn1_get_tag

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x9902             LDR      R1,[SP, #+8]
   \        0x2   0x9800             LDR      R0,[SP, #+0]
   \        0x4   0x4408             ADD      R0,R1,R0
   \        0x6   0x9002             STR      R0,[SP, #+8]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x2330             MOVS     R3,#+48
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x4641             MOV      R1,R8
   \        0x6   0xA802             ADD      R0,SP,#+8
   \        0x8   0x.... 0x....      B.W      mbedtls_asn1_get_tag
   1376          

   \                                 In section .text, align 2, keep-with-next
   1377          int mbedtls_x509_crt_parse_der_nocopy(mbedtls_x509_crt *chain,
   1378                                                const unsigned char *buf,
   1379                                                size_t buflen)
   1380          {
   \                     mbedtls_x509_crt_parse_der_nocopy: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1381              return mbedtls_x509_crt_parse_der_internal(chain, buf, buflen, 0, NULL, NULL);
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x9501             STR      R5,[SP, #+4]
   \        0x6   0x9500             STR      R5,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x....             B.N      ?Subroutine1
   1382          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      BL       mbedtls_x509_crt_parse_der_internal
   \        0x4   0xBD26             POP      {R1,R2,R5,PC}
   1383          

   \                                 In section .text, align 2, keep-with-next
   1384          int mbedtls_x509_crt_parse_der_with_ext_cb(mbedtls_x509_crt *chain,
   1385                                                     const unsigned char *buf,
   1386                                                     size_t buflen,
   1387                                                     int make_copy,
   1388                                                     mbedtls_x509_crt_ext_cb_t cb,
   1389                                                     void *p_ctx)
   1390          {
   \                     mbedtls_x509_crt_parse_der_with_ext_cb: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   1391              return mbedtls_x509_crt_parse_der_internal(chain, buf, buflen, make_copy, cb, p_ctx);
   \        0x2   0x9D07             LDR      R5,[SP, #+28]
   \        0x4   0x9C06             LDR      R4,[SP, #+24]
   \        0x6   0x9501             STR      R5,[SP, #+4]
   \        0x8   0x9400             STR      R4,[SP, #+0]
   \        0xA   0x.... 0x....      BL       mbedtls_x509_crt_parse_der_internal
   \        0xE   0xBD3E             POP      {R1-R5,PC}
   1392          }
   1393          

   \                                 In section .text, align 2, keep-with-next
   1394          int mbedtls_x509_crt_parse_der(mbedtls_x509_crt *chain,
   1395                                         const unsigned char *buf,
   1396                                         size_t buflen)
   1397          {
   \                     mbedtls_x509_crt_parse_der: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1398              return mbedtls_x509_crt_parse_der_internal(chain, buf, buflen, 1, NULL, NULL);
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x9501             STR      R5,[SP, #+4]
   \        0x6   0x9500             STR      R5,[SP, #+0]
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA                      REQUIRE ?Subroutine1
   \        0xA                      ;; // Fall through to label ?Subroutine1
   1399          }
   1400          
   1401          /*
   1402           * Parse one or more PEM certificates from a buffer and add them to the chained
   1403           * list
   1404           */

   \                                 In section .text, align 2, keep-with-next
   1405          int mbedtls_x509_crt_parse(mbedtls_x509_crt *chain,
   1406                                     const unsigned char *buf,
   1407                                     size_t buflen)
   1408          {
   \                     mbedtls_x509_crt_parse: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4605             MOV      R5,R0
   1409          #if defined(MBEDTLS_PEM_PARSE_C)
   1410              int success = 0, first_error = 0, total_failed = 0;
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0xB088             SUB      SP,SP,#+32
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x46B9             MOV      R9,R7
   1411              int buf_format = MBEDTLS_X509_FORMAT_DER;
   1412          #endif
   1413          
   1414              /*
   1415               * Check for valid input
   1416               */
   1417              if (chain == NULL || buf == NULL) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xBF14             ITE      NE
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0x....             LDREQ.N  R0,??DataTable33_1
   1418                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \       0x16   0xD05A             BEQ.N    ??mbedtls_x509_crt_parse_0
   \       0x18   0x0014             MOVS     R4,R2
   1419              }
   1420          
   1421              /*
   1422               * Determine buffer content. Buffer contains either one DER certificate or
   1423               * one or more PEM certificates.
   1424               */
   1425          #if defined(MBEDTLS_PEM_PARSE_C)
   1426              if (buflen != 0 && buf[buflen - 1] == '\0' &&
   1427                  strstr((const char *) buf, "-----BEGIN CERTIFICATE-----") != NULL) {
   \       0x1A   0xD00A             BEQ.N    ??mbedtls_x509_crt_parse_1
   \       0x1C   0x1930             ADDS     R0,R6,R4
   \       0x1E   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \       0x22   0xB930             CBNZ.N   R0,??mbedtls_x509_crt_parse_1
   \       0x24   0x.... 0x....      ADR.W    R10,?_25
   \       0x28   0x4651             MOV      R1,R10
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       strstr
   \       0x30   0xB928             CBNZ.N   R0,??mbedtls_x509_crt_parse_2
   1428                  buf_format = MBEDTLS_X509_FORMAT_PEM;
   1429              }
   1430          
   1431              if (buf_format == MBEDTLS_X509_FORMAT_DER) {
   1432                  return mbedtls_x509_crt_parse_der(chain, buf, buflen);
   \                     ??mbedtls_x509_crt_parse_1: (+1)
   \       0x32   0x4622             MOV      R2,R4
   \       0x34   0x4631             MOV      R1,R6
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0x3C   0xE047             B.N      ??mbedtls_x509_crt_parse_0
   1433              }
   1434          #else
   1435              return mbedtls_x509_crt_parse_der(chain, buf, buflen);
   1436          #endif
   1437          
   1438          #if defined(MBEDTLS_PEM_PARSE_C)
   1439              if (buf_format == MBEDTLS_X509_FORMAT_PEM) {
   1440                  int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \                     ??mbedtls_x509_crt_parse_2: (+1)
   \       0x3E   0x9507             STR      R5,[SP, #+28]
   \       0x40   0x4635             MOV      R5,R6
   \       0x42   0x4626             MOV      R6,R4
   \       0x44   0x.... 0x....      ADR.W    R11,?_26
   \       0x48   0x2400             MOVS     R4,#+0
   \       0x4A   0xE003             B.N      ??mbedtls_x509_crt_parse_3
   1441                  mbedtls_pem_context pem;
   1442          
   1443                  /* 1 rather than 0 since the terminating NULL byte is counted in */
   1444                  while (buflen > 1) {
   1445                      size_t use_len;
   1446                      mbedtls_pem_init(&pem);
   1447          
   1448                      /* If we get there, we know the string is null-terminated */
   1449                      ret = mbedtls_pem_read_buffer(&pem,
   1450                                                    "-----BEGIN CERTIFICATE-----",
   1451                                                    "-----END CERTIFICATE-----",
   1452                                                    buf, NULL, 0, &use_len);
   1453          
   1454                      if (ret == 0) {
   1455                          /*
   1456                           * Was PEM encoded
   1457                           */
   1458                          buflen -= use_len;
   1459                          buf += use_len;
   1460                      } else if (ret == MBEDTLS_ERR_PEM_BAD_INPUT_DATA) {
   1461                          return ret;
   1462                      } else if (ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) {
   1463                          mbedtls_pem_free(&pem);
   1464          
   1465                          /*
   1466                           * PEM header and footer were found
   1467                           */
   1468                          buflen -= use_len;
   1469                          buf += use_len;
   1470          
   1471                          if (first_error == 0) {
   1472                              first_error = ret;
   1473                          }
   1474          
   1475                          total_failed++;
   1476                          continue;
   1477                      } else {
   1478                          break;
   1479                      }
   1480          
   1481                      ret = mbedtls_x509_crt_parse_der(chain, pem.buf, pem.buflen);
   1482          
   1483                      mbedtls_pem_free(&pem);
   1484          
   1485                      if (ret != 0) {
   1486                          /*
   1487                           * Quit parsing on a memory error
   1488                           */
   1489                          if (ret == MBEDTLS_ERR_X509_ALLOC_FAILED) {
   1490                              return ret;
   1491                          }
   1492          
   1493                          if (first_error == 0) {
   \                     ??mbedtls_x509_crt_parse_4: (+1)
   \       0x4C   0xB904             CBNZ.N   R4,??mbedtls_x509_crt_parse_5
   1494                              first_error = ret;
   \       0x4E   0x4644             MOV      R4,R8
   1495                          }
   1496          
   1497                          total_failed++;
   \                     ??mbedtls_x509_crt_parse_5: (+1)
   \       0x50   0xF109 0x0901      ADD      R9,R9,#+1
   1498                          continue;
   \                     ??mbedtls_x509_crt_parse_3: (+1)
   \       0x54   0x2E02             CMP      R6,#+2
   \       0x56   0xD333             BCC.N    ??mbedtls_x509_crt_parse_6
   \       0x58   0xA804             ADD      R0,SP,#+16
   \       0x5A   0x.... 0x....      BL       mbedtls_pem_init
   \       0x5E   0xAA03             ADD      R2,SP,#+12
   \       0x60   0x2100             MOVS     R1,#+0
   \       0x62   0x9202             STR      R2,[SP, #+8]
   \       0x64   0x9101             STR      R1,[SP, #+4]
   \       0x66   0x9100             STR      R1,[SP, #+0]
   \       0x68   0x462B             MOV      R3,R5
   \       0x6A   0x465A             MOV      R2,R11
   \       0x6C   0x4651             MOV      R1,R10
   \       0x6E   0xA804             ADD      R0,SP,#+16
   \       0x70   0x.... 0x....      BL       mbedtls_pem_read_buffer
   \       0x74   0xEA5F 0x0800      MOVS     R8,R0
   \       0x78   0xD110             BNE.N    ??mbedtls_x509_crt_parse_7
   \       0x7A   0x9903             LDR      R1,[SP, #+12]
   \       0x7C   0x1A76             SUBS     R6,R6,R1
   \       0x7E   0x9A05             LDR      R2,[SP, #+20]
   \       0x80   0x186D             ADDS     R5,R5,R1
   \       0x82   0x9904             LDR      R1,[SP, #+16]
   \       0x84   0x9807             LDR      R0,[SP, #+28]
   \       0x86   0x.... 0x....      BL       mbedtls_x509_crt_parse_der
   \       0x8A   0x4680             MOV      R8,R0
   \       0x8C   0xA804             ADD      R0,SP,#+16
   \       0x8E   0x.... 0x....      BL       mbedtls_pem_free
   \       0x92   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x96   0xD10E             BNE.N    ??mbedtls_x509_crt_parse_8
   1499                      }
   1500          
   1501                      success = 1;
   \       0x98   0x2701             MOVS     R7,#+1
   \       0x9A   0xE7DB             B.N      ??mbedtls_x509_crt_parse_3
   \                     ??mbedtls_x509_crt_parse_7: (+1)
   \       0x9C   0xF518 0x5FA4      CMN      R8,#+5248
   \       0xA0   0xD00C             BEQ.N    ??mbedtls_x509_crt_parse_9
   \       0xA2   0xF518 0x5F84      CMN      R8,#+4224
   \       0xA6   0xD00B             BEQ.N    ??mbedtls_x509_crt_parse_6
   \       0xA8   0xA804             ADD      R0,SP,#+16
   \       0xAA   0x.... 0x....      BL       mbedtls_pem_free
   \       0xAE   0x9903             LDR      R1,[SP, #+12]
   \       0xB0   0x1A76             SUBS     R6,R6,R1
   \       0xB2   0x186D             ADDS     R5,R5,R1
   \       0xB4   0xE7CA             B.N      ??mbedtls_x509_crt_parse_4
   \                     ??mbedtls_x509_crt_parse_8: (+1)
   \       0xB6   0xF518 0x5F22      CMN      R8,#+10368
   \       0xBA   0xD1C7             BNE.N    ??mbedtls_x509_crt_parse_4
   \                     ??mbedtls_x509_crt_parse_9: (+1)
   \       0xBC   0x4640             MOV      R0,R8
   \       0xBE   0xE006             B.N      ??mbedtls_x509_crt_parse_0
   1502                  }
   1503              }
   \                     ??mbedtls_x509_crt_parse_6: (+1)
   \       0xC0   0x4620             MOV      R0,R4
   1504          
   1505              if (success) {
   \       0xC2   0xB10F             CBZ.N    R7,??mbedtls_x509_crt_parse_10
   1506                  return total_failed;
   \       0xC4   0x4648             MOV      R0,R9
   \       0xC6   0xE002             B.N      ??mbedtls_x509_crt_parse_0
   1507              } else if (first_error) {
   \                     ??mbedtls_x509_crt_parse_10: (+1)
   \       0xC8   0xB908             CBNZ.N   R0,??mbedtls_x509_crt_parse_0
   1508                  return first_error;
   1509              } else {
   1510                  return MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT;
   \       0xCA   0x.... 0x....      LDR.W    R0,??DataTable38_7
   \                     ??mbedtls_x509_crt_parse_0: (+1)
   \       0xCE   0xB009             ADD      SP,SP,#+36
   \       0xD0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1511              }
   1512          #endif /* MBEDTLS_PEM_PARSE_C */
   1513          }
   1514          
   1515          #if defined(MBEDTLS_FS_IO)
   1516          /*
   1517           * Load one or more certificates and add them to the chained list
   1518           */
   1519          int mbedtls_x509_crt_parse_file(mbedtls_x509_crt *chain, const char *path)
   1520          {
   1521              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1522              size_t n;
   1523              unsigned char *buf;
   1524          
   1525              if ((ret = mbedtls_pk_load_file(path, &buf, &n)) != 0) {
   1526                  return ret;
   1527              }
   1528          
   1529              ret = mbedtls_x509_crt_parse(chain, buf, n);
   1530          
   1531              mbedtls_zeroize_and_free(buf, n);
   1532          
   1533              return ret;
   1534          }
   1535          
   1536          #if !defined( MBEDTLS_X509_CRT_PARSE_PATH_ALT )
   1537          int mbedtls_x509_crt_parse_path(mbedtls_x509_crt *chain, const char *path)
   1538          {
   1539              int ret = 0;
   1540          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
   1541              int w_ret;
   1542              WCHAR szDir[MAX_PATH];
   1543              char filename[MAX_PATH];
   1544              char *p;
   1545              size_t len = strlen(path);
   1546          
   1547              WIN32_FIND_DATAW file_data;
   1548              HANDLE hFind;
   1549          
   1550              if (len > MAX_PATH - 3) {
   1551                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1552              }
   1553          
   1554              memset(szDir, 0, sizeof(szDir));
   1555              memset(filename, 0, MAX_PATH);
   1556              memcpy(filename, path, len);
   1557              filename[len++] = '\\';
   1558              p = filename + len;
   1559              filename[len++] = '*';
   1560          
   1561              /*
   1562               * Note this function uses the code page CP_ACP which is the system default
   1563               * ANSI codepage. The input string is always described in BYTES and the
   1564               * output length is described in WCHARs.
   1565               */
   1566              w_ret = MultiByteToWideChar(CP_ACP, 0, filename, (int) len, szDir,
   1567                                          MAX_PATH - 3);
   1568              if (w_ret == 0) {
   1569                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1570              }
   1571          
   1572              hFind = FindFirstFileW(szDir, &file_data);
   1573              if (hFind == INVALID_HANDLE_VALUE) {
   1574                  return MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1575              }
   1576          
   1577              len = MAX_PATH - len;
   1578              do {
   1579                  memset(p, 0, len);
   1580          
   1581                  if (file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
   1582                      continue;
   1583                  }
   1584                  w_ret = WideCharToMultiByte(CP_ACP, 0, file_data.cFileName,
   1585                                              -1, p, (int) len, NULL, NULL);
   1586                  if (w_ret == 0) {
   1587                      ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1588                      goto cleanup;
   1589                  }
   1590          
   1591                  w_ret = mbedtls_x509_crt_parse_file(chain, filename);
   1592                  if (w_ret < 0) {
   1593                      ret++;
   1594                  } else {
   1595                      ret += w_ret;
   1596                  }
   1597              } while (FindNextFileW(hFind, &file_data) != 0);
   1598          
   1599              if (GetLastError() != ERROR_NO_MORE_FILES) {
   1600                  ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1601              }
   1602          
   1603          cleanup:
   1604              FindClose(hFind);
   1605          #else /* _WIN32 */
   1606              int t_ret;
   1607              int snp_ret;
   1608              struct stat sb;
   1609              struct dirent *entry;
   1610              char entry_name[MBEDTLS_X509_MAX_FILE_PATH_LEN];
   1611              DIR *dir = opendir(path);
   1612          
   1613              if (dir == NULL) {
   1614                  return MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1615              }
   1616          
   1617          #if defined(MBEDTLS_THREADING_C)
   1618              if ((ret = mbedtls_mutex_lock(&mbedtls_threading_readdir_mutex)) != 0) {
   1619                  closedir(dir);
   1620                  return ret;
   1621              }
   1622          #endif /* MBEDTLS_THREADING_C */
   1623          
   1624              memset(&sb, 0, sizeof(sb));
   1625          
   1626              while ((entry = readdir(dir)) != NULL) {
   1627                  snp_ret = mbedtls_snprintf(entry_name, sizeof(entry_name),
   1628                                             "%s/%s", path, entry->d_name);
   1629          
   1630                  if (snp_ret < 0 || (size_t) snp_ret >= sizeof(entry_name)) {
   1631                      ret = MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
   1632                      goto cleanup;
   1633                  } else if (stat(entry_name, &sb) == -1) {
   1634                      if (errno == ENOENT) {
   1635                          /* Broken symbolic link - ignore this entry.
   1636                              stat(2) will return this error for either (a) a dangling
   1637                              symlink or (b) a missing file.
   1638                              Given that we have just obtained the filename from readdir,
   1639                              assume that it does exist and therefore treat this as a
   1640                              dangling symlink. */
   1641                          continue;
   1642                      } else {
   1643                          /* Some other file error; report the error. */
   1644                          ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
   1645                          goto cleanup;
   1646                      }
   1647                  }
   1648          
   1649                  if (!S_ISREG(sb.st_mode)) {
   1650                      continue;
   1651                  }
   1652          
   1653                  // Ignore parse errors
   1654                  //
   1655                  t_ret = mbedtls_x509_crt_parse_file(chain, entry_name);
   1656                  if (t_ret < 0) {
   1657                      ret++;
   1658                  } else {
   1659                      ret += t_ret;
   1660                  }
   1661              }
   1662          
   1663          cleanup:
   1664              closedir(dir);
   1665          
   1666          #if defined(MBEDTLS_THREADING_C)
   1667              if (mbedtls_mutex_unlock(&mbedtls_threading_readdir_mutex) != 0) {
   1668                  ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
   1669              }
   1670          #endif /* MBEDTLS_THREADING_C */
   1671          
   1672          #endif /* _WIN32 */
   1673          
   1674              return ret;
   1675          }
   1676          #endif /* #if !defined( MBEDTLS_X509_CRT_PARSE_PATH_ALT ) */
   1677          #endif /* MBEDTLS_FS_IO */
   1678          
   1679          #if !defined(MBEDTLS_X509_REMOVE_INFO)
   1680          #define PRINT_ITEM(i)                               \
   1681              do {                                            \
   1682                  ret = mbedtls_snprintf(p, n, "%s" i, sep);  \
   1683                  MBEDTLS_X509_SAFE_SNPRINTF;                 \
   1684                  sep = ", ";                                 \
   1685              } while (0)
   1686          
   1687          #define CERT_TYPE(type, name)          \
   1688              do {                               \
   1689                  if (ns_cert_type & (type)) {   \
   1690                      PRINT_ITEM(name);          \
   1691                  }                              \
   1692              } while (0)
   1693          
   1694          #define KEY_USAGE(code, name)      \
   1695              do {                           \
   1696                  if (key_usage & (code)) {  \
   1697                      PRINT_ITEM(name);      \
   1698                  }                          \
   1699              } while (0)
   1700          
   1701          static int x509_info_ext_key_usage(char **buf, size_t *size,
   1702                                             const mbedtls_x509_sequence *extended_key_usage)
   1703          {
   1704              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1705              const char *desc;
   1706              size_t n = *size;
   1707              char *p = *buf;
   1708              const mbedtls_x509_sequence *cur = extended_key_usage;
   1709              const char *sep = "";
   1710          
   1711              while (cur != NULL) {
   1712                  if (mbedtls_oid_get_extended_key_usage(&cur->buf, &desc) != 0) {
   1713                      desc = "???";
   1714                  }
   1715          
   1716                  ret = mbedtls_snprintf(p, n, "%s%s", sep, desc);
   1717                  MBEDTLS_X509_SAFE_SNPRINTF;
   1718          
   1719                  sep = ", ";
   1720          
   1721                  cur = cur->next;
   1722              }
   1723          
   1724              *size = n;
   1725              *buf = p;
   1726          
   1727              return 0;
   1728          }
   1729          
   1730          static int x509_info_cert_policies(char **buf, size_t *size,
   1731                                             const mbedtls_x509_sequence *certificate_policies)
   1732          {
   1733              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1734              const char *desc;
   1735              size_t n = *size;
   1736              char *p = *buf;
   1737              const mbedtls_x509_sequence *cur = certificate_policies;
   1738              const char *sep = "";
   1739          
   1740              while (cur != NULL) {
   1741                  if (mbedtls_oid_get_certificate_policies(&cur->buf, &desc) != 0) {
   1742                      desc = "???";
   1743                  }
   1744          
   1745                  ret = mbedtls_snprintf(p, n, "%s%s", sep, desc);
   1746                  MBEDTLS_X509_SAFE_SNPRINTF;
   1747          
   1748                  sep = ", ";
   1749          
   1750                  cur = cur->next;
   1751              }
   1752          
   1753              *size = n;
   1754              *buf = p;
   1755          
   1756              return 0;
   1757          }
   1758          
   1759          /*
   1760           * Return an informational string about the certificate.
   1761           */
   1762          #define BEFORE_COLON    18
   1763          #define BC              "18"

   \                                 In section .text, align 2, keep-with-next
   1764          int mbedtls_x509_crt_info(char *buf, size_t size, const char *prefix,
   1765                                    const mbedtls_x509_crt *crt)
   1766          {
   \                     mbedtls_x509_crt_info: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0xEA5F 0x0803      MOVS     R8,R3
   1767              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1768              size_t n;
   1769              char *p;
   1770              char key_size_str[BEFORE_COLON];
   1771          
   1772              p = buf;
   \        0xC   0x9007             STR      R0,[SP, #+28]
   1773              n = size;
   \        0xE   0xF8CD 0x9018      STR      R9,[SP, #+24]
   1774          
   1775              if (NULL == crt) {
   \       0x12   0xD10C             BNE.N    ??mbedtls_x509_crt_info_0
   1776                  ret = mbedtls_snprintf(p, n, "\nCertificate is uninitialised!\n");
   \       0x14   0x9807             LDR      R0,[SP, #+28]
   \       0x16   0x.... 0x....      ADR.W    R2,?_31
   \       0x1A   0x.... 0x....      BL       snprintf
   1777                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD412             BMI.N    ??mbedtls_x509_crt_info_1
   \       0x22   0x9A06             LDR      R2,[SP, #+24]
   \       0x24   0x4290             CMP      R0,R2
   \       0x26   0xD213             BCS.N    ??mbedtls_x509_crt_info_2
   1778          
   1779                  return (int) (size - n);
   \       0x28   0xEBA9 0x0102      SUB      R1,R9,R2
   \       0x2C   0xE1CE             B.N      ??mbedtls_x509_crt_info_3
   1780              }
   1781          
   1782              ret = mbedtls_snprintf(p, n, "%scert. version     : %d\n",
   1783                                     prefix, crt->version);
   \                     ??mbedtls_x509_crt_info_0: (+1)
   \       0x2E   0xF108 0x041C      ADD      R4,R8,#+28
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x9906             LDR      R1,[SP, #+24]
   \       0x36   0x4692             MOV      R10,R2
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x9807             LDR      R0,[SP, #+28]
   \       0x3C   0x4653             MOV      R3,R10
   \       0x3E   0x.... 0x....      ADR.W    R2,?_32
   \       0x42   0x.... 0x....      BL       snprintf
   1784              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x46   0x2800             CMP      R0,#+0
   \                     ??mbedtls_x509_crt_info_1: (+1)
   \       0x48   0xF100 0x81BB      BMI.W    ??mbedtls_x509_crt_info_4
   \       0x4C   0x9A06             LDR      R2,[SP, #+24]
   \       0x4E   0x4290             CMP      R0,R2
   \                     ??mbedtls_x509_crt_info_2: (+1)
   \       0x50   0xF080 0x81B7      BCS.W    ??mbedtls_x509_crt_info_4
   \       0x54   0x.... 0x....      BL       ?Subroutine8
   1785              ret = mbedtls_snprintf(p, n, "%sserial number     : ",
   1786                                     prefix);
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x58   0x.... 0x....      ADR.W    R2,?_33
   \       0x5C   0x.... 0x....      BL       snprintf
   1787              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD468             BMI.N    ??mbedtls_x509_crt_info_5
   \       0x64   0x9A06             LDR      R2,[SP, #+24]
   \       0x66   0x4290             CMP      R0,R2
   \       0x68   0xD269             BCS.N    ??mbedtls_x509_crt_info_6
   \       0x6A   0x.... 0x....      BL       ?Subroutine11
   1788          
   1789              ret = mbedtls_x509_serial_gets(p, n, &crt->serial);
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x6E   0xF108 0x0220      ADD      R2,R8,#+32
   \       0x72   0x.... 0x....      BL       mbedtls_x509_serial_gets
   1790              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD45D             BMI.N    ??mbedtls_x509_crt_info_5
   \       0x7A   0x9A06             LDR      R2,[SP, #+24]
   \       0x7C   0x4290             CMP      R0,R2
   \       0x7E   0xD25E             BCS.N    ??mbedtls_x509_crt_info_6
   \       0x80   0x.... 0x....      BL       ?Subroutine8
   1791          
   1792              ret = mbedtls_snprintf(p, n, "\n%sissuer name       : ", prefix);
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x84   0x.... 0x....      ADR.W    R2,?_34
   \       0x88   0x.... 0x....      BL       snprintf
   1793              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD452             BMI.N    ??mbedtls_x509_crt_info_5
   \       0x90   0x9A06             LDR      R2,[SP, #+24]
   \       0x92   0x4290             CMP      R0,R2
   \       0x94   0xD253             BCS.N    ??mbedtls_x509_crt_info_6
   \       0x96   0x.... 0x....      BL       ?Subroutine11
   1794              ret = mbedtls_x509_dn_gets(p, n, &crt->issuer);
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0x9A   0xF108 0x0250      ADD      R2,R8,#+80
   \       0x9E   0x.... 0x....      BL       mbedtls_x509_dn_gets
   1795              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD447             BMI.N    ??mbedtls_x509_crt_info_5
   \       0xA6   0x9A06             LDR      R2,[SP, #+24]
   \       0xA8   0x4290             CMP      R0,R2
   \       0xAA   0xD248             BCS.N    ??mbedtls_x509_crt_info_6
   \       0xAC   0x.... 0x....      BL       ?Subroutine8
   1796          
   1797              ret = mbedtls_snprintf(p, n, "\n%ssubject name      : ", prefix);
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0xB0   0x.... 0x....      ADR.W    R2,?_35
   \       0xB4   0x.... 0x....      BL       snprintf
   1798              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD43C             BMI.N    ??mbedtls_x509_crt_info_5
   \       0xBC   0x9A06             LDR      R2,[SP, #+24]
   \       0xBE   0x4290             CMP      R0,R2
   \       0xC0   0xD23D             BCS.N    ??mbedtls_x509_crt_info_6
   \       0xC2   0x.... 0x....      BL       ?Subroutine11
   1799              ret = mbedtls_x509_dn_gets(p, n, &crt->subject);
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0xC6   0xF108 0x0270      ADD      R2,R8,#+112
   \       0xCA   0x.... 0x....      BL       mbedtls_x509_dn_gets
   1800              MBEDTLS_X509_SAFE_SNPRINTF;
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD431             BMI.N    ??mbedtls_x509_crt_info_5
   \       0xD2   0x9A06             LDR      R2,[SP, #+24]
   \       0xD4   0x4290             CMP      R0,R2
   \       0xD6   0xD232             BCS.N    ??mbedtls_x509_crt_info_6
   \       0xD8   0x.... 0x....      BL       ?Subroutine14
   1801          
   1802              ret = mbedtls_snprintf(p, n, "\n%sissued  on        : " \
   1803                                           "%04d-%02d-%02d %02d:%02d:%02d", prefix,
   1804                                     crt->valid_from.year, crt->valid_from.mon,
   1805                                     crt->valid_from.day,  crt->valid_from.hour,
   1806                                     crt->valid_from.min,  crt->valid_from.sec);
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0xDC   0xF108 0x069C      ADD      R6,R8,#+156
   \       0xE0   0x4402             ADD      R2,R2,R0
   \       0xE2   0x9207             STR      R2,[SP, #+28]
   \       0xE4   0x68B1             LDR      R1,[R6, #+8]
   \       0xE6   0x.... 0x....      LDR.W    R5,??DataTable39
   \       0xEA   0x4653             MOV      R3,R10
   \       0xEC   0x9105             STR      R1,[SP, #+20]
   \       0xEE   0x6870             LDR      R0,[R6, #+4]
   \       0xF0   0x9004             STR      R0,[SP, #+16]
   \       0xF2   0x6832             LDR      R2,[R6, #+0]
   \       0xF4   0x9203             STR      R2,[SP, #+12]
   \       0xF6   0x6FE1             LDR      R1,[R4, #+124]
   \       0xF8   0x462A             MOV      R2,R5
   \       0xFA   0x9102             STR      R1,[SP, #+8]
   \       0xFC   0x6FA0             LDR      R0,[R4, #+120]
   \       0xFE   0x9001             STR      R0,[SP, #+4]
   \      0x100   0x6F61             LDR      R1,[R4, #+116]
   \      0x102   0x.... 0x....      BL       ?Subroutine12
   1807              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_51: (+1)
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD415             BMI.N    ??mbedtls_x509_crt_info_5
   \      0x10A   0x9A06             LDR      R2,[SP, #+24]
   \      0x10C   0x4290             CMP      R0,R2
   \      0x10E   0xD216             BCS.N    ??mbedtls_x509_crt_info_6
   \      0x110   0x.... 0x....      BL       ?Subroutine13
   1808          
   1809              ret = mbedtls_snprintf(p, n, "\n%sexpires on        : " \
   1810                                           "%04d-%02d-%02d %02d:%02d:%02d", prefix,
   1811                                     crt->valid_to.year, crt->valid_to.mon,
   1812                                     crt->valid_to.day,  crt->valid_to.hour,
   1813                                     crt->valid_to.min,  crt->valid_to.sec);
   \                     ??CrossCallReturnLabel_52: (+1)
   \      0x114   0x6A33             LDR      R3,[R6, #+32]
   \      0x116   0xF105 0x0238      ADD      R2,R5,#+56
   \      0x11A   0x9305             STR      R3,[SP, #+20]
   \      0x11C   0x69F1             LDR      R1,[R6, #+28]
   \      0x11E   0x4653             MOV      R3,R10
   \      0x120   0x9104             STR      R1,[SP, #+16]
   \      0x122   0x69B0             LDR      R0,[R6, #+24]
   \      0x124   0x9003             STR      R0,[SP, #+12]
   \      0x126   0x6971             LDR      R1,[R6, #+20]
   \      0x128   0x9102             STR      R1,[SP, #+8]
   \      0x12A   0x6930             LDR      R0,[R6, #+16]
   \      0x12C   0x9001             STR      R0,[SP, #+4]
   \      0x12E   0x68F1             LDR      R1,[R6, #+12]
   \      0x130   0x.... 0x....      BL       ?Subroutine12
   1814              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??CrossCallReturnLabel_50: (+1)
   \      0x134   0x2800             CMP      R0,#+0
   \                     ??mbedtls_x509_crt_info_5: (+1)
   \      0x136   0xF100 0x8144      BMI.W    ??mbedtls_x509_crt_info_4
   \      0x13A   0x9A06             LDR      R2,[SP, #+24]
   \      0x13C   0x4290             CMP      R0,R2
   \                     ??mbedtls_x509_crt_info_6: (+1)
   \      0x13E   0xF080 0x8140      BCS.W    ??mbedtls_x509_crt_info_4
   \      0x142   0x.... 0x....      BL       ?Subroutine8
   1815          
   1816              ret = mbedtls_snprintf(p, n, "\n%ssigned using      : ", prefix);
   \                     ??CrossCallReturnLabel_37: (+1)
   \      0x146   0x.... 0x....      ADR.W    R2,?_36
   \      0x14A   0x.... 0x....      BL       snprintf
   1817              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD4F1             BMI.N    ??mbedtls_x509_crt_info_5
   \      0x152   0x9A06             LDR      R2,[SP, #+24]
   \      0x154   0x4290             CMP      R0,R2
   \      0x156   0xD2F2             BCS.N    ??mbedtls_x509_crt_info_6
   \      0x158   0x.... 0x....      BL       ?Subroutine14
   1818          
   1819              ret = mbedtls_x509_sig_alg_gets(p, n, &crt->sig_oid, crt->sig_pk,
   1820                                              crt->sig_md, crt->sig_opts);
   \                     ??CrossCallReturnLabel_57: (+1)
   \      0x15C   0xF508 0x7404      ADD      R4,R8,#+528
   \      0x160   0x4402             ADD      R2,R2,R0
   \      0x162   0x9207             STR      R2,[SP, #+28]
   \      0x164   0x6961             LDR      R1,[R4, #+20]
   \      0x166   0xF108 0x022C      ADD      R2,R8,#+44
   \      0x16A   0x9101             STR      R1,[SP, #+4]
   \      0x16C   0x7C20             LDRB     R0,[R4, #+16]
   \      0x16E   0x9906             LDR      R1,[SP, #+24]
   \      0x170   0x9000             STR      R0,[SP, #+0]
   \      0x172   0x7C63             LDRB     R3,[R4, #+17]
   \      0x174   0x9807             LDR      R0,[SP, #+28]
   \      0x176   0x.... 0x....      BL       mbedtls_x509_sig_alg_gets
   1821              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD4DB             BMI.N    ??mbedtls_x509_crt_info_5
   \      0x17E   0x9A06             LDR      R2,[SP, #+24]
   \      0x180   0x4290             CMP      R0,R2
   \      0x182   0xD2DC             BCS.N    ??mbedtls_x509_crt_info_6
   \      0x184   0x1A11             SUBS     R1,R2,R0
   \      0x186   0x9A07             LDR      R2,[SP, #+28]
   1822          
   1823              /* Key size */
   1824              if ((ret = mbedtls_x509_key_size_helper(key_size_str, BEFORE_COLON,
   1825                                                      mbedtls_pk_get_name(&crt->pk))) != 0) {
   \      0x188   0xF108 0x05CC      ADD      R5,R8,#+204
   \      0x18C   0x9106             STR      R1,[SP, #+24]
   \      0x18E   0x4402             ADD      R2,R2,R0
   \      0x190   0x9207             STR      R2,[SP, #+28]
   \      0x192   0x4628             MOV      R0,R5
   \      0x194   0x.... 0x....      BL       mbedtls_pk_get_name
   \      0x198   0x4602             MOV      R2,R0
   \      0x19A   0x2112             MOVS     R1,#+18
   \      0x19C   0xA808             ADD      R0,SP,#+32
   \      0x19E   0x.... 0x....      BL       mbedtls_x509_key_size_helper
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD157             BNE.N    ??mbedtls_x509_crt_info_7
   1826                  return ret;
   1827              }
   1828          
   1829              ret = mbedtls_snprintf(p, n, "\n%s%-" BC "s: %d bits", prefix, key_size_str,
   1830                                     (int) mbedtls_pk_get_bitlen(&crt->pk));
   \      0x1A6   0x4628             MOV      R0,R5
   \      0x1A8   0x.... 0x....      BL       mbedtls_pk_get_bitlen
   \      0x1AC   0x9001             STR      R0,[SP, #+4]
   \      0x1AE   0xA808             ADD      R0,SP,#+32
   \      0x1B0   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_38: (+1)
   \      0x1B4   0x.... 0x....      ADR.W    R2,?_37
   \      0x1B8   0x.... 0x....      BL       snprintf
   1831              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x1BC   0x2800             CMP      R0,#+0
   \      0x1BE   0xD4BA             BMI.N    ??mbedtls_x509_crt_info_5
   \      0x1C0   0x9A06             LDR      R2,[SP, #+24]
   \      0x1C2   0x4290             CMP      R0,R2
   \      0x1C4   0xD2BB             BCS.N    ??mbedtls_x509_crt_info_6
   \      0x1C6   0x.... 0x....      BL       ?Subroutine13
   1832          
   1833              /*
   1834               * Optional extensions
   1835               */
   1836          
   1837              if (crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS) {
   \                     ??CrossCallReturnLabel_53: (+1)
   \      0x1CA   0xF8D8 0x11F0      LDR      R1,[R8, #+496]
   \      0x1CE   0x05C8             LSLS     R0,R1,#+23
   \      0x1D0   0xD526             BPL.N    ??CrossCallReturnLabel_55
   1838                  ret = mbedtls_snprintf(p, n, "\n%sbasic constraints : CA=%s", prefix,
   1839                                         crt->ca_istrue ? "true" : "false");
   \      0x1D2   0xF508 0x75F8      ADD      R5,R8,#+496
   \      0x1D6   0x6868             LDR      R0,[R5, #+4]
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xBF14             ITE      NE
   \      0x1DC   0x.... 0x....      ADRNE.W  R0,?_39
   \      0x1E0   0x.... 0x....      ADREQ.W  R0,?_40
   \      0x1E4   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_39: (+1)
   \      0x1E8   0x.... 0x....      ADR.W    R2,?_38
   \      0x1EC   0x.... 0x....      BL       snprintf
   1840                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x1F0   0x2800             CMP      R0,#+0
   \      0x1F2   0xD4A0             BMI.N    ??mbedtls_x509_crt_info_5
   \      0x1F4   0x9A06             LDR      R2,[SP, #+24]
   \      0x1F6   0x4290             CMP      R0,R2
   \      0x1F8   0xD2A1             BCS.N    ??mbedtls_x509_crt_info_6
   \      0x1FA   0x.... 0x....      BL       ?Subroutine13
   1841          
   1842                  if (crt->max_pathlen > 0) {
   \                     ??CrossCallReturnLabel_54: (+1)
   \      0x1FE   0x68AB             LDR      R3,[R5, #+8]
   \      0x200   0x2B00             CMP      R3,#+0
   \      0x202   0xDD0D             BLE.N    ??CrossCallReturnLabel_55
   1843                      ret = mbedtls_snprintf(p, n, ", max_pathlen=%d", crt->max_pathlen - 1);
   \      0x204   0x9906             LDR      R1,[SP, #+24]
   \      0x206   0x9807             LDR      R0,[SP, #+28]
   \      0x208   0x1E5B             SUBS     R3,R3,#+1
   \      0x20A   0x.... 0x....      ADR.W    R2,?_41
   \      0x20E   0x.... 0x....      BL       snprintf
   1844                      MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x212   0x2800             CMP      R0,#+0
   \      0x214   0xD464             BMI.N    ??mbedtls_x509_crt_info_8
   \      0x216   0x9A06             LDR      R2,[SP, #+24]
   \      0x218   0x4290             CMP      R0,R2
   \      0x21A   0xD264             BCS.N    ??mbedtls_x509_crt_info_9
   \      0x21C   0x.... 0x....      BL       ?Subroutine13
   1845                  }
   1846              }
   1847          
   1848              if (crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME) {
   \                     ??CrossCallReturnLabel_55: (+1)
   \      0x220   0xF898 0x11F0      LDRB     R1,[R8, #+496]
   \      0x224   0x0688             LSLS     R0,R1,#+26
   \      0x226   0xD518             BPL.N    ??mbedtls_x509_crt_info_10
   1849                  ret = mbedtls_snprintf(p, n, "\n%ssubject alt name  :", prefix);
   \      0x228   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_40: (+1)
   \      0x22C   0x.... 0x....      ADR.W    R2,?_42
   \      0x230   0x.... 0x....      BL       snprintf
   1850                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x234   0x2800             CMP      R0,#+0
   \      0x236   0xD453             BMI.N    ??mbedtls_x509_crt_info_8
   \      0x238   0x9A06             LDR      R2,[SP, #+24]
   \      0x23A   0x4290             CMP      R0,R2
   \      0x23C   0xD253             BCS.N    ??mbedtls_x509_crt_info_9
   \      0x23E   0x.... 0x....      BL       ?Subroutine14
   1851          
   1852                  if ((ret = mbedtls_x509_info_subject_alt_name(&p, &n,
   1853                                                                &crt->subject_alt_names,
   1854                                                                prefix)) != 0) {
   \                     ??CrossCallReturnLabel_58: (+1)
   \      0x242   0x4653             MOV      R3,R10
   \      0x244   0x4402             ADD      R2,R2,R0
   \      0x246   0x9207             STR      R2,[SP, #+28]
   \      0x248   0xF508 0x72C8      ADD      R2,R8,#+400
   \      0x24C   0xA906             ADD      R1,SP,#+24
   \      0x24E   0xA807             ADD      R0,SP,#+28
   \      0x250   0x.... 0x....      BL       mbedtls_x509_info_subject_alt_name
   \      0x254   0x2800             CMP      R0,#+0
   \                     ??mbedtls_x509_crt_info_7: (+1)
   \      0x256   0xF040 0x80BA      BNE.W    ??mbedtls_x509_crt_info_11
   1855                      return ret;
   1856                  }
   1857              }
   1858          
   1859              if (crt->ext_types & MBEDTLS_X509_EXT_NS_CERT_TYPE) {
   \                     ??mbedtls_x509_crt_info_10: (+1)
   \      0x25A   0xF8D8 0x01F0      LDR      R0,[R8, #+496]
   \      0x25E   0x03C1             LSLS     R1,R0,#+15
   \      0x260   0xD515             BPL.N    ??mbedtls_x509_crt_info_12
   1860                  ret = mbedtls_snprintf(p, n, "\n%scert. type        : ", prefix);
   \      0x262   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_41: (+1)
   \      0x266   0x.... 0x....      ADR.W    R2,?_43
   \      0x26A   0x.... 0x....      BL       snprintf
   1861                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x26E   0x2800             CMP      R0,#+0
   \      0x270   0xD436             BMI.N    ??mbedtls_x509_crt_info_8
   \      0x272   0x9A06             LDR      R2,[SP, #+24]
   \      0x274   0x4290             CMP      R0,R2
   \      0x276   0xD236             BCS.N    ??mbedtls_x509_crt_info_9
   \      0x278   0x.... 0x....      BL       ?Subroutine14
   1862          
   1863                  if ((ret = mbedtls_x509_info_cert_type(&p, &n, crt->ns_cert_type)) != 0) {
   \                     ??CrossCallReturnLabel_59: (+1)
   \      0x27C   0xA906             ADD      R1,SP,#+24
   \      0x27E   0x4402             ADD      R2,R2,R0
   \      0x280   0x9207             STR      R2,[SP, #+28]
   \      0x282   0x7822             LDRB     R2,[R4, #+0]
   \      0x284   0xA807             ADD      R0,SP,#+28
   \      0x286   0x.... 0x....      BL       mbedtls_x509_info_cert_type
   \      0x28A   0x2800             CMP      R0,#+0
   \      0x28C   0xD1E3             BNE.N    ??mbedtls_x509_crt_info_7
   1864                      return ret;
   1865                  }
   1866              }
   1867          
   1868              if (crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE) {
   \                     ??mbedtls_x509_crt_info_12: (+1)
   \      0x28E   0xF898 0x01F0      LDRB     R0,[R8, #+496]
   \      0x292   0x0741             LSLS     R1,R0,#+29
   \      0x294   0xD517             BPL.N    ??mbedtls_x509_crt_info_13
   1869                  ret = mbedtls_snprintf(p, n, "\n%skey usage         : ", prefix);
   \      0x296   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_42: (+1)
   \      0x29A   0x.... 0x....      ADR.W    R2,?_44
   \      0x29E   0x.... 0x....      BL       snprintf
   1870                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x2A2   0x2800             CMP      R0,#+0
   \      0x2A4   0xD41C             BMI.N    ??mbedtls_x509_crt_info_8
   \      0x2A6   0x9A06             LDR      R2,[SP, #+24]
   \      0x2A8   0x4290             CMP      R0,R2
   \      0x2AA   0xD21C             BCS.N    ??mbedtls_x509_crt_info_9
   \      0x2AC   0x.... 0x....      BL       ?Subroutine14
   1871          
   1872                  if ((ret = mbedtls_x509_info_key_usage(&p, &n, crt->key_usage)) != 0) {
   \                     ??CrossCallReturnLabel_60: (+1)
   \      0x2B0   0xF508 0x71F8      ADD      R1,R8,#+496
   \      0x2B4   0x4402             ADD      R2,R2,R0
   \      0x2B6   0x9207             STR      R2,[SP, #+28]
   \      0x2B8   0x68CA             LDR      R2,[R1, #+12]
   \      0x2BA   0xA906             ADD      R1,SP,#+24
   \      0x2BC   0xA807             ADD      R0,SP,#+28
   \      0x2BE   0x.... 0x....      BL       mbedtls_x509_info_key_usage
   \      0x2C2   0x2800             CMP      R0,#+0
   \      0x2C4   0xD1C7             BNE.N    ??mbedtls_x509_crt_info_7
   1873                      return ret;
   1874                  }
   1875              }
   1876          
   1877              if (crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE) {
   \                     ??mbedtls_x509_crt_info_13: (+1)
   \      0x2C6   0xF8D8 0x01F0      LDR      R0,[R8, #+496]
   \      0x2CA   0x.... 0x....      ADR.W    R11,??DataTable37
   \      0x2CE   0x0501             LSLS     R1,R0,#+20
   \      0x2D0   0xD536             BPL.N    ??mbedtls_x509_crt_info_14
   1878                  ret = mbedtls_snprintf(p, n, "\n%sext key usage     : ", prefix);
   \      0x2D2   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_43: (+1)
   \      0x2D6   0x.... 0x....      ADR.W    R2,?_45
   \      0x2DA   0x.... 0x....      BL       snprintf
   1879                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x2DE   0x2800             CMP      R0,#+0
   \                     ??mbedtls_x509_crt_info_8: (+1)
   \      0x2E0   0xD46F             BMI.N    ??mbedtls_x509_crt_info_4
   \      0x2E2   0x9A06             LDR      R2,[SP, #+24]
   \      0x2E4   0x4290             CMP      R0,R2
   \                     ??mbedtls_x509_crt_info_9: (+1)
   \      0x2E6   0xD26C             BCS.N    ??mbedtls_x509_crt_info_4
   \      0x2E8   0x.... 0x....      BL       ?Subroutine14
   1880          
   1881                  if ((ret = x509_info_ext_key_usage(&p, &n,
   1882                                                     &crt->ext_key_usage)) != 0) {
   \                     ??CrossCallReturnLabel_61: (+1)
   \      0x2EC   0x....             ADR.N    R1,??DataTable37_2
   \      0x2EE   0x4402             ADD      R2,R2,R0
   \      0x2F0   0x9207             STR      R2,[SP, #+28]
   \      0x2F2   0x9F06             LDR      R7,[SP, #+24]
   \      0x2F4   0x4615             MOV      R5,R2
   \      0x2F6   0x9104             STR      R1,[SP, #+16]
   \      0x2F8   0x.... 0x....      ADR.W    R2,?_29
   \      0x2FC   0x....             ADR.N    R1,??DataTable37_3
   \      0x2FE   0xF508 0x7400      ADD      R4,R8,#+512
   \      0x302   0x465E             MOV      R6,R11
   \      0x304   0x9203             STR      R2,[SP, #+12]
   \      0x306   0x9102             STR      R1,[SP, #+8]
   \      0x308   0xE016             B.N      ??mbedtls_x509_crt_info_15
   \                     ??mbedtls_x509_crt_info_16: (+1)
   \      0x30A   0xA901             ADD      R1,SP,#+4
   \      0x30C   0x4620             MOV      R0,R4
   \      0x30E   0x.... 0x....      BL       mbedtls_oid_get_extended_key_usage
   \      0x312   0xB108             CBZ.N    R0,??mbedtls_x509_crt_info_17
   \      0x314   0x9802             LDR      R0,[SP, #+8]
   \      0x316   0x9001             STR      R0,[SP, #+4]
   \                     ??mbedtls_x509_crt_info_17: (+1)
   \      0x318   0x9801             LDR      R0,[SP, #+4]
   \      0x31A   0x9A03             LDR      R2,[SP, #+12]
   \      0x31C   0x4633             MOV      R3,R6
   \      0x31E   0x9000             STR      R0,[SP, #+0]
   \      0x320   0x4639             MOV      R1,R7
   \      0x322   0x4628             MOV      R0,R5
   \      0x324   0x.... 0x....      BL       snprintf
   \      0x328   0x2800             CMP      R0,#+0
   \      0x32A   0xD44A             BMI.N    ??mbedtls_x509_crt_info_4
   \      0x32C   0x42B8             CMP      R0,R7
   \      0x32E   0xD248             BCS.N    ??mbedtls_x509_crt_info_4
   \      0x330   0x1A3F             SUBS     R7,R7,R0
   \      0x332   0x182D             ADDS     R5,R5,R0
   \      0x334   0x9E04             LDR      R6,[SP, #+16]
   \      0x336   0x68E4             LDR      R4,[R4, #+12]
   \                     ??mbedtls_x509_crt_info_15: (+1)
   \      0x338   0x2C00             CMP      R4,#+0
   \      0x33A   0xD1E6             BNE.N    ??mbedtls_x509_crt_info_16
   \      0x33C   0x9706             STR      R7,[SP, #+24]
   \      0x33E   0x9507             STR      R5,[SP, #+28]
   1883                      return ret;
   1884                  }
   1885              }
   1886          
   1887              if (crt->ext_types & MBEDTLS_OID_X509_EXT_CERTIFICATE_POLICIES) {
   \                     ??mbedtls_x509_crt_info_14: (+1)
   \      0x340   0xF898 0x11F0      LDRB     R1,[R8, #+496]
   \      0x344   0x0708             LSLS     R0,R1,#+28
   \      0x346   0xD532             BPL.N    ??mbedtls_x509_crt_info_18
   1888                  ret = mbedtls_snprintf(p, n, "\n%scertificate policies : ", prefix);
   \      0x348   0x.... 0x....      BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_44: (+1)
   \      0x34C   0x.... 0x....      ADR.W    R2,?_46
   \      0x350   0x.... 0x....      BL       snprintf
   1889                  MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x354   0x2800             CMP      R0,#+0
   \      0x356   0xD434             BMI.N    ??mbedtls_x509_crt_info_4
   \      0x358   0x9A06             LDR      R2,[SP, #+24]
   \      0x35A   0x4290             CMP      R0,R2
   \      0x35C   0xD231             BCS.N    ??mbedtls_x509_crt_info_4
   \      0x35E   0x.... 0x....      BL       ?Subroutine14
   1890          
   1891                  if ((ret = x509_info_cert_policies(&p, &n,
   1892                                                     &crt->certificate_policies)) != 0) {
   \                     ??CrossCallReturnLabel_62: (+1)
   \      0x362   0xF508 0x74F0      ADD      R4,R8,#+480
   \      0x366   0x4402             ADD      R2,R2,R0
   \      0x368   0x9207             STR      R2,[SP, #+28]
   \      0x36A   0x9E06             LDR      R6,[SP, #+24]
   \      0x36C   0x4617             MOV      R7,R2
   \      0x36E   0x.... 0x....      ADR.W    R8,??DataTable37_2
   \      0x372   0x.... 0x....      ADR.W    R10,?_29
   \      0x376   0x....             ADR.N    R5,??DataTable37_3
   \      0x378   0xE003             B.N      ??mbedtls_x509_crt_info_19
   \                     ??mbedtls_x509_crt_info_20: (+1)
   \      0x37A   0x1A36             SUBS     R6,R6,R0
   \      0x37C   0x183F             ADDS     R7,R7,R0
   \      0x37E   0x46C3             MOV      R11,R8
   \      0x380   0x68E4             LDR      R4,[R4, #+12]
   \                     ??mbedtls_x509_crt_info_19: (+1)
   \      0x382   0xB194             CBZ.N    R4,??mbedtls_x509_crt_info_21
   \      0x384   0xA901             ADD      R1,SP,#+4
   \      0x386   0x4620             MOV      R0,R4
   \      0x388   0x.... 0x....      BL       mbedtls_oid_get_certificate_policies
   \      0x38C   0xB100             CBZ.N    R0,??mbedtls_x509_crt_info_22
   \      0x38E   0x9501             STR      R5,[SP, #+4]
   \                     ??mbedtls_x509_crt_info_22: (+1)
   \      0x390   0x9801             LDR      R0,[SP, #+4]
   \      0x392   0x465B             MOV      R3,R11
   \      0x394   0x4652             MOV      R2,R10
   \      0x396   0x9000             STR      R0,[SP, #+0]
   \      0x398   0x4631             MOV      R1,R6
   \      0x39A   0x4638             MOV      R0,R7
   \      0x39C   0x.... 0x....      BL       snprintf
   \      0x3A0   0x2800             CMP      R0,#+0
   \      0x3A2   0xD40E             BMI.N    ??mbedtls_x509_crt_info_4
   \      0x3A4   0x42B0             CMP      R0,R6
   \      0x3A6   0xD3E8             BCC.N    ??mbedtls_x509_crt_info_20
   1893                      return ret;
   \      0x3A8   0xE00B             B.N      ??mbedtls_x509_crt_info_4
   1894                  }
   1895              }
   \                     ??mbedtls_x509_crt_info_21: (+1)
   \      0x3AA   0x9606             STR      R6,[SP, #+24]
   \      0x3AC   0x9707             STR      R7,[SP, #+28]
   1896          
   1897              ret = mbedtls_snprintf(p, n, "\n");
   \                     ??mbedtls_x509_crt_info_18: (+1)
   \      0x3AE   0x9906             LDR      R1,[SP, #+24]
   \      0x3B0   0x9807             LDR      R0,[SP, #+28]
   \      0x3B2   0x....             ADR.N    R2,??DataTable37_5
   \      0x3B4   0x.... 0x....      BL       snprintf
   1898              MBEDTLS_X509_SAFE_SNPRINTF;
   \      0x3B8   0x2800             CMP      R0,#+0
   \      0x3BA   0xD402             BMI.N    ??mbedtls_x509_crt_info_4
   \      0x3BC   0x9906             LDR      R1,[SP, #+24]
   \      0x3BE   0x4288             CMP      R0,R1
   \      0x3C0   0xD302             BCC.N    ??mbedtls_x509_crt_info_23
   \                     ??mbedtls_x509_crt_info_4: (+1)
   \      0x3C2   0x.... 0x....      LDR.W    R0,??DataTable39_1
   \      0x3C6   0xE002             B.N      ??mbedtls_x509_crt_info_11
   1899          
   1900              return (int) (size - n);
   \                     ??mbedtls_x509_crt_info_23: (+1)
   \      0x3C8   0xEBA9 0x0101      SUB      R1,R9,R1
   \                     ??mbedtls_x509_crt_info_3: (+1)
   \      0x3CC   0x4408             ADD      R0,R0,R1
   \                     ??mbedtls_x509_crt_info_11: (+1)
   \      0x3CE   0xB00D             ADD      SP,SP,#+52
   \      0x3D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1901          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x1A11             SUBS     R1,R2,R0
   \        0x2   0x9A07             LDR      R2,[SP, #+28]
   \        0x4   0x9106             STR      R1,[SP, #+24]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x1A11             SUBS     R1,R2,R0
   \        0x2   0x9A07             LDR      R2,[SP, #+28]
   \        0x4   0x9106             STR      R1,[SP, #+24]
   \        0x6   0x4402             ADD      R2,R2,R0
   \        0x8   0x9207             STR      R2,[SP, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x9807             LDR      R0,[SP, #+28]
   \        0x2   0x9100             STR      R1,[SP, #+0]
   \        0x4   0x9906             LDR      R1,[SP, #+24]
   \        0x6   0x.... 0x....      B.W      snprintf

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x1A11             SUBS     R1,R2,R0
   \        0x2   0x9A07             LDR      R2,[SP, #+28]
   \        0x4   0x9106             STR      R1,[SP, #+24]
   \        0x6   0x9906             LDR      R1,[SP, #+24]
   \        0x8   0x4402             ADD      R2,R2,R0
   \        0xA   0x9207             STR      R2,[SP, #+28]
   \        0xC   0x9807             LDR      R0,[SP, #+28]
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \                     ??Subroutine9_0: (+1)
   \        0x2   0x9906             LDR      R1,[SP, #+24]
   \        0x4   0x9807             LDR      R0,[SP, #+28]
   \        0x6   0x4653             MOV      R3,R10
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x1A11             SUBS     R1,R2,R0
   \        0x2   0x9A07             LDR      R2,[SP, #+28]
   \        0x4   0x9106             STR      R1,[SP, #+24]
   \        0x6   0x9906             LDR      R1,[SP, #+24]
   \        0x8   0x4402             ADD      R2,R2,R0
   \        0xA   0x9207             STR      R2,[SP, #+28]
   \        0xC   0x9807             LDR      R0,[SP, #+28]
   \        0xE   0x4653             MOV      R3,R10
   \       0x10   0x4770             BX       LR
   1902          
   1903          struct x509_crt_verify_string {
   1904              int code;
   1905              const char *string;
   1906          };
   1907          
   1908          #define X509_CRT_ERROR_INFO(err, err_str, info) { err, info },

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x25 0x73          DC8 "%sUnknown reason (this should not happen)\012"
   \              0x55 0x6E    
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x61 0x73    
   \              0x6F 0x6E    
   \              0x20 0x28    
   \              0x74 0x68    
   \              0x69 0x73    
   \              0x20 0x73    
   \              0x68 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x68 0x61    
   \              0x70 0x70    
   \              0x65 0x6E    
   \              0x29 0x0A    
   \              0x00
   \       0x2B                      DS8 1
   \       0x2C   0x0000'0001        DC32 1, ?_0, 2, ?_1, 4, ?_2, 8, ?_3, 16, ?_4, 32, ?_5, 64, ?_6, 128
   \              0x....'....  
   \              0x0000'0002  
   \              0x....'....  
   \              0x0000'0004  
   \              0x....'....  
   \              0x0000'0008  
   \              0x....'....  
   \              0x0000'0010  
   \              0x....'....  
   \              0x0000'0020  
   \              0x....'....  
   \              0x0000'0040  
   \              0x....'....  
   \              0x0000'0080
   \       0x68   0x....'....        DC32 ?_7, 256, ?_8, 512, ?_9, 1'024, ?_10, 2'048, ?_11, 4'096, ?_12
   \              0x0000'0100  
   \              0x....'....  
   \              0x0000'0200  
   \              0x....'....  
   \              0x0000'0400  
   \              0x....'....  
   \              0x0000'0800  
   \              0x....'....  
   \              0x0000'1000  
   \              0x....'....
   \       0x94   0x0000'2000        DC32 8'192, ?_13, 16'384, ?_14, 32'768, ?_15, 65'536, ?_16, 131'072
   \              0x....'....  
   \              0x0000'4000  
   \              0x....'....  
   \              0x0000'8000  
   \              0x....'....  
   \              0x0001'0000  
   \              0x....'....  
   \              0x0002'0000
   \       0xB8   0x....'....        DC32 ?_17, 262'144, ?_18, 524'288, ?_19, 0, 0x0
   \              0x0004'0000  
   \              0x....'....  
   \              0x0008'0000  
   \              0x....'....  
   \              0x0000'0000  
   \              0x0000'0000
   1909          static const struct x509_crt_verify_string x509_crt_verify_strings[] = {
   1910              MBEDTLS_X509_CRT_ERROR_INFO_LIST
   1911              { 0, NULL }
   1912          };
   1913          #undef X509_CRT_ERROR_INFO
   1914          

   \                                 In section .text, align 2, keep-with-next
   1915          int mbedtls_x509_crt_verify_info(char *buf, size_t size, const char *prefix,
   1916                                           uint32_t flags)
   1917          {
   \                     mbedtls_x509_crt_verify_info: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x460F             MOV      R7,R1
   1918              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   1919              const struct x509_crt_verify_string *cur;
   1920              char *p = buf;
   1921              size_t n = size;
   1922          
   1923              for (cur = x509_crt_verify_strings; cur->string != NULL; cur++) {
   \        0x6   0x.... 0x....      LDR.W    R10,??DataTable39_2
   \        0xA   0x4683             MOV      R11,R0
   \        0xC   0x4691             MOV      R9,R2
   \        0xE   0x461C             MOV      R4,R3
   \       0x10   0x463E             MOV      R6,R7
   \       0x12   0xF10A 0x052C      ADD      R5,R10,#+44
   \       0x16   0x.... 0x....      ADR.W    R8,?_48
   \       0x1A   0xE012             B.N      ??mbedtls_x509_crt_verify_info_0
   1924                  if ((flags & cur->code) == 0) {
   \                     ??mbedtls_x509_crt_verify_info_1: (+1)
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x420C             TST      R4,R1
   \       0x20   0xD00E             BEQ.N    ??mbedtls_x509_crt_verify_info_2
   1925                      continue;
   1926                  }
   1927          
   1928                  ret = mbedtls_snprintf(p, n, "%s%s\n", prefix, cur->string);
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0x464B             MOV      R3,R9
   \       0x26   0x4642             MOV      R2,R8
   \       0x28   0x4631             MOV      R1,R6
   \       0x2A   0x4658             MOV      R0,R11
   \       0x2C   0x.... 0x....      BL       snprintf
   1929                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD418             BMI.N    ??mbedtls_x509_crt_verify_info_3
   \       0x34   0x42B0             CMP      R0,R6
   \       0x36   0xD216             BCS.N    ??mbedtls_x509_crt_verify_info_3
   \       0x38   0x1A36             SUBS     R6,R6,R0
   \       0x3A   0x4483             ADD      R11,R11,R0
   1930                  flags ^= cur->code;
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x4044             EORS     R4,R0,R4
   1931              }
   \                     ??mbedtls_x509_crt_verify_info_2: (+1)
   \       0x40   0x3508             ADDS     R5,R5,#+8
   \                     ??mbedtls_x509_crt_verify_info_0: (+1)
   \       0x42   0x6868             LDR      R0,[R5, #+4]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD1E9             BNE.N    ??mbedtls_x509_crt_verify_info_1
   \       0x48   0x464B             MOV      R3,R9
   1932          
   1933              if (flags != 0) {
   \       0x4A   0xB14C             CBZ.N    R4,??mbedtls_x509_crt_verify_info_4
   1934                  ret = mbedtls_snprintf(p, n, "%sUnknown reason "
   1935                                               "(this should not happen)\n", prefix);
   \       0x4C   0x4652             MOV      R2,R10
   \       0x4E   0x4631             MOV      R1,R6
   \       0x50   0x4658             MOV      R0,R11
   \       0x52   0x.... 0x....      BL       snprintf
   1936                  MBEDTLS_X509_SAFE_SNPRINTF;
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD405             BMI.N    ??mbedtls_x509_crt_verify_info_3
   \       0x5A   0x42B0             CMP      R0,R6
   \       0x5C   0xD203             BCS.N    ??mbedtls_x509_crt_verify_info_3
   \       0x5E   0x1A36             SUBS     R6,R6,R0
   1937              }
   1938          
   1939              return (int) (size - n);
   \                     ??mbedtls_x509_crt_verify_info_4: (+1)
   \       0x60   0x1BB8             SUBS     R0,R7,R6
   \                     ??mbedtls_x509_crt_verify_info_5: (+1)
   \       0x62   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   \                     ??mbedtls_x509_crt_verify_info_3: (+1)
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable39_1
   \       0x6A   0xE7FA             B.N      ??mbedtls_x509_crt_verify_info_5
   1940          }
   1941          #endif /* MBEDTLS_X509_REMOVE_INFO */
   1942          

   \                                 In section .text, align 2, keep-with-next
   1943          int mbedtls_x509_crt_check_key_usage(const mbedtls_x509_crt *crt,
   1944                                               unsigned int usage)
   1945          {
   \                     mbedtls_x509_crt_check_key_usage: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1946              unsigned int usage_must, usage_may;
   1947              unsigned int may_mask = MBEDTLS_X509_KU_ENCIPHER_ONLY
   1948                                      | MBEDTLS_X509_KU_DECIPHER_ONLY;
   1949          
   1950              if ((crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE) == 0) {
   \        0x2   0xF500 0x70F8      ADD      R0,R0,#+496
   \        0x6   0x7803             LDRB     R3,[R0, #+0]
   \        0x8   0x075A             LSLS     R2,R3,#+29
   \        0xA   0xD510             BPL.N    ??mbedtls_x509_crt_check_key_usage_0
   1951                  return 0;
   1952              }
   1953          
   1954              usage_must = usage & ~may_mask;
   \        0xC   0x.... 0x....      LDR.W    R2,??DataTable39_3
   \       0x10   0x400A             ANDS     R2,R2,R1
   1955          
   1956              if (((crt->key_usage & ~may_mask) & usage_must) != usage_must) {
   \       0x12   0x68C3             LDR      R3,[R0, #+12]
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable39_4
   \       0x18   0xEA02 0x0403      AND      R4,R2,R3
   \       0x1C   0x4294             CMP      R4,R2
   \       0x1E   0xD107             BNE.N    ??mbedtls_x509_crt_check_key_usage_1
   1957                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1958              }
   1959          
   1960              usage_may = usage & may_mask;
   \       0x20   0xF248 0x0201      MOVW     R2,#+32769
   \       0x24   0x4011             ANDS     R1,R2,R1
   1961          
   1962              if (((crt->key_usage & may_mask) | usage_may) != usage_may) {
   \       0x26   0x4013             ANDS     R3,R2,R3
   \       0x28   0x430B             ORRS     R3,R1,R3
   \       0x2A   0x428B             CMP      R3,R1
   \       0x2C   0xD100             BNE.N    ??mbedtls_x509_crt_check_key_usage_1
   1963                  return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   1964              }
   1965          
   1966              return 0;
   \                     ??mbedtls_x509_crt_check_key_usage_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_check_key_usage_1: (+1)
   \       0x30   0xBD10             POP      {R4,PC}
   1967          }
   1968          

   \                                 In section .text, align 2, keep-with-next
   1969          int mbedtls_x509_crt_check_extended_key_usage(const mbedtls_x509_crt *crt,
   1970                                                        const char *usage_oid,
   1971                                                        size_t usage_len)
   1972          {
   \                     mbedtls_x509_crt_check_extended_key_usage: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4616             MOV      R6,R2
   1973              const mbedtls_x509_sequence *cur;
   1974          
   1975              /* Extension is not mandatory, absent means no restriction */
   1976              if ((crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE) == 0) {
   \        0x6   0xF8D0 0x21F0      LDR      R2,[R0, #+496]
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x0511             LSLS     R1,R2,#+20
   \        0xE   0xD518             BPL.N    ??mbedtls_x509_crt_check_extended_key_usage_0
   1977                  return 0;
   1978              }
   1979          
   1980              /*
   1981               * Look for the requested usage (or wildcard ANY) in our list
   1982               */
   1983              for (cur = &crt->ext_key_usage; cur != NULL; cur = cur->next) {
   \       0x10   0xF500 0x7400      ADD      R4,R0,#+512
   \       0x14   0x.... 0x....      ADR.W    R8,?_49
   \       0x18   0xE000             B.N      ??mbedtls_x509_crt_check_extended_key_usage_1
   \                     ??mbedtls_x509_crt_check_extended_key_usage_2: (+1)
   \       0x1A   0x68E4             LDR      R4,[R4, #+12]
   \                     ??mbedtls_x509_crt_check_extended_key_usage_1: (+1)
   \       0x1C   0xB19C             CBZ.N    R4,??mbedtls_x509_crt_check_extended_key_usage_3
   1984                  const mbedtls_x509_buf *cur_oid = &cur->buf;
   1985          
   1986                  if (cur_oid->len == usage_len &&
   1987                      memcmp(cur_oid->p, usage_oid, usage_len) == 0) {
   \       0x1E   0x6867             LDR      R7,[R4, #+4]
   \       0x20   0x42B7             CMP      R7,R6
   \       0x22   0xD105             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_4
   \       0x24   0x68A0             LDR      R0,[R4, #+8]
   \       0x26   0x4632             MOV      R2,R6
   \       0x28   0x4629             MOV      R1,R5
   \       0x2A   0x.... 0x....      BL       memcmp
   \       0x2E   0xB140             CBZ.N    R0,??mbedtls_x509_crt_check_extended_key_usage_0
   1988                      return 0;
   1989                  }
   1990          
   1991                  if (MBEDTLS_OID_CMP(MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid) == 0) {
   \                     ??mbedtls_x509_crt_check_extended_key_usage_4: (+1)
   \       0x30   0x2F04             CMP      R7,#+4
   \       0x32   0xD1F2             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_2
   \       0x34   0x68A1             LDR      R1,[R4, #+8]
   \       0x36   0x2204             MOVS     R2,#+4
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0x.... 0x....      BL       memcmp
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1EB             BNE.N    ??mbedtls_x509_crt_check_extended_key_usage_2
   1992                      return 0;
   \                     ??mbedtls_x509_crt_check_extended_key_usage_0: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE001             B.N      ??mbedtls_x509_crt_check_extended_key_usage_5
   1993                  }
   1994              }
   1995          
   1996              return MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \                     ??mbedtls_x509_crt_check_extended_key_usage_3: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable39_4
   \                     ??mbedtls_x509_crt_check_extended_key_usage_5: (+1)
   \       0x4A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1997          }
   1998          
   1999          #if defined(MBEDTLS_X509_CRL_PARSE_C)
   2000          /*
   2001           * Return 1 if the certificate is revoked, or 0 otherwise.
   2002           */

   \                                 In section .text, align 2, keep-with-next
   2003          int mbedtls_x509_crt_is_revoked(const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl)
   2004          {
   \                     mbedtls_x509_crt_is_revoked: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   2005              const mbedtls_x509_crl_entry *cur = &crl->entry;
   \        0x4   0xF101 0x0484      ADD      R4,R1,#+132
   \        0x8   0xE000             B.N      ??mbedtls_x509_crt_is_revoked_0
   2006          
   2007              while (cur != NULL && cur->serial.len != 0) {
   2008                  if (crt->serial.len == cur->serial.len &&
   2009                      memcmp(crt->serial.p, cur->serial.p, crt->serial.len) == 0) {
   2010                      return 1;
   2011                  }
   2012          
   2013                  cur = cur->next;
   \                     ??mbedtls_x509_crt_is_revoked_1: (+1)
   \        0xA   0x6BE4             LDR      R4,[R4, #+60]
   \                     ??mbedtls_x509_crt_is_revoked_0: (+1)
   \        0xC   0xB164             CBZ.N    R4,??mbedtls_x509_crt_is_revoked_2
   \        0xE   0x6920             LDR      R0,[R4, #+16]
   \       0x10   0xB150             CBZ.N    R0,??mbedtls_x509_crt_is_revoked_2
   \       0x12   0x6A6A             LDR      R2,[R5, #+36]
   \       0x14   0x4282             CMP      R2,R0
   \       0x16   0xD1F8             BNE.N    ??mbedtls_x509_crt_is_revoked_1
   \       0x18   0x6961             LDR      R1,[R4, #+20]
   \       0x1A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1C   0x.... 0x....      BL       memcmp
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD1F2             BNE.N    ??mbedtls_x509_crt_is_revoked_1
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
   2014              }
   2015          
   2016              return 0;
   \                     ??mbedtls_x509_crt_is_revoked_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
   2017          }
   2018          
   2019          /*
   2020           * Check that the given certificate is not revoked according to the CRL.
   2021           * Skip validation if no CRL for the given CA is present.
   2022           */
   2023          static int x509_crt_verifycrl(mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
   2024                                        mbedtls_x509_crl *crl_list,
   2025                                        const mbedtls_x509_crt_profile *profile,
   2026                                        const mbedtls_x509_time *now)
   2027          {
   2028              int flags = 0;
   2029              unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   2030          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2031              psa_algorithm_t psa_algorithm;
   2032          #else
   2033              const mbedtls_md_info_t *md_info;
   2034          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2035              size_t hash_length;
   2036          
   2037              if (ca == NULL) {
   2038                  return flags;
   2039              }
   2040          
   2041              while (crl_list != NULL) {
   2042                  if (crl_list->version == 0 ||
   2043                      x509_name_cmp(&crl_list->issuer, &ca->subject) != 0) {
   2044                      crl_list = crl_list->next;
   2045                      continue;
   2046                  }
   2047          
   2048                  /*
   2049                   * Check if the CA is configured to sign CRLs
   2050                   */
   2051                  if (mbedtls_x509_crt_check_key_usage(ca,
   2052                                                       MBEDTLS_X509_KU_CRL_SIGN) != 0) {
   2053                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   2054                      break;
   2055                  }
   2056          
   2057                  /*
   2058                   * Check if CRL is correctly signed by the trusted CA
   2059                   */
   2060                  if (x509_profile_check_md_alg(profile, crl_list->sig_md) != 0) {
   2061                      flags |= MBEDTLS_X509_BADCRL_BAD_MD;
   2062                  }
   2063          
   2064                  if (x509_profile_check_pk_alg(profile, crl_list->sig_pk) != 0) {
   2065                      flags |= MBEDTLS_X509_BADCRL_BAD_PK;
   2066                  }
   2067          
   2068          #if defined(MBEDTLS_USE_PSA_CRYPTO)
   2069                  psa_algorithm = mbedtls_md_psa_alg_from_type(crl_list->sig_md);
   2070                  if (psa_hash_compute(psa_algorithm,
   2071                                       crl_list->tbs.p,
   2072                                       crl_list->tbs.len,
   2073                                       hash,
   2074                                       sizeof(hash),
   2075                                       &hash_length) != PSA_SUCCESS) {
   2076                      /* Note: this can't happen except after an internal error */
   2077                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   2078                      break;
   2079                  }
   2080          #else
   2081                  md_info = mbedtls_md_info_from_type(crl_list->sig_md);
   2082                  hash_length = mbedtls_md_get_size(md_info);
   2083                  if (mbedtls_md(md_info,
   2084                                 crl_list->tbs.p,
   2085                                 crl_list->tbs.len,
   2086                                 hash) != 0) {
   2087                      /* Note: this can't happen except after an internal error */
   2088                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   2089                      break;
   2090                  }
   2091          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2092          
   2093                  if (x509_profile_check_key(profile, &ca->pk) != 0) {
   2094                      flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
   2095                  }
   2096          
   2097                  if (mbedtls_pk_verify_ext(crl_list->sig_pk, crl_list->sig_opts, &ca->pk,
   2098                                            crl_list->sig_md, hash, hash_length,
   2099                                            crl_list->sig.p, crl_list->sig.len) != 0) {
   2100                      flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
   2101                      break;
   2102                  }
   2103          
   2104          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2105                  /*
   2106                   * Check for validity of CRL (Do not drop out)
   2107                   */
   2108                  if (mbedtls_x509_time_cmp(&crl_list->next_update, now) < 0) {
   2109                      flags |= MBEDTLS_X509_BADCRL_EXPIRED;
   2110                  }
   2111          
   2112                  if (mbedtls_x509_time_cmp(&crl_list->this_update, now) > 0) {
   2113                      flags |= MBEDTLS_X509_BADCRL_FUTURE;
   2114                  }
   2115          #else
   2116                  ((void) now);
   2117          #endif
   2118          
   2119                  /*
   2120                   * Check if certificate is revoked
   2121                   */
   2122                  if (mbedtls_x509_crt_is_revoked(crt, crl_list)) {
   2123                      flags |= MBEDTLS_X509_BADCERT_REVOKED;
   2124                      break;
   2125                  }
   2126          
   2127                  crl_list = crl_list->next;
   2128              }
   2129          
   2130              return flags;
   2131          }
   2132          #endif /* MBEDTLS_X509_CRL_PARSE_C */
   2133          
   2134          /*
   2135           * Check the signature of a certificate by its parent
   2136           */
   2137          static int x509_crt_check_signature(const mbedtls_x509_crt *child,
   2138                                              mbedtls_x509_crt *parent,
   2139                                              mbedtls_x509_crt_restart_ctx *rs_ctx)
   2140          {
   2141              size_t hash_len;
   2142              unsigned char hash[MBEDTLS_MD_MAX_SIZE];
   2143          #if !defined(MBEDTLS_USE_PSA_CRYPTO)
   2144              const mbedtls_md_info_t *md_info;
   2145              md_info = mbedtls_md_info_from_type(child->sig_md);
   2146              hash_len = mbedtls_md_get_size(md_info);
   2147          
   2148              /* Note: hash errors can happen only after an internal error */
   2149              if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
   2150                  return -1;
   2151              }
   2152          #else
   2153              psa_algorithm_t hash_alg = mbedtls_md_psa_alg_from_type(child->sig_md);
   2154              psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
   2155          
   2156              status = psa_hash_compute(hash_alg,
   2157                                        child->tbs.p,
   2158                                        child->tbs.len,
   2159                                        hash,
   2160                                        sizeof(hash),
   2161                                        &hash_len);
   2162              if (status != PSA_SUCCESS) {
   2163                  return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
   2164              }
   2165          
   2166          #endif /* MBEDTLS_USE_PSA_CRYPTO */
   2167              /* Skip expensive computation on obvious mismatch */
   2168              if (!mbedtls_pk_can_do(&parent->pk, child->sig_pk)) {
   2169                  return -1;
   2170              }
   2171          
   2172          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2173              if (rs_ctx != NULL && child->sig_pk == MBEDTLS_PK_ECDSA) {
   2174                  return mbedtls_pk_verify_restartable(&parent->pk,
   2175                                                       child->sig_md, hash, hash_len,
   2176                                                       child->sig.p, child->sig.len, &rs_ctx->pk);
   2177              }
   2178          #else
   2179              (void) rs_ctx;
   2180          #endif
   2181          
   2182              return mbedtls_pk_verify_ext(child->sig_pk, child->sig_opts, &parent->pk,
   2183                                           child->sig_md, hash, hash_len,
   2184                                           child->sig.p, child->sig.len);
   2185          }
   2186          
   2187          /*
   2188           * Check if 'parent' is a suitable parent (signing CA) for 'child'.
   2189           * Return 0 if yes, -1 if not.
   2190           *
   2191           * top means parent is a locally-trusted certificate
   2192           */
   2193          static int x509_crt_check_parent(const mbedtls_x509_crt *child,
   2194                                           const mbedtls_x509_crt *parent,
   2195                                           int top)
   2196          {
   2197              int need_ca_bit;
   2198          
   2199              /* Parent must be the issuer */
   2200              if (x509_name_cmp(&child->issuer, &parent->subject) != 0) {
   2201                  return -1;
   2202              }
   2203          
   2204              /* Parent must have the basicConstraints CA bit set as a general rule */
   2205              need_ca_bit = 1;
   2206          
   2207              /* Exception: v1/v2 certificates that are locally trusted. */
   2208              if (top && parent->version < 3) {
   2209                  need_ca_bit = 0;
   2210              }
   2211          
   2212              if (need_ca_bit && !parent->ca_istrue) {
   2213                  return -1;
   2214              }
   2215          
   2216              if (need_ca_bit &&
   2217                  mbedtls_x509_crt_check_key_usage(parent, MBEDTLS_X509_KU_KEY_CERT_SIGN) != 0) {
   2218                  return -1;
   2219              }
   2220          
   2221              return 0;
   2222          }
   2223          
   2224          /*
   2225           * Find a suitable parent for child in candidates, or return NULL.
   2226           *
   2227           * Here suitable is defined as:
   2228           *  1. subject name matches child's issuer
   2229           *  2. if necessary, the CA bit is set and key usage allows signing certs
   2230           *  3. for trusted roots, the signature is correct
   2231           *     (for intermediates, the signature is checked and the result reported)
   2232           *  4. pathlen constraints are satisfied
   2233           *
   2234           * If there's a suitable candidate which is also time-valid, return the first
   2235           * such. Otherwise, return the first suitable candidate (or NULL if there is
   2236           * none).
   2237           *
   2238           * The rationale for this rule is that someone could have a list of trusted
   2239           * roots with two versions on the same root with different validity periods.
   2240           * (At least one user reported having such a list and wanted it to just work.)
   2241           * The reason we don't just require time-validity is that generally there is
   2242           * only one version, and if it's expired we want the flags to state that
   2243           * rather than NOT_TRUSTED, as would be the case if we required it here.
   2244           *
   2245           * The rationale for rule 3 (signature for trusted roots) is that users might
   2246           * have two versions of the same CA with different keys in their list, and the
   2247           * way we select the correct one is by checking the signature (as we don't
   2248           * rely on key identifier extensions). (This is one way users might choose to
   2249           * handle key rollover, another relies on self-issued certs, see [SIRO].)
   2250           *
   2251           * Arguments:
   2252           *  - [in] child: certificate for which we're looking for a parent
   2253           *  - [in] candidates: chained list of potential parents
   2254           *  - [out] r_parent: parent found (or NULL)
   2255           *  - [out] r_signature_is_good: 1 if child signature by parent is valid, or 0
   2256           *  - [in] top: 1 if candidates consists of trusted roots, ie we're at the top
   2257           *         of the chain, 0 otherwise
   2258           *  - [in] path_cnt: number of intermediates seen so far
   2259           *  - [in] self_cnt: number of self-signed intermediates seen so far
   2260           *         (will never be greater than path_cnt)
   2261           *  - [in-out] rs_ctx: context for restarting operations
   2262           *
   2263           * Return value:
   2264           *  - 0 on success
   2265           *  - MBEDTLS_ERR_ECP_IN_PROGRESS otherwise
   2266           */
   2267          static int x509_crt_find_parent_in(
   2268              mbedtls_x509_crt *child,
   2269              mbedtls_x509_crt *candidates,
   2270              mbedtls_x509_crt **r_parent,
   2271              int *r_signature_is_good,
   2272              int top,
   2273              unsigned path_cnt,
   2274              unsigned self_cnt,
   2275              mbedtls_x509_crt_restart_ctx *rs_ctx,
   2276              const mbedtls_x509_time *now)
   2277          {
   2278              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2279              mbedtls_x509_crt *parent, *fallback_parent;
   2280              int signature_is_good = 0, fallback_signature_is_good;
   2281          
   2282          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2283              /* did we have something in progress? */
   2284              if (rs_ctx != NULL && rs_ctx->parent != NULL) {
   2285                  /* restore saved state */
   2286                  parent = rs_ctx->parent;
   2287                  fallback_parent = rs_ctx->fallback_parent;
   2288                  fallback_signature_is_good = rs_ctx->fallback_signature_is_good;
   2289          
   2290                  /* clear saved state */
   2291                  rs_ctx->parent = NULL;
   2292                  rs_ctx->fallback_parent = NULL;
   2293                  rs_ctx->fallback_signature_is_good = 0;
   2294          
   2295                  /* resume where we left */
   2296                  goto check_signature;
   2297              }
   2298          #endif
   2299          
   2300              fallback_parent = NULL;
   2301              fallback_signature_is_good = 0;
   2302          
   2303              for (parent = candidates; parent != NULL; parent = parent->next) {
   2304                  /* basic parenting skills (name, CA bit, key usage) */
   2305                  if (x509_crt_check_parent(child, parent, top) != 0) {
   2306                      continue;
   2307                  }
   2308          
   2309                  /* +1 because stored max_pathlen is 1 higher that the actual value */
   2310                  if (parent->max_pathlen > 0 &&
   2311                      (size_t) parent->max_pathlen < 1 + path_cnt - self_cnt) {
   2312                      continue;
   2313                  }
   2314          
   2315                  /* Signature */
   2316          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2317          check_signature:
   2318          #endif
   2319                  ret = x509_crt_check_signature(child, parent, rs_ctx);
   2320          
   2321          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2322                  if (rs_ctx != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2323                      /* save state */
   2324                      rs_ctx->parent = parent;
   2325                      rs_ctx->fallback_parent = fallback_parent;
   2326                      rs_ctx->fallback_signature_is_good = fallback_signature_is_good;
   2327          
   2328                      return ret;
   2329                  }
   2330          #else
   2331                  (void) ret;
   2332          #endif
   2333          
   2334                  signature_is_good = ret == 0;
   2335                  if (top && !signature_is_good) {
   2336                      continue;
   2337                  }
   2338          
   2339          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2340                  /* optional time check */
   2341                  if (mbedtls_x509_time_cmp(&parent->valid_to, now) < 0 ||    /* past */
   2342                      mbedtls_x509_time_cmp(&parent->valid_from, now) > 0) {  /* future */
   2343                      if (fallback_parent == NULL) {
   2344                          fallback_parent = parent;
   2345                          fallback_signature_is_good = signature_is_good;
   2346                      }
   2347          
   2348                      continue;
   2349                  }
   2350          #else
   2351                  ((void) now);
   2352          #endif
   2353          
   2354                  *r_parent = parent;
   2355                  *r_signature_is_good = signature_is_good;
   2356          
   2357                  break;
   2358              }
   2359          
   2360              if (parent == NULL) {
   2361                  *r_parent = fallback_parent;
   2362                  *r_signature_is_good = fallback_signature_is_good;
   2363              }
   2364          
   2365              return 0;
   2366          }
   2367          
   2368          /*
   2369           * Find a parent in trusted CAs or the provided chain, or return NULL.
   2370           *
   2371           * Searches in trusted CAs first, and return the first suitable parent found
   2372           * (see find_parent_in() for definition of suitable).
   2373           *
   2374           * Arguments:
   2375           *  - [in] child: certificate for which we're looking for a parent, followed
   2376           *         by a chain of possible intermediates
   2377           *  - [in] trust_ca: list of locally trusted certificates
   2378           *  - [out] parent: parent found (or NULL)
   2379           *  - [out] parent_is_trusted: 1 if returned `parent` is trusted, or 0
   2380           *  - [out] signature_is_good: 1 if child signature by parent is valid, or 0
   2381           *  - [in] path_cnt: number of links in the chain so far (EE -> ... -> child)
   2382           *  - [in] self_cnt: number of self-signed certs in the chain so far
   2383           *         (will always be no greater than path_cnt)
   2384           *  - [in-out] rs_ctx: context for restarting operations
   2385           *
   2386           * Return value:
   2387           *  - 0 on success
   2388           *  - MBEDTLS_ERR_ECP_IN_PROGRESS otherwise
   2389           */
   2390          static int x509_crt_find_parent(
   2391              mbedtls_x509_crt *child,
   2392              mbedtls_x509_crt *trust_ca,
   2393              mbedtls_x509_crt **parent,
   2394              int *parent_is_trusted,
   2395              int *signature_is_good,
   2396              unsigned path_cnt,
   2397              unsigned self_cnt,
   2398              mbedtls_x509_crt_restart_ctx *rs_ctx,
   2399              const mbedtls_x509_time *now)
   2400          {
   2401              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2402              mbedtls_x509_crt *search_list;
   2403          
   2404              *parent_is_trusted = 1;
   2405          
   2406          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2407              /* restore then clear saved state if we have some stored */
   2408              if (rs_ctx != NULL && rs_ctx->parent_is_trusted != -1) {
   2409                  *parent_is_trusted = rs_ctx->parent_is_trusted;
   2410                  rs_ctx->parent_is_trusted = -1;
   2411              }
   2412          #endif
   2413          
   2414              while (1) {
   2415                  search_list = *parent_is_trusted ? trust_ca : child->next;
   2416          
   2417                  ret = x509_crt_find_parent_in(child, search_list,
   2418                                                parent, signature_is_good,
   2419                                                *parent_is_trusted,
   2420                                                path_cnt, self_cnt, rs_ctx, now);
   2421          
   2422          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2423                  if (rs_ctx != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2424                      /* save state */
   2425                      rs_ctx->parent_is_trusted = *parent_is_trusted;
   2426                      return ret;
   2427                  }
   2428          #else
   2429                  (void) ret;
   2430          #endif
   2431          
   2432                  /* stop here if found or already in second iteration */
   2433                  if (*parent != NULL || *parent_is_trusted == 0) {
   2434                      break;
   2435                  }
   2436          
   2437                  /* prepare second iteration */
   2438                  *parent_is_trusted = 0;
   2439              }
   2440          
   2441              /* extra precaution against mistakes in the caller */
   2442              if (*parent == NULL) {
   2443                  *parent_is_trusted = 0;
   2444                  *signature_is_good = 0;
   2445              }
   2446          
   2447              return 0;
   2448          }
   2449          
   2450          /*
   2451           * Check if an end-entity certificate is locally trusted
   2452           *
   2453           * Currently we require such certificates to be self-signed (actually only
   2454           * check for self-issued as self-signatures are not checked)
   2455           */
   2456          static int x509_crt_check_ee_locally_trusted(
   2457              mbedtls_x509_crt *crt,
   2458              mbedtls_x509_crt *trust_ca)
   2459          {
   2460              mbedtls_x509_crt *cur;
   2461          
   2462              /* must be self-issued */
   2463              if (x509_name_cmp(&crt->issuer, &crt->subject) != 0) {
   2464                  return -1;
   2465              }
   2466          
   2467              /* look for an exact match with trusted cert */
   2468              for (cur = trust_ca; cur != NULL; cur = cur->next) {
   2469                  if (crt->raw.len == cur->raw.len &&
   2470                      memcmp(crt->raw.p, cur->raw.p, crt->raw.len) == 0) {
   2471                      return 0;
   2472                  }
   2473              }
   2474          
   2475              /* too bad */
   2476              return -1;
   2477          }
   2478          
   2479          /*
   2480           * Build and verify a certificate chain
   2481           *
   2482           * Given a peer-provided list of certificates EE, C1, ..., Cn and
   2483           * a list of trusted certs R1, ... Rp, try to build and verify a chain
   2484           *      EE, Ci1, ... Ciq [, Rj]
   2485           * such that every cert in the chain is a child of the next one,
   2486           * jumping to a trusted root as early as possible.
   2487           *
   2488           * Verify that chain and return it with flags for all issues found.
   2489           *
   2490           * Special cases:
   2491           * - EE == Rj -> return a one-element list containing it
   2492           * - EE, Ci1, ..., Ciq cannot be continued with a trusted root
   2493           *   -> return that chain with NOT_TRUSTED set on Ciq
   2494           *
   2495           * Tests for (aspects of) this function should include at least:
   2496           * - trusted EE
   2497           * - EE -> trusted root
   2498           * - EE -> intermediate CA -> trusted root
   2499           * - if relevant: EE untrusted
   2500           * - if relevant: EE -> intermediate, untrusted
   2501           * with the aspect under test checked at each relevant level (EE, int, root).
   2502           * For some aspects longer chains are required, but usually length 2 is
   2503           * enough (but length 1 is not in general).
   2504           *
   2505           * Arguments:
   2506           *  - [in] crt: the cert list EE, C1, ..., Cn
   2507           *  - [in] trust_ca: the trusted list R1, ..., Rp
   2508           *  - [in] ca_crl, profile: as in verify_with_profile()
   2509           *  - [out] ver_chain: the built and verified chain
   2510           *      Only valid when return value is 0, may contain garbage otherwise!
   2511           *      Restart note: need not be the same when calling again to resume.
   2512           *  - [in-out] rs_ctx: context for restarting operations
   2513           *
   2514           * Return value:
   2515           *  - non-zero if the chain could not be fully built and examined
   2516           *  - 0 is the chain was successfully built and examined,
   2517           *      even if it was found to be invalid
   2518           */
   2519          static int x509_crt_verify_chain(
   2520              mbedtls_x509_crt *crt,
   2521              mbedtls_x509_crt *trust_ca,
   2522              mbedtls_x509_crl *ca_crl,
   2523              mbedtls_x509_crt_ca_cb_t f_ca_cb,
   2524              void *p_ca_cb,
   2525              const mbedtls_x509_crt_profile *profile,
   2526              mbedtls_x509_crt_verify_chain *ver_chain,
   2527              mbedtls_x509_crt_restart_ctx *rs_ctx)
   2528          {
   2529              /* Don't initialize any of those variables here, so that the compiler can
   2530               * catch potential issues with jumping ahead when restarting */
   2531              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   2532              uint32_t *flags;
   2533              mbedtls_x509_crt_verify_chain_item *cur;
   2534              mbedtls_x509_crt *child;
   2535              mbedtls_x509_crt *parent;
   2536              int parent_is_trusted;
   2537              int child_is_trusted;
   2538              int signature_is_good;
   2539              unsigned self_cnt;
   2540              mbedtls_x509_crt *cur_trust_ca = NULL;
   2541              mbedtls_x509_time now;
   2542          
   2543          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2544              if (mbedtls_x509_time_gmtime(mbedtls_time(NULL), &now) != 0) {
   2545                  return MBEDTLS_ERR_X509_FATAL_ERROR;
   2546              }
   2547          #endif
   2548          
   2549          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2550              /* resume if we had an operation in progress */
   2551              if (rs_ctx != NULL && rs_ctx->in_progress == x509_crt_rs_find_parent) {
   2552                  /* restore saved state */
   2553                  *ver_chain = rs_ctx->ver_chain; /* struct copy */
   2554                  self_cnt = rs_ctx->self_cnt;
   2555          
   2556                  /* restore derived state */
   2557                  cur = &ver_chain->items[ver_chain->len - 1];
   2558                  child = cur->crt;
   2559                  flags = &cur->flags;
   2560          
   2561                  goto find_parent;
   2562              }
   2563          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   2564          
   2565              child = crt;
   2566              self_cnt = 0;
   2567              parent_is_trusted = 0;
   2568              child_is_trusted = 0;
   2569          
   2570              while (1) {
   2571                  /* Add certificate to the verification chain */
   2572                  cur = &ver_chain->items[ver_chain->len];
   2573                  cur->crt = child;
   2574                  cur->flags = 0;
   2575                  ver_chain->len++;
   2576                  flags = &cur->flags;
   2577          
   2578          #if defined(MBEDTLS_HAVE_TIME_DATE)
   2579                  /* Check time-validity (all certificates) */
   2580                  if (mbedtls_x509_time_cmp(&child->valid_to, &now) < 0) {
   2581                      *flags |= MBEDTLS_X509_BADCERT_EXPIRED;
   2582                  }
   2583          
   2584                  if (mbedtls_x509_time_cmp(&child->valid_from, &now) > 0) {
   2585                      *flags |= MBEDTLS_X509_BADCERT_FUTURE;
   2586                  }
   2587          #endif
   2588          
   2589                  /* Stop here for trusted roots (but not for trusted EE certs) */
   2590                  if (child_is_trusted) {
   2591                      return 0;
   2592                  }
   2593          
   2594                  /* Check signature algorithm: MD & PK algs */
   2595                  if (x509_profile_check_md_alg(profile, child->sig_md) != 0) {
   2596                      *flags |= MBEDTLS_X509_BADCERT_BAD_MD;
   2597                  }
   2598          
   2599                  if (x509_profile_check_pk_alg(profile, child->sig_pk) != 0) {
   2600                      *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
   2601                  }
   2602          
   2603                  /* Special case: EE certs that are locally trusted */
   2604                  if (ver_chain->len == 1 &&
   2605                      x509_crt_check_ee_locally_trusted(child, trust_ca) == 0) {
   2606                      return 0;
   2607                  }
   2608          
   2609          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2610          find_parent:
   2611          #endif
   2612          
   2613                  /* Obtain list of potential trusted signers from CA callback,
   2614                   * or use statically provided list. */
   2615          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   2616                  if (f_ca_cb != NULL) {
   2617                      mbedtls_x509_crt_free(ver_chain->trust_ca_cb_result);
   2618                      mbedtls_free(ver_chain->trust_ca_cb_result);
   2619                      ver_chain->trust_ca_cb_result = NULL;
   2620          
   2621                      ret = f_ca_cb(p_ca_cb, child, &ver_chain->trust_ca_cb_result);
   2622                      if (ret != 0) {
   2623                          return MBEDTLS_ERR_X509_FATAL_ERROR;
   2624                      }
   2625          
   2626                      cur_trust_ca = ver_chain->trust_ca_cb_result;
   2627                  } else
   2628          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   2629                  {
   2630                      ((void) f_ca_cb);
   2631                      ((void) p_ca_cb);
   2632                      cur_trust_ca = trust_ca;
   2633                  }
   2634          
   2635                  /* Look for a parent in trusted CAs or up the chain */
   2636                  ret = x509_crt_find_parent(child, cur_trust_ca, &parent,
   2637                                             &parent_is_trusted, &signature_is_good,
   2638                                             ver_chain->len - 1, self_cnt, rs_ctx,
   2639                                             &now);
   2640          
   2641          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   2642                  if (rs_ctx != NULL && ret == MBEDTLS_ERR_ECP_IN_PROGRESS) {
   2643                      /* save state */
   2644                      rs_ctx->in_progress = x509_crt_rs_find_parent;
   2645                      rs_ctx->self_cnt = self_cnt;
   2646                      rs_ctx->ver_chain = *ver_chain; /* struct copy */
   2647          
   2648                      return ret;
   2649                  }
   2650          #else
   2651                  (void) ret;
   2652          #endif
   2653          
   2654                  /* No parent? We're done here */
   2655                  if (parent == NULL) {
   2656                      *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
   2657                      return 0;
   2658                  }
   2659          
   2660                  /* Count intermediate self-issued (not necessarily self-signed) certs.
   2661                   * These can occur with some strategies for key rollover, see [SIRO],
   2662                   * and should be excluded from max_pathlen checks. */
   2663                  if (ver_chain->len != 1 &&
   2664                      x509_name_cmp(&child->issuer, &child->subject) == 0) {
   2665                      self_cnt++;
   2666                  }
   2667          
   2668                  /* path_cnt is 0 for the first intermediate CA,
   2669                   * and if parent is trusted it's not an intermediate CA */
   2670                  if (!parent_is_trusted &&
   2671                      ver_chain->len > MBEDTLS_X509_MAX_INTERMEDIATE_CA) {
   2672                      /* return immediately to avoid overflow the chain array */
   2673                      return MBEDTLS_ERR_X509_FATAL_ERROR;
   2674                  }
   2675          
   2676                  /* signature was checked while searching parent */
   2677                  if (!signature_is_good) {
   2678                      *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
   2679                  }
   2680          
   2681                  /* check size of signing key */
   2682                  if (x509_profile_check_key(profile, &parent->pk) != 0) {
   2683                      *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
   2684                  }
   2685          
   2686          #if defined(MBEDTLS_X509_CRL_PARSE_C)
   2687                  /* Check trusted CA's CRL for the given crt */
   2688                  *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile, &now);
   2689          #else
   2690                  (void) ca_crl;
   2691          #endif
   2692          
   2693                  /* prepare for next iteration */
   2694                  child = parent;
   2695                  parent = NULL;
   2696                  child_is_trusted = parent_is_trusted;
   2697                  signature_is_good = 0;
   2698              }
   2699          }
   2700          
   2701          #ifdef _WIN32
   2702          #ifdef _MSC_VER
   2703          #pragma comment(lib, "ws2_32.lib")
   2704          #include <winsock2.h>
   2705          #include <ws2tcpip.h>
   2706          #elif (defined(__MINGW32__) || defined(__MINGW64__)) && _WIN32_WINNT >= 0x0600
   2707          #include <winsock2.h>
   2708          #include <ws2tcpip.h>
   2709          #else
   2710          /* inet_pton() is not supported, fallback to software version */
   2711          #define MBEDTLS_TEST_SW_INET_PTON
   2712          #endif
   2713          #elif defined(__sun)
   2714          /* Solaris requires -lsocket -lnsl for inet_pton() */
   2715          #elif defined(__has_include)
   2716          #if __has_include(<sys/socket.h>)
   2717          #include <sys/socket.h>
   2718          #endif
   2719          #if __has_include(<arpa/inet.h>)
   2720          #include <arpa/inet.h>
   2721          #endif
   2722          #endif
   2723          
   2724          /* Use whether or not AF_INET6 is defined to indicate whether or not to use
   2725           * the platform inet_pton() or a local implementation (below).  The local
   2726           * implementation may be used even in cases where the platform provides
   2727           * inet_pton(), e.g. when there are different includes required and/or the
   2728           * platform implementation requires dependencies on additional libraries.
   2729           * Specifically, Windows requires custom includes and additional link
   2730           * dependencies, and Solaris requires additional link dependencies.
   2731           * Also, as a coarse heuristic, use the local implementation if the compiler
   2732           * does not support __has_include(), or if the definition of AF_INET6 is not
   2733           * provided by headers included (or not) via __has_include() above.
   2734           * MBEDTLS_TEST_SW_INET_PTON is a bypass define to force testing of this code //no-check-names
   2735           * despite having a platform that has inet_pton. */
   2736          #if !defined(AF_INET6) || defined(MBEDTLS_TEST_SW_INET_PTON) //no-check-names
   2737          /* Definition located further below to possibly reduce compiler inlining */
   2738          static int x509_inet_pton_ipv4(const char *src, void *dst);
   2739          
   2740          #define li_cton(c, n) \
   2741              (((n) = (c) - '0') <= 9 || (((n) = ((c)&0xdf) - 'A') <= 5 ? ((n) += 10) : 0))
   2742          
   2743          static int x509_inet_pton_ipv6(const char *src, void *dst)
   2744          {
   2745              const unsigned char *p = (const unsigned char *) src;
   2746              int nonzero_groups = 0, num_digits, zero_group_start = -1;
   2747              uint16_t addr[8];
   2748              do {
   2749                  /* note: allows excess leading 0's, e.g. 1:0002:3:... */
   2750                  uint16_t group = num_digits = 0;
   2751                  for (uint8_t digit; num_digits < 4; num_digits++) {
   2752                      if (li_cton(*p, digit) == 0) {
   2753                          break;
   2754                      }
   2755                      group = (group << 4) | digit;
   2756                      p++;
   2757                  }
   2758                  if (num_digits != 0) {
   2759                      MBEDTLS_PUT_UINT16_BE(group, addr, nonzero_groups);
   2760                      nonzero_groups++;
   2761                      if (*p == '\0') {
   2762                          break;
   2763                      } else if (*p == '.') {
   2764                          /* Don't accept IPv4 too early or late */
   2765                          if ((nonzero_groups == 0 && zero_group_start == -1) ||
   2766                              nonzero_groups >= 7) {
   2767                              break;
   2768                          }
   2769          
   2770                          /* Walk back to prior ':', then parse as IPv4-mapped */
   2771                          int steps = 4;
   2772                          do {
   2773                              p--;
   2774                              steps--;
   2775                          } while (*p != ':' && steps > 0);
   2776          
   2777                          if (*p != ':') {
   2778                              break;
   2779                          }
   2780                          p++;
   2781                          nonzero_groups--;
   2782                          if (x509_inet_pton_ipv4((const char *) p,
   2783                                                  addr + nonzero_groups) != 0) {
   2784                              break;
   2785                          }
   2786          
   2787                          nonzero_groups += 2;
   2788                          p = (const unsigned char *) "";
   2789                          break;
   2790                      } else if (*p != ':') {
   2791                          return -1;
   2792                      }
   2793                  } else {
   2794                      /* Don't accept a second zero group or an invalid delimiter */
   2795                      if (zero_group_start != -1 || *p != ':') {
   2796                          return -1;
   2797                      }
   2798                      zero_group_start = nonzero_groups;
   2799          
   2800                      /* Accept a zero group at start, but it has to be a double colon */
   2801                      if (zero_group_start == 0 && *++p != ':') {
   2802                          return -1;
   2803                      }
   2804          
   2805                      if (p[1] == '\0') {
   2806                          ++p;
   2807                          break;
   2808                      }
   2809                  }
   2810                  ++p;
   2811              } while (nonzero_groups < 8);
   2812          
   2813              if (*p != '\0') {
   2814                  return -1;
   2815              }
   2816          
   2817              if (zero_group_start != -1) {
   2818                  if (nonzero_groups > 6) {
   2819                      return -1;
   2820                  }
   2821                  int zero_groups = 8 - nonzero_groups;
   2822                  int groups_after_zero = nonzero_groups - zero_group_start;
   2823          
   2824                  /* Move the non-zero part to after the zeroes */
   2825                  if (groups_after_zero) {
   2826                      memmove(addr + zero_group_start + zero_groups,
   2827                              addr + zero_group_start,
   2828                              groups_after_zero * sizeof(*addr));
   2829                  }
   2830                  memset(addr + zero_group_start, 0, zero_groups * sizeof(*addr));
   2831              } else {
   2832                  if (nonzero_groups != 8) {
   2833                      return -1;
   2834                  }
   2835              }
   2836              memcpy(dst, addr, sizeof(addr));
   2837              return 0;
   2838          }
   2839          

   \                                 In section .text, align 2, keep-with-next
   2840          static int x509_inet_pton_ipv4(const char *src, void *dst)
   2841          {
   \                     x509_inet_pton_ipv4: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   2842              const unsigned char *p = (const unsigned char *) src;
   2843              uint8_t *res = (uint8_t *) dst;
   2844              uint8_t digit, num_digits = 0;
   2845              uint8_t num_octets = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   2846              uint16_t octet;
   2847          
   2848              do {
   2849                  octet = num_digits = 0;
   \                     ??x509_inet_pton_ipv4_0: (+1)
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2300             MOVS     R3,#+0
   2850                  do {
   2851                      digit = *p - '0';
   \                     ??x509_inet_pton_ipv4_1: (+1)
   \        0x8   0x7805             LDRB     R5,[R0, #+0]
   \        0xA   0xF1A5 0x0730      SUB      R7,R5,#+48
   \        0xE   0xB2FF             UXTB     R7,R7
   2852                      if (digit > 9) {
   \       0x10   0x2F0A             CMP      R7,#+10
   \       0x12   0xDA0C             BGE.N    ??x509_inet_pton_ipv4_2
   2853                          break;
   2854                      }
   2855          
   2856                      /* Don't allow leading zeroes. These might mean octal format,
   2857                       * which this implementation does not support. */
   2858                      if (octet == 0 && num_digits > 0) {
   \       0x14   0xB903             CBNZ.N   R3,??x509_inet_pton_ipv4_3
   \       0x16   0xBB02             CBNZ.N   R2,??x509_inet_pton_ipv4_4
   2859                          return -1;
   2860                      }
   2861          
   2862                      octet = octet * 10 + digit;
   \                     ??x509_inet_pton_ipv4_3: (+1)
   \       0x18   0x461E             MOV      R6,R3
   \       0x1A   0x250A             MOVS     R5,#+10
   \       0x1C   0x463B             MOV      R3,R7
   \       0x1E   0xFB05 0x3306      MLA      R3,R5,R6,R3
   2863                      num_digits++;
   \       0x22   0x1C52             ADDS     R2,R2,#+1
   \       0x24   0xB2D2             UXTB     R2,R2
   2864                      p++;
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0xB29B             UXTH     R3,R3
   2865                  } while (num_digits < 3);
   \       0x2A   0x2A03             CMP      R2,#+3
   \       0x2C   0xDBEC             BLT.N    ??x509_inet_pton_ipv4_1
   2866          
   2867                  if (octet >= 256 || num_digits > 3 || num_digits == 0) {
   \                     ??x509_inet_pton_ipv4_2: (+1)
   \       0x2E   0xF5B3 0x7F80      CMP      R3,#+256
   \       0x32   0xDA12             BGE.N    ??x509_inet_pton_ipv4_4
   \       0x34   0x2A03             CMP      R2,#+3
   \       0x36   0xDC10             BGT.N    ??x509_inet_pton_ipv4_4
   \       0x38   0xB17A             CBZ.N    R2,??x509_inet_pton_ipv4_4
   2868                      return -1;
   2869                  }
   2870                  *res++ = (uint8_t) octet;
   \       0x3A   0xF801 0x3B01      STRB     R3,[R1], #+1
   2871                  num_octets++;
   \       0x3E   0x1C64             ADDS     R4,R4,#+1
   2872              } while (num_octets < 4 && *p++ == '.');
   \       0x40   0xB2E3             UXTB     R3,R4
   \       0x42   0x2B03             CMP      R3,#+3
   \       0x44   0xDC03             BGT.N    ??x509_inet_pton_ipv4_5
   \       0x46   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \       0x4A   0x2A2E             CMP      R2,#+46
   \       0x4C   0xD0DA             BEQ.N    ??x509_inet_pton_ipv4_0
   2873              return num_octets == 4 && *p == '\0' ? 0 : -1;
   \                     ??x509_inet_pton_ipv4_5: (+1)
   \       0x4E   0xB2E4             UXTB     R4,R4
   \       0x50   0x2C04             CMP      R4,#+4
   \       0x52   0xBF04             ITT      EQ
   \       0x54   0x7800             LDRBEQ   R0,[R0, #+0]
   \       0x56   0x2800             CMPEQ    R0,#+0
   \       0x58   0xD001             BEQ.N    ??x509_inet_pton_ipv4_6
   \                     ??x509_inet_pton_ipv4_4: (+1)
   \       0x5A   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??x509_inet_pton_ipv4_6: (+1)
   \       0x5E   0xBDF0             POP      {R4-R7,PC}
   2874          }
   2875          
   2876          #else
   2877          
   2878          static int x509_inet_pton_ipv6(const char *src, void *dst)
   2879          {
   2880              return inet_pton(AF_INET6, src, dst) == 1 ? 0 : -1;
   2881          }
   2882          
   2883          static int x509_inet_pton_ipv4(const char *src, void *dst)
   2884          {
   2885              return inet_pton(AF_INET, src, dst) == 1 ? 0 : -1;
   2886          }
   2887          
   2888          #endif /* !AF_INET6 || MBEDTLS_TEST_SW_INET_PTON */ //no-check-names
   2889          

   \                                 In section .text, align 2, keep-with-next
   2890          size_t mbedtls_x509_crt_parse_cn_inet_pton(const char *cn, void *dst)
   2891          {
   \                     mbedtls_x509_crt_parse_cn_inet_pton: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460F             MOV      R7,R1
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4606             MOV      R6,R0
   2892              return strchr(cn, ':') == NULL
   2893                      ? x509_inet_pton_ipv4(cn, dst) == 0 ? 4 : 0
   2894                      : x509_inet_pton_ipv6(cn, dst) == 0 ? 16 : 0;
   \        0x8   0x213A             MOVS     R1,#+58
   \        0xA   0x.... 0x....      BL       strchr
   \        0xE   0xB938             CBNZ.N   R0,??mbedtls_x509_crt_parse_cn_inet_pton_0
   \       0x10   0x4639             MOV      R1,R7
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0x.... 0x....      BL       x509_inet_pton_ipv4
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD135             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_1
   \       0x1C   0x2004             MOVS     R0,#+4
   \       0x1E   0xE087             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_2
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_0: (+1)
   \       0x20   0x2400             MOVS     R4,#+0
   \       0x22   0xF04F 0x35FF      MOV      R5,#+4294967295
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_3: (+1)
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x2200             MOVS     R2,#+0
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_4: (+1)
   \       0x2A   0x7833             LDRB     R3,[R6, #+0]
   \       0x2C   0xF1A3 0x0030      SUB      R0,R3,#+48
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x280A             CMP      R0,#+10
   \       0x34   0xDB09             BLT.N    ??mbedtls_x509_crt_parse_cn_inet_pton_5
   \       0x36   0xF003 0x03DF      AND      R3,R3,#0xDF
   \       0x3A   0xF1A3 0x0041      SUB      R0,R3,#+65
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0x2806             CMP      R0,#+6
   \       0x42   0xDA08             BGE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_6
   \       0x44   0x300A             ADDS     R0,R0,#+10
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0xB128             CBZ.N    R0,??mbedtls_x509_crt_parse_cn_inet_pton_6
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_5: (+1)
   \       0x4A   0x1C76             ADDS     R6,R6,#+1
   \       0x4C   0x1C49             ADDS     R1,R1,#+1
   \       0x4E   0xEA40 0x1202      ORR      R2,R0,R2, LSL #+4
   \       0x52   0x2904             CMP      R1,#+4
   \       0x54   0xDBE9             BLT.N    ??mbedtls_x509_crt_parse_cn_inet_pton_4
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_6: (+1)
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD04C             BEQ.N    ??mbedtls_x509_crt_parse_cn_inet_pton_7
   \       0x5A   0x.... 0x....      ADR.W    R3,mbedtls_byte_order_detector
   \       0x5E   0x7819             LDRB     R1,[R3, #+0]
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0xEB00 0x0044      ADD      R0,R0,R4, LSL #+1
   \       0x66   0x2901             CMP      R1,#+1
   \       0x68   0xBF08             IT       EQ
   \       0x6A   0xB291             UXTHEQ   R1,R2
   \       0x6C   0xD004             BEQ.N    ??mbedtls_x509_crt_parse_cn_inet_pton_8
   \       0x6E   0x0411             LSLS     R1,R2,#+16
   \       0x70   0x0E09             LSRS     R1,R1,#+24
   \       0x72   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x76   0xB289             UXTH     R1,R1
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_8: (+1)
   \       0x78   0x.... 0x....      BL       mbedtls_put_unaligned_uint16
   \       0x7C   0x7830             LDRB     R0,[R6, #+0]
   \       0x7E   0x1C64             ADDS     R4,R4,#+1
   \       0x80   0xB1F8             CBZ.N    R0,??mbedtls_x509_crt_parse_cn_inet_pton_9
   \       0x82   0x282E             CMP      R0,#+46
   \       0x84   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_cn_inet_pton_10
   \       0x86   0x283A             CMP      R0,#+58
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_1: (+1)
   \       0x88   0xD151             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_11
   \       0x8A   0xE041             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_12
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_10: (+1)
   \       0x8C   0xB91C             CBNZ.N   R4,??mbedtls_x509_crt_parse_cn_inet_pton_13
   \       0x8E   0xF115 0x0F01      CMN      R5,#+1
   \       0x92   0xD102             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_14
   \       0x94   0xE015             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_9
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_13: (+1)
   \       0x96   0x2C06             CMP      R4,#+6
   \       0x98   0xDC13             BGT.N    ??mbedtls_x509_crt_parse_cn_inet_pton_9
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_14: (+1)
   \       0x9A   0x2004             MOVS     R0,#+4
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_15: (+1)
   \       0x9C   0xF816 0x1D01      LDRB     R1,[R6, #-1]!
   \       0xA0   0x1E40             SUBS     R0,R0,#+1
   \       0xA2   0x293A             CMP      R1,#+58
   \       0xA4   0xD002             BEQ.N    ??mbedtls_x509_crt_parse_cn_inet_pton_16
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD1F8             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_15
   \       0xAA   0xE00A             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_9
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_16: (+1)
   \       0xAC   0x1E64             SUBS     R4,R4,#+1
   \       0xAE   0x4668             MOV      R0,SP
   \       0xB0   0x1C76             ADDS     R6,R6,#+1
   \       0xB2   0xEB00 0x0144      ADD      R1,R0,R4, LSL #+1
   \       0xB6   0x4630             MOV      R0,R6
   \       0xB8   0x.... 0x....      BL       x509_inet_pton_ipv4
   \       0xBC   0xB908             CBNZ.N   R0,??mbedtls_x509_crt_parse_cn_inet_pton_9
   \       0xBE   0x1CA4             ADDS     R4,R4,#+2
   \       0xC0   0x....             ADR.N    R6,??DataTable38_3
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_9: (+1)
   \       0xC2   0x7830             LDRB     R0,[R6, #+0]
   \       0xC4   0xBB98             CBNZ.N   R0,??mbedtls_x509_crt_parse_cn_inet_pton_11
   \       0xC6   0xF115 0x0F01      CMN      R5,#+1
   \       0xCA   0xD027             BEQ.N    ??mbedtls_x509_crt_parse_cn_inet_pton_17
   \       0xCC   0x2C06             CMP      R4,#+6
   \       0xCE   0xDC2E             BGT.N    ??mbedtls_x509_crt_parse_cn_inet_pton_11
   \       0xD0   0xF1C4 0x0608      RSB      R6,R4,#+8
   \       0xD4   0x1B64             SUBS     R4,R4,R5
   \       0xD6   0x4668             MOV      R0,SP
   \       0xD8   0xEB00 0x0545      ADD      R5,R0,R5, LSL #+1
   \       0xDC   0xD005             BEQ.N    ??mbedtls_x509_crt_parse_cn_inet_pton_18
   \       0xDE   0x0062             LSLS     R2,R4,#+1
   \       0xE0   0x4629             MOV      R1,R5
   \       0xE2   0xEB05 0x0046      ADD      R0,R5,R6, LSL #+1
   \       0xE6   0x.... 0x....      BL       __aeabi_memmove
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_18: (+1)
   \       0xEA   0x0071             LSLS     R1,R6,#+1
   \       0xEC   0x4628             MOV      R0,R5
   \       0xEE   0x.... 0x....      BL       __aeabi_memclr
   \       0xF2   0xE015             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_19
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_7: (+1)
   \       0xF4   0xF115 0x0F01      CMN      R5,#+1
   \       0xF8   0xBF04             ITT      EQ
   \       0xFA   0x7830             LDRBEQ   R0,[R6, #+0]
   \       0xFC   0x283A             CMPEQ    R0,#+58
   \       0xFE   0xD116             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_11
   \      0x100   0x0025             MOVS     R5,R4
   \      0x102   0xD103             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_20
   \      0x104   0xF816 0x0F01      LDRB     R0,[R6, #+1]!
   \      0x108   0x283A             CMP      R0,#+58
   \      0x10A   0xD110             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_11
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_20: (+1)
   \      0x10C   0x7870             LDRB     R0,[R6, #+1]
   \      0x10E   0xB118             CBZ.N    R0,??mbedtls_x509_crt_parse_cn_inet_pton_21
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_12: (+1)
   \      0x110   0x1C76             ADDS     R6,R6,#+1
   \      0x112   0x2C08             CMP      R4,#+8
   \      0x114   0xDB87             BLT.N    ??mbedtls_x509_crt_parse_cn_inet_pton_3
   \      0x116   0xE7D4             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_9
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_21: (+1)
   \      0x118   0x1C76             ADDS     R6,R6,#+1
   \      0x11A   0xE7D2             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_9
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_17: (+1)
   \      0x11C   0x2C08             CMP      R4,#+8
   \      0x11E   0xD106             BNE.N    ??mbedtls_x509_crt_parse_cn_inet_pton_11
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_19: (+1)
   \      0x120   0x2210             MOVS     R2,#+16
   \      0x122   0x4669             MOV      R1,SP
   \      0x124   0x4638             MOV      R0,R7
   \      0x126   0x.... 0x....      BL       __aeabi_memcpy
   \      0x12A   0x2010             MOVS     R0,#+16
   \      0x12C   0xE000             B.N      ??mbedtls_x509_crt_parse_cn_inet_pton_2
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_11: (+1)
   \      0x12E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_crt_parse_cn_inet_pton_2: (+1)
   \      0x130   0xB005             ADD      SP,SP,#+20
   \      0x132   0xBDF0             POP      {R4-R7,PC}
   2895          }
   2896          
   2897          /*
   2898           * Check for CN match
   2899           */

   \                                 In section .text, align 2, keep-with-next
   2900          static int x509_crt_check_cn(const mbedtls_x509_buf *name,
   2901                                       const char *cn, size_t cn_len)
   2902          {
   \                     x509_crt_check_cn: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   2903              /* try exact match */
   2904              if (name->len == cn_len &&
   2905                  x509_memcasecmp(cn, name->p, cn_len) == 0) {
   \        0x4   0x686B             LDR      R3,[R5, #+4]
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4293             CMP      R3,R2
   \        0xA   0xD104             BNE.N    ??x509_crt_check_cn_0
   \        0xC   0x68A9             LDR      R1,[R5, #+8]
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       x509_memcasecmp
   \       0x14   0xB310             CBZ.N    R0,??x509_crt_check_cn_1
   2906                  return 0;
   2907              }
   2908          
   2909              /* try wildcard match */
   2910              if (x509_check_wildcard(cn, name) == 0) {
   \                     ??x509_crt_check_cn_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       strlen
   \       0x1C   0x686A             LDR      R2,[R5, #+4]
   \       0x1E   0x4601             MOV      R1,R0
   \       0x20   0x2A03             CMP      R2,#+3
   \       0x22   0xD319             BCC.N    ??x509_crt_check_cn_2
   \       0x24   0x68AB             LDR      R3,[R5, #+8]
   \       0x26   0x7818             LDRB     R0,[R3, #+0]
   \       0x28   0x282A             CMP      R0,#+42
   \       0x2A   0xBF04             ITT      EQ
   \       0x2C   0x7858             LDRBEQ   R0,[R3, #+1]
   \       0x2E   0x282E             CMPEQ    R0,#+46
   \       0x30   0xD112             BNE.N    ??x509_crt_check_cn_2
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE000             B.N      ??x509_crt_check_cn_3
   \                     ??x509_crt_check_cn_4: (+1)
   \       0x36   0x1C40             ADDS     R0,R0,#+1
   \                     ??x509_crt_check_cn_3: (+1)
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD20D             BCS.N    ??x509_crt_check_cn_2
   \       0x3C   0x5C25             LDRB     R5,[R4, R0]
   \       0x3E   0x2D2E             CMP      R5,#+46
   \       0x40   0xD1F9             BNE.N    ??x509_crt_check_cn_4
   \       0x42   0xB148             CBZ.N    R0,??x509_crt_check_cn_2
   \       0x44   0x1A09             SUBS     R1,R1,R0
   \       0x46   0x1C49             ADDS     R1,R1,#+1
   \       0x48   0x4291             CMP      R1,R2
   \       0x4A   0xD105             BNE.N    ??x509_crt_check_cn_2
   \       0x4C   0x1821             ADDS     R1,R4,R0
   \       0x4E   0x1E52             SUBS     R2,R2,#+1
   \       0x50   0x1C58             ADDS     R0,R3,#+1
   \       0x52   0x.... 0x....      BL       x509_memcasecmp
   \       0x56   0xB108             CBZ.N    R0,??x509_crt_check_cn_1
   2911                  return 0;
   2912              }
   2913          
   2914              return -1;
   \                     ??x509_crt_check_cn_2: (+1)
   \       0x58   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??x509_crt_check_cn_1: (+1)
   \       0x5C   0xBD32             POP      {R1,R4,R5,PC}
   2915          }
   2916          
   2917          static int x509_crt_check_san_ip(const mbedtls_x509_sequence *san,
   2918                                           const char *cn, size_t cn_len)
   2919          {
   2920              uint32_t ip[4];
   2921              cn_len = mbedtls_x509_crt_parse_cn_inet_pton(cn, ip);
   2922              if (cn_len == 0) {
   2923                  return -1;
   2924              }
   2925          
   2926              for (const mbedtls_x509_sequence *cur = san; cur != NULL; cur = cur->next) {
   2927                  const unsigned char san_type = (unsigned char) cur->buf.tag &
   2928                                                 MBEDTLS_ASN1_TAG_VALUE_MASK;
   2929                  if (san_type == MBEDTLS_X509_SAN_IP_ADDRESS &&
   2930                      cur->buf.len == cn_len && memcmp(cur->buf.p, ip, cn_len) == 0) {
   2931                      return 0;
   2932                  }
   2933              }
   2934          
   2935              return -1;
   2936          }
   2937          
   2938          static int x509_crt_check_san_uri(const mbedtls_x509_sequence *san,
   2939                                            const char *cn, size_t cn_len)
   2940          {
   2941              for (const mbedtls_x509_sequence *cur = san; cur != NULL; cur = cur->next) {
   2942                  const unsigned char san_type = (unsigned char) cur->buf.tag &
   2943                                                 MBEDTLS_ASN1_TAG_VALUE_MASK;
   2944                  if (san_type == MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER &&
   2945                      cur->buf.len == cn_len && memcmp(cur->buf.p, cn, cn_len) == 0) {
   2946                      return 0;
   2947                  }
   2948              }
   2949          
   2950              return -1;
   2951          }
   2952          
   2953          /*
   2954           * Check for SAN match, see RFC 5280 Section 4.2.1.6
   2955           */
   2956          static int x509_crt_check_san(const mbedtls_x509_sequence *san,
   2957                                        const char *cn, size_t cn_len)
   2958          {
   2959              int san_ip = 0;
   2960              int san_uri = 0;
   2961              /* Prioritize DNS name over other subtypes due to popularity */
   2962              for (const mbedtls_x509_sequence *cur = san; cur != NULL; cur = cur->next) {
   2963                  switch ((unsigned char) cur->buf.tag & MBEDTLS_ASN1_TAG_VALUE_MASK) {
   2964                      case MBEDTLS_X509_SAN_DNS_NAME:
   2965                          if (x509_crt_check_cn(&cur->buf, cn, cn_len) == 0) {
   2966                              return 0;
   2967                          }
   2968                          break;
   2969                      case MBEDTLS_X509_SAN_IP_ADDRESS:
   2970                          san_ip = 1;
   2971                          break;
   2972                      case MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER:
   2973                          san_uri = 1;
   2974                          break;
   2975                      /* (We may handle other types here later.) */
   2976                      default: /* Unrecognized type */
   2977                          break;
   2978                  }
   2979              }
   2980              if (san_ip) {
   2981                  if (x509_crt_check_san_ip(san, cn, cn_len) == 0) {
   2982                      return 0;
   2983                  }
   2984              }
   2985              if (san_uri) {
   2986                  if (x509_crt_check_san_uri(san, cn, cn_len) == 0) {
   2987                      return 0;
   2988                  }
   2989              }
   2990          
   2991              return -1;
   2992          }
   2993          
   2994          /*
   2995           * Verify the requested CN - only call this if cn is not NULL!
   2996           */
   2997          static void x509_crt_verify_name(const mbedtls_x509_crt *crt,
   2998                                           const char *cn,
   2999                                           uint32_t *flags)
   3000          {
   3001              const mbedtls_x509_name *name;
   3002              size_t cn_len = strlen(cn);
   3003          
   3004              if (crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME) {
   3005                  if (x509_crt_check_san(&crt->subject_alt_names, cn, cn_len) == 0) {
   3006                      return;
   3007                  }
   3008              } else {
   3009                  for (name = &crt->subject; name != NULL; name = name->next) {
   3010                      if (MBEDTLS_OID_CMP(MBEDTLS_OID_AT_CN, &name->oid) == 0 &&
   3011                          x509_crt_check_cn(&name->val, cn, cn_len) == 0) {
   3012                          return;
   3013                      }
   3014                  }
   3015          
   3016              }
   3017          
   3018              *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
   3019          }
   3020          
   3021          /*
   3022           * Merge the flags for all certs in the chain, after calling callback
   3023           */
   3024          static int x509_crt_merge_flags_with_cb(
   3025              uint32_t *flags,
   3026              const mbedtls_x509_crt_verify_chain *ver_chain,
   3027              int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3028              void *p_vrfy)
   3029          {
   3030              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3031              unsigned i;
   3032              uint32_t cur_flags;
   3033              const mbedtls_x509_crt_verify_chain_item *cur;
   3034          
   3035              for (i = ver_chain->len; i != 0; --i) {
   3036                  cur = &ver_chain->items[i-1];
   3037                  cur_flags = cur->flags;
   3038          
   3039                  if (NULL != f_vrfy) {
   3040                      if ((ret = f_vrfy(p_vrfy, cur->crt, (int) i-1, &cur_flags)) != 0) {
   3041                          return ret;
   3042                      }
   3043                  }
   3044          
   3045                  *flags |= cur_flags;
   3046              }
   3047          
   3048              return 0;
   3049          }
   3050          
   3051          /*
   3052           * Verify the certificate validity, with profile, restartable version
   3053           *
   3054           * This function:
   3055           *  - checks the requested CN (if any)
   3056           *  - checks the type and size of the EE cert's key,
   3057           *    as that isn't done as part of chain building/verification currently
   3058           *  - builds and verifies the chain
   3059           *  - then calls the callback and merges the flags
   3060           *
   3061           * The parameters pairs `trust_ca`, `ca_crl` and `f_ca_cb`, `p_ca_cb`
   3062           * are mutually exclusive: If `f_ca_cb != NULL`, it will be used by the
   3063           * verification routine to search for trusted signers, and CRLs will
   3064           * be disabled. Otherwise, `trust_ca` will be used as the static list
   3065           * of trusted signers, and `ca_crl` will be use as the static list
   3066           * of CRLs.
   3067           */

   \                                 In section .text, align 4, keep-with-next
   3068          static int x509_crt_verify_restartable_ca_cb(mbedtls_x509_crt *crt,
   3069                                                       mbedtls_x509_crt *trust_ca,
   3070                                                       mbedtls_x509_crl *ca_crl,
   3071                                                       mbedtls_x509_crt_ca_cb_t f_ca_cb,
   3072                                                       void *p_ca_cb,
   3073                                                       const mbedtls_x509_crt_profile *profile,
   3074                                                       const char *cn, uint32_t *flags,
   3075                                                       int (*f_vrfy)(void *,
   3076                                                                     mbedtls_x509_crt *,
   3077                                                                     int,
   3078                                                                     uint32_t *),
   3079                                                       void *p_vrfy,
   3080                                                       mbedtls_x509_crt_restart_ctx *rs_ctx)
   3081          {
   \                     x509_crt_verify_restartable_ca_cb: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB0A7             SUB      SP,SP,#+156
   \        0x6   0x4690             MOV      R8,R2
   3082              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   3083              mbedtls_pk_type_t pk_type;
   3084              mbedtls_x509_crt_verify_chain ver_chain;
   3085              uint32_t ee_flags;
   3086          
   3087              *flags = 0;
   \        0x8   0x9A33             LDR      R2,[SP, #+204]
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x460E             MOV      R6,R1
   \        0xE   0x6013             STR      R3,[R2, #+0]
   3088              ee_flags = 0;
   \       0x10   0x9304             STR      R3,[SP, #+16]
   3089              x509_crt_verify_chain_reset(&ver_chain);
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0xF04F 0x34FF      MOV      R4,#+4294967295
   \                     ??x509_crt_verify_restartable_ca_cb_1: (+1)
   \       0x18   0xA909             ADD      R1,SP,#+36
   \       0x1A   0xF841 0x3032      STR      R3,[R1, R2, LSL #+3]
   \       0x1E   0xA90A             ADD      R1,SP,#+40
   \       0x20   0xF841 0x4032      STR      R4,[R1, R2, LSL #+3]
   \       0x24   0x1C52             ADDS     R2,R2,#+1
   \       0x26   0x2A09             CMP      R2,#+9
   \       0x28   0xD9F6             BLS.N    ??x509_crt_verify_restartable_ca_cb_1
   3090          
   3091              if (profile == NULL) {
   \       0x2A   0x9931             LDR      R1,[SP, #+196]
   \       0x2C   0x931D             STR      R3,[SP, #+116]
   \       0x2E   0xB911             CBNZ.N   R1,??x509_crt_verify_restartable_ca_cb_2
   3092                  ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable39_4
   3093                  goto exit;
   \       0x34   0xE1EB             B.N      ??x509_crt_verify_restartable_ca_cb_3
   3094              }
   \                     ??x509_crt_verify_restartable_ca_cb_2: (+1)
   \       0x36   0xF8DD 0xA0C8      LDR      R10,[SP, #+200]
   \       0x3A   0x4605             MOV      R5,R0
   3095          
   3096              /* check name if requested */
   3097              if (cn != NULL) {
   \       0x3C   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x40   0xD075             BEQ.N    ??x509_crt_verify_restartable_ca_cb_4
   3098                  x509_crt_verify_name(crt, cn, &ee_flags);
   \       0x42   0x4650             MOV      R0,R10
   \       0x44   0x.... 0x....      BL       strlen
   \       0x48   0xF895 0x11F0      LDRB     R1,[R5, #+496]
   \       0x4C   0x4681             MOV      R9,R0
   \       0x4E   0x0688             LSLS     R0,R1,#+26
   \       0x50   0xD552             BPL.N    ??x509_crt_verify_restartable_ca_cb_5
   \       0x52   0xF04F 0x0B00      MOV      R11,#+0
   \       0x56   0x4657             MOV      R7,R10
   \       0x58   0xF505 0x74C8      ADD      R4,R5,#+400
   \       0x5C   0x46DA             MOV      R10,R11
   \       0x5E   0xE007             B.N      ??x509_crt_verify_restartable_ca_cb_6
   \                     ??x509_crt_verify_restartable_ca_cb_7: (+1)
   \       0x60   0x464A             MOV      R2,R9
   \       0x62   0x4639             MOV      R1,R7
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x.... 0x....      BL       x509_crt_check_cn
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD05F             BEQ.N    ??x509_crt_verify_restartable_ca_cb_4
   \                     ??x509_crt_verify_restartable_ca_cb_8: (+1)
   \       0x6E   0x68E4             LDR      R4,[R4, #+12]
   \                     ??x509_crt_verify_restartable_ca_cb_6: (+1)
   \       0x70   0xB174             CBZ.N    R4,??x509_crt_verify_restartable_ca_cb_9
   \       0x72   0x7820             LDRB     R0,[R4, #+0]
   \       0x74   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x78   0x2802             CMP      R0,#+2
   \       0x7A   0xD0F1             BEQ.N    ??x509_crt_verify_restartable_ca_cb_7
   \       0x7C   0x2806             CMP      R0,#+6
   \       0x7E   0xD004             BEQ.N    ??x509_crt_verify_restartable_ca_cb_10
   \       0x80   0x2807             CMP      R0,#+7
   \       0x82   0xBF08             IT       EQ
   \       0x84   0xF04F 0x0B01      MOVEQ    R11,#+1
   \       0x88   0xE7F1             B.N      ??x509_crt_verify_restartable_ca_cb_8
   \                     ??x509_crt_verify_restartable_ca_cb_10: (+1)
   \       0x8A   0xF04F 0x0A01      MOV      R10,#+1
   \       0x8E   0xE7EE             B.N      ??x509_crt_verify_restartable_ca_cb_8
   \                     ??x509_crt_verify_restartable_ca_cb_9: (+1)
   \       0x90   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x94   0xD01A             BEQ.N    ??x509_crt_verify_restartable_ca_cb_11
   \       0x96   0x4669             MOV      R1,SP
   \       0x98   0x4638             MOV      R0,R7
   \       0x9A   0x.... 0x....      BL       mbedtls_x509_crt_parse_cn_inet_pton
   \       0x9E   0xEA5F 0x0B00      MOVS     R11,R0
   \       0xA2   0xD013             BEQ.N    ??x509_crt_verify_restartable_ca_cb_11
   \       0xA4   0xF505 0x74C8      ADD      R4,R5,#+400
   \       0xA8   0xE00E             B.N      ??x509_crt_verify_restartable_ca_cb_12
   \                     ??x509_crt_verify_restartable_ca_cb_13: (+1)
   \       0xAA   0x7820             LDRB     R0,[R4, #+0]
   \       0xAC   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0xB0   0x2807             CMP      R0,#+7
   \       0xB2   0xBF04             ITT      EQ
   \       0xB4   0x6860             LDREQ    R0,[R4, #+4]
   \       0xB6   0x4558             CMPEQ    R0,R11
   \       0xB8   0xD105             BNE.N    ??x509_crt_verify_restartable_ca_cb_14
   \       0xBA   0x68A0             LDR      R0,[R4, #+8]
   \       0xBC   0x465A             MOV      R2,R11
   \       0xBE   0x4669             MOV      R1,SP
   \       0xC0   0x.... 0x....      BL       memcmp
   \       0xC4   0xB398             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_4
   \                     ??x509_crt_verify_restartable_ca_cb_14: (+1)
   \       0xC6   0x68E4             LDR      R4,[R4, #+12]
   \                     ??x509_crt_verify_restartable_ca_cb_12: (+1)
   \       0xC8   0x2C00             CMP      R4,#+0
   \       0xCA   0xD1EE             BNE.N    ??x509_crt_verify_restartable_ca_cb_13
   \                     ??x509_crt_verify_restartable_ca_cb_11: (+1)
   \       0xCC   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xD0   0xD02B             BEQ.N    ??x509_crt_verify_restartable_ca_cb_15
   \       0xD2   0xF505 0x74C8      ADD      R4,R5,#+400
   \                     ??x509_crt_verify_restartable_ca_cb_16: (+1)
   \       0xD6   0xB344             CBZ.N    R4,??x509_crt_verify_restartable_ca_cb_15
   \       0xD8   0x7820             LDRB     R0,[R4, #+0]
   \       0xDA   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0xDE   0x2806             CMP      R0,#+6
   \       0xE0   0xBF04             ITT      EQ
   \       0xE2   0x6860             LDREQ    R0,[R4, #+4]
   \       0xE4   0x4548             CMPEQ    R0,R9
   \       0xE6   0xD105             BNE.N    ??x509_crt_verify_restartable_ca_cb_17
   \       0xE8   0x68A0             LDR      R0,[R4, #+8]
   \       0xEA   0x464A             MOV      R2,R9
   \       0xEC   0x4639             MOV      R1,R7
   \       0xEE   0x.... 0x....      BL       memcmp
   \       0xF2   0xB1E0             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_4
   \                     ??x509_crt_verify_restartable_ca_cb_17: (+1)
   \       0xF4   0x68E4             LDR      R4,[R4, #+12]
   \       0xF6   0xE7EE             B.N      ??x509_crt_verify_restartable_ca_cb_16
   \                     ??x509_crt_verify_restartable_ca_cb_5: (+1)
   \       0xF8   0xF105 0x0470      ADD      R4,R5,#+112
   \       0xFC   0xA700             ADR.N    R7,??x509_crt_verify_restartable_ca_cb_0
   \       0xFE   0xE012             B.N      ??x509_crt_verify_restartable_ca_cb_18
   \                     ??x509_crt_verify_restartable_ca_cb_0:
   \      0x100   0x55 0x04          DC8      "U\004\003"    
   \              0x03 0x00
   \                     ??x509_crt_verify_restartable_ca_cb_19: (+1)
   \      0x104   0x6860             LDR      R0,[R4, #+4]
   \      0x106   0x2803             CMP      R0,#+3
   \      0x108   0xD10C             BNE.N    ??x509_crt_verify_restartable_ca_cb_20
   \      0x10A   0x68A1             LDR      R1,[R4, #+8]
   \      0x10C   0x2203             MOVS     R2,#+3
   \      0x10E   0x4638             MOV      R0,R7
   \      0x110   0x.... 0x....      BL       memcmp
   \      0x114   0xB930             CBNZ.N   R0,??x509_crt_verify_restartable_ca_cb_20
   \      0x116   0x464A             MOV      R2,R9
   \      0x118   0x4651             MOV      R1,R10
   \      0x11A   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x11E   0x.... 0x....      BL       x509_crt_check_cn
   \      0x122   0xB120             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_4
   \                     ??x509_crt_verify_restartable_ca_cb_20: (+1)
   \      0x124   0x69A4             LDR      R4,[R4, #+24]
   \                     ??x509_crt_verify_restartable_ca_cb_18: (+1)
   \      0x126   0x2C00             CMP      R4,#+0
   \      0x128   0xD1EC             BNE.N    ??x509_crt_verify_restartable_ca_cb_19
   \                     ??x509_crt_verify_restartable_ca_cb_15: (+1)
   \      0x12A   0x2004             MOVS     R0,#+4
   \      0x12C   0x9004             STR      R0,[SP, #+16]
   3099              }
   3100          
   3101              /* Check the type and size of the key */
   3102              pk_type = mbedtls_pk_get_type(&crt->pk);
   \                     ??x509_crt_verify_restartable_ca_cb_4: (+1)
   \      0x12E   0xF105 0x04CC      ADD      R4,R5,#+204
   \      0x132   0x4620             MOV      R0,R4
   \      0x134   0x.... 0x....      BL       mbedtls_pk_get_type
   3103          
   3104              if (x509_profile_check_pk_alg(profile, pk_type) != 0) {
   \      0x138   0x4601             MOV      R1,R0
   \      0x13A   0x9831             LDR      R0,[SP, #+196]
   \      0x13C   0x.... 0x....      BL       x509_profile_check_pk_alg
   \      0x140   0xB118             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_21
   3105                  ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;
   \      0x142   0x9804             LDR      R0,[SP, #+16]
   \      0x144   0xF440 0x4000      ORR      R0,R0,#0x8000
   \      0x148   0x9004             STR      R0,[SP, #+16]
   3106              }
   3107          
   3108              if (x509_profile_check_key(profile, &crt->pk) != 0) {
   \                     ??x509_crt_verify_restartable_ca_cb_21: (+1)
   \      0x14A   0x9831             LDR      R0,[SP, #+196]
   \      0x14C   0x4621             MOV      R1,R4
   \      0x14E   0x.... 0x....      BL       x509_profile_check_key
   \      0x152   0xB118             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_22
   3109                  ee_flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
   \      0x154   0x9904             LDR      R1,[SP, #+16]
   \      0x156   0xF441 0x3180      ORR      R1,R1,#0x10000
   \      0x15A   0x9104             STR      R1,[SP, #+16]
   3110              }
   3111          
   3112              /* Check the chain */
   3113              ret = x509_crt_verify_chain(crt, trust_ca, ca_crl,
   3114                                          f_ca_cb, p_ca_cb, profile,
   3115                                          &ver_chain, rs_ctx);
   \                     ??x509_crt_verify_restartable_ca_cb_22: (+1)
   \      0x15C   0x2200             MOVS     R2,#+0
   \      0x15E   0x46AA             MOV      R10,R5
   \      0x160   0x9205             STR      R2,[SP, #+20]
   \      0x162   0x2000             MOVS     R0,#+0
   \      0x164   0x9608             STR      R6,[SP, #+32]
   \      0x166   0xF8CD 0x8078      STR      R8,[SP, #+120]
   \      0x16A   0xE05B             B.N      ??x509_crt_verify_restartable_ca_cb_23
   \                     ??x509_crt_verify_restartable_ca_cb_24: (+1)
   \      0x16C   0xF8CD 0xB0C4      STR      R11,[SP, #+196]
   \      0x170   0xF046 0x0610      ORR      R6,R6,#0x10
   \      0x174   0xE052             B.N      ??x509_crt_verify_restartable_ca_cb_25
   \                     ??x509_crt_verify_restartable_ca_cb_26: (+1)
   \      0x176   0x692C             LDR      R4,[R5, #+16]
   \                     ??x509_crt_verify_restartable_ca_cb_27: (+1)
   \      0x178   0x2C00             CMP      R4,#+0
   \      0x17A   0xD04D             BEQ.N    ??x509_crt_verify_restartable_ca_cb_28
   \      0x17C   0x69A0             LDR      R0,[R4, #+24]
   \      0x17E   0xF104 0x05E0      ADD      R5,R4,#+224
   \      0x182   0x2800             CMP      R0,#+0
   \      0x184   0xD0F7             BEQ.N    ??x509_crt_verify_restartable_ca_cb_26
   \      0x186   0xF10A 0x0170      ADD      R1,R10,#+112
   \      0x18A   0xF104 0x0034      ADD      R0,R4,#+52
   \      0x18E   0x.... 0x....      BL       x509_name_cmp
   \      0x192   0x2800             CMP      R0,#+0
   \      0x194   0xD1EF             BNE.N    ??x509_crt_verify_restartable_ca_cb_26
   \      0x196   0x2102             MOVS     R1,#+2
   \      0x198   0x4650             MOV      R0,R10
   \      0x19A   0x.... 0x....      BL       mbedtls_x509_crt_check_key_usage
   \      0x19E   0x2800             CMP      R0,#+0
   \      0x1A0   0xD1E4             BNE.N    ??x509_crt_verify_restartable_ca_cb_24
   \      0x1A2   0x7A29             LDRB     R1,[R5, #+8]
   \      0x1A4   0x4658             MOV      R0,R11
   \      0x1A6   0x.... 0x....      BL       x509_profile_check_md_alg
   \      0x1AA   0xB108             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_29
   \      0x1AC   0xF446 0x3600      ORR      R6,R6,#0x20000
   \                     ??x509_crt_verify_restartable_ca_cb_29: (+1)
   \      0x1B0   0x7A69             LDRB     R1,[R5, #+9]
   \      0x1B2   0x4658             MOV      R0,R11
   \      0x1B4   0x.... 0x....      BL       x509_profile_check_pk_alg
   \      0x1B8   0xB108             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_30
   \      0x1BA   0xF446 0x2680      ORR      R6,R6,#0x40000
   \                     ??x509_crt_verify_restartable_ca_cb_30: (+1)
   \      0x1BE   0x7A28             LDRB     R0,[R5, #+8]
   \      0x1C0   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \      0x1C4   0xAA06             ADD      R2,SP,#+24
   \      0x1C6   0x2120             MOVS     R1,#+32
   \      0x1C8   0x9201             STR      R2,[SP, #+4]
   \      0x1CA   0x9100             STR      R1,[SP, #+0]
   \      0x1CC   0x6922             LDR      R2,[R4, #+16]
   \      0x1CE   0x6961             LDR      R1,[R4, #+20]
   \      0x1D0   0xAB1F             ADD      R3,SP,#+124
   \      0x1D2   0x.... 0x....      BL       psa_hash_compute
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD1C8             BNE.N    ??x509_crt_verify_restartable_ca_cb_24
   \      0x1DA   0x4649             MOV      R1,R9
   \      0x1DC   0x4658             MOV      R0,R11
   \      0x1DE   0x.... 0x....      BL       x509_profile_check_key
   \      0x1E2   0xB108             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_31
   \      0x1E4   0xF446 0x3680      ORR      R6,R6,#0x10000
   \                     ??x509_crt_verify_restartable_ca_cb_31: (+1)
   \      0x1E8   0x6828             LDR      R0,[R5, #+0]
   \      0x1EA   0x9906             LDR      R1,[SP, #+24]
   \      0x1EC   0x9003             STR      R0,[SP, #+12]
   \      0x1EE   0x686A             LDR      R2,[R5, #+4]
   \      0x1F0   0xA81F             ADD      R0,SP,#+124
   \      0x1F2   0x9101             STR      R1,[SP, #+4]
   \      0x1F4   0x9202             STR      R2,[SP, #+8]
   \      0x1F6   0x9000             STR      R0,[SP, #+0]
   \      0x1F8   0x7A2B             LDRB     R3,[R5, #+8]
   \      0x1FA   0x68E9             LDR      R1,[R5, #+12]
   \      0x1FC   0x7A68             LDRB     R0,[R5, #+9]
   \      0x1FE   0x464A             MOV      R2,R9
   \      0x200   0x.... 0x....      BL       mbedtls_pk_verify_ext
   \      0x204   0x2800             CMP      R0,#+0
   \      0x206   0xD1B1             BNE.N    ??x509_crt_verify_restartable_ca_cb_24
   \      0x208   0x4621             MOV      R1,R4
   \      0x20A   0x4640             MOV      R0,R8
   \      0x20C   0x.... 0x....      BL       mbedtls_x509_crt_is_revoked
   \      0x210   0x2800             CMP      R0,#+0
   \      0x212   0xD0B0             BEQ.N    ??x509_crt_verify_restartable_ca_cb_26
   \      0x214   0xF046 0x0602      ORR      R6,R6,#0x2
   \                     ??x509_crt_verify_restartable_ca_cb_28: (+1)
   \      0x218   0xF8CD 0xB0C4      STR      R11,[SP, #+196]
   \                     ??x509_crt_verify_restartable_ca_cb_25: (+1)
   \      0x21C   0x6878             LDR      R0,[R7, #+4]
   \      0x21E   0x4306             ORRS     R6,R6,R0
   \      0x220   0x607E             STR      R6,[R7, #+4]
   \      0x222   0x9807             LDR      R0,[SP, #+28]
   \                     ??x509_crt_verify_restartable_ca_cb_23: (+1)
   \      0x224   0x9A1D             LDR      R2,[SP, #+116]
   \      0x226   0xA909             ADD      R1,SP,#+36
   \      0x228   0xEB01 0x07C2      ADD      R7,R1,R2, LSL #+3
   \      0x22C   0xF8C7 0xA000      STR      R10,[R7, #+0]
   \      0x230   0x2100             MOVS     R1,#+0
   \      0x232   0x6079             STR      R1,[R7, #+4]
   \      0x234   0x991D             LDR      R1,[SP, #+116]
   \      0x236   0x1C49             ADDS     R1,R1,#+1
   \      0x238   0x911D             STR      R1,[SP, #+116]
   \      0x23A   0x2800             CMP      R0,#+0
   \      0x23C   0xF040 0x80C3      BNE.W    ??x509_crt_verify_restartable_ca_cb_32
   \      0x240   0xF50A 0x7006      ADD      R0,R10,#+536
   \      0x244   0x7A01             LDRB     R1,[R0, #+8]
   \      0x246   0x9831             LDR      R0,[SP, #+196]
   \      0x248   0x.... 0x....      BL       x509_profile_check_md_alg
   \      0x24C   0xB118             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_33
   \      0x24E   0x6878             LDR      R0,[R7, #+4]
   \      0x250   0xF440 0x4080      ORR      R0,R0,#0x4000
   \      0x254   0x6078             STR      R0,[R7, #+4]
   \                     ??x509_crt_verify_restartable_ca_cb_33: (+1)
   \      0x256   0xF50A 0x7006      ADD      R0,R10,#+536
   \      0x25A   0x7A41             LDRB     R1,[R0, #+9]
   \      0x25C   0x9831             LDR      R0,[SP, #+196]
   \      0x25E   0x.... 0x....      BL       x509_profile_check_pk_alg
   \      0x262   0xB118             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_34
   \      0x264   0x6878             LDR      R0,[R7, #+4]
   \      0x266   0xF440 0x4000      ORR      R0,R0,#0x8000
   \      0x26A   0x6078             STR      R0,[R7, #+4]
   \                     ??x509_crt_verify_restartable_ca_cb_34: (+1)
   \      0x26C   0x981D             LDR      R0,[SP, #+116]
   \      0x26E   0x2801             CMP      R0,#+1
   \      0x270   0xD115             BNE.N    ??x509_crt_verify_restartable_ca_cb_35
   \      0x272   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_63: (+1)
   \      0x276   0xB990             CBNZ.N   R0,??x509_crt_verify_restartable_ca_cb_35
   \      0x278   0x9C08             LDR      R4,[SP, #+32]
   \      0x27A   0xE00E             B.N      ??x509_crt_verify_restartable_ca_cb_36
   \                     ??x509_crt_verify_restartable_ca_cb_37: (+1)
   \      0x27C   0xF8DA 0x2008      LDR      R2,[R10, #+8]
   \      0x280   0x68A0             LDR      R0,[R4, #+8]
   \      0x282   0x4282             CMP      R2,R0
   \      0x284   0xD107             BNE.N    ??x509_crt_verify_restartable_ca_cb_38
   \      0x286   0x68E1             LDR      R1,[R4, #+12]
   \      0x288   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \      0x28C   0x.... 0x....      BL       memcmp
   \      0x290   0x2800             CMP      R0,#+0
   \      0x292   0xF000 0x8098      BEQ.W    ??x509_crt_verify_restartable_ca_cb_32
   \                     ??x509_crt_verify_restartable_ca_cb_38: (+1)
   \      0x296   0xF8D4 0x4228      LDR      R4,[R4, #+552]
   \                     ??x509_crt_verify_restartable_ca_cb_36: (+1)
   \      0x29A   0x2C00             CMP      R4,#+0
   \      0x29C   0xD1EE             BNE.N    ??x509_crt_verify_restartable_ca_cb_37
   \                     ??x509_crt_verify_restartable_ca_cb_35: (+1)
   \      0x29E   0x981D             LDR      R0,[SP, #+116]
   \      0x2A0   0x2401             MOVS     R4,#+1
   \      0x2A2   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \      0x2A6   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \      0x2AA   0xF50A 0x7606      ADD      R6,R10,#+536
   \      0x2AE   0xE002             B.N      ??x509_crt_verify_restartable_ca_cb_39
   \                     ??x509_crt_verify_restartable_ca_cb_40: (+1)
   \      0x2B0   0x2400             MOVS     R4,#+0
   \      0x2B2   0xF8D6 0x8010      LDR      R8,[R6, #+16]
   \                     ??x509_crt_verify_restartable_ca_cb_39: (+1)
   \      0x2B6   0x9D05             LDR      R5,[SP, #+20]
   \      0x2B8   0xE001             B.N      ??x509_crt_verify_restartable_ca_cb_41
   \                     ??x509_crt_verify_restartable_ca_cb_42: (+1)
   \      0x2BA   0xF8D9 0x8034      LDR      R8,[R9, #+52]
   \                     ??x509_crt_verify_restartable_ca_cb_41: (+1)
   \      0x2BE   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x2C2   0xD078             BEQ.N    ??x509_crt_verify_restartable_ca_cb_43
   \      0x2C4   0xF108 0x0170      ADD      R1,R8,#+112
   \      0x2C8   0xF10A 0x0050      ADD      R0,R10,#+80
   \      0x2CC   0x.... 0x....      BL       x509_name_cmp
   \      0x2D0   0xF508 0x79FA      ADD      R9,R8,#+500
   \      0x2D4   0x2800             CMP      R0,#+0
   \      0x2D6   0xD1F0             BNE.N    ??x509_crt_verify_restartable_ca_cb_42
   \      0x2D8   0xB11C             CBZ.N    R4,??x509_crt_verify_restartable_ca_cb_44
   \      0x2DA   0xF8D8 0x101C      LDR      R1,[R8, #+28]
   \      0x2DE   0x2903             CMP      R1,#+3
   \      0x2E0   0xDB09             BLT.N    ??x509_crt_verify_restartable_ca_cb_45
   \                     ??x509_crt_verify_restartable_ca_cb_44: (+1)
   \      0x2E2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x2E6   0x2800             CMP      R0,#+0
   \      0x2E8   0xD0E7             BEQ.N    ??x509_crt_verify_restartable_ca_cb_42
   \      0x2EA   0x2104             MOVS     R1,#+4
   \      0x2EC   0x4640             MOV      R0,R8
   \      0x2EE   0x.... 0x....      BL       mbedtls_x509_crt_check_key_usage
   \      0x2F2   0x2800             CMP      R0,#+0
   \      0x2F4   0xD1E1             BNE.N    ??x509_crt_verify_restartable_ca_cb_42
   \                     ??x509_crt_verify_restartable_ca_cb_45: (+1)
   \      0x2F6   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x2FA   0x2800             CMP      R0,#+0
   \      0x2FC   0xDD04             BLE.N    ??x509_crt_verify_restartable_ca_cb_46
   \      0x2FE   0xF10B 0x0101      ADD      R1,R11,#+1
   \      0x302   0x1B49             SUBS     R1,R1,R5
   \      0x304   0x4288             CMP      R0,R1
   \      0x306   0xD3D8             BCC.N    ??x509_crt_verify_restartable_ca_cb_42
   \                     ??x509_crt_verify_restartable_ca_cb_46: (+1)
   \      0x308   0x7A30             LDRB     R0,[R6, #+8]
   \      0x30A   0x.... 0x....      BL       mbedtls_md_psa_alg_from_type
   \      0x30E   0xAA06             ADD      R2,SP,#+24
   \      0x310   0x2120             MOVS     R1,#+32
   \      0x312   0x9201             STR      R2,[SP, #+4]
   \      0x314   0x9100             STR      R1,[SP, #+0]
   \      0x316   0xF8DA 0x2014      LDR      R2,[R10, #+20]
   \      0x31A   0xF8DA 0x1018      LDR      R1,[R10, #+24]
   \      0x31E   0xAB1F             ADD      R3,SP,#+124
   \      0x320   0x.... 0x....      BL       psa_hash_compute
   \      0x324   0xB9C0             CBNZ.N   R0,??x509_crt_verify_restartable_ca_cb_47
   \      0x326   0xF108 0x00CC      ADD      R0,R8,#+204
   \      0x32A   0x9005             STR      R0,[SP, #+20]
   \      0x32C   0x7A71             LDRB     R1,[R6, #+9]
   \      0x32E   0x.... 0x....      BL       mbedtls_pk_can_do
   \      0x332   0xB188             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_47
   \      0x334   0x6830             LDR      R0,[R6, #+0]
   \      0x336   0x9A06             LDR      R2,[SP, #+24]
   \      0x338   0x9003             STR      R0,[SP, #+12]
   \      0x33A   0x6871             LDR      R1,[R6, #+4]
   \      0x33C   0xA81F             ADD      R0,SP,#+124
   \      0x33E   0x9201             STR      R2,[SP, #+4]
   \      0x340   0x9102             STR      R1,[SP, #+8]
   \      0x342   0x9000             STR      R0,[SP, #+0]
   \      0x344   0x7A33             LDRB     R3,[R6, #+8]
   \      0x346   0x9A05             LDR      R2,[SP, #+20]
   \      0x348   0x68F1             LDR      R1,[R6, #+12]
   \      0x34A   0x7A70             LDRB     R0,[R6, #+9]
   \      0x34C   0x.... 0x....      BL       mbedtls_pk_verify_ext
   \      0x350   0x1E41             SUBS     R1,R0,#+1
   \      0x352   0x4189             SBCS     R1,R1,R1
   \      0x354   0x0FC9             LSRS     R1,R1,#+31
   \      0x356   0xE000             B.N      ??x509_crt_verify_restartable_ca_cb_48
   \                     ??x509_crt_verify_restartable_ca_cb_47: (+1)
   \      0x358   0x2100             MOVS     R1,#+0
   \                     ??x509_crt_verify_restartable_ca_cb_48: (+1)
   \      0x35A   0xF081 0x0201      EOR      R2,R1,#0x1
   \      0x35E   0x4214             TST      R4,R2
   \      0x360   0xD1AB             BNE.N    ??x509_crt_verify_restartable_ca_cb_42
   \      0x362   0x9505             STR      R5,[SP, #+20]
   \      0x364   0x981D             LDR      R0,[SP, #+116]
   \      0x366   0x9407             STR      R4,[SP, #+28]
   \      0x368   0x4644             MOV      R4,R8
   \      0x36A   0x460D             MOV      R5,R1
   \      0x36C   0x2801             CMP      R0,#+1
   \      0x36E   0xD00A             BEQ.N    ??x509_crt_verify_restartable_ca_cb_49
   \      0x370   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_64: (+1)
   \      0x374   0xB910             CBNZ.N   R0,??x509_crt_verify_restartable_ca_cb_50
   \      0x376   0x9805             LDR      R0,[SP, #+20]
   \      0x378   0x1C40             ADDS     R0,R0,#+1
   \      0x37A   0x9005             STR      R0,[SP, #+20]
   \                     ??x509_crt_verify_restartable_ca_cb_50: (+1)
   \      0x37C   0x9807             LDR      R0,[SP, #+28]
   \      0x37E   0xB910             CBNZ.N   R0,??x509_crt_verify_restartable_ca_cb_49
   \      0x380   0x981D             LDR      R0,[SP, #+116]
   \      0x382   0x2808             CMP      R0,#+8
   \      0x384   0xD842             BHI.N    ??x509_crt_verify_restartable_ca_cb_51
   \                     ??x509_crt_verify_restartable_ca_cb_49: (+1)
   \      0x386   0xB91D             CBNZ.N   R5,??x509_crt_verify_restartable_ca_cb_52
   \      0x388   0x6878             LDR      R0,[R7, #+4]
   \      0x38A   0xF040 0x0008      ORR      R0,R0,#0x8
   \      0x38E   0x6078             STR      R0,[R7, #+4]
   \                     ??x509_crt_verify_restartable_ca_cb_52: (+1)
   \      0x390   0x9831             LDR      R0,[SP, #+196]
   \      0x392   0xF104 0x09CC      ADD      R9,R4,#+204
   \      0x396   0x4649             MOV      R1,R9
   \      0x398   0x.... 0x....      BL       x509_profile_check_key
   \      0x39C   0xB118             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_53
   \      0x39E   0x6878             LDR      R0,[R7, #+4]
   \      0x3A0   0xF440 0x3080      ORR      R0,R0,#0x10000
   \      0x3A4   0x6078             STR      R0,[R7, #+4]
   \                     ??x509_crt_verify_restartable_ca_cb_53: (+1)
   \      0x3A6   0x981E             LDR      R0,[SP, #+120]
   \      0x3A8   0x46D0             MOV      R8,R10
   \      0x3AA   0x46A2             MOV      R10,R4
   \      0x3AC   0x2600             MOVS     R6,#+0
   \      0x3AE   0xF8DD 0xB0C4      LDR      R11,[SP, #+196]
   \      0x3B2   0x4604             MOV      R4,R0
   \      0x3B4   0xE6E0             B.N      ??x509_crt_verify_restartable_ca_cb_27
   \                     ??x509_crt_verify_restartable_ca_cb_43: (+1)
   \      0x3B6   0x9505             STR      R5,[SP, #+20]
   \      0x3B8   0x2C00             CMP      R4,#+0
   \      0x3BA   0xF47F 0xAF79      BNE.W    ??x509_crt_verify_restartable_ca_cb_40
   \      0x3BE   0x6878             LDR      R0,[R7, #+4]
   \      0x3C0   0xF040 0x0008      ORR      R0,R0,#0x8
   \      0x3C4   0x6078             STR      R0,[R7, #+4]
   3116          
   3117              if (ret != 0) {
   3118                  goto exit;
   3119              }
   3120          
   3121              /* Merge end-entity flags */
   3122              ver_chain.items[0].flags |= ee_flags;
   \                     ??x509_crt_verify_restartable_ca_cb_32: (+1)
   \      0x3C6   0x990A             LDR      R1,[SP, #+40]
   \      0x3C8   0x9804             LDR      R0,[SP, #+16]
   3123          
   3124              /* Build final flags, calling callback on the way if any */
   3125              ret = x509_crt_merge_flags_with_cb(flags, &ver_chain, f_vrfy, p_vrfy);
   \      0x3CA   0x9C1D             LDR      R4,[SP, #+116]
   \      0x3CC   0x9E34             LDR      R6,[SP, #+208]
   \      0x3CE   0x4301             ORRS     R1,R0,R1
   \      0x3D0   0x910A             STR      R1,[SP, #+40]
   \      0x3D2   0x9D35             LDR      R5,[SP, #+212]
   \      0x3D4   0x9F33             LDR      R7,[SP, #+204]
   \      0x3D6   0xE004             B.N      ??x509_crt_verify_restartable_ca_cb_54
   \                     ??x509_crt_verify_restartable_ca_cb_55: (+1)
   \      0x3D8   0x6839             LDR      R1,[R7, #+0]
   \      0x3DA   0x9800             LDR      R0,[SP, #+0]
   \      0x3DC   0x1E64             SUBS     R4,R4,#+1
   \      0x3DE   0x4301             ORRS     R1,R0,R1
   \      0x3E0   0x6039             STR      R1,[R7, #+0]
   \                     ??x509_crt_verify_restartable_ca_cb_54: (+1)
   \      0x3E2   0xB1CC             CBZ.N    R4,??x509_crt_verify_restartable_ca_cb_56
   \      0x3E4   0xA809             ADD      R0,SP,#+36
   \      0x3E6   0xEB00 0x02C4      ADD      R2,R0,R4, LSL #+3
   \      0x3EA   0xF1A2 0x0008      SUB      R0,R2,#+8
   \      0x3EE   0x6841             LDR      R1,[R0, #+4]
   \      0x3F0   0x0032             MOVS     R2,R6
   \      0x3F2   0x9100             STR      R1,[SP, #+0]
   \      0x3F4   0xD0F0             BEQ.N    ??x509_crt_verify_restartable_ca_cb_55
   \      0x3F6   0x6801             LDR      R1,[R0, #+0]
   \      0x3F8   0x466B             MOV      R3,SP
   \      0x3FA   0x1E62             SUBS     R2,R4,#+1
   \      0x3FC   0x4628             MOV      R0,R5
   \      0x3FE   0x47B0             BLX      R6
   \      0x400   0x2800             CMP      R0,#+0
   \      0x402   0xD0E9             BEQ.N    ??x509_crt_verify_restartable_ca_cb_55
   \      0x404   0x9733             STR      R7,[SP, #+204]
   3126          
   3127          exit:
   3128          
   3129          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   3130              mbedtls_x509_crt_free(ver_chain.trust_ca_cb_result);
   3131              mbedtls_free(ver_chain.trust_ca_cb_result);
   3132              ver_chain.trust_ca_cb_result = NULL;
   3133          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   3134          
   3135          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   3136              if (rs_ctx != NULL && ret != MBEDTLS_ERR_ECP_IN_PROGRESS) {
   3137                  mbedtls_x509_crt_restart_free(rs_ctx);
   3138              }
   3139          #endif
   3140          
   3141              /* prevent misuse of the vrfy callback - VERIFY_FAILED would be ignored by
   3142               * the SSL module for authmode optional, but non-zero return from the
   3143               * callback means a fatal error so it shouldn't be ignored */
   3144              if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {
   \      0x406   0xF510 0x5F1C      CMN      R0,#+9984
   \      0x40A   0xD100             BNE.N    ??x509_crt_verify_restartable_ca_cb_3
   3145                  ret = MBEDTLS_ERR_X509_FATAL_ERROR;
   \                     ??x509_crt_verify_restartable_ca_cb_51: (+1)
   \      0x40C   0x....             LDR.N    R0,??DataTable39_5
   3146              }
   3147          
   3148              if (ret != 0) {
   3149                  *flags = (uint32_t) -1;
   \                     ??x509_crt_verify_restartable_ca_cb_3: (+1)
   \      0x40E   0x9A33             LDR      R2,[SP, #+204]
   \      0x410   0xF04F 0x31FF      MOV      R1,#+4294967295
   \      0x414   0x6011             STR      R1,[R2, #+0]
   3150                  return ret;
   \      0x416   0xE002             B.N      ??x509_crt_verify_restartable_ca_cb_57
   3151              }
   3152          
   3153              if (*flags != 0) {
   \                     ??x509_crt_verify_restartable_ca_cb_56: (+1)
   \      0x418   0x6838             LDR      R0,[R7, #+0]
   \      0x41A   0xB100             CBZ.N    R0,??x509_crt_verify_restartable_ca_cb_57
   3154                  return MBEDTLS_ERR_X509_CERT_VERIFY_FAILED;
   \      0x41C   0x....             LDR.N    R0,??DataTable39_6
   3155              }
   3156          
   3157              return 0;
   \                     ??x509_crt_verify_restartable_ca_cb_57: (+1)
   \      0x41E   0xB027             ADD      SP,SP,#+156
   \      0x420   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3158          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0xF10A 0x0170      ADD      R1,R10,#+112
   \        0x4   0xF10A 0x0050      ADD      R0,R10,#+80
   \        0x8   0x.... 0x....      B.W      x509_name_cmp
   3159          
   3160          
   3161          /*
   3162           * Verify the certificate validity (default profile, not restartable)
   3163           */

   \                                 In section .text, align 4, keep-with-next
   3164          int mbedtls_x509_crt_verify(mbedtls_x509_crt *crt,
   3165                                      mbedtls_x509_crt *trust_ca,
   3166                                      mbedtls_x509_crl *ca_crl,
   3167                                      const char *cn, uint32_t *flags,
   3168                                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3169                                      void *p_vrfy)
   3170          {
   \                     mbedtls_x509_crt_verify: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   3171              return x509_crt_verify_restartable_ca_cb(crt, trust_ca, ca_crl,
   3172                                                       NULL, NULL,
   3173                                                       &mbedtls_x509_crt_profile_default,
   3174                                                       cn, flags,
   3175                                                       f_vrfy, p_vrfy, NULL);
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x9C0E             LDR      R4,[SP, #+56]
   \        0x8   0x9506             STR      R5,[SP, #+24]
   \        0xA   0x9D0D             LDR      R5,[SP, #+52]
   \        0xC   0x9405             STR      R4,[SP, #+20]
   \        0xE   0x9C0C             LDR      R4,[SP, #+48]
   \       0x10   0x9504             STR      R5,[SP, #+16]
   \       0x12   0x9302             STR      R3,[SP, #+8]
   \       0x14   0x....             ADR.N    R6,mbedtls_x509_crt_profile_default
   \       0x16   0x2500             MOVS     R5,#+0
   \       0x18   0x9403             STR      R4,[SP, #+12]
   \       0x1A   0x9601             STR      R6,[SP, #+4]
   \       0x1C   0x9500             STR      R5,[SP, #+0]
   \       0x1E   0x....             B.N      ??Subroutine17_0
   3176          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine17_0: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x.... 0x....      BL       x509_crt_verify_restartable_ca_cb
   \        0x6   0xB008             ADD      SP,SP,#+32
   \        0x8   0xBD70             POP      {R4-R6,PC}
   3177          
   3178          /*
   3179           * Verify the certificate validity (user-chosen profile, not restartable)
   3180           */

   \                                 In section .text, align 2, keep-with-next
   3181          int mbedtls_x509_crt_verify_with_profile(mbedtls_x509_crt *crt,
   3182                                                   mbedtls_x509_crt *trust_ca,
   3183                                                   mbedtls_x509_crl *ca_crl,
   3184                                                   const mbedtls_x509_crt_profile *profile,
   3185                                                   const char *cn, uint32_t *flags,
   3186                                                   int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3187                                                   void *p_vrfy)
   3188          {
   \                     mbedtls_x509_crt_verify_with_profile: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   3189              return x509_crt_verify_restartable_ca_cb(crt, trust_ca, ca_crl,
   3190                                                       NULL, NULL,
   3191                                                       profile, cn, flags,
   3192                                                       f_vrfy, p_vrfy, NULL);
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x9406             STR      R4,[SP, #+24]
   \        0x8   0x9D0F             LDR      R5,[SP, #+60]
   \        0xA   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_65: (+1)
   \        0xE   0x9301             STR      R3,[SP, #+4]
   \       0x10   0x....             B.N      ?Subroutine2
   3193          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2600             MOVS     R6,#+0
   \        0x2   0x9503             STR      R5,[SP, #+12]
   \        0x4   0x9402             STR      R4,[SP, #+8]
   \        0x6   0x9600             STR      R6,[SP, #+0]
   \        0x8                      REQUIRE ??Subroutine17_0
   \        0x8                      ;; // Fall through to label ??Subroutine17_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x9C0E             LDR      R4,[SP, #+56]
   \        0x2   0x9505             STR      R5,[SP, #+20]
   \        0x4   0x9D0D             LDR      R5,[SP, #+52]
   \        0x6   0x9404             STR      R4,[SP, #+16]
   \        0x8   0x9C0C             LDR      R4,[SP, #+48]
   \        0xA   0x4770             BX       LR
   3194          
   3195          #if defined(MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK)
   3196          /*
   3197           * Verify the certificate validity (user-chosen profile, CA callback,
   3198           *                                  not restartable).
   3199           */
   3200          int mbedtls_x509_crt_verify_with_ca_cb(mbedtls_x509_crt *crt,
   3201                                                 mbedtls_x509_crt_ca_cb_t f_ca_cb,
   3202                                                 void *p_ca_cb,
   3203                                                 const mbedtls_x509_crt_profile *profile,
   3204                                                 const char *cn, uint32_t *flags,
   3205                                                 int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3206                                                 void *p_vrfy)
   3207          {
   3208              return x509_crt_verify_restartable_ca_cb(crt, NULL, NULL,
   3209                                                       f_ca_cb, p_ca_cb,
   3210                                                       profile, cn, flags,
   3211                                                       f_vrfy, p_vrfy, NULL);
   3212          }
   3213          #endif /* MBEDTLS_X509_TRUSTED_CERTIFICATE_CALLBACK */
   3214          

   \                                 In section .text, align 2, keep-with-next
   3215          int mbedtls_x509_crt_verify_restartable(mbedtls_x509_crt *crt,
   3216                                                  mbedtls_x509_crt *trust_ca,
   3217                                                  mbedtls_x509_crl *ca_crl,
   3218                                                  const mbedtls_x509_crt_profile *profile,
   3219                                                  const char *cn, uint32_t *flags,
   3220                                                  int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   3221                                                  void *p_vrfy,
   3222                                                  mbedtls_x509_crt_restart_ctx *rs_ctx)
   3223          {
   \                     mbedtls_x509_crt_verify_restartable: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   3224              return x509_crt_verify_restartable_ca_cb(crt, trust_ca, ca_crl,
   3225                                                       NULL, NULL,
   3226                                                       profile, cn, flags,
   3227                                                       f_vrfy, p_vrfy, rs_ctx);
   \        0x4   0x9C10             LDR      R4,[SP, #+64]
   \        0x6   0x9D0F             LDR      R5,[SP, #+60]
   \        0x8   0x9301             STR      R3,[SP, #+4]
   \        0xA   0x9406             STR      R4,[SP, #+24]
   \        0xC   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0x10                      REQUIRE ?Subroutine2
   \       0x10                      ;; // Fall through to label ?Subroutine2
   3228          }
   3229          
   3230          
   3231          /*
   3232           * Initialize a certificate chain
   3233           */

   \                                 In section .text, align 2, keep-with-next
   3234          void mbedtls_x509_crt_init(mbedtls_x509_crt *crt)
   3235          {
   3236              memset(crt, 0, sizeof(mbedtls_x509_crt));
   \                     mbedtls_x509_crt_init: (+1)
   \        0x0   0xF44F 0x710B      MOV      R1,#+556
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4
   3237          }
   3238          
   3239          /*
   3240           * Unallocate all certificate data
   3241           */

   \                                 In section .text, align 2, keep-with-next
   3242          void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)
   3243          {
   \                     mbedtls_x509_crt_free: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   3244              mbedtls_x509_crt *cert_cur = crt;
   \        0x4   0x462C             MOV      R4,R5
   \        0x6   0xE02D             B.N      ??mbedtls_x509_crt_free_0
   3245              mbedtls_x509_crt *cert_prv;
   3246          
   3247              while (cert_cur != NULL) {
   3248                  mbedtls_pk_free(&cert_cur->pk);
   \                     ??mbedtls_x509_crt_free_1: (+1)
   \        0x8   0xF104 0x00CC      ADD      R0,R4,#+204
   \        0xC   0x.... 0x....      BL       mbedtls_pk_free
   3249          
   3250          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
   3251                  mbedtls_free(cert_cur->sig_opts);
   3252          #endif
   3253          
   3254                  mbedtls_asn1_free_named_data_list_shallow(cert_cur->issuer.next);
   \       0x10   0x6EA0             LDR      R0,[R4, #+104]
   \       0x12   0xF504 0x76CE      ADD      R6,R4,#+412
   \       0x16   0x.... 0x....      BL       mbedtls_asn1_free_named_data_list_shallow
   3255                  mbedtls_asn1_free_named_data_list_shallow(cert_cur->subject.next);
   \       0x1A   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \       0x1E   0x.... 0x....      BL       mbedtls_asn1_free_named_data_list_shallow
   3256                  mbedtls_asn1_sequence_free(cert_cur->ext_key_usage.next);
   \       0x22   0x6F30             LDR      R0,[R6, #+112]
   \       0x24   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3257                  mbedtls_asn1_sequence_free(cert_cur->subject_alt_names.next);
   \       0x28   0x6830             LDR      R0,[R6, #+0]
   \       0x2A   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3258                  mbedtls_asn1_sequence_free(cert_cur->certificate_policies.next);
   \       0x2E   0x6D30             LDR      R0,[R6, #+80]
   \       0x30   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3259                  mbedtls_asn1_sequence_free(cert_cur->authority_key_id.authorityCertIssuer.next);
   \       0x34   0x6AB0             LDR      R0,[R6, #+40]
   \       0x36   0x.... 0x....      BL       mbedtls_asn1_sequence_free
   3260          
   3261                  if (cert_cur->raw.p != NULL && cert_cur->own_buffer) {
   \       0x3A   0x68E0             LDR      R0,[R4, #+12]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xBF1F             ITTTT    NE
   \       0x40   0x6821             LDRNE    R1,[R4, #+0]
   \       0x42   0x2900             CMPNE    R1,#+0
   3262                      mbedtls_zeroize_and_free(cert_cur->raw.p, cert_cur->raw.len);
   \       0x44   0x68A1             LDRNE    R1,[R4, #+8]
   \       0x46   0x.... 0x....      BLNE     mbedtls_zeroize_and_free
   3263                  }
   3264          
   3265                  cert_prv = cert_cur;
   \       0x4A   0x4626             MOV      R6,R4
   3266                  cert_cur = cert_cur->next;
   \       0x4C   0xF8D4 0x4228      LDR      R4,[R4, #+552]
   3267          
   3268                  mbedtls_platform_zeroize(cert_prv, sizeof(mbedtls_x509_crt));
   \       0x50   0xF44F 0x710B      MOV      R1,#+556
   \       0x54   0x4630             MOV      R0,R6
   \       0x56   0x.... 0x....      BL       mbedtls_platform_zeroize
   3269                  if (cert_prv != crt) {
   \       0x5A   0x42AE             CMP      R6,R5
   \       0x5C   0xBF1C             ITT      NE
   3270                      mbedtls_free(cert_prv);
   \       0x5E   0x4630             MOVNE    R0,R6
   \       0x60   0x.... 0x....      BLNE     sl_free
   3271                  }
   3272              }
   \                     ??mbedtls_x509_crt_free_0: (+1)
   \       0x64   0x2C00             CMP      R4,#+0
   \       0x66   0xD1CF             BNE.N    ??mbedtls_x509_crt_free_1
   3273          }
   \       0x68   0xBD70             POP      {R4-R6,PC}

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x54 0x68          DC8 "The certificate validity has expired"
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x69    
   \              0x74 0x79    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x20 0x65    
   \              0x78 0x70    
   \              0x69 0x72    
   \              0x65 0x64    
   \              0x00
   \       0x25                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x54 0x68          DC8 "The certificate has been revoked (is on a CRL)"
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x68 0x61    
   \              0x73 0x20    
   \              0x62 0x65    
   \              0x65 0x6E    
   \              0x20 0x72    
   \              0x65 0x76    
   \              0x6F 0x6B    
   \              0x65 0x64    
   \              0x20 0x28    
   \              0x69 0x73    
   \              0x20 0x6F    
   \              0x6E 0x20    
   \              0x61 0x20    
   \              0x43 0x52    
   \              0x4C 0x29    
   \              0x00
   \       0x2F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x43 0x6F          DC8 0x43, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 0x4E
   \              0x6D 0x6D    
   \              0x6F 0x6E    
   \              0x20 0x4E
   \       0x18   0x61 0x6D          DC8 0x61, 0x6D, 0x65, 0x20, 0x28, 0x43, 0x4E, 0x29
   \              0x65 0x20    
   \              0x28 0x43    
   \              0x4E 0x29
   \       0x20   0x20 0x64          DC8 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F
   \              0x6F 0x65    
   \              0x73 0x20    
   \              0x6E 0x6F
   \       0x28   0x74 0x20          DC8 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x20
   \       0x30   0x77 0x69          DC8 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65
   \              0x74 0x68    
   \              0x20 0x74    
   \              0x68 0x65
   \       0x38   0x20 0x65          DC8 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65
   \       0x40   0x64 0x20          DC8 0x64, 0x20, 0x43, 0x4E, 0
   \              0x43 0x4E    
   \              0x00
   \       0x45                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x63
   \       0x18   0x6F 0x72          DC8 0x6F, 0x72, 0x72, 0x65, 0x63, 0x74, 0x6C, 0x79
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6C 0x79
   \       0x20   0x20 0x73          DC8 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20
   \       0x28   0x62 0x79          DC8 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x74
   \       0x30   0x72 0x75          DC8 0x72, 0x75, 0x73, 0x74, 0x65, 0x64, 0x20, 0x43
   \              0x73 0x74    
   \              0x65 0x64    
   \              0x20 0x43
   \       0x38   0x41 0x00          DC8 0x41, 0
   \       0x3A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x54 0x68          DC8 "The CRL is not correctly signed by the trusted CA"
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x63    
   \              0x6F 0x72    
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6C 0x79    
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x74    
   \              0x72 0x75    
   \              0x73 0x74    
   \              0x65 0x64    
   \              0x20 0x43    
   \              0x41 0x00
   \       0x32                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x54 0x68          DC8 "The CRL is expired"
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x65    
   \              0x78 0x70    
   \              0x69 0x72    
   \              0x65 0x64    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x43 0x65          DC8 "Certificate was missing"
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x77 0x61    
   \              0x73 0x20    
   \              0x6D 0x69    
   \              0x73 0x73    
   \              0x69 0x6E    
   \              0x67 0x00

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x43 0x65          DC8 "Certificate verification was skipped"
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x76 0x65    
   \              0x72 0x69    
   \              0x66 0x69    
   \              0x63 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x77    
   \              0x61 0x73    
   \              0x20 0x73    
   \              0x6B 0x69    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x00
   \       0x25                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x4F 0x74          DC8 "Other reason (can be used by verify callback)"
   \              0x68 0x65    
   \              0x72 0x20    
   \              0x72 0x65    
   \              0x61 0x73    
   \              0x6F 0x6E    
   \              0x20 0x28    
   \              0x63 0x61    
   \              0x6E 0x20    
   \              0x62 0x65    
   \              0x20 0x75    
   \              0x73 0x65    
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x76    
   \              0x65 0x72    
   \              0x69 0x66    
   \              0x79 0x20    
   \              0x63 0x61    
   \              0x6C 0x6C    
   \              0x62 0x61    
   \              0x63 0x6B    
   \              0x29 0x00
   \       0x2E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x54 0x68          DC8 "The certificate validity starts in the future"
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x69 0x66    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x69    
   \              0x74 0x79    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x73 0x20    
   \              0x69 0x6E    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x66    
   \              0x75 0x74    
   \              0x75 0x72    
   \              0x65 0x00
   \       0x2E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x54 0x68          DC8 "The CRL is from the future"
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x74 0x68    
   \              0x65 0x20    
   \              0x66 0x75    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x00
   \       0x1B                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \        0x0   0x55 0x1D          DC8 0x55, 0x1D, 0x20, 0, 0
   \              0x20 0x00    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \        0x0   0xFFFF'CF00        DC32     0xffffcf00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \        0x0   0xFFFF'D800        DC32     0xffffd800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \        0x0   0xFFFF'D780        DC32     0xffffd780

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \        0x0   0x2D 0x2D          DC8 "-----BEGIN CERTIFICATE-----"
   \              0x2D 0x2D    
   \              0x2D 0x42    
   \              0x45 0x47    
   \              0x49 0x4E    
   \              0x20 0x43    
   \              0x45 0x52    
   \              0x54 0x49    
   \              0x46 0x49    
   \              0x43 0x41    
   \              0x54 0x45    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \        0x0   0x2D 0x2D          DC8 "-----END CERTIFICATE-----"
   \              0x2D 0x2D    
   \              0x2D 0x45    
   \              0x4E 0x44    
   \              0x20 0x43    
   \              0x45 0x52    
   \              0x54 0x49    
   \              0x46 0x49    
   \              0x43 0x41    
   \              0x54 0x45    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00
   \       0x1A                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0xFFFF'DE80        DC32     0xffffde80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \        0x0   0xFFFF'DA80        DC32     0xffffda80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \        0x0   0xFFFF'DD9A        DC32     0xffffdd9a

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x55 0x73          DC8 "Usage does not match the keyUsage extension"
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x6F    
   \              0x65 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6D    
   \              0x61 0x74    
   \              0x63 0x68    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x55 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x65 0x78    
   \              0x74 0x65    
   \              0x6E 0x73    
   \              0x69 0x6F    
   \              0x6E 0x00

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x55 0x73          DC8 0x55, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x6F
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x6F
   \        0x8   0x65 0x73          DC8 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6D
   \       0x10   0x61 0x74          DC8 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65
   \              0x63 0x68    
   \              0x20 0x74    
   \              0x68 0x65
   \       0x18   0x20 0x65          DC8 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64, 0x65
   \              0x78 0x74    
   \              0x65 0x6E    
   \              0x64 0x65
   \       0x20   0x64 0x4B          DC8 0x64, 0x4B, 0x65, 0x79, 0x55, 0x73, 0x61, 0x67
   \              0x65 0x79    
   \              0x55 0x73    
   \              0x61 0x67
   \       0x28   0x65 0x20          DC8 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73
   \              0x65 0x78    
   \              0x74 0x65    
   \              0x6E 0x73
   \       0x30   0x69 0x6F          DC8 0x69, 0x6F, 0x6E, 0
   \              0x6E 0x00

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x55 0x73          DC8 "Usage does not match the nsCertType extension"
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x6F    
   \              0x65 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6D    
   \              0x61 0x74    
   \              0x63 0x68    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6E    
   \              0x73 0x43    
   \              0x65 0x72    
   \              0x74 0x54    
   \              0x79 0x70    
   \              0x65 0x20    
   \              0x65 0x78    
   \              0x74 0x65    
   \              0x6E 0x73    
   \              0x69 0x6F    
   \              0x6E 0x00
   \       0x2E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x18   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x20   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x28   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x68
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x68
   \       0x30   0x61 0x73          DC8 0x61, 0x73, 0x68, 0x2E, 0
   \              0x68 0x2E    
   \              0x00
   \       0x35                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x18   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x20   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x28   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x50
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x50
   \       0x30   0x4B 0x20          DC8 0x4B, 0x20, 0x61, 0x6C, 0x67, 0x20, 0x28, 0x65
   \              0x61 0x6C    
   \              0x67 0x20    
   \              0x28 0x65
   \       0x38   0x67 0x20          DC8 0x67, 0x20, 0x52, 0x53, 0x41, 0x20, 0x76, 0x73
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x76 0x73
   \       0x40   0x20 0x45          DC8 0x20, 0x45, 0x43, 0x44, 0x53, 0x41, 0x29, 0x2E
   \              0x43 0x44    
   \              0x53 0x41    
   \              0x29 0x2E
   \       0x48   0x00               DC8 0
   \       0x49                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74
   \              0x65 0x20    
   \              0x63 0x65    
   \              0x72 0x74
   \        0x8   0x69 0x66          DC8 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x65 0x20
   \       0x10   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x18   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x20   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x28   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6B
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x6B
   \       0x30   0x65 0x79          DC8 0x65, 0x79, 0x20, 0x28, 0x65, 0x67, 0x20, 0x62
   \              0x20 0x28    
   \              0x65 0x67    
   \              0x20 0x62
   \       0x38   0x61 0x64          DC8 0x61, 0x64, 0x20, 0x63, 0x75, 0x72, 0x76, 0x65
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x76 0x65
   \       0x40   0x2C 0x20          DC8 0x2C, 0x20, 0x52, 0x53, 0x41, 0x20, 0x74, 0x6F
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x74 0x6F
   \       0x48   0x6F 0x20          DC8 0x6F, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x29
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x29
   \       0x50   0x2E 0x00          DC8 0x2E, 0
   \       0x52                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x54 0x68          DC8 "The CRL is signed with an unacceptable hash."
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20    
   \              0x69 0x73    
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61    
   \              0x6E 0x20    
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65    
   \              0x70 0x74    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x68 0x2E    
   \              0x00
   \       0x2D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x43, 0x52, 0x4C, 0x20
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20
   \        0x8   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x10   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x18   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x20   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x50
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x50
   \       0x28   0x4B 0x20          DC8 0x4B, 0x20, 0x61, 0x6C, 0x67, 0x20, 0x28, 0x65
   \              0x61 0x6C    
   \              0x67 0x20    
   \              0x28 0x65
   \       0x30   0x67 0x20          DC8 0x67, 0x20, 0x52, 0x53, 0x41, 0x20, 0x76, 0x73
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x76 0x73
   \       0x38   0x20 0x45          DC8 0x20, 0x45, 0x43, 0x44, 0x53, 0x41, 0x29, 0x2E
   \              0x43 0x44    
   \              0x53 0x41    
   \              0x29 0x2E
   \       0x40   0x00               DC8 0
   \       0x41                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x54 0x68          DC8 0x54, 0x68, 0x65, 0x20, 0x43, 0x52, 0x4C, 0x20
   \              0x65 0x20    
   \              0x43 0x52    
   \              0x4C 0x20
   \        0x8   0x69 0x73          DC8 0x69, 0x73, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65
   \              0x20 0x73    
   \              0x69 0x67    
   \              0x6E 0x65
   \       0x10   0x64 0x20          DC8 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61
   \              0x77 0x69    
   \              0x74 0x68    
   \              0x20 0x61
   \       0x18   0x6E 0x20          DC8 0x6E, 0x20, 0x75, 0x6E, 0x61, 0x63, 0x63, 0x65
   \              0x75 0x6E    
   \              0x61 0x63    
   \              0x63 0x65
   \       0x20   0x70 0x74          DC8 0x70, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6B
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x6B
   \       0x28   0x65 0x79          DC8 0x65, 0x79, 0x20, 0x28, 0x65, 0x67, 0x20, 0x62
   \              0x20 0x28    
   \              0x65 0x67    
   \              0x20 0x62
   \       0x30   0x61 0x64          DC8 0x61, 0x64, 0x20, 0x63, 0x75, 0x72, 0x76, 0x65
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x76 0x65
   \       0x38   0x2C 0x20          DC8 0x2C, 0x20, 0x52, 0x53, 0x41, 0x20, 0x74, 0x6F
   \              0x52 0x53    
   \              0x41 0x20    
   \              0x74 0x6F
   \       0x40   0x6F 0x20          DC8 0x6F, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x29
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x29
   \       0x48   0x2E 0x00          DC8 0x2E, 0
   \       0x4A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x0A 0x25          DC8 0x0A, 0x25, 0x73, 0x69, 0x73, 0x73, 0x75, 0x65
   \              0x73 0x69    
   \              0x73 0x73    
   \              0x75 0x65
   \        0x8   0x64 0x20          DC8 0x64, 0x20, 0x20, 0x6F, 0x6E, 0x20, 0x20, 0x20
   \              0x20 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20
   \       0x10   0x20 0x20          DC8 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x25
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x25
   \       0x18   0x30 0x34          DC8 0x30, 0x34, 0x64, 0x2D, 0x25, 0x30, 0x32, 0x64
   \              0x64 0x2D    
   \              0x25 0x30    
   \              0x32 0x64
   \       0x20   0x2D 0x25          DC8 0x2D, 0x25, 0x30, 0x32, 0x64, 0x20, 0x25, 0x30
   \              0x30 0x32    
   \              0x64 0x20    
   \              0x25 0x30
   \       0x28   0x32 0x64          DC8 0x32, 0x64, 0x3A, 0x25, 0x30, 0x32, 0x64, 0x3A
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x64 0x3A
   \       0x30   0x25 0x30          DC8 0x25, 0x30, 0x32, 0x64, 0
   \              0x32 0x64    
   \              0x00
   \       0x35                      DS8 3
   \       0x38   0x0A 0x25          DC8 0x0A, 0x25, 0x73, 0x65, 0x78, 0x70, 0x69, 0x72
   \              0x73 0x65    
   \              0x78 0x70    
   \              0x69 0x72
   \       0x40   0x65 0x73          DC8 0x65, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x20, 0x20
   \              0x20 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20
   \       0x48   0x20 0x20          DC8 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x25
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x25
   \       0x50   0x30 0x34          DC8 0x30, 0x34, 0x64, 0x2D, 0x25, 0x30, 0x32, 0x64
   \              0x64 0x2D    
   \              0x25 0x30    
   \              0x32 0x64
   \       0x58   0x2D 0x25          DC8 0x2D, 0x25, 0x30, 0x32, 0x64, 0x20, 0x25, 0x30
   \              0x30 0x32    
   \              0x64 0x20    
   \              0x25 0x30
   \       0x60   0x32 0x64          DC8 0x32, 0x64, 0x3A, 0x25, 0x30, 0x32, 0x64, 0x3A
   \              0x3A 0x25    
   \              0x30 0x32    
   \              0x64 0x3A
   \       0x68   0x25 0x30          DC8 0x25, 0x30, 0x32, 0x64, 0
   \              0x32 0x64    
   \              0x00
   \       0x6D                      DS8 3

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_27:
   \        0x0   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_28:
   \        0x0   0x3F 0x3F          DC8 "???"
   \              0x3F 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_30:
   \        0x0   0x2C 0x20          DC8 ", "
   \              0x00
   \        0x3                      DS8 1

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_47:
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_50:
   \        0x0   0x55 0x04          DC8 "U\004\003"
   \              0x03 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \        0x0   0x0A 0x43          DC8 "\012Certificate is uninitialised!\012"
   \              0x65 0x72    
   \              0x74 0x69    
   \              0x66 0x69    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x75 0x6E    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x73 0x65    
   \              0x64 0x21    
   \              0x0A 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \        0x0   0x25 0x73          DC8 "%scert. version     : %d\012"
   \              0x63 0x65    
   \              0x72 0x74    
   \              0x2E 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x0A 0x00
   \       0x1A                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \        0x0   0x25 0x73          DC8 "%sserial number     : "
   \              0x73 0x65    
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x6E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \        0x0   0x0A 0x25          DC8 "\012%sissuer name       : "
   \              0x73 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x72 0x20    
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \        0x0   0x0A 0x25          DC8 "\012%ssubject name      : "
   \              0x73 0x73    
   \              0x75 0x62    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x20 0x6E    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0 
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \        0x0   0xFFFF'DB9A        DC32     0xffffdb9a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \        0x0   0x2C 0x20          DC8      0x2C, 0x20, 0x00, 0x00
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \        0x0   0x3F 0x3F          DC8      "???"          
   \              0x3F 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \        0x0   0xFFFF'DB00        DC32     0xffffdb00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0   
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \        0x0   0xFFFF'DA9E        DC32     0xffffda9e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \        0x0   0xFFFF'DF80        DC32     0xffffdf80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \        0x0   0xFFFF'DA96        DC32     0xffffda96

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \        0x0   0xFFFF'DA9A        DC32     0xffffda9a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0 
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \        0x0   0xFFFF'DA9C        DC32     0xffffda9c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \        0x0   0xFFFF'DE1A        DC32     0xffffde1a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \        0x0   0xFFFF'D980        DC32     0xffffd980

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \        0x0   0xFFFF'D880        DC32     0xffffd880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \        0x0   0xFFFF'D680        DC32     0xffffd680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_2:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_3:
   \        0x0   0xFFFF'7FFE        DC32     0xffff7ffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_4:
   \        0x0   0xFFFF'D800        DC32     0xffffd800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_5:
   \        0x0   0xFFFF'D000        DC32     0xffffd000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_6:
   \        0x0   0xFFFF'D900        DC32     0xffffd900

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \        0x0   0x25 0x73          DC8 "%s%s"
   \              0x25 0x73    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \        0x0   0x0A 0x25          DC8 "\012%ssigned using      : "
   \              0x73 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x75 0x73    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_37:
   \        0x0   0x0A 0x25          DC8 "\012%s%-18s: %d bits"
   \              0x73 0x25    
   \              0x2D 0x31    
   \              0x38 0x73    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x20 0x62    
   \              0x69 0x74    
   \              0x73 0x00
   \       0x12                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \        0x0   0x0A 0x25          DC8 "\012%sbasic constraints : CA=%s"
   \              0x73 0x62    
   \              0x61 0x73    
   \              0x69 0x63    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x73 0x74    
   \              0x72 0x61    
   \              0x69 0x6E    
   \              0x74 0x73    
   \              0x20 0x3A    
   \              0x20 0x43    
   \              0x41 0x3D    
   \              0x25 0x73    
   \              0x00
   \       0x1D                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_39:
   \        0x0   0x74 0x72          DC8 "true"
   \              0x75 0x65    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_40:
   \        0x0   0x66 0x61          DC8 "false"
   \              0x6C 0x73    
   \              0x65 0x00
   \        0x6                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_41:
   \        0x0   0x2C 0x20          DC8 ", max_pathlen=%d"
   \              0x6D 0x61    
   \              0x78 0x5F    
   \              0x70 0x61    
   \              0x74 0x68    
   \              0x6C 0x65    
   \              0x6E 0x3D    
   \              0x25 0x64    
   \              0x00
   \       0x11                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_42:
   \        0x0   0x0A 0x25          DC8 "\012%ssubject alt name  :"
   \              0x73 0x73    
   \              0x75 0x62    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x20 0x61    
   \              0x6C 0x74    
   \              0x20 0x6E    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x20 0x3A    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_43:
   \        0x0   0x0A 0x25          DC8 "\012%scert. type        : "
   \              0x73 0x63    
   \              0x65 0x72    
   \              0x74 0x2E    
   \              0x20 0x74    
   \              0x79 0x70    
   \              0x65 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_44:
   \        0x0   0x0A 0x25          DC8 "\012%skey usage         : "
   \              0x73 0x6B    
   \              0x65 0x79    
   \              0x20 0x75    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_45:
   \        0x0   0x0A 0x25          DC8 "\012%sext key usage     : "
   \              0x73 0x65    
   \              0x78 0x74    
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x20 0x75    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_46:
   \        0x0   0x0A 0x25          DC8 "\012%scertificate policies : "
   \              0x73 0x63    
   \              0x65 0x72    
   \              0x74 0x69    
   \              0x66 0x69    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x20 0x70    
   \              0x6F 0x6C    
   \              0x69 0x63    
   \              0x69 0x65    
   \              0x73 0x20    
   \              0x3A 0x20    
   \              0x00
   \       0x1B                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_48:
   \        0x0   0x25 0x73          DC8 "%s%s\012"
   \              0x25 0x73    
   \              0x0A 0x00
   \        0x6                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_49:
   \        0x0   0x55 0x1D          DC8 0x55, 0x1D, 0x25, 0, 0
   \              0x25 0x00    
   \              0x00
   \        0x5                      DS8 3
   3274          
   3275          #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
   3276          /*
   3277           * Initialize a restart context
   3278           */
   3279          void mbedtls_x509_crt_restart_init(mbedtls_x509_crt_restart_ctx *ctx)
   3280          {
   3281              mbedtls_pk_restart_init(&ctx->pk);
   3282          
   3283              ctx->parent = NULL;
   3284              ctx->fallback_parent = NULL;
   3285              ctx->fallback_signature_is_good = 0;
   3286          
   3287              ctx->parent_is_trusted = -1;
   3288          
   3289              ctx->in_progress = x509_crt_rs_none;
   3290              ctx->self_cnt = 0;
   3291              x509_crt_verify_chain_reset(&ctx->ver_chain);
   3292          }
   3293          
   3294          /*
   3295           * Free the components of a restart context
   3296           */
   3297          void mbedtls_x509_crt_restart_free(mbedtls_x509_crt_restart_ctx *ctx)
   3298          {
   3299              if (ctx == NULL) {
   3300                  return;
   3301              }
   3302          
   3303              mbedtls_pk_restart_free(&ctx->pk);
   3304              mbedtls_x509_crt_restart_init(ctx);
   3305          }
   3306          #endif /* MBEDTLS_ECDSA_C && MBEDTLS_ECP_RESTARTABLE */
   3307          
   3308          #endif /* MBEDTLS_X509_CRT_PARSE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_md_psa_alg_from_type
       4   mbedtls_put_unaligned_uint16
      24   mbedtls_x509_crt_check_extended_key_usage
        24   -> memcmp
       8   mbedtls_x509_crt_check_key_usage
      16   mbedtls_x509_crt_free
        16   -> mbedtls_asn1_free_named_data_list_shallow
        16   -> mbedtls_asn1_sequence_free
        16   -> mbedtls_pk_free
        16   -> mbedtls_platform_zeroize
        16   -> mbedtls_zeroize_and_free
        16   -> sl_free
      88   mbedtls_x509_crt_info
        88   -> mbedtls_oid_get_certificate_policies
        88   -> mbedtls_oid_get_extended_key_usage
        88   -> mbedtls_pk_get_bitlen
        88   -> mbedtls_pk_get_name
        88   -> mbedtls_x509_dn_gets
        88   -> mbedtls_x509_info_cert_type
        88   -> mbedtls_x509_info_key_usage
        88   -> mbedtls_x509_info_subject_alt_name
        88   -> mbedtls_x509_key_size_helper
        88   -> mbedtls_x509_serial_gets
        88   -> mbedtls_x509_sig_alg_gets
        88   -> snprintf
       0   mbedtls_x509_crt_init
         0   -> __aeabi_memclr4
      16   mbedtls_x509_crt_is_revoked
        16   -> memcmp
      72   mbedtls_x509_crt_parse
        72   -> mbedtls_pem_free
        72   -> mbedtls_pem_init
        72   -> mbedtls_pem_read_buffer
        72   -> mbedtls_x509_crt_parse_der
        72   -> strstr
      40   mbedtls_x509_crt_parse_cn_inet_pton
        40   -> __aeabi_memclr
        40   -> __aeabi_memcpy
        40   -> __aeabi_memmove
        40   -> mbedtls_put_unaligned_uint16
        40   -> strchr
        40   -> x509_inet_pton_ipv4
      16   mbedtls_x509_crt_parse_der
        16   -> mbedtls_x509_crt_parse_der_internal
     144   mbedtls_x509_crt_parse_der_internal
       144   -- Indirect call
       144   -> __aeabi_memcpy
       144   -> mbedtls_asn1_get_bool
       144   -> mbedtls_asn1_get_int
       144   -> mbedtls_asn1_get_sequence_of
       144   -> mbedtls_asn1_get_tag
       144   -> mbedtls_oid_get_x509_ext_type
       144   -> mbedtls_pk_parse_subpubkey
       144   -> mbedtls_x509_crt_free
       144   -> mbedtls_x509_crt_init
       144   -> mbedtls_x509_get_alg
       144   -> mbedtls_x509_get_ext
       144   -> mbedtls_x509_get_key_usage
       144   -> mbedtls_x509_get_name
       144   -> mbedtls_x509_get_ns_cert_type
       144   -> mbedtls_x509_get_serial
       144   -> mbedtls_x509_get_sig
       144   -> mbedtls_x509_get_sig_alg
       144   -> mbedtls_x509_get_subject_alt_name
       144   -> mbedtls_x509_get_subject_alt_name_ext
       144   -> mbedtls_x509_get_time
       144   -> memcmp
       144   -> sl_calloc
       144   -> sl_free
       144   -> x509_get_uid
      16   mbedtls_x509_crt_parse_der_nocopy
        16   -> mbedtls_x509_crt_parse_der_internal
      24   mbedtls_x509_crt_parse_der_with_ext_cb
        24   -> mbedtls_x509_crt_parse_der_internal
      48   mbedtls_x509_crt_verify
        48   -> x509_crt_verify_restartable_ca_cb
      40   mbedtls_x509_crt_verify_info
        40   -> snprintf
      48   mbedtls_x509_crt_verify_restartable
        48   -> x509_crt_verify_restartable_ca_cb
      48   mbedtls_x509_crt_verify_with_profile
        48   -> x509_crt_verify_restartable_ca_cb
      16   x509_crt_check_cn
        16   -> strlen
        16   -> x509_memcasecmp
     192   x509_crt_verify_restartable_ca_cb
       192   -- Indirect call
       192   -> mbedtls_md_psa_alg_from_type
       192   -> mbedtls_pk_can_do
       192   -> mbedtls_pk_get_type
       192   -> mbedtls_pk_verify_ext
       192   -> mbedtls_x509_crt_check_key_usage
       192   -> mbedtls_x509_crt_is_revoked
       192   -> mbedtls_x509_crt_parse_cn_inet_pton
       192   -> memcmp
       192   -> psa_hash_compute
       192   -> strlen
       192   -> x509_crt_check_cn
       192   -> x509_name_cmp
       192   -> x509_profile_check_key
       192   -> x509_profile_check_md_alg
       192   -> x509_profile_check_pk_alg
      16   x509_get_uid
        16   -> mbedtls_asn1_get_tag
      20   x509_inet_pton_ipv4
      12   x509_memcasecmp
      24   x509_name_cmp
        24   -> memcmp
        24   -> x509_memcasecmp
     176   x509_profile_check_key
       176   -> __aeabi_memclr4
       176   -> __aeabi_memcpy4
       176   -> mbedtls_ecc_group_of_psa
       176   -> mbedtls_pk_get_type
       176   -> psa_get_key_attributes
       176   -> psa_reset_key_attributes
       0   x509_profile_check_md_alg
       0   x509_profile_check_pk_alg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_2
       4  ??DataTable39_3
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
      10  ??Subroutine17_0
       6  ?Subroutine0
       6  ?Subroutine1
      14  ?Subroutine10
      16  ?Subroutine11
      10  ?Subroutine12
      12  ?Subroutine13
       8  ?Subroutine14
      12  ?Subroutine15
      12  ?Subroutine16
       8  ?Subroutine2
      12  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
       6  ?Subroutine6
       8  ?Subroutine7
      18  ?Subroutine8
      10  ?Subroutine9
      40  ?_0
      48  ?_1
      28  ?_10
      44  ?_11
      52  ?_12
      48  ?_13
      56  ?_14
      76  ?_15
      84  ?_16
      48  ?_17
      68  ?_18
      76  ?_19
      72  ?_2
     112  ?_20
      36  ?_23
       8  ?_24
      28  ?_25
      28  ?_26
       1  ?_27
       4  ?_28
       8  ?_29
      60  ?_3
       4  ?_30
      32  ?_31
      28  ?_32
      24  ?_33
      24  ?_34
      24  ?_35
      24  ?_36
      20  ?_37
      32  ?_38
       8  ?_39
      52  ?_4
       8  ?_40
      20  ?_41
      24  ?_42
      24  ?_43
      24  ?_44
      24  ?_45
      28  ?_46
       2  ?_47
       8  ?_48
       8  ?_49
      20  ?_5
       4  ?_50
      12  ?_51
      24  ?_6
      40  ?_7
      48  ?_8
      48  ?_9
       2  mbedtls_byte_order_detector
       6  mbedtls_md_psa_alg_from_type
      18  mbedtls_put_unaligned_uint16
      78  mbedtls_x509_crt_check_extended_key_usage
      50  mbedtls_x509_crt_check_key_usage
     106  mbedtls_x509_crt_free
     980  mbedtls_x509_crt_info
       8  mbedtls_x509_crt_init
      44  mbedtls_x509_crt_is_revoked
     212  mbedtls_x509_crt_parse
     308  mbedtls_x509_crt_parse_cn_inet_pton
      10  mbedtls_x509_crt_parse_der
   1'814  mbedtls_x509_crt_parse_der_internal
      12  mbedtls_x509_crt_parse_der_nocopy
      16  mbedtls_x509_crt_parse_der_with_ext_cb
      16  mbedtls_x509_crt_profile_default
      16  mbedtls_x509_crt_profile_next
      16  mbedtls_x509_crt_profile_none
      16  mbedtls_x509_crt_profile_suiteb
      32  mbedtls_x509_crt_verify
     108  mbedtls_x509_crt_verify_info
      16  mbedtls_x509_crt_verify_restartable
      18  mbedtls_x509_crt_verify_with_profile
      94  x509_crt_check_cn
   1'060  x509_crt_verify_restartable_ca_cb
     212  x509_crt_verify_strings
      58  x509_get_uid
      96  x509_inet_pton_ipv4
      48  x509_memcasecmp
     122  x509_name_cmp
     142  x509_profile_check_key
      20  x509_profile_check_md_alg
      18  x509_profile_check_pk_alg

 
 1'467 bytes in section .rodata
 6'268 bytes in section .text
 
 6'250 bytes of CODE  memory (+ 18 bytes shared)
 1'467 bytes of CONST memory

Errors: none
Warnings: none
