###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:20
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\asn1parse.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\asn1parse.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\asn1parse.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\asn1parse.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\asn1parse.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\asn1parse.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\asn1parse.c
      1          /*
      2           *  Generic ASN.1 parsing
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          #include "common.h"
     21          
     22          #if defined(MBEDTLS_ASN1_PARSE_C) || defined(MBEDTLS_X509_CREATE_C)
     23          
     24          #include "mbedtls/asn1.h"
     25          #include "mbedtls/platform_util.h"
     26          #include "mbedtls/error.h"
     27          
     28          #include <string.h>
     29          
     30          #if defined(MBEDTLS_BIGNUM_C)
     31          #include "mbedtls/bignum.h"
     32          #endif
     33          
     34          #include "mbedtls/platform.h"
     35          
     36          /*
     37           * ASN.1 DER decoding routines
     38           */

   \                                 In section .text, align 2, keep-with-next
     39          int mbedtls_asn1_get_len(unsigned char **p,
     40                                   const unsigned char *end,
     41                                   size_t *len)
     42          {
   \                     mbedtls_asn1_get_len: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4603             MOV      R3,R0
   \        0x4   0x460D             MOV      R5,R1
     43              if ((end - *p) < 1) {
   \        0x6   0x6819             LDR      R1,[R3, #+0]
   \        0x8   0xF06F 0x005F      MVN      R0,#+95
   \        0xC   0x1A6F             SUBS     R7,R5,R1
   \        0xE   0x2F00             CMP      R7,#+0
   \       0x10   0xDD25             BLE.N    ??mbedtls_asn1_get_len_0
     44                  return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
     45              }
     46          
     47              if ((**p & 0x80) == 0) {
   \       0x12   0x780C             LDRB     R4,[R1, #+0]
   \       0x14   0x0626             LSLS     R6,R4,#+24
   \       0x16   0xD403             BMI.N    ??mbedtls_asn1_get_len_1
     48                  *len = *(*p)++;
   \       0x18   0x1C4E             ADDS     R6,R1,#+1
   \       0x1A   0x601E             STR      R6,[R3, #+0]
   \       0x1C   0x780F             LDRB     R7,[R1, #+0]
   \       0x1E   0xE017             B.N      ??mbedtls_asn1_get_len_2
     49              } else {
     50                  int n = (**p) & 0x7F;
   \                     ??mbedtls_asn1_get_len_1: (+1)
   \       0x20   0xF014 0x047F      ANDS     R4,R4,#0x7F
     51                  if (n == 0 || n > 4) {
   \       0x24   0xD001             BEQ.N    ??mbedtls_asn1_get_len_3
   \       0x26   0x2C05             CMP      R4,#+5
   \       0x28   0xDB02             BLT.N    ??mbedtls_asn1_get_len_4
     52                      return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
   \                     ??mbedtls_asn1_get_len_3: (+1)
   \       0x2A   0xF06F 0x0063      MVN      R0,#+99
   \       0x2E   0xBDF0             POP      {R4-R7,PC}
     53                  }
     54                  if ((end - *p) <= n) {
   \                     ??mbedtls_asn1_get_len_4: (+1)
   \       0x30   0x42BC             CMP      R4,R7
   \       0x32   0xDA14             BGE.N    ??mbedtls_asn1_get_len_0
     55                      return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
     56                  }
     57                  *len = 0;
   \       0x34   0x2700             MOVS     R7,#+0
     58                  (*p)++;
   \       0x36   0x1C4E             ADDS     R6,R1,#+1
   \       0x38   0xE006             B.N      ??mbedtls_asn1_get_len_5
     59                  while (n--) {
     60                      *len = (*len << 8) | **p;
   \                     ??mbedtls_asn1_get_len_6: (+1)
   \       0x3A   0x6017             STR      R7,[R2, #+0]
   \       0x3C   0x601E             STR      R6,[R3, #+0]
   \       0x3E   0x4639             MOV      R1,R7
   \       0x40   0xF816 0x7B01      LDRB     R7,[R6], #+1
   \       0x44   0xEA47 0x2701      ORR      R7,R7,R1, LSL #+8
     61                      (*p)++;
     62                  }
   \                     ??mbedtls_asn1_get_len_5: (+1)
   \       0x48   0x4621             MOV      R1,R4
   \       0x4A   0x1E4C             SUBS     R4,R1,#+1
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD1F4             BNE.N    ??mbedtls_asn1_get_len_6
   \                     ??mbedtls_asn1_get_len_2: (+1)
   \       0x50   0x601E             STR      R6,[R3, #+0]
   \       0x52   0x6017             STR      R7,[R2, #+0]
     63              }
     64          
     65              if (*len > (size_t) (end - *p)) {
   \       0x54   0x6819             LDR      R1,[R3, #+0]
   \       0x56   0x1A6D             SUBS     R5,R5,R1
   \       0x58   0x42BD             CMP      R5,R7
   \       0x5A   0xBF28             IT       CS
   \       0x5C   0x2000             MOVCS    R0,#+0
     66                  return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
     67              }
     68          
     69              return 0;
   \                     ??mbedtls_asn1_get_len_0: (+1)
   \       0x5E   0xBDF0             POP      {R4-R7,PC}
     70          }
     71          

   \                                 In section .text, align 2, keep-with-next
     72          int mbedtls_asn1_get_tag(unsigned char **p,
     73                                   const unsigned char *end,
     74                                   size_t *len, int tag)
     75          {
   \                     mbedtls_asn1_get_tag: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     76              if ((end - *p) < 1) {
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0x1B0D             SUBS     R5,R1,R4
   \        0x6   0x2D01             CMP      R5,#+1
   \        0x8   0xDA02             BGE.N    ??mbedtls_asn1_get_tag_0
     77                  return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
   \        0xA   0xF06F 0x005F      MVN      R0,#+95
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
     78              }
     79          
     80              if (**p != tag) {
   \                     ??mbedtls_asn1_get_tag_0: (+1)
   \       0x10   0x7825             LDRB     R5,[R4, #+0]
   \       0x12   0x429D             CMP      R5,R3
   \       0x14   0xD002             BEQ.N    ??mbedtls_asn1_get_tag_1
     81                  return MBEDTLS_ERR_ASN1_UNEXPECTED_TAG;
   \       0x16   0xF06F 0x0061      MVN      R0,#+97
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}
     82              }
     83          
     84              (*p)++;
   \                     ??mbedtls_asn1_get_tag_1: (+1)
   \       0x1C   0x1C63             ADDS     R3,R4,#+1
   \       0x1E   0x6003             STR      R3,[R0, #+0]
     85          
     86              return mbedtls_asn1_get_len(p, end, len);
   \       0x20   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x24   0x....             B.N      mbedtls_asn1_get_len
     87          }
     88          #endif /* MBEDTLS_ASN1_PARSE_C || MBEDTLS_X509_CREATE_C */
     89          
     90          #if defined(MBEDTLS_ASN1_PARSE_C)

   \                                 In section .text, align 2, keep-with-next
     91          int mbedtls_asn1_get_bool(unsigned char **p,
     92                                    const unsigned char *end,
     93                                    int *val)
     94          {
   \                     mbedtls_asn1_get_bool: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x4604             MOV      R4,R0
     95              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     96              size_t len;
     97          
     98              if ((ret = mbedtls_asn1_get_tag(p, end, &len, MBEDTLS_ASN1_BOOLEAN)) != 0) {
   \        0x6   0x2301             MOVS     R3,#+1
   \        0x8   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0xC   0xB958             CBNZ.N   R0,??mbedtls_asn1_get_bool_0
     99                  return ret;
    100              }
    101          
    102              if (len != 1) {
   \        0xE   0x9800             LDR      R0,[SP, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD000             BEQ.N    ??mbedtls_asn1_get_bool_1
    103                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
   \       0x14   0x....             B.N      ?Subroutine0
    104              }
    105          
    106              *val = (**p != 0) ? 1 : 0;
   \                     ??mbedtls_asn1_get_bool_1: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x7801             LDRB     R1,[R0, #+0]
   \       0x1A   0xB101             CBZ.N    R1,??mbedtls_asn1_get_bool_2
   \       0x1C   0x2101             MOVS     R1,#+1
   \                     ??mbedtls_asn1_get_bool_2: (+1)
   \       0x1E   0x6029             STR      R1,[R5, #+0]
    107              (*p)++;
   \       0x20   0x1C40             ADDS     R0,R0,#+1
   \       0x22   0x6020             STR      R0,[R4, #+0]
    108          
    109              return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_asn1_get_bool_0: (+1)
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    110          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x0063      MVN      R0,#+99
   \        0x4   0xBD32             POP      {R1,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2330             MOVS     R3,#+48
   \                     ??Subroutine1_0: (+1)
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0x....             B.N      mbedtls_asn1_get_tag
    111          

   \                                 In section .text, align 2, keep-with-next
    112          static int asn1_get_tagged_int(unsigned char **p,
    113                                         const unsigned char *end,
    114                                         int tag, int *val)
    115          {
   \                     asn1_get_tagged_int: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x461D             MOV      R5,R3
    116              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    117              size_t len;
    118          
    119              if ((ret = mbedtls_asn1_get_tag(p, end, &len, tag)) != 0) {
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xC   0xBB30             CBNZ.N   R0,??asn1_get_tagged_int_0
    120                  return ret;
    121              }
    122          
    123              /*
    124               * len==0 is malformed (0 must be represented as 020100 for INTEGER,
    125               * or 0A0100 for ENUMERATED tags
    126               */
    127              if (len == 0) {
   \        0xE   0x9800             LDR      R0,[SP, #+0]
   \       0x10   0xB1B0             CBZ.N    R0,??asn1_get_tagged_int_1
    128                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
    129              }
    130              /* This is a cryptography library. Reject negative integers. */
    131              if ((**p & 0x80) != 0) {
   \       0x12   0x6822             LDR      R2,[R4, #+0]
   \       0x14   0x7810             LDRB     R0,[R2, #+0]
   \       0x16   0x0601             LSLS     R1,R0,#+24
   \       0x18   0xD412             BMI.N    ??asn1_get_tagged_int_1
   \                     ??asn1_get_tagged_int_2: (+1)
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x7808             LDRB     R0,[R1, #+0]
   \       0x1E   0xB940             CBNZ.N   R0,??asn1_get_tagged_int_3
    132                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
    133              }
    134          
    135              /* Skip leading zeros. */
    136              while (len > 0 && **p == 0) {
    137                  ++(*p);
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x6021             STR      R1,[R4, #+0]
    138                  --len;
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0x9000             STR      R0,[SP, #+0]
    139              }
   \       0x2A   0xD1F6             BNE.N    ??asn1_get_tagged_int_2
    140          
    141              /* Reject integers that don't fit in an int. This code assumes that
    142               * the int type has no padding bit. */
    143              if (len > sizeof(int)) {
    144                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
    145              }
    146              if (len == sizeof(int) && (**p & 0x80) != 0) {
    147                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
    148              }
    149          
    150              *val = 0;
   \                     ??asn1_get_tagged_int_4: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6029             STR      R1,[R5, #+0]
   \       0x30   0xE00F             B.N      ??asn1_get_tagged_int_5
   \                     ??asn1_get_tagged_int_3: (+1)
   \       0x32   0x9800             LDR      R0,[SP, #+0]
   \       0x34   0x2804             CMP      R0,#+4
   \       0x36   0xD803             BHI.N    ??asn1_get_tagged_int_1
   \       0x38   0xD1F8             BNE.N    ??asn1_get_tagged_int_4
   \       0x3A   0x7809             LDRB     R1,[R1, #+0]
   \       0x3C   0x0608             LSLS     R0,R1,#+24
   \       0x3E   0xD5F5             BPL.N    ??asn1_get_tagged_int_4
   \                     ??asn1_get_tagged_int_1: (+1)
   \       0x40   0x....             B.N      ?Subroutine0
    151              while (len-- > 0) {
    152                  *val = (*val << 8) | **p;
   \                     ??asn1_get_tagged_int_6: (+1)
   \       0x42   0x6823             LDR      R3,[R4, #+0]
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0xF813 0x2B01      LDRB     R2,[R3], #+1
   \       0x4A   0xEA42 0x2200      ORR      R2,R2,R0, LSL #+8
   \       0x4E   0x602A             STR      R2,[R5, #+0]
    153                  (*p)++;
   \       0x50   0x6023             STR      R3,[R4, #+0]
    154              }
   \                     ??asn1_get_tagged_int_5: (+1)
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0x1E42             SUBS     R2,R0,#+1
   \       0x56   0x9200             STR      R2,[SP, #+0]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD1F2             BNE.N    ??asn1_get_tagged_int_6
   \                     ??asn1_get_tagged_int_0: (+1)
   \       0x5C   0xBD32             POP      {R1,R4,R5,PC}
    155          
    156              return 0;
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          int mbedtls_asn1_get_int(unsigned char **p,
    160                                   const unsigned char *end,
    161                                   int *val)
    162          {
   \                     mbedtls_asn1_get_int: (+1)
   \        0x0   0x4613             MOV      R3,R2
    163              return asn1_get_tagged_int(p, end, MBEDTLS_ASN1_INTEGER, val);
   \        0x2   0x2202             MOVS     R2,#+2
   \        0x4   0x....             B.N      asn1_get_tagged_int
    164          }
    165          

   \                                 In section .text, align 2, keep-with-next
    166          int mbedtls_asn1_get_enum(unsigned char **p,
    167                                    const unsigned char *end,
    168                                    int *val)
    169          {
   \                     mbedtls_asn1_get_enum: (+1)
   \        0x0   0x4613             MOV      R3,R2
    170              return asn1_get_tagged_int(p, end, MBEDTLS_ASN1_ENUMERATED, val);
   \        0x2   0x220A             MOVS     R2,#+10
   \        0x4   0x....             B.N      asn1_get_tagged_int
    171          }
    172          
    173          #if defined(MBEDTLS_BIGNUM_C)

   \                                 In section .text, align 2, keep-with-next
    174          int mbedtls_asn1_get_mpi(unsigned char **p,
    175                                   const unsigned char *end,
    176                                   mbedtls_mpi *X)
    177          {
   \                     mbedtls_asn1_get_mpi: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x4604             MOV      R4,R0
    178              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    179              size_t len;
    180          
    181              if ((ret = mbedtls_asn1_get_tag(p, end, &len, MBEDTLS_ASN1_INTEGER)) != 0) {
   \        0x6   0x2302             MOVS     R3,#+2
   \        0x8   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xC   0xB940             CBNZ.N   R0,??mbedtls_asn1_get_mpi_0
    182                  return ret;
    183              }
    184          
    185              ret = mbedtls_mpi_read_binary(X, *p, len);
   \        0xE   0x9A00             LDR      R2,[SP, #+0]
   \       0x10   0x6821             LDR      R1,[R4, #+0]
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       mbedtls_mpi_read_binary
    186          
    187              *p += len;
   \       0x18   0x6822             LDR      R2,[R4, #+0]
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x4411             ADD      R1,R2,R1
   \       0x1E   0x6021             STR      R1,[R4, #+0]
    188          
    189              return ret;
   \                     ??mbedtls_asn1_get_mpi_0: (+1)
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
    190          }
    191          #endif /* MBEDTLS_BIGNUM_C */
    192          

   \                                 In section .text, align 2, keep-with-next
    193          int mbedtls_asn1_get_bitstring(unsigned char **p, const unsigned char *end,
    194                                         mbedtls_asn1_bitstring *bs)
    195          {
   \                     mbedtls_asn1_get_bitstring: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    196              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    197          
    198              /* Certificate type is a single byte bitstring */
    199              if ((ret = mbedtls_asn1_get_tag(p, end, &bs->len, MBEDTLS_ASN1_BIT_STRING)) != 0) {
   \        0x8   0x2303             MOVS     R3,#+3
   \        0xA   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \        0xE   0xB9D8             CBNZ.N   R0,??mbedtls_asn1_get_bitstring_0
    200                  return ret;
    201              }
    202          
    203              /* Check length, subtract one for actual bit string length */
    204              if (bs->len < 1) {
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0xB910             CBNZ.N   R0,??mbedtls_asn1_get_bitstring_1
    205                  return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
   \       0x14   0xF06F 0x005F      MVN      R0,#+95
   \       0x18   0xBD70             POP      {R4-R6,PC}
    206              }
    207              bs->len -= 1;
   \                     ??mbedtls_asn1_get_bitstring_1: (+1)
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0x6030             STR      R0,[R6, #+0]
    208          
    209              /* Get number of unused bits, ensure unused bits <= 7 */
    210              bs->unused_bits = **p;
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x7809             LDRB     R1,[R1, #+0]
   \       0x22   0x7131             STRB     R1,[R6, #+4]
    211              if (bs->unused_bits > 7) {
   \       0x24   0x2908             CMP      R1,#+8
   \       0x26   0xDB02             BLT.N    ??mbedtls_asn1_get_bitstring_2
    212                  return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
   \       0x28   0xF06F 0x0063      MVN      R0,#+99
   \       0x2C   0xBD70             POP      {R4-R6,PC}
    213              }
    214              (*p)++;
    215          
    216              /* Get actual bitstring */
    217              bs->p = *p;
   \                     ??mbedtls_asn1_get_bitstring_2: (+1)
   \       0x2E   0x6823             LDR      R3,[R4, #+0]
   \       0x30   0x1C5A             ADDS     R2,R3,#+1
   \       0x32   0x6022             STR      R2,[R4, #+0]
   \       0x34   0x60B2             STR      R2,[R6, #+8]
    218              *p += bs->len;
   \       0x36   0x6823             LDR      R3,[R4, #+0]
   \       0x38   0x4418             ADD      R0,R3,R0
   \       0x3A   0x6020             STR      R0,[R4, #+0]
    219          
    220              if (*p != end) {
   \       0x3C   0x42A8             CMP      R0,R5
   \       0x3E   0xD002             BEQ.N    ??mbedtls_asn1_get_bitstring_3
    221                  return MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
   \       0x40   0xF06F 0x0065      MVN      R0,#+101
   \       0x44   0xBD70             POP      {R4-R6,PC}
    222              }
    223          
    224              return 0;
   \                     ??mbedtls_asn1_get_bitstring_3: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_asn1_get_bitstring_0: (+1)
   \       0x48   0xBD70             POP      {R4-R6,PC}
    225          }
    226          
    227          /*
    228           * Traverse an ASN.1 "SEQUENCE OF <tag>"
    229           * and call a callback for each entry found.
    230           */

   \                                 In section .text, align 2, keep-with-next
    231          int mbedtls_asn1_traverse_sequence_of(
    232              unsigned char **p,
    233              const unsigned char *end,
    234              unsigned char tag_must_mask, unsigned char tag_must_val,
    235              unsigned char tag_may_mask, unsigned char tag_may_val,
    236              int (*cb)(void *ctx, int tag,
    237                        unsigned char *start, size_t len),
    238              void *ctx)
    239          {
   \                     mbedtls_asn1_traverse_sequence_of: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x469A             MOV      R10,R3
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x4688             MOV      R8,R1
    240              int ret;
    241              size_t len;
    242          
    243              /* Get main sequence tag */
    244              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    245                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \        0xC   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x10   0xB108             CBZ.N    R0,??mbedtls_asn1_traverse_sequence_of_0
    246                  return ret;
   \                     ??mbedtls_asn1_traverse_sequence_of_1: (+1)
   \       0x12   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    247              }
    248          
    249              if (*p + len != end) {
   \                     ??mbedtls_asn1_traverse_sequence_of_0: (+1)
   \       0x16   0x6838             LDR      R0,[R7, #+0]
   \       0x18   0x9900             LDR      R1,[SP, #+0]
   \       0x1A   0x4401             ADD      R1,R0,R1
   \       0x1C   0x4541             CMP      R1,R8
   \       0x1E   0xBF18             IT       NE
   \       0x20   0xF06F 0x0065      MVNNE    R0,#+101
    250                  return MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
   \       0x24   0xD1F5             BNE.N    ??mbedtls_asn1_traverse_sequence_of_1
   \       0x26   0x4631             MOV      R1,R6
   \       0x28   0x9C0E             LDR      R4,[SP, #+56]
   \       0x2A   0x9E0C             LDR      R6,[SP, #+48]
   \       0x2C   0xF8DD 0xB034      LDR      R11,[SP, #+52]
   \       0x30   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   \       0x34   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \       0x38   0xE015             B.N      ??mbedtls_asn1_traverse_sequence_of_2
    251              }
    252          
    253              while (*p < end) {
    254                  unsigned char const tag = *(*p)++;
    255          
    256                  if ((tag & tag_must_mask) != tag_must_val) {
    257                      return MBEDTLS_ERR_ASN1_UNEXPECTED_TAG;
    258                  }
    259          
    260                  if ((ret = mbedtls_asn1_get_len(p, end, &len)) != 0) {
   \                     ??mbedtls_asn1_traverse_sequence_of_3: (+1)
   \       0x3A   0x466A             MOV      R2,SP
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0x.... 0x....      BL       mbedtls_asn1_get_len
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD1E4             BNE.N    ??mbedtls_asn1_traverse_sequence_of_1
    261                      return ret;
    262                  }
    263          
    264                  if ((tag & tag_may_mask) == tag_may_val) {
   \       0x48   0xEA06 0x0105      AND      R1,R6,R5
   \       0x4C   0x4559             CMP      R1,R11
   \       0x4E   0xD107             BNE.N    ??mbedtls_asn1_traverse_sequence_of_4
    265                      if (cb != NULL) {
   \       0x50   0xB134             CBZ.N    R4,??mbedtls_asn1_traverse_sequence_of_4
    266                          ret = cb(ctx, tag, *p, len);
   \       0x52   0x9B00             LDR      R3,[SP, #+0]
   \       0x54   0x683A             LDR      R2,[R7, #+0]
   \       0x56   0x4629             MOV      R1,R5
   \       0x58   0x4648             MOV      R0,R9
   \       0x5A   0x47A0             BLX      R4
    267                          if (ret != 0) {
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD1D8             BNE.N    ??mbedtls_asn1_traverse_sequence_of_1
    268                              return ret;
    269                          }
    270                      }
    271                  }
    272          
    273                  *p += len;
   \                     ??mbedtls_asn1_traverse_sequence_of_4: (+1)
   \       0x60   0x6839             LDR      R1,[R7, #+0]
   \       0x62   0x9800             LDR      R0,[SP, #+0]
   \       0x64   0x4408             ADD      R0,R1,R0
   \                     ??mbedtls_asn1_traverse_sequence_of_2: (+1)
   \       0x66   0x4540             CMP      R0,R8
   \       0x68   0xD20A             BCS.N    ??mbedtls_asn1_traverse_sequence_of_5
   \       0x6A   0x1C42             ADDS     R2,R0,#+1
   \       0x6C   0x603A             STR      R2,[R7, #+0]
   \       0x6E   0x7805             LDRB     R5,[R0, #+0]
   \       0x70   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0x74   0x4029             ANDS     R1,R1,R5
   \       0x76   0x4551             CMP      R1,R10
   \       0x78   0xD0DF             BEQ.N    ??mbedtls_asn1_traverse_sequence_of_3
   \       0x7A   0xF06F 0x0061      MVN      R0,#+97
   \       0x7E   0xE7C8             B.N      ??mbedtls_asn1_traverse_sequence_of_1
    274              }
    275          
    276              return 0;
   \                     ??mbedtls_asn1_traverse_sequence_of_5: (+1)
   \       0x80   0x6038             STR      R0,[R7, #+0]
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xE7C5             B.N      ??mbedtls_asn1_traverse_sequence_of_1
    277          }
    278          
    279          /*
    280           * Get a bit string without unused bits
    281           */

   \                                 In section .text, align 2, keep-with-next
    282          int mbedtls_asn1_get_bitstring_null(unsigned char **p, const unsigned char *end,
    283                                              size_t *len)
    284          {
   \                     mbedtls_asn1_get_bitstring_null: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
    285              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    286          
    287              if ((ret = mbedtls_asn1_get_tag(p, end, len, MBEDTLS_ASN1_BIT_STRING)) != 0) {
   \        0x6   0x2303             MOVS     R3,#+3
   \        0x8   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \        0xC   0xB958             CBNZ.N   R0,??mbedtls_asn1_get_bitstring_null_0
    288                  return ret;
    289              }
    290          
    291              if (*len == 0) {
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0xF06F 0x0067      MVN      R0,#+103
   \       0x14   0xB139             CBZ.N    R1,??mbedtls_asn1_get_bitstring_null_0
    292                  return MBEDTLS_ERR_ASN1_INVALID_DATA;
    293              }
    294              --(*len);
   \       0x16   0x1E49             SUBS     R1,R1,#+1
   \       0x18   0x6029             STR      R1,[R5, #+0]
    295          
    296              if (**p != 0) {
   \       0x1A   0x6822             LDR      R2,[R4, #+0]
   \       0x1C   0x7811             LDRB     R1,[R2, #+0]
   \       0x1E   0xB911             CBNZ.N   R1,??mbedtls_asn1_get_bitstring_null_0
    297                  return MBEDTLS_ERR_ASN1_INVALID_DATA;
    298              }
    299              ++(*p);
   \       0x20   0x1C50             ADDS     R0,R2,#+1
   \       0x22   0x6020             STR      R0,[R4, #+0]
    300          
    301              return 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_asn1_get_bitstring_null_0: (+1)
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    302          }
    303          

   \                                 In section .text, align 2, keep-with-next
    304          void mbedtls_asn1_sequence_free(mbedtls_asn1_sequence *seq)
    305          {
   \                     mbedtls_asn1_sequence_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xE003             B.N      ??mbedtls_asn1_sequence_free_0
    306              while (seq != NULL) {
    307                  mbedtls_asn1_sequence *next = seq->next;
   \                     ??mbedtls_asn1_sequence_free_1: (+1)
   \        0x6   0x68C4             LDR      R4,[R0, #+12]
    308                  mbedtls_free(seq);
   \        0x8   0x.... 0x....      BL       sl_free
    309                  seq = next;
   \        0xC   0x0020             MOVS     R0,R4
    310              }
   \                     ??mbedtls_asn1_sequence_free_0: (+1)
   \        0xE   0xD1FA             BNE.N    ??mbedtls_asn1_sequence_free_1
    311          }
   \       0x10   0xBD10             POP      {R4,PC}
    312          
    313          typedef struct {
    314              int tag;
    315              mbedtls_asn1_sequence *cur;
    316          } asn1_get_sequence_of_cb_ctx_t;
    317          

   \                                 In section .text, align 2, keep-with-next
    318          static int asn1_get_sequence_of_cb(void *ctx,
    319                                             int tag,
    320                                             unsigned char *start,
    321                                             size_t len)
    322          {
   \                     asn1_get_sequence_of_cb: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
    323              asn1_get_sequence_of_cb_ctx_t *cb_ctx =
    324                  (asn1_get_sequence_of_cb_ctx_t *) ctx;
    325              mbedtls_asn1_sequence *cur =
    326                  cb_ctx->cur;
   \        0x6   0x687C             LDR      R4,[R7, #+4]
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
    327          
    328              if (cur->buf.p != NULL) {
   \        0xC   0x68A0             LDR      R0,[R4, #+8]
   \        0xE   0x4698             MOV      R8,R3
   \       0x10   0xB148             CBZ.N    R0,??asn1_get_sequence_of_cb_0
    329                  cur->next =
    330                      mbedtls_calloc(1, sizeof(mbedtls_asn1_sequence));
   \       0x12   0x2110             MOVS     R1,#+16
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x.... 0x....      BL       sl_calloc
   \       0x1A   0x60E0             STR      R0,[R4, #+12]
    331          
    332                  if (cur->next == NULL) {
   \       0x1C   0x0004             MOVS     R4,R0
   \       0x1E   0xBF08             IT       EQ
   \       0x20   0xF06F 0x0069      MVNEQ    R0,#+105
    333                      return MBEDTLS_ERR_ASN1_ALLOC_FAILED;
   \       0x24   0xD005             BEQ.N    ??asn1_get_sequence_of_cb_1
    334                  }
    335          
    336                  cur = cur->next;
    337              }
    338          
    339              cur->buf.p = start;
   \                     ??asn1_get_sequence_of_cb_0: (+1)
   \       0x26   0x60A6             STR      R6,[R4, #+8]
    340              cur->buf.len = len;
   \       0x28   0xF8C4 0x8004      STR      R8,[R4, #+4]
    341              cur->buf.tag = tag;
   \       0x2C   0x6025             STR      R5,[R4, #+0]
    342          
    343              cb_ctx->cur = cur;
   \       0x2E   0x607C             STR      R4,[R7, #+4]
    344              return 0;
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??asn1_get_sequence_of_cb_1: (+1)
   \       0x32   0xE8BD 0x81F0      POP      {R4-R8,PC}
    345          }
    346          
    347          /*
    348           *  Parses and splits an ASN.1 "SEQUENCE OF <tag>"
    349           */

   \                                 In section .text, align 2, keep-with-next
    350          int mbedtls_asn1_get_sequence_of(unsigned char **p,
    351                                           const unsigned char *end,
    352                                           mbedtls_asn1_sequence *cur,
    353                                           int tag)
    354          {
   \                     mbedtls_asn1_get_sequence_of: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    355              asn1_get_sequence_of_cb_ctx_t cb_ctx = { tag, cur };
   \        0x4   0x9304             STR      R3,[SP, #+16]
   \        0x6   0x9205             STR      R2,[SP, #+20]
    356              memset(cur, 0, sizeof(mbedtls_asn1_sequence));
   \        0x8   0x2700             MOVS     R7,#+0
   \        0xA   0x2400             MOVS     R4,#+0
   \        0xC   0x2500             MOVS     R5,#+0
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0xE882 0x00F0      STM      R2,{R4-R7}
    357              return mbedtls_asn1_traverse_sequence_of(
    358                  p, end, 0xFF, tag, 0, 0,
    359                  asn1_get_sequence_of_cb, &cb_ctx);
   \       0x14   0xAA04             ADD      R2,SP,#+16
   \       0x16   0x9203             STR      R2,[SP, #+12]
   \       0x18   0x....             LDR.N    R6,??DataTable1
   \       0x1A   0x9602             STR      R6,[SP, #+8]
   \       0x1C   0x9501             STR      R5,[SP, #+4]
   \       0x1E   0x9400             STR      R4,[SP, #+0]
   \       0x20   0xB2DB             UXTB     R3,R3
   \       0x22   0x22FF             MOVS     R2,#+255
   \       0x24   0x.... 0x....      BL       mbedtls_asn1_traverse_sequence_of
   \       0x28   0xB007             ADD      SP,SP,#+28
   \       0x2A   0xBDF0             POP      {R4-R7,PC}
    360          }
    361          

   \                                 In section .text, align 2, keep-with-next
    362          int mbedtls_asn1_get_alg(unsigned char **p,
    363                                   const unsigned char *end,
    364                                   mbedtls_asn1_buf *alg, mbedtls_asn1_buf *params)
    365          {
   \                     mbedtls_asn1_get_alg: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4616             MOV      R6,R2
   \        0x4   0x461D             MOV      R5,R3
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460F             MOV      R7,R1
    366              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    367              size_t len;
    368          
    369              if ((ret = mbedtls_asn1_get_tag(p, end, &len,
    370                                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE)) != 0) {
   \        0xA   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xE   0xBBA0             CBNZ.N   R0,??mbedtls_asn1_get_alg_0
    371                  return ret;
    372              }
    373          
    374              if ((end - *p) < 1) {
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x1A3F             SUBS     R7,R7,R0
   \       0x14   0x2F00             CMP      R7,#+0
   \       0x16   0xDC02             BGT.N    ??mbedtls_asn1_get_alg_1
    375                  return MBEDTLS_ERR_ASN1_OUT_OF_DATA;
   \       0x18   0xF06F 0x005F      MVN      R0,#+95
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
    376              }
    377          
    378              alg->tag = **p;
   \                     ??mbedtls_asn1_get_alg_1: (+1)
   \       0x1E   0x7802             LDRB     R2,[R0, #+0]
    379              end = *p + len;
    380          
    381              if ((ret = mbedtls_asn1_get_tag(p, end, &alg->len, MBEDTLS_ASN1_OID)) != 0) {
   \       0x20   0x2306             MOVS     R3,#+6
   \       0x22   0x6032             STR      R2,[R6, #+0]
   \       0x24   0x9900             LDR      R1,[SP, #+0]
   \       0x26   0x1D32             ADDS     R2,R6,#+4
   \       0x28   0x1847             ADDS     R7,R0,R1
   \       0x2A   0x4639             MOV      R1,R7
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \       0x32   0xBB10             CBNZ.N   R0,??mbedtls_asn1_get_alg_0
    382                  return ret;
    383              }
    384          
    385              alg->p = *p;
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x60B1             STR      R1,[R6, #+8]
    386              *p += alg->len;
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6871             LDR      R1,[R6, #+4]
   \       0x3C   0x4401             ADD      R1,R0,R1
   \       0x3E   0x6021             STR      R1,[R4, #+0]
    387          
    388              if (*p == end) {
   \       0x40   0x42B9             CMP      R1,R7
   \       0x42   0xD104             BNE.N    ??mbedtls_asn1_get_alg_2
    389                  mbedtls_platform_zeroize(params, sizeof(mbedtls_asn1_buf));
   \       0x44   0x210C             MOVS     R1,#+12
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x.... 0x....      BL       mbedtls_platform_zeroize
    390                  return 0;
   \       0x4C   0xE014             B.N      ??mbedtls_asn1_get_alg_3
    391              }
    392          
    393              params->tag = **p;
   \                     ??mbedtls_asn1_get_alg_2: (+1)
   \       0x4E   0xF811 0x0B01      LDRB     R0,[R1], #+1
    394              (*p)++;
    395          
    396              if ((ret = mbedtls_asn1_get_len(p, end, &params->len)) != 0) {
   \       0x52   0x1D2A             ADDS     R2,R5,#+4
   \       0x54   0x6028             STR      R0,[R5, #+0]
   \       0x56   0x6021             STR      R1,[R4, #+0]
   \       0x58   0x4639             MOV      R1,R7
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x.... 0x....      BL       mbedtls_asn1_get_len
   \       0x60   0xB958             CBNZ.N   R0,??mbedtls_asn1_get_alg_0
    397                  return ret;
    398              }
    399          
    400              params->p = *p;
   \       0x62   0x6821             LDR      R1,[R4, #+0]
   \       0x64   0x60A9             STR      R1,[R5, #+8]
    401              *p += params->len;
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x6869             LDR      R1,[R5, #+4]
   \       0x6A   0x4408             ADD      R0,R0,R1
   \       0x6C   0x6020             STR      R0,[R4, #+0]
    402          
    403              if (*p != end) {
   \       0x6E   0x42B8             CMP      R0,R7
   \       0x70   0xD002             BEQ.N    ??mbedtls_asn1_get_alg_3
    404                  return MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
   \       0x72   0xF06F 0x0065      MVN      R0,#+101
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}
    405              }
    406          
    407              return 0;
   \                     ??mbedtls_asn1_get_alg_3: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_asn1_get_alg_0: (+1)
   \       0x7A   0xBDF2             POP      {R1,R4-R7,PC}
    408          }
    409          

   \                                 In section .text, align 2, keep-with-next
    410          int mbedtls_asn1_get_alg_null(unsigned char **p,
    411                                        const unsigned char *end,
    412                                        mbedtls_asn1_buf *alg)
    413          {
   \                     mbedtls_asn1_get_alg_null: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
    414              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    415              mbedtls_asn1_buf params;
    416          
    417              memset(&params, 0, sizeof(mbedtls_asn1_buf));
   \        0x2   0x466E             MOV      R6,SP
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x2500             MOVS     R5,#+0
   \        0xA   0xE886 0x0038      STM      R6,{R3-R5}
    418          
    419              if ((ret = mbedtls_asn1_get_alg(p, end, alg, &params)) != 0) {
   \        0xE   0x466B             MOV      R3,SP
   \       0x10   0x.... 0x....      BL       mbedtls_asn1_get_alg
   \       0x14   0xB940             CBNZ.N   R0,??mbedtls_asn1_get_alg_null_0
    420                  return ret;
    421              }
    422          
    423              if ((params.tag != MBEDTLS_ASN1_NULL && params.tag != 0) || params.len != 0) {
   \       0x16   0x9800             LDR      R0,[SP, #+0]
   \       0x18   0x2805             CMP      R0,#+5
   \       0x1A   0xBF18             IT       NE
   \       0x1C   0x2800             CMPNE    R0,#+0
   \       0x1E   0xD101             BNE.N    ??mbedtls_asn1_get_alg_null_1
   \       0x20   0x9801             LDR      R0,[SP, #+4]
   \       0x22   0xB108             CBZ.N    R0,??mbedtls_asn1_get_alg_null_0
    424                  return MBEDTLS_ERR_ASN1_INVALID_DATA;
   \                     ??mbedtls_asn1_get_alg_null_1: (+1)
   \       0x24   0xF06F 0x0067      MVN      R0,#+103
    425              }
    426          
    427              return 0;
   \                     ??mbedtls_asn1_get_alg_null_0: (+1)
   \       0x28   0xB004             ADD      SP,SP,#+16
   \       0x2A   0xBD70             POP      {R4-R6,PC}
    428          }
    429          
    430          #if !defined(MBEDTLS_DEPRECATED_REMOVED)

   \                                 In section .text, align 2, keep-with-next
    431          void mbedtls_asn1_free_named_data(mbedtls_asn1_named_data *cur)
    432          {
   \                     mbedtls_asn1_free_named_data: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    433              if (cur == NULL) {
   \        0x4   0xD00B             BEQ.N    ??mbedtls_asn1_free_named_data_0
    434                  return;
    435              }
    436          
    437              mbedtls_free(cur->oid.p);
   \        0x6   0x68A0             LDR      R0,[R4, #+8]
   \        0x8   0x.... 0x....      BL       sl_free
    438              mbedtls_free(cur->val.p);
   \        0xC   0x6960             LDR      R0,[R4, #+20]
   \        0xE   0x.... 0x....      BL       sl_free
    439          
    440              mbedtls_platform_zeroize(cur, sizeof(mbedtls_asn1_named_data));
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x2120             MOVS     R1,#+32
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x.... 0x....      B.W      mbedtls_platform_zeroize
   \                     ??mbedtls_asn1_free_named_data_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}
    441          }
    442          #endif /* MBEDTLS_DEPRECATED_REMOVED */
    443          

   \                                 In section .text, align 2, keep-with-next
    444          void mbedtls_asn1_free_named_data_list(mbedtls_asn1_named_data **head)
    445          {
   \                     mbedtls_asn1_free_named_data_list: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0xE00A             B.N      ??mbedtls_asn1_free_named_data_list_0
    446              mbedtls_asn1_named_data *cur;
    447          
    448              while ((cur = *head) != NULL) {
    449                  *head = cur->next;
   \                     ??mbedtls_asn1_free_named_data_list_1: (+1)
   \        0x6   0x69A1             LDR      R1,[R4, #+24]
   \        0x8   0x6029             STR      R1,[R5, #+0]
    450                  mbedtls_free(cur->oid.p);
   \        0xA   0x68A0             LDR      R0,[R4, #+8]
   \        0xC   0x.... 0x....      BL       sl_free
    451                  mbedtls_free(cur->val.p);
   \       0x10   0x6960             LDR      R0,[R4, #+20]
   \       0x12   0x.... 0x....      BL       sl_free
    452                  mbedtls_free(cur);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       sl_free
    453              }
   \                     ??mbedtls_asn1_free_named_data_list_0: (+1)
   \       0x1C   0x682C             LDR      R4,[R5, #+0]
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD1F1             BNE.N    ??mbedtls_asn1_free_named_data_list_1
    454          }
   \       0x22   0xBD31             POP      {R0,R4,R5,PC}
    455          

   \                                 In section .text, align 2, keep-with-next
    456          void mbedtls_asn1_free_named_data_list_shallow(mbedtls_asn1_named_data *name)
    457          {
   \                     mbedtls_asn1_free_named_data_list_shallow: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xE003             B.N      ??mbedtls_asn1_free_named_data_list_shallow_0
    458              for (mbedtls_asn1_named_data *next; name != NULL; name = next) {
    459                  next = name->next;
   \                     ??mbedtls_asn1_free_named_data_list_shallow_1: (+1)
   \        0x6   0x6984             LDR      R4,[R0, #+24]
    460                  mbedtls_free(name);
   \        0x8   0x.... 0x....      BL       sl_free
    461              }
   \        0xC   0x0020             MOVS     R0,R4
   \                     ??mbedtls_asn1_free_named_data_list_shallow_0: (+1)
   \        0xE   0xD1FA             BNE.N    ??mbedtls_asn1_free_named_data_list_shallow_1
    462          }
   \       0x10   0xBD10             POP      {R4,PC}
    463          

   \                                 In section .text, align 2, keep-with-next
    464          const mbedtls_asn1_named_data *mbedtls_asn1_find_named_data(const mbedtls_asn1_named_data *list,
    465                                                                      const char *oid, size_t len)
    466          {
   \                     mbedtls_asn1_find_named_data: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0xE000             B.N      ??mbedtls_asn1_find_named_data_0
    467              while (list != NULL) {
    468                  if (list->oid.len == len &&
    469                      memcmp(list->oid.p, oid, len) == 0) {
    470                      break;
    471                  }
    472          
    473                  list = list->next;
   \                     ??mbedtls_asn1_find_named_data_1: (+1)
   \        0xA   0x69A4             LDR      R4,[R4, #+24]
   \                     ??mbedtls_asn1_find_named_data_0: (+1)
   \        0xC   0xB14C             CBZ.N    R4,??mbedtls_asn1_find_named_data_2
   \        0xE   0x6861             LDR      R1,[R4, #+4]
   \       0x10   0x42B1             CMP      R1,R6
   \       0x12   0xD1FA             BNE.N    ??mbedtls_asn1_find_named_data_1
   \       0x14   0x68A0             LDR      R0,[R4, #+8]
   \       0x16   0x4632             MOV      R2,R6
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x.... 0x....      BL       memcmp
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD1F3             BNE.N    ??mbedtls_asn1_find_named_data_1
    474              }
    475          
    476              return list;
   \                     ??mbedtls_asn1_find_named_data_2: (+1)
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0xBD70             POP      {R4-R6,PC}
    477          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     asn1_get_sequence_of_cb
    478          
    479          #endif /* MBEDTLS_ASN1_PARSE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   asn1_get_sequence_of_cb
        24   -> sl_calloc
      16   asn1_get_tagged_int
        16   -> mbedtls_asn1_get_tag
      16   mbedtls_asn1_find_named_data
        16   -> memcmp
       8   mbedtls_asn1_free_named_data
         0   -> mbedtls_platform_zeroize
         8   -> sl_free
      16   mbedtls_asn1_free_named_data_list
        16   -> sl_free
       8   mbedtls_asn1_free_named_data_list_shallow
         8   -> sl_free
      24   mbedtls_asn1_get_alg
        24   -> mbedtls_asn1_get_len
        24   -> mbedtls_asn1_get_tag
        24   -> mbedtls_platform_zeroize
      32   mbedtls_asn1_get_alg_null
        32   -> mbedtls_asn1_get_alg
      16   mbedtls_asn1_get_bitstring
        16   -> mbedtls_asn1_get_tag
      16   mbedtls_asn1_get_bitstring_null
        16   -> mbedtls_asn1_get_tag
      16   mbedtls_asn1_get_bool
        16   -> mbedtls_asn1_get_tag
       0   mbedtls_asn1_get_enum
         0   -> asn1_get_tagged_int
       0   mbedtls_asn1_get_int
         0   -> asn1_get_tagged_int
      20   mbedtls_asn1_get_len
      16   mbedtls_asn1_get_mpi
        16   -> mbedtls_asn1_get_tag
        16   -> mbedtls_mpi_read_binary
      48   mbedtls_asn1_get_sequence_of
        48   -> mbedtls_asn1_traverse_sequence_of
      16   mbedtls_asn1_get_tag
         0   -> mbedtls_asn1_get_len
       8   mbedtls_asn1_sequence_free
         8   -> sl_free
      48   mbedtls_asn1_traverse_sequence_of
        48   -- Indirect call
        48   -> mbedtls_asn1_get_len
        48   -> mbedtls_asn1_get_tag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       6  ?Subroutine0
       6  ?Subroutine1
      54  asn1_get_sequence_of_cb
      94  asn1_get_tagged_int
      38  mbedtls_asn1_find_named_data
      32  mbedtls_asn1_free_named_data
      36  mbedtls_asn1_free_named_data_list
      18  mbedtls_asn1_free_named_data_list_shallow
     124  mbedtls_asn1_get_alg
      44  mbedtls_asn1_get_alg_null
      74  mbedtls_asn1_get_bitstring
      40  mbedtls_asn1_get_bitstring_null
      40  mbedtls_asn1_get_bool
       6  mbedtls_asn1_get_enum
       6  mbedtls_asn1_get_int
      96  mbedtls_asn1_get_len
      34  mbedtls_asn1_get_mpi
      44  mbedtls_asn1_get_sequence_of
      38  mbedtls_asn1_get_tag
      18  mbedtls_asn1_sequence_free
     134  mbedtls_asn1_traverse_sequence_of

 
 986 bytes in section .text
 
 986 bytes of CODE memory

Errors: none
Warnings: none
