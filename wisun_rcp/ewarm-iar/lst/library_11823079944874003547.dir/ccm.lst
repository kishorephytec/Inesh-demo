###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:25
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ccm.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ccm.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ccm.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ccm.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\library_11823079944874003547.dir\ccm.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\library_11823079944874003547.dir\ccm.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\ccm.c
      1          /*
      2           *  NIST SP800-38C compliant CCM implementation
      3           *
      4           *  Copyright The Mbed TLS Contributors
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * Definition of CCM:
     22           * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
     23           * RFC 3610 "Counter with CBC-MAC (CCM)"
     24           *
     25           * Related:
     26           * RFC 5116 "An Interface and Algorithms for Authenticated Encryption"
     27           */
     28          
     29          #include "common.h"

   \                                 In section .text, align 2
   \   __vfp uint32_t mbedtls_get_unaligned_uint32(void const *)
   \                     mbedtls_get_unaligned_uint32: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xB001             ADD      SP,SP,#+4
   \        0x8   0x4608             MOV      R0,R1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2
   \   __vfp void mbedtls_xor(unsigned char *, unsigned char const *, unsigned char const *, size_t)
   \                     mbedtls_xor: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0x2700             MOVS     R7,#+0
   \        0xE   0xE00B             B.N      ??mbedtls_xor_0
   \                     ??mbedtls_xor_1: (+1)
   \       0x10   0x19E8             ADDS     R0,R5,R7
   \       0x12   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x16   0x4606             MOV      R6,R0
   \       0x18   0xEB08 0x0007      ADD      R0,R8,R7
   \       0x1C   0x.... 0x....      BL       mbedtls_get_unaligned_uint32
   \       0x20   0x4046             EORS     R6,R0,R6
   \       0x22   0x9600             STR      R6,[SP, #+0]
   \       0x24   0x51E6             STR      R6,[R4, R7]
   \       0x26   0x4657             MOV      R7,R10
   \                     ??mbedtls_xor_0: (+1)
   \       0x28   0xF107 0x0A04      ADD      R10,R7,#+4
   \       0x2C   0x45D1             CMP      R9,R10
   \       0x2E   0xD2EF             BCS.N    ??mbedtls_xor_1
   \                     ??mbedtls_xor_2: (+1)
   \       0x30   0x454F             CMP      R7,R9
   \       0x32   0xD206             BCS.N    ??mbedtls_xor_3
   \       0x34   0x5DE9             LDRB     R1,[R5, R7]
   \       0x36   0xF818 0x0007      LDRB     R0,[R8, R7]
   \       0x3A   0x4041             EORS     R1,R0,R1
   \       0x3C   0x55E1             STRB     R1,[R4, R7]
   \       0x3E   0x1C7F             ADDS     R7,R7,#+1
   \       0x40   0xE7F6             B.N      ??mbedtls_xor_2
   \                     ??mbedtls_xor_3: (+1)
   \       0x42   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}
     30          
     31          #if defined(MBEDTLS_CCM_C)
     32          
     33          #include "mbedtls/ccm.h"
     34          #include "mbedtls/platform_util.h"
     35          #include "mbedtls/error.h"
     36          #include "mbedtls/constant_time.h"
     37          
     38          #include <string.h>
     39          
     40          #if defined(MBEDTLS_PLATFORM_C)
     41          #include "mbedtls/platform.h"
     42          #else
     43          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
     44          #include <stdio.h>
     45          #define mbedtls_printf printf
     46          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
     47          #endif /* MBEDTLS_PLATFORM_C */
     48          
     49          #if !defined(MBEDTLS_CCM_ALT)
     50          
     51          
     52          /*
     53           * Initialize context
     54           */

   \                                 In section .text, align 2, keep-with-next
     55          void mbedtls_ccm_init(mbedtls_ccm_context *ctx)
     56          {
     57              memset(ctx, 0, sizeof(mbedtls_ccm_context));
   \                     mbedtls_ccm_init: (+1)
   \        0x0   0x2184             MOVS     R1,#+132
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4
     58          }
     59          

   \                                 In section .text, align 2, keep-with-next
     60          int mbedtls_ccm_setkey(mbedtls_ccm_context *ctx,
     61                                 mbedtls_cipher_id_t cipher,
     62                                 const unsigned char *key,
     63                                 unsigned int keybits)
     64          {
   \                     mbedtls_ccm_setkey: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
     65              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     66              const mbedtls_cipher_info_t *cipher_info;
     67          
     68              cipher_info = mbedtls_cipher_info_from_values(cipher, keybits,
     69                                                            MBEDTLS_MODE_ECB);
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x4639             MOV      R1,R7
   \        0xE   0x.... 0x....      BL       mbedtls_cipher_info_from_values
   \       0x12   0x0004             MOVS     R4,R0
     70              if (cipher_info == NULL) {
   \       0x14   0xD004             BEQ.N    ??mbedtls_ccm_setkey_0
     71                  return MBEDTLS_ERR_CCM_BAD_INPUT;
     72              }
     73          
     74              if (mbedtls_cipher_info_get_block_size(cipher_info) != 16) {
   \       0x16   0x7920             LDRB     R0,[R4, #+4]
   \       0x18   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x1C   0x2810             CMP      R0,#+16
   \       0x1E   0xD000             BEQ.N    ??mbedtls_ccm_setkey_1
     75                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \                     ??mbedtls_ccm_setkey_0: (+1)
   \       0x20   0x....             B.N      ?Subroutine0
     76              }
     77          
     78              mbedtls_cipher_free(&ctx->cipher_ctx);
   \                     ??mbedtls_ccm_setkey_1: (+1)
   \       0x22   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x26   0x.... 0x....      BL       mbedtls_cipher_free
     79          
     80              if ((ret = mbedtls_cipher_setup(&ctx->cipher_ctx, cipher_info)) != 0) {
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x30   0x.... 0x....      BL       mbedtls_cipher_setup
   \       0x34   0xB948             CBNZ.N   R0,??mbedtls_ccm_setkey_2
     81                  return ret;
     82              }
     83          
     84              if ((ret = mbedtls_cipher_setkey(&ctx->cipher_ctx, key, keybits,
     85                                               MBEDTLS_ENCRYPT)) != 0) {
     86                  return ret;
   \       0x36   0x463A             MOV      R2,R7
   \       0x38   0x4631             MOV      R1,R6
   \       0x3A   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x3E   0xB001             ADD      SP,SP,#+4
   \       0x40   0x2301             MOVS     R3,#+1
   \       0x42   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \       0x46   0x.... 0x....      B.W      mbedtls_cipher_setkey
   \                     ??mbedtls_ccm_setkey_2: (+1)
   \       0x4A   0xBDF2             POP      {R1,R4-R7,PC}
     87              }
     88          
     89              return 0;
     90          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF06F 0x000C      MVN      R0,#+12
   \        0x4   0xBDF2             POP      {R1,R4-R7,PC}
     91          
     92          /*
     93           * Free context
     94           */

   \                                 In section .text, align 2, keep-with-next
     95          void mbedtls_ccm_free(mbedtls_ccm_context *ctx)
     96          {
   \                     mbedtls_ccm_free: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     97              if (ctx == NULL) {
   \        0x4   0xD009             BEQ.N    ??mbedtls_ccm_free_0
     98                  return;
     99              }
    100              mbedtls_cipher_free(&ctx->cipher_ctx);
   \        0x6   0xF104 0x0038      ADD      R0,R4,#+56
   \        0xA   0x.... 0x....      BL       mbedtls_cipher_free
    101              mbedtls_platform_zeroize(ctx, sizeof(mbedtls_ccm_context));
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x2184             MOVS     R1,#+132
   \       0x12   0xE8BD 0x4010      POP      {R4,LR}
   \       0x16   0x.... 0x....      B.W      mbedtls_platform_zeroize
   \                     ??mbedtls_ccm_free_0: (+1)
   \       0x1A   0xBD10             POP      {R4,PC}
    102          }
    103          
    104          #define CCM_STATE__CLEAR                0
    105          #define CCM_STATE__STARTED              (1 << 0)
    106          #define CCM_STATE__LENGTHS_SET          (1 << 1)
    107          #define CCM_STATE__AUTH_DATA_STARTED    (1 << 2)
    108          #define CCM_STATE__AUTH_DATA_FINISHED   (1 << 3)
    109          #define CCM_STATE__ERROR                (1 << 4)
    110          
    111          /*
    112           * Encrypt or decrypt a partial block with CTR
    113           */

   \                                 In section .text, align 2, keep-with-next
    114          static int mbedtls_ccm_crypt(mbedtls_ccm_context *ctx,
    115                                       size_t offset, size_t use_len,
    116                                       const unsigned char *input,
    117                                       unsigned char *output)
    118          {
   \                     mbedtls_ccm_crypt: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   \        0xC   0xB086             SUB      SP,SP,#+24
    119              size_t olen = 0;
   \        0xE   0x2000             MOVS     R0,#+0
    120              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xAC02             ADD      R4,SP,#+8
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0x9001             STR      R0,[SP, #+4]
   \       0x1A   0xE884 0x000F      STM      R4,{R0-R3}
    121              unsigned char tmp_buf[16] = { 0 };
    122          
    123              if ((ret = mbedtls_cipher_update(&ctx->cipher_ctx, ctx->ctr, 16, tmp_buf,
    124                                               &olen)) != 0) {
   \       0x1E   0xA801             ADD      R0,SP,#+4
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xAB02             ADD      R3,SP,#+8
   \       0x24   0x2210             MOVS     R2,#+16
   \       0x26   0xF108 0x0110      ADD      R1,R8,#+16
   \       0x2A   0xF108 0x0038      ADD      R0,R8,#+56
   \       0x2E   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x32   0x0004             MOVS     R4,R0
   \       0x34   0xD00B             BEQ.N    ??mbedtls_ccm_crypt_0
    125                  ctx->state |= CCM_STATE__ERROR;
   \       0x36   0xF8D8 0x0080      LDR      R0,[R8, #+128]
    126                  mbedtls_platform_zeroize(tmp_buf, sizeof(tmp_buf));
   \       0x3A   0x2110             MOVS     R1,#+16
   \       0x3C   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x40   0xF8C8 0x0080      STR      R0,[R8, #+128]
   \       0x44   0xA802             ADD      R0,SP,#+8
   \       0x46   0x.... 0x....      BL       mbedtls_platform_zeroize
    127                  return ret;
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0xE00B             B.N      ??mbedtls_ccm_crypt_1
    128              }
   \                     ??mbedtls_ccm_crypt_0: (+1)
   \       0x4E   0x980C             LDR      R0,[SP, #+48]
    129          
    130              mbedtls_xor(output, input, tmp_buf + offset, use_len);
   \       0x50   0xA902             ADD      R1,SP,#+8
   \       0x52   0x194A             ADDS     R2,R1,R5
   \       0x54   0x4633             MOV      R3,R6
   \       0x56   0x4639             MOV      R1,R7
   \       0x58   0x.... 0x....      BL       mbedtls_xor
    131          
    132              mbedtls_platform_zeroize(tmp_buf, sizeof(tmp_buf));
   \       0x5C   0x2110             MOVS     R1,#+16
   \       0x5E   0xA802             ADD      R0,SP,#+8
   \       0x60   0x.... 0x....      BL       mbedtls_platform_zeroize
    133              return ret;
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_crypt_1: (+1)
   \       0x66   0xB006             ADD      SP,SP,#+24
   \       0x68   0xE8BD 0x81F0      POP      {R4-R8,PC}
    134          }
    135          
    136          static void mbedtls_ccm_clear_state(mbedtls_ccm_context *ctx)
    137          {
    138              ctx->state = CCM_STATE__CLEAR;
    139              memset(ctx->y, 0, 16);
    140              memset(ctx->ctr, 0, 16);
    141          }
    142          

   \                                 In section .text, align 2, keep-with-next
    143          static int ccm_calculate_first_block_if_ready(mbedtls_ccm_context *ctx)
    144          {
   \                     ccm_calculate_first_block_if_ready: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    145              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    146              unsigned char i;
    147              size_t len_left, olen;
    148          
    149              /* length calculation can be done only after both
    150               * mbedtls_ccm_starts() and mbedtls_ccm_set_lengths() have been executed
    151               */
    152              if (!(ctx->state & CCM_STATE__STARTED) || !(ctx->state & CCM_STATE__LENGTHS_SET)) {
   \        0x4   0xF894 0x0080      LDRB     R0,[R4, #+128]
   \        0x8   0xF000 0x0003      AND      R0,R0,#0x3
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD001             BEQ.N    ??ccm_calculate_first_block_if_ready_0
    153                  return 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD3E             POP      {R1-R5,PC}
    154              }
    155          
    156              /* CCM expects non-empty tag.
    157               * CCM* allows empty tag. For CCM* without tag, ignore plaintext length.
    158               */
    159              if (ctx->tag_len == 0) {
   \                     ??ccm_calculate_first_block_if_ready_0: (+1)
   \       0x14   0x6AA1             LDR      R1,[R4, #+40]
   \       0x16   0xF06F 0x000C      MVN      R0,#+12
   \       0x1A   0xB931             CBNZ.N   R1,??ccm_calculate_first_block_if_ready_1
    160                  if (ctx->mode == MBEDTLS_CCM_STAR_ENCRYPT || ctx->mode == MBEDTLS_CCM_STAR_DECRYPT) {
   \       0x1C   0x6B61             LDR      R1,[R4, #+52]
   \       0x1E   0x2903             CMP      R1,#+3
   \       0x20   0xBF18             IT       NE
   \       0x22   0x2902             CMPNE    R1,#+2
   \       0x24   0xD131             BNE.N    ??ccm_calculate_first_block_if_ready_2
    161                      ctx->plaintext_len = 0;
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x6221             STR      R1,[R4, #+32]
    162                  } else {
    163                      return MBEDTLS_ERR_CCM_BAD_INPUT;
    164                  }
    165              }
    166          
    167              /*
    168               * First block:
    169               * 0        .. 0        flags
    170               * 1        .. iv_len   nonce (aka iv)  - set by: mbedtls_ccm_starts()
    171               * iv_len+1 .. 15       length
    172               *
    173               * With flags as (bits):
    174               * 7        0
    175               * 6        add present?
    176               * 5 .. 3   (t - 2) / 2
    177               * 2 .. 0   q - 1
    178               */
    179              ctx->y[0] |= (ctx->add_len > 0) << 6;
   \                     ??ccm_calculate_first_block_if_ready_1: (+1)
   \       0x2A   0x6A61             LDR      R1,[R4, #+36]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xBF14             ITE      NE
   \       0x30   0x2240             MOVNE    R2,#+64
   \       0x32   0x2200             MOVEQ    R2,#+0
   \       0x34   0x7823             LDRB     R3,[R4, #+0]
   \       0x36   0x431A             ORRS     R2,R2,R3
   \       0x38   0x7022             STRB     R2,[R4, #+0]
    180              ctx->y[0] |= ((ctx->tag_len - 2) / 2) << 3;
   \       0x3A   0x6AA1             LDR      R1,[R4, #+40]
   \       0x3C   0x1E89             SUBS     R1,R1,#+2
   \       0x3E   0x0849             LSRS     R1,R1,#+1
   \       0x40   0xEA42 0x02C1      ORR      R2,R2,R1, LSL #+3
   \       0x44   0x7022             STRB     R2,[R4, #+0]
    181              ctx->y[0] |= ctx->q - 1;
   \       0x46   0x6B23             LDR      R3,[R4, #+48]
   \       0x48   0x1E59             SUBS     R1,R3,#+1
   \       0x4A   0x430A             ORRS     R2,R1,R2
   \       0x4C   0x7022             STRB     R2,[R4, #+0]
    182          
    183              for (i = 0, len_left = ctx->plaintext_len; i < ctx->q; i++, len_left >>= 8) {
   \       0x4E   0x2300             MOVS     R3,#+0
   \       0x50   0x6A21             LDR      R1,[R4, #+32]
   \       0x52   0xE005             B.N      ??ccm_calculate_first_block_if_ready_3
    184                  ctx->y[15-i] = MBEDTLS_BYTE_0(len_left);
   \                     ??ccm_calculate_first_block_if_ready_4: (+1)
   \       0x54   0xB2DA             UXTB     R2,R3
   \       0x56   0x4252             RSBS     R2,R2,#+0
   \       0x58   0x4422             ADD      R2,R4,R2
   \       0x5A   0x73D1             STRB     R1,[R2, #+15]
    185              }
   \       0x5C   0x1C5B             ADDS     R3,R3,#+1
   \       0x5E   0x0A09             LSRS     R1,R1,#+8
   \                     ??ccm_calculate_first_block_if_ready_3: (+1)
   \       0x60   0x6B22             LDR      R2,[R4, #+48]
   \       0x62   0xB2DD             UXTB     R5,R3
   \       0x64   0x4295             CMP      R5,R2
   \       0x66   0xD3F5             BCC.N    ??ccm_calculate_first_block_if_ready_4
    186          
    187              if (len_left > 0) {
   \       0x68   0xB949             CBNZ.N   R1,??ccm_calculate_first_block_if_ready_5
    188                  ctx->state |= CCM_STATE__ERROR;
    189                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    190              }
    191          
    192              /* Start CBC-MAC with first block*/
    193              if ((ret = mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
   \       0x6A   0xA801             ADD      R0,SP,#+4
   \       0x6C   0x9000             STR      R0,[SP, #+0]
   \       0x6E   0x4623             MOV      R3,R4
   \       0x70   0x2210             MOVS     R2,#+16
   \       0x72   0x4621             MOV      R1,R4
   \       0x74   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x78   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x7C   0xB128             CBZ.N    R0,??ccm_calculate_first_block_if_ready_2
    194                  ctx->state |= CCM_STATE__ERROR;
   \                     ??ccm_calculate_first_block_if_ready_5: (+1)
   \       0x7E   0xF8D4 0x1080      LDR      R1,[R4, #+128]
   \       0x82   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0x86   0xF8C4 0x1080      STR      R1,[R4, #+128]
    195                  return ret;
    196              }
    197          
    198              return 0;
   \                     ??ccm_calculate_first_block_if_ready_2: (+1)
   \       0x8A   0xBD3E             POP      {R1-R5,PC}
    199          }
    200          

   \                                 In section .text, align 2, keep-with-next
    201          int mbedtls_ccm_starts(mbedtls_ccm_context *ctx,
    202                                 int mode,
    203                                 const unsigned char *iv,
    204                                 size_t iv_len)
    205          {
   \                     mbedtls_ccm_starts: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x461D             MOV      R5,R3
    206              /* Also implies q is within bounds */
    207              if (iv_len < 7 || iv_len > 13) {
   \        0x6   0x1FE8             SUBS     R0,R5,#+7
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x2807             CMP      R0,#+7
   \        0xC   0xD300             BCC.N    ??mbedtls_ccm_starts_0
    208                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \        0xE   0x....             B.N      ?Subroutine0
    209              }
    210          
    211              ctx->mode = mode;
    212              ctx->q = 16 - 1 - (unsigned char) iv_len;
   \                     ??mbedtls_ccm_starts_0: (+1)
   \       0x10   0xB2E8             UXTB     R0,R5
   \       0x12   0xF1C0 0x000F      RSB      R0,R0,#+15
   \       0x16   0x6361             STR      R1,[R4, #+52]
   \       0x18   0x6320             STR      R0,[R4, #+48]
    213          
    214              /*
    215               * Prepare counter block for encryption:
    216               * 0        .. 0        flags
    217               * 1        .. iv_len   nonce (aka iv)
    218               * iv_len+1 .. 15       counter (initially 1)
    219               *
    220               * With flags as (bits):
    221               * 7 .. 3   0
    222               * 2 .. 0   q - 1
    223               */
    224              memset(ctx->ctr, 0, 16);
   \       0x1A   0xF104 0x0710      ADD      R7,R4,#+16
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0xE887 0x000F      STM      R7,{R0-R3}
    225              ctx->ctr[0] = ctx->q - 1;
   \       0x2A   0x6B23             LDR      R3,[R4, #+48]
    226              memcpy(ctx->ctr + 1, iv, iv_len);
   \       0x2C   0x462A             MOV      R2,R5
   \       0x2E   0x4631             MOV      R1,R6
   \       0x30   0x1E58             SUBS     R0,R3,#+1
   \       0x32   0x7420             STRB     R0,[R4, #+16]
   \       0x34   0xF104 0x0011      ADD      R0,R4,#+17
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy
    227              memset(ctx->ctr + 1 + iv_len, 0, ctx->q);
   \       0x3C   0x6B21             LDR      R1,[R4, #+48]
   \       0x3E   0xF104 0x0011      ADD      R0,R4,#+17
   \       0x42   0x4428             ADD      R0,R0,R5
   \       0x44   0x.... 0x....      BL       __aeabi_memclr
    228              ctx->ctr[15] = 1;
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0x77E1             STRB     R1,[R4, #+31]
    229          
    230              /*
    231               * See ccm_calculate_first_block_if_ready() for block layout description
    232               */
    233              memcpy(ctx->y + 1, iv, iv_len);
   \       0x4C   0x462A             MOV      R2,R5
   \       0x4E   0x4631             MOV      R1,R6
   \       0x50   0x1C60             ADDS     R0,R4,#+1
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
    234          
    235              ctx->state |= CCM_STATE__STARTED;
   \       0x56   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x5A   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x5E   0xF8C4 0x0080      STR      R0,[R4, #+128]
    236              return ccm_calculate_first_block_if_ready(ctx);
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x68   0x....             B.N      ccm_calculate_first_block_if_ready
    237          }
    238          

   \                                 In section .text, align 2, keep-with-next
    239          int mbedtls_ccm_set_lengths(mbedtls_ccm_context *ctx,
    240                                      size_t total_ad_len,
    241                                      size_t plaintext_len,
    242                                      size_t tag_len)
    243          {
   \                     mbedtls_ccm_set_lengths: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    244              /*
    245               * Check length requirements: SP800-38C A.1
    246               * Additional requirement: a < 2^16 - 2^8 to simplify the code.
    247               * 'length' checked later (when writing it to the first block)
    248               *
    249               * Also, loosen the requirements to enable support for CCM* (IEEE 802.15.4).
    250               */
    251              if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
   \        0x4   0xF06F 0x000C      MVN      R0,#+12
   \        0x8   0x2B02             CMP      R3,#+2
   \        0xA   0xD015             BEQ.N    ??mbedtls_ccm_set_lengths_0
   \        0xC   0x2B11             CMP      R3,#+17
   \        0xE   0xD213             BCS.N    ??mbedtls_ccm_set_lengths_0
   \       0x10   0x07DD             LSLS     R5,R3,#+31
   \       0x12   0xD411             BMI.N    ??mbedtls_ccm_set_lengths_0
    252                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    253              }
    254          
    255              if (total_ad_len >= 0xFF00) {
   \       0x14   0xF5B1 0x4F7F      CMP      R1,#+65280
   \       0x18   0xD20E             BCS.N    ??mbedtls_ccm_set_lengths_0
    256                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    257              }
    258          
    259              ctx->plaintext_len = plaintext_len;
    260              ctx->add_len = total_ad_len;
    261              ctx->tag_len = tag_len;
    262              ctx->processed = 0;
    263          
    264              ctx->state |= CCM_STATE__LENGTHS_SET;
   \       0x1A   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x1E   0x6261             STR      R1,[R4, #+36]
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x26   0xF8C4 0x0080      STR      R0,[R4, #+128]
   \       0x2A   0x6222             STR      R2,[R4, #+32]
   \       0x2C   0x62A3             STR      R3,[R4, #+40]
   \       0x2E   0x62E1             STR      R1,[R4, #+44]
    265              return ccm_calculate_first_block_if_ready(ctx);
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x36   0x....             B.N      ccm_calculate_first_block_if_ready
   \                     ??mbedtls_ccm_set_lengths_0: (+1)
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
    266          }
    267          

   \                                 In section .text, align 2, keep-with-next
    268          int mbedtls_ccm_update_ad(mbedtls_ccm_context *ctx,
    269                                    const unsigned char *add,
    270                                    size_t add_len)
    271          {
   \                     mbedtls_ccm_update_ad: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4688             MOV      R8,R1
    272              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    273              size_t olen, use_len, offset;
    274          
    275              if (ctx->state & CCM_STATE__ERROR) {
   \        0x8   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \        0xC   0x4614             MOV      R4,R2
   \        0xE   0x06C8             LSLS     R0,R1,#+27
   \       0x10   0xD450             BMI.N    ??mbedtls_ccm_update_ad_0
    276                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    277              }
    278          
    279              if (add_len > 0) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD047             BEQ.N    ??mbedtls_ccm_update_ad_1
    280                  if (ctx->state & CCM_STATE__AUTH_DATA_FINISHED) {
   \       0x16   0x0708             LSLS     R0,R1,#+28
   \       0x18   0xD44C             BMI.N    ??mbedtls_ccm_update_ad_0
    281                      return MBEDTLS_ERR_CCM_BAD_INPUT;
    282                  }
    283          
    284                  if (!(ctx->state & CCM_STATE__AUTH_DATA_STARTED)) {
   \       0x1A   0x6A68             LDR      R0,[R5, #+36]
   \       0x1C   0x0749             LSLS     R1,R1,#+29
   \       0x1E   0xD445             BMI.N    ??mbedtls_ccm_update_ad_2
    285                      if (add_len > ctx->add_len) {
   \       0x20   0x42A0             CMP      R0,R4
   \       0x22   0xD347             BCC.N    ??mbedtls_ccm_update_ad_0
    286                          return MBEDTLS_ERR_CCM_BAD_INPUT;
    287                      }
    288          
    289                      ctx->y[0] ^= (unsigned char) ((ctx->add_len >> 8) & 0xFF);
   \       0x24   0x782A             LDRB     R2,[R5, #+0]
   \       0x26   0xEA82 0x2010      EOR      R0,R2,R0, LSR #+8
   \       0x2A   0x7028             STRB     R0,[R5, #+0]
    290                      ctx->y[1] ^= (unsigned char) ((ctx->add_len) & 0xFF);
   \       0x2C   0x7869             LDRB     R1,[R5, #+1]
   \       0x2E   0x6A68             LDR      R0,[R5, #+36]
   \       0x30   0x4041             EORS     R1,R0,R1
   \       0x32   0x7069             STRB     R1,[R5, #+1]
    291          
    292                      ctx->state |= CCM_STATE__AUTH_DATA_STARTED;
   \       0x34   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \       0x38   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x3C   0xF8C5 0x1080      STR      R1,[R5, #+128]
    293                  } else if (ctx->processed + add_len > ctx->add_len) {
    294                      return MBEDTLS_ERR_CCM_BAD_INPUT;
    295                  }
    296          
    297                  while (add_len > 0) {
    298                      offset = (ctx->processed + 2) % 16; /* account for y[0] and y[1]
   \                     ??mbedtls_ccm_update_ad_3: (+1)
   \       0x40   0x6AEF             LDR      R7,[R5, #+44]
    299                                                           * holding total auth data length */
    300                      use_len = 16 - offset;
    301          
    302                      if (use_len > add_len) {
   \       0x42   0x4626             MOV      R6,R4
   \       0x44   0x1CBF             ADDS     R7,R7,#+2
   \       0x46   0xF007 0x070F      AND      R7,R7,#0xF
   \       0x4A   0xF1C7 0x0010      RSB      R0,R7,#+16
   \       0x4E   0x4284             CMP      R4,R0
   \       0x50   0xBF88             IT       HI
   \       0x52   0x4606             MOVHI    R6,R0
    303                          use_len = add_len;
    304                      }
    305          
    306                      mbedtls_xor(ctx->y + offset, ctx->y + offset, add, use_len);
   \       0x54   0x19E8             ADDS     R0,R5,R7
   \       0x56   0x4633             MOV      R3,R6
   \       0x58   0x4642             MOV      R2,R8
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x.... 0x....      BL       mbedtls_xor
    307          
    308                      ctx->processed += use_len;
   \       0x60   0x6AE8             LDR      R0,[R5, #+44]
    309                      add_len -= use_len;
   \       0x62   0x1BA4             SUBS     R4,R4,R6
    310                      add += use_len;
    311          
    312                      if (use_len + offset == 16 || ctx->processed == ctx->add_len) {
   \       0x64   0x19BF             ADDS     R7,R7,R6
   \       0x66   0x1830             ADDS     R0,R6,R0
   \       0x68   0x62E8             STR      R0,[R5, #+44]
   \       0x6A   0x44B0             ADD      R8,R8,R6
   \       0x6C   0x2F10             CMP      R7,#+16
   \       0x6E   0xBF1C             ITT      NE
   \       0x70   0x6A69             LDRNE    R1,[R5, #+36]
   \       0x72   0x4288             CMPNE    R0,R1
   \       0x74   0xD109             BNE.N    ??mbedtls_ccm_update_ad_4
    313                          if ((ret =
    314                                   mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
   \       0x76   0xA801             ADD      R0,SP,#+4
   \       0x78   0x9000             STR      R0,[SP, #+0]
   \       0x7A   0x462B             MOV      R3,R5
   \       0x7C   0x2210             MOVS     R2,#+16
   \       0x7E   0x4629             MOV      R1,R5
   \       0x80   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x84   0x.... 0x....      BL       mbedtls_cipher_update
   \       0x88   0xB9B8             CBNZ.N   R0,??mbedtls_ccm_update_ad_5
   \                     ??mbedtls_ccm_update_ad_4: (+1)
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD1D8             BNE.N    ??mbedtls_ccm_update_ad_3
    315                              ctx->state |= CCM_STATE__ERROR;
    316                              return ret;
    317                          }
    318                      }
    319                  }
    320          
    321                  if (ctx->processed == ctx->add_len) {
   \       0x8E   0x6AE9             LDR      R1,[R5, #+44]
   \       0x90   0x6A68             LDR      R0,[R5, #+36]
   \       0x92   0x4281             CMP      R1,R0
   \       0x94   0xD107             BNE.N    ??mbedtls_ccm_update_ad_1
    322                      ctx->state |= CCM_STATE__AUTH_DATA_FINISHED;
   \       0x96   0xF8D5 0x1080      LDR      R1,[R5, #+128]
    323                      ctx->processed = 0; // prepare for mbedtls_ccm_update()
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x62E8             STR      R0,[R5, #+44]
   \       0x9E   0xF041 0x0108      ORR      R1,R1,#0x8
   \       0xA2   0xF8C5 0x1080      STR      R1,[R5, #+128]
    324                  }
    325              }
    326          
    327              return 0;
   \                     ??mbedtls_ccm_update_ad_1: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_update_ad_6: (+1)
   \       0xA8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   \                     ??mbedtls_ccm_update_ad_2: (+1)
   \       0xAC   0x6AE9             LDR      R1,[R5, #+44]
   \       0xAE   0x1861             ADDS     R1,R4,R1
   \       0xB0   0x4288             CMP      R0,R1
   \       0xB2   0xD2C5             BCS.N    ??mbedtls_ccm_update_ad_3
   \                     ??mbedtls_ccm_update_ad_0: (+1)
   \       0xB4   0xF06F 0x000C      MVN      R0,#+12
   \       0xB8   0xE7F6             B.N      ??mbedtls_ccm_update_ad_6
   \                     ??mbedtls_ccm_update_ad_5: (+1)
   \       0xBA   0xF8D5 0x1080      LDR      R1,[R5, #+128]
   \       0xBE   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0xC2   0xF8C5 0x1080      STR      R1,[R5, #+128]
   \       0xC6   0xE7EF             B.N      ??mbedtls_ccm_update_ad_6
    328          }
    329          

   \                                 In section .text, align 2, keep-with-next
    330          int mbedtls_ccm_update(mbedtls_ccm_context *ctx,
    331                                 const unsigned char *input, size_t input_len,
    332                                 unsigned char *output, size_t output_size,
    333                                 size_t *output_len)
    334          {
   \                     mbedtls_ccm_update: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4607             MOV      R7,R0
    335              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    336              unsigned char i;
    337              size_t use_len, offset, olen;
    338          
    339              unsigned char local_output[16];
    340          
    341              if (ctx->state & CCM_STATE__ERROR) {
   \        0x8   0xF897 0x0080      LDRB     R0,[R7, #+128]
   \        0xC   0x06C4             LSLS     R4,R0,#+27
   \        0xE   0xD40A             BMI.N    ??mbedtls_ccm_update_0
    342                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    343              }
    344          
    345              /* Check against plaintext length only if performing operation with
    346               * authentication
    347               */
    348              if (ctx->tag_len != 0 && ctx->processed + input_len > ctx->plaintext_len) {
   \       0x10   0x6AB8             LDR      R0,[R7, #+40]
   \       0x12   0x4615             MOV      R5,R2
   \       0x14   0xB120             CBZ.N    R0,??mbedtls_ccm_update_1
   \       0x16   0x6AF8             LDR      R0,[R7, #+44]
   \       0x18   0x6A3A             LDR      R2,[R7, #+32]
   \       0x1A   0x1828             ADDS     R0,R5,R0
   \       0x1C   0x4282             CMP      R2,R0
   \       0x1E   0xD302             BCC.N    ??mbedtls_ccm_update_0
   \                     ??mbedtls_ccm_update_1: (+1)
   \       0x20   0x9810             LDR      R0,[SP, #+64]
    349                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    350              }
    351          
    352              if (output_size < input_len) {
   \       0x22   0x42A8             CMP      R0,R5
   \       0x24   0xD202             BCS.N    ??mbedtls_ccm_update_2
    353                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \                     ??mbedtls_ccm_update_0: (+1)
   \       0x26   0xF06F 0x000C      MVN      R0,#+12
   \       0x2A   0xE07E             B.N      ??mbedtls_ccm_update_3
    354              }
   \                     ??mbedtls_ccm_update_2: (+1)
   \       0x2C   0x9811             LDR      R0,[SP, #+68]
    355              *output_len = input_len;
    356          
    357              ret = 0;
   \       0x2E   0x2400             MOVS     R4,#+0
   \       0x30   0x468A             MOV      R10,R1
   \       0x32   0x6005             STR      R5,[R0, #+0]
   \       0x34   0x469B             MOV      R11,R3
   \       0x36   0xE010             B.N      ??mbedtls_ccm_update_4
    358          
    359              while (input_len > 0) {
    360                  offset = ctx->processed % 16;
    361          
    362                  use_len = 16 - offset;
    363          
    364                  if (use_len > input_len) {
    365                      use_len = input_len;
    366                  }
    367          
    368                  ctx->processed += use_len;
    369          
    370                  if (ctx->mode == MBEDTLS_CCM_ENCRYPT || \
    371                      ctx->mode == MBEDTLS_CCM_STAR_ENCRYPT) {
    372                      mbedtls_xor(ctx->y + offset, ctx->y + offset, input, use_len);
    373          
    374                      if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
    375                          if ((ret =
    376                                   mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
    377                              ctx->state |= CCM_STATE__ERROR;
    378                              goto exit;
    379                          }
    380                      }
    381          
    382                      ret = mbedtls_ccm_crypt(ctx, offset, use_len, input, output);
    383                      if (ret != 0) {
    384                          goto exit;
    385                      }
    386                  }
    387          
    388                  if (ctx->mode == MBEDTLS_CCM_DECRYPT || \
    389                      ctx->mode == MBEDTLS_CCM_STAR_DECRYPT) {
    390                      /* Since output may be in shared memory, we cannot be sure that
    391                       * it will contain what we wrote to it. Therefore, we should avoid using
    392                       * it as input to any operations.
    393                       * Write decrypted data to local_output to avoid using output variable as
    394                       * input in the XOR operation for Y.
    395                       */
    396                      ret = mbedtls_ccm_crypt(ctx, offset, use_len, input, local_output);
    397                      if (ret != 0) {
    398                          goto exit;
    399                      }
    400          
    401                      mbedtls_xor(ctx->y + offset, ctx->y + offset, local_output, use_len);
    402          
    403                      memcpy(output, local_output, use_len);
    404          
    405                      if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
    406                          if ((ret =
    407                                   mbedtls_cipher_update(&ctx->cipher_ctx, ctx->y, 16, ctx->y, &olen)) != 0) {
    408                              ctx->state |= CCM_STATE__ERROR;
    409                              goto exit;
    410                          }
    411                      }
    412                  }
    413          
    414                  if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
    415                      for (i = 0; i < ctx->q; i++) {
   \                     ??mbedtls_ccm_update_5: (+1)
   \       0x38   0x1C40             ADDS     R0,R0,#+1
   \       0x3A   0xB2C0             UXTB     R0,R0
   \                     ??mbedtls_ccm_update_6: (+1)
   \       0x3C   0x6B39             LDR      R1,[R7, #+48]
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD207             BCS.N    ??mbedtls_ccm_update_7
    416                          if (++(ctx->ctr)[15-i] != 0) {
   \       0x42   0x4241             RSBS     R1,R0,#+0
   \       0x44   0x187A             ADDS     R2,R7,R1
   \       0x46   0x7FD1             LDRB     R1,[R2, #+31]
   \       0x48   0x1C49             ADDS     R1,R1,#+1
   \       0x4A   0x77D1             STRB     R1,[R2, #+31]
   \       0x4C   0xB2C9             UXTB     R1,R1
   \       0x4E   0x2900             CMP      R1,#+0
   \       0x50   0xD0F2             BEQ.N    ??mbedtls_ccm_update_5
    417                              break;
    418                          }
    419                      }
    420                  }
    421          
    422                  input_len -= use_len;
   \                     ??mbedtls_ccm_update_7: (+1)
   \       0x52   0xEBA5 0x0509      SUB      R5,R5,R9
    423                  input += use_len;
   \       0x56   0x44CA             ADD      R10,R10,R9
    424                  output += use_len;
   \       0x58   0x44CB             ADD      R11,R11,R9
   \                     ??mbedtls_ccm_update_4: (+1)
   \       0x5A   0x2D00             CMP      R5,#+0
   \       0x5C   0xD060             BEQ.N    ??mbedtls_ccm_update_8
   \       0x5E   0x6AF8             LDR      R0,[R7, #+44]
   \       0x60   0x46A9             MOV      R9,R5
   \       0x62   0xF000 0x080F      AND      R8,R0,#0xF
   \       0x66   0xF1C8 0x0110      RSB      R1,R8,#+16
   \       0x6A   0x428D             CMP      R5,R1
   \       0x6C   0xBF88             IT       HI
   \       0x6E   0x4689             MOVHI    R9,R1
   \       0x70   0x4448             ADD      R0,R9,R0
   \       0x72   0x62F8             STR      R0,[R7, #+44]
   \       0x74   0xEB07 0x0008      ADD      R0,R7,R8
   \       0x78   0x9002             STR      R0,[SP, #+8]
   \       0x7A   0x6B78             LDR      R0,[R7, #+52]
   \       0x7C   0xEB08 0x0609      ADD      R6,R8,R9
   \       0x80   0x2801             CMP      R0,#+1
   \       0x82   0xBF18             IT       NE
   \       0x84   0x2803             CMPNE    R0,#+3
   \       0x86   0xD119             BNE.N    ??mbedtls_ccm_update_9
   \       0x88   0x9902             LDR      R1,[SP, #+8]
   \       0x8A   0x464B             MOV      R3,R9
   \       0x8C   0x4652             MOV      R2,R10
   \       0x8E   0x4608             MOV      R0,R1
   \       0x90   0x.... 0x....      BL       mbedtls_xor
   \       0x94   0x2E10             CMP      R6,#+16
   \       0x96   0xBF1E             ITTT     NE
   \       0x98   0x6AF9             LDRNE    R1,[R7, #+44]
   \       0x9A   0x6A38             LDRNE    R0,[R7, #+32]
   \       0x9C   0x4281             CMPNE    R1,R0
   \       0x9E   0xD103             BNE.N    ??mbedtls_ccm_update_10
   \       0xA0   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xA4   0x0004             MOVS     R4,R0
   \       0xA6   0xD135             BNE.N    ??mbedtls_ccm_update_11
   \                     ??mbedtls_ccm_update_10: (+1)
   \       0xA8   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \       0xAC   0x4653             MOV      R3,R10
   \       0xAE   0x464A             MOV      R2,R9
   \       0xB0   0x4641             MOV      R1,R8
   \       0xB2   0x4638             MOV      R0,R7
   \       0xB4   0x.... 0x....      BL       mbedtls_ccm_crypt
   \       0xB8   0x0004             MOVS     R4,R0
   \       0xBA   0xD131             BNE.N    ??mbedtls_ccm_update_8
   \                     ??mbedtls_ccm_update_9: (+1)
   \       0xBC   0x6B78             LDR      R0,[R7, #+52]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xBF18             IT       NE
   \       0xC2   0x2802             CMPNE    R0,#+2
   \       0xC4   0xD11E             BNE.N    ??mbedtls_ccm_update_12
   \       0xC6   0xA803             ADD      R0,SP,#+12
   \       0xC8   0x9000             STR      R0,[SP, #+0]
   \       0xCA   0x4653             MOV      R3,R10
   \       0xCC   0x464A             MOV      R2,R9
   \       0xCE   0x4641             MOV      R1,R8
   \       0xD0   0x4638             MOV      R0,R7
   \       0xD2   0x.... 0x....      BL       mbedtls_ccm_crypt
   \       0xD6   0x0004             MOVS     R4,R0
   \       0xD8   0xD122             BNE.N    ??mbedtls_ccm_update_8
   \       0xDA   0x9902             LDR      R1,[SP, #+8]
   \       0xDC   0x464B             MOV      R3,R9
   \       0xDE   0xAA03             ADD      R2,SP,#+12
   \       0xE0   0x4608             MOV      R0,R1
   \       0xE2   0x.... 0x....      BL       mbedtls_xor
   \       0xE6   0x464A             MOV      R2,R9
   \       0xE8   0xA903             ADD      R1,SP,#+12
   \       0xEA   0x4658             MOV      R0,R11
   \       0xEC   0x.... 0x....      BL       __aeabi_memcpy
   \       0xF0   0x2E10             CMP      R6,#+16
   \       0xF2   0xBF1E             ITTT     NE
   \       0xF4   0x6AF9             LDRNE    R1,[R7, #+44]
   \       0xF6   0x6A38             LDRNE    R0,[R7, #+32]
   \       0xF8   0x4281             CMPNE    R1,R0
   \       0xFA   0xD105             BNE.N    ??mbedtls_ccm_update_13
   \       0xFC   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_0: (+1)
   \      0x100   0x0004             MOVS     R4,R0
   \      0x102   0xD107             BNE.N    ??mbedtls_ccm_update_11
   \                     ??mbedtls_ccm_update_12: (+1)
   \      0x104   0x2E10             CMP      R6,#+16
   \      0x106   0xD003             BEQ.N    ??mbedtls_ccm_update_14
   \                     ??mbedtls_ccm_update_13: (+1)
   \      0x108   0x6AF9             LDR      R1,[R7, #+44]
   \      0x10A   0x6A38             LDR      R0,[R7, #+32]
   \      0x10C   0x4281             CMP      R1,R0
   \      0x10E   0xD1A0             BNE.N    ??mbedtls_ccm_update_7
   \                     ??mbedtls_ccm_update_14: (+1)
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0xE793             B.N      ??mbedtls_ccm_update_6
   \                     ??mbedtls_ccm_update_11: (+1)
   \      0x114   0xF8D7 0x0080      LDR      R0,[R7, #+128]
   \      0x118   0xF040 0x0010      ORR      R0,R0,#0x10
   \      0x11C   0xF8C7 0x0080      STR      R0,[R7, #+128]
    425              }
    426          
    427          exit:
    428              mbedtls_platform_zeroize(local_output, 16);
   \                     ??mbedtls_ccm_update_8: (+1)
   \      0x120   0x2110             MOVS     R1,#+16
   \      0x122   0xA803             ADD      R0,SP,#+12
   \      0x124   0x.... 0x....      BL       mbedtls_platform_zeroize
    429          
    430              return ret;
   \      0x128   0x4620             MOV      R0,R4
   \                     ??mbedtls_ccm_update_3: (+1)
   \      0x12A   0xB007             ADD      SP,SP,#+28
   \      0x12C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    431          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xA901             ADD      R1,SP,#+4
   \        0x2   0x9100             STR      R1,[SP, #+0]
   \        0x4   0x463B             MOV      R3,R7
   \        0x6   0x2210             MOVS     R2,#+16
   \        0x8   0x4639             MOV      R1,R7
   \        0xA   0xF107 0x0038      ADD      R0,R7,#+56
   \        0xE   0x.... 0x....      B.W      mbedtls_cipher_update
    432          

   \                                 In section .text, align 2, keep-with-next
    433          int mbedtls_ccm_finish(mbedtls_ccm_context *ctx,
    434                                 unsigned char *tag, size_t tag_len)
    435          {
   \                     mbedtls_ccm_finish: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
    436              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    437              unsigned char i;
    438          
    439              if (ctx->state & CCM_STATE__ERROR) {
   \        0x6   0xF8D6 0x1080      LDR      R1,[R6, #+128]
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x06C8             LSLS     R0,R1,#+27
   \        0xE   0xD502             BPL.N    ??mbedtls_ccm_finish_0
    440                  return MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
   \       0x10   0xF06F 0x006D      MVN      R0,#+109
   \       0x14   0xBD76             POP      {R1,R2,R4-R6,PC}
    441              }
    442          
    443              if (ctx->add_len > 0 && !(ctx->state & CCM_STATE__AUTH_DATA_FINISHED)) {
   \                     ??mbedtls_ccm_finish_0: (+1)
   \       0x16   0x6A70             LDR      R0,[R6, #+36]
   \       0x18   0xB108             CBZ.N    R0,??mbedtls_ccm_finish_1
   \       0x1A   0x0708             LSLS     R0,R1,#+28
   \       0x1C   0xD505             BPL.N    ??mbedtls_ccm_finish_2
    444                  return MBEDTLS_ERR_CCM_BAD_INPUT;
    445              }
    446          
    447              if (ctx->plaintext_len > 0 && ctx->processed != ctx->plaintext_len) {
   \                     ??mbedtls_ccm_finish_1: (+1)
   \       0x1E   0x6A30             LDR      R0,[R6, #+32]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xBF1C             ITT      NE
   \       0x24   0x6AF1             LDRNE    R1,[R6, #+44]
   \       0x26   0x4281             CMPNE    R1,R0
   \       0x28   0xD002             BEQ.N    ??mbedtls_ccm_finish_3
    448                  return MBEDTLS_ERR_CCM_BAD_INPUT;
   \                     ??mbedtls_ccm_finish_2: (+1)
   \       0x2A   0xF06F 0x000C      MVN      R0,#+12
   \       0x2E   0xBD76             POP      {R1,R2,R4-R6,PC}
    449              }
    450          
    451              /*
    452               * Authentication: reset counter and crypt/mask internal tag
    453               */
    454              for (i = 0; i < ctx->q; i++) {
   \                     ??mbedtls_ccm_finish_3: (+1)
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0xE004             B.N      ??mbedtls_ccm_finish_4
    455                  ctx->ctr[15-i] = 0;
   \                     ??mbedtls_ccm_finish_5: (+1)
   \       0x34   0x4252             RSBS     R2,R2,#+0
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x4432             ADD      R2,R6,R2
   \       0x3A   0x77D0             STRB     R0,[R2, #+31]
    456              }
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \                     ??mbedtls_ccm_finish_4: (+1)
   \       0x3E   0x6B30             LDR      R0,[R6, #+48]
   \       0x40   0xB2CA             UXTB     R2,R1
   \       0x42   0x4282             CMP      R2,R0
   \       0x44   0xD3F6             BCC.N    ??mbedtls_ccm_finish_5
    457          
    458              ret = mbedtls_ccm_crypt(ctx, 0, 16, ctx->y, ctx->y);
   \       0x46   0x9600             STR      R6,[SP, #+0]
   \       0x48   0x4633             MOV      R3,R6
   \       0x4A   0x2210             MOVS     R2,#+16
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x4630             MOV      R0,R6
   \       0x50   0x.... 0x....      BL       mbedtls_ccm_crypt
    459              if (ret != 0) {
   \       0x54   0xB988             CBNZ.N   R0,??mbedtls_ccm_finish_6
    460                  return ret;
    461              }
    462              if (tag != NULL) {
   \       0x56   0xB124             CBZ.N    R4,??mbedtls_ccm_finish_7
    463                  memcpy(tag, ctx->y, tag_len);
   \       0x58   0x462A             MOV      R2,R5
   \       0x5A   0x4631             MOV      R1,R6
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy
    464              }
    465              mbedtls_ccm_clear_state(ctx);
   \                     ??mbedtls_ccm_finish_7: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF8C6 0x0080      STR      R0,[R6, #+128]
   \       0x68   0x2300             MOVS     R3,#+0
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0xE886 0x000F      STM      R6,{R0-R3}
   \       0x72   0xF106 0x0410      ADD      R4,R6,#+16
   \       0x76   0xE884 0x000F      STM      R4,{R0-R3}
    466          
    467              return 0;
   \                     ??mbedtls_ccm_finish_6: (+1)
   \       0x7A   0xBD76             POP      {R1,R2,R4-R6,PC}
    468          }
    469          
    470          /*
    471           * Authenticated encryption or decryption
    472           */

   \                                 In section .text, align 2, keep-with-next
    473          static int ccm_auth_crypt(mbedtls_ccm_context *ctx, int mode, size_t length,
    474                                    const unsigned char *iv, size_t iv_len,
    475                                    const unsigned char *add, size_t add_len,
    476                                    const unsigned char *input, unsigned char *output,
    477                                    unsigned char *tag, size_t tag_len)
    478          {
   \                     ccm_auth_crypt: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x461A             MOV      R2,R3
   \        0x6   0x9B08             LDR      R3,[SP, #+32]
   \        0x8   0x4604             MOV      R4,R0
    479              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    480              size_t olen;
    481          
    482              if ((ret = mbedtls_ccm_starts(ctx, mode, iv, iv_len)) != 0) {
   \        0xA   0x.... 0x....      BL       mbedtls_ccm_starts
   \        0xE   0xB9E8             CBNZ.N   R0,??ccm_auth_crypt_0
    483                  return ret;
   \       0x10   0x9E0E             LDR      R6,[SP, #+56]
   \       0x12   0x9F0A             LDR      R7,[SP, #+40]
    484              }
    485          
    486              if ((ret = mbedtls_ccm_set_lengths(ctx, add_len, length, tag_len)) != 0) {
   \       0x14   0x462A             MOV      R2,R5
   \       0x16   0x4633             MOV      R3,R6
   \       0x18   0x4639             MOV      R1,R7
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       mbedtls_ccm_set_lengths
   \       0x20   0xB9A0             CBNZ.N   R0,??ccm_auth_crypt_0
    487                  return ret;
   \       0x22   0x9909             LDR      R1,[SP, #+36]
    488              }
    489          
    490              if ((ret = mbedtls_ccm_update_ad(ctx, add, add_len)) != 0) {
   \       0x24   0x463A             MOV      R2,R7
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       mbedtls_ccm_update_ad
   \       0x2C   0xB970             CBNZ.N   R0,??ccm_auth_crypt_0
    491                  return ret;
   \       0x2E   0x9B0C             LDR      R3,[SP, #+48]
   \       0x30   0x990B             LDR      R1,[SP, #+44]
    492              }
    493          
    494              if ((ret = mbedtls_ccm_update(ctx, input, length,
    495                                            output, length, &olen)) != 0) {
   \       0x32   0xA802             ADD      R0,SP,#+8
   \       0x34   0x9001             STR      R0,[SP, #+4]
   \       0x36   0x9500             STR      R5,[SP, #+0]
   \       0x38   0x462A             MOV      R2,R5
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x.... 0x....      BL       mbedtls_ccm_update
   \       0x40   0xB920             CBNZ.N   R0,??ccm_auth_crypt_0
    496                  return ret;
   \       0x42   0x990D             LDR      R1,[SP, #+52]
    497              }
    498          
    499              if ((ret = mbedtls_ccm_finish(ctx, tag, tag_len)) != 0) {
    500                  return ret;
   \       0x44   0x4632             MOV      R2,R6
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x.... 0x....      BL       mbedtls_ccm_finish
   \                     ??ccm_auth_crypt_0: (+1)
   \       0x4C   0xBDFE             POP      {R1-R7,PC}
    501              }
    502          
    503              return 0;
    504          }
    505          
    506          /*
    507           * Authenticated encryption
    508           */

   \                                 In section .text, align 2, keep-with-next
    509          int mbedtls_ccm_star_encrypt_and_tag(mbedtls_ccm_context *ctx, size_t length,
    510                                               const unsigned char *iv, size_t iv_len,
    511                                               const unsigned char *add, size_t add_len,
    512                                               const unsigned char *input, unsigned char *output,
    513                                               unsigned char *tag, size_t tag_len)
    514          {
   \                     mbedtls_ccm_star_encrypt_and_tag: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    515              return ccm_auth_crypt(ctx, MBEDTLS_CCM_STAR_ENCRYPT, length, iv, iv_len,
    516                                    add, add_len, input, output, tag, tag_len);
   \        0x4   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x8   0x2103             MOVS     R1,#+3
   \        0xA   0x....             B.N      ?Subroutine1
    517          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      BL       ccm_auth_crypt
   \        0x4   0xB007             ADD      SP,SP,#+28
   \        0x6   0xBD30             POP      {R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x9D0F             LDR      R5,[SP, #+60]
   \        0x2   0x9C0E             LDR      R4,[SP, #+56]
   \        0x4   0x9506             STR      R5,[SP, #+24]
   \        0x6   0x9D0D             LDR      R5,[SP, #+52]
   \        0x8   0x9405             STR      R4,[SP, #+20]
   \        0xA   0x9C0C             LDR      R4,[SP, #+48]
   \        0xC   0x9504             STR      R5,[SP, #+16]
   \        0xE   0x9D0B             LDR      R5,[SP, #+44]
   \       0x10   0x9403             STR      R4,[SP, #+12]
   \       0x12   0x9C0A             LDR      R4,[SP, #+40]
   \       0x14   0x9300             STR      R3,[SP, #+0]
   \       0x16   0x4613             MOV      R3,R2
   \       0x18   0x460A             MOV      R2,R1
   \       0x1A   0x9502             STR      R5,[SP, #+8]
   \       0x1C   0x9401             STR      R4,[SP, #+4]
   \       0x1E   0x4770             BX       LR
    518          

   \                                 In section .text, align 2, keep-with-next
    519          int mbedtls_ccm_encrypt_and_tag(mbedtls_ccm_context *ctx, size_t length,
    520                                          const unsigned char *iv, size_t iv_len,
    521                                          const unsigned char *add, size_t add_len,
    522                                          const unsigned char *input, unsigned char *output,
    523                                          unsigned char *tag, size_t tag_len)
    524          {
   \                     mbedtls_ccm_encrypt_and_tag: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    525              return ccm_auth_crypt(ctx, MBEDTLS_CCM_ENCRYPT, length, iv, iv_len,
    526                                    add, add_len, input, output, tag, tag_len);
   \        0x4   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA                      REQUIRE ?Subroutine1
   \        0xA                      ;; // Fall through to label ?Subroutine1
    527          }
    528          
    529          /*
    530           * Authenticated decryption
    531           */
    532          static int mbedtls_ccm_compare_tags(const unsigned char *tag1,
    533                                              const unsigned char *tag2,
    534                                              size_t tag_len)
    535          {
    536              /* Check tag in "constant-time" */
    537              int diff = mbedtls_ct_memcmp(tag1, tag2, tag_len);
    538          
    539              if (diff != 0) {
    540                  return MBEDTLS_ERR_CCM_AUTH_FAILED;
    541              }
    542          
    543              return 0;
    544          }
    545          

   \                                 In section .text, align 2, keep-with-next
    546          static int ccm_auth_decrypt(mbedtls_ccm_context *ctx, int mode, size_t length,
    547                                      const unsigned char *iv, size_t iv_len,
    548                                      const unsigned char *add, size_t add_len,
    549                                      const unsigned char *input, unsigned char *output,
    550                                      const unsigned char *tag, size_t tag_len)
    551          {
   \                     ccm_auth_decrypt: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4616             MOV      R6,R2
   \        0x4   0xB08B             SUB      SP,SP,#+44
    552              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    553              unsigned char check_tag[16];
    554          
    555              if ((ret = ccm_auth_crypt(ctx, mode, length,
    556                                        iv, iv_len, add, add_len,
    557                                        input, output, check_tag, tag_len)) != 0) {
   \        0x6   0xAA07             ADD      R2,SP,#+28
   \        0x8   0x9205             STR      R2,[SP, #+20]
   \        0xA   0x9A12             LDR      R2,[SP, #+72]
   \        0xC   0x9F13             LDR      R7,[SP, #+76]
   \        0xE   0x9C14             LDR      R4,[SP, #+80]
   \       0x10   0x9202             STR      R2,[SP, #+8]
   \       0x12   0x9703             STR      R7,[SP, #+12]
   \       0x14   0x9A10             LDR      R2,[SP, #+64]
   \       0x16   0x9D16             LDR      R5,[SP, #+88]
   \       0x18   0x9F11             LDR      R7,[SP, #+68]
   \       0x1A   0x9200             STR      R2,[SP, #+0]
   \       0x1C   0x9506             STR      R5,[SP, #+24]
   \       0x1E   0x9404             STR      R4,[SP, #+16]
   \       0x20   0x9701             STR      R7,[SP, #+4]
   \       0x22   0x4632             MOV      R2,R6
   \       0x24   0x.... 0x....      BL       ccm_auth_crypt
   \       0x28   0xB958             CBNZ.N   R0,??ccm_auth_decrypt_0
    558                  return ret;
   \       0x2A   0x9815             LDR      R0,[SP, #+84]
    559              }
    560          
    561              if ((ret = mbedtls_ccm_compare_tags(tag, check_tag, tag_len)) != 0) {
   \       0x2C   0x462A             MOV      R2,R5
   \       0x2E   0xA907             ADD      R1,SP,#+28
   \       0x30   0x.... 0x....      BL       mbedtls_ct_memcmp
   \       0x34   0xB128             CBZ.N    R0,??ccm_auth_decrypt_0
    562                  mbedtls_platform_zeroize(output, length);
   \       0x36   0x4631             MOV      R1,R6
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       mbedtls_platform_zeroize
    563                  return ret;
   \       0x3E   0xF06F 0x000E      MVN      R0,#+14
    564              }
    565          
    566              return 0;
   \                     ??ccm_auth_decrypt_0: (+1)
   \       0x42   0xB00B             ADD      SP,SP,#+44
   \       0x44   0xBDF0             POP      {R4-R7,PC}
    567          }
    568          

   \                                 In section .text, align 2, keep-with-next
    569          int mbedtls_ccm_star_auth_decrypt(mbedtls_ccm_context *ctx, size_t length,
    570                                            const unsigned char *iv, size_t iv_len,
    571                                            const unsigned char *add, size_t add_len,
    572                                            const unsigned char *input, unsigned char *output,
    573                                            const unsigned char *tag, size_t tag_len)
    574          {
   \                     mbedtls_ccm_star_auth_decrypt: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    575              return ccm_auth_decrypt(ctx, MBEDTLS_CCM_STAR_DECRYPT, length,
    576                                      iv, iv_len, add, add_len,
    577                                      input, output, tag, tag_len);
   \        0x4   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0x8   0x2102             MOVS     R1,#+2
   \        0xA   0x....             B.N      ?Subroutine2
    578          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x.... 0x....      BL       ccm_auth_decrypt
   \        0x4   0xB007             ADD      SP,SP,#+28
   \        0x6   0xBD30             POP      {R4,R5,PC}
    579          

   \                                 In section .text, align 2, keep-with-next
    580          int mbedtls_ccm_auth_decrypt(mbedtls_ccm_context *ctx, size_t length,
    581                                       const unsigned char *iv, size_t iv_len,
    582                                       const unsigned char *add, size_t add_len,
    583                                       const unsigned char *input, unsigned char *output,
    584                                       const unsigned char *tag, size_t tag_len)
    585          {
   \                     mbedtls_ccm_auth_decrypt: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
    586              return ccm_auth_decrypt(ctx, MBEDTLS_CCM_DECRYPT, length,
    587                                      iv, iv_len, add, add_len,
    588                                      input, output, tag, tag_len);
   \        0x4   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA                      REQUIRE ?Subroutine2
   \        0xA                      ;; // Fall through to label ?Subroutine2
    589          }
    590          #endif /* !MBEDTLS_CCM_ALT */
    591          
    592          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
    593          /*
    594           * Examples 1 to 3 from SP800-38C Appendix C
    595           */
    596          
    597          #define NB_TESTS 3
    598          #define CCM_SELFTEST_PT_MAX_LEN 24
    599          #define CCM_SELFTEST_CT_MAX_LEN 32
    600          /*
    601           * The data is the same for all tests, only the used length changes
    602           */
    603          static const unsigned char key_test_data[] = {
    604              0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    605              0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
    606          };
    607          
    608          static const unsigned char iv_test_data[] = {
    609              0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    610              0x18, 0x19, 0x1a, 0x1b
    611          };
    612          
    613          static const unsigned char ad_test_data[] = {
    614              0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    615              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    616              0x10, 0x11, 0x12, 0x13
    617          };
    618          
    619          static const unsigned char msg_test_data[CCM_SELFTEST_PT_MAX_LEN] = {
    620              0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    621              0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    622              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    623          };
    624          
    625          static const size_t iv_len_test_data[NB_TESTS] = { 7, 8,  12 };
    626          static const size_t add_len_test_data[NB_TESTS] = { 8, 16, 20 };
    627          static const size_t msg_len_test_data[NB_TESTS] = { 4, 16, 24 };
    628          static const size_t tag_len_test_data[NB_TESTS] = { 4, 6,  8  };
    629          
    630          static const unsigned char res_test_data[NB_TESTS][CCM_SELFTEST_CT_MAX_LEN] = {
    631              {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },
    632              {   0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,
    633                  0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,
    634                  0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd },
    635              {   0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,
    636                  0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,
    637                  0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,
    638                  0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51 }
    639          };
    640          
    641          int mbedtls_ccm_self_test(int verbose)
    642          {
    643              mbedtls_ccm_context ctx;
    644              /*
    645               * Some hardware accelerators require the input and output buffers
    646               * would be in RAM, because the flash is not accessible.
    647               * Use buffers on the stack to hold the test vectors data.
    648               */
    649              unsigned char plaintext[CCM_SELFTEST_PT_MAX_LEN];
    650              unsigned char ciphertext[CCM_SELFTEST_CT_MAX_LEN];
    651              size_t i;
    652              int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    653          
    654              mbedtls_ccm_init(&ctx);
    655          
    656              if (mbedtls_ccm_setkey(&ctx, MBEDTLS_CIPHER_ID_AES, key_test_data,
    657                                     8 * sizeof(key_test_data)) != 0) {
    658                  if (verbose != 0) {
    659                      mbedtls_printf("  CCM: setup failed");
    660                  }
    661          
    662                  return 1;
    663              }
    664          
    665              for (i = 0; i < NB_TESTS; i++) {
    666                  if (verbose != 0) {
    667                      mbedtls_printf("  CCM-AES #%u: ", (unsigned int) i + 1);
    668                  }
    669          
    670                  memset(plaintext, 0, CCM_SELFTEST_PT_MAX_LEN);
    671                  memset(ciphertext, 0, CCM_SELFTEST_CT_MAX_LEN);
    672                  memcpy(plaintext, msg_test_data, msg_len_test_data[i]);
    673          
    674                  ret = mbedtls_ccm_encrypt_and_tag(&ctx, msg_len_test_data[i],
    675                                                    iv_test_data, iv_len_test_data[i],
    676                                                    ad_test_data, add_len_test_data[i],
    677                                                    plaintext, ciphertext,
    678                                                    ciphertext + msg_len_test_data[i],
    679                                                    tag_len_test_data[i]);
    680          
    681                  if (ret != 0 ||
    682                      memcmp(ciphertext, res_test_data[i],
    683                             msg_len_test_data[i] + tag_len_test_data[i]) != 0) {
    684                      if (verbose != 0) {
    685                          mbedtls_printf("failed\n");
    686                      }
    687          
    688                      return 1;
    689                  }
    690                  memset(plaintext, 0, CCM_SELFTEST_PT_MAX_LEN);
    691          
    692                  ret = mbedtls_ccm_auth_decrypt(&ctx, msg_len_test_data[i],
    693                                                 iv_test_data, iv_len_test_data[i],
    694                                                 ad_test_data, add_len_test_data[i],
    695                                                 ciphertext, plaintext,
    696                                                 ciphertext + msg_len_test_data[i],
    697                                                 tag_len_test_data[i]);
    698          
    699                  if (ret != 0 ||
    700                      memcmp(plaintext, msg_test_data, msg_len_test_data[i]) != 0) {
    701                      if (verbose != 0) {
    702                          mbedtls_printf("failed\n");
    703                      }
    704          
    705                      return 1;
    706                  }
    707          
    708                  if (verbose != 0) {
    709                      mbedtls_printf("passed\n");
    710                  }
    711              }
    712          
    713              mbedtls_ccm_free(&ctx);
    714          
    715              if (verbose != 0) {
    716                  mbedtls_printf("\n");
    717              }
    718          
    719              return 0;
    720          }
    721          
    722          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
    723          
    724          #endif /* MBEDTLS_CCM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ccm_auth_crypt
        32   -> mbedtls_ccm_finish
        32   -> mbedtls_ccm_set_lengths
        32   -> mbedtls_ccm_starts
        32   -> mbedtls_ccm_update
        32   -> mbedtls_ccm_update_ad
      64   ccm_auth_decrypt
        64   -> ccm_auth_crypt
        64   -> mbedtls_ct_memcmp
        64   -> mbedtls_platform_zeroize
      24   ccm_calculate_first_block_if_ready
        24   -> mbedtls_cipher_update
      40   mbedtls_ccm_auth_decrypt
        40   -> ccm_auth_decrypt
      48   mbedtls_ccm_crypt
        48   -> mbedtls_cipher_update
        48   -> mbedtls_platform_zeroize
        48   -> mbedtls_xor
      40   mbedtls_ccm_encrypt_and_tag
        40   -> ccm_auth_crypt
      24   mbedtls_ccm_finish
        24   -> __aeabi_memcpy
        24   -> mbedtls_ccm_crypt
       8   mbedtls_ccm_free
         8   -> mbedtls_cipher_free
         0   -> mbedtls_platform_zeroize
       0   mbedtls_ccm_init
         0   -> __aeabi_memclr4
      16   mbedtls_ccm_set_lengths
         0   -> ccm_calculate_first_block_if_ready
      24   mbedtls_ccm_setkey
        24   -> mbedtls_cipher_free
        24   -> mbedtls_cipher_info_from_values
         0   -> mbedtls_cipher_setkey
        24   -> mbedtls_cipher_setup
      40   mbedtls_ccm_star_auth_decrypt
        40   -> ccm_auth_decrypt
      40   mbedtls_ccm_star_encrypt_and_tag
        40   -> ccm_auth_crypt
      24   mbedtls_ccm_starts
        24   -> __aeabi_memclr
        24   -> __aeabi_memcpy
         0   -> ccm_calculate_first_block_if_ready
      64   mbedtls_ccm_update
        64   -> __aeabi_memcpy
        64   -> mbedtls_ccm_crypt
        64   -> mbedtls_cipher_update
        64   -> mbedtls_platform_zeroize
        64   -> mbedtls_xor
      32   mbedtls_ccm_update_ad
        32   -> mbedtls_cipher_update
        32   -> mbedtls_xor
       4   mbedtls_get_unaligned_uint32
      40   mbedtls_xor
        40   -> mbedtls_get_unaligned_uint32


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      18  ?Subroutine3
      32  ?Subroutine4
      78  ccm_auth_crypt
      70  ccm_auth_decrypt
     140  ccm_calculate_first_block_if_ready
      10  mbedtls_ccm_auth_decrypt
     108  mbedtls_ccm_crypt
      10  mbedtls_ccm_encrypt_and_tag
     124  mbedtls_ccm_finish
      28  mbedtls_ccm_free
       6  mbedtls_ccm_init
      58  mbedtls_ccm_set_lengths
      76  mbedtls_ccm_setkey
      12  mbedtls_ccm_star_auth_decrypt
      12  mbedtls_ccm_star_encrypt_and_tag
     106  mbedtls_ccm_starts
     304  mbedtls_ccm_update
     200  mbedtls_ccm_update_ad
      12  mbedtls_get_unaligned_uint32
      70  mbedtls_xor

 
 1'496 bytes in section .text
 
 1'414 bytes of CODE memory (+ 82 bytes shared)

Errors: none
Warnings: none
