###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:18:05
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\SEGGER_RTT.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\SEGGER_14197436847510308367.dir\SEGGER_RTT.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\SEGGER_RTT.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\SEGGER_14197436847510308367.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\SEGGER_14197436847510308367.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\SEGGER_14197436847510308367.dir\SEGGER_RTT.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\SEGGER_14197436847510308367.dir\SEGGER_RTT.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\SEGGER_14197436847510308367.dir\SEGGER_RTT.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\SEGGER_RTT.c
      1          /*********************************************************************
      2          *                    SEGGER Microcontroller GmbH                     *
      3          *                        The Embedded Experts                        *
      4          **********************************************************************
      5          *                                                                    *
      6          *            (c) 1995 - 2023 SEGGER Microcontroller GmbH             *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       SEGGER SystemView * Real-time application analysis           *
     13          *                                                                    *
     14          **********************************************************************
     15          *                                                                    *
     16          * All rights reserved.                                               *
     17          *                                                                    *
     18          * SEGGER strongly recommends to not make any changes                 *
     19          * to or modify the source code of this software in order to stay     *
     20          * compatible with the SystemView and RTT protocol, and J-Link.       *
     21          *                                                                    *
     22          * Redistribution and use in source and binary forms, with or         *
     23          * without modification, are permitted provided that the following    *
     24          * condition is met:                                                  *
     25          *                                                                    *
     26          * o Redistributions of source code must retain the above copyright   *
     27          *   notice, this condition and the following disclaimer.             *
     28          *                                                                    *
     29          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
     30          * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
     31          * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
     32          * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
     33          * DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
     34          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
     35          * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
     36          * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
     37          * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
     38          * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
     39          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
     40          * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
     41          * DAMAGE.                                                            *
     42          *                                                                    *
     43          **********************************************************************
     44          *                                                                    *
     45          *       SystemView version: 3.52                                    *
     46          *                                                                    *
     47          **********************************************************************
     48          ---------------------------END-OF-HEADER------------------------------
     49          File    : SEGGER_RTT.c
     50          Purpose : Implementation of SEGGER real-time transfer (RTT) which
     51                    allows real-time communication on targets which support
     52                    debugger memory accesses while the CPU is running.
     53          Revision: $Rev: 29668 $
     54          
     55          Additional information:
     56                    Type "int" is assumed to be 32-bits in size
     57                    H->T    Host to target communication
     58                    T->H    Target to host communication
     59          
     60                    RTT channel 0 is always present and reserved for Terminal usage.
     61                    Name is fixed to "Terminal"
     62          
     63                    Effective buffer size: SizeOfBuffer - 1
     64          
     65                    WrOff == RdOff:       Buffer is empty
     66                    WrOff == (RdOff - 1): Buffer is full
     67                    WrOff >  RdOff:       Free space includes wrap-around
     68                    WrOff <  RdOff:       Used space includes wrap-around
     69                    (WrOff == (SizeOfBuffer - 1)) && (RdOff == 0):
     70                                          Buffer full and wrap-around after next byte
     71          
     72          
     73          ----------------------------------------------------------------------
     74          */
     75          
     76          #include "SEGGER_RTT.h"
     77          
     78          #include <string.h>                 // for memcpy
     79          
     80          /*********************************************************************
     81          *
     82          *       Configuration, default values
     83          *
     84          **********************************************************************
     85          */
     86          
     87          #if SEGGER_RTT_CPU_CACHE_LINE_SIZE
     88            #ifdef SEGGER_RTT_CB_ALIGN
     89              #error "Custom SEGGER_RTT_CB_ALIGN() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     90            #endif
     91            #ifdef SEGGER_RTT_BUFFER_ALIGN
     92              #error "Custom SEGGER_RTT_BUFFER_ALIGN() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     93            #endif
     94            #ifdef SEGGER_RTT_PUT_CB_SECTION
     95              #error "Custom SEGGER_RTT_PUT_CB_SECTION() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     96            #endif
     97            #ifdef SEGGER_RTT_PUT_BUFFER_SECTION
     98              #error "Custom SEGGER_RTT_PUT_BUFFER_SECTION() is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
     99            #endif
    100            #ifdef SEGGER_RTT_BUFFER_ALIGNMENT
    101              #error "Custom SEGGER_RTT_BUFFER_ALIGNMENT is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
    102            #endif
    103            #ifdef SEGGER_RTT_ALIGNMENT
    104              #error "Custom SEGGER_RTT_ALIGNMENT is not supported for SEGGER_RTT_CPU_CACHE_LINE_SIZE != 0"
    105            #endif
    106          #endif
    107          
    108          #ifndef   BUFFER_SIZE_UP
    109            #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
    110          #endif
    111          
    112          #ifndef   BUFFER_SIZE_DOWN
    113            #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
    114          #endif
    115          
    116          #ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
    117            #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
    118          #endif
    119          
    120          #ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
    121            #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
    122          #endif
    123          
    124          #ifndef SEGGER_RTT_BUFFER_SECTION
    125            #if defined(SEGGER_RTT_SECTION)
    126              #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
    127            #endif
    128          #endif
    129          
    130          #ifndef   SEGGER_RTT_ALIGNMENT
    131            #define SEGGER_RTT_ALIGNMENT                            SEGGER_RTT_CPU_CACHE_LINE_SIZE
    132          #endif
    133          
    134          #ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
    135            #define SEGGER_RTT_BUFFER_ALIGNMENT                     SEGGER_RTT_CPU_CACHE_LINE_SIZE
    136          #endif
    137          
    138          #ifndef   SEGGER_RTT_MODE_DEFAULT
    139            #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
    140          #endif
    141          
    142          #ifndef   SEGGER_RTT_LOCK
    143            #define SEGGER_RTT_LOCK()
    144          #endif
    145          
    146          #ifndef   SEGGER_RTT_UNLOCK
    147            #define SEGGER_RTT_UNLOCK()
    148          #endif
    149          
    150          #ifndef   STRLEN
    151            #define STRLEN(a)                                       strlen((a))
    152          #endif
    153          
    154          #ifndef   STRCPY
    155            #define STRCPY(pDest, pSrc)                             strcpy((pDest), (pSrc))
    156          #endif
    157          
    158          #ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
    159            #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
    160          #endif
    161          
    162          #ifndef   SEGGER_RTT_MEMCPY
    163            #ifdef  MEMCPY
    164              #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
    165            #else
    166              #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
    167            #endif
    168          #endif
    169          
    170          #ifndef   MIN
    171            #define MIN(a, b)                                       (((a) < (b)) ? (a) : (b))
    172          #endif
    173          
    174          #ifndef   MAX
    175            #define MAX(a, b)                                       (((a) > (b)) ? (a) : (b))
    176          #endif
    177          //
    178          // For some environments, NULL may not be defined until certain headers are included
    179          //
    180          #ifndef NULL
    181            #define NULL                                            0
    182          #endif
    183          
    184          /*********************************************************************
    185          *
    186          *       Defines, fixed
    187          *
    188          **********************************************************************
    189          */
    190          #if (defined __ICCARM__) || (defined __ICCRX__)
    191            #define RTT_PRAGMA(P) _Pragma(#P)
    192          #endif
    193          
    194          #if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
    195            #if ((defined __GNUC__) || (defined __clang__))
    196              #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
    197            #elif (defined __ICCARM__) || (defined __ICCRX__)
    198              #define PRAGMA(A) _Pragma(#A)
    199          #define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
    200                                            Var
    201            #elif (defined __CC_ARM)
    202              #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
    203            #else
    204              #error "Alignment not supported for this compiler."
    205            #endif
    206          #else
    207            #define SEGGER_RTT_ALIGN(Var, Alignment) Var
    208          #endif
    209          
    210          #if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
    211            #if ((defined __GNUC__) || (defined __clang__))
    212              #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
    213            #elif (defined __ICCARM__) || (defined __ICCRX__)
    214          #define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
    215                                                  Var
    216            #elif (defined __CC_ARM)
    217              #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
    218            #else
    219              #error "Section placement not supported for this compiler."
    220            #endif
    221          #else
    222            #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
    223          #endif
    224          
    225          #if SEGGER_RTT_ALIGNMENT
    226            #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
    227          #else
    228            #define SEGGER_RTT_CB_ALIGN(Var)  Var
    229          #endif
    230          
    231          #if SEGGER_RTT_BUFFER_ALIGNMENT
    232            #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
    233          #else
    234            #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
    235          #endif
    236          
    237          
    238          #if defined(SEGGER_RTT_SECTION)
    239            #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
    240          #else
    241            #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
    242          #endif
    243          
    244          #if defined(SEGGER_RTT_BUFFER_SECTION)
    245            #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
    246          #else
    247            #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
    248          #endif
    249          
    250          /*********************************************************************
    251          *
    252          *       Static const data
    253          *
    254          **********************************************************************
    255          */
    256          

   \                                 In section .text, align 4, keep-with-next
    257          static const unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
   \                     _aTerminalId:
   \        0x0   0x30 0x31          DC8 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46
    258          
    259          /*********************************************************************
    260          *
    261          *       Static data
    262          *
    263          **********************************************************************
    264          */
    265          
    266          //
    267          // RTT Control Block and allocate buffers for channel 0
    268          //
    269          #if SEGGER_RTT_CPU_CACHE_LINE_SIZE
    270            #if ((defined __GNUC__) || (defined __clang__))
    271              SEGGER_RTT_CB _SEGGER_RTT                                                             __attribute__ ((aligned (SEGGER_RTT_CPU_CACHE_LINE_SIZE)));
    272              static char   _acUpBuffer  [SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_UP)]   __attribute__ ((aligned (SEGGER_RTT_CPU_CACHE_LINE_SIZE)));
    273              static char   _acDownBuffer[SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_DOWN)] __attribute__ ((aligned (SEGGER_RTT_CPU_CACHE_LINE_SIZE)));
    274            #elif (defined __ICCARM__)
    275              #pragma data_alignment=SEGGER_RTT_CPU_CACHE_LINE_SIZE
    276              SEGGER_RTT_CB _SEGGER_RTT;
    277              #pragma data_alignment=SEGGER_RTT_CPU_CACHE_LINE_SIZE
    278              static char   _acUpBuffer  [SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_UP)];
    279              #pragma data_alignment=SEGGER_RTT_CPU_CACHE_LINE_SIZE
    280              static char   _acDownBuffer[SEGGER_RTT__ROUND_UP_2_CACHE_LINE_SIZE(BUFFER_SIZE_DOWN)];
    281            #else
    282              #error "Don't know how to place _SEGGER_RTT, _acUpBuffer, _acDownBuffer cache-line aligned"
    283            #endif
    284          #else

   \                                 In section .bss, align 4
    285            SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
   \                     _SEGGER_RTT:
   \        0x0                      DS8 168
   \       0xA8                      DS8 1'024
   \      0x4A8                      DS8 1'024
    286            SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
    287            SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
    288          #endif
    289          

   \                                 In section .bss, align 1
    290          static unsigned char _ActiveTerminal;
   \                     _ActiveTerminal:
   \        0x0                      DS8 1
    291          
    292          /*********************************************************************
    293          *
    294          *       Static functions
    295          *
    296          **********************************************************************
    297          */
    298          
    299          /*********************************************************************
    300          *
    301          *       _DoInit()
    302          *
    303          *  Function description
    304          *    Initializes the control block an buffers.
    305          *
    306          *  Notes
    307          *    (1) May only be called via INIT() to avoid overriding settings.
    308          *        The only exception is SEGGER_RTT_Init(), to make an intentional override possible.
    309          */
    310            #define INIT()                                                                             \
    311              do {                                                                                     \
    312                volatile SEGGER_RTT_CB* pRTTCBInit;                                                    \
    313                pRTTCBInit = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF); \
    314                if (pRTTCBInit->acID[0] != 'S') {                                                      \
    315                  _DoInit();                                                                           \
    316                }                                                                                      \
    317              } while (0)
    318          

   \                                 In section .text, align 2, keep-with-next
    319          static void _DoInit(void) {
   \                     _DoInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    320            volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
    321            static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
    322            unsigned i;
    323            //
    324            // Initialize control block
    325            //
    326            p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
    327            memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable27
   \        0x6   0x21A8             MOVS     R1,#+168
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x.... 0x....      BL       __aeabi_memclr
    328            p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   \        0xE   0x2203             MOVS     R2,#+3
   \       0x10   0x6122             STR      R2,[R4, #+16]
    329            p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0x6160             STR      R0,[R4, #+20]
    330            //
    331            // Initialize up buffer 0
    332            //
    333            p->aUp[0].sName         = "Terminal";
   \       0x16   0x.... 0x....      ADR.W    R0,?_0
   \       0x1A   0x61A0             STR      R0,[R4, #+24]
    334            p->aUp[0].pBuffer       = _acUpBuffer;
   \       0x1C   0xF104 0x01A8      ADD      R1,R4,#+168
   \       0x20   0x61E1             STR      R1,[R4, #+28]
    335            p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
   \       0x22   0xF44F 0x6180      MOV      R1,#+1024
   \       0x26   0x6221             STR      R1,[R4, #+32]
    336            p->aUp[0].RdOff         = 0u;
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x62A2             STR      R2,[R4, #+40]
    337            p->aUp[0].WrOff         = 0u;
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x6263             STR      R3,[R4, #+36]
    338            p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   \       0x30   0x62E2             STR      R2,[R4, #+44]
    339            //
    340            // Initialize down buffer 0
    341            //
    342            p->aDown[0].sName         = "Terminal";
   \       0x32   0x6620             STR      R0,[R4, #+96]
    343            p->aDown[0].pBuffer       = _acDownBuffer;
   \       0x34   0xF504 0x6095      ADD      R0,R4,#+1192
   \       0x38   0x6660             STR      R0,[R4, #+100]
    344            p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
   \       0x3A   0x66A1             STR      R1,[R4, #+104]
    345            p->aDown[0].RdOff         = 0u;
   \       0x3C   0x6722             STR      R2,[R4, #+112]
    346            p->aDown[0].WrOff         = 0u;
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x66E1             STR      R1,[R4, #+108]
    347            p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x6760             STR      R0,[R4, #+116]
    348            //
    349            // Finish initialization of the control block.
    350            // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
    351            // as this would cause J-Link to "find" the control block at a wrong address.
    352            //
    353            RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    354            for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
   \       0x46   0x.... 0x....      ADR.W    R0,`_DoInit::_aInitStr`
    355              p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
   \                     ??_DoInit_0: (+1)
   \       0x4A   0x424A             RSBS     R2,R1,#+0
   \       0x4C   0x4402             ADD      R2,R0,R2
   \       0x4E   0x7BD2             LDRB     R2,[R2, #+15]
   \       0x50   0x5462             STRB     R2,[R4, R1]
    356            }
   \       0x52   0x1C49             ADDS     R1,R1,#+1
   \       0x54   0x2910             CMP      R1,#+16
   \       0x56   0xD3F8             BCC.N    ??_DoInit_0
    357            RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    358          }
   \       0x58   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     `_DoInit::_aInitStr`:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0x54, 0x54
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x54 0x54
   \        0x8   0x52 0x20          DC8 0x52, 0x20, 0x52, 0x45, 0x47, 0x47, 0x45, 0x53
   \              0x52 0x45    
   \              0x47 0x47    
   \              0x45 0x53
   \       0x10   0x00               DC8 0
   \       0x11                      DS8 3
    359          
    360          /*********************************************************************
    361          *
    362          *       _WriteBlocking()
    363          *
    364          *  Function description
    365          *    Stores a specified number of characters in SEGGER RTT ring buffer
    366          *    and updates the associated write pointer which is periodically
    367          *    read by the host.
    368          *    The caller is responsible for managing the write chunk sizes as
    369          *    _WriteBlocking() will block until all data has been posted successfully.
    370          *
    371          *  Parameters
    372          *    pRing        Ring buffer to post to.
    373          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    374          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    375          *
    376          *  Return value
    377          *    >= 0 - Number of bytes written into buffer.
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
   \                     _WriteBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4614             MOV      R4,R2
    380            unsigned NumBytesToWrite;
    381            unsigned NumBytesWritten;
    382            unsigned RdOff;
    383            unsigned WrOff;
    384            volatile char* pDst;
    385            //
    386            // Write data to buffer and handle wrap-around if necessary
    387            //
    388            NumBytesWritten = 0u;
   \        0xA   0xF04F 0x0900      MOV      R9,#+0
    389            WrOff = pRing->WrOff;
   \        0xE   0x68EF             LDR      R7,[R5, #+12]
    390            do {
    391              RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
   \                     ??_WriteBlocking_0: (+1)
   \       0x10   0x692E             LDR      R6,[R5, #+16]
    392              if (RdOff > WrOff) {
   \       0x12   0x68A8             LDR      R0,[R5, #+8]
   \       0x14   0x1BC0             SUBS     R0,R0,R7
   \       0x16   0x42B7             CMP      R7,R6
   \       0x18   0xBF34             ITE      CC
   \       0x1A   0x1BF6             SUBCC    R6,R6,R7
   \       0x1C   0x1836             ADDCS    R6,R6,R0
    393                NumBytesToWrite = RdOff - WrOff - 1u;
    394              } else {
    395                NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
   \       0x1E   0x1E76             SUBS     R6,R6,#+1
    396              }
    397              NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
   \       0x20   0x4286             CMP      R6,R0
   \       0x22   0xBF28             IT       CS
   \       0x24   0x4606             MOVCS    R6,R0
    398              NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
   \       0x26   0x42A6             CMP      R6,R4
   \       0x28   0xBF88             IT       HI
   \       0x2A   0x4626             MOVHI    R6,R4
    399              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    400          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    401              NumBytesWritten += NumBytesToWrite;
    402              NumBytes        -= NumBytesToWrite;
    403              WrOff           += NumBytesToWrite;
    404              while (NumBytesToWrite--) {
    405                *pDst++ = *pBuffer++;
    406              };
    407          #else
    408              SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
   \       0x2C   0x6868             LDR      R0,[R5, #+4]
   \       0x2E   0x4632             MOV      R2,R6
   \       0x30   0x4641             MOV      R1,R8
   \       0x32   0x19C0             ADDS     R0,R0,R7
   \       0x34   0x.... 0x....      BL       __aeabi_memcpy
    409              NumBytesWritten += NumBytesToWrite;
    410              pBuffer         += NumBytesToWrite;
    411              NumBytes        -= NumBytesToWrite;
    412              WrOff           += NumBytesToWrite;
    413          #endif
    414              if (WrOff == pRing->SizeOfBuffer) {
   \       0x38   0x68A9             LDR      R1,[R5, #+8]
   \       0x3A   0x1BA4             SUBS     R4,R4,R6
   \       0x3C   0x19F7             ADDS     R7,R6,R7
   \       0x3E   0x44B1             ADD      R9,R6,R9
   \       0x40   0x44B0             ADD      R8,R8,R6
   \       0x42   0x428F             CMP      R7,R1
   \       0x44   0xBF08             IT       EQ
   \       0x46   0x2700             MOVEQ    R7,#+0
    415                WrOff = 0u;
    416              }
    417              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    418              pRing->WrOff = WrOff;
   \       0x48   0x60EF             STR      R7,[R5, #+12]
    419            } while (NumBytes);
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD1E0             BNE.N    ??_WriteBlocking_0
    420            return NumBytesWritten;
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    421          }
    422          
    423          /*********************************************************************
    424          *
    425          *       _WriteNoCheck()
    426          *
    427          *  Function description
    428          *    Stores a specified number of characters in SEGGER RTT ring buffer
    429          *    and updates the associated write pointer which is periodically
    430          *    read by the host.
    431          *    It is callers responsibility to make sure data actually fits in buffer.
    432          *
    433          *  Parameters
    434          *    pRing        Ring buffer to post to.
    435          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    436          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    437          *
    438          *  Notes
    439          *    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
    440          */

   \                                 In section .text, align 2, keep-with-next
    441          static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
   \                     _WriteNoCheck: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
    442            unsigned NumBytesAtOnce;
    443            unsigned WrOff;
    444            unsigned Rem;
    445            volatile char* pDst;
    446          
    447            WrOff = pRing->WrOff;
   \        0x6   0x68E7             LDR      R7,[R4, #+12]
    448            Rem = pRing->SizeOfBuffer - WrOff;
   \        0x8   0x68A5             LDR      R5,[R4, #+8]
    449            if (Rem > NumBytes) {
   \        0xA   0x6860             LDR      R0,[R4, #+4]
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x1BED             SUBS     R5,R5,R7
   \       0x10   0x4688             MOV      R8,R1
   \       0x12   0x4438             ADD      R0,R0,R7
   \       0x14   0x42AE             CMP      R6,R5
   \       0x16   0xD203             BCS.N    ??_WriteNoCheck_0
    450              //
    451              // All data fits before wrap around
    452              //
    453              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    454          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    455              WrOff += NumBytes;
    456              while (NumBytes--) {
    457                *pDst++ = *pData++;
    458              };
    459              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    460              pRing->WrOff = WrOff;
    461          #else
    462              SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
   \       0x18   0x.... 0x....      BL       __aeabi_memcpy
    463              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    464              pRing->WrOff = WrOff + NumBytes;
   \       0x1C   0x19F6             ADDS     R6,R6,R7
   \       0x1E   0xE009             B.N      ??_WriteNoCheck_1
    465          #endif
    466            } else {
    467              //
    468              // We reach the end of the buffer, so need to wrap around
    469              //
    470          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    471              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    472              NumBytesAtOnce = Rem;
    473              while (NumBytesAtOnce--) {
    474                *pDst++ = *pData++;
    475              };
    476              pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    477              NumBytesAtOnce = NumBytes - Rem;
    478              while (NumBytesAtOnce--) {
    479                *pDst++ = *pData++;
    480              };
    481              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    482              pRing->WrOff = NumBytes - Rem;
    483          #else
    484              NumBytesAtOnce = Rem;
    485              pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    486              SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
   \                     ??_WriteNoCheck_0: (+1)
   \       0x20   0x462A             MOV      R2,R5
   \       0x22   0x.... 0x....      BL       __aeabi_memcpy
    487              NumBytesAtOnce = NumBytes - Rem;
    488              pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    489              SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
   \       0x26   0x6860             LDR      R0,[R4, #+4]
   \       0x28   0x1B76             SUBS     R6,R6,R5
   \       0x2A   0x4632             MOV      R2,R6
   \       0x2C   0xEB08 0x0105      ADD      R1,R8,R5
   \       0x30   0x.... 0x....      BL       __aeabi_memcpy
    490              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    491              pRing->WrOff = NumBytesAtOnce;
    492          #endif
    493            }
    494          }
   \                     ??_WriteNoCheck_1: (+1)
   \       0x34   0x60E6             STR      R6,[R4, #+12]
   \       0x36   0xE8BD 0x81F0      POP      {R4-R8,PC}
    495          
    496          /*********************************************************************
    497          *
    498          *       _PostTerminalSwitch()
    499          *
    500          *  Function description
    501          *    Switch terminal to the given terminal ID.  It is the caller's
    502          *    responsibility to ensure the terminal ID is correct and there is
    503          *    enough space in the buffer for this to complete successfully.
    504          *
    505          *  Parameters
    506          *    pRing        Ring buffer to post to.
    507          *    TerminalId   Terminal ID to switch to.
    508          */

   \                                 In section .text, align 2, keep-with-next
    509          static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
   \                     _PostTerminalSwitch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    510            unsigned char ac[2];
    511          
    512            ac[0] = 0xFFu;
   \        0x2   0x22FF             MOVS     R2,#+255
   \        0x4   0xF88D 0x2000      STRB     R2,[SP, #+0]
    513            ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
   \        0x8   0x.... 0x....      ADR.W    R3,_aTerminalId
   \        0xC   0x5C59             LDRB     R1,[R3, R1]
    514            _WriteBlocking(pRing, (const char*)ac, 2u);
   \        0xE   0x2202             MOVS     R2,#+2
   \       0x10   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x.... 0x....      BL       _WriteBlocking
    515          }
   \       0x1A   0xBD01             POP      {R0,PC}
    516          
    517          /*********************************************************************
    518          *
    519          *       _GetAvailWriteSpace()
    520          *
    521          *  Function description
    522          *    Returns the number of bytes that can be written to the ring
    523          *    buffer without blocking.
    524          *
    525          *  Parameters
    526          *    pRing        Ring buffer to check.
    527          *
    528          *  Return value
    529          *    Number of bytes that are free in the buffer.
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
   \                     _GetAvailWriteSpace: (+1)
   \        0x0   0x4601             MOV      R1,R0
    532            unsigned RdOff;
    533            unsigned WrOff;
    534            unsigned r;
    535            //
    536            // Avoid warnings regarding volatile access order.  It's not a problem
    537            // in this case, but dampen compiler enthusiasm.
    538            //
    539            RdOff = pRing->RdOff;
   \        0x2   0x6908             LDR      R0,[R1, #+16]
    540            WrOff = pRing->WrOff;
   \        0x4   0x68CA             LDR      R2,[R1, #+12]
    541            if (RdOff <= WrOff) {
   \        0x6   0x4282             CMP      R2,R0
   \        0x8   0xD304             BCC.N    ??_GetAvailWriteSpace_0
    542              r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   \        0xA   0x6889             LDR      R1,[R1, #+8]
   \        0xC   0x1E49             SUBS     R1,R1,#+1
   \        0xE   0x1A8A             SUBS     R2,R1,R2
   \       0x10   0x1880             ADDS     R0,R0,R2
   \       0x12   0x4770             BX       LR
    543            } else {
    544              r = RdOff - WrOff - 1u;
   \                     ??_GetAvailWriteSpace_0: (+1)
   \       0x14   0x1A80             SUBS     R0,R0,R2
   \       0x16   0x1E40             SUBS     R0,R0,#+1
    545            }
    546            return r;
   \       0x18   0x4770             BX       LR
    547          }
    548          
    549          /*********************************************************************
    550          *
    551          *       Public code
    552          *
    553          **********************************************************************
    554          */
    555          
    556          /*********************************************************************
    557          *
    558          *       SEGGER_RTT_ReadUpBufferNoLock()
    559          *
    560          *  Function description
    561          *    Reads characters from SEGGER real-time-terminal control block
    562          *    which have been previously stored by the application.
    563          *    Do not lock against interrupts and multiple access.
    564          *    Used to do the same operation that J-Link does, to transfer
    565          *    RTT data via other channels, such as TCP/IP or UART.
    566          *
    567          *  Parameters
    568          *    BufferIndex  Index of Up-buffer to be used.
    569          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
    570          *    BufferSize   Size of the target application buffer.
    571          *
    572          *  Return value
    573          *    Number of bytes that have been read.
    574          *
    575          *  Additional information
    576          *    This function must not be called when J-Link might also do RTT.
    577          */

   \                                 In section .text, align 2, keep-with-next
    578          unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
   \                     SEGGER_RTT_ReadUpBufferNoLock: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
    579            unsigned                NumBytesRem;
    580            unsigned                NumBytesRead;
    581            unsigned                RdOff;
    582            unsigned                WrOff;
    583            unsigned char*          pBuffer;
    584            SEGGER_RTT_BUFFER_UP*   pRing;
    585            volatile char*          pSrc;
    586          
    587            INIT();
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable27
   \        0xA   0x7828             LDRB     R0,[R5, #+0]
   \        0xC   0x4689             MOV      R9,R1
   \        0xE   0x4690             MOV      R8,R2
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xBF18             IT       NE
   \       0x14   0x.... 0x....      BLNE     _DoInit
    588            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \       0x18   0x.... 0x....      BL       ??Subroutine22_0
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x1C   0xF100 0x0618      ADD      R6,R0,#+24
    589            pBuffer = (unsigned char*)pData;
    590            RdOff = pRing->RdOff;
   \       0x20   0x6937             LDR      R7,[R6, #+16]
    591            WrOff = pRing->WrOff;
   \       0x22   0x68F4             LDR      R4,[R6, #+12]
    592            NumBytesRead = 0u;
   \       0x24   0x2500             MOVS     R5,#+0
    593            //
    594            // Read from current read position to wrap-around of buffer, first
    595            //
    596            if (RdOff > WrOff) {
   \       0x26   0x42BC             CMP      R4,R7
   \       0x28   0xD20C             BCS.N    ??SEGGER_RTT_ReadUpBufferNoLock_0
    597              NumBytesRem = pRing->SizeOfBuffer - RdOff;
   \       0x2A   0x68B5             LDR      R5,[R6, #+8]
   \       0x2C   0x1BED             SUBS     R5,R5,R7
    598              NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x2E   0x4545             CMP      R5,R8
   \       0x30   0xBF88             IT       HI
   \       0x32   0x4645             MOVHI    R5,R8
    599              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
    600          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    601              NumBytesRead += NumBytesRem;
    602              BufferSize   -= NumBytesRem;
    603              RdOff        += NumBytesRem;
    604              while (NumBytesRem--) {
    605                *pBuffer++ = *pSrc++;
    606              };
    607          #else
    608              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
   \       0x34   0x.... 0x....      BL       ?Subroutine8
    609              NumBytesRead += NumBytesRem;
    610              pBuffer      += NumBytesRem;
    611              BufferSize   -= NumBytesRem;
    612              RdOff        += NumBytesRem;
    613          #endif
    614              //
    615              // Handle wrap-around of buffer
    616              //
    617              if (RdOff == pRing->SizeOfBuffer) {
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x38   0x68B1             LDR      R1,[R6, #+8]
   \       0x3A   0x19EF             ADDS     R7,R5,R7
   \       0x3C   0x44A9             ADD      R9,R9,R5
   \       0x3E   0x428F             CMP      R7,R1
   \       0x40   0xBF08             IT       EQ
   \       0x42   0x2700             MOVEQ    R7,#+0
    618                RdOff = 0u;
    619              }
    620            }
    621            //
    622            // Read remaining items of buffer
    623            //
    624            NumBytesRem = WrOff - RdOff;
   \                     ??SEGGER_RTT_ReadUpBufferNoLock_0: (+1)
   \       0x44   0x1BE4             SUBS     R4,R4,R7
    625            NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x46   0x4544             CMP      R4,R8
   \       0x48   0xBF88             IT       HI
   \       0x4A   0x4644             MOVHI    R4,R8
    626            if (NumBytesRem > 0u) {
   \       0x4C   0x....             B.N      ?Subroutine1
    627              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
    628          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    629              NumBytesRead += NumBytesRem;
    630              BufferSize   -= NumBytesRem;
    631              RdOff        += NumBytesRem;
    632              while (NumBytesRem--) {
    633                *pBuffer++ = *pSrc++;
    634              };
    635          #else
    636              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
    637              NumBytesRead += NumBytesRem;
    638              pBuffer      += NumBytesRem;
    639              BufferSize   -= NumBytesRem;
    640              RdOff        += NumBytesRem;
    641          #endif
    642            }
    643            //
    644            // Update read offset of buffer
    645            //
    646            if (NumBytesRead) {
    647              pRing->RdOff = RdOff;
    648            }
    649            //
    650            return NumBytesRead;
    651          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x6870             LDR      R0,[R6, #+4]
   \        0x2   0x462A             MOV      R2,R5
   \        0x4   0xEBA8 0x0805      SUB      R8,R8,R5
   \        0x8                      REQUIRE ??Subroutine21_0
   \        0x8                      ;; // Fall through to label ??Subroutine21_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine21_0: (+1)
   \        0x0   0x19C1             ADDS     R1,R0,R7
   \        0x2   0x4648             MOV      R0,R9
   \        0x4   0x.... 0x....      B.W      __aeabi_memcpy

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB12C             CBZ.N    R4,??Subroutine1_1
   \        0x2   0x6870             LDR      R0,[R6, #+4]
   \        0x4   0x4622             MOV      R2,R4
   \        0x6   0x1965             ADDS     R5,R4,R5
   \        0x8   0x.... 0x....      BL       ??Subroutine21_0
   \                     ??CrossCallReturnLabel_29: (+1)
   \        0xC   0x19E7             ADDS     R7,R4,R7
   \                     ??Subroutine1_1: (+1)
   \        0xE   0xB105             CBZ.N    R5,??Subroutine1_0
   \       0x10   0x6137             STR      R7,[R6, #+16]
   \                     ??Subroutine1_0: (+1)
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine22_0: (+1)
   \        0x0   0x2018             MOVS     R0,#+24
   \        0x2   0x4344             MULS     R4,R0,R4
   \        0x4   0x1928             ADDS     R0,R5,R4
   \        0x6   0x4770             BX       LR
    652          
    653          /*********************************************************************
    654          *
    655          *       SEGGER_RTT_ReadNoLock()
    656          *
    657          *  Function description
    658          *    Reads characters from SEGGER real-time-terminal control block
    659          *    which have been previously stored by the host.
    660          *    Do not lock against interrupts and multiple access.
    661          *
    662          *  Parameters
    663          *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    664          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    665          *    BufferSize   Size of the target application buffer.
    666          *
    667          *  Return value
    668          *    Number of bytes that have been read.
    669          */

   \                                 In section .text, align 2, keep-with-next
    670          unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
   \                     SEGGER_RTT_ReadNoLock: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
    671            unsigned                NumBytesRem;
    672            unsigned                NumBytesRead;
    673            unsigned                RdOff;
    674            unsigned                WrOff;
    675            unsigned char*          pBuffer;
    676            SEGGER_RTT_BUFFER_DOWN* pRing;
    677            volatile char*          pSrc;
    678            //
    679            INIT();
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable27
   \        0xA   0x7828             LDRB     R0,[R5, #+0]
   \        0xC   0x4689             MOV      R9,R1
   \        0xE   0x4690             MOV      R8,R2
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xBF18             IT       NE
   \       0x14   0x.... 0x....      BLNE     _DoInit
    680            pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \       0x18   0x.... 0x....      BL       ??Subroutine22_0
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x1C   0xF100 0x0660      ADD      R6,R0,#+96
    681            pBuffer = (unsigned char*)pData;
    682            RdOff = pRing->RdOff;
   \       0x20   0x6937             LDR      R7,[R6, #+16]
    683            WrOff = pRing->WrOff;
   \       0x22   0x68F4             LDR      R4,[R6, #+12]
    684            NumBytesRead = 0u;
   \       0x24   0x2500             MOVS     R5,#+0
    685            //
    686            // Read from current read position to wrap-around of buffer, first
    687            //
    688            if (RdOff > WrOff) {
   \       0x26   0x42BC             CMP      R4,R7
   \       0x28   0xD20C             BCS.N    ??SEGGER_RTT_ReadNoLock_0
    689              NumBytesRem = pRing->SizeOfBuffer - RdOff;
   \       0x2A   0x68B5             LDR      R5,[R6, #+8]
   \       0x2C   0x1BED             SUBS     R5,R5,R7
    690              NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x2E   0x4545             CMP      R5,R8
   \       0x30   0xBF88             IT       HI
   \       0x32   0x4645             MOVHI    R5,R8
    691              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
    692          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    693              NumBytesRead += NumBytesRem;
    694              BufferSize   -= NumBytesRem;
    695              RdOff        += NumBytesRem;
    696              while (NumBytesRem--) {
    697                *pBuffer++ = *pSrc++;
    698              };
    699          #else
    700              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
   \       0x34   0x.... 0x....      BL       ?Subroutine8
    701              NumBytesRead += NumBytesRem;
    702              pBuffer      += NumBytesRem;
    703              BufferSize   -= NumBytesRem;
    704              RdOff        += NumBytesRem;
    705          #endif
    706              //
    707              // Handle wrap-around of buffer
    708              //
    709              if (RdOff == pRing->SizeOfBuffer) {
    710                RdOff = 0u;
    711              }
    712            }
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x38   0x68B1             LDR      R1,[R6, #+8]
   \       0x3A   0x19EF             ADDS     R7,R5,R7
   \       0x3C   0x44A9             ADD      R9,R9,R5
   \       0x3E   0x428F             CMP      R7,R1
   \       0x40   0xBF08             IT       EQ
   \       0x42   0x2700             MOVEQ    R7,#+0
    713            //
    714            // Read remaining items of buffer
    715            //
    716            NumBytesRem = WrOff - RdOff;
   \                     ??SEGGER_RTT_ReadNoLock_0: (+1)
   \       0x44   0x1BE4             SUBS     R4,R4,R7
    717            NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x46   0x4544             CMP      R4,R8
   \       0x48   0xBF88             IT       HI
   \       0x4A   0x4644             MOVHI    R4,R8
    718            if (NumBytesRem > 0u) {
   \       0x4C                      REQUIRE ?Subroutine1
   \       0x4C                      ;; // Fall through to label ?Subroutine1
    719              pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
    720          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    721              NumBytesRead += NumBytesRem;
    722              BufferSize   -= NumBytesRem;
    723              RdOff        += NumBytesRem;
    724              while (NumBytesRem--) {
    725                *pBuffer++ = *pSrc++;
    726              };
    727          #else
    728              SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
    729              NumBytesRead += NumBytesRem;
    730              pBuffer      += NumBytesRem;
    731              BufferSize   -= NumBytesRem;
    732              RdOff        += NumBytesRem;
    733          #endif
    734            }
    735            if (NumBytesRead) {
    736              pRing->RdOff = RdOff;
    737            }
    738            //
    739            return NumBytesRead;
    740          }
    741          
    742          /*********************************************************************
    743          *
    744          *       SEGGER_RTT_ReadUpBuffer
    745          *
    746          *  Function description
    747          *    Reads characters from SEGGER real-time-terminal control block
    748          *    which have been previously stored by the application.
    749          *    Used to do the same operation that J-Link does, to transfer
    750          *    RTT data via other channels, such as TCP/IP or UART.
    751          *
    752          *  Parameters
    753          *    BufferIndex  Index of Up-buffer to be used.
    754          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
    755          *    BufferSize   Size of the target application buffer.
    756          *
    757          *  Return value
    758          *    Number of bytes that have been read.
    759          *
    760          *  Additional information
    761          *    This function must not be called when J-Link might also do RTT.
    762          *    This function locks against all other RTT operations. I.e. during
    763          *    the read operation, writing is also locked.
    764          *    If only one consumer reads from the up buffer,
    765          *    call sEGGER_RTT_ReadUpBufferNoLock() instead.
    766          */

   \                                 In section .text, align 2, keep-with-next
    767          unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
   \                     SEGGER_RTT_ReadUpBuffer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    768            unsigned NumBytesRead;
    769          
    770            SEGGER_RTT_LOCK();
   \        0x2   0x.... 0x....      BL       ?Subroutine16
    771            //
    772            // Call the non-locking read function
    773            //
    774            NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
   \                     ??CrossCallReturnLabel_14: (+1)
   \        0x6   0x.... 0x....      BL       SEGGER_RTT_ReadUpBufferNoLock
    775            //
    776            // Finish up.
    777            //
    778            SEGGER_RTT_UNLOCK();
   \        0xA   0x....             B.N      ?Subroutine0
    779            //
    780            return NumBytesRead;
    781          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF384 0x8811      MSR      BASEPRI,R4
   \        0x4   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0xF3EF 0x8411      MRS      R4,BASEPRI
   \        0x4   0x2320             MOVS     R3,#+32
   \        0x6   0xF383 0x8811      MSR      BASEPRI,R3
   \        0xA   0x4770             BX       LR
    782          
    783          /*********************************************************************
    784          *
    785          *       SEGGER_RTT_Read
    786          *
    787          *  Function description
    788          *    Reads characters from SEGGER real-time-terminal control block
    789          *    which have been previously stored by the host.
    790          *
    791          *  Parameters
    792          *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    793          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    794          *    BufferSize   Size of the target application buffer.
    795          *
    796          *  Return value
    797          *    Number of bytes that have been read.
    798          */

   \                                 In section .text, align 2, keep-with-next
    799          unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
   \                     SEGGER_RTT_Read: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    800            unsigned NumBytesRead;
    801          
    802            SEGGER_RTT_LOCK();
   \        0x2   0x.... 0x....      BL       ?Subroutine16
    803            //
    804            // Call the non-locking read function
    805            //
    806            NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
   \                     ??CrossCallReturnLabel_15: (+1)
   \        0x6   0x.... 0x....      BL       SEGGER_RTT_ReadNoLock
    807            //
    808            // Finish up.
    809            //
    810            SEGGER_RTT_UNLOCK();
   \        0xA                      REQUIRE ?Subroutine0
   \        0xA                      ;; // Fall through to label ?Subroutine0
    811            //
    812            return NumBytesRead;
    813          }
    814          
    815          /*********************************************************************
    816          *
    817          *       SEGGER_RTT_WriteWithOverwriteNoLock
    818          *
    819          *  Function description
    820          *    Stores a specified number of characters in SEGGER RTT
    821          *    control block.
    822          *    SEGGER_RTT_WriteWithOverwriteNoLock does not lock the application
    823          *    and overwrites data if the data does not fit into the buffer.
    824          *
    825          *  Parameters
    826          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    827          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    828          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    829          *
    830          *  Notes
    831          *    (1) If there is not enough space in the "Up"-buffer, data is overwritten.
    832          *    (2) For performance reasons this function does not call Init()
    833          *        and may only be called after RTT has been initialized.
    834          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    835          *    (3) Do not use SEGGER_RTT_WriteWithOverwriteNoLock if a J-Link
    836          *        connection reads RTT data.
    837          */

   \                                 In section .text, align 2, keep-with-next
    838          void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteWithOverwriteNoLock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
    839            const char*           pData;
    840            SEGGER_RTT_BUFFER_UP* pRing;
    841            unsigned              Avail;
    842            volatile char*        pDst;
    843            //
    844            // Get "to-host" ring buffer and copy some elements into local variables.
    845            //
    846            pData = (const char *)pBuffer;
    847            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x4   0x.... 0x....      BL       ?Subroutine7
    848            //
    849            // Check if we will overwrite data and need to adjust the RdOff.
    850            //
    851            if (pRing->WrOff == pRing->RdOff) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x8   0x68F1             LDR      R1,[R6, #+12]
   \        0xA   0x6930             LDR      R0,[R6, #+16]
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xBF08             IT       EQ
   \       0x10   0x68B1             LDREQ    R1,[R6, #+8]
    852              Avail = pRing->SizeOfBuffer - 1u;
   \       0x12   0xD009             BEQ.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_0
    853            } else if ( pRing->WrOff < pRing->RdOff) {
   \       0x14   0x6932             LDR      R2,[R6, #+16]
   \       0x16   0x4291             CMP      R1,R2
   \       0x18   0xD202             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_1
    854              Avail = pRing->RdOff - pRing->WrOff - 1u;
   \       0x1A   0x6930             LDR      R0,[R6, #+16]
   \       0x1C   0x1A41             SUBS     R1,R0,R1
   \       0x1E   0xE003             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_0
    855            } else {
    856              Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_1: (+1)
   \       0x20   0x6932             LDR      R2,[R6, #+16]
   \       0x22   0x68B0             LDR      R0,[R6, #+8]
   \       0x24   0x1A51             SUBS     R1,R2,R1
   \       0x26   0x1841             ADDS     R1,R0,R1
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_0: (+1)
   \       0x28   0x1E49             SUBS     R1,R1,#+1
    857            }
    858            if (NumBytes > Avail) {
   \       0x2A   0x42A1             CMP      R1,R4
   \       0x2C   0xD20B             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_2
    859              pRing->RdOff += (NumBytes - Avail);
   \       0x2E   0x6930             LDR      R0,[R6, #+16]
   \       0x30   0x1820             ADDS     R0,R4,R0
   \       0x32   0x1A41             SUBS     R1,R0,R1
   \       0x34   0x6131             STR      R1,[R6, #+16]
   \       0x36   0xE002             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_3
    860              while (pRing->RdOff >= pRing->SizeOfBuffer) {
    861                pRing->RdOff -= pRing->SizeOfBuffer;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_4: (+1)
   \       0x38   0x6931             LDR      R1,[R6, #+16]
   \       0x3A   0x1A08             SUBS     R0,R1,R0
   \       0x3C   0x6130             STR      R0,[R6, #+16]
    862              }
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_3: (+1)
   \       0x3E   0x68B0             LDR      R0,[R6, #+8]
   \       0x40   0x6931             LDR      R1,[R6, #+16]
   \       0x42   0x4281             CMP      R1,R0
   \       0x44   0xD2F8             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_4
    863            }
    864            //
    865            // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
    866            //
    867            Avail = pRing->SizeOfBuffer - pRing->WrOff;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_2: (+1)
   \       0x46   0x68B7             LDR      R7,[R6, #+8]
   \       0x48   0x68F0             LDR      R0,[R6, #+12]
   \       0x4A   0x1A3F             SUBS     R7,R7,R0
    868            do {
    869              if (Avail > NumBytes) {
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_5: (+1)
   \       0x4C   0x6871             LDR      R1,[R6, #+4]
   \       0x4E   0x68F0             LDR      R0,[R6, #+12]
   \       0x50   0x42BC             CMP      R4,R7
   \       0x52   0x4408             ADD      R0,R1,R0
   \       0x54   0xD30C             BCC.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_6
    870                //
    871                // Last round
    872                //
    873                pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
    874          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    875                Avail = NumBytes;
    876                while (NumBytes--) {
    877                  *pDst++ = *pData++;
    878                };
    879                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    880                pRing->WrOff += Avail;
    881          #else
    882                SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
    883                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    884                pRing->WrOff += NumBytes;
    885          #endif
    886                break;
    887              } else {
    888                //
    889                //  Wrap-around necessary, write until wrap-around and reset WrOff
    890                //
    891                pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
    892          #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
    893                NumBytes -= Avail;
    894                while (Avail--) {
    895                  *pDst++ = *pData++;
    896                };
    897                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    898                pRing->WrOff = 0;
    899          #else
    900                SEGGER_RTT_MEMCPY((void*)pDst, pData, Avail);
    901                pData += Avail;
    902                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    903                pRing->WrOff = 0;
    904                NumBytes -= Avail;
   \       0x56   0x1BE4             SUBS     R4,R4,R7
   \       0x58   0x463A             MOV      R2,R7
   \       0x5A   0x4629             MOV      R1,R5
   \       0x5C   0x443D             ADD      R5,R5,R7
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy
    905          #endif
    906                Avail = (pRing->SizeOfBuffer - 1);
   \       0x62   0x68B7             LDR      R7,[R6, #+8]
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x60F1             STR      R1,[R6, #+12]
   \       0x68   0x1E7F             SUBS     R7,R7,#+1
    907              }
    908            } while (NumBytes);
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD1EE             BNE.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_5
   \       0x6E   0xBDF1             POP      {R0,R4-R7,PC}
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_6: (+1)
   \       0x70   0x4622             MOV      R2,R4
   \       0x72   0x4629             MOV      R1,R5
   \       0x74   0x.... 0x....      BL       __aeabi_memcpy
   \       0x78   0x68F0             LDR      R0,[R6, #+12]
   \       0x7A   0x1824             ADDS     R4,R4,R0
   \       0x7C   0x60F4             STR      R4,[R6, #+12]
    909          }
   \       0x7E   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x4614             MOV      R4,R2
   \        0x6   0x.... 0x....      LDR.W    R2,??DataTable27
   \        0xA   0x4410             ADD      R0,R2,R0
   \        0xC   0xF100 0x0618      ADD      R6,R0,#+24
   \       0x10   0x4770             BX       LR
    910          
    911          /*********************************************************************
    912          *
    913          *       SEGGER_RTT_WriteSkipNoLock
    914          *
    915          *  Function description
    916          *    Stores a specified number of characters in SEGGER RTT
    917          *    control block which is then read by the host.
    918          *    SEGGER_RTT_WriteSkipNoLock does not lock the application and
    919          *    skips all data, if the data does not fit into the buffer.
    920          *
    921          *  Parameters
    922          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    923          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    924          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    925          *                 MUST be > 0!!!
    926          *                 This is done for performance reasons, so no initial check has do be done.
    927          *
    928          *  Return value
    929          *    1: Data has been copied
    930          *    0: No space, data has not been copied
    931          *
    932          *  Notes
    933          *    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
    934          *    (2) For performance reasons this function does not call Init()
    935          *        and may only be called after RTT has been initialized.
    936          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    937          */
    938          #if (RTT_USE_ASM == 0)

   \                                 In section .text, align 2, keep-with-next
    939          unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteSkipNoLock: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4688             MOV      R8,R1
    940            const char*           pData;
    941            SEGGER_RTT_BUFFER_UP* pRing;
    942            unsigned              Avail;
    943            unsigned              RdOff;
    944            unsigned              WrOff;
    945            unsigned              Rem;
    946            volatile char*        pDst;
    947            //
    948            // Cases:
    949            //   1) RdOff <= WrOff => Space until wrap-around is sufficient
    950            //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
    951            //   3) RdOff <  WrOff => No space in buf
    952            //   4) RdOff >  WrOff => Space is sufficient
    953            //   5) RdOff >  WrOff => No space in buf
    954            //
    955            // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
    956            //
    957            pData = (const char *)pBuffer;
    958            pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \        0x6   0x.... 0x....      BL       ?Subroutine7
    959            RdOff = pRing->RdOff;
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xA   0x6931             LDR      R1,[R6, #+16]
    960            WrOff = pRing->WrOff;
   \        0xC   0x68F7             LDR      R7,[R6, #+12]
    961            pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
   \        0xE   0x6870             LDR      R0,[R6, #+4]
    962            if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   \       0x10   0x19E5             ADDS     R5,R4,R7
   \       0x12   0x428F             CMP      R7,R1
   \       0x14   0x4438             ADD      R0,R0,R7
   \       0x16   0xD315             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_0
    963              Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   \       0x18   0x68B2             LDR      R2,[R6, #+8]
   \       0x1A   0x1BD7             SUBS     R7,R2,R7
   \       0x1C   0x1E7A             SUBS     R2,R7,#+1
    964              if (Avail >= NumBytes) {                            // Case 1)?
   \       0x1E   0x42A2             CMP      R2,R4
   \       0x20   0xD214             BCS.N    ??SEGGER_RTT_WriteSkipNoLock_1
    965                memcpy((void*)pDst, pData, NumBytes);
    966                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    967                pRing->WrOff = WrOff + NumBytes;
    968                return 1;
    969              }
    970              Avail += RdOff;                                     // Space incl. wrap-around
    971              if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   \       0x22   0x1889             ADDS     R1,R1,R2
   \       0x24   0x42A1             CMP      R1,R4
   \       0x26   0xD318             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_2
    972                Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
    973                memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
   \       0x28   0x463A             MOV      R2,R7
   \       0x2A   0x4641             MOV      R1,R8
   \       0x2C   0x.... 0x....      BL       __aeabi_memcpy
    974                NumBytes -= Rem;
   \       0x30   0x1BE4             SUBS     R4,R4,R7
    975                //
    976                // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
    977                // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
    978                // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
    979                // Therefore, check if 2nd memcpy is necessary at all
    980                //
    981                if (NumBytes) {
   \       0x32   0xD005             BEQ.N    ??SEGGER_RTT_WriteSkipNoLock_3
    982                  pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    983                  memcpy((void*)pDst, pData + Rem, NumBytes);
   \       0x34   0x6870             LDR      R0,[R6, #+4]
   \       0x36   0x4622             MOV      R2,R4
   \       0x38   0xEB08 0x0107      ADD      R1,R8,R7
   \       0x3C   0x.... 0x....      BL       __aeabi_memcpy
    984                }
    985                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    986                pRing->WrOff = NumBytes;
   \                     ??SEGGER_RTT_WriteSkipNoLock_3: (+1)
   \       0x40   0x60F4             STR      R4,[R6, #+12]
    987                return 1;
   \       0x42   0xE008             B.N      ??SEGGER_RTT_WriteSkipNoLock_4
    988              }
    989            } else {                                             // Potential case 4)
    990              Avail = RdOff - WrOff - 1u;
    991              if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   \                     ??SEGGER_RTT_WriteSkipNoLock_0: (+1)
   \       0x44   0x1BC9             SUBS     R1,R1,R7
   \       0x46   0x1E49             SUBS     R1,R1,#+1
   \       0x48   0x42A1             CMP      R1,R4
   \       0x4A   0xD306             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_2
    992                memcpy((void*)pDst, pData, NumBytes);
   \                     ??SEGGER_RTT_WriteSkipNoLock_1: (+1)
   \       0x4C   0x4622             MOV      R2,R4
   \       0x4E   0x4641             MOV      R1,R8
   \       0x50   0x.... 0x....      BL       __aeabi_memcpy
    993                RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    994                pRing->WrOff = WrOff + NumBytes;
   \       0x54   0x60F5             STR      R5,[R6, #+12]
    995                return 1;
   \                     ??SEGGER_RTT_WriteSkipNoLock_4: (+1)
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0xE000             B.N      ??SEGGER_RTT_WriteSkipNoLock_5
    996              }
    997            }
    998            return 0;     // No space in buffer
   \                     ??SEGGER_RTT_WriteSkipNoLock_2: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??SEGGER_RTT_WriteSkipNoLock_5: (+1)
   \       0x5C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    999          }
   1000          #endif
   1001          
   1002          /*********************************************************************
   1003          *
   1004          *       SEGGER_RTT_WriteDownBufferNoLock
   1005          *
   1006          *  Function description
   1007          *    Stores a specified number of characters in SEGGER RTT
   1008          *    control block inside a <Down> buffer.
   1009          *    SEGGER_RTT_WriteDownBufferNoLock does not lock the application.
   1010          *    Used to do the same operation that J-Link does, to transfer
   1011          *    RTT data from other channels, such as TCP/IP or UART.
   1012          *
   1013          *  Parameters
   1014          *    BufferIndex  Index of "Down"-buffer to be used.
   1015          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1016          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1017          *
   1018          *  Return value
   1019          *    Number of bytes which have been stored in the "Down"-buffer.
   1020          *
   1021          *  Notes
   1022          *    (1) Data is stored according to buffer flags.
   1023          *    (2) For performance reasons this function does not call Init()
   1024          *        and may only be called after RTT has been initialized.
   1025          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
   1026          *
   1027          *  Additional information
   1028          *    This function must not be called when J-Link might also do RTT.
   1029          */

   \                                 In section .text, align 2, keep-with-next
   1030          unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteDownBufferNoLock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine15
   1031            unsigned                Status;
   1032            unsigned                Avail;
   1033            const char*             pData;
   1034            SEGGER_RTT_BUFFER_UP*   pRing;
   1035            //
   1036            // Get "to-target" ring buffer.
   1037            // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
   1038            //
   1039            pData = (const char *)pBuffer;
   1040            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     ??CrossCallReturnLabel_12: (+1)
   \        0x6   0xF101 0x0660      ADD      R6,R1,#+96
   1041            //
   1042            // How we output depends upon the mode...
   1043            //
   1044            switch (pRing->Flags) {
   \        0xA   0x6970             LDR      R0,[R6, #+20]
   \        0xC   0xB118             CBZ.N    R0,??SEGGER_RTT_WriteDownBufferNoLock_0
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD00E             BEQ.N    ??SEGGER_RTT_WriteDownBufferNoLock_1
   \       0x12   0xD305             BCC.N    ??SEGGER_RTT_WriteDownBufferNoLock_2
   \       0x14   0xE010             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_3
   1045            case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   1046              //
   1047              // If we are in skip mode and there is no space for the whole
   1048              // of this output, don't bother.
   1049              //
   1050              Avail = _GetAvailWriteSpace(pRing);
   1051              if (Avail < NumBytes) {
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_0: (+1)
   \       0x16   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xD205             BCS.N    ??SEGGER_RTT_WriteDownBufferNoLock_4
   1052                Status = 0u;
   \       0x1E   0xE00B             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_3
   1053              } else {
   1054                Status = NumBytes;
   1055                _WriteNoCheck(pRing, pData, NumBytes);
   1056              }
   1057              break;
   1058            case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   1059              //
   1060              // If we are in trim mode, trim to what we can output without blocking.
   1061              //
   1062              Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_2: (+1)
   \       0x20   0x.... 0x....      BL       ?Subroutine17
   1063              Status = Avail < NumBytes ? Avail : NumBytes;
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x24   0x42A8             CMP      R0,R5
   \       0x26   0xBF98             IT       LS
   \       0x28   0x4605             MOVLS    R5,R0
   1064              _WriteNoCheck(pRing, pData, Status);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_4: (+1)
   \       0x2A   0x.... 0x....      BL       ?Subroutine11
   1065              break;
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x2E   0xE004             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_5
   1066            case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   1067              //
   1068              // If we are in blocking mode, output everything.
   1069              //
   1070              Status = _WriteBlocking(pRing, pData, NumBytes);
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_1: (+1)
   \       0x30   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x34   0x4605             MOV      R5,R0
   1071              break;
   \       0x36   0xE000             B.N      ??SEGGER_RTT_WriteDownBufferNoLock_5
   1072            default:
   1073              Status = 0u;
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_3: (+1)
   \       0x38   0x2500             MOVS     R5,#+0
   1074              break;
   1075            }
   1076            //
   1077            // Finish up.
   1078            //
   1079            return Status;
   \                     ??SEGGER_RTT_WriteDownBufferNoLock_5: (+1)
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0xBD70             POP      {R4-R6,PC}
   1080          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x....             B.N      _GetAvailWriteSpace

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x460C             MOV      R4,R1
   \        0x2   0x2118             MOVS     R1,#+24
   \        0x4   0x4348             MULS     R0,R1,R0
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable27
   \        0xC   0x1811             ADDS     R1,R2,R0
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x462A             MOV      R2,R5
   \        0x2   0x4621             MOV      R1,R4
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....             B.N      _WriteBlocking

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x462A             MOV      R2,R5
   \        0x2   0x4621             MOV      R1,R4
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....             B.N      _WriteNoCheck
   1081          
   1082          /*********************************************************************
   1083          *
   1084          *       SEGGER_RTT_WriteNoLock
   1085          *
   1086          *  Function description
   1087          *    Stores a specified number of characters in SEGGER RTT
   1088          *    control block which is then read by the host.
   1089          *    SEGGER_RTT_WriteNoLock does not lock the application.
   1090          *
   1091          *  Parameters
   1092          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1093          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1094          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1095          *
   1096          *  Return value
   1097          *    Number of bytes which have been stored in the "Up"-buffer.
   1098          *
   1099          *  Notes
   1100          *    (1) Data is stored according to buffer flags.
   1101          *    (2) For performance reasons this function does not call Init()
   1102          *        and may only be called after RTT has been initialized.
   1103          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
   1104          */

   \                                 In section .text, align 2, keep-with-next
   1105          unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteNoLock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine15
   1106            unsigned              Status;
   1107            unsigned              Avail;
   1108            const char*           pData;
   1109            SEGGER_RTT_BUFFER_UP* pRing;
   1110            //
   1111            // Get "to-host" ring buffer.
   1112            //
   1113            pData = (const char *)pBuffer;
   1114            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     ??CrossCallReturnLabel_13: (+1)
   \        0x6   0xF101 0x0618      ADD      R6,R1,#+24
   1115            //
   1116            // How we output depends upon the mode...
   1117            //
   1118            switch (pRing->Flags) {
   \        0xA   0x6970             LDR      R0,[R6, #+20]
   \        0xC   0xB118             CBZ.N    R0,??SEGGER_RTT_WriteNoLock_0
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD00E             BEQ.N    ??SEGGER_RTT_WriteNoLock_1
   \       0x12   0xD305             BCC.N    ??SEGGER_RTT_WriteNoLock_2
   \       0x14   0xE010             B.N      ??SEGGER_RTT_WriteNoLock_3
   1119            case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   1120              //
   1121              // If we are in skip mode and there is no space for the whole
   1122              // of this output, don't bother.
   1123              //
   1124              Avail = _GetAvailWriteSpace(pRing);
   1125              if (Avail < NumBytes) {
   \                     ??SEGGER_RTT_WriteNoLock_0: (+1)
   \       0x16   0x.... 0x....      BL       ?Subroutine17
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xD205             BCS.N    ??SEGGER_RTT_WriteNoLock_4
   1126                Status = 0u;
   \       0x1E   0xE00B             B.N      ??SEGGER_RTT_WriteNoLock_3
   1127              } else {
   1128                Status = NumBytes;
   1129                _WriteNoCheck(pRing, pData, NumBytes);
   1130              }
   1131              break;
   1132            case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   1133              //
   1134              // If we are in trim mode, trim to what we can output without blocking.
   1135              //
   1136              Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteNoLock_2: (+1)
   \       0x20   0x.... 0x....      BL       ?Subroutine17
   1137              Status = Avail < NumBytes ? Avail : NumBytes;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x24   0x42A8             CMP      R0,R5
   \       0x26   0xBF98             IT       LS
   \       0x28   0x4605             MOVLS    R5,R0
   1138              _WriteNoCheck(pRing, pData, Status);
   \                     ??SEGGER_RTT_WriteNoLock_4: (+1)
   \       0x2A   0x.... 0x....      BL       ?Subroutine11
   1139              break;
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x2E   0xE004             B.N      ??SEGGER_RTT_WriteNoLock_5
   1140            case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   1141              //
   1142              // If we are in blocking mode, output everything.
   1143              //
   1144              Status = _WriteBlocking(pRing, pData, NumBytes);
   \                     ??SEGGER_RTT_WriteNoLock_1: (+1)
   \       0x30   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x34   0x4605             MOV      R5,R0
   1145              break;
   \       0x36   0xE000             B.N      ??SEGGER_RTT_WriteNoLock_5
   1146            default:
   1147              Status = 0u;
   \                     ??SEGGER_RTT_WriteNoLock_3: (+1)
   \       0x38   0x2500             MOVS     R5,#+0
   1148              break;
   1149            }
   1150            //
   1151            // Finish up.
   1152            //
   1153            return Status;
   \                     ??SEGGER_RTT_WriteNoLock_5: (+1)
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0xBD70             POP      {R4-R6,PC}
   1154          }
   1155          
   1156          /*********************************************************************
   1157          *
   1158          *       SEGGER_RTT_WriteDownBuffer
   1159          *
   1160          *  Function description
   1161          *    Stores a specified number of characters in SEGGER RTT control block in a <Down> buffer.
   1162          *
   1163          *  Parameters
   1164          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1165          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1166          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1167          *
   1168          *  Return value
   1169          *    Number of bytes which have been stored in the "Down"-buffer.
   1170          *
   1171          *  Notes
   1172          *    (1) Data is stored according to buffer flags.
   1173          *
   1174          *  Additional information
   1175          *    This function must not be called when J-Link might also do RTT.
   1176          *    This function locks against all other RTT operations. I.e. during
   1177          *    the write operation, writing from the application is also locked.
   1178          *    If only one consumer writes to the down buffer,
   1179          *    call SEGGER_RTT_WriteDownBufferNoLock() instead.
   1180          */

   \                                 In section .text, align 2, keep-with-next
   1181          unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_WriteDownBuffer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4605             MOV      R5,R0
   1182            unsigned Status;
   1183          
   1184            INIT();
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable27
   \        0xA   0x7808             LDRB     R0,[R1, #+0]
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0x2853             CMP      R0,#+83
   \       0x10   0xBF18             IT       NE
   \       0x12   0x.... 0x....      BLNE     _DoInit
   1185            SEGGER_RTT_LOCK();
   \       0x16   0x.... 0x....      BL       ?Subroutine14
   1186            Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x1A   0x.... 0x....      BL       SEGGER_RTT_WriteDownBufferNoLock
   1187            SEGGER_RTT_UNLOCK();
   \       0x1E   0x....             B.N      ?Subroutine6
   1188            return Status;
   1189          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xF384 0x8811      MSR      BASEPRI,R4
   \        0x4   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0xF3EF 0x8411      MRS      R4,BASEPRI
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0x463A             MOV      R2,R7
   \        0xC   0x4631             MOV      R1,R6
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x4770             BX       LR
   1190          
   1191          /*********************************************************************
   1192          *
   1193          *       SEGGER_RTT_Write
   1194          *
   1195          *  Function description
   1196          *    Stores a specified number of characters in SEGGER RTT
   1197          *    control block which is then read by the host.
   1198          *
   1199          *  Parameters
   1200          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1201          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
   1202          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
   1203          *
   1204          *  Return value
   1205          *    Number of bytes which have been stored in the "Up"-buffer.
   1206          *
   1207          *  Notes
   1208          *    (1) Data is stored according to buffer flags.
   1209          */

   \                                 In section .text, align 2, keep-with-next
   1210          unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   \                     SEGGER_RTT_Write: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4605             MOV      R5,R0
   1211            unsigned Status;
   1212          
   1213            INIT();
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable27
   \        0xA   0x7808             LDRB     R0,[R1, #+0]
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0x2853             CMP      R0,#+83
   \       0x10   0xBF18             IT       NE
   \       0x12   0x.... 0x....      BLNE     _DoInit
   1214            SEGGER_RTT_LOCK();
   \       0x16   0x.... 0x....      BL       ?Subroutine14
   1215            Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x1A   0x.... 0x....      BL       SEGGER_RTT_WriteNoLock
   1216            SEGGER_RTT_UNLOCK();
   \       0x1E                      REQUIRE ?Subroutine6
   \       0x1E                      ;; // Fall through to label ?Subroutine6
   1217            return Status;
   1218          }
   1219          
   1220          /*********************************************************************
   1221          *
   1222          *       SEGGER_RTT_WriteString
   1223          *
   1224          *  Function description
   1225          *    Stores string in SEGGER RTT control block.
   1226          *    This data is read by the host.
   1227          *
   1228          *  Parameters
   1229          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1230          *    s            Pointer to string.
   1231          *
   1232          *  Return value
   1233          *    Number of bytes which have been stored in the "Up"-buffer.
   1234          *
   1235          *  Notes
   1236          *    (1) Data is stored according to buffer flags.
   1237          *    (2) String passed to this function has to be \0 terminated
   1238          *    (3) \0 termination character is *not* stored in RTT buffer
   1239          */

   \                                 In section .text, align 2, keep-with-next
   1240          unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
   \                     SEGGER_RTT_WriteString: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   1241            unsigned Len;
   1242          
   1243            Len = STRLEN(s);
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x.... 0x....      BL       strlen
   1244            return SEGGER_RTT_Write(BufferIndex, s, Len);
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0x4621             MOV      R1,R4
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x16   0x....             B.N      SEGGER_RTT_Write
   1245          }
   1246          
   1247          /*********************************************************************
   1248          *
   1249          *       SEGGER_RTT_PutCharSkipNoLock
   1250          *
   1251          *  Function description
   1252          *    Stores a single character/byte in SEGGER RTT buffer.
   1253          *    SEGGER_RTT_PutCharSkipNoLock does not lock the application and
   1254          *    skips the byte, if it does not fit into the buffer.
   1255          *
   1256          *  Parameters
   1257          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1258          *    c            Byte to be stored.
   1259          *
   1260          *  Return value
   1261          *    Number of bytes which have been stored in the "Up"-buffer.
   1262          *
   1263          *  Notes
   1264          *    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
   1265          *    (2) For performance reasons this function does not call Init()
   1266          *        and may only be called after RTT has been initialized.
   1267          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
   1268          */
   1269          

   \                                 In section .text, align 2, keep-with-next
   1270          unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
   1271            SEGGER_RTT_BUFFER_UP* pRing;
   1272            unsigned              WrOff;
   1273            unsigned              Status;
   1274            volatile char*        pDst;
   1275            //
   1276            // Get "to-host" ring buffer.
   1277            //
   1278            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     SEGGER_RTT_PutCharSkipNoLock: (+1)
   \        0x0   0x2218             MOVS     R2,#+24
   \        0x2   0x4350             MULS     R0,R2,R0
   \        0x4   0x.... 0x....      LDR.W    R3,??DataTable27
   \        0x8   0xB530             PUSH     {R4,R5,LR}
   \        0xA   0x4418             ADD      R0,R3,R0
   \        0xC   0x3018             ADDS     R0,R0,#+24
   1279            //
   1280            // Get write position and handle wrap-around if necessary
   1281            //
   1282            WrOff = pRing->WrOff + 1;
   \        0xE   0x68C2             LDR      R2,[R0, #+12]
   1283            if (WrOff == pRing->SizeOfBuffer) {
   \       0x10   0x6884             LDR      R4,[R0, #+8]
   \       0x12   0x1C53             ADDS     R3,R2,#+1
   \       0x14   0x42A3             CMP      R3,R4
   \       0x16   0xBF08             IT       EQ
   \       0x18   0x2300             MOVEQ    R3,#+0
   1284              WrOff = 0;
   1285            }
   1286            //
   1287            // Output byte if free space is available
   1288            //
   1289            if (WrOff != pRing->RdOff) {
   \       0x1A   0x6905             LDR      R5,[R0, #+16]
   \       0x1C   0x42AB             CMP      R3,R5
   \       0x1E   0xD004             BEQ.N    ??SEGGER_RTT_PutCharSkipNoLock_0
   1290              pDst = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   1291              *pDst = c;
   \       0x20   0x6844             LDR      R4,[R0, #+4]
   \       0x22   0x54A1             STRB     R1,[R4, R2]
   1292              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1293              pRing->WrOff = WrOff;
   \       0x24   0x60C3             STR      R3,[R0, #+12]
   1294              Status = 1;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xBD30             POP      {R4,R5,PC}
   1295            } else {
   1296              Status = 0;
   \                     ??SEGGER_RTT_PutCharSkipNoLock_0: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   1297            }
   1298            //
   1299            return Status;
   \       0x2C   0xBD30             POP      {R4,R5,PC}
   1300          }
   1301          
   1302          /*********************************************************************
   1303          *
   1304          *       SEGGER_RTT_PutCharSkip
   1305          *
   1306          *  Function description
   1307          *    Stores a single character/byte in SEGGER RTT buffer.
   1308          *
   1309          *  Parameters
   1310          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1311          *    c            Byte to be stored.
   1312          *
   1313          *  Return value
   1314          *    Number of bytes which have been stored in the "Up"-buffer.
   1315          *
   1316          *  Notes
   1317          *    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
   1318          */
   1319          

   \                                 In section .text, align 2, keep-with-next
   1320          unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
   \                     SEGGER_RTT_PutCharSkip: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   1321            SEGGER_RTT_BUFFER_UP* pRing;
   1322            unsigned              WrOff;
   1323            unsigned              Status;
   1324            volatile char*        pDst;
   1325            //
   1326            // Prepare
   1327            //
   1328            INIT();
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable27
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x2853             CMP      R0,#+83
   \        0xE   0xBF18             IT       NE
   \       0x10   0x.... 0x....      BLNE     _DoInit
   1329            SEGGER_RTT_LOCK();
   \       0x14   0x.... 0x....      BL       ?Subroutine9
   1330            //
   1331            // Get "to-host" ring buffer.
   1332            //
   1333            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1334            //
   1335            // Get write position and handle wrap-around if necessary
   1336            //
   1337            WrOff = pRing->WrOff + 1;
   1338            if (WrOff == pRing->SizeOfBuffer) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x18   0xBF08             IT       EQ
   \       0x1A   0x2300             MOVEQ    R3,#+0
   1339              WrOff = 0;
   1340            }
   1341            //
   1342            // Output byte if free space is available
   1343            //
   1344            if (WrOff != pRing->RdOff) {
   \       0x1C   0x....             B.N      ?Subroutine3
   1345              pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   1346              *pDst = c;
   1347              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1348              pRing->WrOff = WrOff;
   1349              Status = 1;
   1350            } else {
   1351              Status = 0;
   1352            }
   1353            //
   1354            // Finish up.
   1355            //
   1356            SEGGER_RTT_UNLOCK();
   1357            //
   1358            return Status;
   1359          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6906             LDR      R6,[R0, #+16]
   \        0x2   0x42B3             CMP      R3,R6
   \        0x4   0xD004             BEQ.N    ??Subroutine3_0
   \        0x6   0x6845             LDR      R5,[R0, #+4]
   \        0x8   0x54AC             STRB     R4,[R5, R2]
   \        0xA   0x60C3             STR      R3,[R0, #+12]
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B.N      ??Subroutine3_1
   \                     ??Subroutine3_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??Subroutine3_1: (+1)
   \       0x12   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x16   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA   0x2018             MOVS     R0,#+24
   \        0xC   0x4346             MULS     R6,R0,R6
   \        0xE   0x19A8             ADDS     R0,R5,R6
   \       0x10   0x3018             ADDS     R0,R0,#+24
   \       0x12   0x68C2             LDR      R2,[R0, #+12]
   \       0x14   0x6885             LDR      R5,[R0, #+8]
   \       0x16   0x1C53             ADDS     R3,R2,#+1
   \       0x18   0x42AB             CMP      R3,R5
   \       0x1A   0x4770             BX       LR
   1360          
   1361           /*********************************************************************
   1362          *
   1363          *       SEGGER_RTT_PutChar
   1364          *
   1365          *  Function description
   1366          *    Stores a single character/byte in SEGGER RTT buffer.
   1367          *
   1368          *  Parameters
   1369          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
   1370          *    c            Byte to be stored.
   1371          *
   1372          *  Return value
   1373          *    Number of bytes which have been stored in the "Up"-buffer.
   1374          *
   1375          *  Notes
   1376          *    (1) Data is stored according to buffer flags.
   1377          */
   1378          

   \                                 In section .text, align 2, keep-with-next
   1379          unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
   \                     SEGGER_RTT_PutChar: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   1380            SEGGER_RTT_BUFFER_UP* pRing;
   1381            unsigned              WrOff;
   1382            unsigned              Status;
   1383            volatile char*        pDst;
   1384            //
   1385            // Prepare
   1386            //
   1387            INIT();
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable27
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x2853             CMP      R0,#+83
   \        0xE   0xBF18             IT       NE
   \       0x10   0x.... 0x....      BLNE     _DoInit
   1388            SEGGER_RTT_LOCK();
   \       0x14   0x.... 0x....      BL       ?Subroutine9
   1389            //
   1390            // Get "to-host" ring buffer.
   1391            //
   1392            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1393            //
   1394            // Get write position and handle wrap-around if necessary
   1395            //
   1396            WrOff = pRing->WrOff + 1;
   1397            if (WrOff == pRing->SizeOfBuffer) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x18   0xBF08             IT       EQ
   \       0x1A   0x2300             MOVEQ    R3,#+0
   1398              WrOff = 0;
   1399            }
   1400            //
   1401            // Wait for free space if mode is set to blocking
   1402            //
   1403            if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
   \       0x1C   0x6945             LDR      R5,[R0, #+20]
   \       0x1E   0x2D02             CMP      R5,#+2
   \       0x20   0xD102             BNE.N    ??SEGGER_RTT_PutChar_0
   1404              while (WrOff == pRing->RdOff) {
   \                     ??SEGGER_RTT_PutChar_1: (+1)
   \       0x22   0x6905             LDR      R5,[R0, #+16]
   \       0x24   0x42AB             CMP      R3,R5
   \       0x26   0xD0FC             BEQ.N    ??SEGGER_RTT_PutChar_1
   1405                ;
   1406              }
   1407            }
   1408            //
   1409            // Output byte if free space is available
   1410            //
   1411            if (WrOff != pRing->RdOff) {
   \                     ??SEGGER_RTT_PutChar_0: (+1)
   \       0x28                      REQUIRE ?Subroutine3
   \       0x28                      ;; // Fall through to label ?Subroutine3
   1412              pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
   1413              *pDst = c;
   1414              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1415              pRing->WrOff = WrOff;
   1416              Status = 1;
   1417            } else {
   1418              Status = 0;
   1419            }
   1420            //
   1421            // Finish up.
   1422            //
   1423            SEGGER_RTT_UNLOCK();
   1424            return Status;
   1425          }
   1426          
   1427          /*********************************************************************
   1428          *
   1429          *       SEGGER_RTT_GetKey
   1430          *
   1431          *  Function description
   1432          *    Reads one character from the SEGGER RTT buffer.
   1433          *    Host has previously stored data there.
   1434          *
   1435          *  Return value
   1436          *    <  0 -   No character available (buffer empty).
   1437          *    >= 0 -   Character which has been read. (Possible values: 0 - 255)
   1438          *
   1439          *  Notes
   1440          *    (1) This function is only specified for accesses to RTT buffer 0.
   1441          */

   \                                 In section .text, align 2, keep-with-next
   1442          int SEGGER_RTT_GetKey(void) {
   \                     SEGGER_RTT_GetKey: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1443            char c;
   1444            int r;
   1445          
   1446            r = (int)SEGGER_RTT_Read(0u, &c, 1u);
   1447            if (r == 1) {
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x.... 0x....      BL       SEGGER_RTT_Read
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD102             BNE.N    ??SEGGER_RTT_GetKey_0
   1448              r = (int)(unsigned char)c;
   \       0x10   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x14   0xBD02             POP      {R1,PC}
   1449            } else {
   1450              r = -1;
   \                     ??SEGGER_RTT_GetKey_0: (+1)
   \       0x16   0xF04F 0x30FF      MOV      R0,#+4294967295
   1451            }
   1452            return r;
   \       0x1A   0xBD02             POP      {R1,PC}
   1453          }
   1454          
   1455          /*********************************************************************
   1456          *
   1457          *       SEGGER_RTT_WaitKey
   1458          *
   1459          *  Function description
   1460          *    Waits until at least one character is avaible in the SEGGER RTT buffer.
   1461          *    Once a character is available, it is read and this function returns.
   1462          *
   1463          *  Return value
   1464          *    >=0 -   Character which has been read.
   1465          *
   1466          *  Notes
   1467          *    (1) This function is only specified for accesses to RTT buffer 0
   1468          *    (2) This function is blocking if no character is present in RTT buffer
   1469          */

   \                                 In section .text, align 2, keep-with-next
   1470          int SEGGER_RTT_WaitKey(void) {
   \                     SEGGER_RTT_WaitKey: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1471            int r;
   1472          
   1473            do {
   1474              r = SEGGER_RTT_GetKey();
   \                     ??SEGGER_RTT_WaitKey_0: (+1)
   \        0x2   0x.... 0x....      BL       SEGGER_RTT_GetKey
   1475            } while (r < 0);
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD4FB             BMI.N    ??SEGGER_RTT_WaitKey_0
   1476            return r;
   \        0xA   0xBD02             POP      {R1,PC}
   1477          }
   1478          
   1479          /*********************************************************************
   1480          *
   1481          *       SEGGER_RTT_HasKey
   1482          *
   1483          *  Function description
   1484          *    Checks if at least one character for reading is available in the SEGGER RTT buffer.
   1485          *
   1486          *  Return value
   1487          *    == 0 -     No characters are available to read.
   1488          *    == 1 -     At least one character is available.
   1489          *
   1490          *  Notes
   1491          *    (1) This function is only specified for accesses to RTT buffer 0
   1492          */

   \                                 In section .text, align 2, keep-with-next
   1493          int SEGGER_RTT_HasKey(void) {
   \                     SEGGER_RTT_HasKey: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1494            SEGGER_RTT_BUFFER_DOWN* pRing;
   1495            unsigned RdOff;
   1496            int r;
   1497          
   1498            INIT();
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable27
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0x2853             CMP      R0,#+83
   \        0xA   0xBF18             IT       NE
   \        0xC   0x.... 0x....      BLNE     _DoInit
   1499            pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1500            RdOff = pRing->RdOff;
   1501            if (RdOff != pRing->WrOff) {
   \       0x10   0xF104 0x0160      ADD      R1,R4,#+96
   \       0x14   0x6908             LDR      R0,[R1, #+16]
   \       0x16   0x68C9             LDR      R1,[R1, #+12]
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xD001             BEQ.N    ??SEGGER_RTT_HasKey_0
   1502              r = 1;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xBD10             POP      {R4,PC}
   1503            } else {
   1504              r = 0;
   \                     ??SEGGER_RTT_HasKey_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   1505            }
   1506            return r;
   \       0x22   0xBD10             POP      {R4,PC}
   1507          }
   1508          
   1509          /*********************************************************************
   1510          *
   1511          *       SEGGER_RTT_HasData
   1512          *
   1513          *  Function description
   1514          *    Check if there is data from the host in the given buffer.
   1515          *
   1516          *  Return value:
   1517          *  ==0:  No data
   1518          *  !=0:  Data in buffer
   1519          *
   1520          */

   \                                 In section .text, align 2, keep-with-next
   1521          unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
   1522            SEGGER_RTT_BUFFER_DOWN* pRing;
   1523            unsigned                v;
   1524          
   1525            pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     SEGGER_RTT_HasData: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable27
   \        0x8   0x4410             ADD      R0,R2,R0
   \        0xA   0xF100 0x0160      ADD      R1,R0,#+96
   1526            v = pRing->WrOff;
   \        0xE   0x68C8             LDR      R0,[R1, #+12]
   1527            return v - pRing->RdOff;
   \       0x10   0x6909             LDR      R1,[R1, #+16]
   \       0x12   0x1A40             SUBS     R0,R0,R1
   \       0x14   0x4770             BX       LR
   1528          }
   1529          
   1530          /*********************************************************************
   1531          *
   1532          *       SEGGER_RTT_HasDataUp
   1533          *
   1534          *  Function description
   1535          *    Check if there is data remaining to be sent in the given buffer.
   1536          *
   1537          *  Return value:
   1538          *  ==0:  No data
   1539          *  !=0:  Data in buffer
   1540          *
   1541          */

   \                                 In section .text, align 2, keep-with-next
   1542          unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
   1543            SEGGER_RTT_BUFFER_UP* pRing;
   1544            unsigned                v;
   1545          
   1546            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   \                     SEGGER_RTT_HasDataUp: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable27
   \        0x8   0x4410             ADD      R0,R2,R0
   \        0xA   0xF100 0x0118      ADD      R1,R0,#+24
   1547            v = pRing->RdOff;
   \        0xE   0x6908             LDR      R0,[R1, #+16]
   1548            return pRing->WrOff - v;
   \       0x10   0x68C9             LDR      R1,[R1, #+12]
   \       0x12   0x1A08             SUBS     R0,R1,R0
   \       0x14   0x4770             BX       LR
   1549          }
   1550          
   1551          /*********************************************************************
   1552          *
   1553          *       SEGGER_RTT_AllocDownBuffer
   1554          *
   1555          *  Function description
   1556          *    Run-time configuration of the next down-buffer (H->T).
   1557          *    The next buffer, which is not used yet is configured.
   1558          *    This includes: Buffer address, size, name, flags, ...
   1559          *
   1560          *  Parameters
   1561          *    sName        Pointer to a constant name string.
   1562          *    pBuffer      Pointer to a buffer to be used.
   1563          *    BufferSize   Size of the buffer.
   1564          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1565          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1566          *
   1567          *  Return value
   1568          *    >= 0 - O.K. Buffer Index
   1569          *     < 0 - Error
   1570          */

   \                                 In section .text, align 2, keep-with-next
   1571          int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_AllocDownBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   1572            int BufferIndex;
   1573            volatile SEGGER_RTT_CB* pRTTCB;
   1574          
   1575            INIT();
   \        0x6   0x.... 0x....      LDR.W    R7,??DataTable27
   \        0xA   0x7838             LDRB     R0,[R7, #+0]
   \        0xC   0x460D             MOV      R5,R1
   \        0xE   0x4616             MOV      R6,R2
   \       0x10   0x4698             MOV      R8,R3
   \       0x12   0x2853             CMP      R0,#+83
   \       0x14   0xBF18             IT       NE
   \       0x16   0x.... 0x....      BLNE     _DoInit
   1576            SEGGER_RTT_LOCK();
   \       0x1A   0x.... 0x....      BL       ?Subroutine18
   1577            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1578            BufferIndex = 0;
   1579            do {
   1580              if (pRTTCB->aDown[BufferIndex].pBuffer == NULL) {
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x1E   0xFB03 0xFC01      MUL      R12,R3,R1
   \       0x22   0xF107 0x0E64      ADD      LR,R7,#+100
   \       0x26   0xF85E 0x000C      LDR      R0,[LR, R12]
   \       0x2A   0xB120             CBZ.N    R0,??SEGGER_RTT_AllocDownBuffer_0
   1581                break;
   1582              }
   1583              BufferIndex++;
   1584            } while (BufferIndex < pRTTCB->MaxNumDownBuffers);
   \       0x2C   0xF8D7 0xC014      LDR      R12,[R7, #+20]
   \       0x30   0x1C49             ADDS     R1,R1,#+1
   \       0x32   0x4561             CMP      R1,R12
   \       0x34   0xDBF3             BLT.N    ??CrossCallReturnLabel_20
   1585            if (BufferIndex < pRTTCB->MaxNumDownBuffers) {
   \                     ??SEGGER_RTT_AllocDownBuffer_0: (+1)
   \       0x36   0x6978             LDR      R0,[R7, #+20]
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xDA0B             BGE.N    ??SEGGER_RTT_AllocDownBuffer_1
   1586              pRTTCB->aDown[BufferIndex].sName        = sName;
   \       0x3C   0x434B             MULS     R3,R3,R1
   \       0x3E   0x18F8             ADDS     R0,R7,R3
   \       0x40   0x6604             STR      R4,[R0, #+96]
   1587              pRTTCB->aDown[BufferIndex].pBuffer      = (char*)pBuffer;
   \       0x42   0x6645             STR      R5,[R0, #+100]
   1588              pRTTCB->aDown[BufferIndex].SizeOfBuffer = BufferSize;
   \       0x44   0x6686             STR      R6,[R0, #+104]
   1589              pRTTCB->aDown[BufferIndex].RdOff        = 0u;
   \       0x46   0x2400             MOVS     R4,#+0
   \       0x48   0x6704             STR      R4,[R0, #+112]
   1590              pRTTCB->aDown[BufferIndex].WrOff        = 0u;
   \       0x4A   0x2300             MOVS     R3,#+0
   \       0x4C   0x66C3             STR      R3,[R0, #+108]
   1591              pRTTCB->aDown[BufferIndex].Flags        = Flags;
   \       0x4E   0xF8C0 0x8074      STR      R8,[R0, #+116]
   \       0x52   0xE001             B.N      ??SEGGER_RTT_AllocDownBuffer_2
   1592              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1593            } else {
   1594              BufferIndex = -1;
   \                     ??SEGGER_RTT_AllocDownBuffer_1: (+1)
   \       0x54   0xF04F 0x31FF      MOV      R1,#+4294967295
   1595            }
   1596            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_AllocDownBuffer_2: (+1)
   \       0x58   0x....             B.N      ?Subroutine2
   1597            return BufferIndex;
   1598          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF382 0x8811      MSR      BASEPRI,R2
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0xE8BD 0x81F0      POP      {R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0xF3EF 0x8211      MRS      R2,BASEPRI
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x2318             MOVS     R3,#+24
   \        0xE   0x4770             BX       LR
   1599          
   1600          /*********************************************************************
   1601          *
   1602          *       SEGGER_RTT_AllocUpBuffer
   1603          *
   1604          *  Function description
   1605          *    Run-time configuration of the next up-buffer (T->H).
   1606          *    The next buffer, which is not used yet is configured.
   1607          *    This includes: Buffer address, size, name, flags, ...
   1608          *
   1609          *  Parameters
   1610          *    sName        Pointer to a constant name string.
   1611          *    pBuffer      Pointer to a buffer to be used.
   1612          *    BufferSize   Size of the buffer.
   1613          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1614          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1615          *
   1616          *  Return value
   1617          *    >= 0 - O.K. Buffer Index
   1618          *     < 0 - Error
   1619          */

   \                                 In section .text, align 2, keep-with-next
   1620          int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_AllocUpBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   1621            int BufferIndex;
   1622            volatile SEGGER_RTT_CB* pRTTCB;
   1623          
   1624            INIT();
   \        0x6   0x....             LDR.N    R7,??DataTable27
   \        0x8   0x7838             LDRB     R0,[R7, #+0]
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x4698             MOV      R8,R3
   \       0x10   0x2853             CMP      R0,#+83
   \       0x12   0xBF18             IT       NE
   \       0x14   0x.... 0x....      BLNE     _DoInit
   1625            SEGGER_RTT_LOCK();
   \       0x18   0x.... 0x....      BL       ?Subroutine18
   1626            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1627            BufferIndex = 0;
   1628            do {
   1629              if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x1C   0xFB03 0xFC01      MUL      R12,R3,R1
   \       0x20   0xF107 0x0E1C      ADD      LR,R7,#+28
   \       0x24   0xF85E 0x000C      LDR      R0,[LR, R12]
   \       0x28   0xB120             CBZ.N    R0,??SEGGER_RTT_AllocUpBuffer_0
   1630                break;
   1631              }
   1632              BufferIndex++;
   1633            } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
   \       0x2A   0xF8D7 0xC010      LDR      R12,[R7, #+16]
   \       0x2E   0x1C49             ADDS     R1,R1,#+1
   \       0x30   0x4561             CMP      R1,R12
   \       0x32   0xDBF3             BLT.N    ??CrossCallReturnLabel_21
   1634            if (BufferIndex < pRTTCB->MaxNumUpBuffers) {
   \                     ??SEGGER_RTT_AllocUpBuffer_0: (+1)
   \       0x34   0x6938             LDR      R0,[R7, #+16]
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xDA0B             BGE.N    ??SEGGER_RTT_AllocUpBuffer_1
   1635              pRTTCB->aUp[BufferIndex].sName        = sName;
   \       0x3A   0x434B             MULS     R3,R3,R1
   \       0x3C   0x18F8             ADDS     R0,R7,R3
   \       0x3E   0x6184             STR      R4,[R0, #+24]
   1636              pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
   \       0x40   0x61C5             STR      R5,[R0, #+28]
   1637              pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
   \       0x42   0x6206             STR      R6,[R0, #+32]
   1638              pRTTCB->aUp[BufferIndex].RdOff        = 0u;
   \       0x44   0x2400             MOVS     R4,#+0
   \       0x46   0x6284             STR      R4,[R0, #+40]
   1639              pRTTCB->aUp[BufferIndex].WrOff        = 0u;
   \       0x48   0x2300             MOVS     R3,#+0
   \       0x4A   0x6243             STR      R3,[R0, #+36]
   1640              pRTTCB->aUp[BufferIndex].Flags        = Flags;
   \       0x4C   0xF8C0 0x802C      STR      R8,[R0, #+44]
   \       0x50   0xE001             B.N      ??SEGGER_RTT_AllocUpBuffer_2
   1641              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1642            } else {
   1643              BufferIndex = -1;
   \                     ??SEGGER_RTT_AllocUpBuffer_1: (+1)
   \       0x52   0xF04F 0x31FF      MOV      R1,#+4294967295
   1644            }
   1645            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_AllocUpBuffer_2: (+1)
   \       0x56                      REQUIRE ?Subroutine2
   \       0x56                      ;; // Fall through to label ?Subroutine2
   1646            return BufferIndex;
   1647          }
   1648          
   1649          /*********************************************************************
   1650          *
   1651          *       SEGGER_RTT_ConfigUpBuffer
   1652          *
   1653          *  Function description
   1654          *    Run-time configuration of a specific up-buffer (T->H).
   1655          *    Buffer to be configured is specified by index.
   1656          *    This includes: Buffer address, size, name, flags, ...
   1657          *
   1658          *  Parameters
   1659          *    BufferIndex  Index of the buffer to configure.
   1660          *    sName        Pointer to a constant name string.
   1661          *    pBuffer      Pointer to a buffer to be used.
   1662          *    BufferSize   Size of the buffer.
   1663          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1664          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1665          *
   1666          *  Return value
   1667          *    >= 0 - O.K.
   1668          *     < 0 - Error
   1669          *
   1670          *  Additional information
   1671          *    Buffer 0 is configured on compile-time.
   1672          *    May only be called once per buffer.
   1673          *    Buffer name and flags can be reconfigured using the appropriate functions.
   1674          */

   \                                 In section .text, align 2, keep-with-next
   1675          int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_ConfigUpBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   1676            int r;
   1677            volatile SEGGER_RTT_CB* pRTTCB;
   1678            volatile SEGGER_RTT_BUFFER_UP* pUp;
   1679          
   1680            INIT();
   \        0x6   0x.... 0x....      LDR.W    R8,??DataTable27
   \        0xA   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \        0xE   0x460D             MOV      R5,R1
   \       0x10   0x4616             MOV      R6,R2
   \       0x12   0x461F             MOV      R7,R3
   \       0x14   0x2853             CMP      R0,#+83
   \       0x16   0xBF18             IT       NE
   \       0x18   0x.... 0x....      BLNE     _DoInit
   1681            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1682            if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
   \       0x1C   0x2C03             CMP      R4,#+3
   \       0x1E   0xD205             BCS.N    ??SEGGER_RTT_ConfigUpBuffer_0
   1683              SEGGER_RTT_LOCK();
   \       0x20   0x.... 0x....      BL       ?Subroutine19
   1684              pUp = &pRTTCB->aUp[BufferIndex];
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x24   0x3118             ADDS     R1,R1,#+24
   1685              if (BufferIndex) {
   \       0x26   0x.... 0x....      BL       ?Subroutine13
   1686                pUp->sName        = sName;
   1687                pUp->pBuffer      = (char*)pBuffer;
   1688                pUp->SizeOfBuffer = BufferSize;
   1689                pUp->RdOff        = 0u;
   1690                pUp->WrOff        = 0u;
   1691              }
   1692              pUp->Flags          = Flags;
   1693              SEGGER_RTT_UNLOCK();
   1694              r =  0;
   1695            } else {
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x2A   0xE001             B.N      ??SEGGER_RTT_ConfigUpBuffer_1
   1696              r = -1;
   \                     ??SEGGER_RTT_ConfigUpBuffer_0: (+1)
   \       0x2C   0xF04F 0x30FF      MOV      R0,#+4294967295
   1697            }
   1698            return r;
   \                     ??SEGGER_RTT_ConfigUpBuffer_1: (+1)
   \       0x30   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1699          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0xF3EF 0x8011      MRS      R0,BASEPRI
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA   0x2118             MOVS     R1,#+24
   \        0xC   0x4361             MULS     R1,R1,R4
   \        0xE   0x4441             ADD      R1,R8,R1
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0xB134             CBZ.N    R4,??Subroutine13_0
   \        0x2   0x600D             STR      R5,[R1, #+0]
   \        0x4   0x604E             STR      R6,[R1, #+4]
   \        0x6   0x608F             STR      R7,[R1, #+8]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x610B             STR      R3,[R1, #+16]
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x60CA             STR      R2,[R1, #+12]
   \                     ??Subroutine13_0: (+1)
   \       0x10   0x9A06             LDR      R2,[SP, #+24]
   \       0x12   0x614A             STR      R2,[R1, #+20]
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4770             BX       LR
   1700          
   1701          /*********************************************************************
   1702          *
   1703          *       SEGGER_RTT_ConfigDownBuffer
   1704          *
   1705          *  Function description
   1706          *    Run-time configuration of a specific down-buffer (H->T).
   1707          *    Buffer to be configured is specified by index.
   1708          *    This includes: Buffer address, size, name, flags, ...
   1709          *
   1710          *  Parameters
   1711          *    BufferIndex  Index of the buffer to configure.
   1712          *    sName        Pointer to a constant name string.
   1713          *    pBuffer      Pointer to a buffer to be used.
   1714          *    BufferSize   Size of the buffer.
   1715          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1716          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1717          *
   1718          *  Return value
   1719          *    >= 0  O.K.
   1720          *     < 0  Error
   1721          *
   1722          *  Additional information
   1723          *    Buffer 0 is configured on compile-time.
   1724          *    May only be called once per buffer.
   1725          *    Buffer name and flags can be reconfigured using the appropriate functions.
   1726          */

   \                                 In section .text, align 2, keep-with-next
   1727          int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
   \                     SEGGER_RTT_ConfigDownBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   1728            int r;
   1729            volatile SEGGER_RTT_CB* pRTTCB;
   1730            volatile SEGGER_RTT_BUFFER_DOWN* pDown;
   1731          
   1732            INIT();
   \        0x6   0x.... 0x....      LDR.W    R8,??DataTable27
   \        0xA   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \        0xE   0x460D             MOV      R5,R1
   \       0x10   0x4616             MOV      R6,R2
   \       0x12   0x461F             MOV      R7,R3
   \       0x14   0x2853             CMP      R0,#+83
   \       0x16   0xBF18             IT       NE
   \       0x18   0x.... 0x....      BLNE     _DoInit
   1733            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1734            if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
   \       0x1C   0x2C03             CMP      R4,#+3
   \       0x1E   0xD205             BCS.N    ??SEGGER_RTT_ConfigDownBuffer_0
   1735              SEGGER_RTT_LOCK();
   \       0x20   0x.... 0x....      BL       ?Subroutine19
   1736              pDown = &pRTTCB->aDown[BufferIndex];
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x24   0x3160             ADDS     R1,R1,#+96
   1737              if (BufferIndex) {
   \       0x26   0x.... 0x....      BL       ?Subroutine13
   1738                pDown->sName        = sName;
   1739                pDown->pBuffer      = (char*)pBuffer;
   1740                pDown->SizeOfBuffer = BufferSize;
   1741                pDown->RdOff        = 0u;
   1742                pDown->WrOff        = 0u;
   1743              }
   1744              pDown->Flags          = Flags;
   1745              RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
   1746              SEGGER_RTT_UNLOCK();
   1747              r =  0;
   1748            } else {
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x2A   0xE001             B.N      ??SEGGER_RTT_ConfigDownBuffer_1
   1749              r = -1;
   \                     ??SEGGER_RTT_ConfigDownBuffer_0: (+1)
   \       0x2C   0xF04F 0x30FF      MOV      R0,#+4294967295
   1750            }
   1751            return r;
   \                     ??SEGGER_RTT_ConfigDownBuffer_1: (+1)
   \       0x30   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1752          }
   1753          
   1754          /*********************************************************************
   1755          *
   1756          *       SEGGER_RTT_SetNameUpBuffer
   1757          *
   1758          *  Function description
   1759          *    Run-time configuration of a specific up-buffer name (T->H).
   1760          *    Buffer to be configured is specified by index.
   1761          *
   1762          *  Parameters
   1763          *    BufferIndex  Index of the buffer to renamed.
   1764          *    sName        Pointer to a constant name string.
   1765          *
   1766          *  Return value
   1767          *    >= 0  O.K.
   1768          *     < 0  Error
   1769          */

   \                                 In section .text, align 2, keep-with-next
   1770          int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
   \                     SEGGER_RTT_SetNameUpBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1771            int r;
   1772            volatile SEGGER_RTT_CB* pRTTCB;
   1773            volatile SEGGER_RTT_BUFFER_UP* pUp;
   1774          
   1775            INIT();
   \        0x4   0x....             LDR.N    R5,??DataTable27
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x2853             CMP      R0,#+83
   \        0xC   0xBF18             IT       NE
   \        0xE   0x.... 0x....      BLNE     _DoInit
   1776            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1777            if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
   \       0x12   0x2C03             CMP      R4,#+3
   \       0x14   0xD203             BCS.N    ??SEGGER_RTT_SetNameUpBuffer_0
   1778              SEGGER_RTT_LOCK();
   \       0x16   0x.... 0x....      BL       ?Subroutine10
   1779              pUp = &pRTTCB->aUp[BufferIndex];
   1780              pUp->sName = sName;
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x1A   0x6186             STR      R6,[R0, #+24]
   1781              SEGGER_RTT_UNLOCK();
   \       0x1C   0x....             B.N      ?Subroutine4
   1782              r =  0;
   1783            } else {
   1784              r = -1;
   \                     ??SEGGER_RTT_SetNameUpBuffer_0: (+1)
   \       0x1E   0x....             B.N      ?Subroutine5
   1785            }
   1786            return r;
   1787          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#+4294967295
   \        0x4   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA                      REQUIRE ??Subroutine22_0
   \        0xA                      ;; // Fall through to label ??Subroutine22_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xF381 0x8811      MSR      BASEPRI,R1
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD70             POP      {R4-R6,PC}
   1788          
   1789          /*********************************************************************
   1790          *
   1791          *       SEGGER_RTT_SetNameDownBuffer
   1792          *
   1793          *  Function description
   1794          *    Run-time configuration of a specific Down-buffer name (T->H).
   1795          *    Buffer to be configured is specified by index.
   1796          *
   1797          *  Parameters
   1798          *    BufferIndex  Index of the buffer to renamed.
   1799          *    sName        Pointer to a constant name string.
   1800          *
   1801          *  Return value
   1802          *    >= 0  O.K.
   1803          *     < 0  Error
   1804          */

   \                                 In section .text, align 2, keep-with-next
   1805          int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
   \                     SEGGER_RTT_SetNameDownBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1806            int r;
   1807            volatile SEGGER_RTT_CB* pRTTCB;
   1808            volatile SEGGER_RTT_BUFFER_DOWN* pDown;
   1809          
   1810            INIT();
   \        0x4   0x....             LDR.N    R5,??DataTable27
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x2853             CMP      R0,#+83
   \        0xC   0xBF18             IT       NE
   \        0xE   0x.... 0x....      BLNE     _DoInit
   1811            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1812            if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
   \       0x12   0x2C03             CMP      R4,#+3
   \       0x14   0xD203             BCS.N    ??SEGGER_RTT_SetNameDownBuffer_0
   1813              SEGGER_RTT_LOCK();
   \       0x16   0x.... 0x....      BL       ?Subroutine10
   1814              pDown = &pRTTCB->aDown[BufferIndex];
   1815              pDown->sName = sName;
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x1A   0x6606             STR      R6,[R0, #+96]
   1816              SEGGER_RTT_UNLOCK();
   \       0x1C   0x....             B.N      ?Subroutine4
   1817              r =  0;
   1818            } else {
   1819              r = -1;
   \                     ??SEGGER_RTT_SetNameDownBuffer_0: (+1)
   \       0x1E                      REQUIRE ?Subroutine5
   \       0x1E                      ;; // Fall through to label ?Subroutine5
   1820            }
   1821            return r;
   1822          }
   1823          
   1824          /*********************************************************************
   1825          *
   1826          *       SEGGER_RTT_SetFlagsUpBuffer
   1827          *
   1828          *  Function description
   1829          *    Run-time configuration of specific up-buffer flags (T->H).
   1830          *    Buffer to be configured is specified by index.
   1831          *
   1832          *  Parameters
   1833          *    BufferIndex  Index of the buffer.
   1834          *    Flags        Flags to set for the buffer.
   1835          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1836          *
   1837          *  Return value
   1838          *    >= 0  O.K.
   1839          *     < 0  Error
   1840          */

   \                                 In section .text, align 2, keep-with-next
   1841          int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
   \                     SEGGER_RTT_SetFlagsUpBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1842            int r;
   1843            volatile SEGGER_RTT_CB* pRTTCB;
   1844            volatile SEGGER_RTT_BUFFER_UP* pUp;
   1845          
   1846            INIT();
   \        0x4   0x....             LDR.N    R5,??DataTable27
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x2853             CMP      R0,#+83
   \        0xC   0xBF18             IT       NE
   \        0xE   0x.... 0x....      BLNE     _DoInit
   1847            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1848            if (BufferIndex < SEGGER_RTT_MAX_NUM_UP_BUFFERS) {
   \       0x12   0x2C03             CMP      R4,#+3
   \       0x14   0xD203             BCS.N    ??SEGGER_RTT_SetFlagsUpBuffer_0
   1849              SEGGER_RTT_LOCK();
   \       0x16   0x.... 0x....      BL       ?Subroutine10
   1850              pUp = &pRTTCB->aUp[BufferIndex];
   1851              pUp->Flags = Flags;
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x1A   0x62C6             STR      R6,[R0, #+44]
   1852              SEGGER_RTT_UNLOCK();
   \       0x1C   0x....             B.N      ?Subroutine4
   1853              r =  0;
   1854            } else {
   1855              r = -1;
   \                     ??SEGGER_RTT_SetFlagsUpBuffer_0: (+1)
   \       0x1E   0x....             B.N      ?Subroutine5
   1856            }
   1857            return r;
   1858          }
   1859          
   1860          /*********************************************************************
   1861          *
   1862          *       SEGGER_RTT_SetFlagsDownBuffer
   1863          *
   1864          *  Function description
   1865          *    Run-time configuration of specific Down-buffer flags (T->H).
   1866          *    Buffer to be configured is specified by index.
   1867          *
   1868          *  Parameters
   1869          *    BufferIndex  Index of the buffer to renamed.
   1870          *    Flags        Flags to set for the buffer.
   1871          *                 Flags[31:24] are used for validity check and must be zero. Flags[23:2] are reserved for future use. Flags[1:0] = RTT operating mode.
   1872          *
   1873          *  Return value
   1874          *    >= 0  O.K.
   1875          *     < 0  Error
   1876          */

   \                                 In section .text, align 2, keep-with-next
   1877          int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
   \                     SEGGER_RTT_SetFlagsDownBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1878            int r;
   1879            volatile SEGGER_RTT_CB* pRTTCB;
   1880            volatile SEGGER_RTT_BUFFER_DOWN* pDown;
   1881          
   1882            INIT();
   \        0x4   0x....             LDR.N    R5,??DataTable27
   \        0x6   0x7828             LDRB     R0,[R5, #+0]
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x2853             CMP      R0,#+83
   \        0xC   0xBF18             IT       NE
   \        0xE   0x.... 0x....      BLNE     _DoInit
   1883            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1884            if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
   \       0x12   0x2C03             CMP      R4,#+3
   \       0x14   0xD203             BCS.N    ??SEGGER_RTT_SetFlagsDownBuffer_0
   1885              SEGGER_RTT_LOCK();
   \       0x16   0x.... 0x....      BL       ?Subroutine10
   1886              pDown = &pRTTCB->aDown[BufferIndex];
   1887              pDown->Flags = Flags;
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x1A   0x6746             STR      R6,[R0, #+116]
   1888              SEGGER_RTT_UNLOCK();
   \       0x1C   0x....             B.N      ?Subroutine4
   1889              r =  0;
   1890            } else {
   1891              r = -1;
   \                     ??SEGGER_RTT_SetFlagsDownBuffer_0: (+1)
   \       0x1E   0x....             B.N      ?Subroutine5
   1892            }
   1893            return r;
   1894          }
   1895          
   1896          /*********************************************************************
   1897          *
   1898          *       SEGGER_RTT_Init
   1899          *
   1900          *  Function description
   1901          *    Initializes the RTT Control Block.
   1902          *    Should be used in RAM targets, at start of the application.
   1903          *
   1904          */

   \                                 In section .text, align 2, keep-with-next
   1905          void SEGGER_RTT_Init (void) {
   1906            _DoInit();
   \                     SEGGER_RTT_Init: (+1)
   \        0x0   0x....             B.N      _DoInit
   1907          }
   1908          
   1909          /*********************************************************************
   1910          *
   1911          *       SEGGER_RTT_SetTerminal
   1912          *
   1913          *  Function description
   1914          *    Sets the terminal to be used for output on channel 0.
   1915          *
   1916          *  Parameters
   1917          *    TerminalId  Index of the terminal.
   1918          *
   1919          *  Return value
   1920          *    >= 0  O.K.
   1921          *     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
   1922          *
   1923          *  Notes
   1924          *    (1) Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
   1925          */

   \                                 In section .text, align 4, keep-with-next
   1926          int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
   \                     SEGGER_RTT_SetTerminal: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   1927            unsigned char         ac[2];
   1928            SEGGER_RTT_BUFFER_UP* pRing;
   1929            unsigned Avail;
   1930            int r;
   1931          
   1932            INIT();
   \        0x6   0x....             LDR.N    R4,??DataTable27
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0x2853             CMP      R0,#+83
   \        0xC   0xBF18             IT       NE
   \        0xE   0x.... 0x....      BLNE     _DoInit
   1933            r = 0;
   \       0x12   0x2500             MOVS     R5,#+0
   1934            ac[0] = 0xFFu;
   \       0x14   0x21FF             MOVS     R1,#+255
   \       0x16   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1935            if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
   \       0x1A   0xF04F 0x39FF      MOV      R9,#+4294967295
   \       0x1E   0x2E10             CMP      R6,#+16
   \       0x20   0xD227             BCS.N    ??SEGGER_RTT_SetTerminal_0
   1936              ac[1] = _aTerminalId[TerminalId];
   \       0x22   0xBF00             Nop
   \       0x24   0x....             ADR.N    R2,_aTerminalId
   \       0x26   0x5D90             LDRB     R0,[R2, R6]
   \       0x28   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1937              pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1938              SEGGER_RTT_LOCK();                     // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
   \       0x2C   0xF3EF 0x8811      MRS      R8,BASEPRI
   \       0x30   0x2020             MOVS     R0,#+32
   \       0x32   0xF380 0x8811      MSR      BASEPRI,R0
   1939              if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
   \       0x36   0x3418             ADDS     R4,R4,#+24
   \       0x38   0x7D20             LDRB     R0,[R4, #+20]
   \       0x3A   0x....             LDR.N    R7,??DataTable27_1
   \       0x3C   0xF000 0x0003      AND      R0,R0,#0x3
   \       0x40   0x2802             CMP      R0,#+2
   \       0x42   0xD106             BNE.N    ??SEGGER_RTT_SetTerminal_1
   1940                _ActiveTerminal = TerminalId;
   \       0x44   0x703E             STRB     R6,[R7, #+0]
   1941                _WriteBlocking(pRing, (const char*)ac, 2u);
   \       0x46   0x2202             MOVS     R2,#+2
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x.... 0x....      BL       _WriteBlocking
   \       0x50   0xE00C             B.N      ??SEGGER_RTT_SetTerminal_2
   1942              } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
   1943                Avail = _GetAvailWriteSpace(pRing);
   1944                if (Avail >= 2) {
   \                     ??SEGGER_RTT_SetTerminal_1: (+1)
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x58   0x2802             CMP      R0,#+2
   \       0x5A   0xD306             BCC.N    ??SEGGER_RTT_SetTerminal_3
   1945                  _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
   \       0x5C   0x703E             STRB     R6,[R7, #+0]
   1946                  _WriteNoCheck(pRing, (const char*)ac, 2u);
   \       0x5E   0x2202             MOVS     R2,#+2
   \       0x60   0x4669             MOV      R1,SP
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0x.... 0x....      BL       _WriteNoCheck
   \       0x68   0xE000             B.N      ??SEGGER_RTT_SetTerminal_2
   1947                } else {
   1948                  r = -1;
   \                     ??SEGGER_RTT_SetTerminal_3: (+1)
   \       0x6A   0x464D             MOV      R5,R9
   1949                }
   1950              }
   1951              SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_SetTerminal_2: (+1)
   \       0x6C   0xF388 0x8811      MSR      BASEPRI,R8
   \       0x70   0xE000             B.N      ??SEGGER_RTT_SetTerminal_4
   1952            } else {
   1953              r = -1;
   \                     ??SEGGER_RTT_SetTerminal_0: (+1)
   \       0x72   0x464D             MOV      R5,R9
   1954            }
   1955            return r;
   \                     ??SEGGER_RTT_SetTerminal_4: (+1)
   \       0x74   0x....             B.N      ??Subroutine1_0
   1956          }
   1957          
   1958          /*********************************************************************
   1959          *
   1960          *       SEGGER_RTT_TerminalOut
   1961          *
   1962          *  Function description
   1963          *    Writes a string to the given terminal
   1964          *     without changing the terminal for channel 0.
   1965          *
   1966          *  Parameters
   1967          *    TerminalId   Index of the terminal.
   1968          *    s            String to be printed on the terminal.
   1969          *
   1970          *  Return value
   1971          *    >= 0 - Number of bytes written.
   1972          *     < 0 - Error.
   1973          *
   1974          */

   \                                 In section .text, align 2, keep-with-next
   1975          int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
   \                     SEGGER_RTT_TerminalOut: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   1976            int                   Status;
   1977            unsigned              FragLen;
   1978            unsigned              Avail;
   1979            SEGGER_RTT_BUFFER_UP* pRing;
   1980            //
   1981            INIT();
   \        0x6   0x....             LDR.N    R6,??DataTable27
   \        0x8   0x7830             LDRB     R0,[R6, #+0]
   \        0xA   0x4688             MOV      R8,R1
   \        0xC   0x2853             CMP      R0,#+83
   \        0xE   0xBF18             IT       NE
   \       0x10   0x.... 0x....      BLNE     _DoInit
   1982            //
   1983            // Validate terminal ID.
   1984            //
   1985            if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
   \       0x14   0xF04F 0x34FF      MOV      R4,#+4294967295
   \       0x18   0xF1BB 0x0F10      CMP      R11,#+16
   \       0x1C   0xDA33             BGE.N    ??SEGGER_RTT_TerminalOut_0
   1986              //
   1987              // Get "to-host" ring buffer.
   1988              //
   1989              pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[0] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   1990              //
   1991              // Need to be able to change terminal, write data, change back.
   1992              // Compute the fixed and variable sizes.
   1993              //
   1994              FragLen = STRLEN(s);
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0x.... 0x....      BL       strlen
   \       0x24   0x4605             MOV      R5,R0
   1995              //
   1996              // How we output depends upon the mode...
   1997              //
   1998              SEGGER_RTT_LOCK();
   \       0x26   0xF3EF 0x8911      MRS      R9,BASEPRI
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   1999              Avail = _GetAvailWriteSpace(pRing);
   \       0x30   0xF106 0x0A18      ADD      R10,R6,#+24
   \       0x34   0x4650             MOV      R0,R10
   \       0x36   0x.... 0x....      BL       _GetAvailWriteSpace
   \       0x3A   0x4607             MOV      R7,R0
   2000              switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
   \       0x3C   0xF89A 0x0014      LDRB     R0,[R10, #+20]
   \       0x40   0x....             LDR.N    R6,??DataTable27_1
   \       0x42   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x46   0xD003             BEQ.N    ??SEGGER_RTT_TerminalOut_1
   \       0x48   0x2802             CMP      R0,#+2
   \       0x4A   0xD00F             BEQ.N    ??SEGGER_RTT_TerminalOut_2
   \       0x4C   0xD305             BCC.N    ??SEGGER_RTT_TerminalOut_3
   \       0x4E   0xE018             B.N      ??CrossCallReturnLabel_24
   2001              case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   2002                //
   2003                // If we are in skip mode and there is no space for the whole
   2004                // of this output, don't bother switching terminals at all.
   2005                //
   2006                if (Avail < (FragLen + 4u)) {
   \                     ??SEGGER_RTT_TerminalOut_1: (+1)
   \       0x50   0x1D29             ADDS     R1,R5,#+4
   \       0x52   0x428F             CMP      R7,R1
   \       0x54   0xD20A             BCS.N    ??SEGGER_RTT_TerminalOut_2
   2007                  Status = 0;
   \       0x56   0x2400             MOVS     R4,#+0
   \       0x58   0xE013             B.N      ??CrossCallReturnLabel_24
   2008                } else {
   2009                  _PostTerminalSwitch(pRing, TerminalId);
   2010                  Status = (int)_WriteBlocking(pRing, s, FragLen);
   2011                  _PostTerminalSwitch(pRing, _ActiveTerminal);
   2012                }
   2013                break;
   2014              case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   2015                //
   2016                // If we are in trim mode and there is not enough space for everything,
   2017                // trim the output but always include the terminal switch.  If no room
   2018                // for terminal switch, skip that totally.
   2019                //
   2020                if (Avail < 4u) {
   \                     ??SEGGER_RTT_TerminalOut_3: (+1)
   \       0x5A   0x2F03             CMP      R7,#+3
   \       0x5C   0xD911             BLS.N    ??CrossCallReturnLabel_24
   2021                  Status = -1;
   2022                } else {
   2023                  _PostTerminalSwitch(pRing, TerminalId);
   \       0x5E   0x.... 0x....      BL       ?Subroutine20
   2024                  Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x62   0x1F3F             SUBS     R7,R7,#+4
   \       0x64   0x42BD             CMP      R5,R7
   \       0x66   0xD903             BLS.N    ??CrossCallReturnLabel_25
   \       0x68   0x463D             MOV      R5,R7
   \       0x6A   0xE001             B.N      ??CrossCallReturnLabel_25
   2025                  _PostTerminalSwitch(pRing, _ActiveTerminal);
   2026                }
   2027                break;
   2028              case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   2029                //
   2030                // If we are in blocking mode, output everything.
   2031                //
   2032                _PostTerminalSwitch(pRing, TerminalId);
   \                     ??SEGGER_RTT_TerminalOut_2: (+1)
   \       0x6C   0x.... 0x....      BL       ?Subroutine20
   2033                Status = (int)_WriteBlocking(pRing, s, FragLen);
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x70   0x462A             MOV      R2,R5
   \       0x72   0x4641             MOV      R1,R8
   \       0x74   0x4650             MOV      R0,R10
   \       0x76   0x.... 0x....      BL       _WriteBlocking
   2034                _PostTerminalSwitch(pRing, _ActiveTerminal);
   \       0x7A   0x7831             LDRB     R1,[R6, #+0]
   \       0x7C   0x4604             MOV      R4,R0
   \       0x7E   0x.... 0x....      BL       ??Subroutine20_0
   2035                break;
   2036              default:
   2037                Status = -1;
   2038                break;
   2039              }
   2040              //
   2041              // Finish up.
   2042              //
   2043              SEGGER_RTT_UNLOCK();
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x82   0xF389 0x8811      MSR      BASEPRI,R9
   2044            } else {
   2045              Status = -1;
   2046            }
   2047            return Status;
   \                     ??SEGGER_RTT_TerminalOut_0: (+1)
   \       0x86   0x4620             MOV      R0,R4
   \       0x88   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2048          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x4659             MOV      R1,R11
   \                     ??Subroutine20_0: (+1)
   \        0x2   0x4650             MOV      R0,R10
   \        0x4   0x....             B.N      _PostTerminalSwitch
   2049          
   2050          /*********************************************************************
   2051          *
   2052          *       SEGGER_RTT_GetAvailWriteSpace
   2053          *
   2054          *  Function description
   2055          *    Returns the number of bytes available in the ring buffer.
   2056          *
   2057          *  Parameters
   2058          *    BufferIndex  Index of the up buffer.
   2059          *
   2060          *  Return value
   2061          *    Number of bytes that are free in the selected up buffer.
   2062          */

   \                                 In section .text, align 2, keep-with-next
   2063          unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex) {
   2064            SEGGER_RTT_BUFFER_UP* pRing;
   2065          
   2066            pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   2067            return _GetAvailWriteSpace(pRing);
   \                     SEGGER_RTT_GetAvailWriteSpace: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x....             LDR.N    R2,??DataTable27
   \        0x6   0x1811             ADDS     R1,R2,R0
   \        0x8   0xF101 0x0018      ADD      R0,R1,#+24
   \        0xC   0x....             B.N      _GetAvailWriteSpace
   2068          }
   2069          
   2070          
   2071          /*********************************************************************
   2072          *
   2073          *       SEGGER_RTT_GetBytesInBuffer()
   2074          *
   2075          *  Function description
   2076          *    Returns the number of bytes currently used in the up buffer.
   2077          *
   2078          *  Parameters
   2079          *    BufferIndex  Index of the up buffer.
   2080          *
   2081          *  Return value
   2082          *    Number of bytes that are used in the buffer.
   2083          */

   \                                 In section .text, align 2, keep-with-next
   2084          unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
   2085            unsigned RdOff;
   2086            unsigned WrOff;
   2087            unsigned r;
   2088            volatile SEGGER_RTT_CB* pRTTCB;
   2089            //
   2090            // Avoid warnings regarding volatile access order.  It's not a problem
   2091            // in this case, but dampen compiler enthusiasm.
   2092            //
   2093            pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
   2094            RdOff = pRTTCB->aUp[BufferIndex].RdOff;
   \                     SEGGER_RTT_GetBytesInBuffer: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x....             LDR.N    R2,??DataTable27
   \        0x6   0x4402             ADD      R2,R2,R0
   \        0x8   0x6A90             LDR      R0,[R2, #+40]
   2095            WrOff = pRTTCB->aUp[BufferIndex].WrOff;
   \        0xA   0x6A51             LDR      R1,[R2, #+36]
   2096            if (RdOff <= WrOff) {
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xD301             BCC.N    ??SEGGER_RTT_GetBytesInBuffer_0
   2097              r = WrOff - RdOff;
   \       0x10   0x1A08             SUBS     R0,R1,R0
   \       0x12   0x4770             BX       LR
   2098            } else {
   2099              r = pRTTCB->aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
   \                     ??SEGGER_RTT_GetBytesInBuffer_0: (+1)
   \       0x14   0x6A12             LDR      R2,[R2, #+32]
   \       0x16   0x1A51             SUBS     R1,R2,R1
   \       0x18   0x1840             ADDS     R0,R0,R1
   2100            }
   2101            return r;
   \       0x1A   0x4770             BX       LR
   2102          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     _SEGGER_RTT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     _ActiveTerminal

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x54 0x65          DC8 "Terminal"
   \              0x72 0x6D    
   \              0x69 0x6E    
   \              0x61 0x6C    
   \              0x00
   \        0x9                      DS8 3
   2103          
   2104          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SEGGER_RTT_AllocDownBuffer
        24   -> _DoInit
      24   SEGGER_RTT_AllocUpBuffer
        24   -> _DoInit
      24   SEGGER_RTT_ConfigDownBuffer
        24   -> _DoInit
      24   SEGGER_RTT_ConfigUpBuffer
        24   -> _DoInit
       0   SEGGER_RTT_GetAvailWriteSpace
         0   -> _GetAvailWriteSpace
       0   SEGGER_RTT_GetBytesInBuffer
       8   SEGGER_RTT_GetKey
         8   -> SEGGER_RTT_Read
       0   SEGGER_RTT_HasData
       0   SEGGER_RTT_HasDataUp
       8   SEGGER_RTT_HasKey
         8   -> _DoInit
       0   SEGGER_RTT_Init
         0   -> _DoInit
      16   SEGGER_RTT_PutChar
        16   -> _DoInit
      16   SEGGER_RTT_PutCharSkip
        16   -> _DoInit
      12   SEGGER_RTT_PutCharSkipNoLock
       8   SEGGER_RTT_Read
         8   -> SEGGER_RTT_ReadNoLock
      32   SEGGER_RTT_ReadNoLock
        32   -> _DoInit
        32   -> __aeabi_memcpy
       8   SEGGER_RTT_ReadUpBuffer
         8   -> SEGGER_RTT_ReadUpBufferNoLock
      32   SEGGER_RTT_ReadUpBufferNoLock
        32   -> _DoInit
        32   -> __aeabi_memcpy
      16   SEGGER_RTT_SetFlagsDownBuffer
        16   -> _DoInit
      16   SEGGER_RTT_SetFlagsUpBuffer
        16   -> _DoInit
      16   SEGGER_RTT_SetNameDownBuffer
        16   -> _DoInit
      16   SEGGER_RTT_SetNameUpBuffer
        16   -> _DoInit
      32   SEGGER_RTT_SetTerminal
        32   -> _DoInit
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      40   SEGGER_RTT_TerminalOut
        40   -> _DoInit
        40   -> _GetAvailWriteSpace
        40   -> _PostTerminalSwitch
        40   -> _WriteBlocking
        40   -> strlen
       8   SEGGER_RTT_WaitKey
         8   -> SEGGER_RTT_GetKey
      24   SEGGER_RTT_Write
        24   -> SEGGER_RTT_WriteNoLock
        24   -> _DoInit
      24   SEGGER_RTT_WriteDownBuffer
        24   -> SEGGER_RTT_WriteDownBufferNoLock
        24   -> _DoInit
      16   SEGGER_RTT_WriteDownBufferNoLock
        16   -> _GetAvailWriteSpace
        16   -> _WriteBlocking
        16   -> _WriteNoCheck
      16   SEGGER_RTT_WriteNoLock
        16   -> _GetAvailWriteSpace
        16   -> _WriteBlocking
        16   -> _WriteNoCheck
      24   SEGGER_RTT_WriteSkipNoLock
        24   -> __aeabi_memcpy
      16   SEGGER_RTT_WriteString
         0   -> SEGGER_RTT_Write
        16   -> strlen
      24   SEGGER_RTT_WriteWithOverwriteNoLock
        24   -> __aeabi_memcpy
       8   _DoInit
         8   -> __aeabi_memclr
       0   _GetAvailWriteSpace
       8   _PostTerminalSwitch
         8   -> _WriteBlocking
      32   _WriteBlocking
        32   -> __aeabi_memcpy
      24   _WriteNoCheck
        24   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       8  ??Subroutine21_0
       8  ??Subroutine22_0
       6  ?Subroutine0
      24  ?Subroutine1
      10  ?Subroutine10
       8  ?Subroutine11
       8  ?Subroutine12
      28  ?Subroutine13
      18  ?Subroutine14
      16  ?Subroutine15
      12  ?Subroutine16
       4  ?Subroutine17
      16  ?Subroutine18
      18  ?Subroutine19
      10  ?Subroutine2
       6  ?Subroutine20
      24  ?Subroutine3
       8  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
      18  ?Subroutine7
       8  ?Subroutine8
      28  ?Subroutine9
      12  ?_0
      90  SEGGER_RTT_AllocDownBuffer
      86  SEGGER_RTT_AllocUpBuffer
      52  SEGGER_RTT_ConfigDownBuffer
      52  SEGGER_RTT_ConfigUpBuffer
      14  SEGGER_RTT_GetAvailWriteSpace
      28  SEGGER_RTT_GetBytesInBuffer
      28  SEGGER_RTT_GetKey
      22  SEGGER_RTT_HasData
      22  SEGGER_RTT_HasDataUp
      36  SEGGER_RTT_HasKey
       2  SEGGER_RTT_Init
      40  SEGGER_RTT_PutChar
      30  SEGGER_RTT_PutCharSkip
      46  SEGGER_RTT_PutCharSkipNoLock
      10  SEGGER_RTT_Read
      76  SEGGER_RTT_ReadNoLock
      12  SEGGER_RTT_ReadUpBuffer
      78  SEGGER_RTT_ReadUpBufferNoLock
      32  SEGGER_RTT_SetFlagsDownBuffer
      32  SEGGER_RTT_SetFlagsUpBuffer
      30  SEGGER_RTT_SetNameDownBuffer
      32  SEGGER_RTT_SetNameUpBuffer
     118  SEGGER_RTT_SetTerminal
     140  SEGGER_RTT_TerminalOut
      12  SEGGER_RTT_WaitKey
      30  SEGGER_RTT_Write
      32  SEGGER_RTT_WriteDownBuffer
      62  SEGGER_RTT_WriteDownBufferNoLock
      62  SEGGER_RTT_WriteNoLock
      96  SEGGER_RTT_WriteSkipNoLock
      24  SEGGER_RTT_WriteString
     128  SEGGER_RTT_WriteWithOverwriteNoLock
       1  _ActiveTerminal
      90  _DoInit
      26  _GetAvailWriteSpace
      28  _PostTerminalSwitch
   2'216  _SEGGER_RTT
          _acUpBuffer
          _acDownBuffer
      84  _WriteBlocking
      58  _WriteNoCheck
      20  _aInitStr
      16  _aTerminalId

 
 2'217 bytes in section .bss
 2'194 bytes in section .text
 
 2'194 bytes of CODE memory
 2'217 bytes of DATA memory

Errors: none
Warnings: none
