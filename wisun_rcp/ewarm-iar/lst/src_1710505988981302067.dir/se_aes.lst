###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:00
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\src\se_aes.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_1710505988981302067.dir\se_aes.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\src\se_aes.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_1710505988981302067.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_1710505988981302067.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_1710505988981302067.dir\se_aes.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_1710505988981302067.dir\se_aes.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_1710505988981302067.dir\se_aes.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\src\se_aes.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief AES abstraction based on Secure Engine
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          /*
     32           * This file includes alternative plugin implementations of various
     33           * functions in aes.c using the Secure Engine accelerator incorporated
     34           * in Series-2 devices with Secure Engine from Silicon Laboratories.
     35           */
     36          
     37          /**
     38           *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
     39           *
     40           *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
     41           *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
     42           */
     43          
     44          #include <mbedtls/build_info.h>
     45          
     46          #if defined(MBEDTLS_AES_C)
     47          #if defined(MBEDTLS_AES_ALT)
     48          
     49          #include "em_device.h"
     50          
     51          #if defined(SEMAILBOX_PRESENT)
     52          
     53          #include "em_se.h"
     54          #include "se_management.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int se_management_acquire(void)
   \                     se_management_acquire: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       sli_se_lock_acquire
   \        0x6   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB108             CBZ.N    R0,??Subroutine0_0
   \        0x2   0xF04F 0x30FF      MOV      R0,#+4294967295
   \                     ??Subroutine0_0: (+1)
   \        0x6   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int se_management_release(void)
   \                     se_management_release: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       sli_se_lock_release
   \        0x6                      REQUIRE ?Subroutine0
   \        0x6                      ;; // Fall through to label ?Subroutine0
     55          #include "mbedtls/aes.h"
     56          #include "mbedtls/platform.h"
     57          #include "mbedtls/platform_util.h"
     58          #include "mbedtls/error.h"
     59          #include <string.h>
     60          
     61          /* Parameter validation macros based on platform_util.h */
     62          #define AES_VALIDATE_RET(cond) \
     63            MBEDTLS_INTERNAL_VALIDATE_RET(cond, MBEDTLS_ERR_AES_BAD_INPUT_DATA)
     64          #define AES_VALIDATE(cond) \
     65            MBEDTLS_INTERNAL_VALIDATE(cond)
     66          
     67          /*
     68           * Initialize AES context
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          void mbedtls_aes_init(mbedtls_aes_context *ctx)
     71          {
     72            AES_VALIDATE(ctx != NULL);
     73          
     74            memset(ctx, 0, sizeof(mbedtls_aes_context) );
   \                     mbedtls_aes_init: (+1)
   \        0x0   0x2124             MOVS     R1,#+36
   \        0x2   0x.... 0x....      B.W      __aeabi_memclr4
     75          }
     76          
     77          /*
     78           * Clear AES context
     79           */

   \                                 In section .text, align 2, keep-with-next
     80          void mbedtls_aes_free(mbedtls_aes_context *ctx)
     81          {
     82            if ( ctx == NULL ) {
   \                     mbedtls_aes_free: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
     83              return;
     84            }
     85          
     86            memset(ctx, 0, sizeof(mbedtls_aes_context) );
   \        0x4   0x2124             MOVNE    R1,#+36
   \        0x6   0x.... 0x....      BNE.W    __aeabi_memclr4
     87          }
   \        0xA   0x4770             BX       LR
     88          
     89          #if defined(MBEDTLS_CIPHER_MODE_XTS)
     90          void mbedtls_aes_xts_init(mbedtls_aes_xts_context *ctx)
     91          {
     92            AES_VALIDATE(ctx != NULL);
     93          
     94            mbedtls_aes_init(&ctx->crypt);
     95            mbedtls_aes_init(&ctx->tweak);
     96          }
     97          
     98          void mbedtls_aes_xts_free(mbedtls_aes_xts_context *ctx)
     99          {
    100            if ( ctx == NULL ) {
    101              return;
    102            }
    103          
    104            mbedtls_aes_free(&ctx->crypt);
    105            mbedtls_aes_free(&ctx->tweak);
    106          }
    107          
    108          static int mbedtls_aes_xts_decode_keys(const unsigned char *key,
    109                                                 unsigned int keybits,
    110                                                 const unsigned char **key1,
    111                                                 unsigned int *key1bits,
    112                                                 const unsigned char **key2,
    113                                                 unsigned int *key2bits)
    114          {
    115            const unsigned int half_keybits = keybits / 2;
    116            const unsigned int half_keybytes = half_keybits / 8;
    117          
    118            switch ( keybits ) {
    119              case 256: break;
    120              case 512: break;
    121              default: return(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH);
    122            }
    123          
    124            *key1bits = half_keybits;
    125            *key2bits = half_keybits;
    126            *key1 = &key[0];
    127            *key2 = &key[half_keybytes];
    128          
    129            return 0;
    130          }
    131          
    132          int mbedtls_aes_xts_setkey_enc(mbedtls_aes_xts_context *ctx,
    133                                         const unsigned char *key,
    134                                         unsigned int keybits)
    135          {
    136            int ret;
    137            const unsigned char *key1 = NULL;
    138            const unsigned char *key2 = NULL;
    139            unsigned int key1bits = 0;
    140            unsigned int key2bits = 0;
    141          
    142            AES_VALIDATE_RET(ctx != NULL);
    143            AES_VALIDATE_RET(key != NULL);
    144          
    145            ret = mbedtls_aes_xts_decode_keys(key, keybits, &key1, &key1bits,
    146                                              &key2, &key2bits);
    147            if ( ret != 0 ) {
    148              return(ret);
    149            }
    150          
    151            /* Set the tweak key. Always set tweak key for the encryption mode. */
    152            ret = mbedtls_aes_setkey_enc(&ctx->tweak, key2, key2bits);
    153            if ( ret != 0 ) {
    154              return(ret);
    155            }
    156          
    157            /* Set crypt key for encryption. */
    158            return mbedtls_aes_setkey_enc(&ctx->crypt, key1, key1bits);
    159          }
    160          
    161          int mbedtls_aes_xts_setkey_dec(mbedtls_aes_xts_context *ctx,
    162                                         const unsigned char *key,
    163                                         unsigned int keybits)
    164          {
    165            int ret;
    166            const unsigned char *key1 = NULL;
    167            const unsigned char *key2 = NULL;
    168            unsigned int key1bits = 0;
    169            unsigned int key2bits = 0;
    170          
    171            if (ctx == NULL || key == NULL) {
    172              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
    173            }
    174          
    175            ret = mbedtls_aes_xts_decode_keys(key, keybits, &key1, &key1bits,
    176                                              &key2, &key2bits);
    177            if ( ret != 0 ) {
    178              return(ret);
    179            }
    180          
    181            /* Set the tweak key. Always set tweak key for encryption. */
    182            ret = mbedtls_aes_setkey_enc(&ctx->tweak, key2, key2bits);
    183            if ( ret != 0 ) {
    184              return(ret);
    185            }
    186          
    187            /* Set crypt key for decryption. */
    188            return mbedtls_aes_setkey_dec(&ctx->crypt, key1, key1bits);
    189          }
    190          
    191          /* Endianess with 64 bits values */
    192          #ifndef GET_UINT64_LE
    193          #define GET_UINT64_LE(n, b, i)               \
    194            {                                          \
    195              (n) = ( (uint64_t) (b)[(i) + 7] << 56)   \
    196                    | ( (uint64_t) (b)[(i) + 6] << 48) \
    197                    | ( (uint64_t) (b)[(i) + 5] << 40) \
    198                    | ( (uint64_t) (b)[(i) + 4] << 32) \
    199                    | ( (uint64_t) (b)[(i) + 3] << 24) \
    200                    | ( (uint64_t) (b)[(i) + 2] << 16) \
    201                    | ( (uint64_t) (b)[(i) + 1] <<  8) \
    202                    | ( (uint64_t) (b)[(i)]);          \
    203            }
    204          #endif
    205          
    206          #ifndef PUT_UINT64_LE
    207          #define PUT_UINT64_LE(n, b, i)                   \
    208            {                                              \
    209              (b)[(i) + 7] = (unsigned char) ( (n) >> 56); \
    210              (b)[(i) + 6] = (unsigned char) ( (n) >> 48); \
    211              (b)[(i) + 5] = (unsigned char) ( (n) >> 40); \
    212              (b)[(i) + 4] = (unsigned char) ( (n) >> 32); \
    213              (b)[(i) + 3] = (unsigned char) ( (n) >> 24); \
    214              (b)[(i) + 2] = (unsigned char) ( (n) >> 16); \
    215              (b)[(i) + 1] = (unsigned char) ( (n) >>  8); \
    216              (b)[(i)] = (unsigned char) ( (n)       );    \
    217            }
    218          #endif
    219          
    220          /*
    221           * GF(2^128) multiplication function
    222           *
    223           * This function multiplies a field element by x in the polynomial field
    224           * representation. It uses 64-bit word operations to gain speed but compensates
    225           * for machine endianess and hence works correctly on both big and little
    226           * endian machines.
    227           */
    228          static void mbedtls_gf128mul_x_ble(unsigned char r[16],
    229                                             const unsigned char x[16])
    230          {
    231            uint64_t a, b, ra, rb;
    232          
    233            GET_UINT64_LE(a, x, 0);
    234            GET_UINT64_LE(b, x, 8);
    235          
    236            ra = (a << 1)  ^ 0x0087 >> (8 - ( (b >> 63) << 3) );
    237            rb = (a >> 63) | (b << 1);
    238          
    239            PUT_UINT64_LE(ra, r, 0);
    240            PUT_UINT64_LE(rb, r, 8);
    241          }
    242          
    243          /*
    244           * AES-XTS buffer encryption/decryption
    245           */
    246          int mbedtls_aes_crypt_xts(mbedtls_aes_xts_context *ctx,
    247                                    int mode,
    248                                    size_t length,
    249                                    const unsigned char data_unit[16],
    250                                    const unsigned char *input,
    251                                    unsigned char *output)
    252          {
    253            int ret;
    254            size_t blocks = length / 16;
    255            size_t leftover = length % 16;
    256            unsigned char tweak[16];
    257            unsigned char prev_tweak[16];
    258            unsigned char tmp[16];
    259          
    260            AES_VALIDATE_RET(ctx != NULL);
    261            AES_VALIDATE_RET(data_unit != NULL);
    262            AES_VALIDATE_RET(input != NULL);
    263            AES_VALIDATE_RET(output != NULL);
    264          
    265            if ((mode != MBEDTLS_AES_ENCRYPT) && (mode != MBEDTLS_AES_DECRYPT)) {
    266              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
    267            }
    268          
    269            /* Data units must be at least 16 bytes long. */
    270            if ( length < 16 ) {
    271              return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
    272            }
    273          
    274            /* NIST SP 800-38E disallows data units larger than 2**20 blocks. */
    275            if ( length > (1 << 20) * 16 ) {
    276              return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
    277            }
    278          
    279            /* Compute the tweak. */
    280            ret = mbedtls_aes_crypt_ecb(&ctx->tweak, MBEDTLS_AES_ENCRYPT,
    281                                        data_unit, tweak);
    282            if ( ret != 0 ) {
    283              return(ret);
    284            }
    285          
    286            while ( blocks-- ) {
    287              size_t i;
    288          
    289              if ( leftover && (mode == MBEDTLS_AES_DECRYPT) && blocks == 0 ) {
    290                /* We are on the last block in a decrypt operation that has
    291                 * leftover bytes, so we need to use the next tweak for this block,
    292                 * and this tweak for the lefover bytes. Save the current tweak for
    293                 * the leftovers and then update the current tweak for use on this,
    294                 * the last full block. */
    295                memcpy(prev_tweak, tweak, sizeof(tweak) );
    296                mbedtls_gf128mul_x_ble(tweak, tweak);
    297              }
    298          
    299              for ( i = 0; i < 16; i++ ) {
    300                tmp[i] = input[i] ^ tweak[i];
    301              }
    302          
    303              ret = mbedtls_aes_crypt_ecb(&ctx->crypt, mode, tmp, tmp);
    304              if ( ret != 0 ) {
    305                return(ret);
    306              }
    307          
    308              for ( i = 0; i < 16; i++ ) {
    309                output[i] = tmp[i] ^ tweak[i];
    310              }
    311          
    312              /* Update the tweak for the next block. */
    313              mbedtls_gf128mul_x_ble(tweak, tweak);
    314          
    315              output += 16;
    316              input += 16;
    317            }
    318          
    319            if ( leftover ) {
    320              /* If we are on the leftover bytes in a decrypt operation, we need to
    321              * use the previous tweak for these bytes (as saved in prev_tweak). */
    322              unsigned char *t = mode == MBEDTLS_AES_DECRYPT ? prev_tweak : tweak;
    323          
    324              /* We are now on the final part of the data unit, which doesn't divide
    325               * evenly by 16. It's time for ciphertext stealing. */
    326              size_t i;
    327              unsigned char *prev_output = output - 16;
    328          
    329              /* Copy ciphertext bytes from the previous block to our output for each
    330               * byte of cyphertext we won't steal. At the same time, copy the
    331               * remainder of the input for this final round (since the loop bounds
    332               * are the same). */
    333              for ( i = 0; i < leftover; i++ ) {
    334                output[i] = prev_output[i];
    335                tmp[i] = input[i] ^ t[i];
    336              }
    337          
    338              /* Copy ciphertext bytes from the previous block for input in this
    339               * round. */
    340              for (; i < 16; i++ ) {
    341                tmp[i] = prev_output[i] ^ t[i];
    342              }
    343          
    344              ret = mbedtls_aes_crypt_ecb(&ctx->crypt, mode, tmp, tmp);
    345              if ( ret != 0 ) {
    346                return ret;
    347              }
    348          
    349              /* Write the result back to the previous block, overriding the previous
    350               * output we copied. */
    351              for ( i = 0; i < 16; i++ ) {
    352                prev_output[i] = tmp[i] ^ t[i];
    353              }
    354            }
    355          
    356            return(0);
    357          }
    358          
    359          #endif /* MBEDTLS_CIPHER_MODE_XTS */
    360          
    361          /*
    362           * AES key schedule (encryption)
    363           */

   \                                 In section .text, align 2, keep-with-next
    364          int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx,
    365                                     const unsigned char *key,
    366                                     unsigned int keybits)
    367          {
   \                     mbedtls_aes_setkey_enc: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4615             MOV      R5,R2
    368            AES_VALIDATE_RET(ctx != NULL);
    369            AES_VALIDATE_RET(key != NULL);
    370          
    371            memset(ctx, 0, sizeof(mbedtls_aes_context) );
   \        0x8   0x2124             MOVS     R1,#+36
   \        0xA   0x.... 0x....      BL       __aeabi_memclr4
    372          
    373            if ( (128UL != keybits) && (192UL != keybits) && (256UL != keybits) ) {
   \        0xE   0x2D80             CMP      R5,#+128
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2DC0             CMPNE    R5,#+192
   \       0x14   0xF5B5 0x7F80      CMPNE    R5,#+256
   \       0x18   0xD002             BEQ.N    ??mbedtls_aes_setkey_enc_0
    374              // Unsupported key size
    375              return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
   \       0x1A   0xF06F 0x001F      MVN      R0,#+31
   \       0x1E   0xBD70             POP      {R4-R6,PC}
    376            }
    377          
    378            ctx->keybits = keybits;
   \                     ??mbedtls_aes_setkey_enc_0: (+1)
   \       0x20   0x6035             STR      R5,[R6, #+0]
    379            memcpy(ctx->key, key, keybits / 8);
   \       0x22   0x08EA             LSRS     R2,R5,#+3
   \       0x24   0x4621             MOV      R1,R4
   \       0x26   0x1D30             ADDS     R0,R6,#+4
   \       0x28   0x.... 0x....      BL       __aeabi_memcpy
    380          
    381            return 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD70             POP      {R4-R6,PC}
    382          }
    383          
    384          /*
    385           * AES key schedule (decryption)
    386           */

   \                                 In section .text, align 2, keep-with-next
    387          int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx,
    388                                     const unsigned char *key,
    389                                     unsigned int keybits)
    390          {
    391            AES_VALIDATE_RET(ctx != NULL);
    392            AES_VALIDATE_RET(key != NULL);
    393          
    394            return mbedtls_aes_setkey_enc(ctx, key, keybits);
   \                     mbedtls_aes_setkey_dec: (+1)
   \        0x0   0x....             B.N      mbedtls_aes_setkey_enc
    395          }
    396          
    397          /*
    398           * AES-ECB block encryption/decryption
    399           */

   \                                 In section .text, align 4, keep-with-next
    400          int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx,
    401                                    int mode,
    402                                    const unsigned char input[16],
    403                                    unsigned char output[16])
    404          {
   \                     mbedtls_aes_crypt_ecb: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xB091             SUB      SP,SP,#+68
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x461E             MOV      R6,R3
    405            SE_Response_t command_status;
    406          
    407            AES_VALIDATE_RET(ctx != NULL);
    408            AES_VALIDATE_RET(input != NULL);
    409            AES_VALIDATE_RET(output != NULL);
    410          
    411            if ((mode != MBEDTLS_AES_ENCRYPT) && (mode != MBEDTLS_AES_DECRYPT)) {
   \        0xE   0x2C01             CMP      R4,#+1
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2C00             CMPNE    R4,#+0
   \       0x14   0xF06F 0x0020      MVNNE    R0,#+32
    412              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
   \       0x18   0xD156             BNE.N    ??mbedtls_aes_crypt_ecb_0
    413            }
    414          
    415            if ( ctx->keybits != 128UL && ctx->keybits != 192UL && ctx->keybits != 256UL) {
   \       0x1A   0x6838             LDR      R0,[R7, #+0]
   \       0x1C   0x2880             CMP      R0,#+128
   \       0x1E   0xBF18             IT       NE
   \       0x20   0x28C0             CMPNE    R0,#+192
   \       0x22   0xD005             BEQ.N    ??mbedtls_aes_crypt_ecb_1
   \       0x24   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x28   0xBF18             IT       NE
   \       0x2A   0xF06F 0x0071      MVNNE    R0,#+113
    416              return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
   \       0x2E   0xD14B             BNE.N    ??mbedtls_aes_crypt_ecb_0
    417            }
    418          
    419            SE_Command_t command = SE_COMMAND_DEFAULT((mode == MBEDTLS_AES_ENCRYPT ? SE_COMMAND_AES_ENCRYPT : SE_COMMAND_AES_DECRYPT) | SE_COMMAND_OPTION_MODE_ECB | SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \                     ??mbedtls_aes_crypt_ecb_1: (+1)
   \       0x30   0xA809             ADD      R0,SP,#+36
   \       0x32   0x2120             MOVS     R1,#+32
   \       0x34   0x.... 0x....      BL       __aeabi_memclr4
   \       0x38   0x2C01             CMP      R4,#+1
   \       0x3A   0xBF0C             ITE      EQ
   \       0x3C   0x....             LDREQ.N  R0,??DataTable13
   \       0x3E   0x....             LDRNE.N  R0,??DataTable13_1
   \       0x40   0x9009             STR      R0,[SP, #+36]
    420            SE_DataTransfer_t key = SE_DATATRANSFER_DEFAULT(ctx->key, (ctx->keybits / 8));
   \       0x42   0xBF00             Nop
   \       0x44   0x....             ADR.N    R0,?_1
   \       0x46   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x4A   0x466C             MOV      R4,SP
   \       0x4C   0xF107 0x0E04      ADD      LR,R7,#+4
   \       0x50   0xE884 0x000E      STM      R4,{R1-R3}
   \       0x54   0xF8CD 0xE000      STR      LR,[SP, #+0]
   \       0x58   0x683C             LDR      R4,[R7, #+0]
    421            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT((void*)input, 16);
   \       0x5A   0xBF00             Nop
   \       0x5C   0x....             ADR.N    R0,?_2
    422            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, 16);
   \       0x5E   0xF10D 0x0A0C      ADD      R10,SP,#+12
   \       0x62   0x08E4             LSRS     R4,R4,#+3
   \       0x64   0xF044 0x5400      ORR      R4,R4,#0x20000000
   \       0x68   0x9402             STR      R4,[SP, #+8]
   \       0x6A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x6E   0xAC06             ADD      R4,SP,#+24
    423          
    424            SE_addDataInput(&command, &key);
   \       0x70   0xA809             ADD      R0,SP,#+36
   \       0x72   0xE884 0x000E      STM      R4,{R1-R3}
   \       0x76   0x9506             STR      R5,[SP, #+24]
   \       0x78   0x....             ADR.N    R4,?_3
   \       0x7A   0xE894 0x0320      LDM      R4,{R5,R8,R9}
   \       0x7E   0x4669             MOV      R1,SP
   \       0x80   0xE88A 0x0320      STM      R10,{R5,R8,R9}
   \       0x84   0x9603             STR      R6,[SP, #+12]
   \       0x86   0x.... 0x....      BL       SE_addDataInput
    425            SE_addDataInput(&command, &in);
   \       0x8A   0xA906             ADD      R1,SP,#+24
   \       0x8C   0xA809             ADD      R0,SP,#+36
   \       0x8E   0x.... 0x....      BL       SE_addDataInput
    426            SE_addDataOutput(&command, &out);
   \       0x92   0xA903             ADD      R1,SP,#+12
   \       0x94   0xA809             ADD      R0,SP,#+36
   \       0x96   0x.... 0x....      BL       SE_addDataOutput
    427            SE_addParameter(&command, (ctx->keybits / 8));
   \       0x9A   0x6839             LDR      R1,[R7, #+0]
   \       0x9C   0xA809             ADD      R0,SP,#+36
   \       0x9E   0x08C9             LSRS     R1,R1,#+3
   \       0xA0   0x.... 0x....      BL       SE_addParameter
    428            SE_addParameter(&command, 16);
   \       0xA4   0x2110             MOVS     R1,#+16
   \       0xA6   0xA809             ADD      R0,SP,#+36
   \       0xA8   0x.... 0x....      BL       SE_addParameter
    429          
    430            int status = se_management_acquire();
   \       0xAC   0x.... 0x....      BL       se_management_acquire
    431            if (status != 0) {
   \       0xB0   0xB950             CBNZ.N   R0,??mbedtls_aes_crypt_ecb_0
    432              return status;
    433            }
    434          
    435            SE_executeCommand(&command);
   \       0xB2   0xA809             ADD      R0,SP,#+36
   \       0xB4   0x.... 0x....      BL       SE_executeCommand
    436            command_status = SE_readCommandResponse();
   \       0xB8   0x.... 0x....      BL       ?Subroutine1
    437          
    438            se_management_release();
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xBC   0xF404 0x2470      AND      R4,R4,#0xF0000
    439          
    440            if ( command_status == SE_RESPONSE_OK ) {
   \       0xC0   0x2C00             CMP      R4,#+0
   \       0xC2   0xBF0C             ITE      EQ
   \       0xC4   0x2000             MOVEQ    R0,#+0
   \       0xC6   0x4620             MOVNE    R0,R4
    441              return 0;
    442            } else {
    443              return (int)command_status;
   \                     ??mbedtls_aes_crypt_ecb_0: (+1)
   \       0xC8   0xB012             ADD      SP,SP,#+72
   \       0xCA   0xE8BD 0x87F0      POP      {R4-R10,PC}
    444            }
    445          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable13_4
   \                     ??Subroutine1_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x02C9             LSLS     R1,R1,#+11
   \        0x6   0xD5FC             BPL.N    ??Subroutine1_0
   \        0x8   0x6904             LDR      R4,[R0, #+16]
   \        0xA   0x....             B.N      se_management_release

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    446          
    447          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    448          
    449          /*
    450           * AES-CBC buffer encryption/decryption
    451           */

   \                                 In section .text, align 4, keep-with-next
    452          int mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx,
    453                                    int mode,
    454                                    size_t length,
    455                                    unsigned char iv[16],
    456                                    const unsigned char *input,
    457                                    unsigned char *output)
    458          {
   \                     mbedtls_aes_crypt_cbc: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0xB097             SUB      SP,SP,#+92
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461D             MOV      R5,R3
    459            SE_Response_t command_status;
    460          
    461            AES_VALIDATE_RET(ctx != NULL);
    462            AES_VALIDATE_RET(iv != NULL);
    463            AES_VALIDATE_RET(input != NULL);
    464            AES_VALIDATE_RET(output != NULL);
    465          
    466            if ((mode != MBEDTLS_AES_ENCRYPT) && (mode != MBEDTLS_AES_DECRYPT)) {
   \        0xE   0x2C01             CMP      R4,#+1
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2C00             CMPNE    R4,#+0
   \       0x14   0xF06F 0x0020      MVNNE    R0,#+32
    467              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
   \       0x18   0xD104             BNE.N    ??mbedtls_aes_crypt_cbc_0
    468            }
    469          
    470            // Input length must be a multiple of 16 bytes which is the AES block
    471            // length.
    472            if ( length & 0xf ) {
   \       0x1A   0xF016 0x0F0F      TST      R6,#0xF
   \       0x1E   0xBF18             IT       NE
   \       0x20   0xF06F 0x0021      MVNNE    R0,#+33
    473              return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;
   \                     ??mbedtls_aes_crypt_cbc_0: (+1)
   \       0x24   0xD175             BNE.N    ??mbedtls_aes_crypt_cbc_1
    474            }
    475          
    476            if ( ctx->keybits != 128UL && ctx->keybits != 192UL && ctx->keybits != 256UL) {
   \       0x26   0x6838             LDR      R0,[R7, #+0]
   \       0x28   0x2880             CMP      R0,#+128
   \       0x2A   0xBF18             IT       NE
   \       0x2C   0x28C0             CMPNE    R0,#+192
   \       0x2E   0xD005             BEQ.N    ??mbedtls_aes_crypt_cbc_2
   \       0x30   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x34   0xBF18             IT       NE
   \       0x36   0xF06F 0x001F      MVNNE    R0,#+31
    477              return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
   \       0x3A   0xD16A             BNE.N    ??mbedtls_aes_crypt_cbc_1
    478            }
    479          
    480            SE_Command_t command = SE_COMMAND_DEFAULT((mode == MBEDTLS_AES_ENCRYPT ? SE_COMMAND_AES_ENCRYPT : SE_COMMAND_AES_DECRYPT) | SE_COMMAND_OPTION_MODE_CBC | SE_COMMAND_OPTION_CONTEXT_ADD);
   \                     ??mbedtls_aes_crypt_cbc_2: (+1)
   \       0x3C   0xA80F             ADD      R0,SP,#+60
   \       0x3E   0x2120             MOVS     R1,#+32
   \       0x40   0x.... 0x....      BL       __aeabi_memclr4
   \       0x44   0x2C01             CMP      R4,#+1
   \       0x46   0xBF0C             ITE      EQ
   \       0x48   0x....             LDREQ.N  R0,??DataTable13_2
   \       0x4A   0x....             LDRNE.N  R0,??DataTable13_3
   \       0x4C   0x900F             STR      R0,[SP, #+60]
    481            SE_DataTransfer_t key = SE_DATATRANSFER_DEFAULT(ctx->key, (ctx->keybits / 8));
   \       0x4E   0xBF00             Nop
   \       0x50   0x....             ADR.N    R0,?_5
   \       0x52   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \       0x56   0xAB06             ADD      R3,SP,#+24
   \       0x58   0xF107 0x0E04      ADD      LR,R7,#+4
   \       0x5C   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \       0x60   0xF8CD 0xE018      STR      LR,[SP, #+24]
   \       0x64   0x683B             LDR      R3,[R7, #+0]
    482            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, 16);
   \       0x66   0xBF00             Nop
   \       0x68   0x....             ADR.N    R0,?_6
   \       0x6A   0xA90C             ADD      R1,SP,#+48
   \       0x6C   0x08DB             LSRS     R3,R3,#+3
   \       0x6E   0xF043 0x5300      ORR      R3,R3,#0x20000000
   \       0x72   0x9308             STR      R3,[SP, #+32]
   \       0x74   0xE890 0x0700      LDM      R0,{R8-R10}
    483            SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(iv, 16);
   \       0x78   0xF10D 0x0E24      ADD      LR,SP,#+36
    484            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT((void*)input, length);
   \       0x7C   0xA803             ADD      R0,SP,#+12
   \       0x7E   0xE881 0x0700      STM      R1,{R8-R10}
   \       0x82   0x950C             STR      R5,[SP, #+48]
   \       0x84   0x.... 0x....      ADR.W    R1,?_7
   \       0x88   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0x8C   0x....             ADR.N    R1,?_8
   \       0x8E   0xE88E 0x001C      STM      LR,{R2-R4}
   \       0x92   0x9509             STR      R5,[SP, #+36]
   \       0x94   0xE891 0x4120      LDM      R1,{R5,R8,LR}
   \       0x98   0x9920             LDR      R1,[SP, #+128]
    485            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \       0x9A   0x466C             MOV      R4,SP
   \       0x9C   0xE880 0x4120      STM      R0,{R5,R8,LR}
   \       0xA0   0x9103             STR      R1,[SP, #+12]
   \       0xA2   0xF046 0x5100      ORR      R1,R6,#0x20000000
   \       0xA6   0x9105             STR      R1,[SP, #+20]
   \       0xA8   0x....             ADR.N    R0,?_9
   \       0xAA   0xE890 0x002C      LDM      R0,{R2,R3,R5}
   \       0xAE   0xF8DD 0xE084      LDR      LR,[SP, #+132]
    486          
    487            SE_addDataInput(&command, &key);
   \       0xB2   0xA80F             ADD      R0,SP,#+60
   \       0xB4   0xE884 0x002C      STM      R4,{R2,R3,R5}
   \       0xB8   0xF8CD 0xE000      STR      LR,[SP, #+0]
   \       0xBC   0x9102             STR      R1,[SP, #+8]
   \       0xBE   0xA906             ADD      R1,SP,#+24
   \       0xC0   0x.... 0x....      BL       SE_addDataInput
    488            SE_addDataInput(&command, &iv_in);
   \       0xC4   0xA90C             ADD      R1,SP,#+48
   \       0xC6   0xA80F             ADD      R0,SP,#+60
   \       0xC8   0x.... 0x....      BL       SE_addDataInput
    489            SE_addDataInput(&command, &in);
   \       0xCC   0xA903             ADD      R1,SP,#+12
   \       0xCE   0xA80F             ADD      R0,SP,#+60
   \       0xD0   0x.... 0x....      BL       SE_addDataInput
    490            SE_addDataOutput(&command, &out);
   \       0xD4   0x4669             MOV      R1,SP
   \       0xD6   0xA80F             ADD      R0,SP,#+60
   \       0xD8   0x.... 0x....      BL       SE_addDataOutput
    491            SE_addDataOutput(&command, &iv_out);
   \       0xDC   0xA909             ADD      R1,SP,#+36
   \       0xDE   0xA80F             ADD      R0,SP,#+60
   \       0xE0   0x.... 0x....      BL       SE_addDataOutput
    492            SE_addParameter(&command, (ctx->keybits / 8));
   \       0xE4   0x6839             LDR      R1,[R7, #+0]
   \       0xE6   0xA80F             ADD      R0,SP,#+60
   \       0xE8   0x08C9             LSRS     R1,R1,#+3
   \       0xEA   0x.... 0x....      BL       SE_addParameter
    493            SE_addParameter(&command, length);
   \       0xEE   0x4631             MOV      R1,R6
   \       0xF0   0xA80F             ADD      R0,SP,#+60
   \       0xF2   0x.... 0x....      BL       SE_addParameter
    494          
    495            int status = se_management_acquire();
   \       0xF6   0x.... 0x....      BL       se_management_acquire
    496            if (status != 0) {
   \       0xFA   0xB950             CBNZ.N   R0,??mbedtls_aes_crypt_cbc_1
    497              return status;
    498            }
    499          
    500            SE_executeCommand(&command);
   \       0xFC   0xA80F             ADD      R0,SP,#+60
   \       0xFE   0x.... 0x....      BL       SE_executeCommand
    501            command_status = SE_readCommandResponse();
   \      0x102   0x.... 0x....      BL       ?Subroutine1
    502          
    503            se_management_release();
   \                     ??CrossCallReturnLabel_0: (+1)
   \      0x106   0xF404 0x2470      AND      R4,R4,#0xF0000
    504          
    505            if ( command_status == SE_RESPONSE_OK ) {
   \      0x10A   0x2C00             CMP      R4,#+0
   \      0x10C   0xBF0C             ITE      EQ
   \      0x10E   0x2000             MOVEQ    R0,#+0
   \      0x110   0x4620             MOVNE    R0,R4
    506              return 0;
    507            } else {
    508              return (int)command_status;
   \                     ??mbedtls_aes_crypt_cbc_1: (+1)
   \      0x112   0xB018             ADD      SP,SP,#+96
   \      0x114   0xE8BD 0x87F0      POP      {R4-R10,PC}
    509            }
    510          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x0400'0100        DC32     0x4000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x0401'0100        DC32     0x4010100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x0400'0203        DC32     0x4000203

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x0401'0203        DC32     0x4010203

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x4C00'0044        DC32     0x4c000044
    511          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    512          
    513          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    514          /*
    515           * AES-CFB128 buffer encryption/decryption
    516           */
    517          int mbedtls_aes_crypt_cfb128(mbedtls_aes_context *ctx,
    518                                       int mode,
    519                                       size_t length,
    520                                       size_t *iv_off,
    521                                       unsigned char iv[16],
    522                                       const unsigned char *input,
    523                                       unsigned char *output)
    524          {
    525            size_t n = iv_off ? *iv_off : 0;
    526            size_t processed = 0;
    527            SE_Response_t command_status = SE_RESPONSE_OK;
    528          
    529            AES_VALIDATE_RET(ctx != NULL);
    530            AES_VALIDATE_RET(iv_off != NULL);
    531            AES_VALIDATE_RET(iv != NULL);
    532            AES_VALIDATE_RET(input != NULL);
    533            AES_VALIDATE_RET(output != NULL);
    534          
    535            if ((mode != MBEDTLS_AES_ENCRYPT) && (mode != MBEDTLS_AES_DECRYPT)) {
    536              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
    537            }
    538          
    539            if ( n > 15 ) {
    540              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
    541            }
    542          
    543            if ( ctx->keybits != 128UL && ctx->keybits != 192UL && ctx->keybits != 256UL) {
    544              return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    545            }
    546          
    547            while ( processed < length ) {
    548              if ( n > 0 ) {
    549                /* start by filling up the IV */
    550                if ( mode == MBEDTLS_AES_ENCRYPT ) {
    551                  iv[n] = output[processed] = (unsigned char)(iv[n] ^ input[processed]);
    552                } else {
    553                  int c = input[processed];
    554                  output[processed] = (unsigned char)(c ^ iv[n]);
    555                  iv[n] = (unsigned char) c;
    556                }
    557                n = (n + 1) & 0x0F;
    558                processed++;
    559              } else {
    560                /* process one ore more blocks of data */
    561                size_t iterations = (length - processed) / 16;
    562          
    563                if ( iterations > 0 ) {
    564                  SE_Command_t command = SE_COMMAND_DEFAULT((mode == MBEDTLS_AES_ENCRYPT ? SE_COMMAND_AES_ENCRYPT : SE_COMMAND_AES_DECRYPT) | SE_COMMAND_OPTION_MODE_CFB | SE_COMMAND_OPTION_CONTEXT_ADD);
    565                  SE_DataTransfer_t key = SE_DATATRANSFER_DEFAULT(ctx->key, (ctx->keybits / 8));
    566                  SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, 16);
    567                  SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(iv, 16);
    568                  SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT((void*)&input[processed], iterations * 16);
    569                  SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(&output[processed], iterations * 16);
    570          
    571                  SE_addDataInput(&command, &key);
    572                  SE_addDataInput(&command, &iv_in);
    573                  SE_addDataInput(&command, &in);
    574                  SE_addDataOutput(&command, &out);
    575                  SE_addDataOutput(&command, &iv_out);
    576                  SE_addParameter(&command, (ctx->keybits / 8));
    577                  SE_addParameter(&command, iterations * 16);
    578          
    579                  int status = se_management_acquire();
    580                  if (status != 0) {
    581                    return status;
    582                  }
    583          
    584                  SE_executeCommand(&command);
    585                  command_status = SE_readCommandResponse();
    586          
    587                  se_management_release();
    588                  processed += iterations * 16;
    589                }
    590          
    591                if ( command_status != SE_RESPONSE_OK ) {
    592                  goto exit;
    593                }
    594          
    595                while ( length - processed > 0 ) {
    596                  if ( n == 0 ) {
    597                    // Need to update the IV but don't have a full block of input to pass to the SE
    598                    int status = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);
    599                    if (status != 0) {
    600                      return status;
    601                    }
    602                  }
    603                  /* Save remainder to iv */
    604                  if ( mode == MBEDTLS_AES_ENCRYPT ) {
    605                    iv[n] = output[processed] = (unsigned char)(iv[n] ^ input[processed]);
    606                  } else {
    607                    int c = input[processed];
    608                    output[processed] = (unsigned char)(c ^ iv[n]);
    609                    iv[n] = (unsigned char) c;
    610                  }
    611                  n = (n + 1) & 0x0F;
    612                  processed++;
    613                }
    614              }
    615            }
    616          
    617            if ( iv_off ) {
    618              *iv_off = n;
    619            }
    620          
    621            exit:
    622            if ( command_status == SE_RESPONSE_OK ) {
    623              return 0;
    624            } else {
    625              return (int)command_status;
    626            }
    627          }
    628          
    629          /*
    630           * AES-CFB8 buffer encryption/decryption
    631           */
    632          int mbedtls_aes_crypt_cfb8(mbedtls_aes_context *ctx,
    633                                     int mode,
    634                                     size_t length,
    635                                     unsigned char iv[16],
    636                                     const unsigned char *input,
    637                                     unsigned char *output)
    638          {
    639            unsigned char c;
    640            unsigned char ov[17];
    641            int ret = 0;
    642          
    643            AES_VALIDATE_RET(ctx != NULL);
    644            AES_VALIDATE_RET(iv != NULL);
    645            AES_VALIDATE_RET(input != NULL);
    646            AES_VALIDATE_RET(output != NULL);
    647          
    648            if ((mode != MBEDTLS_AES_ENCRYPT) && (mode != MBEDTLS_AES_DECRYPT)) {
    649              return MBEDTLS_ERR_AES_BAD_INPUT_DATA;
    650            }
    651          
    652            if ( ctx->keybits != 128UL && ctx->keybits != 192UL && ctx->keybits != 256UL) {
    653              return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    654            }
    655          
    656            while ( length-- ) {
    657              memcpy(ov, iv, 16);
    658              if ( (ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv) ) != 0 ) {
    659                return ret;
    660              }
    661          
    662              if ( mode == MBEDTLS_AES_DECRYPT ) {
    663                ov[16] = *input;
    664              }
    665          
    666              c = *output++ = (unsigned char)(iv[0] ^ *input++);
    667          
    668              if ( mode == MBEDTLS_AES_ENCRYPT ) {
    669                ov[16] = c;
    670              }
    671          
    672              memcpy(iv, ov + 1, 16);
    673            }
    674          
    675            return ret;
    676          }
    677          #endif /*MBEDTLS_CIPHER_MODE_CFB */
    678          
    679          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    680          /*
    681           * AES-CTR buffer encryption/decryption
    682           */
    683          int mbedtls_aes_crypt_ctr(mbedtls_aes_context *ctx,
    684                                    size_t length,
    685                                    size_t *nc_off,
    686                                    unsigned char nonce_counter[16],
    687                                    unsigned char stream_block[16],
    688                                    const unsigned char *input,
    689                                    unsigned char *output)
    690          {
    691            size_t n = nc_off ? *nc_off : 0;
    692            size_t processed = 0;
    693            SE_Response_t command_status = SE_RESPONSE_OK;
    694          
    695            AES_VALIDATE_RET(ctx != NULL);
    696            AES_VALIDATE_RET(nc_off != NULL);
    697            AES_VALIDATE_RET(nonce_counter != NULL);
    698            AES_VALIDATE_RET(stream_block != NULL);
    699            AES_VALIDATE_RET(input != NULL);
    700            AES_VALIDATE_RET(output != NULL);
    701          
    702            if ( ctx->keybits != 128UL && ctx->keybits != 192UL && ctx->keybits != 256UL) {
    703              return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    704            }
    705          
    706            while ( processed < length ) {
    707              if ( n > 0 ) {
    708                /* start by filling up the IV */
    709                output[processed] = (unsigned char)(input[processed] ^ stream_block[n]);
    710                n = (n + 1) & 0x0F;
    711                processed++;
    712              } else {
    713                /* process one or more blocks of data */
    714                size_t iterations = (length - processed) / 16;
    715          
    716                if ( iterations > 0 ) {
    717                  SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_AES_ENCRYPT | SE_COMMAND_OPTION_MODE_CTR | SE_COMMAND_OPTION_CONTEXT_ADD);
    718                  SE_DataTransfer_t key = SE_DATATRANSFER_DEFAULT(ctx->key, (ctx->keybits / 8));
    719                  SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(nonce_counter, 16);
    720                  SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(nonce_counter, 16);
    721                  SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT((void*)&input[processed], iterations * 16);
    722                  SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(&output[processed], iterations * 16);
    723          
    724                  SE_addDataInput(&command, &key);
    725                  SE_addDataInput(&command, &iv_in);
    726                  SE_addDataInput(&command, &in);
    727                  SE_addDataOutput(&command, &out);
    728                  SE_addDataOutput(&command, &iv_out);
    729                  SE_addParameter(&command, (ctx->keybits / 8));
    730                  SE_addParameter(&command, iterations * 16);
    731          
    732                  int status = se_management_acquire();
    733                  if (status != 0) {
    734                    return status;
    735                  }
    736          
    737                  SE_executeCommand(&command);
    738                  command_status = SE_readCommandResponse();
    739          
    740                  se_management_release();
    741                  processed += iterations * 16;
    742                }
    743          
    744                if ( command_status != SE_RESPONSE_OK ) {
    745                  goto exit;
    746                }
    747          
    748                while ( length - processed > 0 ) {
    749                  if ( n == 0 ) {
    750                    // Get a new stream block
    751                    int status = mbedtls_aes_crypt_ecb(ctx,
    752                                                       MBEDTLS_AES_ENCRYPT,
    753                                                       nonce_counter,
    754                                                       stream_block);
    755                    if (status != 0) {
    756                      return status;
    757                    }
    758                    // increment nonce counter...
    759                    for (size_t i = 0; i < 16; i++) {
    760                      nonce_counter[15 - i] = nonce_counter[15 - i] + 1;
    761                      if ( nonce_counter[15 - i] != 0 ) {
    762                        break;
    763                      }
    764                    }
    765                  }
    766                  /* Save remainder to iv */
    767                  output[processed] = (unsigned char)(input[processed] ^ stream_block[n]);
    768                  n = (n + 1) & 0x0F;
    769                  processed++;
    770                }
    771              }
    772            }
    773          
    774            if ( nc_off ) {
    775              *nc_off = n;
    776            }
    777          
    778            exit:
    779            if ( command_status == SE_RESPONSE_OK ) {
    780              return 0;
    781            } else {
    782              return (int)command_status;
    783            }
    784          }
    785          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    786          
    787          #if defined(MBEDTLS_CIPHER_MODE_OFB)
    788          /*
    789           * AES-OFB (Output Feedback Mode) buffer encryption/decryption
    790           */
    791          int mbedtls_aes_crypt_ofb(mbedtls_aes_context *ctx,
    792                                    size_t length,
    793                                    size_t *iv_off,
    794                                    unsigned char iv[16],
    795                                    const unsigned char *input,
    796                                    unsigned char *output)
    797          {
    798            int ret = 0;
    799            size_t n;
    800          
    801            AES_VALIDATE_RET(ctx != NULL);
    802            AES_VALIDATE_RET(iv_off != NULL);
    803            AES_VALIDATE_RET(iv != NULL);
    804            AES_VALIDATE_RET(input != NULL);
    805            AES_VALIDATE_RET(output != NULL);
    806          
    807            n = *iv_off;
    808          
    809            if ( n > 15 ) {
    810              return(MBEDTLS_ERR_AES_BAD_INPUT_DATA);
    811            }
    812          
    813            while ( length-- ) {
    814              if ( n == 0 ) {
    815                ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);
    816                if ( ret != 0 ) {
    817                  goto exit;
    818                }
    819              }
    820              *output++ =  *input++ ^ iv[n];
    821          
    822              n = (n + 1) & 0x0F;
    823            }
    824          
    825            *iv_off = n;
    826          
    827            exit:
    828            return(ret);
    829          }
    830          #endif /* MBEDTLS_CIPHER_MODE_OFB */
    831          
    832          #endif /* SEMAILBOX_PRESENT */
    833          
    834          #endif /* MBEDTLS_AES_ALT */
    835          
    836          #endif /* MBEDTLS_AES_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     128   mbedtls_aes_crypt_cbc
       128   -> SE_addDataInput
       128   -> SE_addDataOutput
       128   -> SE_addParameter
       128   -> SE_executeCommand
       128   -> __aeabi_memclr4
       128   -> se_management_acquire
       128   -> se_management_release
     104   mbedtls_aes_crypt_ecb
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> SE_executeCommand
       104   -> __aeabi_memclr4
       104   -> se_management_acquire
       104   -> se_management_release
       0   mbedtls_aes_free
         0   -> __aeabi_memclr4
       0   mbedtls_aes_init
         0   -> __aeabi_memclr4
       0   mbedtls_aes_setkey_dec
         0   -> mbedtls_aes_setkey_enc
      16   mbedtls_aes_setkey_enc
        16   -> __aeabi_memclr4
        16   -> __aeabi_memcpy
       8   se_management_acquire
         8   -> sli_se_lock_acquire
       8   se_management_release
         8   -> sli_se_lock_release


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       8  ?Subroutine0
      12  ?Subroutine1
      32  ?_0
      12  ?_1
      12  ?_2
      12  ?_3
      32  ?_4
      12  ?_5
      12  ?_6
      12  ?_7
      12  ?_8
      12  ?_9
     280  mbedtls_aes_crypt_cbc
     206  mbedtls_aes_crypt_ecb
      12  mbedtls_aes_free
       6  mbedtls_aes_init
       2  mbedtls_aes_setkey_dec
      48  mbedtls_aes_setkey_enc
       8  se_management_acquire
       6  se_management_release

 
  64 bytes in section .rodata
 704 bytes in section .text
 
 704 bytes of CODE  memory
  64 bytes of CONST memory

Errors: none
Warnings: none
