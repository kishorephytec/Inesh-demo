###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:58
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\pa_conversions_efr32.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\pa-conversions_3073922530588947952.dir\pa_conversions_efr32.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\pa_conversions_efr32.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\pa-conversions_3073922530588947952.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\pa-conversions_3073922530588947952.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\pa-conversions_3073922530588947952.dir\pa_conversions_efr32.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\pa-conversions_3073922530588947952.dir\pa_conversions_efr32.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\pa-conversions_3073922530588947952.dir\pa_conversions_efr32.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\pa_conversions_efr32.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief PA power conversion functions provided to the customer as source for
      4           *   highest level of customization.
      5           * @details This file contains the curves and logic that convert PA power
      6           *   levels to dBm powers.
      7           *******************************************************************************
      8           * # License
      9           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
     10           *******************************************************************************
     11           *
     12           * SPDX-License-Identifier: Zlib
     13           *
     14           * The licensor of this software is Silicon Laboratories Inc.
     15           *
     16           * This software is provided 'as-is', without any express or implied
     17           * warranty. In no event will the authors be held liable for any damages
     18           * arising from the use of this software.
     19           *
     20           * Permission is granted to anyone to use this software for any purpose,
     21           * including commercial applications, and to alter it and redistribute it
     22           * freely, subject to the following restrictions:
     23           *
     24           * 1. The origin of this software must not be misrepresented; you must not
     25           *    claim that you wrote the original software. If you use this software
     26           *    in a product, an acknowledgment in the product documentation would be
     27           *    appreciated but is not required.
     28           * 2. Altered source versions must be plainly marked as such, and must not be
     29           *    misrepresented as being the original software.
     30           * 3. This notice may not be removed or altered from any source distribution.
     31           *
     32           ******************************************************************************/
     33          // For details on how to use this plugin, see
     34          //   https://www.silabs.com/documents/public/application-notes/an1127-power-amplifier-power-conversion-functions.pdf
     35          
     36          #include "em_device.h"
     37          #include "em_cmu.h"
     38          #include "pa_conversions_efr32.h"
     39          #include "rail.h"
     40          
     41          #define MAX(a, b) ((a) > (b) ? (a) : (b))
     42          
     43          static RAIL_TxPowerCurvesConfigAlt_t powerCurvesState;
     44          
     45          // Make sure SUPPORTED_PA_INDICES match the per-platform PA curves
     46          // provided by RAIL_DECLARE_TX_POWER_CURVES_CONFIG_ALT and resulting
     47          // RAIL_TxPowerCurvesConfigAlt_t!
     48          #ifndef SUPPORTED_PA_INDICES
     49          #if defined(_SILICON_LABS_32B_SERIES_1)
     50          #define SUPPORTED_PA_INDICES {                   \
     51              0U,        /* 2P4GIG_HP  */                  \
     52              RAIL_NUM_PA, /* 2P4GIG_MP  */                \
     53              1U,        /* 2P4GIG_LP  */                  \
     54              RAIL_NUM_PA, /* 2P4GIG_LLP */                \
     55              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */            \
     56              RAIL_NUM_PA, /* SUBGIG_POWERSETTING_TABLE */ \
     57              2U,        /* SUBGIG_HP */                   \
     58              /* The rest are unsupported */               \
     59          }
     60          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 1)
     61          #define SUPPORTED_PA_INDICES {     \
     62              0U,        /* 2P4GIG_HP  */    \
     63              1U,        /* 2P4GIG_MP  */    \
     64              2U,        /* 2P4GIG_LP  */    \
     65              /* The rest are unsupported */ \
     66          }
     67          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 2)
     68          #define SUPPORTED_PA_INDICES {     \
     69              0U,        /* 2P4GIG_HP  */    \
     70              RAIL_NUM_PA, /* 2P4GIG_MP  */  \
     71              1U,        /* 2P4GIG_LP  */    \
     72              /* The rest are unsupported */ \
     73          }
     74          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 3)
     75          #define SUPPORTED_PA_INDICES {                   \
     76              RAIL_NUM_PA, /* 2P4GIG_HP  */                \
     77              RAIL_NUM_PA, /* 2P4GIG_MP  */                \
     78              RAIL_NUM_PA, /* 2P4GIG_LP  */                \
     79              RAIL_NUM_PA, /* 2P4GIG_LLP */                \
     80              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */            \
     81              RAIL_NUM_PA, /* SUBGIG_POWERSETTING_TABLE */ \
     82              0U,        /* SUBGIG_HP */                   \
     83              1U,        /* SUBGIG_MP */                   \
     84              2U,        /* SUBGIG_LP */                   \
     85              3U,        /* SUBGIG_LLP */                  \
     86              /* The rest are unsupported */               \
     87          }
     88          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 4)
     89          #define SUPPORTED_PA_INDICES {     \
     90              0U,        /* 2P4GIG_HP  */    \
     91              RAIL_NUM_PA, /* 2P4GIG_MP  */  \
     92              1U,        /* 2P4GIG_LP  */    \
     93              /* The rest are unsupported */ \
     94          }
     95          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 5)
     96          #define SUPPORTED_PA_INDICES {                      \
     97              RAIL_NUM_PA, /* 2P4GIG_HP  */                   \
     98              RAIL_NUM_PA, /* 2P4GIG_MP  */                   \
     99              RAIL_NUM_PA, /* 2P4GIG_LP  */                   \
    100              RAIL_NUM_PA, /* 2P4GIG_LLP */                   \
    101              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */               \
    102              0U,        /* SUBGIG_POWERSETTING_TABLE */      \
    103              RAIL_NUM_PA, /* SUBGIG_HP */                    \
    104              RAIL_NUM_PA, /* SUBGIG_MP */                    \
    105              RAIL_NUM_PA, /* SUBGIG_LP */                    \
    106              RAIL_NUM_PA, /* SUBGIG_LLP */                   \
    107              RAIL_NUM_PA, /* SUBGIG_HIGHEST */               \
    108              1U,        /* OFDM_PA_POWERSETTING_TABLE */     \
    109              2U,        /* SUBGIG_EFF_POWERSETTING_TABLE */  \
    110              3U,        /* OFDM_PA_EFF_POWERSETTING_TABLE */ \
    111          }
    112          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 7)
    113          #define SUPPORTED_PA_INDICES {     \
    114              0U,        /* 2P4GIG_HP  */    \
    115              RAIL_NUM_PA, /* 2P4GIG_MP  */  \
    116              1U,        /* 2P4GIG_LP  */    \
    117              /* The rest are unsupported */ \
    118          }
    119          #elif (_SILICON_LABS_32B_SERIES_2_CONFIG == 8)
    120          #define SUPPORTED_PA_INDICES {                   \
    121              0U,        /* 2P4GIG_HP  */                  \
    122              RAIL_NUM_PA, /* 2P4GIG_MP  */                \
    123              RAIL_NUM_PA, /* 2P4GIG_LP  */                \
    124              RAIL_NUM_PA, /* 2P4GIG_LLP */                \
    125              RAIL_NUM_PA, /* 2P4GIG_HIGHEST */            \
    126              RAIL_NUM_PA, /* SUBGIG_POWERSETTING_TABLE */ \
    127              1U,        /* SUBGIG_HP */                   \
    128              2U,        /* SUBGIG_MP */                   \
    129              3U,        /* SUBGIG_LP */                   \
    130              4U,        /* SUBGIG_LLP */                  \
    131              /* The rest are unsupported */               \
    132          }
    133          #else
    134          #error "unknown platform"
    135          #endif
    136          #endif
    137          

   \                                 In section .text, align 4, keep-with-next
    138          static const uint8_t supportedPaIndices[] = SUPPORTED_PA_INDICES;
   \                     supportedPaIndices:
   \        0x0   0x00 0x05          DC8 0, 5, 5, 5, 5, 5, 1, 2, 3, 4
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x01 0x02    
   \              0x03 0x04
   \        0xA                      DS8 2
    139          
    140          #if defined(_SILICON_LABS_32B_SERIES_1) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    141            #define PA_CONVERSION_MINIMUM_PWRLVL 1U
    142          #else
    143            #define PA_CONVERSION_MINIMUM_PWRLVL 0U
    144          #endif
    145          
    146          //   This macro is defined when Silicon Labs builds this into the library as WEAK
    147          //   to ensure it can be overriden by customer versions of these functions. The macro
    148          //   should *not* be defined in a customer build.
    149          #ifdef RAIL_PA_CONVERSIONS_WEAK
    150          __WEAK
    151          #endif

   \                                 In section .text, align 2, keep-with-next
    152          const RAIL_TxPowerCurves_t *RAIL_GetTxPowerCurve(RAIL_TxPowerMode_t mode)
    153          {
   \                     RAIL_GetTxPowerCurve: (+1)
   \        0x0   0xB501             PUSH     {R0,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    154            static RAIL_TxPowerCurves_t powerCurves;
    155            RAIL_TxPowerLevel_t maxPowerLevel, minPowerLevel;
    156            if (RAIL_SupportsTxPowerModeAlt(RAIL_EFR32_HANDLE,
    157                                            &mode,
    158                                            &maxPowerLevel,
    159                                            &minPowerLevel)
    160                && (mode < sizeof(supportedPaIndices))
    161                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \        0x4   0x466B             MOV      R3,SP
   \        0x6   0xF10D 0x0201      ADD      R2,SP,#+1
   \        0xA   0xA902             ADD      R1,SP,#+8
   \        0xC   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x10   0x.... 0x....      BL       RAIL_SupportsTxPowerModeAlt
   \       0x14   0xB1B0             CBZ.N    R0,??RAIL_GetTxPowerCurve_0
   \       0x16   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x1A   0x280A             CMP      R0,#+10
   \       0x1C   0xBF3E             ITTT     CC
   \       0x1E   0x.... 0x....      ADRCC.W  R2,supportedPaIndices
   \       0x22   0x5C10             LDRBCC   R0,[R2, R0]
   \       0x24   0x2805             CMPCC    R0,#+5
   \       0x26   0xD20D             BCS.N    ??RAIL_GetTxPowerCurve_0
    162              const RAIL_PaDescriptor_t *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
    163              const RAIL_TxPowerCurveAlt_t *curve = modeInfo->conversion.powerCurve;
   \       0x28   0x....             LDR.N    R1,??DataTable9
   \       0x2A   0xEB01 0x00C0      ADD      R0,R1,R0, LSL #+3
   \       0x2E   0x6840             LDR      R0,[R0, #+4]
    164              // Check for an invalid power curve
    165              if (curve == NULL) {
   \       0x30   0xB148             CBZ.N    R0,??RAIL_GetTxPowerCurve_1
    166                return NULL;
    167              }
    168          
    169          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    170              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_DBM_POWERSETTING_MAPPING_TABLE) {
    171                powerCurves.maxPower = modeInfo->maxPowerDbm;
    172                powerCurves.minPower = modeInfo->minPowerDbm;
    173                // Mapping table does not have RAIL_TxPowerCurveSegment_t segments
    174                powerCurves.powerParams = NULL;
    175              } else
    176          #endif
    177              {
    178                powerCurves.maxPower = curve->maxPower;
   \       0x32   0x8803             LDRH     R3,[R0, #+0]
   \       0x34   0x860B             STRH     R3,[R1, #+48]
    179                powerCurves.minPower = curve->minPower;
   \       0x36   0x8842             LDRH     R2,[R0, #+2]
    180                powerCurves.powerParams = &curve->powerParams[0];
   \       0x38   0x1D00             ADDS     R0,R0,#+4
   \       0x3A   0x6348             STR      R0,[R1, #+52]
   \       0x3C   0x864A             STRH     R2,[R1, #+50]
    181              }
    182              return &powerCurves;
   \       0x3E   0xF101 0x0030      ADD      R0,R1,#+48
   \       0x42   0xBD0E             POP      {R1-R3,PC}
    183            }
    184            return NULL;
   \                     ??RAIL_GetTxPowerCurve_0: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??RAIL_GetTxPowerCurve_1: (+1)
   \       0x46   0xBD0E             POP      {R1-R3,PC}
    185          }

   \                                 In section .bss, align 4
   \                     powerCurvesState:
   \        0x0                      DS8 48
   \       0x30                      DS8 8
    186          
    187          // This function will not be supported for any parts after efr32xg1x
    188          #ifdef RAIL_PA_CONVERSIONS_WEAK
    189          __WEAK
    190          #endif

   \                                 In section .text, align 2, keep-with-next
    191          RAIL_Status_t RAIL_InitTxPowerCurves(const RAIL_TxPowerCurvesConfig_t *config)
    192          {
    193          #ifdef _SILICON_LABS_32B_SERIES_1
    194            // First PA is 2.4 GHz high power, using a piecewise fit
    195            RAIL_PaDescriptor_t *current = &powerCurvesState.curves[0];
    196            current->algorithm = RAIL_PA_ALGORITHM_PIECEWISE_LINEAR;
    197            current->segments = config->piecewiseSegments;
    198            current->min = RAIL_TX_POWER_LEVEL_2P4_HP_MIN;
    199            current->max = RAIL_TX_POWER_LEVEL_2P4_HP_MAX;
    200            static RAIL_TxPowerCurveAlt_t txPower2p4 = {
    201              .minPower = 0U,
    202              .maxPower = 0U,
    203              .powerParams = { // The current max number of piecewise segments is 8
    204                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    205                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    206              }
    207            };
    208            txPower2p4.maxPower = config->txPowerSgCurves->maxPower;
    209            txPower2p4.minPower = config->txPowerSgCurves->minPower;
    210            (void) memcpy(&txPower2p4.powerParams[0],
    211                          config->txPowerSgCurves->powerParams,
    212                          config->piecewiseSegments * sizeof(RAIL_TxPowerCurveSegment_t));
    213            current->conversion.powerCurve = &txPower2p4;
    214          
    215            // Second PA is 2.4 GHz low power, using a mapping table
    216            current = &powerCurvesState.curves[1];
    217            current->algorithm = RAIL_PA_ALGORITHM_MAPPING_TABLE;
    218            current->segments = 0U;
    219            current->min = RAIL_TX_POWER_LEVEL_2P4_LP_MIN;
    220            current->max = RAIL_TX_POWER_LEVEL_2P4_LP_MAX;
    221            current->conversion.mappingTable = config->txPower24LpCurves;
    222          
    223            // Third and final PA is Sub-GHz, using a piecewise fit
    224            current = &powerCurvesState.curves[2];
    225            current->algorithm = RAIL_PA_ALGORITHM_PIECEWISE_LINEAR;
    226            current->segments = config->piecewiseSegments;
    227            current->min = RAIL_TX_POWER_LEVEL_SUBGIG_MIN;
    228            current->max = RAIL_TX_POWER_LEVEL_SUBGIG_HP_MAX;
    229            static RAIL_TxPowerCurveAlt_t txPowerSubGig = {
    230              .minPower = 0U,
    231              .maxPower = 0U,
    232              .powerParams = { // The current max number of piecewise segments is 8
    233                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    234                { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U }, { 0U, 0U, 0U },
    235              }
    236            };
    237            txPowerSubGig.maxPower = config->txPowerSgCurves->maxPower;
    238            txPowerSubGig.minPower = config->txPowerSgCurves->minPower;
    239            (void) memcpy(&txPowerSubGig.powerParams[0],
    240                          config->txPowerSgCurves->powerParams,
    241                          config->piecewiseSegments * sizeof(RAIL_TxPowerCurveSegment_t));
    242            current->conversion.powerCurve = &txPowerSubGig;
    243          
    244            return RAIL_STATUS_NO_ERROR;
    245          #else
    246            (void) config;
    247            return RAIL_STATUS_INVALID_CALL;
   \                     RAIL_InitTxPowerCurves: (+1)
   \        0x0   0x2003             MOVS     R0,#+3
   \        0x2   0x4770             BX       LR
    248          #endif
    249          }
    250          
    251          #ifdef RAIL_PA_CONVERSIONS_WEAK
    252          __WEAK
    253          #endif

   \                                 In section .text, align 2, keep-with-next
    254          RAIL_Status_t RAIL_InitTxPowerCurvesAlt(const RAIL_TxPowerCurvesConfigAlt_t *config)
    255          {
   \                     RAIL_InitTxPowerCurvesAlt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    256            RAIL_VerifyTxPowerCurves(config);
   \        0x4   0x.... 0x....      BL       RAIL_VerifyTxPowerCurves
    257          
    258            powerCurvesState = *config;
   \        0x8   0x....             LDR.N    R0,??DataTable9
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x2230             MOVS     R2,#+48
   \        0xE   0x.... 0x....      BL       __aeabi_memcpy4
    259          
    260            return RAIL_STATUS_NO_ERROR;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD10             POP      {R4,PC}
    261          }
    262          
    263          #ifdef RAIL_PA_CONVERSIONS_WEAK
    264          __WEAK
    265          #endif

   \                                 In section .text, align 2, keep-with-next
    266          const RAIL_PaPowerSetting_t *RAIL_GetPowerSettingTable(RAIL_Handle_t railHandle, RAIL_TxPowerMode_t mode,
    267                                                                 RAIL_TxPower_t *minPower, RAIL_TxPower_t *maxPower,
    268                                                                 RAIL_TxPowerLevel_t *step)
    269          {
    270            (void)railHandle;
    271          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    272            if ((mode < sizeof(supportedPaIndices))
    273                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
    274              RAIL_PaDescriptor_t *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
    275              *minPower = modeInfo->minPowerDbm;
    276              *maxPower = modeInfo->maxPowerDbm;
    277              *step = modeInfo->step;
    278              return (RAIL_PaPowerSetting_t*)(modeInfo->conversion.mappingTable);
    279            }
    280            return NULL;
    281          #else
    282            (void)mode;
    283            (void)minPower;
    284            (void)maxPower;
    285            (void)step;
    286            return NULL;
   \                     RAIL_GetPowerSettingTable: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
    287          #endif
    288          }
    289          
    290          #ifdef RAIL_PA_CONVERSIONS_WEAK
    291          __WEAK
    292          #endif

   \                                 In section .text, align 2, keep-with-next
    293          RAIL_TxPowerLevel_t RAIL_ConvertDbmToRaw(RAIL_Handle_t railHandle,
    294                                                   RAIL_TxPowerMode_t mode,
    295                                                   RAIL_TxPower_t power)
    296          {
    297            (void)railHandle;
    298            // This function is called internally from the RAIL library,
    299            // so if the user never calls RAIL_InitTxPowerCurves - even
    300            // if they never intend to use dBm values in their code -
    301            // they'll always hit the assert below. Give the user a way
    302            // to not have to call RAIL_InitTxPowerCurves if they don't
    303            // care about dBm values by picking a dBm value that returns the
    304            // highest RAIL_TxPowerLevel_t possible. In other words, when
    305            // a channel dBm limitation greater than or equal to \ref RAIL_TX_POWER_MAX
    306            // is converted to raw units, the max RAIL_TxPowerLevel_t will be
    307            // returned. When compared to the current power level of the PA,
    308            // it will always be greater, indicating that no power coercion
    309            // is necessary to comply with channel limitations.
    310            if (power >= RAIL_TX_POWER_MAX) {
   \                     RAIL_ConvertDbmToRaw: (+1)
   \        0x0   0xF647 0x70FF      MOVW     R0,#+32767
   \        0x4   0xB5F0             PUSH     {R4-R7,LR}
   \        0x6   0x4282             CMP      R2,R0
   \        0x8   0xD101             BNE.N    ??RAIL_ConvertDbmToRaw_0
    311              return 255U;
   \        0xA   0x20FF             MOVS     R0,#+255
   \        0xC   0xBDF0             POP      {R4-R7,PC}
    312            }
    313          
    314            if ((mode < sizeof(supportedPaIndices))
    315                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \                     ??RAIL_ConvertDbmToRaw_0: (+1)
   \        0xE   0x290A             CMP      R1,#+10
   \       0x10   0xBF3E             ITTT     CC
   \       0x12   0x.... 0x....      ADRCC.W  R0,supportedPaIndices
   \       0x16   0x5C40             LDRBCC   R0,[R0, R1]
   \       0x18   0x2805             CMPCC    R0,#+5
   \       0x1A   0xD262             BCS.N    ??RAIL_ConvertDbmToRaw_1
    316              RAIL_PaDescriptor_t const *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x1C   0x....             LDR.N    R3,??DataTable9
   \       0x1E   0xEB03 0x03C0      ADD      R3,R3,R0, LSL #+3
    317              uint32_t minPowerLevel = MAX(modeInfo->min, PA_CONVERSION_MINIMUM_PWRLVL);
    318          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    319              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_DBM_POWERSETTING_MAPPING_TABLE) {
    320                RAIL_TxPower_t minPower = modeInfo->minPowerDbm;
    321                RAIL_TxPower_t maxPower = modeInfo->maxPowerDbm;
    322                RAIL_TxPowerLevel_t step = modeInfo->step;
    323          
    324                // Cap the power to within the range of the mapping table
    325                if (power < minPower) {
    326                  power = minPower;
    327                } else if (power > maxPower) {
    328                  power = maxPower;
    329                } else {
    330                  // Power level is within bounds (MISRA required else)
    331                }
    332          
    333                uint32_t powerIndex = (power - minPower) / step;
    334                RAIL_SetPaPowerSetting(railHandle, modeInfo->conversion.mappingTable[powerIndex], minPower, maxPower, power);
    335                return 0U;
    336              }
    337          #endif
    338          
    339              // If we're in low power mode, just use the simple lookup table
    340              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_MAPPING_TABLE) {
   \       0x22   0x7819             LDRB     R1,[R3, #+0]
   \       0x24   0x7898             LDRB     R0,[R3, #+2]
   \       0x26   0x2901             CMP      R1,#+1
   \       0x28   0xD111             BNE.N    ??RAIL_ConvertDbmToRaw_2
    341                // Binary search through the lookup table to find the closest power level
    342                // without going over.
    343                uint32_t lower = 0U;
    344                // Track the high side of the estimate
    345                uint32_t powerIndex = modeInfo->max - minPowerLevel;
   \       0x2A   0x78DE             LDRB     R6,[R3, #+3]
   \       0x2C   0x2400             MOVS     R4,#+0
   \       0x2E   0x685B             LDR      R3,[R3, #+4]
   \       0x30   0x1A36             SUBS     R6,R6,R0
    346          
    347                while (lower < powerIndex) {
   \                     ??RAIL_ConvertDbmToRaw_3: (+1)
   \       0x32   0x42B4             CMP      R4,R6
   \       0x34   0xD209             BCS.N    ??RAIL_ConvertDbmToRaw_4
    348                  // Calculate the midpoint of the current range
    349                  uint32_t index = powerIndex - (powerIndex - lower) / 2U;
   \       0x36   0x1B31             SUBS     R1,R6,R4
   \       0x38   0xEBA6 0x0551      SUB      R5,R6,R1, LSR #+1
    350                  if (power < modeInfo->conversion.mappingTable[index]) {
   \       0x3C   0xF933 0x7015      LDRSH    R7,[R3, R5, LSL #+1]
   \       0x40   0x42BA             CMP      R2,R7
   \       0x42   0xBFAC             ITE      GE
   \       0x44   0x462C             MOVGE    R4,R5
   \       0x46   0x1E6E             SUBLT    R6,R5,#+1
    351                    powerIndex = index - 1U;
    352                  } else {
    353                    lower = index;
   \       0x48   0xE7F3             B.N      ??RAIL_ConvertDbmToRaw_3
    354                  }
    355                }
    356                return (RAIL_TxPowerLevel_t)(powerIndex + minPowerLevel);
   \                     ??RAIL_ConvertDbmToRaw_4: (+1)
   \       0x4A   0x1980             ADDS     R0,R0,R6
   \       0x4C   0xE047             B.N      ??RAIL_ConvertDbmToRaw_5
    357              }
    358          
    359              // Here we know we're using the piecewise linear conversion
    360              RAIL_TxPowerCurveAlt_t const *paParams = modeInfo->conversion.powerCurve;
   \                     ??RAIL_ConvertDbmToRaw_2: (+1)
   \       0x4E   0x6859             LDR      R1,[R3, #+4]
    361              // Check for valid paParams before using them
    362              if (paParams == NULL) {
   \       0x50   0x2900             CMP      R1,#+0
   \       0x52   0xD046             BEQ.N    ??RAIL_ConvertDbmToRaw_1
    363                return 0U;
    364              }
    365          
    366              // Cap the power based on the PA settings.
    367              if (power > paParams->maxPower) {
   \       0x54   0xF9B1 0x4000      LDRSH    R4,[R1, #+0]
   \       0x58   0x4294             CMP      R4,R2
   \       0x5A   0xDB04             BLT.N    ??RAIL_ConvertDbmToRaw_6
    368                // If we go above the maximum dbm the chip supports
    369                // Then provide maximum powerLevel
    370                power = paParams->maxPower;
    371              } else if (power < paParams->minPower) {
   \       0x5C   0xF9B1 0x4002      LDRSH    R4,[R1, #+2]
   \       0x60   0x4294             CMP      R4,R2
   \       0x62   0xBFB8             IT       LT
   \       0x64   0x4614             MOVLT    R4,R2
    372                // If we go below the minimum we want included in the curve fit, force it.
    373                power = paParams->minPower;
    374              } else {
    375                // Do nothing, power is OK
    376              }
    377              // Map the power value to a 0 - 7 curveIndex value
    378              //There are 8 segments of step size of RAIL_TX_POWER_CURVE_INCREMENT in deci dBm
    379              //starting from maximum RAIL_TX_POWER_CURVE_MAX in deci dBm
    380              // These are just starting points to give the code
    381              // a rough idea of which segment to use, based on
    382              // how they were fit. Adjustments are made later on
    383              // if this turns out to be incorrect.
    384              RAIL_TxPower_t txPowerMax = RAIL_TX_POWER_CURVE_DEFAULT_MAX;
    385              RAIL_TxPower_t txPowerIncrement = RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT;
    386              int16_t curveIndex = 0;
    387              // if the first curve segment starts with RAIL_TX_POWER_LEVEL_INVALID
    388              //It is an extra curve segment to depict the maxpower and increment
    389              // (in deci-dBm) used while generating the curves.
    390              // The extra segment is only present when curve segment is generated by
    391              //using values different than the default - RAIL_TX_POWER_CURVE_DEFAULT_MAX
    392              // and RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT.
    393              if ((paParams->powerParams[0].maxPowerLevel) == RAIL_TX_POWER_LEVEL_INVALID) {
   \                     ??RAIL_ConvertDbmToRaw_6: (+1)
   \       0x66   0x888E             LDRH     R6,[R1, #+4]
   \       0x68   0x27C8             MOVS     R7,#+200
   \       0x6A   0x2228             MOVS     R2,#+40
   \       0x6C   0x2500             MOVS     R5,#+0
   \       0x6E   0x2EFF             CMP      R6,#+255
   \       0x70   0xD103             BNE.N    ??RAIL_ConvertDbmToRaw_7
    394                curveIndex += 1;
   \       0x72   0x2501             MOVS     R5,#+1
    395                txPowerMax = (RAIL_TxPower_t) paParams->powerParams[0].slope;
   \       0x74   0xF9B1 0x7006      LDRSH    R7,[R1, #+6]
    396                txPowerIncrement = (RAIL_TxPower_t) paParams->powerParams[0].intercept;
   \       0x78   0x688A             LDR      R2,[R1, #+8]
    397              }
    398          
    399              curveIndex += (txPowerMax - power) / txPowerIncrement;
   \                     ??RAIL_ConvertDbmToRaw_7: (+1)
   \       0x7A   0x1B3F             SUBS     R7,R7,R4
   \       0x7C   0xB212             SXTH     R2,R2
   \       0x7E   0xFB97 0xF2F2      SDIV     R2,R7,R2
    400              if ((curveIndex > ((int16_t)modeInfo->segments - 1))
    401                  || (curveIndex < 0)) {
   \       0x82   0x785E             LDRB     R6,[R3, #+1]
   \       0x84   0x1955             ADDS     R5,R2,R5
   \       0x86   0xB22D             SXTH     R5,R5
   \       0x88   0x4632             MOV      R2,R6
   \       0x8A   0x1E53             SUBS     R3,R2,#+1
   \       0x8C   0x42AB             CMP      R3,R5
   \       0x8E   0xDB01             BLT.N    ??RAIL_ConvertDbmToRaw_8
   \       0x90   0x2D00             CMP      R5,#+0
   \       0x92   0xD501             BPL.N    ??RAIL_ConvertDbmToRaw_9
    402                curveIndex = ((int16_t)modeInfo->segments - 1);
   \                     ??RAIL_ConvertDbmToRaw_8: (+1)
   \       0x94   0x1E75             SUBS     R5,R6,#+1
   \       0x96   0xB22D             SXTH     R5,R5
    403              }
    404          
    405              uint32_t powerLevel;
    406              do {
    407                // Select the correct piecewise segment to use for conversion.
    408                RAIL_TxPowerCurveSegment_t const *powerParams =
    409                  &paParams->powerParams[curveIndex];
   \                     ??RAIL_ConvertDbmToRaw_9: (+1)
   \       0x98   0x1D0E             ADDS     R6,R1,#+4
   \       0x9A   0xEB06 0x06C5      ADD      R6,R6,R5, LSL #+3
    410          
    411                // powerLevel can only go down to 0.
    412                int32_t powerLevelInt = powerParams->intercept + ((int32_t)powerParams->slope * (int32_t)power);
   \       0x9E   0x6873             LDR      R3,[R6, #+4]
   \       0xA0   0xF9B6 0x6002      LDRSH    R6,[R6, #+2]
   \       0xA4   0xFB16 0x3604      SMLABB   R6,R6,R4,R3
    413                if (powerLevelInt < 0) {
   \       0xA8   0x2E00             CMP      R6,#+0
   \       0xAA   0xBF4F             ITEEE    MI
   \       0xAC   0x2300             MOVMI    R3,#+0
   \       0xAE   0x365C             ADDPL    R6,R6,#+92
   \       0xB0   0xF44F 0x737A      MOVPL    R3,#+1000
   \       0xB4   0xFBB6 0xF3F3      UDIVPL   R3,R6,R3
    414                  powerLevel = 0U;
    415                } else {
    416                  powerLevel = (uint32_t) powerLevelInt;
    417                }
    418                // RAIL_LIB-8330: Modified from adding 500 to adding 92, this was tested on xg21 as being the highest
    419                // number we can use without exceeding the requested power in dBm
    420                powerLevel = ((powerLevel + 92U) / 1000U);
    421          
    422                // In case it turns out the resultant power level was too low and we have
    423                // to recalculate with the next curve...
    424                curveIndex++;
   \       0xB8   0x1C6D             ADDS     R5,R5,#+1
   \       0xBA   0xB22D             SXTH     R5,R5
    425              } while ((curveIndex < (int16_t)modeInfo->segments)
    426                       && (powerLevel <= paParams->powerParams[curveIndex].maxPowerLevel));
   \       0xBC   0x4295             CMP      R5,R2
   \       0xBE   0xDA04             BGE.N    ??RAIL_ConvertDbmToRaw_10
   \       0xC0   0x1D0F             ADDS     R7,R1,#+4
   \       0xC2   0xF837 0x6035      LDRH     R6,[R7, R5, LSL #+3]
   \       0xC6   0x429E             CMP      R6,R3
   \       0xC8   0xD2E6             BCS.N    ??RAIL_ConvertDbmToRaw_9
    427          
    428              // We already know that curveIndex is at most modeInfo->segments
    429              if (powerLevel > paParams->powerParams[curveIndex - 1].maxPowerLevel) {
   \                     ??RAIL_ConvertDbmToRaw_10: (+1)
   \       0xCA   0xEB01 0x01C5      ADD      R1,R1,R5, LSL #+3
   \       0xCE   0xF831 0x1C04      LDRH     R1,[R1, #-4]
   \       0xD2   0x4299             CMP      R1,R3
   \       0xD4   0xBF88             IT       HI
   \       0xD6   0x4619             MOVHI    R1,R3
    430                powerLevel = paParams->powerParams[curveIndex - 1].maxPowerLevel;
    431              }
    432          
    433              // If we go below the minimum we want included in the curve fit, force it.
    434              if (powerLevel < minPowerLevel) {
   \       0xD8   0x4288             CMP      R0,R1
   \       0xDA   0xBF38             IT       CC
   \       0xDC   0x4608             MOVCC    R0,R1
    435                powerLevel = minPowerLevel;
    436              }
    437          
    438              return (RAIL_TxPowerLevel_t)powerLevel;
   \                     ??RAIL_ConvertDbmToRaw_5: (+1)
   \       0xDE   0xB2C0             UXTB     R0,R0
   \       0xE0   0xBDF0             POP      {R4-R7,PC}
    439            }
    440            return 0U;
   \                     ??RAIL_ConvertDbmToRaw_1: (+1)
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xBDF0             POP      {R4-R7,PC}
    441          }
    442          
    443          #ifdef RAIL_PA_CONVERSIONS_WEAK
    444          __WEAK
    445          #endif

   \                                 In section .text, align 2, keep-with-next
    446          RAIL_TxPower_t RAIL_ConvertRawToDbm(RAIL_Handle_t railHandle,
    447                                              RAIL_TxPowerMode_t mode,
    448                                              RAIL_TxPowerLevel_t powerLevel)
    449          {
   \                     RAIL_ConvertRawToDbm: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    450            (void)railHandle;
    451          
    452            if ((mode < sizeof(supportedPaIndices))
    453                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \        0x2   0x290A             CMP      R1,#+10
   \        0x4   0xBF3E             ITTT     CC
   \        0x6   0x.... 0x....      ADRCC.W  R0,supportedPaIndices
   \        0xA   0x5C40             LDRBCC   R0,[R0, R1]
   \        0xC   0x2805             CMPCC    R0,#+5
   \        0xE   0xD24D             BCS.N    ??RAIL_ConvertRawToDbm_0
    454              RAIL_PaDescriptor_t const *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x10   0x....             LDR.N    R1,??DataTable9
   \       0x12   0xEB01 0x03C0      ADD      R3,R1,R0, LSL #+3
    455              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_MAPPING_TABLE) {
   \       0x16   0x7818             LDRB     R0,[R3, #+0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD110             BNE.N    ??RAIL_ConvertRawToDbm_1
    456                // Limit the max power level
    457                if (powerLevel > modeInfo->max) {
   \       0x1C   0x78D9             LDRB     R1,[R3, #+3]
   \       0x1E   0x4608             MOV      R0,R1
   \       0x20   0x4290             CMP      R0,R2
   \       0x22   0xBF88             IT       HI
   \       0x24   0x4610             MOVHI    R0,R2
    458                  powerLevel = modeInfo->max;
    459                }
    460          
    461                // We 1-index low power PA power levels, but of course arrays are 0 indexed
    462                powerLevel -= MAX(modeInfo->min, PA_CONVERSION_MINIMUM_PWRLVL);
   \       0x26   0x789A             LDRB     R2,[R3, #+2]
   \       0x28   0x1A80             SUBS     R0,R0,R2
    463          
    464                //If the index calculation above underflowed, then provide the lowest array index.
    465                if (powerLevel > (modeInfo->max - modeInfo->min)) {
   \       0x2A   0x1A89             SUBS     R1,R1,R2
   \       0x2C   0xB2C2             UXTB     R2,R0
   \       0x2E   0x4291             CMP      R1,R2
   \       0x30   0xBFB8             IT       LT
   \       0x32   0x2000             MOVLT    R0,#+0
    466                  powerLevel = 0U;
    467                }
    468                return modeInfo->conversion.mappingTable[powerLevel];
   \       0x34   0x6859             LDR      R1,[R3, #+4]
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0xF931 0x0010      LDRSH    R0,[R1, R0, LSL #+1]
   \       0x3C   0xBD70             POP      {R4-R6,PC}
    469              } else {
    470          #if defined(_SILICON_LABS_32B_SERIES_1) || defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    471                // Although 0 is a legitimate power on non-2.4 LP PA's and can be set via
    472                // "RAIL_SetTxPower(railHandle, 0)" it is MUCH lower than power
    473                // level 1 (approximately -50 dBm). Including it in the piecewise
    474                // linear fit would skew the curve substantially, so we exclude it
    475                // from the conversion.
    476                if (powerLevel == 0U) {
    477                  return -500;
    478                }
    479          #endif
    480          
    481                RAIL_TxPowerCurveAlt_t const *powerCurve = modeInfo->conversion.powerCurve;
   \                     ??RAIL_ConvertRawToDbm_1: (+1)
   \       0x3E   0x6858             LDR      R0,[R3, #+4]
    482                // Check for a valid powerCurve pointer before using it
    483                if (powerCurve == NULL) {
   \       0x40   0xB3A0             CBZ.N    R0,??RAIL_ConvertRawToDbm_0
    484                  return RAIL_TX_POWER_MIN;
    485                }
    486          
    487                RAIL_TxPowerCurveSegment_t const *powerParams = powerCurve->powerParams;
    488          
    489                // Hard code the extremes (i.e. don't use the curve fit) in order
    490                // to make it clear that we are reaching the extent of the chip's
    491                // capabilities
    492                if (powerLevel <= modeInfo->min) {
   \       0x42   0x789C             LDRB     R4,[R3, #+2]
   \       0x44   0x4294             CMP      R4,R2
   \       0x46   0xD302             BCC.N    ??RAIL_ConvertRawToDbm_2
    493                  return powerCurve->minPower;
   \       0x48   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \       0x4C   0xBD70             POP      {R4-R6,PC}
    494                } else if (powerLevel >= modeInfo->max) {
   \                     ??RAIL_ConvertRawToDbm_2: (+1)
   \       0x4E   0x78D9             LDRB     R1,[R3, #+3]
   \       0x50   0x428A             CMP      R2,R1
   \       0x52   0xD222             BCS.N    ??RAIL_ConvertRawToDbm_3
    495                  return powerCurve->maxPower;
    496                } else {
    497                  // Power level is within bounds (MISRA required else)
    498                }
    499          
    500                // Figure out which parameter to use based on the power level
    501                uint8_t x = 0;
    502                uint8_t upperBound = modeInfo->segments - 1U;
   \       0x54   0x785C             LDRB     R4,[R3, #+1]
    503          
    504                // If the first curve segment starts with RAIL_TX_POWER_LEVEL_INVALID,
    505                // then it is an additional curve segment that stores maxpower and increment
    506                // (in deci-dBm) used to generate the curves.
    507                // The extra info segment is present only if the curves were generated using
    508                // values other than default - RAIL_TX_POWER_CURVE_DEFAULT_MAX and
    509                // RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT.
    510                if ((powerParams[0].maxPowerLevel) == RAIL_TX_POWER_LEVEL_INVALID) {
   \       0x56   0x8883             LDRH     R3,[R0, #+4]
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x1E65             SUBS     R5,R4,#+1
   \       0x5C   0xB2ED             UXTB     R5,R5
   \       0x5E   0x2BFF             CMP      R3,#+255
   \       0x60   0xD103             BNE.N    ??RAIL_ConvertRawToDbm_4
    511                  x = 1U; // skip over the first entry
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0xE001             B.N      ??RAIL_ConvertRawToDbm_4
    512                }
    513          
    514                for (; x < upperBound; x++) {
   \                     ??RAIL_ConvertRawToDbm_5: (+1)
   \       0x66   0x1C49             ADDS     R1,R1,#+1
   \       0x68   0xB2C9             UXTB     R1,R1
   \                     ??RAIL_ConvertRawToDbm_4: (+1)
   \       0x6A   0xEB00 0x03C1      ADD      R3,R0,R1, LSL #+3
   \       0x6E   0x42A9             CMP      R1,R5
   \       0x70   0xDA02             BGE.N    ??RAIL_ConvertRawToDbm_6
    515                  if (powerParams[x + 1U].maxPowerLevel < powerLevel) {
   \       0x72   0x899E             LDRH     R6,[R3, #+12]
   \       0x74   0x4296             CMP      R6,R2
   \       0x76   0xD2F6             BCS.N    ??RAIL_ConvertRawToDbm_5
    516                    break;
    517                  }
    518                }
    519                int32_t power;
    520                power = ((1000 * (int32_t)(powerLevel)) - powerParams[x].intercept);
    521                power = ((power + ((int32_t)powerParams[x].slope / 2)) / (int32_t)powerParams[x].slope);
   \                     ??RAIL_ConvertRawToDbm_6: (+1)
   \       0x78   0xF9B3 0x4006      LDRSH    R4,[R3, #+6]
   \       0x7C   0xF44F 0x717A      MOV      R1,#+1000
   \       0x80   0x434A             MULS     R2,R1,R2
   \       0x82   0x689B             LDR      R3,[R3, #+8]
   \       0x84   0xEB04 0x75D4      ADD      R5,R4,R4, LSR #+31
   \       0x88   0x1AD2             SUBS     R2,R2,R3
   \       0x8A   0xEB02 0x0265      ADD      R2,R2,R5, ASR #+1
   \       0x8E   0xFB92 0xF1F4      SDIV     R1,R2,R4
    522          
    523                if (power > powerCurve->maxPower) {
   \       0x92   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \       0x96   0x428A             CMP      R2,R1
   \       0x98   0xDA02             BGE.N    ??RAIL_ConvertRawToDbm_7
    524                  return powerCurve->maxPower;
   \                     ??RAIL_ConvertRawToDbm_3: (+1)
   \       0x9A   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \       0x9E   0xBD70             POP      {R4-R6,PC}
    525                } else if (power < powerCurve->minPower) {
   \                     ??RAIL_ConvertRawToDbm_7: (+1)
   \       0xA0   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \       0xA4   0x4281             CMP      R1,R0
   \       0xA6   0xDB02             BLT.N    ??RAIL_ConvertRawToDbm_8
    526                  return powerCurve->minPower;
    527                } else {
    528                  return (RAIL_TxPower_t)power;
   \       0xA8   0xB208             SXTH     R0,R1
   \       0xAA   0xBD70             POP      {R4-R6,PC}
    529                }
    530              }
    531            }
    532            return RAIL_TX_POWER_MIN;
   \                     ??RAIL_ConvertRawToDbm_0: (+1)
   \       0xAC   0x....             LDR.N    R0,??DataTable9_1
   \                     ??RAIL_ConvertRawToDbm_8: (+1)
   \       0xAE   0xBD70             POP      {R4-R6,PC}
    533          }
    534          
    535          #ifdef RAIL_PA_CONVERSIONS_WEAK
    536          __WEAK
    537          #endif

   \                                 In section .text, align 2, keep-with-next
    538          RAIL_Status_t RAIL_GetTxPowerCurveLimits(RAIL_Handle_t railHandle,
    539                                                   RAIL_TxPowerMode_t mode,
    540                                                   RAIL_TxPower_t *maxPower,
    541                                                   RAIL_TxPower_t *increment)
    542          {
   \                     RAIL_GetTxPowerCurveLimits: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    543            (void)railHandle;
    544            if ((mode < sizeof(supportedPaIndices))
    545                && (supportedPaIndices[mode] < RAIL_NUM_PA)) {
   \        0x2   0x290A             CMP      R1,#+10
   \        0x4   0xBF3E             ITTT     CC
   \        0x6   0x.... 0x....      ADRCC.W  R0,supportedPaIndices
   \        0xA   0x5C40             LDRBCC   R0,[R0, R1]
   \        0xC   0x2805             CMPCC    R0,#+5
   \        0xE   0xD215             BCS.N    ??RAIL_GetTxPowerCurveLimits_0
    546              RAIL_PaDescriptor_t const *modeInfo = &powerCurvesState.curves[supportedPaIndices[mode]];
   \       0x10   0x....             LDR.N    R4,??DataTable9
   \       0x12   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
    547          #if RAIL_SUPPORTS_DBM_POWERSETTING_MAPPING_TABLE
    548              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_DBM_POWERSETTING_MAPPING_TABLE) {
    549                *maxPower = modeInfo->maxPowerDbm;
    550                *increment = modeInfo->step;
    551                return RAIL_STATUS_NO_ERROR;
    552              }
    553          #endif
    554          
    555              //The power max info only for available Linear fit
    556              if (modeInfo->algorithm == RAIL_PA_ALGORITHM_MAPPING_TABLE) {
   \       0x16   0x7801             LDRB     R1,[R0, #+0]
   \       0x18   0x2901             CMP      R1,#+1
   \       0x1A   0xD101             BNE.N    ??RAIL_GetTxPowerCurveLimits_1
    557                return RAIL_STATUS_INVALID_CALL;
   \       0x1C   0x2003             MOVS     R0,#+3
   \       0x1E   0xBD10             POP      {R4,PC}
    558              }
    559              *maxPower = RAIL_TX_POWER_CURVE_DEFAULT_MAX;
   \                     ??RAIL_GetTxPowerCurveLimits_1: (+1)
   \       0x20   0x24C8             MOVS     R4,#+200
   \       0x22   0x8014             STRH     R4,[R2, #+0]
    560              *increment = RAIL_TX_POWER_CURVE_DEFAULT_INCREMENT;
   \       0x24   0x2128             MOVS     R1,#+40
   \       0x26   0x8019             STRH     R1,[R3, #+0]
    561              RAIL_TxPowerCurveAlt_t const *paParams = modeInfo->conversion.powerCurve;
   \       0x28   0x6840             LDR      R0,[R0, #+4]
    562              if ((paParams->powerParams[0].maxPowerLevel) == RAIL_TX_POWER_LEVEL_INVALID) {
   \       0x2A   0x8881             LDRH     R1,[R0, #+4]
   \       0x2C   0x29FF             CMP      R1,#+255
   \       0x2E   0xD103             BNE.N    ??RAIL_GetTxPowerCurveLimits_2
    563                *maxPower = paParams->powerParams[0].slope;
   \       0x30   0x88C1             LDRH     R1,[R0, #+6]
   \       0x32   0x8011             STRH     R1,[R2, #+0]
    564                *increment = (RAIL_TxPower_t)paParams->powerParams[0].intercept;
   \       0x34   0x6880             LDR      R0,[R0, #+8]
   \       0x36   0x8018             STRH     R0,[R3, #+0]
    565              }
    566              return RAIL_STATUS_NO_ERROR;
   \                     ??RAIL_GetTxPowerCurveLimits_2: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD10             POP      {R4,PC}
    567            }
    568            return RAIL_STATUS_INVALID_PARAMETER;
   \                     ??RAIL_GetTxPowerCurveLimits_0: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xBD10             POP      {R4,PC}
    569          }
    570          
    571          // This macro is defined when Silicon Labs builds curves into the library as WEAK
    572          // to ensure it can be overriden by customer versions of these functions. It
    573          // should *not* be defined in a customer build.
    574          #if !defined(RAIL_PA_CONVERSIONS_WEAK) && !defined(HAL_CONFIG)
    575          
    576          #include "sl_rail_util_pa_config.h"
    577          

   \                                 In section .text, align 2, keep-with-next
    578          void sl_rail_util_pa_init(void)
    579          {
   \                     sl_rail_util_pa_init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    580          #if SL_RAIL_UTIL_PA_VOLTAGE_MV > 1800
    581            (void)RAIL_InitTxPowerCurvesAlt(&RAIL_TxPowerCurvesVbat);
   \        0x2   0x....             LDR.N    R0,??DataTable9_2
   \        0x4   0x.... 0x....      BL       RAIL_InitTxPowerCurvesAlt
    582          #else
    583            (void)RAIL_InitTxPowerCurvesAlt(&RAIL_TxPowerCurvesDcdc);
    584          #endif
    585          #if SL_RAIL_UTIL_PA_CALIBRATION_ENABLE
    586            RAIL_EnablePaCal(true);
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE8BD 0x4002      POP      {R1,LR}
   \        0xE   0x.... 0x....      B.W      RAIL_EnablePaCal
    587          #endif
    588          }
    589          
    590          #if RAIL_SUPPORTS_2P4GHZ_BAND
    591          static RAIL_TxPowerConfig_t txPowerConfig2p4Ghz = {
    592            .mode = SL_RAIL_UTIL_PA_SELECTION_2P4GHZ,
    593            .voltage = SL_RAIL_UTIL_PA_VOLTAGE_MV,
    594            .rampTime = SL_RAIL_UTIL_PA_RAMP_TIME_US,
    595          };
    596          #endif

   \                                 In section .text, align 2, keep-with-next
    597          RAIL_TxPowerConfig_t *sl_rail_util_pa_get_tx_power_config_2p4ghz(void)
    598          {
    599          #if RAIL_SUPPORTS_2P4GHZ_BAND
    600            return &txPowerConfig2p4Ghz;
   \                     sl_rail_util_pa_get_tx_power_config_2p4ghz: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable9_3
   \        0x2   0x4770             BX       LR
    601          #else
    602            return NULL;
    603          #endif
    604          }

   \                                 In section .data, align 4
   \                     txPowerConfig2p4Ghz:
   \        0x0   0x04               DC8 4
   \        0x1                      DS8 1
   \        0x2   0x0CE4 0x000A      DC16 3'300, 10
   \        0x6                      DS8 2
   \        0x8   0x0A               DC8 10
   \        0x9                      DS8 1
   \        0xA   0x0CE4 0x000A      DC16 3'300, 10
   \        0xE                      DS8 2
    605          
    606          #if RAIL_SUPPORTS_SUBGHZ_BAND
    607          static RAIL_TxPowerConfig_t txPowerConfigSubGhz = {
    608            .mode = SL_RAIL_UTIL_PA_SELECTION_SUBGHZ,
    609            .voltage = SL_RAIL_UTIL_PA_VOLTAGE_MV,
    610            .rampTime = SL_RAIL_UTIL_PA_RAMP_TIME_US,
    611          };
    612          #endif

   \                                 In section .text, align 2, keep-with-next
    613          RAIL_TxPowerConfig_t *sl_rail_util_pa_get_tx_power_config_subghz(void)
    614          {
    615          #if RAIL_SUPPORTS_SUBGHZ_BAND
    616            return &txPowerConfigSubGhz;
   \                     sl_rail_util_pa_get_tx_power_config_subghz: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable9_4
   \        0x2   0x4770             BX       LR
    617          #else
    618            return NULL;
    619          #endif
    620          }
    621          
    622          #if RAIL_SUPPORTS_OFDM_PA
    623          #ifndef SL_RAIL_UTIL_PA_SELECTION_OFDM
    624          #define SL_RAIL_UTIL_PA_SELECTION_OFDM RAIL_TX_POWER_MODE_OFDM_PA_POWERSETTING_TABLE
    625          #endif
    626          static RAIL_TxPowerConfig_t txPowerConfigOFDM = {
    627            .mode = SL_RAIL_UTIL_PA_SELECTION_OFDM,
    628            .voltage = SL_RAIL_UTIL_PA_VOLTAGE_MV,
    629          };
    630          #endif // RAIL_SUPPORTS_OFDM_PA

   \                                 In section .text, align 2, keep-with-next
    631          RAIL_TxPowerConfig_t *sl_rail_util_pa_get_tx_power_config_ofdm(void)
    632          {
    633          #if RAIL_SUPPORTS_OFDM_PA
    634            return &txPowerConfigOFDM;
    635          #else
    636            return NULL;
   \                     sl_rail_util_pa_get_tx_power_config_ofdm: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
    637          #endif // RAIL_SUPPORTS_OFDM_PA
    638          }
    639          

   \                                 In section .text, align 2, keep-with-next
    640          void sl_rail_util_pa_on_channel_config_change(RAIL_Handle_t rail_handle,
    641                                                        const RAIL_ChannelConfigEntry_t *entry)
    642          {
   \                     sl_rail_util_pa_on_channel_config_change: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
    643            if (!RAIL_IsPaAutoModeEnabled(rail_handle)) {
   \        0x6   0x.... 0x....      BL       RAIL_IsPaAutoModeEnabled
   \        0xA   0xBB80             CBNZ.N   R0,??sl_rail_util_pa_on_channel_config_change_0
    644              RAIL_TxPowerConfig_t currentTxPowerConfig;
    645              RAIL_TxPowerConfig_t *newTxPowerConfigPtr;
    646              RAIL_Status_t status;
    647          
    648              // Get current TX Power Config.
    649              status = RAIL_GetTxPowerConfig(rail_handle, &currentTxPowerConfig);
    650              if (status != RAIL_STATUS_NO_ERROR) {
   \        0xC   0x4669             MOV      R1,SP
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       RAIL_GetTxPowerConfig
   \       0x14   0xB100             CBZ.N    R0,??sl_rail_util_pa_on_channel_config_change_1
    651                while (true) {
   \                     ??sl_rail_util_pa_on_channel_config_change_2: (+1)
   \       0x16   0xE7FE             B.N      ??sl_rail_util_pa_on_channel_config_change_2
    652                } // Error: Can't get TX Power Config
    653              }
    654          
    655          #if RAIL_SUPPORTS_DUAL_BAND
    656              // Determine new TX Power Config.
    657              if (entry->baseFrequency < 1000000000UL) {
   \                     ??sl_rail_util_pa_on_channel_config_change_1: (+1)
   \       0x18   0x6871             LDR      R1,[R6, #+4]
   \       0x1A   0x....             LDR.N    R0,??DataTable9_5
   \       0x1C   0x....             LDR.N    R5,??DataTable9_3
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xBF38             IT       CC
   \       0x22   0x3508             ADDCC    R5,R5,#+8
    658                newTxPowerConfigPtr = &txPowerConfigSubGhz;
    659              } else {
    660                newTxPowerConfigPtr = &txPowerConfig2p4Ghz;
    661              }
    662          #else
    663              (void) entry;
    664          #if RAIL_SUPPORTS_2P4GHZ_BAND
    665              newTxPowerConfigPtr = &txPowerConfig2p4Ghz;
    666          #else
    667              newTxPowerConfigPtr = &txPowerConfigSubGhz;
    668          #endif
    669          #endif
    670          
    671          #if RAIL_IEEE802154_SUPPORTS_DUAL_PA_CONFIG
    672              if (currentTxPowerConfig.mode == RAIL_TX_POWER_MODE_NONE) {
    673          #if RAIL_SUPPORTS_OFDM_PA
    674                if (RAIL_SupportsTxPowerMode(rail_handle,
    675                                             txPowerConfigOFDM.mode,
    676                                             NULL)) {
    677                  // Apply OFDM Power Config.
    678                  status = RAIL_ConfigTxPower(rail_handle, &txPowerConfigOFDM);
    679                  if (status != RAIL_STATUS_NO_ERROR) {
    680                    while (true) {
    681                    } // Error: Can't set TX Power Config
    682                  }
    683                  // Set default TX power after RAIL_ConfigTxPower.
    684                  status = RAIL_SetTxPowerDbm(rail_handle, SL_RAIL_UTIL_PA_POWER_DECI_DBM);
    685                  if (status != RAIL_STATUS_NO_ERROR) {
    686                    while (true) {
    687                    } // Error: Can't set TX Power
    688                  }
    689                }
    690          #endif // RAIL_SUPPORTS_OFDM_PA
    691                // Apply FSK Power Config.
    692                status = RAIL_ConfigTxPower(rail_handle, newTxPowerConfigPtr);
    693                if (status != RAIL_STATUS_NO_ERROR) {
    694                  while (true) {
    695                  } // Error: Can't set TX Power Config
    696                }
    697                // Set default TX power after RAIL_ConfigTxPower.
    698                status = RAIL_SetTxPowerDbm(rail_handle, SL_RAIL_UTIL_PA_POWER_DECI_DBM);
    699                if (status != RAIL_STATUS_NO_ERROR) {
    700                  while (true) {
    701                  } // Error: Can't set TX Power
    702                }
    703              }
    704          #else
    705              // Call RAIL_ConfigTxPower only if TX Power Config mode has changed.
    706              if (currentTxPowerConfig.mode != newTxPowerConfigPtr->mode) {
   \       0x24   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x28   0x7828             LDRB     R0,[R5, #+0]
   \       0x2A   0x4281             CMP      R1,R0
   \       0x2C   0xD01F             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_0
    707                // Save current TX power before RAIL_ConfigTxPower (because not preserved).
    708                RAIL_TxPower_t txPowerDeciDbm;
    709                if (currentTxPowerConfig.mode == RAIL_TX_POWER_MODE_NONE) {
   \       0x2E   0x290E             CMP      R1,#+14
   \       0x30   0xBF08             IT       EQ
   \       0x32   0x26C8             MOVEQ    R6,#+200
    710                  txPowerDeciDbm = SL_RAIL_UTIL_PA_POWER_DECI_DBM;
   \       0x34   0xD003             BEQ.N    ??sl_rail_util_pa_on_channel_config_change_3
    711                } else {
    712                  txPowerDeciDbm = RAIL_GetTxPowerDbm(rail_handle);
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x.... 0x....      BL       RAIL_GetTxPowerDbm
   \       0x3C   0x4606             MOV      R6,R0
    713                }
    714          
    715                // Apply new TX Power Config.
    716                status = RAIL_ConfigTxPower(rail_handle, newTxPowerConfigPtr);
    717                if (status != RAIL_STATUS_NO_ERROR) {
   \                     ??sl_rail_util_pa_on_channel_config_change_3: (+1)
   \       0x3E   0x4629             MOV      R1,R5
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x.... 0x....      BL       RAIL_ConfigTxPower
   \       0x46   0xB100             CBZ.N    R0,??sl_rail_util_pa_on_channel_config_change_4
    718                  while (true) {
   \                     ??sl_rail_util_pa_on_channel_config_change_5: (+1)
   \       0x48   0xE7FE             B.N      ??sl_rail_util_pa_on_channel_config_change_5
    719                  } // Error: Can't set TX Power Config
    720                }
    721                // Restore TX power after RAIL_ConfigTxPower.
    722                status = RAIL_SetTxPowerDbm(rail_handle, txPowerDeciDbm);
    723                if (status != RAIL_STATUS_NO_ERROR) {
   \                     ??sl_rail_util_pa_on_channel_config_change_4: (+1)
   \       0x4A   0x4631             MOV      R1,R6
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       RAIL_SetTxPowerDbm
   \       0x52   0xB100             CBZ.N    R0,??sl_rail_util_pa_on_channel_config_change_6
    724                  while (true) {
   \                     ??sl_rail_util_pa_on_channel_config_change_7: (+1)
   \       0x54   0xE7FE             B.N      ??sl_rail_util_pa_on_channel_config_change_7
    725                  } // Error: Can't set TX Power
    726                }
    727                // If requested a HIGHEST setting, update it with the real one selected
    728                // to short-circuit the next time through here since HIGHEST never
    729                // matches the real PA returned by RAIL_GetTxPowerConfig(), causing
    730                // reconfiguration of the same PA on every callback.
    731                if (false
    732                   #ifdef  RAIL_TX_POWER_MODE_2P4GIG_HIGHEST
    733                    || (newTxPowerConfigPtr->mode == RAIL_TX_POWER_MODE_2P4GIG_HIGHEST)
    734                   #endif
    735                   #ifdef  RAIL_TX_POWER_MODE_SUBGIG_HIGHEST
    736                    || (newTxPowerConfigPtr->mode == RAIL_TX_POWER_MODE_SUBGIG_HIGHEST)
    737                   #endif
    738                    ) {
   \                     ??sl_rail_util_pa_on_channel_config_change_6: (+1)
   \       0x56   0x7828             LDRB     R0,[R5, #+0]
   \       0x58   0x2804             CMP      R0,#+4
   \       0x5A   0xBF18             IT       NE
   \       0x5C   0x280A             CMPNE    R0,#+10
   \       0x5E   0xD106             BNE.N    ??sl_rail_util_pa_on_channel_config_change_0
    739                  (void) RAIL_GetTxPowerConfig(rail_handle, &currentTxPowerConfig);
   \       0x60   0x4669             MOV      R1,SP
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0x.... 0x....      BL       RAIL_GetTxPowerConfig
    740                  newTxPowerConfigPtr->mode = currentTxPowerConfig.mode;
   \       0x68   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6C   0x7028             STRB     R0,[R5, #+0]
    741                }
    742              }
    743          #endif
    744            } // !RAIL_IsPaAutoModeEnabled
    745          }
   \                     ??sl_rail_util_pa_on_channel_config_change_0: (+1)
   \       0x6E   0xBD73             POP      {R0,R1,R4-R6,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     powerCurvesState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0xFFFF'8000        DC32     0xffff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     RAIL_TxPowerCurvesVbat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     txPowerConfig2p4Ghz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x....'....        DC32     txPowerConfig2p4Ghz+8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x3B9A'CA00        DC32     0x3b9aca00
    746          #endif // !RAIL_PA_CONVERSIONS_WEAK

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   RAIL_ConvertDbmToRaw
      16   RAIL_ConvertRawToDbm
       0   RAIL_GetPowerSettingTable
      16   RAIL_GetTxPowerCurve
        16   -> RAIL_SupportsTxPowerModeAlt
       8   RAIL_GetTxPowerCurveLimits
       0   RAIL_InitTxPowerCurves
       8   RAIL_InitTxPowerCurvesAlt
         8   -> RAIL_VerifyTxPowerCurves
         8   -> __aeabi_memcpy4
       0   sl_rail_util_pa_get_tx_power_config_2p4ghz
       0   sl_rail_util_pa_get_tx_power_config_ofdm
       0   sl_rail_util_pa_get_tx_power_config_subghz
       8   sl_rail_util_pa_init
         0   -> RAIL_EnablePaCal
         8   -> RAIL_InitTxPowerCurvesAlt
      24   sl_rail_util_pa_on_channel_config_change
        24   -> RAIL_ConfigTxPower
        24   -> RAIL_GetTxPowerConfig
        24   -> RAIL_GetTxPowerDbm
        24   -> RAIL_IsPaAutoModeEnabled
        24   -> RAIL_SetTxPowerDbm


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
     230  RAIL_ConvertDbmToRaw
     176  RAIL_ConvertRawToDbm
       4  RAIL_GetPowerSettingTable
      72  RAIL_GetTxPowerCurve
      64  RAIL_GetTxPowerCurveLimits
       4  RAIL_InitTxPowerCurves
      22  RAIL_InitTxPowerCurvesAlt
      56  powerCurvesState
          powerCurves
       4  sl_rail_util_pa_get_tx_power_config_2p4ghz
       4  sl_rail_util_pa_get_tx_power_config_ofdm
       4  sl_rail_util_pa_get_tx_power_config_subghz
      18  sl_rail_util_pa_init
     112  sl_rail_util_pa_on_channel_config_change
      12  supportedPaIndices
      16  txPowerConfig2p4Ghz
          txPowerConfigSubGhz

 
  56 bytes in section .bss
  16 bytes in section .data
 750 bytes in section .text
 
 750 bytes of CODE memory
  72 bytes of DATA memory

Errors: none
Warnings: none
