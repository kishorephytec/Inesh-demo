###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:16:59
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_util.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_util.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_util.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_util.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir\sl_se_manager_util.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_util.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_util.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager_util.h"
     32          
     33          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED) || defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
     34          
     35          #include "sli_se_manager_internal.h"
     36          #include "em_se.h"
     37          #include "sl_assert.h"
     38          
     39          #if defined(SLI_SE_MAJOR_VERSION_ONE)
     40            #include "em_system.h"
     41          #endif
     42          
     43          /// @addtogroup sl_se_manager
     44          /// @{
     45          
     46          // -----------------------------------------------------------------------------
     47          // Defines
     48          
     49          // OTP initialization structure defines.
     50          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE (1 << 16)
     51          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE (1 << 17)
     52          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK (1 << 18)
     53          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW (1 << 19)
     54          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL (1 << 20)
     55          
     56          // -----------------------------------------------------------------------------
     57          // Local Functions
     58          
     59          /***************************************************************************//**
     60           * @brief
     61           *   Decode debug status word (as received from the SE).
     62           *
     63           * @return N/A
     64           ******************************************************************************/
     65          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   \                                 In section .text, align 2, keep-with-next
     66          static void decode_debug_status(sl_se_debug_status_t *debug_status,
     67                                          uint32_t status_word)
     68          {
     69            debug_status->debug_port_lock_applied = status_word & (1 << 0);
   \                     decode_debug_status: (+1)
   \        0x0   0xF001 0x0201      AND      R2,R1,#0x1
     70            debug_status->device_erase_enabled = status_word & (1 << 1);
   \        0x4   0x084B             LSRS     R3,R1,#+1
   \        0x6   0x7082             STRB     R2,[R0, #+2]
   \        0x8   0xF003 0x0301      AND      R3,R3,#0x1
     71            debug_status->secure_debug_enabled = status_word & (1 << 2);
   \        0xC   0x088A             LSRS     R2,R1,#+2
   \        0xE   0x7003             STRB     R3,[R0, #+0]
   \       0x10   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x14   0x7042             STRB     R2,[R0, #+1]
     72            debug_status->debug_port_lock_state = status_word & (1 << 5);
     73            debug_status->options_state.non_secure_invasive_debug =
     74              (status_word & (1 << 6)) == 0;
   \       0x16   0x098A             LSRS     R2,R1,#+6
   \       0x18   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x1C   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x20   0x7202             STRB     R2,[R0, #+8]
     75            debug_status->options_state.non_secure_non_invasive_debug =
     76              (status_word & (1 << 7)) == 0;
   \       0x22   0x09CA             LSRS     R2,R1,#+7
   \       0x24   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x28   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x2C   0x7242             STRB     R2,[R0, #+9]
     77            debug_status->options_state.secure_invasive_debug =
     78              (status_word & (1 << 8)) == 0;
   \       0x2E   0x0A0A             LSRS     R2,R1,#+8
   \       0x30   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x34   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x38   0x7282             STRB     R2,[R0, #+10]
     79            debug_status->options_state.secure_non_invasive_debug =
     80              (status_word & (1 << 9)) == 0;
   \       0x3A   0x0A4A             LSRS     R2,R1,#+9
   \       0x3C   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x40   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x44   0x72C2             STRB     R2,[R0, #+11]
     81            debug_status->options_config.non_secure_invasive_debug =
     82              (status_word & (1 << 10)) == 0;
   \       0x46   0x0A8A             LSRS     R2,R1,#+10
   \       0x48   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x4C   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x50   0x7102             STRB     R2,[R0, #+4]
     83            debug_status->options_config.non_secure_non_invasive_debug =
     84              (status_word & (1 << 11)) == 0;
   \       0x52   0x0ACA             LSRS     R2,R1,#+11
   \       0x54   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x58   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x5C   0x7142             STRB     R2,[R0, #+5]
     85            debug_status->options_config.secure_invasive_debug =
     86              (status_word & (1 << 12)) == 0;
   \       0x5E   0x0B0A             LSRS     R2,R1,#+12
   \       0x60   0x094B             LSRS     R3,R1,#+5
     87            debug_status->options_config.secure_non_invasive_debug =
     88              (status_word & (1 << 13)) == 0;
   \       0x62   0x0B49             LSRS     R1,R1,#+13
   \       0x64   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x68   0xF001 0x0101      AND      R1,R1,#0x1
   \       0x6C   0xF003 0x0301      AND      R3,R3,#0x1
   \       0x70   0xF082 0x0201      EOR      R2,R2,#0x1
   \       0x74   0xF081 0x0101      EOR      R1,R1,#0x1
   \       0x78   0x70C3             STRB     R3,[R0, #+3]
   \       0x7A   0x7182             STRB     R2,[R0, #+6]
   \       0x7C   0x71C1             STRB     R1,[R0, #+7]
     89          }
   \       0x7E   0x4770             BX       LR
     90          #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
     91          static void decode_debug_status(sl_se_debug_status_t *debug_status,
     92                                          uint32_t status_word)
     93          {
     94            debug_status->debug_port_lock_applied = status_word & (1 << 10);
     95            debug_status->device_erase_enabled = status_word & (1 << 11);
     96            debug_status->secure_debug_enabled = status_word & (1 << 12);
     97            debug_status->debug_port_lock_state = status_word & (1 << 15);
     98          }
     99          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    100          
    101          // -----------------------------------------------------------------------------
    102          // Global Functions
    103          
    104          /***************************************************************************//**
    105           * Validate SE firmware image.
    106           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          sl_status_t sl_se_check_se_image(sl_se_command_context_t *cmd_ctx,
    108                                           void *image_addr)
    109          {
   \                     sl_se_check_se_image: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    110            if (cmd_ctx == NULL || image_addr == NULL) {
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD101             BNE.N    ??sl_se_check_se_image_0
    111              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0xBD10             POP      {R4,PC}
    112            }
    113          
    114            SE_Command_t *se_cmd = &cmd_ctx->command;
    115            // SE command structures
    116            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHECK_SE_IMAGE);
   \                     ??sl_se_check_se_image_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R3,??DataTable53
   \       0x12   0x....             B.N      ?Subroutine1
    117          
    118            SE_addParameter(se_cmd, (uint32_t)image_addr);
    119          
    120            return sli_se_execute_and_wait(cmd_ctx);
    121          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      BL       ?Subroutine6
   \                     ??Subroutine1_0: (+1)
   \        0x4   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_32: (+1)
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6023             STR      R3,[R4, #+0]
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6060             STR      R0,[R4, #+4]
   \        0x6   0x60A0             STR      R0,[R4, #+8]
   \        0x8   0x61E0             STR      R0,[R4, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4631             MOV      R1,R6
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addParameter
    122          
    123          /***************************************************************************//**
    124           * Apply SE firmware image.
    125           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          sl_status_t sl_se_apply_se_image(sl_se_command_context_t *cmd_ctx,
    127                                           void *image_addr)
    128          {
   \                     sl_se_apply_se_image: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    129            if (cmd_ctx == NULL || image_addr == NULL) {
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD101             BNE.N    ??sl_se_apply_se_image_0
    130              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0xBD10             POP      {R4,PC}
    131            }
    132          
    133            SE_Command_t *se_cmd = &cmd_ctx->command;
    134            // SE command structures
    135            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_APPLY_SE_IMAGE);
   \                     ??sl_se_apply_se_image_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R3,??DataTable53_1
   \       0x12                      REQUIRE ?Subroutine1
   \       0x12                      ;; // Fall through to label ?Subroutine1
    136          
    137            SE_addParameter(se_cmd, (uint32_t)image_addr);
    138          
    139            return sli_se_execute_and_wait(cmd_ctx);
    140          }
    141          
    142          /***************************************************************************//**
    143           * Get upgrade status of SE firmware image.
    144           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    145          sl_status_t sl_se_get_upgrade_status_se_image(sl_se_command_context_t *cmd_ctx,
    146                                                        uint32_t *status,
    147                                                        uint32_t *prev_version)
    148          {
   \                     sl_se_get_upgrade_status_se_image: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
    149            if (cmd_ctx == NULL || status == NULL || prev_version == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2C00             CMPNE    R4,#+0
   \        0xE   0xD000             BEQ.N    ??sl_se_get_upgrade_status_se_image_0
   \       0x10   0xB90D             CBNZ.N   R5,??sl_se_get_upgrade_status_se_image_1
    150              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_upgrade_status_se_image_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE014             B.N      ??CrossCallReturnLabel_23
    151            }
    152          
    153            SE_Command_t *se_cmd = &cmd_ctx->command;
    154            // SE command structures
    155            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_SE_IMAGE);
   \                     ??sl_se_get_upgrade_status_se_image_1: (+1)
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable53_2
   \       0x1A   0x6032             STR      R2,[R6, #+0]
   \       0x1C   0x2100             MOVS     R1,#+0
    156          
    157            volatile uint32_t out_buf[2];
    158            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(out_buf,
    159                                                                 sizeof(out_buf));
   \       0x1E   0x.... 0x....      ADR.W    R0,?_0
   \       0x22   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x26   0x46EE             MOV      LR,SP
   \       0x28   0xE881 0x008C      STM      R1,{R2,R3,R7}
   \       0x2C   0xF8CD 0xE008      STR      LR,[SP, #+8]
    160            SE_addDataOutput(se_cmd, &out_data);
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x.... 0x....      BL       SE_addDataOutput
    161          
    162            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x.... 0x....      BL       sli_se_execute_and_wait
    163          
    164            if (ret == SL_STATUS_OK) {
   \       0x3C   0x.... 0x....      BL       ?Subroutine11
    165              *status = out_buf[0];
    166              *prev_version = out_buf[1];
    167            }
    168          
    169            return ret;
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x40   0xB005             ADD      SP,SP,#+20
   \       0x42   0xBDF0             POP      {R4-R7,PC}
    170          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0xB918             CBNZ.N   R0,??Subroutine11_0
   \        0x2   0x9900             LDR      R1,[SP, #+0]
   \        0x4   0x6021             STR      R1,[R4, #+0]
   \        0x6   0x9A01             LDR      R2,[SP, #+4]
   \        0x8   0x602A             STR      R2,[R5, #+0]
   \                     ??Subroutine11_0: (+1)
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x6071             STR      R1,[R6, #+4]
   \        0x2   0x60B1             STR      R1,[R6, #+8]
   \        0x4   0x61F1             STR      R1,[R6, #+28]
   \        0x6   0xE890 0x008C      LDM      R0,{R2,R3,R7}
   \        0xA   0xA902             ADD      R1,SP,#+8
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'920
   \              0x0000'0001  
   \              0x2000'0008
    171          
    172          /***************************************************************************//**
    173           * Validate Host firmware image.
    174           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    175          sl_status_t sl_se_check_host_image(sl_se_command_context_t *cmd_ctx,
    176                                             void *image_addr,
    177                                             uint32_t size)
    178          {
   \                     sl_se_check_host_image: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x4615             MOV      R5,R2
    179            if (cmd_ctx == NULL || image_addr == NULL || size == 0UL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2900             CMPNE    R1,#+0
   \        0xA   0xD000             BEQ.N    ??sl_se_check_host_image_0
   \        0xC   0xB90D             CBNZ.N   R5,??sl_se_check_host_image_1
    180              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_check_host_image_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
    181            }
    182          
    183            SE_Command_t *se_cmd = &cmd_ctx->command;
    184            // SE command structures
    185            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHECK_HOST_IMAGE);
   \                     ??sl_se_check_host_image_1: (+1)
   \       0x12   0x.... 0x....      LDR.W    R3,??DataTable53_3
   \       0x16   0x....             B.N      ?Subroutine0
    186          
    187            SE_addParameter(se_cmd, (uint32_t)image_addr);
    188            SE_addParameter(se_cmd, size);
    189          
    190            return sli_se_execute_and_wait(cmd_ctx);
    191          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0x4   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_31: (+1)
   \        0x8   0x4629             MOV      R1,R5
   \        0xA                      REQUIRE ??Subroutine13_0
   \        0xA                      ;; // Fall through to label ??Subroutine13_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \        0x0   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_30: (+1)
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \        0xA   0x.... 0x....      B.W      sli_se_execute_and_wait
    192          
    193          /***************************************************************************//**
    194           * Apply Host firmware image.
    195           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    196          sl_status_t sl_se_apply_host_image(sl_se_command_context_t *cmd_ctx,
    197                                             void *image_addr,
    198                                             uint32_t size)
    199          {
   \                     sl_se_apply_host_image: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x4615             MOV      R5,R2
    200            if (cmd_ctx == NULL || image_addr == NULL || size == 0UL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2900             CMPNE    R1,#+0
   \        0xA   0xD000             BEQ.N    ??sl_se_apply_host_image_0
   \        0xC   0xB90D             CBNZ.N   R5,??sl_se_apply_host_image_1
    201              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_apply_host_image_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
    202            }
    203          
    204            SE_Command_t *se_cmd = &cmd_ctx->command;
    205            // SE command structures
    206            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_APPLY_HOST_IMAGE);
   \                     ??sl_se_apply_host_image_1: (+1)
   \       0x12   0x.... 0x....      LDR.W    R3,??DataTable53_4
   \       0x16                      REQUIRE ?Subroutine0
   \       0x16                      ;; // Fall through to label ?Subroutine0
    207          
    208            SE_addParameter(se_cmd, (uint32_t)image_addr);
    209            SE_addParameter(se_cmd, size);
    210          
    211            return sli_se_execute_and_wait(cmd_ctx);
    212          }
    213          
    214          /***************************************************************************//**
    215           * Get upgrade status of Host firmware image.
    216           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    217          sl_status_t
    218          sl_se_get_upgrade_status_host_image(sl_se_command_context_t *cmd_ctx,
    219                                              uint32_t *status,
    220                                              uint32_t *prev_version)
    221          {
   \                     sl_se_get_upgrade_status_host_image: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
    222            if (cmd_ctx == NULL || status == NULL || prev_version == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2C00             CMPNE    R4,#+0
   \        0xE   0xD000             BEQ.N    ??sl_se_get_upgrade_status_host_image_0
   \       0x10   0xB90D             CBNZ.N   R5,??sl_se_get_upgrade_status_host_image_1
    223              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_upgrade_status_host_image_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE014             B.N      ??CrossCallReturnLabel_24
    224            }
    225          
    226            SE_Command_t *se_cmd = &cmd_ctx->command;
    227            // SE command structures
    228            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_HOST_IMAGE);
   \                     ??sl_se_get_upgrade_status_host_image_1: (+1)
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable53_5
   \       0x1A   0x6032             STR      R2,[R6, #+0]
   \       0x1C   0x2100             MOVS     R1,#+0
    229          
    230            volatile uint32_t out_buf[2];
    231            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(out_buf,
    232                                                                 sizeof(out_buf));
   \       0x1E   0x.... 0x....      ADR.W    R0,?_1
   \       0x22   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x26   0x46EE             MOV      LR,SP
   \       0x28   0xE881 0x008C      STM      R1,{R2,R3,R7}
   \       0x2C   0xF8CD 0xE008      STR      LR,[SP, #+8]
    233            SE_addDataOutput(se_cmd, &out_data);
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x.... 0x....      BL       SE_addDataOutput
    234          
    235            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x.... 0x....      BL       sli_se_execute_and_wait
    236          
    237            if (ret == SL_STATUS_OK) {
   \       0x3C   0x.... 0x....      BL       ?Subroutine11
    238              *status = out_buf[0];
    239              *prev_version = out_buf[1];
    240            }
    241          
    242            return ret;
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x40   0xB005             ADD      SP,SP,#+20
   \       0x42   0xBDF0             POP      {R4-R7,PC}
    243          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'920
   \              0x0000'0001  
   \              0x2000'0008
    244          
    245          /***************************************************************************//**
    246           * Initialize key to be stored in the SE OTP flash.
    247           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    248          sl_status_t sl_se_init_otp_key(sl_se_command_context_t *cmd_ctx,
    249                                         sl_se_device_key_type_t key_type,
    250                                         void *key,
    251                                         uint32_t num_bytes)
    252          {
   \                     sl_se_init_otp_key: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461E             MOV      R6,R3
    253            if (cmd_ctx == NULL || key == NULL || num_bytes == 0UL || (size_t)key & 3U) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2D00             CMPNE    R5,#+0
   \        0xE   0xD01A             BEQ.N    ??sl_se_init_otp_key_0
   \       0x10   0xB1CE             CBZ.N    R6,??sl_se_init_otp_key_0
   \       0x12   0xF015 0x0003      ANDS     R0,R5,#0x3
   \       0x16   0xD116             BNE.N    ??sl_se_init_otp_key_0
    254              return SL_STATUS_INVALID_PARAMETER;
    255            }
    256          
    257            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    258            if (key_type == SL_SE_KEY_TYPE_IMMUTABLE_AES_128) {
   \       0x18   0x2902             CMP      R1,#+2
   \       0x1A   0xD104             BNE.N    ??sl_se_init_otp_key_1
    259              if (num_bytes != 16UL) {
   \       0x1C   0x2E10             CMP      R6,#+16
   \       0x1E   0xD112             BNE.N    ??sl_se_init_otp_key_0
    260                return SL_STATUS_INVALID_PARAMETER;
    261              }
    262            } else {
    263              if (num_bytes != 64UL) {
    264                return SL_STATUS_INVALID_PARAMETER;
    265              }
    266            }
    267            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    268            if (num_bytes != 64UL) {
    269              return SL_STATUS_INVALID_PARAMETER;
    270            }
    271            #endif
    272          
    273            uint32_t command_word;
    274            SE_Command_t *se_cmd = &cmd_ctx->command;
    275          
    276            uint32_t se_key_type;
    277            switch (key_type) {
    278              case SL_SE_KEY_TYPE_IMMUTABLE_BOOT:
    279                se_key_type = SLI_SE_KEY_TYPE_BOOT;
    280                break;
    281          
    282              case SL_SE_KEY_TYPE_IMMUTABLE_AUTH:
    283                se_key_type = SLI_SE_KEY_TYPE_AUTH;
    284                break;
    285          
    286              #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    287              case SL_SE_KEY_TYPE_IMMUTABLE_AES_128:
    288                se_key_type = SLI_SE_IMMUTABLE_KEY_TYPE_AES_128;
   \                     ??sl_se_init_otp_key_2: (+1)
   \       0x20   0xF44F 0x60A0      MOV      R0,#+1280
    289                break;
   \       0x24   0xE009             B.N      ??sl_se_init_otp_key_3
   \                     ??sl_se_init_otp_key_1: (+1)
   \       0x26   0x2E40             CMP      R6,#+64
   \       0x28   0xD10D             BNE.N    ??sl_se_init_otp_key_0
   \       0x2A   0x0008             MOVS     R0,R1
   \       0x2C   0xD003             BEQ.N    ??sl_se_init_otp_key_4
   \       0x2E   0x2902             CMP      R1,#+2
   \       0x30   0xD0F6             BEQ.N    ??sl_se_init_otp_key_2
   \       0x32   0xD305             BCC.N    ??sl_se_init_otp_key_5
   \       0x34   0xE007             B.N      ??sl_se_init_otp_key_0
   \                     ??sl_se_init_otp_key_4: (+1)
   \       0x36   0xF44F 0x7080      MOV      R0,#+256
    290              #endif // SLI_MAILBOX_COMMAND_SUPPORTED
    291          
    292              default:
    293                return SL_STATUS_INVALID_PARAMETER;
    294                break;
    295            }
    296          
    297            // Find parity word
    298            volatile uint32_t parity = 0;
   \                     ??sl_se_init_otp_key_3: (+1)
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x9200             STR      R2,[SP, #+0]
    299            for (size_t i = 0; i < num_bytes / 4; i++) {
   \       0x3E   0xE00A             B.N      ??sl_se_init_otp_key_6
   \                     ??sl_se_init_otp_key_5: (+1)
   \       0x40   0xF44F 0x7000      MOV      R0,#+512
   \       0x44   0xE7F9             B.N      ??sl_se_init_otp_key_3
   \                     ??sl_se_init_otp_key_0: (+1)
   \       0x46   0x2021             MOVS     R0,#+33
   \       0x48   0xE032             B.N      ??CrossCallReturnLabel_22
    300              parity = parity ^ ((uint32_t *)key)[i];
   \                     ??sl_se_init_otp_key_7: (+1)
   \       0x4A   0x9F00             LDR      R7,[SP, #+0]
   \       0x4C   0xF855 0x3022      LDR      R3,[R5, R2, LSL #+2]
    301            }
   \       0x50   0x1C52             ADDS     R2,R2,#+1
   \       0x52   0x405F             EORS     R7,R3,R7
   \       0x54   0x9700             STR      R7,[SP, #+0]
   \                     ??sl_se_init_otp_key_6: (+1)
   \       0x56   0xEBB2 0x0F96      CMP      R2,R6, LSR #+2
   \       0x5A   0xD3F6             BCC.N    ??sl_se_init_otp_key_7
    302          
    303            // SE command structures
    304            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    305            command_word = key_type == SL_SE_KEY_TYPE_IMMUTABLE_AES_128
    306                           ? SLI_SE_COMMAND_INIT_AES_128_KEY : SLI_SE_COMMAND_INIT_PUBKEY;
   \       0x5C   0x2902             CMP      R1,#+2
   \       0x5E   0xBF0C             ITE      EQ
   \       0x60   0x.... 0x....      LDREQ.W  R1,??DataTable53_6
   \       0x64   0x.... 0x....      LDRNE.W  R1,??DataTable53_7
    307            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    308            command_word = SLI_SE_COMMAND_INIT_PUBKEY;
    309            #endif
    310          
    311            sli_se_command_init(cmd_ctx, (command_word | se_key_type));
   \       0x68   0x4308             ORRS     R0,R0,R1
   \       0x6A   0x6020             STR      R0,[R4, #+0]
   \       0x6C   0x2100             MOVS     R1,#+0
    312          
    313            SE_DataTransfer_t parity_data = SE_DATATRANSFER_DEFAULT(&parity, 4);
   \       0x6E   0x.... 0x....      ADR.W    R0,?_2
   \       0x72   0x6061             STR      R1,[R4, #+4]
   \       0x74   0x60A1             STR      R1,[R4, #+8]
   \       0x76   0x61E1             STR      R1,[R4, #+28]
   \       0x78   0xE890 0x008C      LDM      R0,{R2,R3,R7}
   \       0x7C   0xA904             ADD      R1,SP,#+16
   \       0x7E   0x46EE             MOV      LR,SP
   \       0x80   0xE881 0x008C      STM      R1,{R2,R3,R7}
   \       0x84   0xF8CD 0xE010      STR      LR,[SP, #+16]
    314            SE_addDataInput(se_cmd, &parity_data);
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0x.... 0x....      BL       SE_addDataInput
    315          
    316            SE_DataTransfer_t key_data = SE_DATATRANSFER_DEFAULT(key, num_bytes);
   \       0x8E   0x.... 0x....      ADR.W    R0,?_3
   \       0x92   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x96   0xAF01             ADD      R7,SP,#+4
   \       0x98   0xF046 0x5600      ORR      R6,R6,#0x20000000
   \       0x9C   0xE887 0x000E      STM      R7,{R1-R3}
   \       0xA0   0x9501             STR      R5,[SP, #+4]
   \       0xA2   0x9603             STR      R6,[SP, #+12]
    317            SE_addDataInput(se_cmd, &key_data);
   \       0xA4   0xA901             ADD      R1,SP,#+4
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x.... 0x....      BL       SE_addDataInput
    318          
    319            return sli_se_execute_and_wait(cmd_ctx);
   \       0xAC   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0xB0   0xB007             ADD      SP,SP,#+28
   \       0xB2   0xBDF0             POP      {R4-R7,PC}
    320          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    321          
    322          /***************************************************************************//**
    323           * Read a public key stored in the SE.
    324           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    325          sl_status_t sl_se_read_pubkey(sl_se_command_context_t *cmd_ctx,
    326                                        sl_se_device_key_type_t key_type,
    327                                        void *key,
    328                                        uint32_t num_bytes)
    329          {
   \                     sl_se_read_pubkey: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    330            if (cmd_ctx == NULL || key == NULL || num_bytes != 64UL || (size_t)key & 3U) {
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2A00             CMPNE    R2,#+0
   \        0x8   0xD026             BEQ.N    ??sl_se_read_pubkey_1
   \        0xA   0x2B40             CMP      R3,#+64
   \        0xC   0xBF08             IT       EQ
   \        0xE   0xF012 0x0003      ANDSEQ   R0,R2,#0x3
   \       0x12   0xD121             BNE.N    ??sl_se_read_pubkey_1
    331              return SL_STATUS_INVALID_PARAMETER;
    332            }
    333          
    334            SE_Command_t *se_cmd = &cmd_ctx->command;
    335            uint32_t se_key_type;
    336            uint32_t command_word = SLI_SE_COMMAND_READ_PUBKEY;
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable53_8
    337            switch (key_type) {
   \       0x18   0x2904             CMP      R1,#+4
   \       0x1A   0xD81D             BHI.N    ??sl_se_read_pubkey_1
   \       0x1C   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??sl_se_read_pubkey_0:
   \       0x20   0x03 0x14          DC8      0x3,0x14,0x1C,0x19
   \              0x1C 0x19
   \       0x24   0x17 0x00          DC8      0x17,0x0
    338              case SL_SE_KEY_TYPE_IMMUTABLE_BOOT:
    339                se_key_type = SLI_SE_KEY_TYPE_BOOT;
   \                     ??sl_se_read_pubkey_2: (+1)
   \       0x26   0xF44F 0x7180      MOV      R1,#+256
    340                break;
    341          
    342              case SL_SE_KEY_TYPE_IMMUTABLE_AUTH:
    343                se_key_type = SLI_SE_KEY_TYPE_AUTH;
    344                break;
    345              #if defined(SLI_MAILBOX_COMMAND_SUPPORTED) && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    346              case SL_SE_KEY_TYPE_IMMUTABLE_SE_ATTESTATION:
    347                command_word = command_word & ~0x1;
    348              // Intentional fallthrough
    349              case SL_SE_KEY_TYPE_IMMUTABLE_ATTESTATION:
    350                se_key_type = SLI_SE_KEY_TYPE_ATTEST;
    351                break;
    352              #endif // _SILICON_LABS_SECURITY_FEATURE_VAULT
    353          
    354              default:
    355                return SL_STATUS_INVALID_PARAMETER;
    356                break;
    357            }
    358          
    359            // SE command structures
    360            sli_se_command_init(cmd_ctx, command_word | se_key_type);
   \                     ??sl_se_read_pubkey_3: (+1)
   \       0x2A   0x4308             ORRS     R0,R1,R0
   \       0x2C   0x.... 0x....      BL       ?Subroutine12
    361          
    362            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(key, num_bytes);
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x30   0x.... 0x....      ADR.W    R0,?_4
   \       0x34   0xE890 0x002A      LDM      R0,{R1,R3,R5}
   \       0x38   0x466E             MOV      R6,SP
   \       0x3A   0x.... 0x....      LDR.W    R7,??DataTable53_9
   \       0x3E   0xE886 0x002A      STM      R6,{R1,R3,R5}
   \       0x42   0x9200             STR      R2,[SP, #+0]
   \       0x44   0x9702             STR      R7,[SP, #+8]
    363            SE_addDataOutput(se_cmd, &out_data);
   \       0x46   0x....             B.N      ?Subroutine3
   \                     ??sl_se_read_pubkey_4: (+1)
   \       0x48   0xF44F 0x7100      MOV      R1,#+512
   \       0x4C   0xE7ED             B.N      ??sl_se_read_pubkey_3
   \                     ??sl_se_read_pubkey_5: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable53_10
   \                     ??sl_se_read_pubkey_6: (+1)
   \       0x52   0xF44F 0x6180      MOV      R1,#+1024
   \       0x56   0xE7E8             B.N      ??sl_se_read_pubkey_3
   \                     ??sl_se_read_pubkey_1: (+1)
   \       0x58   0x2021             MOVS     R0,#+33
   \       0x5A   0xBDFE             POP      {R1-R7,PC}
    364          
    365            return sli_se_execute_and_wait(cmd_ctx);
    366          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      BL       SE_addDataOutput
   \        0x8                      REQUIRE ??Subroutine14_0
   \        0x8                      ;; // Fall through to label ??Subroutine14_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine14_0: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x.... 0x....      BL       sli_se_execute_and_wait
   \        0x6   0xBDFE             POP      {R1-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x6020             STR      R0,[R4, #+0]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6061             STR      R1,[R4, #+4]
   \        0x6   0x60A1             STR      R1,[R4, #+8]
   \        0x8   0x61E1             STR      R1,[R4, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    367          
    368          /***************************************************************************//**
    369           * Read the SE firmware version.
    370           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          sl_status_t sl_se_get_se_version(sl_se_command_context_t *cmd_ctx,
    372                                           uint32_t *version)
    373          {
   \                     sl_se_get_se_version: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    374            if (cmd_ctx == NULL || version == NULL) {
   \        0x4   0xBF14             ITE      NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0x2021             MOVEQ    R0,#+33
    375              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0xD009             BEQ.N    ??CrossCallReturnLabel_21
    376            }
    377          
    378            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    379          
    380            // SE command structures
    381            SE_Command_t *se_cmd = &cmd_ctx->command;
    382            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_SE_VERSION);
   \        0xC   0x.... 0x....      LDR.W    R3,??DataTable53_11
   \       0x10   0x.... 0x....      BL       ?Subroutine5
    383            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(version, sizeof(uint32_t));
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x14   0x.... 0x....      ADR.W    R0,?_5
   \       0x18   0x.... 0x....      BL       ?Subroutine9
    384          
    385            SE_addDataOutput(se_cmd, &out_data);
    386          
    387            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x1C   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x20   0xB004             ADD      SP,SP,#+16
   \       0x22   0xBD70             POP      {R4-R6,PC}
    388          
    389            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    390          
    391            sl_status_t status = SL_STATUS_OK;
    392            SE_Response_t command_response;
    393          
    394            // Try to acquire SE lock.
    395            // Need to protect VSE mailbox from being written by e.g. SE_ackCommand()
    396            status = sli_se_lock_acquire();
    397            if (status != SL_STATUS_OK) {
    398              return status;
    399            }
    400          
    401            // Read SE version from VSE mailbox.
    402            command_response = SE_getVersion(version);
    403          
    404            // Release SE lock
    405            status = sli_se_lock_release();
    406          
    407            // Return sl_status_t code.
    408            if (command_response == SLI_SE_RESPONSE_OK) {
    409              return status;
    410            } else {
    411              // Convert from SE_Response_t to sl_status_t code and return.
    412              return sli_se_to_sl_status(command_response);
    413            }
    414          
    415            #endif
    416          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x6023             STR      R3,[R4, #+0]
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x6062             STR      R2,[R4, #+4]
   \        0x6   0x60A2             STR      R2,[R4, #+8]
   \        0x8   0x61E2             STR      R2,[R4, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0xE890 0x002C      LDM      R0,{R2,R3,R5}
   \        0x4   0x466E             MOV      R6,SP
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0xE886 0x002C      STM      R6,{R2,R3,R5}
   \        0xC   0x9100             STR      R1,[SP, #+0]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
    417          
    418          /***************************************************************************//**
    419           * Enables the debug lock for the part.
    420           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          sl_status_t sl_se_apply_debug_lock(sl_se_command_context_t *cmd_ctx)
    422          {
    423            if (cmd_ctx == NULL) {
   \                     sl_se_apply_debug_lock: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_apply_debug_lock_0
    424              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
    425            }
    426          
    427            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_APPLY);
   \                     ??sl_se_apply_debug_lock_0: (+1)
   \        0x6   0x.... 0x....      LDR.W    R3,??DataTable53_12
   \        0xA   0x....             B.N      ?Subroutine2
    428          
    429            return sli_se_execute_and_wait(cmd_ctx);
    430          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6003             STR      R3,[R0, #+0]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6041             STR      R1,[R0, #+4]
   \        0x6   0x6081             STR      R1,[R0, #+8]
   \        0x8   0x61C1             STR      R1,[R0, #+28]
   \        0xA   0x.... 0x....      B.W      sli_se_execute_and_wait
    431          
    432          /***************************************************************************//**
    433           * Returns the current debug lock configuration.
    434           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    435          sl_status_t sl_se_get_debug_lock_status(sl_se_command_context_t *cmd_ctx,
    436                                                  sl_se_debug_status_t *debug_status)
    437          {
   \                     sl_se_get_debug_lock_status: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x460C             MOV      R4,R1
    438            if (cmd_ctx == NULL || debug_status == NULL) {
   \        0x8   0xBF14             ITE      NE
   \        0xA   0x2C00             CMPNE    R4,#+0
   \        0xC   0x2021             MOVEQ    R0,#+33
    439              return SL_STATUS_INVALID_PARAMETER;
   \        0xE   0xD01F             BEQ.N    ??sl_se_get_debug_lock_status_0
    440            }
    441            #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    442            SE_Command_t *se_cmd = &cmd_ctx->command;
    443            volatile uint32_t status_word = 0;
   \       0x10   0x2700             MOVS     R7,#+0
   \       0x12   0x9700             STR      R7,[SP, #+0]
    444            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(&status_word, 4);
   \       0x14   0x.... 0x....      ADR.W    R0,?_6
   \       0x18   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x1C   0xAE01             ADD      R6,SP,#+4
   \       0x1E   0x466F             MOV      R7,SP
   \       0x20   0xE886 0x000E      STM      R6,{R1-R3}
   \       0x24   0x9701             STR      R7,[SP, #+4]
    445          
    446            // Initialize SE command structures
    447            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_STATUS);
   \       0x26   0x.... 0x....      LDR.W    R6,??DataTable53_13
   \       0x2A   0x602E             STR      R6,[R5, #+0]
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6068             STR      R0,[R5, #+4]
   \       0x30   0x60A8             STR      R0,[R5, #+8]
   \       0x32   0x61E8             STR      R0,[R5, #+28]
    448            SE_addDataOutput(se_cmd, &out_data);
   \       0x34   0xA901             ADD      R1,SP,#+4
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       SE_addDataOutput
    449          
    450            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       sli_se_execute_and_wait
   \       0x42   0x0005             MOVS     R5,R0
    451          
    452            if (ret == SL_STATUS_OK) {
   \       0x44   0xD103             BNE.N    ??sl_se_get_debug_lock_status_1
    453              decode_debug_status(debug_status, status_word);
   \       0x46   0x9900             LDR      R1,[SP, #+0]
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x.... 0x....      BL       decode_debug_status
    454            }
    455          
    456            return ret;
   \                     ??sl_se_get_debug_lock_status_1: (+1)
   \       0x4E   0x4628             MOV      R0,R5
   \                     ??sl_se_get_debug_lock_status_0: (+1)
   \       0x50   0xB005             ADD      SP,SP,#+20
   \       0x52   0xBDF0             POP      {R4-R7,PC}
    457            #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    458            uint32_t vse_version = 0;
    459            uint32_t debug_lock_flags = 0;
    460          
    461            // Try to acquire SE lock
    462            sl_status_t status = sli_se_lock_acquire();
    463            if (status != SL_STATUS_OK) {
    464              return status;
    465            }
    466          
    467            // Read SE version from VSE mailbox.
    468            SE_Response_t vse_mbx_status = SE_getVersion(&vse_version);
    469          
    470            // Reading debug lock status is not supported on VSE with versions <= 1.2.2.
    471            if ((vse_version <= 0x1010202UL) || (vse_mbx_status != SE_RESPONSE_OK)) {
    472              sli_se_lock_release();
    473              return SL_STATUS_COMMAND_IS_INVALID;
    474            }
    475          
    476            vse_mbx_status = SE_getConfigStatusBits(&debug_lock_flags);
    477            // Release SE lock
    478            status = sli_se_lock_release();
    479          
    480            if (vse_mbx_status != SE_RESPONSE_OK) {
    481              return sli_se_to_sl_status(vse_mbx_status);
    482            } else if (status != SL_STATUS_OK) {
    483              return status;
    484            }
    485          
    486            decode_debug_status(debug_status, debug_lock_flags);
    487          
    488            return SL_STATUS_OK;
    489            #endif
    490          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
    491          
    492          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    493          
    494          /***************************************************************************//**
    495           * Initialize SE OTP configuration.
    496           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    497          sl_status_t sl_se_init_otp(sl_se_command_context_t *cmd_ctx,
    498                                     sl_se_otp_init_t *otp_init)
    499          {
   \                     sl_se_init_otp: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB09C             SUB      SP,SP,#+112
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460D             MOV      R5,R1
    500            if (cmd_ctx == NULL || otp_init == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2D00             CMPNE    R5,#+0
   \        0xE   0xF000 0x80B0      BEQ.W    ??sl_se_init_otp_0
    501              return SL_STATUS_INVALID_PARAMETER;
    502            }
    503          
    504            SE_Command_t *se_cmd = &cmd_ctx->command;
    505            uint32_t mcu_settings_flags = 0;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x9100             STR      R1,[SP, #+0]
    506          
    507            sl_status_t status;
    508          
    509            if (otp_init->enable_secure_boot) {
   \       0x16   0x7828             LDRB     R0,[R5, #+0]
   \       0x18   0xB158             CBZ.N    R0,??sl_se_init_otp_1
    510              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE;
   \       0x1A   0xF44F 0x3180      MOV      R1,#+65536
   \       0x1E   0x9100             STR      R1,[SP, #+0]
    511          
    512              // Check for installed boot pubkey before OTP initialization
    513              uint8_t pubkey[64];
    514              status =
    515                sl_se_read_pubkey(cmd_ctx, SL_SE_KEY_TYPE_IMMUTABLE_BOOT, &pubkey, 64);
    516              if (status != SL_STATUS_OK) {
   \       0x20   0x2340             MOVS     R3,#+64
   \       0x22   0xAA0C             ADD      R2,SP,#+48
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       sl_se_read_pubkey
   \       0x2C   0xB108             CBZ.N    R0,??sl_se_init_otp_1
    517                return SL_STATUS_ABORT;
   \       0x2E   0x2006             MOVS     R0,#+6
   \       0x30   0xE09C             B.N      ??CrossCallReturnLabel_20
    518              }
    519            }
    520            if (otp_init->verify_secure_boot_certificate) {
   \                     ??sl_se_init_otp_1: (+1)
   \       0x32   0x7868             LDRB     R0,[R5, #+1]
   \       0x34   0xB118             CBZ.N    R0,??sl_se_init_otp_2
    521              mcu_settings_flags |=
    522                SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE;
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0xF440 0x3000      ORR      R0,R0,#0x20000
   \       0x3C   0x9000             STR      R0,[SP, #+0]
    523            }
    524            if (otp_init->enable_anti_rollback) {
   \                     ??sl_se_init_otp_2: (+1)
   \       0x3E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x40   0xB118             CBZ.N    R0,??sl_se_init_otp_3
    525              // Verify firmware compatibility before enabling anti-rollback
    526              #if defined(SLI_SE_MAJOR_VERSION_ONE)
    527              uint16_t part_number = SYSTEM_GetPartNumber();
    528              if (part_number == 1010 || part_number == 1020) {
    529                if (SYSTEM_GetProdRev() < 16) {
    530                  sl_se_status_t se_status;
    531                  status = sl_se_get_status(cmd_ctx, &se_status);
    532                  if ((status != SL_STATUS_OK)
    533                      || (se_status.se_fw_version < 0x00010201)) {
    534                    // If the following error is returned, the SE firmware version
    535                    // needs to be upgraded to v1.2.1 or higher before enabling
    536                    // anti-rollback.
    537                    EFM_ASSERT(false);
    538                    return SL_STATUS_ABORT;
    539                  }
    540                }
    541              }
    542              #endif
    543          
    544              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK;
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0xF440 0x2080      ORR      R0,R0,#0x40000
   \       0x48   0x9000             STR      R0,[SP, #+0]
    545            }
    546            if (otp_init->secure_boot_page_lock_narrow) {
   \                     ??sl_se_init_otp_3: (+1)
   \       0x4A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x4C   0xB118             CBZ.N    R0,??sl_se_init_otp_4
    547              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW;
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0xF440 0x2000      ORR      R0,R0,#0x80000
   \       0x54   0x9000             STR      R0,[SP, #+0]
    548            }
    549            if (otp_init->secure_boot_page_lock_full) {
   \                     ??sl_se_init_otp_4: (+1)
   \       0x56   0x7928             LDRB     R0,[R5, #+4]
   \       0x58   0xB118             CBZ.N    R0,??sl_se_init_otp_5
    550              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL;
   \       0x5A   0x9800             LDR      R0,[SP, #+0]
   \       0x5C   0xF440 0x1080      ORR      R0,R0,#0x100000
   \       0x60   0x9000             STR      R0,[SP, #+0]
    551            }
    552          
    553            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    554            static struct {
    555              uint8_t levels[SL_SE_TAMPER_SIGNAL_NUM_SIGNALS / 2];
    556              uint8_t period;
    557              uint8_t threshold;
    558              uint8_t flags;
    559              uint8_t reset_threshold;
    560            } otp_tamper_settings;
    561          
    562            // Check for reserved sources
    563            if ((otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_1] != SL_SE_TAMPER_LEVEL_IGNORE)
    564                || (otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_2] != SL_SE_TAMPER_LEVEL_IGNORE)
    565                || (otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_3] != SL_SE_TAMPER_LEVEL_IGNORE)
    566                || (otp_init->tamper_levels[SL_SE_TAMPER_SIGNAL_RESERVED_4] != SL_SE_TAMPER_LEVEL_IGNORE)) {
   \                     ??sl_se_init_otp_5: (+1)
   \       0x62   0x7968             LDRB     R0,[R5, #+5]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xBF04             ITT      EQ
   \       0x68   0x7A28             LDRBEQ   R0,[R5, #+8]
   \       0x6A   0x2800             CMPEQ    R0,#+0
   \       0x6C   0xD104             BNE.N    ??sl_se_init_otp_6
   \       0x6E   0x7AE8             LDRB     R0,[R5, #+11]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xBF04             ITT      EQ
   \       0x74   0x7CA8             LDRBEQ   R0,[R5, #+18]
   \       0x76   0x2800             CMPEQ    R0,#+0
   \                     ??sl_se_init_otp_6: (+1)
   \       0x78   0xD17B             BNE.N    ??sl_se_init_otp_0
    567              return SL_STATUS_INVALID_PARAMETER;
    568            }
    569          
    570            // Combine tamper levels, two per byte
    571            for (size_t i = 0; i < SL_SE_TAMPER_SIGNAL_NUM_SIGNALS; i += 2) {
   \       0x7A   0x.... 0x....      LDR.W    R1,??DataTable53_14
    572              // Check for reserved levels
    573              for (size_t offset = 0; offset < 2; ++offset) {
   \                     ??sl_se_init_otp_7: (+1)
   \       0x7E   0x2300             MOVS     R3,#+0
   \       0x80   0x1D6E             ADDS     R6,R5,#+5
    574                switch (otp_init->tamper_levels[i + offset]) {
   \                     ??sl_se_init_otp_8: (+1)
   \       0x82   0x181A             ADDS     R2,R3,R0
   \       0x84   0x5CB7             LDRB     R7,[R6, R2]
   \       0x86   0x2F02             CMP      R7,#+2
   \       0x88   0xD903             BLS.N    ??sl_se_init_otp_9
   \       0x8A   0x1F3F             SUBS     R7,R7,#+4
   \       0x8C   0xD001             BEQ.N    ??sl_se_init_otp_9
   \       0x8E   0x1EFF             SUBS     R7,R7,#+3
   \       0x90   0xD16F             BNE.N    ??sl_se_init_otp_0
    575                  case SL_SE_TAMPER_LEVEL_IGNORE:
    576                  case SL_SE_TAMPER_LEVEL_INTERRUPT:
    577                  case SL_SE_TAMPER_LEVEL_FILTER:
    578                  case SL_SE_TAMPER_LEVEL_RESET:
    579                  case SL_SE_TAMPER_LEVEL_PERMANENTLY_ERASE_OTP:
    580                    break;
   \                     ??sl_se_init_otp_9: (+1)
   \       0x92   0x1C5B             ADDS     R3,R3,#+1
   \       0x94   0x2B02             CMP      R3,#+2
   \       0x96   0xD3F4             BCC.N    ??sl_se_init_otp_8
    581                  default:
    582                    return SL_STATUS_INVALID_PARAMETER;
    583                }
    584              }
    585          
    586              otp_tamper_settings.levels[i / 2] = (otp_init->tamper_levels[i] & 0x7)
    587                                                  | ((otp_init->tamper_levels[i + 1] & 0x7) << 4);
   \       0x98   0x182B             ADDS     R3,R5,R0
   \       0x9A   0x5C32             LDRB     R2,[R6, R0]
   \       0x9C   0x799E             LDRB     R6,[R3, #+6]
   \       0x9E   0x0843             LSRS     R3,R0,#+1
   \       0xA0   0xF002 0x0207      AND      R2,R2,#0x7
   \       0xA4   0x0136             LSLS     R6,R6,#+4
   \       0xA6   0xF006 0x0670      AND      R6,R6,#0x70
   \       0xAA   0x4332             ORRS     R2,R6,R2
   \       0xAC   0x1C80             ADDS     R0,R0,#+2
   \       0xAE   0x54CA             STRB     R2,[R1, R3]
   \       0xB0   0x2820             CMP      R0,#+32
   \       0xB2   0xD3E4             BCC.N    ??sl_se_init_otp_7
    588            }
    589            // Limit period and threshold input
    590            otp_tamper_settings.period = otp_init->tamper_filter_period & 0x1f;
   \       0xB4   0xF105 0x0025      ADD      R0,R5,#+37
   \       0xB8   0x7802             LDRB     R2,[R0, #+0]
   \       0xBA   0xF002 0x021F      AND      R2,R2,#0x1F
   \       0xBE   0x740A             STRB     R2,[R1, #+16]
    591            otp_tamper_settings.threshold = otp_init->tamper_filter_threshold & 0x7;
   \       0xC0   0x7842             LDRB     R2,[R0, #+1]
   \       0xC2   0xF002 0x0207      AND      R2,R2,#0x7
   \       0xC6   0x744A             STRB     R2,[R1, #+17]
    592          
    593            #if !defined(SLI_SE_TAMPER_FLAG_KEEP_TAMPER_ALIVE_AVAILABLE)
    594            if ((otp_init->tamper_flags & SL_SE_TAMPER_FLAG_KEEP_TAMPER_ALIVE_DURING_SLEEP)
    595                == SL_SE_TAMPER_FLAG_KEEP_TAMPER_ALIVE_DURING_SLEEP) {
    596              return SL_STATUS_INVALID_PARAMETER;
    597            }
    598            #endif
    599            otp_tamper_settings.flags = otp_init->tamper_flags;
   \       0xC8   0x7882             LDRB     R2,[R0, #+2]
   \       0xCA   0x748A             STRB     R2,[R1, #+18]
    600            otp_tamper_settings.reset_threshold = otp_init->tamper_reset_threshold;
   \       0xCC   0x78C3             LDRB     R3,[R0, #+3]
    601            #else
    602            static struct otp_tamper_settings {
    603              uint8_t reserved1[16];
    604              uint8_t reserved2[2];
    605              uint8_t reserved3[2];
    606            } otp_tamper_settings = {
    607              { 0x00 },
    608              { 0xFF, 0xFF },
    609              { 0x00 }
    610            };
    611            #endif
    612          
    613            // Find parity word
    614            volatile uint32_t parity = 0;
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0x74CB             STRB     R3,[R1, #+19]
   \       0xD2   0x9001             STR      R0,[SP, #+4]
    615            parity = parity ^ mcu_settings_flags;
   \       0xD4   0x9A01             LDR      R2,[SP, #+4]
   \       0xD6   0x9800             LDR      R0,[SP, #+0]
   \       0xD8   0x4042             EORS     R2,R0,R2
   \       0xDA   0x9201             STR      R2,[SP, #+4]
    616            for (size_t i = 0; i < 5; i++) {
   \       0xDC   0x2000             MOVS     R0,#+0
    617              parity = parity ^ ((uint32_t*)(&otp_tamper_settings))[i];
   \                     ??sl_se_init_otp_10: (+1)
   \       0xDE   0x9B01             LDR      R3,[SP, #+4]
   \       0xE0   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
    618            }
   \       0xE4   0x1C40             ADDS     R0,R0,#+1
   \       0xE6   0x4053             EORS     R3,R2,R3
   \       0xE8   0x9301             STR      R3,[SP, #+4]
   \       0xEA   0x2805             CMP      R0,#+5
   \       0xEC   0xD3F7             BCC.N    ??sl_se_init_otp_10
    619          
    620            // SE command structures
    621            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_INIT_OTP);
   \       0xEE   0x.... 0x....      LDR.W    R0,??DataTable53_15
   \       0xF2   0x6020             STR      R0,[R4, #+0]
    622          
    623            volatile uint32_t parameters[2] = {
    624              parity,
    625              sizeof(mcu_settings_flags)
    626              + sizeof(otp_tamper_settings)
    627            };
   \       0xF4   0x.... 0x....      ADR.W    R0,?_7
   \       0xF8   0x2200             MOVS     R2,#+0
   \       0xFA   0x6062             STR      R2,[R4, #+4]
   \       0xFC   0x60A2             STR      R2,[R4, #+8]
   \       0xFE   0x61E2             STR      R2,[R4, #+28]
   \      0x100   0xE9D0 0x1300      LDRD     R1,R3,[R0, #+0]
   \      0x104   0xAA0A             ADD      R2,SP,#+40
   \      0x106   0xAD0A             ADD      R5,SP,#+40
   \      0x108   0xE9C2 0x1300      STRD     R1,R3,[R2, #+0]
   \      0x10C   0xE9D5 0x6E00      LDRD     R6,LR,[R5, #+0]
   \      0x110   0xAF02             ADD      R7,SP,#+8
    628            SE_DataTransfer_t parameters_data = SE_DATATRANSFER_DEFAULT(&parameters, 8);
   \      0x112   0x.... 0x....      ADR.W    R0,?_8
   \      0x116   0xE9C7 0x6E00      STRD     R6,LR,[R7, #+0]
   \      0x11A   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   \      0x11E   0xAD07             ADD      R5,SP,#+28
   \      0x120   0xAE02             ADD      R6,SP,#+8
   \      0x122   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \      0x126   0xE890 0x000E      LDM      R0,{R1-R3}
    629            SE_addDataInput(se_cmd, &parameters_data);
   \      0x12A   0x4620             MOV      R0,R4
   \      0x12C   0xE885 0x000E      STM      R5,{R1-R3}
   \      0x130   0x9607             STR      R6,[SP, #+28]
   \      0x132   0xA907             ADD      R1,SP,#+28
   \      0x134   0x.... 0x....      BL       SE_addDataInput
    630          
    631            SE_DataTransfer_t mcu_settings_flags_data =
    632              SE_DATATRANSFER_DEFAULT((volatile void *)&mcu_settings_flags, sizeof(mcu_settings_flags));
   \      0x138   0x.... 0x....      ADR.W    R0,?_9
   \      0x13C   0xE890 0x0026      LDM      R0,{R1,R2,R5}
   \      0x140   0xAB04             ADD      R3,SP,#+16
   \      0x142   0x466E             MOV      R6,SP
   \      0x144   0xE883 0x0026      STM      R3,{R1,R2,R5}
   \      0x148   0x9604             STR      R6,[SP, #+16]
    633            SE_addDataInput(se_cmd, &mcu_settings_flags_data);
   \      0x14A   0xA904             ADD      R1,SP,#+16
   \      0x14C   0x4620             MOV      R0,R4
   \      0x14E   0x.... 0x....      BL       SE_addDataInput
    634          
    635            SE_DataTransfer_t tamper_settings_data =
    636              SE_DATATRANSFER_DEFAULT((volatile void *)&otp_tamper_settings, sizeof(otp_tamper_settings));
   \      0x152   0x.... 0x....      ADR.W    R0,?_10
   \      0x156   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x15A   0xAD0C             ADD      R5,SP,#+48
    637            SE_addDataInput(se_cmd, &tamper_settings_data);
   \      0x15C   0x4620             MOV      R0,R4
   \      0x15E   0xE885 0x000E      STM      R5,{R1-R3}
   \      0x162   0xA90C             ADD      R1,SP,#+48
   \      0x164   0x.... 0x....      BL       SE_addDataInput
    638          
    639            return sli_se_execute_and_wait(cmd_ctx);
   \      0x168   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x16C   0xB01C             ADD      SP,SP,#+112
   \      0x16E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??sl_se_init_otp_0: (+1)
   \      0x172   0x2021             MOVS     R0,#+33
   \      0x174   0xE7FA             B.N      ??CrossCallReturnLabel_20
    640          }

   \                                 In section .bss, align 4
   \                     `sl_se_init_otp::otp_tamper_settings`:
   \        0x0                      DS8 20

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0, 24
   \              0x0000'0018

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'920
   \              0x0000'0001  
   \              0x2000'0008

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x....'....        DC32 `sl_se_init_otp::otp_tamper_settings`, 0x1, 536'870'932
   \              0x0000'0001  
   \              0x2000'0014
    641          
    642          /***************************************************************************//**
    643           * Read SE OTP configuration.
    644           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    645          sl_status_t sl_se_read_otp(sl_se_command_context_t *cmd_ctx,
    646                                     sl_se_otp_init_t *otp_settings)
    647          {
   \                     sl_se_read_otp: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x460C             MOV      R4,R1
    648            if (cmd_ctx == NULL || otp_settings == NULL) {
   \        0x8   0xBF14             ITE      NE
   \        0xA   0x2C00             CMPNE    R4,#+0
   \        0xC   0x2021             MOVEQ    R0,#+33
    649              return SL_STATUS_INVALID_PARAMETER;
   \        0xE   0xD04D             BEQ.N    ??sl_se_read_otp_0
    650            }
    651          
    652            SE_Command_t *se_cmd = &cmd_ctx->command;
    653            sl_status_t status;
    654          
    655            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    656            volatile struct {
    657              uint32_t mcu_settings_flags;
    658              uint8_t levels[SL_SE_TAMPER_SIGNAL_NUM_SIGNALS / 2];
    659              uint8_t period;
    660              uint8_t threshold;
    661              uint8_t flags;
    662              uint8_t reset_threshold;
    663            } otp_raw;
    664            #else
    665            volatile struct {
    666              uint32_t mcu_settings_flags;
    667              uint8_t reserved1[16];
    668              uint8_t reserved2[2];
    669              uint8_t reserved3[2];
    670            } otp_raw;
    671            #endif
    672          
    673            // SE command structures
    674            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_OTP);
   \       0x10   0x.... 0x....      LDR.W    R2,??DataTable53_16
    675          
    676            SE_DataTransfer_t otp_raw_data =
    677              SE_DATATRANSFER_DEFAULT(&otp_raw, sizeof(otp_raw));
   \       0x14   0x.... 0x....      ADR.W    R0,?_11
   \       0x18   0x602A             STR      R2,[R5, #+0]
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x6069             STR      R1,[R5, #+4]
   \       0x1E   0x60A9             STR      R1,[R5, #+8]
   \       0x20   0x61E9             STR      R1,[R5, #+28]
   \       0x22   0xE890 0x004C      LDM      R0,{R2,R3,R6}
   \       0x26   0xA906             ADD      R1,SP,#+24
   \       0x28   0x466F             MOV      R7,SP
   \       0x2A   0xE881 0x004C      STM      R1,{R2,R3,R6}
   \       0x2E   0x9706             STR      R7,[SP, #+24]
    678            SE_addDataOutput(se_cmd, &otp_raw_data);
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x.... 0x....      BL       SE_addDataOutput
    679          
    680            status = sli_se_execute_and_wait(cmd_ctx);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       sli_se_execute_and_wait
    681          
    682            if (status != SL_STATUS_OK) {
   \       0x3C   0xBBB0             CBNZ.N   R0,??sl_se_read_otp_0
    683              return status;
    684            }
    685          
    686            otp_settings->enable_secure_boot =
    687              (otp_raw.mcu_settings_flags
    688               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE);
   \       0x3E   0x9800             LDR      R0,[SP, #+0]
    689            otp_settings->verify_secure_boot_certificate =
    690              (otp_raw.mcu_settings_flags
    691               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE);
    692            otp_settings->enable_anti_rollback =
    693              (otp_raw.mcu_settings_flags
    694               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK);
    695            otp_settings->secure_boot_page_lock_narrow =
    696              (otp_raw.mcu_settings_flags
    697               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW);
    698            otp_settings->secure_boot_page_lock_full =
    699              (otp_raw.mcu_settings_flags
    700               & SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL);
    701          
    702            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    703            // Split levels
    704            for (size_t i = 0; i < sizeof(otp_raw.levels); i++) {
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0xAB01             ADD      R3,SP,#+4
   \       0x44   0x0C00             LSRS     R0,R0,#+16
   \       0x46   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x4A   0x7020             STRB     R0,[R4, #+0]
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x0C40             LSRS     R0,R0,#+17
   \       0x50   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x54   0x7060             STRB     R0,[R4, #+1]
   \       0x56   0x9800             LDR      R0,[SP, #+0]
   \       0x58   0x0C80             LSRS     R0,R0,#+18
   \       0x5A   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x5E   0x70A0             STRB     R0,[R4, #+2]
   \       0x60   0x9800             LDR      R0,[SP, #+0]
   \       0x62   0x0CC0             LSRS     R0,R0,#+19
   \       0x64   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x68   0x70E0             STRB     R0,[R4, #+3]
   \       0x6A   0x9800             LDR      R0,[SP, #+0]
   \       0x6C   0x0D00             LSRS     R0,R0,#+20
   \       0x6E   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x72   0x7120             STRB     R0,[R4, #+4]
    705              otp_settings->tamper_levels[2 * i] = (otp_raw.levels[i]) & 0x7;
   \                     ??sl_se_read_otp_1: (+1)
   \       0x74   0x5C98             LDRB     R0,[R3, R2]
   \       0x76   0xEB04 0x0142      ADD      R1,R4,R2, LSL #+1
   \       0x7A   0xF000 0x0007      AND      R0,R0,#0x7
   \       0x7E   0x7148             STRB     R0,[R1, #+5]
    706              otp_settings->tamper_levels[2 * i + 1] = (otp_raw.levels[i] >> 4) & 0x7;
   \       0x80   0x5C98             LDRB     R0,[R3, R2]
    707            }
   \       0x82   0x1C52             ADDS     R2,R2,#+1
   \       0x84   0x2A10             CMP      R2,#+16
   \       0x86   0xF3C0 0x1002      UBFX     R0,R0,#+4,#+3
   \       0x8A   0x7188             STRB     R0,[R1, #+6]
   \       0x8C   0xD3F2             BCC.N    ??sl_se_read_otp_1
    708          
    709            otp_settings->tamper_filter_period = otp_raw.period;
   \       0x8E   0xF89D 0x2014      LDRB     R2,[SP, #+20]
   \       0x92   0xF104 0x0025      ADD      R0,R4,#+37
   \       0x96   0x7002             STRB     R2,[R0, #+0]
    710            otp_settings->tamper_filter_threshold = otp_raw.threshold;
   \       0x98   0xF89D 0x1015      LDRB     R1,[SP, #+21]
   \       0x9C   0x7041             STRB     R1,[R0, #+1]
    711          
    712            otp_settings->tamper_flags = otp_raw.flags;
   \       0x9E   0xF89D 0x1016      LDRB     R1,[SP, #+22]
   \       0xA2   0x7081             STRB     R1,[R0, #+2]
    713            otp_settings->tamper_reset_threshold = otp_raw.reset_threshold;
   \       0xA4   0xF89D 0x1017      LDRB     R1,[SP, #+23]
   \       0xA8   0x70C1             STRB     R1,[R0, #+3]
    714            #endif
    715          
    716            return SL_STATUS_OK;
   \       0xAA   0x2000             MOVS     R0,#+0
   \                     ??sl_se_read_otp_0: (+1)
   \       0xAC   0xB009             ADD      SP,SP,#+36
   \       0xAE   0xBDF0             POP      {R4-R7,PC}
    717          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'936
   \              0x0000'0001  
   \              0x2000'0018
    718          
    719          #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    720          
    721          sl_status_t sl_se_init_otp(sl_se_command_context_t *cmd_ctx,
    722                                     sl_se_otp_init_t *otp_init)
    723          {
    724            if (cmd_ctx == NULL || otp_init == NULL) {
    725              return SL_STATUS_INVALID_PARAMETER;
    726            }
    727          
    728            SE_Command_t *se_cmd = &cmd_ctx->command;
    729            volatile uint32_t mcu_settings_flags = 0;
    730          
    731            if (otp_init->enable_secure_boot) {
    732              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE;
    733            }
    734            if (otp_init->verify_secure_boot_certificate) {
    735              mcu_settings_flags |=
    736                SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE;
    737            }
    738            if (otp_init->enable_anti_rollback) {
    739              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK;
    740            }
    741            if (otp_init->secure_boot_page_lock_narrow) {
    742              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW;
    743            }
    744            if (otp_init->secure_boot_page_lock_full) {
    745              mcu_settings_flags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL;
    746            }
    747          
    748            // Find parity word
    749            uint32_t parity = 0;
    750            parity = parity ^ mcu_settings_flags;
    751          
    752            // SE command structures
    753            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_INIT_OTP);
    754          
    755            volatile uint32_t parameters[2] = {
    756              parity,
    757              sizeof(mcu_settings_flags)
    758            };
    759            SE_DataTransfer_t parameters_data = SE_DATATRANSFER_DEFAULT(&parameters, 8);
    760            SE_addDataInput(se_cmd, &parameters_data);
    761          
    762            SE_DataTransfer_t mcu_settings_flags_data =
    763              SE_DATATRANSFER_DEFAULT(&mcu_settings_flags, sizeof(mcu_settings_flags));
    764            SE_addDataInput(se_cmd, &mcu_settings_flags_data);
    765          
    766            SE_executeCommand(se_cmd);
    767            return SL_STATUS_FAIL; // Should never get to this point
    768          }
    769          
    770          /***************************************************************************//**
    771           * Read the OTP firmware version of the SE module.
    772           ******************************************************************************/
    773          sl_status_t sl_se_get_otp_version(sl_se_command_context_t *cmd_ctx,
    774                                            uint32_t *version)
    775          {
    776            if (cmd_ctx == NULL || version == NULL) {
    777              return SL_STATUS_INVALID_PARAMETER;
    778            }
    779          
    780            // Try to acquire SE lock
    781            sl_status_t lock_status = sli_se_lock_acquire();
    782            if (lock_status != SL_STATUS_OK) {
    783              return lock_status;
    784            }
    785          
    786            SE_Response_t otp_status = SE_getOTPVersion(version);
    787          
    788            // Release SE lock
    789            sli_se_lock_release();
    790          
    791            if (otp_status == SE_RESPONSE_OK) {
    792              return SL_STATUS_OK;
    793            }
    794          
    795            return SL_STATUS_NOT_SUPPORTED;
    796          }
    797          
    798          sl_status_t sl_se_read_otp(sl_se_command_context_t *cmd_ctx,
    799                                     sl_se_otp_init_t *otp_settings)
    800          {
    801            if (cmd_ctx == NULL || otp_settings == NULL) {
    802              return SL_STATUS_INVALID_PARAMETER;
    803            }
    804          
    805            // Try to acquire SE lock
    806            sl_status_t status = sli_se_lock_acquire();
    807            if (status != SL_STATUS_OK) {
    808              return status;
    809            }
    810          
    811            uint32_t mcu_settings_flags = 0;
    812            SE_Response_t vse_mbx_status = SE_getConfigStatusBits(&mcu_settings_flags);
    813          
    814            // Release SE lock
    815            status = sli_se_lock_release();
    816          
    817            if (vse_mbx_status != SE_RESPONSE_OK) {
    818              return sli_se_to_sl_status(vse_mbx_status);
    819            } else if (status != SL_STATUS_OK) {
    820              return status;
    821            }
    822          
    823            otp_settings->enable_secure_boot =
    824              (mcu_settings_flags
    825               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    826            otp_settings->verify_secure_boot_certificate =
    827              (mcu_settings_flags
    828               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    829            otp_settings->enable_anti_rollback =
    830              (mcu_settings_flags
    831               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    832            otp_settings->secure_boot_page_lock_narrow =
    833              (mcu_settings_flags
    834               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_NARROW >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    835            otp_settings->secure_boot_page_lock_full =
    836              (mcu_settings_flags
    837               & (SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_PAGE_LOCK_FULL >> SL_SE_ROOT_CONFIG_MCU_SETTINGS_SHIFT));
    838          
    839            return SL_STATUS_OK;
    840          }
    841          #endif
    842          
    843          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
    844          
    845          /***************************************************************************//**
    846           * Writes data to User Data section in MTP. Write data must be aligned to
    847           * word size and contain a number of bytes that is divisable by four.
    848           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    849          sl_status_t sl_se_write_user_data(sl_se_command_context_t *cmd_ctx,
    850                                            uint32_t offset,
    851                                            void *data,
    852                                            uint32_t num_bytes)
    853          {
   \                     sl_se_write_user_data: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x461D             MOV      R5,R3
    854            if (cmd_ctx == NULL) {
   \        0x8   0xD001             BEQ.N    ??sl_se_write_user_data_0
    855              return SL_STATUS_INVALID_PARAMETER;
    856            }
    857          
    858            if (data == NULL && num_bytes > 0UL) {
   \        0xA   0xB912             CBNZ.N   R2,??sl_se_write_user_data_1
   \        0xC   0xB10D             CBZ.N    R5,??sl_se_write_user_data_1
    859              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_write_user_data_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xBDFE             POP      {R1-R7,PC}
    860            }
    861          
    862            // Setup SE command structures
    863            SE_Command_t *se_cmd = &cmd_ctx->command;
    864            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(data, num_bytes);
   \                     ??sl_se_write_user_data_1: (+1)
   \       0x12   0x.... 0x....      ADR.W    R0,?_12
   \       0x16   0xE890 0x008A      LDM      R0,{R1,R3,R7}
   \       0x1A   0x46EE             MOV      LR,SP
    865          
    866            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_WRITE_USER_DATA);
    867            SE_addDataInput(se_cmd, &in_data);
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0xE88E 0x008A      STM      LR,{R1,R3,R7}
   \       0x22   0x9200             STR      R2,[SP, #+0]
   \       0x24   0xF045 0x5200      ORR      R2,R5,#0x20000000
   \       0x28   0x9202             STR      R2,[SP, #+8]
   \       0x2A   0x.... 0x....      LDR.W    R3,??DataTable53_17
   \       0x2E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x.... 0x....      BL       SE_addDataInput
    868          
    869            SE_addParameter(se_cmd, offset);
   \       0x38   0x.... 0x....      BL       ?Subroutine7
    870            SE_addParameter(se_cmd, num_bytes);
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x3C   0x4629             MOV      R1,R5
   \       0x3E   0x.... 0x....      BL       ??Subroutine7_0
    871          
    872            // Execute and wait
    873            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x42   0x....             B.N      ??Subroutine14_0
    874          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    875          
    876          /***************************************************************************//**
    877           * Erases User Data section in MTP.
    878           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    879          sl_status_t sl_se_erase_user_data(sl_se_command_context_t *cmd_ctx)
    880          {
   \                     sl_se_erase_user_data: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    881            if (cmd_ctx == NULL) {
   \        0x4   0xD101             BNE.N    ??sl_se_erase_user_data_0
    882              return SL_STATUS_INVALID_PARAMETER;
   \        0x6   0x2021             MOVS     R0,#+33
   \        0x8   0xBD10             POP      {R4,PC}
    883            }
    884          
    885            // SE command structures
    886            SE_Command_t *se_cmd = &cmd_ctx->command;
    887            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_ERASE_USER_DATA);
   \                     ??sl_se_erase_user_data_0: (+1)
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable53_18
   \        0xE   0x6022             STR      R2,[R4, #+0]
   \       0x10   0x.... 0x....      BL       ??Subroutine6_0
    888          
    889            SE_addParameter(se_cmd, SLI_SE_COMMAND_OPTION_ERASE_UD);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable53_19
   \       0x18   0x....             B.N      ??Subroutine1_0
    890          
    891            // Execute and wait.
    892            return sli_se_execute_and_wait(cmd_ctx);
    893          }
    894          
    895          /***************************************************************************//**
    896           * Returns the current boot status, versions and system configuration.
    897           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    898          sl_status_t sl_se_get_status(sl_se_command_context_t *cmd_ctx,
    899                                       sl_se_status_t *status)
    900          {
   \                     sl_se_get_status: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB08C             SUB      SP,SP,#+48
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x460C             MOV      R4,R1
    901            if (cmd_ctx == NULL || status == NULL) {
   \        0x8   0xBF14             ITE      NE
   \        0xA   0x2C00             CMPNE    R4,#+0
   \        0xC   0x2021             MOVEQ    R0,#+33
    902              return SL_STATUS_INVALID_PARAMETER;
   \        0xE   0xD03F             BEQ.N    ??sl_se_get_status_0
   \       0x10   0x2124             MOVS     R1,#+36
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0xA803             ADD      R0,SP,#+12
   \       0x16   0x.... 0x....      BL       __aeabi_memset
    903            }
    904          
    905            volatile uint32_t output[9] = { 0 };
    906            SE_Command_t *se_cmd = &cmd_ctx->command;
    907          
    908            // SE command structures
    909            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_GET_STATUS);
   \       0x1A   0x.... 0x....      LDR.W    R3,??DataTable53_20
   \       0x1E   0x602B             STR      R3,[R5, #+0]
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6069             STR      R1,[R5, #+4]
   \       0x24   0x60A9             STR      R1,[R5, #+8]
   \       0x26   0x61E9             STR      R1,[R5, #+28]
    910            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(output, 4 * 9);
   \       0x28   0x.... 0x....      ADR.W    R0,?_13
   \       0x2C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x30   0x466E             MOV      R6,SP
   \       0x32   0xAF03             ADD      R7,SP,#+12
   \       0x34   0xE886 0x000E      STM      R6,{R1-R3}
   \       0x38   0x9700             STR      R7,[SP, #+0]
    911          
    912            SE_addDataOutput(se_cmd, &out_data);
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       SE_addDataOutput
    913          
    914            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x.... 0x....      BL       sli_se_execute_and_wait
   \       0x48   0x0005             MOVS     R5,R0
    915          
    916            if (ret == SL_STATUS_OK) {
   \       0x4A   0xD120             BNE.N    ??sl_se_get_status_1
    917              // Tamper status
    918              status->tamper_status = output[0];
   \       0x4C   0x9803             LDR      R0,[SP, #+12]
    919              status->tamper_status_raw = output[2];
   \       0x4E   0xAE03             ADD      R6,SP,#+12
   \       0x50   0x61E0             STR      R0,[R4, #+28]
   \       0x52   0x68B0             LDR      R0,[R6, #+8]
   \       0x54   0x6220             STR      R0,[R4, #+32]
    920          
    921              // Update status object
    922              status->boot_status = output[4];
   \       0x56   0x9807             LDR      R0,[SP, #+28]
   \       0x58   0x6020             STR      R0,[R4, #+0]
    923              status->se_fw_version = output[5];
   \       0x5A   0x9908             LDR      R1,[SP, #+32]
   \       0x5C   0x6061             STR      R1,[R4, #+4]
    924              status->host_fw_version = output[6];
   \       0x5E   0x69B0             LDR      R0,[R6, #+24]
   \       0x60   0x60A0             STR      R0,[R4, #+8]
    925          
    926              // Decode debug status
    927              decode_debug_status(&status->debug_status, output[7]);
   \       0x62   0x69F1             LDR      R1,[R6, #+28]
   \       0x64   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x68   0x.... 0x....      BL       decode_debug_status
    928          
    929              // Decode secure boot mode
    930              status->secure_boot_enabled =
    931                ((output[8] & 0x1U) && ((output[8] & ~0x1U) == 0));
   \       0x6C   0x6A31             LDR      R1,[R6, #+32]
   \       0x6E   0x07C8             LSLS     R0,R1,#+31
   \       0x70   0xD506             BPL.N    ??sl_se_get_status_2
   \       0x72   0x6A31             LDR      R1,[R6, #+32]
   \       0x74   0x0849             LSRS     R1,R1,#+1
   \       0x76   0x0049             LSLS     R1,R1,#+1
   \       0x78   0x1E48             SUBS     R0,R1,#+1
   \       0x7A   0x4180             SBCS     R0,R0,R0
   \       0x7C   0x0FC0             LSRS     R0,R0,#+31
   \       0x7E   0xE000             B.N      ??sl_se_get_status_3
   \                     ??sl_se_get_status_2: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \                     ??sl_se_get_status_3: (+1)
   \       0x82   0x7620             STRB     R0,[R4, #+24]
    932          
    933          #if (_SILICON_LABS_32B_SERIES_2_CONFIG < 3)
    934              uint32_t active_mode_shift = 16;
    935          #else
    936              uint32_t active_mode_shift = 8;
    937          #endif
    938              status->active_mode_enabled =
    939                (status->boot_status >> active_mode_shift) & 0x1;
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x0A00             LSRS     R0,R0,#+8
   \       0x88   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x8C   0x7660             STRB     R0,[R4, #+25]
    940            }
    941          
    942            return ret;
   \                     ??sl_se_get_status_1: (+1)
   \       0x8E   0x4628             MOV      R0,R5
   \                     ??sl_se_get_status_0: (+1)
   \       0x90   0xB00D             ADD      SP,SP,#+52
   \       0x92   0xBDF0             POP      {R4-R7,PC}
    943          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'948
   \              0x0000'0001  
   \              0x2000'0024
    944          
    945          /***************************************************************************//**
    946           * Read the serial number of the SE module.
    947           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    948          sl_status_t sl_se_get_serialnumber(sl_se_command_context_t *cmd_ctx,
    949                                             void *serial)
    950          {
   \                     sl_se_get_serialnumber: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    951            if (cmd_ctx == NULL || serial == NULL) {
   \        0x4   0xBF14             ITE      NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0x2021             MOVEQ    R0,#+33
    952              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0xD009             BEQ.N    ??CrossCallReturnLabel_19
    953            }
    954          
    955            // SE command structures
    956            SE_Command_t *se_cmd = &cmd_ctx->command;
    957            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_SERIAL);
   \        0xC   0xF04F 0x437E      MOV      R3,#+4261412864
   \       0x10   0x.... 0x....      BL       ?Subroutine5
    958            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(serial, 16);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x14   0x.... 0x....      ADR.W    R0,?_14
   \       0x18   0x.... 0x....      BL       ?Subroutine9
    959          
    960            SE_addDataOutput(se_cmd, &out_data);
    961          
    962            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x1C   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x20   0xB004             ADD      SP,SP,#+16
   \       0x22   0xBD70             POP      {R4-R6,PC}
    963          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    964          
    965          /***************************************************************************//**
    966           * Read the OTP firmware version of the SE module.
    967           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    968          sl_status_t sl_se_get_otp_version(sl_se_command_context_t *cmd_ctx,
    969                                            uint32_t *version)
    970          {
   \                     sl_se_get_otp_version: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    971            if (cmd_ctx == NULL || version == NULL) {
   \        0x4   0xBF14             ITE      NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0x2021             MOVEQ    R0,#+33
    972              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0xD008             BEQ.N    ??CrossCallReturnLabel_18
    973            }
    974          
    975            // SE command structures
    976            SE_Command_t *se_cmd = &cmd_ctx->command;
    977            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_OTP_VERSION);
   \        0xC   0x....             LDR.N    R3,??DataTable53_21
   \        0xE   0x.... 0x....      BL       ?Subroutine5
    978            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(version, sizeof(uint32_t));
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x12   0x.... 0x....      ADR.W    R0,?_15
   \       0x16   0x.... 0x....      BL       ?Subroutine9
    979          
    980            SE_addDataOutput(se_cmd, &out_data);
    981          
    982            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x1A   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x1E   0xB004             ADD      SP,SP,#+16
   \       0x20   0xBD70             POP      {R4-R6,PC}
    983          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
    984          
    985          #if defined(SLI_SE_COMMAND_STATUS_READ_RSTCAUSE_AVAILABLE)
    986          /***************************************************************************//**
    987           * Read the EMU->RSTCAUSE after a tamper reset. This function should be called
    988           * if EMU->RSTCAUSE has been cleared upon boot.
    989           ******************************************************************************/
    990          sl_status_t sl_se_get_reset_cause(sl_se_command_context_t *cmd_ctx,
    991                                            uint32_t *reset_cause)
    992          {
    993            if (cmd_ctx == NULL || reset_cause == NULL) {
    994              return SL_STATUS_INVALID_PARAMETER;
    995            }
    996          
    997            // SE command structures
    998            SE_Command_t *se_cmd = &cmd_ctx->command;
    999            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_STATUS_READ_RSTCAUSE);
   1000            SE_DataTransfer_t out_data =
   1001              SE_DATATRANSFER_DEFAULT(reset_cause, sizeof(uint32_t));
   1002            SE_addDataOutput(se_cmd, &out_data);
   1003            return sli_se_execute_and_wait(cmd_ctx);
   1004          }
   1005          #endif // SLI_SE_COMMAND_STATUS_READ_RSTCAUSE_AVAILABLE
   1006          
   1007          #if defined(SLI_SE_COMMAND_READ_TAMPER_RESET_CAUSE_AVAILABLE)
   1008          /***************************************************************************//**
   1009           * Read the cached value of the EMU->TAMPERRSTCAUSE register after a tamper
   1010           * reset. This function should be called if EMU->TAMPERRSTCAUSE has been cleared
   1011           * upon boot.
   1012           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1013          sl_status_t sl_se_get_tamper_reset_cause(sl_se_command_context_t *cmd_ctx,
   1014                                                   bool *was_tamper_reset,
   1015                                                   uint32_t *reset_cause)
   1016          {
   \                     sl_se_get_tamper_reset_cause: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   1017            if (cmd_ctx == NULL || reset_cause == NULL || was_tamper_reset == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2D00             CMPNE    R5,#+0
   \        0xE   0xD000             BEQ.N    ??sl_se_get_tamper_reset_cause_0
   \       0x10   0xB90C             CBNZ.N   R4,??sl_se_get_tamper_reset_cause_1
   1018              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_get_tamper_reset_cause_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE025             B.N      ??sl_se_get_tamper_reset_cause_2
   1019            }
   1020          
   1021            // Use a local cache to convert from bitfield to integer
   1022            uint32_t tamper_cause_ret = 0;
   \                     ??sl_se_get_tamper_reset_cause_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x9000             STR      R0,[SP, #+0]
   1023          
   1024            // SE command structures
   1025            SE_Command_t *se_cmd = &cmd_ctx->command;
   1026            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_TAMPER_RESET_CAUSE);
   \       0x1A   0x....             LDR.N    R2,??DataTable53_22
   \       0x1C   0x6032             STR      R2,[R6, #+0]
   \       0x1E   0x6070             STR      R0,[R6, #+4]
   \       0x20   0x60B0             STR      R0,[R6, #+8]
   \       0x22   0x61F0             STR      R0,[R6, #+28]
   1027            SE_DataTransfer_t out_data =
   1028              SE_DATATRANSFER_DEFAULT(&tamper_cause_ret, sizeof(uint32_t));
   \       0x24   0x.... 0x....      ADR.W    R0,?_16
   \       0x28   0xE890 0x008C      LDM      R0,{R2,R3,R7}
   \       0x2C   0xA901             ADD      R1,SP,#+4
   \       0x2E   0x46EE             MOV      LR,SP
   \       0x30   0xE881 0x008C      STM      R1,{R2,R3,R7}
   \       0x34   0xF8CD 0xE004      STR      LR,[SP, #+4]
   1029            SE_addDataOutput(se_cmd, &out_data);
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       SE_addDataOutput
   1030            sl_status_t status = sli_se_execute_and_wait(cmd_ctx);
   \       0x3E   0x4630             MOV      R0,R6
   \       0x40   0x.... 0x....      BL       sli_se_execute_and_wait
   1031            if (status != SL_STATUS_OK) {
   \       0x44   0xB968             CBNZ.N   R0,??sl_se_get_tamper_reset_cause_2
   1032              return status;
   1033            }
   1034          
   1035            // Update indication if the reset was because of a tamper event or not.
   1036            *was_tamper_reset = tamper_cause_ret > 0 ? true : false;
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0xB100             CBZ.N    R0,??sl_se_get_tamper_reset_cause_3
   \       0x4A   0x2001             MOVS     R0,#+1
   \                     ??sl_se_get_tamper_reset_cause_3: (+1)
   \       0x4C   0x7020             STRB     R0,[R4, #+0]
   1037          
   1038            // If there is a tamper cause the returned value(tamper_cause_ret) has a
   1039            // single bit set at the position of the tamper cause.
   1040            // Find the position of the set bit and return it.
   1041            uint32_t set_bit_position = 0;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE002             B.N      ??sl_se_get_tamper_reset_cause_4
   1042            while (tamper_cause_ret > 1) {
   1043              tamper_cause_ret >>= 1;
   \                     ??sl_se_get_tamper_reset_cause_5: (+1)
   \       0x52   0x0849             LSRS     R1,R1,#+1
   \       0x54   0x9100             STR      R1,[SP, #+0]
   1044              set_bit_position++;
   \       0x56   0x1C40             ADDS     R0,R0,#+1
   1045            }
   \                     ??sl_se_get_tamper_reset_cause_4: (+1)
   \       0x58   0x9900             LDR      R1,[SP, #+0]
   \       0x5A   0x2901             CMP      R1,#+1
   \       0x5C   0xD8F9             BHI.N    ??sl_se_get_tamper_reset_cause_5
   1046          
   1047            *reset_cause = set_bit_position;
   \       0x5E   0x6028             STR      R0,[R5, #+0]
   1048            return status;
   \       0x60   0x2000             MOVS     R0,#+0
   \                     ??sl_se_get_tamper_reset_cause_2: (+1)
   \       0x62   0xB005             ADD      SP,SP,#+20
   \       0x64   0xBDF0             POP      {R4-R7,PC}
   1049          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
   1050          #endif // SLI_SE_COMMAND_READ_TAMPER_RESET_CAUSE_AVAILABLE
   1051          
   1052          /***************************************************************************//**
   1053           * Enables the secure debug functionality.
   1054           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1055          sl_status_t sl_se_enable_secure_debug(sl_se_command_context_t *cmd_ctx)
   1056          {
   1057            if (cmd_ctx == NULL) {
   \                     sl_se_enable_secure_debug: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_enable_secure_debug_0
   1058              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
   1059            }
   1060          
   1061            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_ENABLE_SECURE);
   \                     ??sl_se_enable_secure_debug_0: (+1)
   \        0x6   0x....             LDR.N    R3,??DataTable53_23
   \        0x8                      REQUIRE ?Subroutine2
   \        0x8                      ;; // Fall through to label ?Subroutine2
   1062          
   1063            return sli_se_execute_and_wait(cmd_ctx);
   1064          }
   1065          
   1066          /***************************************************************************//**
   1067           * Disables the secure debug functionality.
   1068           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1069          sl_status_t sl_se_disable_secure_debug(sl_se_command_context_t *cmd_ctx)
   1070          {
   1071            if (cmd_ctx == NULL) {
   \                     sl_se_disable_secure_debug: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_disable_secure_debug_0
   1072              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
   1073            }
   1074          
   1075            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_LOCK_DISABLE_SECURE);
   \                     ??sl_se_disable_secure_debug_0: (+1)
   \        0x6   0x....             LDR.N    R3,??DataTable53_24
   \        0x8   0x....             B.N      ?Subroutine2
   1076          
   1077            return sli_se_execute_and_wait(cmd_ctx);
   1078          }
   1079          
   1080          /***************************************************************************//**
   1081           * Set options on the debug interface.
   1082           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1083          sl_status_t sl_se_set_debug_options(sl_se_command_context_t *cmd_ctx,
   1084                                              const sl_se_debug_options_t *debug_options)
   1085          {
   \                     sl_se_set_debug_options: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1086            if (cmd_ctx == NULL || debug_options == NULL) {
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD101             BNE.N    ??sl_se_set_debug_options_0
   1087              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
   1088            }
   1089          
   1090            SE_Command_t *se_cmd = &cmd_ctx->command;
   1091            uint32_t restriction_bits = 0x0;
   1092          
   1093            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DBG_SET_RESTRICTIONS);
   \                     ??sl_se_set_debug_options_0: (+1)
   \        0xE   0x....             LDR.N    R5,??DataTable53_25
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x6025             STR      R5,[R4, #+0]
   \       0x14   0x6062             STR      R2,[R4, #+4]
   \       0x16   0x60A2             STR      R2,[R4, #+8]
   \       0x18   0x61E2             STR      R2,[R4, #+28]
   1094          
   1095            /// Encode restricted debug options parameter.
   1096            restriction_bits |= debug_options->non_secure_invasive_debug ? 0 : 1UL << 0;
   \       0x1A   0x7808             LDRB     R0,[R1, #+0]
   \       0x1C   0xB900             CBNZ.N   R0,??sl_se_set_debug_options_1
   \       0x1E   0x2201             MOVS     R2,#+1
   1097            restriction_bits |= debug_options->non_secure_non_invasive_debug ? 0 : 1UL << 1;
   \                     ??sl_se_set_debug_options_1: (+1)
   \       0x20   0x7848             LDRB     R0,[R1, #+1]
   \       0x22   0xB908             CBNZ.N   R0,??sl_se_set_debug_options_2
   \       0x24   0xF042 0x0202      ORR      R2,R2,#0x2
   1098            restriction_bits |= debug_options->secure_invasive_debug ? 0 : 1UL << 2;
   \                     ??sl_se_set_debug_options_2: (+1)
   \       0x28   0x7888             LDRB     R0,[R1, #+2]
   \       0x2A   0xB908             CBNZ.N   R0,??sl_se_set_debug_options_3
   \       0x2C   0xF042 0x0204      ORR      R2,R2,#0x4
   1099            restriction_bits |= debug_options->secure_non_invasive_debug ? 0 : 1UL << 3;
   \                     ??sl_se_set_debug_options_3: (+1)
   \       0x30   0x78C8             LDRB     R0,[R1, #+3]
   \       0x32   0xB908             CBNZ.N   R0,??sl_se_set_debug_options_4
   \       0x34   0xF042 0x0208      ORR      R2,R2,#0x8
   1100          
   1101            SE_addParameter(se_cmd, restriction_bits);
   \                     ??sl_se_set_debug_options_4: (+1)
   \       0x38   0x4611             MOV      R1,R2
   \       0x3A   0x....             B.N      ??Subroutine13_0
   1102          
   1103            return sli_se_execute_and_wait(cmd_ctx);
   1104          }
   1105          
   1106          /***************************************************************************//**
   1107           * Performs a device mass erase and debug unlock.
   1108           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1109          sl_status_t sl_se_erase_device(sl_se_command_context_t *cmd_ctx)
   1110          {
   1111            if (cmd_ctx == NULL) {
   \                     sl_se_erase_device: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_erase_device_0
   1112              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
   1113            }
   1114          
   1115            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DEVICE_ERASE);
   \                     ??sl_se_erase_device_0: (+1)
   \        0x6   0x....             LDR.N    R3,??DataTable53_26
   \        0x8   0x....             B.N      ?Subroutine2
   1116          
   1117            return sli_se_execute_and_wait(cmd_ctx);
   1118          }
   1119          
   1120          /***************************************************************************//**
   1121           * Disabled device erase functionality.
   1122           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1123          sl_status_t sl_se_disable_device_erase(sl_se_command_context_t *cmd_ctx)
   1124          {
   1125            if (cmd_ctx == NULL) {
   \                     sl_se_disable_device_erase: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_disable_device_erase_0
   1126              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
   1127            }
   1128          
   1129            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DEVICE_ERASE_DISABLE);
   \                     ??sl_se_disable_device_erase_0: (+1)
   \        0x6   0x....             LDR.N    R3,??DataTable53_27
   \        0x8   0x....             B.N      ?Subroutine2
   1130          
   1131            return sli_se_execute_and_wait(cmd_ctx);
   1132          }
   1133          
   1134          /***************************************************************************//**
   1135           * Request challenge from SE which can be used to open debug access.
   1136           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1137          sl_status_t sl_se_get_challenge(sl_se_command_context_t *cmd_ctx,
   1138                                          sl_se_challenge_t challenge)
   1139          {
   \                     sl_se_get_challenge: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1140            if (cmd_ctx == NULL || challenge == NULL) {
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD101             BNE.N    ??sl_se_get_challenge_0
   1141              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0xBDFE             POP      {R1-R7,PC}
   1142            }
   1143          
   1144            SE_Command_t *se_cmd = &cmd_ctx->command;
   1145            SE_DataTransfer_t out_data =
   1146              SE_DATATRANSFER_DEFAULT(challenge, sizeof(sl_se_challenge_t));
   \                     ??sl_se_get_challenge_0: (+1)
   \        0xE   0xBF00             Nop
   \       0x10   0x....             ADR.N    R0,?_17
   \       0x12   0xE890 0x002C      LDM      R0,{R2,R3,R5}
   \       0x16   0x466E             MOV      R6,SP
   1147          
   1148            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_GET_CHALLENGE);
   \       0x18   0x....             LDR.N    R7,??DataTable53_28
   \       0x1A   0xE886 0x002C      STM      R6,{R2,R3,R5}
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   \       0x20   0x6027             STR      R7,[R4, #+0]
   \       0x22   0x2600             MOVS     R6,#+0
   \       0x24   0x6066             STR      R6,[R4, #+4]
   \       0x26   0x60A6             STR      R6,[R4, #+8]
   \       0x28   0x61E6             STR      R6,[R4, #+28]
   1149          
   1150            SE_addDataOutput(se_cmd, &out_data);
   \       0x2A                      REQUIRE ?Subroutine3
   \       0x2A                      ;; // Fall through to label ?Subroutine3
   1151          
   1152            return sli_se_execute_and_wait(cmd_ctx);
   1153          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1154          
   1155          /***************************************************************************//**
   1156           * Invalidate current challenge and make a new challenge.
   1157           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1158          sl_status_t sl_se_roll_challenge(sl_se_command_context_t *cmd_ctx)
   1159          {
   \                     sl_se_roll_challenge: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   1160            sl_se_challenge_t new_challenge;
   1161            if (cmd_ctx == NULL) {
   \        0x6   0xBF08             IT       EQ
   \        0x8   0x2021             MOVEQ    R0,#+33
   1162              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0xD011             BEQ.N    ??CrossCallReturnLabel_17
   1163            }
   1164          
   1165            SE_DataTransfer_t out_data =
   1166              SE_DATATRANSFER_DEFAULT(new_challenge, sizeof(sl_se_challenge_t));
   \        0xC   0x....             ADR.N    R0,?_18
   \        0xE   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x12   0x466D             MOV      R5,SP
   \       0x14   0xAE03             ADD      R6,SP,#+12
   \       0x16   0xE885 0x000E      STM      R5,{R1-R3}
   \       0x1A   0x9600             STR      R6,[SP, #+0]
   1167          
   1168            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_ROLL_CHALLENGE);
   \       0x1C   0x....             LDR.N    R5,??DataTable53_29
   \       0x1E   0x6025             STR      R5,[R4, #+0]
   \       0x20   0x.... 0x....      BL       ??Subroutine6_0
   1169            SE_addDataOutput(&cmd_ctx->command, &out_data);
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       SE_addDataOutput
   1170          
   1171            return sli_se_execute_and_wait(cmd_ctx);
   \       0x2C   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x30   0xB008             ADD      SP,SP,#+32
   \       0x32   0xBD70             POP      {R4-R6,PC}
   1172          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1173          
   1174          /***************************************************************************//**
   1175           * Unlock debug access using certificate signed with challenge.
   1176           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1177          sl_status_t sl_se_open_debug(sl_se_command_context_t *cmd_ctx,
   1178                                       void *cert, uint32_t len,
   1179                                       const sl_se_debug_options_t *debug_options)
   1180          {
   \                     sl_se_open_debug: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x461D             MOV      R5,R3
   1181            if (cmd_ctx == NULL || cert == NULL || debug_options == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2900             CMPNE    R1,#+0
   \        0xA   0xD000             BEQ.N    ??sl_se_open_debug_0
   \        0xC   0xB90D             CBNZ.N   R5,??sl_se_open_debug_1
   1182              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_open_debug_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \       0x10   0xBDFE             POP      {R1-R7,PC}
   1183            }
   1184          
   1185            SE_Command_t *se_cmd = &cmd_ctx->command;
   1186            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(cert, len);
   \                     ??sl_se_open_debug_1: (+1)
   \       0x12   0xBF00             Nop
   \       0x14   0x....             ADR.N    R0,?_19
   \       0x16   0xE890 0x00C8      LDM      R0,{R3,R6,R7}
   \       0x1A   0x46EE             MOV      LR,SP
   \       0x1C   0xF042 0x5200      ORR      R2,R2,#0x20000000
   \       0x20   0xE88E 0x00C8      STM      LR,{R3,R6,R7}
   \       0x24   0x9100             STR      R1,[SP, #+0]
   \       0x26   0x9202             STR      R2,[SP, #+8]
   1187            uint32_t unlock_bits = 1UL << 1;  // Always request to unlock debug access port
   1188          
   1189            // SE command structures
   1190            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_OPEN_DEBUG);
   \       0x28   0x....             LDR.N    R3,??DataTable53_30
   \       0x2A   0x.... 0x....      BL       ?Subroutine4
   1191          
   1192            SE_addDataInput(se_cmd, &in_data);
   1193          
   1194            /** Encode parameter that holds debug options to unlock. */
   1195            unlock_bits |= debug_options->non_secure_invasive_debug     ? 1UL << 2 : 0;
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2602             MOVS     R6,#+2
   \       0x32   0xB100             CBZ.N    R0,??sl_se_open_debug_2
   \       0x34   0x2606             MOVS     R6,#+6
   1196            unlock_bits |= debug_options->non_secure_non_invasive_debug ? 1UL << 3 : 0;
   \                     ??sl_se_open_debug_2: (+1)
   \       0x36   0x7868             LDRB     R0,[R5, #+1]
   \       0x38   0xB108             CBZ.N    R0,??sl_se_open_debug_3
   \       0x3A   0xF046 0x0608      ORR      R6,R6,#0x8
   1197            unlock_bits |= debug_options->secure_invasive_debug         ? 1UL << 4 : 0;
   \                     ??sl_se_open_debug_3: (+1)
   \       0x3E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x40   0xB108             CBZ.N    R0,??sl_se_open_debug_4
   \       0x42   0xF046 0x0610      ORR      R6,R6,#0x10
   1198            unlock_bits |= debug_options->secure_non_invasive_debug     ? 1UL << 5 : 0;
   \                     ??sl_se_open_debug_4: (+1)
   \       0x46   0x78E8             LDRB     R0,[R5, #+3]
   \       0x48   0xB108             CBZ.N    R0,??sl_se_open_debug_5
   \       0x4A   0xF046 0x0620      ORR      R6,R6,#0x20
   1199          
   1200            SE_addParameter(se_cmd, unlock_bits);
   \                     ??sl_se_open_debug_5: (+1)
   \       0x4E   0x.... 0x....      BL       ?Subroutine7
   1201          
   1202            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x52   0x....             B.N      ??Subroutine14_0
   1203          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x6023             STR      R3,[R4, #+0]
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x6062             STR      R2,[R4, #+4]
   \        0x6   0x60A2             STR      R2,[R4, #+8]
   \        0x8   0x61E2             STR      R2,[R4, #+28]
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1204          
   1205          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
   1206          /***************************************************************************//**
   1207           * Temporarily disable tamper configuration using certificate signed with
   1208           * challenge.
   1209           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1210          sl_status_t sl_se_disable_tamper(sl_se_command_context_t *cmd_ctx,
   1211                                           void *cert,
   1212                                           uint32_t len,
   1213                                           sl_se_tamper_signals_t tamper_signals)
   1214          {
   \                     sl_se_disable_tamper: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x461D             MOV      R5,R3
   1215            if (cmd_ctx == NULL || cert == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2900             CMPNE    R1,#+0
   \        0xA   0xD101             BNE.N    ??sl_se_disable_tamper_0
   1216              return SL_STATUS_INVALID_PARAMETER;
   \        0xC   0x2021             MOVS     R0,#+33
   \        0xE   0xBDFE             POP      {R1-R7,PC}
   1217            }
   1218          
   1219            SE_Command_t *se_cmd = &cmd_ctx->command;
   1220            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(cert, len);
   \                     ??sl_se_disable_tamper_0: (+1)
   \       0x10   0x....             ADR.N    R0,?_20
   \       0x12   0xE890 0x00C8      LDM      R0,{R3,R6,R7}
   \       0x16   0x46EE             MOV      LR,SP
   \       0x18   0xF042 0x5200      ORR      R2,R2,#0x20000000
   \       0x1C   0xE88E 0x00C8      STM      LR,{R3,R6,R7}
   \       0x20   0x9100             STR      R1,[SP, #+0]
   \       0x22   0x9202             STR      R2,[SP, #+8]
   1221          
   1222            // SE command structures
   1223            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DISABLE_TAMPER);
   \       0x24   0x....             LDR.N    R3,??DataTable53_31
   \       0x26   0x.... 0x....      BL       ?Subroutine4
   1224          
   1225            SE_addDataInput(se_cmd, &in_data);
   1226          
   1227            SE_addParameter(se_cmd, tamper_signals);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x.... 0x....      BL       ??Subroutine7_0
   1228          
   1229            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x30   0x....             B.N      ??Subroutine14_0
   1230          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1231          
   1232          #endif
   1233          
   1234          /***************************************************************************//**
   1235           * Read size of stored certificates in SE.
   1236           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1237          sl_status_t sl_se_read_cert_size(sl_se_command_context_t *cmd_ctx,
   1238                                           sl_se_cert_size_type_t *cert_size)
   1239          {
   \                     sl_se_read_cert_size: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1240            if (cmd_ctx == NULL || cert_size == NULL) {
   \        0x4   0xBF14             ITE      NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0x2021             MOVEQ    R0,#+33
   1241              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0xD008             BEQ.N    ??CrossCallReturnLabel_16
   1242            }
   1243            SE_Command_t *se_cmd = &cmd_ctx->command;
   1244          
   1245            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_USER_CERT_SIZE);
   \        0xC   0x....             LDR.N    R3,??DataTable53_32
   \        0xE   0x.... 0x....      BL       ?Subroutine5
   1246          
   1247            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(cert_size, 12UL);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x12   0xBF00             Nop
   \       0x14   0x....             ADR.N    R0,?_21
   \       0x16   0x.... 0x....      BL       ?Subroutine9
   1248            SE_addDataOutput(se_cmd, &out_data);
   1249          
   1250            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x1A   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x1E   0xB004             ADD      SP,SP,#+16
   \       0x20   0xBD70             POP      {R4-R6,PC}
   1251          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C
   1252          
   1253          /***************************************************************************//**
   1254           * Read stored certificates in SE.
   1255           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1256          sl_status_t sl_se_read_cert(sl_se_command_context_t *cmd_ctx,
   1257                                      sl_se_cert_type_t cert_type,
   1258                                      void *cert,
   1259                                      uint32_t num_bytes)
   1260          {
   \                     sl_se_read_cert: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x461E             MOV      R6,R3
   1261            if (cmd_ctx == NULL || cert == NULL || num_bytes == 0UL) {
   \        0x8   0xBF18             IT       NE
   \        0xA   0x2D00             CMPNE    R5,#+0
   \        0xC   0xD01B             BEQ.N    ??sl_se_read_cert_0
   \        0xE   0xB1D6             CBZ.N    R6,??sl_se_read_cert_0
   1262              return SL_STATUS_INVALID_PARAMETER;
   1263            }
   1264            SE_Command_t *se_cmd = &cmd_ctx->command;
   1265            uint32_t se_cert_type;
   1266          
   1267            switch (cert_type) {
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD004             BEQ.N    ??sl_se_read_cert_1
   \       0x14   0xD317             BCC.N    ??sl_se_read_cert_0
   \       0x16   0x2903             CMP      R1,#+3
   \       0x18   0xD013             BEQ.N    ??sl_se_read_cert_2
   \       0x1A   0xD310             BCC.N    ??sl_se_read_cert_3
   \       0x1C   0xE013             B.N      ??sl_se_read_cert_0
   1268              case SL_SE_CERT_BATCH:
   1269                se_cert_type = SLI_SE_COMMAND_CERT_BATCH;
   \                     ??sl_se_read_cert_1: (+1)
   \       0x1E   0x....             LDR.N    R0,??DataTable53_33
   1270                break;
   1271          
   1272              case SL_SE_CERT_DEVICE_SE:
   1273                se_cert_type = SLI_SE_COMMAND_CERT_SE;
   1274                break;
   1275          
   1276              case SL_SE_CERT_DEVICE_HOST:
   1277                se_cert_type = SLI_SE_COMMAND_CERT_HOST;
   1278                break;
   1279          
   1280              default:
   1281                return SL_STATUS_INVALID_PARAMETER;
   1282                break;
   1283            }
   1284          
   1285            // SE command structures
   1286            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READ_USER_CERT | se_cert_type);
   \                     ??sl_se_read_cert_4: (+1)
   \       0x20   0x.... 0x....      BL       ?Subroutine12
   1287          
   1288          #if SLI_MINIMUM_REQUIRED_NUMBER_PARAMS == 1
   1289            // One parameter is required, but has no effect
   1290            SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x24   0x.... 0x....      BL       ??Subroutine7_0
   1291          #endif
   1292          
   1293            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(cert, num_bytes);
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x28   0x....             ADR.N    R0,?_22
   \       0x2A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x2E   0x466F             MOV      R7,SP
   \       0x30   0xF046 0x5600      ORR      R6,R6,#0x20000000
   \       0x34   0xE887 0x000E      STM      R7,{R1-R3}
   \       0x38   0x9500             STR      R5,[SP, #+0]
   \       0x3A   0x9602             STR      R6,[SP, #+8]
   1294            SE_addDataOutput(se_cmd, &out_data);
   \       0x3C   0x....             B.N      ?Subroutine3
   \                     ??sl_se_read_cert_3: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable53_34
   \       0x40   0xE7EE             B.N      ??sl_se_read_cert_4
   \                     ??sl_se_read_cert_2: (+1)
   \       0x42   0x....             LDR.N    R0,??DataTable53_35
   \       0x44   0xE7EC             B.N      ??sl_se_read_cert_4
   \                     ??sl_se_read_cert_0: (+1)
   \       0x46   0x2021             MOVS     R0,#+33
   \       0x48   0xBDFE             POP      {R1-R7,PC}
   1295          
   1296            return sli_se_execute_and_wait(cmd_ctx);
   1297          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1298          
   1299          /***************************************************************************//**
   1300           * Enter active mode.
   1301           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1302          sl_status_t sl_se_enter_active_mode(sl_se_command_context_t *cmd_ctx)
   1303          {
   1304            if (cmd_ctx == NULL) {
   \                     sl_se_enter_active_mode: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_enter_active_mode_0
   1305              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
   1306            }
   1307          
   1308            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_ENTER_ACTIVE_MODE);
   \                     ??sl_se_enter_active_mode_0: (+1)
   \        0x6   0xF04F 0x438A      MOV      R3,#+1157627904
   \        0xA   0x....             B.N      ?Subroutine2
   1309          
   1310            return sli_se_execute_and_wait(cmd_ctx);
   1311          }
   1312          
   1313          /***************************************************************************//**
   1314           * Exit active mode.
   1315           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1316          sl_status_t sl_se_exit_active_mode(sl_se_command_context_t *cmd_ctx)
   1317          {
   1318            if (cmd_ctx == NULL) {
   \                     sl_se_exit_active_mode: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_exit_active_mode_0
   1319              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
   1320            }
   1321          
   1322            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_EXIT_ACTIVE_MODE);
   \                     ??sl_se_exit_active_mode_0: (+1)
   \        0x6   0x....             LDR.N    R3,??DataTable53_36
   \        0x8   0x....             B.N      ?Subroutine2
   1323          
   1324            return sli_se_execute_and_wait(cmd_ctx);
   1325          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \        0x0   0x4302'0000        DC32     0x43020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \        0x0   0x4303'0000        DC32     0x43030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_2:
   \        0x0   0x4304'0000        DC32     0x43040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_3:
   \        0x0   0x4305'0001        DC32     0x43050001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_4:
   \        0x0   0x4306'0001        DC32     0x43060001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_5:
   \        0x0   0x4307'0000        DC32     0x43070000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_6:
   \        0x0   0xFF0B'0001        DC32     0xff0b0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_7:
   \        0x0   0xFF07'0001        DC32     0xff070001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_8:
   \        0x0   0xFF08'0001        DC32     0xff080001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_9:
   \        0x0   0x2000'0040        DC32     0x20000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_10:
   \        0x0   0xFF08'0000        DC32     0xff080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_11:
   \        0x0   0x4308'0000        DC32     0x43080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_12:
   \        0x0   0x430C'0000        DC32     0x430c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_13:
   \        0x0   0x4311'0000        DC32     0x43110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_14:
   \        0x0   0x....'....        DC32     `sl_se_init_otp::otp_tamper_settings`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_15:
   \        0x0   0xFF00'0001        DC32     0xff000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_16:
   \        0x0   0xFE04'0000        DC32     0xfe040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_17:
   \        0x0   0x4309'0000        DC32     0x43090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_18:
   \        0x0   0x430A'0000        DC32     0x430a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_19:
   \        0x0   0xDE1E'7EAD        DC32     0xde1e7ead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_20:
   \        0x0   0xFE01'0000        DC32     0xfe010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_21:
   \        0x0   0x4308'0100        DC32     0x43080100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_22:
   \        0x0   0xFE05'0000        DC32     0xfe050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_23:
   \        0x0   0x430D'0000        DC32     0x430d0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_24:
   \        0x0   0x430E'0000        DC32     0x430e0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_25:
   \        0x0   0x4312'0000        DC32     0x43120000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_26:
   \        0x0   0x430F'0000        DC32     0x430f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_27:
   \        0x0   0x4310'0000        DC32     0x43100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_28:
   \        0x0   0xFD00'0001        DC32     0xfd000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_29:
   \        0x0   0xFD00'0101        DC32     0xfd000101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_30:
   \        0x0   0xFD01'0001        DC32     0xfd010001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_31:
   \        0x0   0xFD02'0001        DC32     0xfd020001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_32:
   \        0x0   0x43FA'0000        DC32     0x43fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_33:
   \        0x0   0x43FB'0100        DC32     0x43fb0100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_34:
   \        0x0   0x43FB'0200        DC32     0x43fb0200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_35:
   \        0x0   0x43FB'0300        DC32     0x43fb0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_36:
   \        0x0   0x4501'0000        DC32     0x45010000
   1326          
   1327          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)
   1328          
   1329          /// @} (end addtogroup sl_se)
   1330          
   1331          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED) || defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   decode_debug_status
       0   sl_se_apply_debug_lock
         0   -> sli_se_execute_and_wait
      16   sl_se_apply_host_image
        16   -> SE_addParameter
         0   -> sli_se_execute_and_wait
       8   sl_se_apply_se_image
         8   -> SE_addParameter
         0   -> sli_se_execute_and_wait
      16   sl_se_check_host_image
        16   -> SE_addParameter
         0   -> sli_se_execute_and_wait
       8   sl_se_check_se_image
         8   -> SE_addParameter
         0   -> sli_se_execute_and_wait
       0   sl_se_disable_device_erase
         0   -> sli_se_execute_and_wait
       0   sl_se_disable_secure_debug
         0   -> sli_se_execute_and_wait
      32   sl_se_disable_tamper
        32   -> SE_addDataInput
        32   -> SE_addParameter
        32   -> sli_se_execute_and_wait
       0   sl_se_enable_secure_debug
         0   -> sli_se_execute_and_wait
       0   sl_se_enter_active_mode
         0   -> sli_se_execute_and_wait
       0   sl_se_erase_device
         0   -> sli_se_execute_and_wait
       8   sl_se_erase_user_data
         8   -> SE_addParameter
         0   -> sli_se_execute_and_wait
       0   sl_se_exit_active_mode
         0   -> sli_se_execute_and_wait
      32   sl_se_get_challenge
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      40   sl_se_get_debug_lock_status
        40   -> SE_addDataOutput
        40   -> decode_debug_status
        40   -> sli_se_execute_and_wait
      32   sl_se_get_otp_version
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      32   sl_se_get_se_version
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      32   sl_se_get_serialnumber
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      72   sl_se_get_status
        72   -> SE_addDataOutput
        72   -> __aeabi_memset
        72   -> decode_debug_status
        72   -> sli_se_execute_and_wait
      40   sl_se_get_tamper_reset_cause
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
      40   sl_se_get_upgrade_status_host_image
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
      40   sl_se_get_upgrade_status_se_image
        40   -> SE_addDataOutput
        40   -> sli_se_execute_and_wait
     136   sl_se_init_otp
       136   -> SE_addDataInput
       136   -> sl_se_read_pubkey
       136   -> sli_se_execute_and_wait
      48   sl_se_init_otp_key
        48   -> SE_addDataInput
        48   -> sli_se_execute_and_wait
      32   sl_se_open_debug
        32   -> SE_addDataInput
        32   -> SE_addParameter
        32   -> sli_se_execute_and_wait
      32   sl_se_read_cert
        32   -> SE_addDataOutput
        32   -> SE_addParameter
        32   -> sli_se_execute_and_wait
      32   sl_se_read_cert_size
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      56   sl_se_read_otp
        56   -> SE_addDataOutput
        56   -> sli_se_execute_and_wait
      32   sl_se_read_pubkey
        32   -> SE_addDataOutput
        32   -> sli_se_execute_and_wait
      48   sl_se_roll_challenge
        48   -> SE_addDataOutput
        48   -> sli_se_execute_and_wait
      16   sl_se_set_debug_options
        16   -> SE_addParameter
         0   -> sli_se_execute_and_wait
      32   sl_se_write_user_data
        32   -> SE_addDataInput
        32   -> SE_addParameter
        32   -> sli_se_execute_and_wait


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_10
       4  ??DataTable53_11
       4  ??DataTable53_12
       4  ??DataTable53_13
       4  ??DataTable53_14
       4  ??DataTable53_15
       4  ??DataTable53_16
       4  ??DataTable53_17
       4  ??DataTable53_18
       4  ??DataTable53_19
       4  ??DataTable53_2
       4  ??DataTable53_20
       4  ??DataTable53_21
       4  ??DataTable53_22
       4  ??DataTable53_23
       4  ??DataTable53_24
       4  ??DataTable53_25
       4  ??DataTable53_26
       4  ??DataTable53_27
       4  ??DataTable53_28
       4  ??DataTable53_29
       4  ??DataTable53_3
       4  ??DataTable53_30
       4  ??DataTable53_31
       4  ??DataTable53_32
       4  ??DataTable53_33
       4  ??DataTable53_34
       4  ??DataTable53_35
       4  ??DataTable53_36
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable53_7
       4  ??DataTable53_8
       4  ??DataTable53_9
      14  ??Subroutine13_0
       8  ??Subroutine14_0
      10  ?Subroutine0
      18  ?Subroutine1
       6  ?Subroutine10
      12  ?Subroutine11
      12  ?Subroutine12
      14  ?Subroutine2
       8  ?Subroutine3
      18  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
       8  ?Subroutine7
      14  ?Subroutine8
      20  ?Subroutine9
      12  ?_0
      12  ?_1
      12  ?_10
      12  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      12  ?_2
      12  ?_20
      12  ?_21
      12  ?_22
      12  ?_3
      12  ?_4
      12  ?_5
      12  ?_6
       8  ?_7
      12  ?_8
      12  ?_9
     128  decode_debug_status
      20  otp_tamper_settings
      12  sl_se_apply_debug_lock
      22  sl_se_apply_host_image
      18  sl_se_apply_se_image
      24  sl_se_check_host_image
      20  sl_se_check_se_image
      10  sl_se_disable_device_erase
      10  sl_se_disable_secure_debug
      50  sl_se_disable_tamper
       8  sl_se_enable_secure_debug
      12  sl_se_enter_active_mode
      10  sl_se_erase_device
      26  sl_se_erase_user_data
      10  sl_se_exit_active_mode
      42  sl_se_get_challenge
      84  sl_se_get_debug_lock_status
      34  sl_se_get_otp_version
      36  sl_se_get_se_version
      36  sl_se_get_serialnumber
     148  sl_se_get_status
     102  sl_se_get_tamper_reset_cause
      68  sl_se_get_upgrade_status_host_image
      68  sl_se_get_upgrade_status_se_image
     374  sl_se_init_otp
     180  sl_se_init_otp_key
      84  sl_se_open_debug
      74  sl_se_read_cert
      34  sl_se_read_cert_size
     176  sl_se_read_otp
      92  sl_se_read_pubkey
      52  sl_se_roll_challenge
      60  sl_se_set_debug_options
      68  sl_se_write_user_data

 
    20 bytes in section .bss
 2'778 bytes in section .text
 
 2'778 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
