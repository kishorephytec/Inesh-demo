###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:18:00
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_cipher.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_cipher.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_cipher.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_cipher.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir\sl_se_manager_cipher.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_cipher.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_cipher.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager.h"
     32          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
     33          
     34          #include "sli_se_manager_internal.h"
     35          #include "em_se.h"
     36          #include "sl_assert.h"
     37          #include <string.h>
     38          
     39          /// @addtogroup sl_se_manager
     40          /// @{
     41          

   \                                 In section .text, align 2, keep-with-next
     42          uint32_t memcmp_time_cst(uint8_t *in1, uint8_t *in2, uint32_t size)
     43          {
   \                     memcmp_time_cst: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
     44            //Don't try to optimise this function for performance, it's time constant for security reasons
     45            uint32_t diff = 0;
   \        0x2   0x2300             MOVS     R3,#+0
     46            uint32_t i = 0;
   \        0x4   0x2500             MOVS     R5,#+0
     47            for (i = 0; i < size; i++) {
   \        0x6   0xE004             B.N      ??memcmp_time_cst_0
     48              diff |= (*(in1 + i) ^ (*(in2 + i)));
   \                     ??memcmp_time_cst_1: (+1)
   \        0x8   0x5D46             LDRB     R6,[R0, R5]
   \        0xA   0x5D4C             LDRB     R4,[R1, R5]
     49            }
   \        0xC   0x1C6D             ADDS     R5,R5,#+1
   \        0xE   0x4066             EORS     R6,R4,R6
   \       0x10   0x4333             ORRS     R3,R6,R3
   \                     ??memcmp_time_cst_0: (+1)
   \       0x12   0x4295             CMP      R5,R2
   \       0x14   0xD3F8             BCC.N    ??memcmp_time_cst_1
     50          
     51            return (diff > 0);
   \       0x16   0x0018             MOVS     R0,R3
   \       0x18   0xBF18             IT       NE
   \       0x1A   0x2001             MOVNE    R0,#+1
   \       0x1C   0xBD70             POP      {R4-R6,PC}
     52          }
     53          
     54          // -----------------------------------------------------------------------------
     55          // Global Functions
     56          
     57          /***************************************************************************//**
     58           * AES-ECB block encryption/decryption.
     59           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     60          sl_status_t sl_se_aes_crypt_ecb(sl_se_command_context_t *cmd_ctx,
     61                                          const sl_se_key_descriptor_t *key,
     62                                          sl_se_cipher_operation_t mode,
     63                                          size_t length,
     64                                          const unsigned char *input,
     65                                          unsigned char *output)
     66          {
   \                     sl_se_aes_crypt_ecb: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460F             MOV      R7,R1
   \        0xA   0x4698             MOV      R8,R3
     67            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
     68                || (length & 0xFU) != 0U) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2F00             CMPNE    R7,#+0
   \       0x10   0xD008             BEQ.N    ??sl_se_aes_crypt_ecb_0
   \       0x12   0x9E12             LDR      R6,[SP, #+72]
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x9D13             LDRNE    R5,[SP, #+76]
   \       0x1A   0x2D00             CMPNE    R5,#+0
   \       0x1C   0xD002             BEQ.N    ??sl_se_aes_crypt_ecb_0
   \       0x1E   0xF018 0x0F0F      TST      R8,#0xF
   \       0x22   0xD001             BEQ.N    ??sl_se_aes_crypt_ecb_1
     69              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_ecb_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE031             B.N      ??CrossCallReturnLabel_120
     70            }
     71          
     72            SE_Command_t *se_cmd = &cmd_ctx->command;
     73            sl_status_t status;
     74          
     75            sli_se_command_init(cmd_ctx,
     76                                (mode == SL_SE_ENCRYPT
     77                                 ? SLI_SE_COMMAND_AES_ENCRYPT : SLI_SE_COMMAND_AES_DECRYPT)
     78                                | SLI_SE_COMMAND_OPTION_MODE_ECB
     79                                | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \                     ??sl_se_aes_crypt_ecb_1: (+1)
   \       0x28   0x2A00             CMP      R2,#+0
   \       0x2A   0xBF0C             ITE      EQ
   \       0x2C   0x.... 0x....      LDREQ.W  R0,??DataTable112
   \       0x30   0x.... 0x....      LDRNE.W  R0,??DataTable112_1
   \       0x34   0x.... 0x....      BL       ?Subroutine8
     80          
     81            // Add key parameters to command
     82            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD124             BNE.N    ??CrossCallReturnLabel_120
   \       0x42   0x.... 0x....      BL       ?Subroutine17
     83            // Message size (number of bytes)
     84            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x46   0x.... 0x....      BL       ?Subroutine21
     85          
     86            // Add key metadata block to command
     87            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_100: (+1)
   \       0x4A   0x.... 0x....      BL       ?Subroutine27
   \                     ??CrossCallReturnLabel_156: (+1)
   \       0x4E   0xB9E8             CBNZ.N   R0,??CrossCallReturnLabel_120
   \       0x50   0xA909             ADD      R1,SP,#+36
   \       0x52   0x.... 0x....      BL       ??Subroutine20_1
     88            // Add key input block to command
     89            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x56   0x.... 0x....      BL       ?Subroutine36
   \                     ??CrossCallReturnLabel_228: (+1)
   \       0x5A   0xB9B8             CBNZ.N   R0,??CrossCallReturnLabel_120
   \       0x5C   0xA906             ADD      R1,SP,#+24
   \       0x5E   0x.... 0x....      BL       ??Subroutine20_1
     90          
     91            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0x62   0xBF00             Nop
   \       0x64   0x....             ADR.N    R0,?_0
   \       0x66   0x.... 0x....      BL       ?Subroutine34
   \                     ??CrossCallReturnLabel_220: (+1)
   \       0x6A   0x9603             STR      R6,[SP, #+12]
   \       0x6C   0x.... 0x....      BL       ?Subroutine20
     92            SE_addDataInput(se_cmd, &in);
     93          
     94            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x70   0x....             ADR.N    R1,?_1
   \       0x72   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x76   0x4668             MOV      R0,SP
     95            SE_addDataOutput(se_cmd, &out);
   \       0x78   0x4669             MOV      R1,SP
   \       0x7A   0xE880 0x004C      STM      R0,{R2,R3,R6}
   \       0x7E   0x9500             STR      R5,[SP, #+0]
   \       0x80   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x84   0x.... 0x....      BL       ?Subroutine22
     96          
     97            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_110: (+1)
   \       0x88   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_120: (+1)
   \       0x8C   0x.... 0x....      B.W      ?Subroutine0
     98          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \        0x0   0xA906             ADD      R1,SP,#+24
   \                     ??Subroutine36_0: (+1)
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      sli_se_get_key_input_output

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \        0x0   0xA909             ADD      R1,SP,#+36
   \                     ??Subroutine27_0: (+1)
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      sli_se_get_auth_buffer

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x6020             STR      R0,[R4, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6060             STR      R0,[R4, #+4]
   \        0x6   0x60A0             STR      R0,[R4, #+8]
   \        0x8   0x61E0             STR      R0,[R4, #+28]
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x9900             LDR      R1,[SP, #+0]
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB00C             ADD      SP,SP,#+48
   \        0x2   0xE8BD 0x81F0      POP      {R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \        0x0   0xE890 0x000E      LDM      R0,{R1-R3}
   \        0x4   0xAF03             ADD      R7,SP,#+12
   \        0x6   0xF048 0x5800      ORR      R8,R8,#0x20000000
   \        0xA   0xE887 0x000E      STM      R7,{R1-R3}
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \                     ??Subroutine20_0: (+1)
   \        0x4   0xA903             ADD      R1,SP,#+12
   \                     ??Subroutine20_1: (+1)
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \                     ??Subroutine21_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
     99          
    100          /***************************************************************************//**
    101           * AES-CBC buffer encryption/decryption.
    102           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    103          sl_status_t sl_se_aes_crypt_cbc(sl_se_command_context_t *cmd_ctx,
    104                                          const sl_se_key_descriptor_t *key,
    105                                          sl_se_cipher_operation_t mode,
    106                                          size_t length,
    107                                          unsigned char iv[16],
    108                                          const unsigned char *input,
    109                                          unsigned char *output)
    110          {
   \                     sl_se_aes_crypt_cbc: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4698             MOV      R8,R3
    111            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
    112                || iv == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x12   0xD00A             BEQ.N    ??sl_se_aes_crypt_cbc_0
   \       0x14   0x9D1D             LDR      R5,[SP, #+116]
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xBF1C             ITT      NE
   \       0x1A   0x9E1E             LDRNE    R6,[SP, #+120]
   \       0x1C   0x2E00             CMPNE    R6,#+0
   \       0x1E   0xD004             BEQ.N    ??sl_se_aes_crypt_cbc_0
   \       0x20   0x9F1C             LDR      R7,[SP, #+112]
   \       0x22   0xB117             CBZ.N    R7,??sl_se_aes_crypt_cbc_0
    113              return SL_STATUS_INVALID_PARAMETER;
    114            }
    115          
    116            SE_Command_t *se_cmd = &cmd_ctx->command;
    117            sl_status_t status;
    118          
    119            // Input length must be a multiple of 16 bytes which is the AES block length
    120            if (length & 0xf) {
   \       0x24   0xF018 0x0F0F      TST      R8,#0xF
   \       0x28   0xD001             BEQ.N    ??sl_se_aes_crypt_cbc_1
    121              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_cbc_0: (+1)
   \       0x2A   0x2021             MOVS     R0,#+33
   \       0x2C   0xE053             B.N      ??CrossCallReturnLabel_119
    122            }
    123          
    124            sli_se_command_init(cmd_ctx,
    125                                (mode == SL_SE_ENCRYPT
    126                                 ? SLI_SE_COMMAND_AES_ENCRYPT : SLI_SE_COMMAND_AES_DECRYPT)
    127                                | SLI_SE_COMMAND_OPTION_MODE_CBC
    128                                | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \                     ??sl_se_aes_crypt_cbc_1: (+1)
   \       0x2E   0x2A00             CMP      R2,#+0
   \       0x30   0xBF0C             ITE      EQ
   \       0x32   0x.... 0x....      LDREQ.W  R0,??DataTable112_2
   \       0x36   0x.... 0x....      LDRNE.W  R0,??DataTable112_3
   \       0x3A   0x.... 0x....      BL       ?Subroutine8
    129          
    130            // Add key parameters to command
    131            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x3E   0x.... 0x....      BL       ??Subroutine16_0
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD147             BNE.N    ??CrossCallReturnLabel_119
   \       0x46   0x.... 0x....      BL       ?Subroutine17
    132            // Message size (number of bytes)
    133            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x4A   0x.... 0x....      BL       ?Subroutine21
    134          
    135            // Add key metadata block to command
    136            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_99: (+1)
   \       0x4E   0xA90F             ADD      R1,SP,#+60
   \       0x50   0x4648             MOV      R0,R9
   \       0x52   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD13D             BNE.N    ??CrossCallReturnLabel_119
   \       0x5A   0xA90F             ADD      R1,SP,#+60
   \       0x5C   0x.... 0x....      BL       ??Subroutine20_1
    137            // Add key input block to command
    138            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0x60   0xA90C             ADD      R1,SP,#+48
   \       0x62   0x4648             MOV      R0,R9
   \       0x64   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD134             BNE.N    ??CrossCallReturnLabel_119
   \       0x6C   0xA90C             ADD      R1,SP,#+48
   \       0x6E   0x.... 0x....      BL       ??Subroutine20_1
    139          
    140            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, 16);
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0x72   0xBF00             Nop
   \       0x74   0x....             ADR.N    R0,?_2
   \       0x76   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x7A   0xF10D 0x0E24      ADD      LR,SP,#+36
    141            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0x7E   0xA806             ADD      R0,SP,#+24
   \       0x80   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0x84   0xF8CD 0x7024      STR.W    R7,[SP, #+36]
   \       0x88   0x....             ADR.N    R1,?_3
   \       0x8A   0xE891 0x0E00      LDM      R1,{R9-R11}
   \       0x8E   0xF048 0x5800      ORR      R8,R8,#0x20000000
    142            SE_addDataInput(se_cmd, &iv_in);
   \       0x92   0xA909             ADD      R1,SP,#+36
   \       0x94   0xE880 0x0E00      STM      R0,{R9-R11}
   \       0x98   0x9506             STR      R5,[SP, #+24]
   \       0x9A   0xF8CD 0x8020      STR      R8,[SP, #+32]
   \       0x9E   0x.... 0x....      BL       ??Subroutine20_1
    143            SE_addDataInput(se_cmd, &in);
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0xA2   0xA906             ADD      R1,SP,#+24
   \       0xA4   0x.... 0x....      BL       ??Subroutine20_1
    144          
    145            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0xA8   0x....             ADR.N    R1,?_4
   \       0xAA   0xE891 0x002C      LDM      R1,{R2,R3,R5}
   \       0xAE   0xA803             ADD      R0,SP,#+12
    146            SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(iv, 16);
   \       0xB0   0x....             ADR.N    R1,?_5
   \       0xB2   0xE880 0x002C      STM      R0,{R2,R3,R5}
   \       0xB6   0x9603             STR      R6,[SP, #+12]
   \       0xB8   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \       0xBC   0xE891 0x002C      LDM      R1,{R2,R3,R5}
   \       0xC0   0x466E             MOV      R6,SP
    147            SE_addDataOutput(se_cmd, &out);
   \       0xC2   0xA903             ADD      R1,SP,#+12
   \       0xC4   0xE886 0x002C      STM      R6,{R2,R3,R5}
   \       0xC8   0x9700             STR      R7,[SP, #+0]
   \       0xCA   0x.... 0x....      BL       ?Subroutine22
    148            SE_addDataOutput(se_cmd, &iv_out);
   \                     ??CrossCallReturnLabel_109: (+1)
   \       0xCE   0x.... 0x....      BL       ?Subroutine11
    149          
    150            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xD2   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_119: (+1)
   \       0xD6   0x.... 0x....      B.W      ?Subroutine1
    151          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB013             ADD      SP,SP,#+76
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \                     ??Subroutine16_0: (+1)
   \        0x2   0x4648             MOV      R0,R9
   \        0x4   0x.... 0x....      B.W      sli_se_key_to_keyspec

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    152          
    153          /***************************************************************************//**
    154           * AES-CFB128 buffer encryption/decryption.
    155           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    156          sl_status_t sl_se_aes_crypt_cfb128(sl_se_command_context_t *cmd_ctx,
    157                                             const sl_se_key_descriptor_t *key,
    158                                             sl_se_cipher_operation_t mode,
    159                                             size_t length,
    160                                             uint32_t *iv_off,
    161                                             unsigned char iv[16],
    162                                             const unsigned char *input,
    163                                             unsigned char *output)
    164          {
   \                     sl_se_aes_crypt_cfb128: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
    165            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
    166                || iv == NULL) {
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xBF18             IT       NE
   \        0xA   0xEA5F 0x0B01      MOVSNE   R11,R1
   \        0xE   0xD009             BEQ.N    ??sl_se_aes_crypt_cfb128_0
   \       0x10   0x9F20             LDR      R7,[SP, #+128]
   \       0x12   0x2F00             CMP      R7,#+0
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0xF8DD 0x8084      LDRNE    R8,[SP, #+132]
   \       0x1A   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x1E   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb128_0
   \       0x20   0x9E1F             LDR      R6,[SP, #+124]
   \       0x22   0xB90E             CBNZ.N   R6,??sl_se_aes_crypt_cfb128_1
    167              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_cfb128_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \       0x26   0xE0C8             B.N      ??sl_se_aes_crypt_cfb128_2
    168            }
    169          
    170            SE_Command_t *se_cmd = &cmd_ctx->command;
    171            uint32_t n = iv_off ? *iv_off : 0;
   \                     ??sl_se_aes_crypt_cfb128_1: (+1)
   \       0x28   0x981E             LDR      R0,[SP, #+120]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xBF14             ITE      NE
   \       0x2E   0x6804             LDRNE    R4,[R0, #+0]
   \       0x30   0x2400             MOVEQ    R4,#+0
    172            uint32_t processed = 0;
   \       0x32   0xF04F 0x0900      MOV      R9,#+0
    173            sl_status_t command_status = SL_STATUS_OK;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \       0x3C   0x9301             STR      R3,[SP, #+4]
   \       0x3E   0xE00C             B.N      ??sl_se_aes_crypt_cfb128_3
    174          
    175            while (processed < length) {
    176              if (n > 0) {
    177                // start by filling up the IV
    178                if (mode == SL_SE_ENCRYPT) {
    179                  iv[n] = output[processed] = (unsigned char)(iv[n] ^ input[processed]);
    180                } else {
    181                  int c = input[processed];
   \                     ??sl_se_aes_crypt_cfb128_4: (+1)
   \       0x40   0xF817 0x1009      LDRB     R1,[R7, R9]
    182                  output[processed] = (unsigned char)(c ^ iv[n]);
   \       0x44   0x5D32             LDRB     R2,[R6, R4]
   \       0x46   0x404A             EORS     R2,R2,R1
   \       0x48   0xF808 0x2009      STRB     R2,[R8, R9]
    183                  iv[n] = (unsigned char) c;
   \                     ??sl_se_aes_crypt_cfb128_5: (+1)
   \       0x4C   0x5531             STRB     R1,[R6, R4]
    184                }
    185                n = (n + 1) & 0x0F;
   \       0x4E   0x.... 0x....      BL       ?Subroutine43
    186                processed++;
   \                     ??CrossCallReturnLabel_264: (+1)
   \       0x52   0xE002             B.N      ??sl_se_aes_crypt_cfb128_3
    187              } else {
    188                // process one ore more blocks of data
    189                uint32_t iterations = (length - processed) / 16;
    190          
    191                if (iterations > 0) {
    192                  sli_se_command_init(cmd_ctx,
    193                                      (mode == SL_SE_ENCRYPT
    194                                       ? SLI_SE_COMMAND_AES_ENCRYPT : SLI_SE_COMMAND_AES_DECRYPT)
    195                                      | SLI_SE_COMMAND_OPTION_MODE_CFB
    196                                      | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
    197          
    198                  // Add key parameters to command
    199                  sli_add_key_parameters(cmd_ctx, key, command_status);
    200                  // Message size (number of bytes)
    201                  SE_addParameter(se_cmd, iterations * 16);
    202          
    203                  // Add key metadata block to command
    204                  sli_add_key_metadata(cmd_ctx, key, command_status);
    205                  // Add key input block to command
    206                  sli_add_key_input(cmd_ctx, key, command_status);
    207          
    208                  SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, 16);
    209                  SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(&input[processed], iterations * 16);
    210                  SE_addDataInput(se_cmd, &iv_in);
    211                  SE_addDataInput(se_cmd, &in);
    212          
    213                  SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(&output[processed], iterations * 16);
    214                  SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(iv, 16);
    215                  SE_addDataOutput(se_cmd, &out);
    216                  SE_addDataOutput(se_cmd, &iv_out);
    217          
    218                  command_status = sli_se_execute_and_wait(cmd_ctx);
    219                  processed += iterations * 16;
    220                  if (command_status != SL_STATUS_OK) {
    221                    return command_status;
    222                  }
    223                }
    224          
    225                while ((length - processed) > 0) {
   \                     ??sl_se_aes_crypt_cfb128_6: (+1)
   \       0x54   0xF88D 0xA000      STRB     R10,[SP, #+0]
   \       0x58   0x9501             STR      R5,[SP, #+4]
   \                     ??sl_se_aes_crypt_cfb128_3: (+1)
   \       0x5A   0x9A01             LDR      R2,[SP, #+4]
   \       0x5C   0x4591             CMP      R9,R2
   \       0x5E   0xF080 0x80A9      BCS.W    ??sl_se_aes_crypt_cfb128_7
   \       0x62   0xB154             CBZ.N    R4,??sl_se_aes_crypt_cfb128_8
   \       0x64   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD1E9             BNE.N    ??sl_se_aes_crypt_cfb128_4
   \       0x6C   0x5D32             LDRB     R2,[R6, R4]
   \       0x6E   0xF817 0x1009      LDRB     R1,[R7, R9]
   \       0x72   0x4051             EORS     R1,R1,R2
   \       0x74   0xF808 0x1009      STRB     R1,[R8, R9]
   \       0x78   0xE7E8             B.N      ??sl_se_aes_crypt_cfb128_5
   \                     ??sl_se_aes_crypt_cfb128_8: (+1)
   \       0x7A   0xEBA2 0x0509      SUB      R5,R2,R9
   \       0x7E   0x092D             LSRS     R5,R5,#+4
   \       0x80   0xD073             BEQ.N    ??sl_se_aes_crypt_cfb128_9
   \       0x82   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xBF0C             ITE      EQ
   \       0x8A   0x.... 0x....      LDREQ.W  R0,??DataTable113
   \       0x8E   0x.... 0x....      LDRNE.W  R0,??DataTable113_1
   \       0x92   0x9914             LDR      R1,[SP, #+80]
   \       0x94   0x6008             STR      R0,[R1, #+0]
   \       0x96   0x9A14             LDR      R2,[SP, #+80]
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0x6050             STR      R0,[R2, #+4]
   \       0x9E   0x9814             LDR      R0,[SP, #+80]
   \       0xA0   0x6081             STR      R1,[R0, #+8]
   \       0xA2   0x9814             LDR      R0,[SP, #+80]
   \       0xA4   0x61C1             STR      R1,[R0, #+28]
   \       0xA6   0xA902             ADD      R1,SP,#+8
   \       0xA8   0x4658             MOV      R0,R11
   \       0xAA   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD10D             BNE.N    ??sl_se_aes_crypt_cfb128_10
   \       0xB2   0x9902             LDR      R1,[SP, #+8]
   \       0xB4   0x9814             LDR      R0,[SP, #+80]
   \       0xB6   0x012D             LSLS     R5,R5,#+4
   \       0xB8   0x.... 0x....      BL       SE_addParameter
   \       0xBC   0x9814             LDR      R0,[SP, #+80]
   \       0xBE   0x4629             MOV      R1,R5
   \       0xC0   0x.... 0x....      BL       SE_addParameter
   \       0xC4   0xA911             ADD      R1,SP,#+68
   \       0xC6   0x4658             MOV      R0,R11
   \       0xC8   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xCC   0x2800             CMP      R0,#+0
   \                     ??sl_se_aes_crypt_cfb128_10: (+1)
   \       0xCE   0xD174             BNE.N    ??sl_se_aes_crypt_cfb128_2
   \       0xD0   0x9814             LDR      R0,[SP, #+80]
   \       0xD2   0xA911             ADD      R1,SP,#+68
   \       0xD4   0x.... 0x....      BL       SE_addDataInput
   \       0xD8   0xA90E             ADD      R1,SP,#+56
   \       0xDA   0x4658             MOV      R0,R11
   \       0xDC   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD16A             BNE.N    ??sl_se_aes_crypt_cfb128_2
   \       0xE4   0x9814             LDR      R0,[SP, #+80]
   \       0xE6   0xA90E             ADD      R1,SP,#+56
   \       0xE8   0x.... 0x....      BL       SE_addDataInput
   \       0xEC   0x.... 0x....      ADR.W    LR,?_6
   \       0xF0   0xE89E 0x0007      LDM      LR,{R0-R2}
   \       0xF4   0xAB0B             ADD      R3,SP,#+44
   \       0xF6   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xFA   0x960B             STR      R6,[SP, #+44]
   \       0xFC   0x....             ADR.N    R2,?_7
   \       0xFE   0xE892 0x0409      LDM      R2,{R0,R3,R10}
   \      0x102   0xA908             ADD      R1,SP,#+32
   \      0x104   0xE881 0x0409      STM      R1,{R0,R3,R10}
   \      0x108   0xEB07 0x0309      ADD      R3,R7,R9
   \      0x10C   0x9308             STR      R3,[SP, #+32]
   \      0x10E   0xF045 0x5A00      ORR      R10,R5,#0x20000000
   \      0x112   0xF8CD 0xA028      STR      R10,[SP, #+40]
   \      0x116   0x9814             LDR      R0,[SP, #+80]
   \      0x118   0xA90B             ADD      R1,SP,#+44
   \      0x11A   0x.... 0x....      BL       SE_addDataInput
   \      0x11E   0x9814             LDR      R0,[SP, #+80]
   \      0x120   0xA908             ADD      R1,SP,#+32
   \      0x122   0x.... 0x....      BL       SE_addDataInput
   \      0x126   0xBF00             Nop
   \      0x128   0x....             ADR.N    R1,?_8
   \      0x12A   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x12E   0xA805             ADD      R0,SP,#+20
   \      0x130   0xEB08 0x0109      ADD      R1,R8,R9
   \      0x134   0xE880 0x400C      STM      R0,{R2,R3,LR}
   \      0x138   0x9105             STR      R1,[SP, #+20]
   \      0x13A   0xBF00             Nop
   \      0x13C   0x....             ADR.N    R1,?_9
   \      0x13E   0xF8CD 0xA01C      STR      R10,[SP, #+28]
   \      0x142   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x146   0xF10D 0x0A08      ADD      R10,SP,#+8
   \      0x14A   0xA905             ADD      R1,SP,#+20
   \      0x14C   0xE88A 0x400C      STM      R10,{R2,R3,LR}
   \      0x150   0x9602             STR      R6,[SP, #+8]
   \      0x152   0x9814             LDR      R0,[SP, #+80]
   \      0x154   0x44A9             ADD      R9,R5,R9
   \      0x156   0x.... 0x....      BL       SE_addDataOutput
   \      0x15A   0x9814             LDR      R0,[SP, #+80]
   \      0x15C   0xA902             ADD      R1,SP,#+8
   \      0x15E   0x.... 0x....      BL       SE_addDataOutput
   \      0x162   0x9814             LDR      R0,[SP, #+80]
   \      0x164   0x.... 0x....      BL       sli_se_execute_and_wait
   \      0x168   0xBB38             CBNZ.N   R0,??sl_se_aes_crypt_cfb128_2
   \                     ??sl_se_aes_crypt_cfb128_9: (+1)
   \      0x16A   0xE004             B.N      ??sl_se_aes_crypt_cfb128_11
    226                  if (n == 0) {
    227                    // Need to update the IV but don't have a full block of input to pass
    228                    // to the SE.
    229                    command_status = sl_se_aes_crypt_ecb(cmd_ctx, key, SL_SE_ENCRYPT, 16U, iv, iv);
    230                    if (command_status != SL_STATUS_OK) {
    231                      return command_status;
    232                    }
    233                  }
    234                  // Save remainder to IV
    235                  if (mode == SL_SE_ENCRYPT) {
    236                    iv[n] = output[processed] = (unsigned char)(iv[n] ^ input[processed]);
    237                  } else {
    238                    int c = input[processed];
   \                     ??sl_se_aes_crypt_cfb128_12: (+1)
   \      0x16C   0xF817 0x2009      LDRB     R2,[R7, R9]
    239                    output[processed] = (unsigned char)(c ^ iv[n]);
   \      0x170   0x5D31             LDRB     R1,[R6, R4]
   \      0x172   0x4051             EORS     R1,R1,R2
    240                    iv[n] = (unsigned char) c;
   \      0x174   0xE018             B.N      ??sl_se_aes_crypt_cfb128_13
    241                  }
   \                     ??sl_se_aes_crypt_cfb128_11: (+1)
   \      0x176   0xF89D 0xA000      LDRB     R10,[SP, #+0]
   \      0x17A   0x9D01             LDR      R5,[SP, #+4]
   \                     ??sl_se_aes_crypt_cfb128_14: (+1)
   \      0x17C   0xEBB5 0x0109      SUBS     R1,R5,R9
   \      0x180   0xF43F 0xAF68      BEQ.W    ??sl_se_aes_crypt_cfb128_6
   \      0x184   0xB944             CBNZ.N   R4,??sl_se_aes_crypt_cfb128_15
   \      0x186   0x9814             LDR      R0,[SP, #+80]
   \      0x188   0x9601             STR      R6,[SP, #+4]
   \      0x18A   0x9600             STR      R6,[SP, #+0]
   \      0x18C   0x2310             MOVS     R3,#+16
   \      0x18E   0x2200             MOVS     R2,#+0
   \      0x190   0x4659             MOV      R1,R11
   \      0x192   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \      0x196   0xB980             CBNZ.N   R0,??sl_se_aes_crypt_cfb128_2
   \                     ??sl_se_aes_crypt_cfb128_15: (+1)
   \      0x198   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x19C   0xD1E6             BNE.N    ??sl_se_aes_crypt_cfb128_12
   \      0x19E   0x5D32             LDRB     R2,[R6, R4]
   \      0x1A0   0xF817 0x1009      LDRB     R1,[R7, R9]
   \      0x1A4   0x4051             EORS     R1,R1,R2
   \      0x1A6   0x460A             MOV      R2,R1
   \                     ??sl_se_aes_crypt_cfb128_13: (+1)
   \      0x1A8   0xF808 0x1009      STRB     R1,[R8, R9]
   \      0x1AC   0x5532             STRB     R2,[R6, R4]
    242                  n = (n + 1) & 0x0F;
   \      0x1AE   0x.... 0x....      BL       ?Subroutine43
    243                  processed++;
    244                }
    245              }
    246            }
   \                     ??CrossCallReturnLabel_265: (+1)
   \      0x1B2   0xE7E3             B.N      ??sl_se_aes_crypt_cfb128_14
    247          
    248            if ( iv_off ) {
   \                     ??sl_se_aes_crypt_cfb128_7: (+1)
   \      0x1B4   0x991E             LDR      R1,[SP, #+120]
   \      0x1B6   0xB101             CBZ.N    R1,??sl_se_aes_crypt_cfb128_2
    249              *iv_off = n;
   \      0x1B8   0x600C             STR      R4,[R1, #+0]
    250            }
    251          
    252            return command_status;
   \                     ??sl_se_aes_crypt_cfb128_2: (+1)
   \      0x1BA   0x....             B.N      ?Subroutine2
    253          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine43: (+1)
   \        0x0   0x1C64             ADDS     R4,R4,#+1
   \        0x2   0xF004 0x040F      AND      R4,R4,#0xF
   \        0x6   0xF109 0x0901      ADD      R9,R9,#+1
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xB015             ADD      SP,SP,#+84
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    254          
    255          /***************************************************************************//**
    256           * AES-CFB8 buffer encryption/decryption.
    257           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    258          sl_status_t sl_se_aes_crypt_cfb8(sl_se_command_context_t *cmd_ctx,
    259                                           const sl_se_key_descriptor_t *key,
    260                                           sl_se_cipher_operation_t mode,
    261                                           size_t length,
    262                                           unsigned char iv[16],
    263                                           const unsigned char *input,
    264                                           unsigned char *output)
    265          {
   \                     sl_se_aes_crypt_cfb8: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0xEA5F 0x0B00      MOVS     R11,R0
   \        0xA   0x4688             MOV      R8,R1
   \        0xC   0x4615             MOV      R5,R2
   \        0xE   0x469A             MOV      R10,R3
    266            unsigned char c;
    267            unsigned char ov[17];
    268            sl_status_t ret = SL_STATUS_OK;
   \       0x10   0xF04F 0x0900      MOV      R9,#+0
    269          
    270            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL
    271                || iv == NULL) {
   \       0x14   0xBF18             IT       NE
   \       0x16   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x1A   0xD007             BEQ.N    ??sl_se_aes_crypt_cfb8_0
   \       0x1C   0x9F11             LDR      R7,[SP, #+68]
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xBF1C             ITT      NE
   \       0x22   0x9E12             LDRNE    R6,[SP, #+72]
   \       0x24   0x2E00             CMPNE    R6,#+0
   \       0x26   0xD001             BEQ.N    ??sl_se_aes_crypt_cfb8_0
   \       0x28   0x9C10             LDR      R4,[SP, #+64]
   \       0x2A   0xB9A4             CBNZ.N   R4,??sl_se_aes_crypt_cfb8_1
    272              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_cfb8_0: (+1)
   \       0x2C   0x2021             MOVS     R0,#+33
   \       0x2E   0xE028             B.N      ??sl_se_aes_crypt_cfb8_2
    273            }
    274          
    275            while (length--) {
    276              memcpy(ov, iv, 16U);
    277              if ((ret = sl_se_aes_crypt_ecb(cmd_ctx, key, SL_SE_ENCRYPT, 16U, iv, iv))
    278                  != SL_STATUS_OK) {
    279                return ret;
    280              }
    281          
    282              if (mode == SL_SE_DECRYPT) {
   \                     ??sl_se_aes_crypt_cfb8_3: (+1)
   \       0x30   0xA802             ADD      R0,SP,#+8
   \       0x32   0x2D01             CMP      R5,#+1
   \       0x34   0xBF04             ITT      EQ
   \       0x36   0x7839             LDRBEQ   R1,[R7, #+0]
   \       0x38   0x7401             STRBEQ   R1,[R0, #+16]
    283                ov[16] = *input;
    284              }
    285          
    286              c = *output++ = (unsigned char)(iv[0] ^ *input++);
   \       0x3A   0x7823             LDRB     R3,[R4, #+0]
   \       0x3C   0xF817 0x1B01      LDRB     R1,[R7], #+1
   \       0x40   0x4059             EORS     R1,R1,R3
   \       0x42   0xF806 0x1B01      STRB     R1,[R6], #+1
    287          
    288              if (mode == SL_SE_ENCRYPT) {
   \       0x46   0xB905             CBNZ.N   R5,??sl_se_aes_crypt_cfb8_4
    289                ov[16] = c;
   \       0x48   0x7401             STRB     R1,[R0, #+16]
    290              }
    291          
    292              memcpy(iv, ov + 1, 16U);
   \                     ??sl_se_aes_crypt_cfb8_4: (+1)
   \       0x4A   0x2210             MOVS     R2,#+16
   \       0x4C   0xF10D 0x0109      ADD      R1,SP,#+9
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??sl_se_aes_crypt_cfb8_1: (+1)
   \       0x56   0xEA5F 0x000A      MOVS     R0,R10
   \       0x5A   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \       0x5E   0xD00F             BEQ.N    ??sl_se_aes_crypt_cfb8_5
   \       0x60   0x2210             MOVS     R2,#+16
   \       0x62   0x4621             MOV      R1,R4
   \       0x64   0xA802             ADD      R0,SP,#+8
   \       0x66   0x.... 0x....      BL       __aeabi_memcpy
   \       0x6A   0x9401             STR      R4,[SP, #+4]
   \       0x6C   0x9400             STR      R4,[SP, #+0]
   \       0x6E   0x2310             MOVS     R3,#+16
   \       0x70   0x2200             MOVS     R2,#+0
   \       0x72   0x4641             MOV      R1,R8
   \       0x74   0x4658             MOV      R0,R11
   \       0x76   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   \       0x7A   0xEA5F 0x0900      MOVS     R9,R0
   \       0x7E   0xD0D7             BEQ.N    ??sl_se_aes_crypt_cfb8_3
    293            }
    294          
    295            return ret;
   \                     ??sl_se_aes_crypt_cfb8_5: (+1)
   \       0x80   0x4648             MOV      R0,R9
   \                     ??sl_se_aes_crypt_cfb8_2: (+1)
   \       0x82   0xB007             ADD      SP,SP,#+28
   \       0x84   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    296          }
    297          
    298          /***************************************************************************//**
    299           * Increment the input nonce counter by one
    300           ******************************************************************************/
    301          static void increment_nonce_counter(uint8_t block_end, unsigned char nonce_counter[])
    302          {
    303            for (size_t i = 0u; i < SL_SE_AES_BLOCK_SIZE; i++) {
    304              nonce_counter[block_end - i] = nonce_counter[block_end - i] + 1u;
    305              if (nonce_counter[block_end - i] != 0u) {
    306                // did not overflow so no need to increment the value at next index
    307                break;
    308              }
    309            }
    310          }
    311          
    312          #if (SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1)
    313          /***************************************************************************//**
    314           * Prepare the SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE byte
    315           * wide stream block buffer that will be used as nonce counter for
    316           * encryption/decryption.
    317           ******************************************************************************/
    318          static void prepare_nonce_counter(unsigned char nonce_counter[],
    319                                            unsigned char stream_block[])
    320          {
    321            uint8_t no_of_blocks = ((SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE) / SL_SE_AES_BLOCK_SIZE);
    322            // place the most recent counter in the first stream block
    323            memcpy(stream_block,
    324                   nonce_counter,
    325                   SL_SE_AES_BLOCK_SIZE);
    326          
    327            for (size_t i = 0; i < no_of_blocks - 1u; i++) {
    328              // Use the first block's reference counter to update the other
    329              // blocks since it holds the most recent counter information.
    330              memcpy(&stream_block[i * SL_SE_AES_BLOCK_SIZE + SL_SE_AES_BLOCK_SIZE],
    331                     &stream_block[i * SL_SE_AES_BLOCK_SIZE],
    332                     SL_SE_AES_BLOCK_SIZE);
    333              increment_nonce_counter(((i + 2u) * SL_SE_AES_BLOCK_SIZE) - 1u, stream_block);
    334            }
    335          
    336            // Store the largest counter back in the nonce counter buffer
    337            memcpy(nonce_counter,
    338                   &stream_block[(no_of_blocks - 1u) * SL_SE_AES_BLOCK_SIZE],
    339                   SL_SE_AES_BLOCK_SIZE);
    340          }
    341          #endif // SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1
    342          
    343          /***************************************************************************//**
    344           * AES-CTR buffer encryption/decryption.
    345           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    346          sl_status_t sl_se_aes_crypt_ctr(sl_se_command_context_t *cmd_ctx,
    347                                          const sl_se_key_descriptor_t *key,
    348                                          size_t length,
    349                                          uint32_t *nc_off,
    350                                          unsigned char nonce_counter[16],
    351                                          unsigned char stream_block[SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE],
    352                                          const unsigned char *input,
    353                                          unsigned char *output)
    354          {
   \                     sl_se_aes_crypt_ctr: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x0006             MOVS     R6,R0
    355            if (cmd_ctx == NULL || key == NULL
    356                || (length != 0 && (input == NULL || output == NULL))
    357                || nonce_counter == NULL || stream_block == NULL) {
   \        0x8   0xBF1C             ITT      NE
   \        0xA   0x9102             STRNE    R1,[SP, #+8]
   \        0xC   0x2900             CMPNE    R1,#+0
   \        0xE   0xD00F             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \       0x10   0x9204             STR      R2,[SP, #+16]
   \       0x12   0xF8DD 0x808C      LDR      R8,[SP, #+140]
   \       0x16   0xB12A             CBZ.N    R2,??sl_se_aes_crypt_ctr_1
   \       0x18   0x9822             LDR      R0,[SP, #+136]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xBF18             IT       NE
   \       0x1E   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x22   0xD005             BEQ.N    ??sl_se_aes_crypt_ctr_0
   \                     ??sl_se_aes_crypt_ctr_1: (+1)
   \       0x24   0x9D20             LDR      R5,[SP, #+128]
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xBF1C             ITT      NE
   \       0x2A   0x9F21             LDRNE    R7,[SP, #+132]
   \       0x2C   0x2F00             CMPNE    R7,#+0
   \       0x2E   0xD101             BNE.N    ??sl_se_aes_crypt_ctr_2
    358              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_aes_crypt_ctr_0: (+1)
   \       0x30   0x2021             MOVS     R0,#+33
   \       0x32   0xE093             B.N      ??sl_se_aes_crypt_ctr_3
    359            }
   \                     ??sl_se_aes_crypt_ctr_2: (+1)
   \       0x34   0x9303             STR      R3,[SP, #+12]
    360          
    361            SE_Command_t *se_cmd = &cmd_ctx->command;
    362            uint32_t n = nc_off ? *nc_off : 0;
   \       0x36   0x2B00             CMP      R3,#+0
   \       0x38   0xBF14             ITE      NE
   \       0x3A   0x681C             LDRNE    R4,[R3, #+0]
   \       0x3C   0x2400             MOVEQ    R4,#+0
    363            uint32_t processed = 0;
   \       0x3E   0xF04F 0x0900      MOV      R9,#+0
    364            sl_status_t command_status = SL_STATUS_OK;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE001             B.N      ??CrossCallReturnLabel_262
    365          
    366            while (processed < length) {
    367              if (n > 0) {
    368                // start by filling up the IV
    369                output[processed] = (unsigned char)(input[processed] ^ stream_block[n]);
   \                     ??sl_se_aes_crypt_ctr_4: (+1)
   \       0x46   0x.... 0x....      BL       ?Subroutine42
    370                n = (n + 1) & ((SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE) - 1u);
    371                processed++;
    372              } else {
   \                     ??CrossCallReturnLabel_262: (+1)
   \       0x4A   0x9904             LDR      R1,[SP, #+16]
   \       0x4C   0x4589             CMP      R9,R1
   \       0x4E   0xF080 0x8082      BCS.W    ??sl_se_aes_crypt_ctr_5
   \       0x52   0x2C00             CMP      R4,#+0
   \       0x54   0xD1F7             BNE.N    ??sl_se_aes_crypt_ctr_4
    373                // process one or more blocks of data
    374                uint32_t iterations = (length - processed) / SL_SE_AES_BLOCK_SIZE;
   \       0x56   0xEBA1 0x0109      SUB      R1,R1,R9
   \       0x5A   0xEA5F 0x1A11      LSRS     R10,R1,#+4
    375          
    376                if (iterations > 0) {
   \       0x5E   0xD05E             BEQ.N    ??sl_se_aes_crypt_ctr_6
    377                  sli_se_command_init(cmd_ctx,
    378                                      SLI_SE_COMMAND_AES_ENCRYPT
    379                                      | SLI_SE_COMMAND_OPTION_MODE_CTR
    380                                      | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \       0x60   0x.... 0x....      LDR.W    R2,??DataTable115
   \       0x64   0x.... 0x....      BL       ?Subroutine9
    381          
    382                  // Add key parameters to command
    383                  sli_add_key_parameters(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x68   0x9802             LDR      R0,[SP, #+8]
   \       0x6A   0x4669             MOV      R1,SP
   \       0x6C   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD173             BNE.N    ??sl_se_aes_crypt_ctr_3
   \       0x74   0x9900             LDR      R1,[SP, #+0]
   \       0x76   0x.... 0x....      BL       ??Subroutine25_0
    384                  // Message size (number of bytes)
    385                  SE_addParameter(se_cmd, iterations * SL_SE_AES_BLOCK_SIZE);
   \                     ??CrossCallReturnLabel_145: (+1)
   \       0x7A   0xEA4F 0x110A      LSL      R1,R10,#+4
   \       0x7E   0x.... 0x....      BL       ??Subroutine25_0
    386          
    387                  // Add key metadata block to command
    388                  sli_add_key_metadata(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_144: (+1)
   \       0x82   0x9802             LDR      R0,[SP, #+8]
   \       0x84   0x.... 0x....      BL       ??Subroutine28_0
   \                     ??CrossCallReturnLabel_157: (+1)
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD167             BNE.N    ??sl_se_aes_crypt_ctr_3
   \       0x8C   0xA914             ADD      R1,SP,#+80
   \       0x8E   0x.... 0x....      BL       ??Subroutine30_0
    389                  // Add key input block to command
    390                  sli_add_key_input(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_206: (+1)
   \       0x92   0x9802             LDR      R0,[SP, #+8]
   \       0x94   0x.... 0x....      BL       ??Subroutine37_0
   \                     ??CrossCallReturnLabel_229: (+1)
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD15F             BNE.N    ??sl_se_aes_crypt_ctr_3
   \       0x9C   0x.... 0x....      BL       ?Subroutine30
    391          
    392                  SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(nonce_counter, SL_SE_AES_BLOCK_SIZE);
   \                     ??CrossCallReturnLabel_209: (+1)
   \       0xA0   0x....             ADR.N    R0,?_10
   \       0xA2   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xA6   0xAB0E             ADD      R3,SP,#+56
   \       0xA8   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xAC   0x950E             STR      R5,[SP, #+56]
    393                  SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(&input[processed], iterations * SL_SE_AES_BLOCK_SIZE);
   \       0xAE   0xBF00             Nop
   \       0xB0   0x....             ADR.N    R3,?_11
   \       0xB2   0xE893 0x0803      LDM      R3,{R0,R1,R11}
   \       0xB6   0xF8DD 0xE088      LDR      LR,[SP, #+136]
   \       0xBA   0xAA0B             ADD      R2,SP,#+44
   \       0xBC   0xE882 0x0803      STM      R2,{R0,R1,R11}
   \       0xC0   0x44CE             ADD      LR,LR,R9
   \       0xC2   0xEA4F 0x100A      LSL      R0,R10,#+4
   \       0xC6   0xF8CD 0xE02C      STR      LR,[SP, #+44]
   \       0xCA   0xF040 0x5B00      ORR      R11,R0,#0x20000000
   \       0xCE   0xF8CD 0xB034      STR      R11,[SP, #+52]
    394                  SE_addDataInput(se_cmd, &iv_in);
   \       0xD2   0xA90E             ADD      R1,SP,#+56
   \       0xD4   0x.... 0x....      BL       ??Subroutine30_0
    395                  SE_addDataInput(se_cmd, &in);
   \                     ??CrossCallReturnLabel_205: (+1)
   \       0xD8   0xA90B             ADD      R1,SP,#+44
   \       0xDA   0x.... 0x....      BL       ??Subroutine30_0
    396          
    397                  SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(&output[processed], iterations * SL_SE_AES_BLOCK_SIZE);
   \                     ??CrossCallReturnLabel_204: (+1)
   \       0xDE   0xBF00             Nop
   \       0xE0   0x....             ADR.N    R1,?_12
   \       0xE2   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \       0xE6   0xA808             ADD      R0,SP,#+32
   \       0xE8   0xEB08 0x0109      ADD      R1,R8,R9
   \       0xEC   0xE880 0x400C      STM      R0,{R2,R3,LR}
   \       0xF0   0x9108             STR      R1,[SP, #+32]
    398                  SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(nonce_counter, SL_SE_AES_BLOCK_SIZE);
   \       0xF2   0xBF00             Nop
   \       0xF4   0x....             ADR.N    R1,?_13
   \       0xF6   0xF8CD 0xB028      STR      R11,[SP, #+40]
   \       0xFA   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \       0xFE   0xF10D 0x0B14      ADD      R11,SP,#+20
    399                  SE_addDataOutput(se_cmd, &out);
   \      0x102   0xA908             ADD      R1,SP,#+32
   \      0x104   0xE88B 0x400C      STM      R11,{R2,R3,LR}
   \      0x108   0x9505             STR      R5,[SP, #+20]
   \      0x10A   0x.... 0x....      BL       ?Subroutine38
    400                  SE_addDataOutput(se_cmd, &iv_out);
   \                     ??CrossCallReturnLabel_241: (+1)
   \      0x10E   0xA905             ADD      R1,SP,#+20
   \      0x110   0x.... 0x....      BL       ?Subroutine38
    401          
    402                  command_status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_240: (+1)
   \      0x114   0x.... 0x....      BL       ?Subroutine41
    403                  processed += iterations * SL_SE_AES_BLOCK_SIZE;
   \                     ??CrossCallReturnLabel_261: (+1)
   \      0x118   0xEB09 0x190A      ADD      R9,R9,R10, LSL #+4
    404                  if (command_status != SL_STATUS_OK) {
   \      0x11C   0xB9F0             CBNZ.N   R0,??sl_se_aes_crypt_ctr_3
    405                    return command_status;
    406                  }
    407                }
    408          
    409                while ((length - processed) > 0) {
   \                     ??sl_se_aes_crypt_ctr_6: (+1)
   \      0x11E   0x9904             LDR      R1,[SP, #+16]
   \      0x120   0xEBB1 0x0109      SUBS     R1,R1,R9
   \      0x124   0xD091             BEQ.N    ??CrossCallReturnLabel_262
    410                  if (n == 0) {
   \      0x126   0xB99C             CBNZ.N   R4,??sl_se_aes_crypt_ctr_7
    411                    // Get a new stream block
    412                    unsigned char *counter_ptr = NULL;
    413                    #if (SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1)
    414                    // Use the nonce counter buffer as the reference to create nonce counter blocks
    415                    // needed to compute the key stream blocks. Also, update the nonce counter buffer
    416                    // to store the latest block.
    417                    prepare_nonce_counter(nonce_counter, stream_block);
    418                    // The key stream buffer now holds the nonce counter
    419                    counter_ptr = stream_block;
    420                    #else
    421                    counter_ptr = nonce_counter;
    422                    #endif // SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED > 1
    423          
    424                    command_status = sl_se_aes_crypt_ecb(cmd_ctx,
    425                                                         key,
    426                                                         SL_SE_ENCRYPT,
    427                                                         SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE,
    428                                                         counter_ptr,
    429                                                         stream_block);
   \      0x128   0x9902             LDR      R1,[SP, #+8]
   \      0x12A   0x9701             STR      R7,[SP, #+4]
   \      0x12C   0x9500             STR      R5,[SP, #+0]
   \      0x12E   0x2310             MOVS     R3,#+16
   \      0x130   0x2200             MOVS     R2,#+0
   \      0x132   0x4630             MOV      R0,R6
   \      0x134   0x.... 0x....      BL       sl_se_aes_crypt_ecb
    430                    if (command_status != SL_STATUS_OK) {
   \      0x138   0xB980             CBNZ.N   R0,??sl_se_aes_crypt_ctr_3
    431                      return command_status;
    432                    }
    433                    increment_nonce_counter(SL_SE_AES_BLOCK_SIZE - 1u, nonce_counter);
   \      0x13A   0x2100             MOVS     R1,#+0
   \                     ??sl_se_aes_crypt_ctr_8: (+1)
   \      0x13C   0x424A             RSBS     R2,R1,#+0
   \      0x13E   0x18AB             ADDS     R3,R5,R2
   \      0x140   0x7BDA             LDRB     R2,[R3, #+15]
   \      0x142   0x1C52             ADDS     R2,R2,#+1
   \      0x144   0x73DA             STRB     R2,[R3, #+15]
   \      0x146   0xB2D2             UXTB     R2,R2
   \      0x148   0xB912             CBNZ.N   R2,??sl_se_aes_crypt_ctr_7
   \      0x14A   0x1C49             ADDS     R1,R1,#+1
   \      0x14C   0x290F             CMP      R1,#+15
   \      0x14E   0xD9F5             BLS.N    ??sl_se_aes_crypt_ctr_8
    434                  }
    435                  // Save remainder to IV
    436                  output[processed] = (unsigned char)(input[processed] ^ stream_block[n]);
   \                     ??sl_se_aes_crypt_ctr_7: (+1)
   \      0x150   0x.... 0x....      BL       ?Subroutine42
    437                  n = (n + 1) & ((SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED * SL_SE_AES_BLOCK_SIZE) - 1u);
    438                  processed++;
    439                }
    440              }
    441            }
   \                     ??CrossCallReturnLabel_263: (+1)
   \      0x154   0xE7E3             B.N      ??sl_se_aes_crypt_ctr_6
    442          
    443            if ( nc_off ) {
   \                     ??sl_se_aes_crypt_ctr_5: (+1)
   \      0x156   0x9903             LDR      R1,[SP, #+12]
   \      0x158   0xB101             CBZ.N    R1,??sl_se_aes_crypt_ctr_3
    444              *nc_off = n;
   \      0x15A   0x600C             STR      R4,[R1, #+0]
    445            }
    446          
    447            return command_status;
   \                     ??sl_se_aes_crypt_ctr_3: (+1)
   \      0x15C   0x....             B.N      ?Subroutine3
    448          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine42: (+1)
   \        0x0   0x9B22             LDR      R3,[SP, #+136]
   \        0x2   0x5D39             LDRB     R1,[R7, R4]
   \        0x4   0x1C64             ADDS     R4,R4,#+1
   \        0x6   0xF813 0x2009      LDRB     R2,[R3, R9]
   \        0xA   0xF004 0x040F      AND      R4,R4,#0xF
   \        0xE   0x404A             EORS     R2,R1,R2
   \       0x10   0xF808 0x2009      STRB     R2,[R8, R9]
   \       0x14   0xF109 0x0901      ADD      R9,R9,#+1
   \       0x18   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x6032             STR      R2,[R6, #+0]
   \                     ??Subroutine9_0: (+1)
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6070             STR      R0,[R6, #+4]
   \        0x6   0x60B0             STR      R0,[R6, #+8]
   \        0x8   0x61F0             STR      R0,[R6, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xB017             ADD      SP,SP,#+92
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine41: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine38: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \        0x0   0xA911             ADD      R1,SP,#+68
   \                     ??Subroutine30_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x9901             LDR      R1,[SP, #+4]
   \                     ??Subroutine25_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \        0x0   0x9800             LDR      R0,[SP, #+0]
   \                     ??Subroutine37_0: (+1)
   \        0x2   0xA911             ADD      R1,SP,#+68
   \        0x4   0x.... 0x....      B.W      sli_se_get_key_input_output

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \        0x0   0x9800             LDR      R0,[SP, #+0]
   \                     ??Subroutine28_0: (+1)
   \        0x2   0xA914             ADD      R1,SP,#+80
   \        0x4   0x.... 0x....      B.W      sli_se_get_auth_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
    449          
    450          /***************************************************************************//**
    451           * AES-CCM buffer encryption.
    452           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    453          sl_status_t sl_se_ccm_encrypt_and_tag(sl_se_command_context_t *cmd_ctx,
    454                                                const sl_se_key_descriptor_t *key,
    455                                                size_t length,
    456                                                const unsigned char *iv, size_t iv_len,
    457                                                const unsigned char *add, size_t add_len,
    458                                                const unsigned char *input,
    459                                                unsigned char *output,
    460                                                unsigned char *tag, size_t tag_len)
    461          {
   \                     sl_se_ccm_encrypt_and_tag: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x0004             MOVS     R4,R0
    462            if (cmd_ctx == NULL || key == NULL || (tag_len > 0 && tag == NULL) || iv == NULL) {
   \        0x8   0xD035             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \        0xA   0x9101             STR      R1,[SP, #+4]
   \        0xC   0x0008             MOVS     R0,R1
   \        0xE   0xD032             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \       0x10   0x9D24             LDR      R5,[SP, #+144]
   \       0x12   0x9E23             LDR      R6,[SP, #+140]
   \       0x14   0xB105             CBZ.N    R5,??sl_se_ccm_encrypt_and_tag_1
   \       0x16   0xB376             CBZ.N    R6,??sl_se_ccm_encrypt_and_tag_0
   \                     ??sl_se_ccm_encrypt_and_tag_1: (+1)
   \       0x18   0x9303             STR      R3,[SP, #+12]
   \       0x1A   0x0018             MOVS     R0,R3
   \       0x1C   0xD02B             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \       0x1E   0x9F20             LDR      R7,[SP, #+128]
   \       0x20   0xF8DD 0x807C      LDR      R8,[SP, #+124]
    463              return SL_STATUS_INVALID_PARAMETER;
    464            }
    465            if (add_len > 0 && add == NULL) {
   \       0x24   0xB117             CBZ.N    R7,??sl_se_ccm_encrypt_and_tag_2
   \       0x26   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x2A   0xD024             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \                     ??sl_se_ccm_encrypt_and_tag_2: (+1)
   \       0x2C   0x9200             STR      R2,[SP, #+0]
   \       0x2E   0xF8DD 0x9084      LDR      R9,[SP, #+132]
   \       0x32   0xF8DD 0xA088      LDR      R10,[SP, #+136]
    466              return SL_STATUS_INVALID_PARAMETER;
    467            }
    468            if (length > 0 && (input == NULL || output == NULL)) {
   \       0x36   0x0010             MOVS     R0,R2
   \       0x38   0xD005             BEQ.N    ??sl_se_ccm_encrypt_and_tag_3
   \       0x3A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x3E   0xBF18             IT       NE
   \       0x40   0xF1BA 0x0F00      CMPNE    R10,#+0
   \       0x44   0xD017             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \                     ??sl_se_ccm_encrypt_and_tag_3: (+1)
   \       0x46   0xF8DD 0xB078      LDR      R11,[SP, #+120]
    469              return SL_STATUS_INVALID_PARAMETER;
    470            }
    471          
    472            SE_Command_t *se_cmd = &cmd_ctx->command;
    473            unsigned char q;
    474            sl_status_t command_status = SL_STATUS_OK;
    475          
    476            // Test for invalid (too long) message length. This test is included here because
    477            // the SE does not implement the test. When the SE ultimately implements the test
    478            // the following test can be removed.
    479            q = 16 - 1 - (unsigned char) iv_len;
   \       0x4A   0x.... 0x....      BL       ?Subroutine45
    480            if ((q < sizeof(length)) && (length >= (1UL << (q * 8)))) {
   \                     ??CrossCallReturnLabel_268: (+1)
   \       0x4E   0xD202             BCS.N    ??sl_se_ccm_encrypt_and_tag_4
   \       0x50   0x.... 0x....      BL       ?Subroutine46
   \                     ??CrossCallReturnLabel_271: (+1)
   \       0x54   0xD20F             BCS.N    ??sl_se_ccm_encrypt_and_tag_0
    481              return SL_STATUS_INVALID_PARAMETER;
    482            }
    483          
    484            if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
   \                     ??sl_se_ccm_encrypt_and_tag_4: (+1)
   \       0x56   0x2D02             CMP      R5,#+2
   \       0x58   0xD00D             BEQ.N    ??sl_se_ccm_encrypt_and_tag_0
   \       0x5A   0x2D11             CMP      R5,#+17
   \       0x5C   0xD20B             BCS.N    ??sl_se_ccm_encrypt_and_tag_0
   \       0x5E   0x07E9             LSLS     R1,R5,#+31
   \       0x60   0xD409             BMI.N    ??sl_se_ccm_encrypt_and_tag_0
    485              return SL_STATUS_INVALID_PARAMETER;
    486            }
    487          
    488            // Also implies q is within bounds
    489            if (iv_len < 7 || iv_len > 13) {
   \       0x62   0xF1AB 0x0007      SUB      R0,R11,#+7
   \       0x66   0x2807             CMP      R0,#+7
   \       0x68   0xBF3F             ITTTT    CC
   \       0x6A   0x9800             LDRCC    R0,[SP, #+0]
   \       0x6C   0x4450             ADDCC    R0,R0,R10
   \       0x6E   0x.... 0x....      LDRCC.W  R1,??DataTable116
   \       0x72   0x4288             CMPCC    R0,R1
    490              return SL_STATUS_INVALID_PARAMETER;
    491            }
    492          
    493          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
    494            if ((uint32_t)output + length > RAM_MEM_END) {
   \       0x74   0xD301             BCC.N    ??sl_se_ccm_encrypt_and_tag_5
    495              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_encrypt_and_tag_0: (+1)
   \       0x76   0x2021             MOVS     R0,#+33
   \       0x78   0xE074             B.N      ??CrossCallReturnLabel_118
    496            }
    497          #endif // SLI_SE_MANAGER_HOST_SYSTEM
    498          
    499            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CCM_ENCRYPT);
   \                     ??sl_se_ccm_encrypt_and_tag_5: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R1,??DataTable116_1
   \       0x7E   0x.... 0x....      BL       ?Subroutine10
    500          
    501            // Add key parameters to command
    502            sli_add_key_parameters(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x82   0x9801             LDR      R0,[SP, #+4]
   \       0x84   0x.... 0x....      BL       ??Subroutine51_1
   \                     ??CrossCallReturnLabel_284: (+1)
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD16B             BNE.N    ??CrossCallReturnLabel_118
   \       0x8C   0x9902             LDR      R1,[SP, #+8]
   \       0x8E   0x.... 0x....      BL       ??Subroutine21_0
    503            // Message size (number of bytes)
    504            SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \                     ??CrossCallReturnLabel_96: (+1)
   \       0x92   0x4629             MOV      R1,R5
   \       0x94   0xF36B 0x411F      BFI      R1,R11,#+16,#+16
   \       0x98   0x.... 0x....      BL       ??Subroutine21_0
    505            SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_95: (+1)
   \       0x9C   0x4639             MOV      R1,R7
   \       0x9E   0x.... 0x....      BL       ??Subroutine21_0
    506            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_94: (+1)
   \       0xA2   0x.... 0x....      BL       ?Subroutine17
    507          
    508            // Add key metadata block to command
    509            sli_add_key_metadata(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0xA6   0x9801             LDR      R0,[SP, #+4]
   \       0xA8   0xA912             ADD      R1,SP,#+72
   \       0xAA   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD158             BNE.N    ??CrossCallReturnLabel_118
   \       0xB2   0xA912             ADD      R1,SP,#+72
   \       0xB4   0x.... 0x....      BL       ??Subroutine20_1
    510            // Add key input block to command
    511            sli_add_key_input(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0xB8   0x9801             LDR      R0,[SP, #+4]
   \       0xBA   0xA90F             ADD      R1,SP,#+60
   \       0xBC   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD14F             BNE.N    ??CrossCallReturnLabel_118
   \       0xC4   0xA90F             ADD      R1,SP,#+60
   \       0xC6   0x.... 0x....      BL       ??Subroutine20_1
    512          
    513            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(input, length);
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0xCA   0xBF00             Nop
   \       0xCC   0x....             ADR.N    R0,?_14
   \       0xCE   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xD2   0xAB0C             ADD      R3,SP,#+48
    514            SE_DataTransfer_t in_add = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0xD4   0xF047 0x5700      ORR      R7,R7,#0x20000000
   \       0xD8   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xDC   0xF8CD 0x9030      STR      R9,[SP, #+48]
   \       0xE0   0xF8DD 0x0000      LDR.W    R0,[SP, #+0]
   \       0xE4   0x....             ADR.N    R1,?_15
   \       0xE6   0xF10D 0x0E24      ADD      LR,SP,#+36
   \       0xEA   0xF040 0x5900      ORR      R9,R0,#0x20000000
   \       0xEE   0xF8CD 0x9038      STR      R9,[SP, #+56]
   \       0xF2   0xE891 0x000D      LDM      R1,{R0,R2,R3}
    515            SE_DataTransfer_t in_nonce = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0xF6   0xBF00             Nop
   \       0xF8   0x....             ADR.N    R1,?_16
   \       0xFA   0xF04B 0x5B00      ORR      R11,R11,#0x20000000
   \       0xFE   0xE88E 0x000D      STM      LR,{R0,R2,R3}
   \      0x102   0xF8CD 0x8024      STR      R8,[SP, #+36]
   \      0x106   0x970B             STR      R7,[SP, #+44]
   \      0x108   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x10C   0x9803             LDR      R0,[SP, #+12]
   \      0x10E   0xAF06             ADD      R7,SP,#+24
   \      0x110   0xE887 0x400C      STM      R7,{R2,R3,LR}
   \      0x114   0x9006             STR      R0,[SP, #+24]
   \      0x116   0xF8CD 0xB020      STR      R11,[SP, #+32]
    516            SE_addDataInput(se_cmd, &in_nonce);
   \      0x11A   0xA906             ADD      R1,SP,#+24
   \      0x11C   0x.... 0x....      BL       ??Subroutine20_1
    517            SE_addDataInput(se_cmd, &in_add);
   \                     ??CrossCallReturnLabel_67: (+1)
   \      0x120   0xA909             ADD      R1,SP,#+36
   \      0x122   0x.... 0x....      BL       ??Subroutine20_1
    518            SE_addDataInput(se_cmd, &in_data);
   \                     ??CrossCallReturnLabel_66: (+1)
   \      0x126   0xA90C             ADD      R1,SP,#+48
   \      0x128   0x.... 0x....      BL       ??Subroutine20_1
    519          
    520            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_65: (+1)
   \      0x12C   0x....             ADR.N    R1,?_17
   \      0x12E   0xE891 0x008C      LDM      R1,{R2,R3,R7}
   \      0x132   0xA803             ADD      R0,SP,#+12
    521            SE_DataTransfer_t out_tag = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \      0x134   0xF045 0x5500      ORR      R5,R5,#0x20000000
   \      0x138   0xE880 0x008C      STM      R0,{R2,R3,R7}
   \      0x13C   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \      0x140   0xF8CD 0x9014      STR      R9,[SP, #+20]
   \      0x144   0x....             ADR.N    R0,?_18
   \      0x146   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x14A   0x466F             MOV      R7,SP
    522            SE_addDataOutput(se_cmd, &out_data);
   \      0x14C   0x4620             MOV      R0,R4
   \      0x14E   0xE887 0x000E      STM      R7,{R1-R3}
   \      0x152   0x9600             STR      R6,[SP, #+0]
   \      0x154   0x9502             STR      R5,[SP, #+8]
   \      0x156   0xA903             ADD      R1,SP,#+12
   \      0x158   0x.... 0x....      BL       SE_addDataOutput
    523            SE_addDataOutput(se_cmd, &out_tag);
   \      0x15C   0x.... 0x....      BL       ?Subroutine11
    524          
    525            command_status = sli_se_execute_and_wait(cmd_ctx);
    526            return command_status;
   \                     ??CrossCallReturnLabel_14: (+1)
   \      0x160   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_118: (+1)
   \      0x164                      REQUIRE ?Subroutine2
   \      0x164                      ;; // Fall through to label ?Subroutine2
    527          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine46: (+1)
   \        0x0   0x4611             MOV      R1,R2
   \                     ??Subroutine46_0: (+1)
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x00C0             LSLS     R0,R0,#+3
   \        0x6   0x4082             LSLS     R2,R2,R0
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x6021             STR      R1,[R4, #+0]
   \                     ??Subroutine10_0: (+1)
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6060             STR      R0,[R4, #+4]
   \        0x6   0x60A0             STR      R0,[R4, #+8]
   \        0x8   0x61E0             STR      R0,[R4, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine45: (+1)
   \        0x0   0xFA5F 0xF08B      UXTB     R0,R11
   \        0x4   0xF1C0 0x000F      RSB      R0,R0,#+15
   \        0x8   0xB2C1             UXTB     R1,R0
   \        0xA   0x2904             CMP      R1,#+4
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine51_0: (+1)
   \        0x0   0x9800             LDR      R0,[SP, #+0]
   \                     ??Subroutine51_1: (+1)
   \        0x2   0xA902             ADD      R1,SP,#+8
   \        0x4   0x.... 0x....      B.W      sli_se_key_to_keyspec

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    528          
    529          /***************************************************************************//**
    530           * AES-CCM buffer decryption.
    531           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    532          sl_status_t sl_se_ccm_auth_decrypt(sl_se_command_context_t *cmd_ctx,
    533                                             const sl_se_key_descriptor_t *key,
    534                                             size_t length,
    535                                             const unsigned char *iv, size_t iv_len,
    536                                             const unsigned char *add, size_t add_len,
    537                                             const unsigned char *input,
    538                                             unsigned char *output,
    539                                             const unsigned char *tag, size_t tag_len)
    540          {
   \                     sl_se_ccm_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB096             SUB      SP,SP,#+88
   \        0x6   0x0004             MOVS     R4,R0
    541            if (cmd_ctx == NULL || key == NULL || tag == NULL || iv == NULL) {
   \        0x8   0xD039             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \        0xA   0x9101             STR      R1,[SP, #+4]
   \        0xC   0x0008             MOVS     R0,R1
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9D25             LDRNE    R5,[SP, #+148]
   \       0x12   0x2D00             CMPNE    R5,#+0
   \       0x14   0xD033             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \       0x16   0x9303             STR      R3,[SP, #+12]
   \       0x18   0x0018             MOVS     R0,R3
   \       0x1A   0xD030             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \       0x1C   0x9E22             LDR      R6,[SP, #+136]
   \       0x1E   0x9F21             LDR      R7,[SP, #+132]
    542              return SL_STATUS_INVALID_PARAMETER;
    543            }
    544            if (add_len > 0 && add == NULL) {
   \       0x20   0xB106             CBZ.N    R6,??sl_se_ccm_auth_decrypt_1
   \       0x22   0xB367             CBZ.N    R7,??sl_se_ccm_auth_decrypt_0
   \                     ??sl_se_ccm_auth_decrypt_1: (+1)
   \       0x24   0x9200             STR      R2,[SP, #+0]
   \       0x26   0xF8DD 0x808C      LDR      R8,[SP, #+140]
   \       0x2A   0xF8DD 0x9090      LDR      R9,[SP, #+144]
    545              return SL_STATUS_INVALID_PARAMETER;
    546            }
    547            if (length > 0 && (input == NULL || output == NULL)) {
   \       0x2E   0x0010             MOVS     R0,R2
   \       0x30   0xD005             BEQ.N    ??sl_se_ccm_auth_decrypt_2
   \       0x32   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x36   0xBF18             IT       NE
   \       0x38   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x3C   0xD01F             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \                     ??sl_se_ccm_auth_decrypt_2: (+1)
   \       0x3E   0xF8DD 0xB080      LDR      R11,[SP, #+128]
    548              return SL_STATUS_INVALID_PARAMETER;
    549            }
    550          
    551            SE_Command_t *se_cmd = &cmd_ctx->command;
    552            unsigned char q;
    553            sl_status_t command_status = SL_STATUS_OK;
    554          
    555            // Test for invalid (too long) message length. This test is included here because
    556            // the SE does not implement the test. When the SE ultimately implements the test
    557            // the following test can be removed.
    558            q = 16 - 1 - (unsigned char) iv_len;
   \       0x42   0x.... 0x....      BL       ?Subroutine45
    559            if ((q < sizeof(length)) && (length >= (1UL << (q * 8)))) {
   \                     ??CrossCallReturnLabel_269: (+1)
   \       0x46   0xD202             BCS.N    ??sl_se_ccm_auth_decrypt_3
   \       0x48   0x.... 0x....      BL       ?Subroutine46
   \                     ??CrossCallReturnLabel_272: (+1)
   \       0x4C   0xD217             BCS.N    ??sl_se_ccm_auth_decrypt_0
   \                     ??sl_se_ccm_auth_decrypt_3: (+1)
   \       0x4E   0xF8DD 0xA098      LDR      R10,[SP, #+152]
    560              return SL_STATUS_INVALID_PARAMETER;
    561            }
    562          
    563            if (tag_len == 2 || tag_len == 0 || tag_len > 16 || tag_len % 2 != 0) {
   \       0x52   0xF1BA 0x0F02      CMP      R10,#+2
   \       0x56   0xBF18             IT       NE
   \       0x58   0xF1BA 0x0F00      CMPNE    R10,#+0
   \       0x5C   0xD00F             BEQ.N    ??sl_se_ccm_auth_decrypt_0
   \       0x5E   0xF1BA 0x0F11      CMP      R10,#+17
   \       0x62   0xD20C             BCS.N    ??sl_se_ccm_auth_decrypt_0
   \       0x64   0xEA5F 0x71CA      LSLS     R1,R10,#+31
   \       0x68   0xD409             BMI.N    ??sl_se_ccm_auth_decrypt_0
    564              return SL_STATUS_INVALID_PARAMETER;
    565            }
    566          
    567            // Also implies q is within bounds */
    568            if (iv_len < 7 || iv_len > 13) {
   \       0x6A   0xF1AB 0x0007      SUB      R0,R11,#+7
   \       0x6E   0x2807             CMP      R0,#+7
   \       0x70   0xBF3F             ITTTT    CC
   \       0x72   0x9800             LDRCC    R0,[SP, #+0]
   \       0x74   0x4448             ADDCC    R0,R0,R9
   \       0x76   0x.... 0x....      LDRCC.W  R1,??DataTable116
   \       0x7A   0x4288             CMPCC    R0,R1
    569              return SL_STATUS_INVALID_PARAMETER;
    570            }
    571          
    572          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
    573            if ((uint32_t)output + length > RAM_MEM_END) {
   \       0x7C   0xD301             BCC.N    ??sl_se_ccm_auth_decrypt_4
    574              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_auth_decrypt_0: (+1)
   \       0x7E   0x2021             MOVS     R0,#+33
   \       0x80   0xE082             B.N      ??sl_se_ccm_auth_decrypt_5
    575            }
    576          #endif // SLI_SE_MANAGER_HOST_SYSTEM
    577          
    578            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CCM_DECRYPT);
   \                     ??sl_se_ccm_auth_decrypt_4: (+1)
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable117
   \       0x86   0x6021             STR      R1,[R4, #+0]
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x6062             STR      R2,[R4, #+4]
   \       0x8C   0x60A2             STR      R2,[R4, #+8]
   \       0x8E   0x61E2             STR      R2,[R4, #+28]
    579          
    580            // Add key parameters to command
    581            sli_add_key_parameters(cmd_ctx, key, command_status);
   \       0x90   0x9801             LDR      R0,[SP, #+4]
   \       0x92   0x.... 0x....      BL       ??Subroutine51_1
   \                     ??CrossCallReturnLabel_283: (+1)
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD176             BNE.N    ??sl_se_ccm_auth_decrypt_5
   \       0x9A   0x9902             LDR      R1,[SP, #+8]
   \       0x9C   0x.... 0x....      BL       ??Subroutine21_0
    582            // Message size (number of bytes)
    583            SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \                     ??CrossCallReturnLabel_93: (+1)
   \       0xA0   0x4651             MOV      R1,R10
   \       0xA2   0xF36B 0x411F      BFI      R1,R11,#+16,#+16
   \       0xA6   0x.... 0x....      BL       ??Subroutine21_0
    584            SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_92: (+1)
   \       0xAA   0x4631             MOV      R1,R6
   \       0xAC   0x.... 0x....      BL       ??Subroutine21_0
    585            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0xB0   0x.... 0x....      BL       ?Subroutine17
    586          
    587            // Add key metadata block to command
    588            sli_add_key_metadata(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0xB4   0x9801             LDR      R0,[SP, #+4]
   \       0xB6   0xA913             ADD      R1,SP,#+76
   \       0xB8   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD163             BNE.N    ??sl_se_ccm_auth_decrypt_5
   \       0xC0   0xA913             ADD      R1,SP,#+76
   \       0xC2   0x.... 0x....      BL       ??Subroutine20_1
    589            // Add key input block to command
    590            sli_add_key_input(cmd_ctx, key, command_status);
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0xC6   0x9801             LDR      R0,[SP, #+4]
   \       0xC8   0xA910             ADD      R1,SP,#+64
   \       0xCA   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD15A             BNE.N    ??sl_se_ccm_auth_decrypt_5
   \       0xD2   0xA910             ADD      R1,SP,#+64
   \       0xD4   0x.... 0x....      BL       ??Subroutine20_1
    591          
    592            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(input, length);
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0xD8   0x....             ADR.N    R0,?_19
   \       0xDA   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xDE   0xF10D 0x0E34      ADD      LR,SP,#+52
    593            SE_DataTransfer_t in_add = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0xE2   0xF046 0x5600      ORR      R6,R6,#0x20000000
   \       0xE6   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xEA   0xF8CD 0x8034      STR      R8,[SP, #+52]
   \       0xEE   0x9800             LDR      R0,[SP, #+0]
   \       0xF0   0xF10D 0x0E28      ADD      LR,SP,#+40
    594            SE_DataTransfer_t in_nonce = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0xF4   0xF04B 0x5B00      ORR      R11,R11,#0x20000000
   \       0xF8   0xF040 0x5800      ORR      R8,R0,#0x20000000
   \       0xFC   0xF8CD 0x803C      STR      R8,[SP, #+60]
   \      0x100   0x....             ADR.N    R0,?_20
   \      0x102   0xE890 0x000E      LDM      R0,{R1-R3}
    595            SE_addDataInput(se_cmd, &in_nonce);
   \      0x106   0xF04A 0x5A00      ORR      R10,R10,#0x20000000
   \      0x10A   0xE88E 0x000E      STM      LR,{R1-R3}
   \      0x10E   0x970A             STR      R7,[SP, #+40]
   \      0x110   0xF8CD 0x6030      STR.W    R6,[SP, #+48]
   \      0x114   0x....             ADR.N    R1,?_21
   \      0x116   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \      0x11A   0x9803             LDR      R0,[SP, #+12]
   \      0x11C   0xAF07             ADD      R7,SP,#+28
   \      0x11E   0xE887 0x004C      STM      R7,{R2,R3,R6}
   \      0x122   0x9007             STR      R0,[SP, #+28]
   \      0x124   0xF8CD 0xB024      STR      R11,[SP, #+36]
   \      0x128   0xA907             ADD      R1,SP,#+28
   \      0x12A   0x.... 0x....      BL       ??Subroutine20_1
    596            SE_addDataInput(se_cmd, &in_add);
   \                     ??CrossCallReturnLabel_62: (+1)
   \      0x12E   0xA90A             ADD      R1,SP,#+40
   \      0x130   0x.... 0x....      BL       ??Subroutine20_1
    597            SE_addDataInput(se_cmd, &in_data);
   \                     ??CrossCallReturnLabel_61: (+1)
   \      0x134   0xA90D             ADD      R1,SP,#+52
   \      0x136   0x.... 0x....      BL       ??Subroutine20_1
    598          
    599            SE_DataTransfer_t out_data = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_60: (+1)
   \      0x13A   0xBF00             Nop
   \      0x13C   0x....             ADR.N    R1,?_22
   \      0x13E   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \      0x142   0xA804             ADD      R0,SP,#+16
    600            SE_addDataOutput(se_cmd, &out_data);
   \      0x144   0xA904             ADD      R1,SP,#+16
   \      0x146   0xE880 0x004C      STM      R0,{R2,R3,R6}
   \      0x14A   0xF8CD 0x9010      STR      R9,[SP, #+16]
   \      0x14E   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \      0x152   0x.... 0x....      BL       ?Subroutine22
    601            SE_DataTransfer_t in_tag = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \                     ??CrossCallReturnLabel_108: (+1)
   \      0x156   0xBF00             Nop
   \      0x158   0x....             ADR.N    R0,?_23
   \      0x15A   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \      0x15E   0xAB01             ADD      R3,SP,#+4
    602            SE_addDataInput(se_cmd, &in_tag);
   \      0x160   0x4620             MOV      R0,R4
   \      0x162   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \      0x166   0x9501             STR      R5,[SP, #+4]
   \      0x168   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \      0x16C   0xA901             ADD      R1,SP,#+4
   \      0x16E   0x.... 0x....      BL       SE_addDataInput
    603          
    604            command_status = sli_se_execute_and_wait(cmd_ctx);
   \      0x172   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_117: (+1)
   \      0x176   0x0004             MOVS     R4,R0
    605            if (command_status == SL_STATUS_OK) {
   \      0x178   0xBF08             IT       EQ
   \      0x17A   0x2000             MOVEQ    R0,#+0
    606              return SL_STATUS_OK;
   \      0x17C   0xD004             BEQ.N    ??sl_se_ccm_auth_decrypt_5
    607            } else {
    608              memset(output, 0, length);
   \      0x17E   0x9900             LDR      R1,[SP, #+0]
   \      0x180   0x4648             MOV      R0,R9
   \      0x182   0x.... 0x....      BL       __aeabi_memclr
    609              return command_status;
   \      0x186   0x4620             MOV      R0,R4
    610            }
   \                     ??sl_se_ccm_auth_decrypt_5: (+1)
   \      0x188                      REQUIRE ?Subroutine3
   \      0x188                      ;; // Fall through to label ?Subroutine3
    611          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    612          
    613          #if defined(SLI_SE_MAJOR_VERSION_ONE)
    614          sl_status_t sl_se_ccm_multipart_starts(sl_se_ccm_multipart_context_t *ccm_ctx,
    615                                                 sl_se_command_context_t *cmd_ctx,
    616                                                 const sl_se_key_descriptor_t *key,
    617                                                 sl_se_cipher_operation_t mode,
    618                                                 uint32_t total_message_length,
    619                                                 const uint8_t *iv,
    620                                                 size_t iv_len,
    621                                                 const uint8_t *aad,
    622                                                 size_t aad_len,
    623                                                 size_t tag_len)
    624          {
    625            sl_status_t status = SL_STATUS_OK;
    626            uint8_t q;
    627            uint8_t b[SL_SE_AES_BLOCK_SIZE] = { 0 };
    628            uint8_t tag_out[SL_SE_AES_BLOCK_SIZE] = { 0 };
    629            uint8_t cbc_mac_state[SL_SE_AES_BLOCK_SIZE] = { 0 };
    630            uint8_t nonce_counter[SL_SE_AES_BLOCK_SIZE] = { 0 };
    631            uint32_t len_left;
    632          
    633            //Check input parameters
    634            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL) {
    635              return SL_STATUS_INVALID_PARAMETER;
    636            }
    637            if (aad_len > 0 && aad == NULL) {
    638              return SL_STATUS_INVALID_PARAMETER;
    639            }
    640          
    641            if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
    642              return SL_STATUS_INVALID_PARAMETER;
    643            }
    644          
    645            if (iv_len < 7 || iv_len > 13) {
    646              return SL_STATUS_INVALID_PARAMETER;
    647            }
    648          
    649            // q is the the octet length of Q which again is a bit string representation of
    650            // the octet length of the payload.
    651            q = 16 - 1 - (uint8_t) iv_len;
    652          
    653            // The parameter q determines the maximum length of the payload: by definition, p<2^(8*q),
    654            // where p is payload.
    655            if ((q < sizeof(total_message_length)) && (total_message_length >= (1UL << (q * 8)))) {
    656              return SL_STATUS_INVALID_PARAMETER;
    657            }
    658            memset(ccm_ctx, 0, sizeof(sl_se_ccm_multipart_context_t));
    659          
    660            // Format first input block B_O according to the formatting function:
    661          
    662            // 0        .. 0        flags
    663            // 1        .. iv_len   nonce (aka iv)
    664            // iv_len+1 .. 15       length
    665            //
    666            // With flags as (bits):
    667            // 7        0
    668            // 6        add present?
    669            // 5 .. 3   (t - 2) / 2
    670            // 2 .. 0   q - 1
    671          
    672            b[0] = 0;
    673            b[0] |= (aad_len > 0) << 6;
    674            b[0] |= ((tag_len - 2) / 2) << 3;
    675            b[0] |= q - 1;
    676          
    677            memcpy(b + 1, iv, iv_len);
    678          
    679            len_left = total_message_length;
    680            for (uint32_t i = 0; i < q; i++, len_left >>= 8) {
    681              b[15 - i] = (unsigned char)(len_left & 0xFF);
    682            }
    683          
    684            ccm_ctx->mode = mode;
    685            ccm_ctx->processed_message_length = 0;
    686            ccm_ctx->total_message_length = total_message_length;
    687            ccm_ctx->tag_len = tag_len;
    688            ccm_ctx->mode = mode;
    689            ccm_ctx->iv_len = iv_len;
    690            memcpy(ccm_ctx->iv, iv, iv_len);
    691          
    692            status = sl_se_aes_crypt_cbc(cmd_ctx,
    693                                         key,
    694                                         SL_SE_ENCRYPT,
    695                                         SL_SE_AES_BLOCK_SIZE,
    696                                         cbc_mac_state,
    697                                         b,
    698                                         tag_out);
    699          
    700            if (status != SL_STATUS_OK) {
    701              return status;
    702            }
    703          
    704            // If there is additional data, update using CBC. Must be done
    705            // blockwise to achieve the same behaviour as CBC-MAC.
    706            if (aad_len > 0) {
    707              uint8_t use_len;
    708              len_left = aad_len;
    709              memset(b, 0, sizeof(b));
    710              // First block.
    711              b[0] = (unsigned char)((aad_len >> 8) & 0xFF);
    712              b[1] = (unsigned char)((aad_len) & 0xFF);
    713              use_len = len_left < SL_SE_AES_BLOCK_SIZE - 2 ? len_left : 16 - 2;
    714              memcpy(b + 2, aad, use_len);
    715              len_left -= use_len;
    716              aad += use_len;
    717          
    718              status = sl_se_aes_crypt_cbc(cmd_ctx,
    719                                           key,
    720                                           SL_SE_ENCRYPT,
    721                                           SL_SE_AES_BLOCK_SIZE,
    722                                           cbc_mac_state,
    723                                           b,
    724                                           tag_out);
    725              if (status != SL_STATUS_OK) {
    726                return status;
    727              }
    728          
    729              while (len_left) {
    730                use_len = len_left > 16 ? 16 : len_left;
    731          
    732                memset(b, 0, sizeof(b));
    733                memcpy(b, aad, use_len);
    734                status = sl_se_aes_crypt_cbc(cmd_ctx,
    735                                             key,
    736                                             SL_SE_ENCRYPT,
    737                                             SL_SE_AES_BLOCK_SIZE,
    738                                             cbc_mac_state,
    739                                             b,
    740                                             tag_out);
    741          
    742                if (status != SL_STATUS_OK) {
    743                  return status;
    744                }
    745                len_left -= use_len;
    746                aad += use_len;
    747              }
    748            }
    749          
    750            memcpy(ccm_ctx->cbc_mac_state, cbc_mac_state, sizeof(cbc_mac_state));
    751          
    752            // Prepare nonce counter for encryption/decryption operation.
    753            nonce_counter[0] = q - 1;
    754            memcpy(nonce_counter + 1, iv, iv_len);
    755            memset(nonce_counter + 1 + iv_len, 0, q);
    756            nonce_counter[15] = 1;
    757          
    758            memcpy(ccm_ctx->nonce_counter, nonce_counter, sizeof(ccm_ctx->nonce_counter));
    759          
    760            return SL_STATUS_OK;
    761          }
    762          
    763          sl_status_t sl_se_ccm_multipart_update(sl_se_ccm_multipart_context_t *ccm_ctx,
    764                                                 sl_se_command_context_t *cmd_ctx,
    765                                                 const sl_se_key_descriptor_t *key,
    766                                                 size_t length,
    767                                                 const uint8_t *input,
    768                                                 uint8_t *output,
    769                                                 size_t *output_length)
    770          {
    771            sl_status_t status = SL_STATUS_OK;
    772            *output_length = 0;
    773          
    774            uint8_t out_buf[SL_SE_AES_BLOCK_SIZE] = { 0 };
    775            uint8_t empty[SL_SE_AES_BLOCK_SIZE * SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED] = { 0 };
    776            uint8_t b[SL_SE_AES_BLOCK_SIZE] = { 0 };
    777          
    778            size_t len_left;
    779          
    780            // Check input parameters.
    781            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL) {
    782              return SL_STATUS_INVALID_PARAMETER;
    783            }
    784          
    785            if (length == 0) {
    786              return SL_STATUS_OK;
    787            }
    788          
    789            // Check variable overflow
    790            if (ccm_ctx->processed_message_length > 0xFFFFFFFF - length) {
    791              return SL_STATUS_INVALID_PARAMETER;
    792            }
    793          
    794            if (ccm_ctx->processed_message_length + length > ccm_ctx->total_message_length) {
    795              return SL_STATUS_INVALID_PARAMETER;
    796            }
    797          
    798            if (length > 0 && (input == NULL || output == NULL)) {
    799              return SL_STATUS_INVALID_PARAMETER;
    800            }
    801          
    802            if ((uint32_t)output + length > RAM_MEM_END) {
    803              return SL_STATUS_INVALID_PARAMETER;
    804            }
    805          
    806            // Support partial overlap.
    807            if ((output > input) && (output < (input + length))) {
    808              memmove(output, input, length);
    809              input = output;
    810            }
    811          
    812            if (length + ccm_ctx->final_data_length < SL_SE_AES_BLOCK_SIZE && length < SL_SE_AES_BLOCK_SIZE && ccm_ctx->processed_message_length + length != ccm_ctx->total_message_length ) {
    813              if (ccm_ctx->final_data_length > SL_SE_AES_BLOCK_SIZE) {
    814                // Context is not valid.
    815                return SL_STATUS_INVALID_PARAMETER;
    816              }
    817              memcpy(ccm_ctx->final_data + ccm_ctx->final_data_length, input, length);
    818              ccm_ctx->final_data_length += length;
    819              *output_length = 0;
    820              return SL_STATUS_OK;
    821            }
    822          
    823            len_left = length + ccm_ctx->final_data_length;
    824          
    825            // Authenticate and {en,de}crypt the message.
    826          
    827            // The only difference between encryption and decryption is
    828            // the respective order of authentication and {en,de}cryption.
    829            while (len_left > 0 ) {
    830              uint8_t use_len = len_left > SL_SE_AES_BLOCK_SIZE ? SL_SE_AES_BLOCK_SIZE : len_left;
    831          
    832              memset(b, 0, sizeof(b));
    833          
    834              // Process data stored in context first.
    835              if (ccm_ctx->final_data_length > 0) {
    836                if (ccm_ctx->final_data_length > SL_SE_AES_BLOCK_SIZE) {
    837                  // Context is not valid.
    838                  return SL_STATUS_INVALID_PARAMETER;
    839                }
    840                memcpy(b, ccm_ctx->final_data, ccm_ctx->final_data_length);
    841                memcpy(b + ccm_ctx->final_data_length, input, SL_SE_AES_BLOCK_SIZE - ccm_ctx->final_data_length);
    842                input += SL_SE_AES_BLOCK_SIZE - ccm_ctx->final_data_length;
    843                ccm_ctx->final_data_length = 0;
    844              } else {
    845                memcpy(b, input, use_len);
    846                input += use_len;
    847              }
    848              if (ccm_ctx->mode == SL_SE_ENCRYPT) {
    849                // Authenticate input.
    850                status = sl_se_aes_crypt_cbc(cmd_ctx,
    851                                             key,
    852                                             SL_SE_ENCRYPT,
    853                                             SL_SE_AES_BLOCK_SIZE,
    854                                             ccm_ctx->cbc_mac_state,
    855                                             b,
    856                                             out_buf);
    857          
    858                if (status != SL_STATUS_OK) {
    859                  return status;
    860                }
    861              }
    862              // Encrypt/decrypt data with CTR.
    863              status = sl_se_aes_crypt_ctr(cmd_ctx,
    864                                           key,
    865                                           use_len,
    866                                           NULL,
    867                                           ccm_ctx->nonce_counter,
    868                                           empty,
    869                                           b,
    870                                           output);
    871          
    872              if (ccm_ctx->mode == SL_SE_DECRYPT) {
    873                // Authenticate output.
    874                memset(b, 0, sizeof(b));
    875                memcpy(b, output, use_len);
    876                status = sl_se_aes_crypt_cbc(cmd_ctx,
    877                                             key,
    878                                             SL_SE_ENCRYPT,
    879                                             SL_SE_AES_BLOCK_SIZE,
    880                                             ccm_ctx->cbc_mac_state,
    881                                             b,
    882                                             out_buf);
    883          
    884                if (status != SL_STATUS_OK) {
    885                  return status;
    886                }
    887              }
    888              ccm_ctx->processed_message_length += use_len;
    889              *output_length += use_len;
    890              len_left -= use_len;
    891              output += use_len;
    892          
    893              if (len_left < SL_SE_AES_BLOCK_SIZE && ((ccm_ctx->processed_message_length + len_left) != ccm_ctx->total_message_length)) {
    894                memcpy(ccm_ctx->final_data, input, len_left);
    895                ccm_ctx->final_data_length = len_left;
    896                break;
    897              }
    898            }
    899          
    900            if (status != SL_STATUS_OK) {
    901              return status;
    902            }
    903          
    904            return SL_STATUS_OK;
    905          }
    906          
    907          sl_status_t sl_se_ccm_multipart_finish(sl_se_ccm_multipart_context_t *ccm_ctx,
    908                                                 sl_se_command_context_t *cmd_ctx,
    909                                                 const sl_se_key_descriptor_t *key,
    910                                                 uint8_t *tag,
    911                                                 uint8_t tag_size,
    912                                                 uint8_t *output,
    913                                                 uint8_t output_size,
    914                                                 uint8_t *output_length)
    915          {
    916            (void)output;
    917            uint8_t q;
    918            uint8_t ctr[SL_SE_AES_BLOCK_SIZE] = { 0 };
    919            uint8_t out_tag[SL_SE_AES_BLOCK_SIZE] = { 0 };
    920            //Check input parameters
    921            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || tag == NULL) {
    922              return SL_STATUS_INVALID_PARAMETER;
    923            }
    924          
    925            if (tag_size < ccm_ctx->tag_len || output_size < ccm_ctx->final_data_length) {
    926              return SL_STATUS_INVALID_PARAMETER;
    927            }
    928          
    929            sl_status_t status = SL_STATUS_OK;
    930          
    931            // Reset CTR counter.
    932            q = 16 - 1 - (unsigned char) ccm_ctx->iv_len;
    933          
    934            ctr[0] = q - 1;
    935            memcpy(ctr + 1, ccm_ctx->iv, ccm_ctx->iv_len);
    936          
    937            // Encrypt the tag with CTR.
    938            uint8_t empty[SL_SE_AES_BLOCK_SIZE * SLI_SE_AES_CTR_NUM_BLOCKS_BUFFERED] = { 0 };
    939            status =  sl_se_aes_crypt_ctr(cmd_ctx,
    940                                          key,
    941                                          ccm_ctx->tag_len,
    942                                          NULL,
    943                                          ctr,
    944                                          empty,
    945                                          ccm_ctx->cbc_mac_state,
    946                                          out_tag);
    947          
    948            if (status != SL_STATUS_OK) {
    949              memset(out_tag, 0, sizeof(out_tag));
    950              return status;
    951            }
    952          
    953            if (ccm_ctx->mode == SL_SE_DECRYPT) {
    954              if (memcmp_time_cst(tag, out_tag, ccm_ctx->tag_len) != 0) {
    955                memset(tag, 0, ccm_ctx->tag_len);
    956                return SL_STATUS_INVALID_SIGNATURE;
    957              }
    958            } else {
    959              memcpy(tag, out_tag, ccm_ctx->tag_len);
    960            }
    961          
    962            *output_length = 0;
    963            return SL_STATUS_OK;
    964          }
    965          #endif // SLI_SE_MAJOR_VERSION_ONE
    966          
    967          #if defined(SLI_SE_MAJOR_VERSION_TWO)
    968          /***************************************************************************//**
    969           *   Prepare a CCM streaming command context object to be used in subsequent
    970           *   CCM streaming function calls.
    971           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    972          sl_status_t sl_se_ccm_multipart_starts(sl_se_ccm_multipart_context_t *ccm_ctx,
    973                                                 sl_se_command_context_t *cmd_ctx,
    974                                                 const sl_se_key_descriptor_t *key,
    975                                                 sl_se_cipher_operation_t mode,
    976                                                 uint32_t total_message_length,
    977                                                 const uint8_t *iv,
    978                                                 size_t iv_len,
    979                                                 const uint8_t *add,
    980                                                 size_t add_len,
    981                                                 size_t tag_len)
    982          
    983          {
   \                     sl_se_ccm_multipart_starts: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
    984            sl_status_t status = SL_STATUS_OK;
    985            uint8_t q;
    986          
    987            //Check input parameters
    988            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL) {
   \        0x8   0xD028             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \        0xA   0x000D             MOVS     R5,R1
   \        0xC   0xD026             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \        0xE   0x0016             MOVS     R6,R2
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x9F1D             LDRNE    R7,[SP, #+116]
   \       0x14   0x2F00             CMPNE    R7,#+0
   \       0x16   0xD021             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \       0x18   0xF8DD 0x8080      LDR      R8,[SP, #+128]
   \       0x1C   0xF8DD 0x907C      LDR      R9,[SP, #+124]
    989              return SL_STATUS_INVALID_PARAMETER;
    990            }
    991            if (add_len > 0 && add == NULL) {
   \       0x20   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x24   0xD002             BEQ.N    ??sl_se_ccm_multipart_starts_1
   \       0x26   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x2A   0xD017             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \                     ??sl_se_ccm_multipart_starts_1: (+1)
   \       0x2C   0xF8DD 0xA084      LDR      R10,[SP, #+132]
    992              return SL_STATUS_INVALID_PARAMETER;
    993            }
    994          
    995            if (tag_len == 2 || tag_len > 16 || tag_len % 2 != 0) {
   \       0x30   0xF1BA 0x0F02      CMP      R10,#+2
   \       0x34   0xD012             BEQ.N    ??sl_se_ccm_multipart_starts_0
   \       0x36   0xF1BA 0x0F10      CMP      R10,#+16
   \       0x3A   0xD80F             BHI.N    ??sl_se_ccm_multipart_starts_0
   \       0x3C   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \       0x40   0xD40C             BMI.N    ??sl_se_ccm_multipart_starts_0
   \       0x42   0xF8DD 0xB078      LDR      R11,[SP, #+120]
    996              return SL_STATUS_INVALID_PARAMETER;
    997            }
    998          
    999            if (iv_len < 7 || iv_len > 13) {
   \       0x46   0xF1AB 0x0007      SUB      R0,R11,#+7
   \       0x4A   0x2807             CMP      R0,#+7
   \       0x4C   0xD206             BCS.N    ??sl_se_ccm_multipart_starts_0
   1000              return SL_STATUS_INVALID_PARAMETER;
   1001            }
   1002          
   1003            q = 16 - 1 - (unsigned char) iv_len;
   \       0x4E   0x.... 0x....      BL       ?Subroutine45
   1004            if ((q < sizeof(ccm_ctx->total_message_length)) && (ccm_ctx->total_message_length >= (1UL << (q * 8)))) {
   \                     ??CrossCallReturnLabel_270: (+1)
   \       0x52   0xD205             BCS.N    ??sl_se_ccm_multipart_starts_2
   \       0x54   0x6861             LDR      R1,[R4, #+4]
   \       0x56   0x.... 0x....      BL       ??Subroutine46_0
   \                     ??CrossCallReturnLabel_273: (+1)
   \       0x5A   0xD301             BCC.N    ??sl_se_ccm_multipart_starts_2
   1005              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_starts_0: (+1)
   \       0x5C   0x2021             MOVS     R0,#+33
   \       0x5E   0xE0D5             B.N      ??sl_se_ccm_multipart_starts_3
   1006            }
   \                     ??sl_se_ccm_multipart_starts_2: (+1)
   \       0x60   0xF88D 0x3000      STRB     R3,[SP, #+0]
   1007          
   1008            memset(ccm_ctx, 0, sizeof(sl_se_ccm_multipart_context_t));
   \       0x64   0x2150             MOVS     R1,#+80
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x.... 0x....      BL       __aeabi_memclr4
   1009          
   1010            ccm_ctx->mode = mode;
   \       0x6C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   1011            ccm_ctx->processed_message_length = 0;
   \       0x70   0x2100             MOVS     R1,#+0
   1012            ccm_ctx->total_message_length = total_message_length;
   1013            ccm_ctx->tag_len = tag_len;
   1014            memcpy(ccm_ctx->iv, iv, iv_len);
   \       0x72   0x465A             MOV      R2,R11
   \       0x74   0x7720             STRB     R0,[R4, #+28]
   \       0x76   0x6021             STR      R1,[R4, #+0]
   \       0x78   0x981C             LDR      R0,[SP, #+112]
   \       0x7A   0xF8C4 0xA018      STR      R10,[R4, #+24]
   \       0x7E   0x4639             MOV      R1,R7
   \       0x80   0x6060             STR      R0,[R4, #+4]
   \       0x82   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x86   0x.... 0x....      BL       __aeabi_memcpy
   1015          
   1016            SE_Command_t *se_cmd = &cmd_ctx->command;
   1017          
   1018            if (total_message_length == 0) {
   \       0x8A   0x991C             LDR      R1,[SP, #+112]
   \       0x8C   0xF048 0x5E00      ORR      LR,R8,#0x20000000
   \       0x90   0xF04B 0x5000      ORR      R0,R11,#0x20000000
   \       0x94   0x2900             CMP      R1,#+0
   \       0x96   0xD155             BNE.N    ??sl_se_ccm_multipart_starts_4
   1019              // The first encryption precomputes the tag in the event there is no more data.
   1020              // For decryption, the pre-computed is compared to the input tag in
   1021              // sl_se_ccm_multipart_finish.
   1022              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0x98   0x.... 0x....      ADR.W    R12,?_24
   \       0x9C   0xE8BC 0x000C      LDM      R12!,{R2,R3}
   \       0xA0   0xA90C             ADD      R1,SP,#+48
   \       0xA2   0xC10C             STM      R1!,{R2,R3}
   \       0xA4   0xF8DC 0x2000      LDR      R2,[R12, #+0]
   1023              SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   1024              SE_DataTransfer_t tag_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->mode_specific_buffer.tagbuf,
   1025                                                                  tag_len);
   \       0xA8   0xF104 0x0C3D      ADD      R12,R4,#+61
   \       0xAC   0x600A             STR      R2,[R1, #+0]
   \       0xAE   0x970C             STR      R7,[SP, #+48]
   \       0xB0   0xF8CD 0x0038      STR.W    R0,[SP, #+56]
   \       0xB4   0x....             ADR.N    R1,?_25
   \       0xB6   0xE891 0x000D      LDM      R1,{R0,R2,R3}
   \       0xBA   0xAF09             ADD      R7,SP,#+36
   \       0xBC   0x....             ADR.N    R1,?_26
   \       0xBE   0xE887 0x000D      STM      R7,{R0,R2,R3}
   \       0xC2   0xF8CD 0x9024      STR      R9,[SP, #+36]
   \       0xC6   0xF8CD 0xE02C      STR      LR,[SP, #+44]
   \       0xCA   0xE891 0x008C      LDM      R1,{R2,R3,R7}
   \       0xCE   0xF10D 0x0E18      ADD      LR,SP,#+24
   1026          
   1027              sli_se_command_init(cmd_ctx,
   1028                                  SLI_SE_COMMAND_AES_CCM_ENCRYPT
   1029                                  | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \       0xD2   0x2000             MOVS     R0,#+0
   \       0xD4   0xE88E 0x008C      STM      LR,{R2,R3,R7}
   \       0xD8   0xF8CD 0xC018      STR      R12,[SP, #+24]
   \       0xDC   0xF04A 0x5E00      ORR      LR,R10,#0x20000000
   \       0xE0   0xF8CD 0xE020      STR      LR,[SP, #+32]
   \       0xE4   0x.... 0x....      LDR.W    R2,??DataTable116_1
   \       0xE8   0x602A             STR      R2,[R5, #+0]
   \       0xEA   0x6068             STR      R0,[R5, #+4]
   \       0xEC   0x60A8             STR      R0,[R5, #+8]
   \       0xEE   0x61E8             STR      R0,[R5, #+28]
   1030          
   1031              sli_add_key_parameters(cmd_ctx, key, status);
   \       0xF0   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0xF4   0x2800             CMP      R0,#+0
   \       0xF6   0xD113             BNE.N    ??sl_se_ccm_multipart_starts_5
   \       0xF8   0x.... 0x....      BL       ?Subroutine18
   1032              SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0xFC   0x4651             MOV      R1,R10
   \       0xFE   0x.... 0x....      BL       ??Subroutine24_0
   1033              SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_133: (+1)
   \      0x102   0x4641             MOV      R1,R8
   \      0x104   0x.... 0x....      BL       ??Subroutine24_0
   1034              SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_132: (+1)
   \      0x108   0x.... 0x....      BL       ?Subroutine24
   1035          
   1036              // Add key metadata block to command
   1037              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_136: (+1)
   \      0x10C   0x.... 0x....      BL       ?Subroutine26
   \                     ??CrossCallReturnLabel_153: (+1)
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD105             BNE.N    ??sl_se_ccm_multipart_starts_5
   \      0x114   0xA903             ADD      R1,SP,#+12
   \      0x116   0x.... 0x....      BL       ??Subroutine29_0
   1038              // Add key input block to command
   1039              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_182: (+1)
   \      0x11A   0x.... 0x....      BL       ?Subroutine35
   \                     ??CrossCallReturnLabel_225: (+1)
   \      0x11E   0x2800             CMP      R0,#+0
   \                     ??sl_se_ccm_multipart_starts_5: (+1)
   \      0x120   0xD174             BNE.N    ??sl_se_ccm_multipart_starts_3
   \      0x122   0x.... 0x....      BL       ?Subroutine13
   1040          
   1041              SE_addDataInput(se_cmd, &iv_in);
   \                     ??CrossCallReturnLabel_21: (+1)
   \      0x126   0x.... 0x....      BL       ?Subroutine29
   1042              SE_addDataInput(se_cmd, &add_in);
   \                     ??CrossCallReturnLabel_186: (+1)
   \      0x12A   0xA909             ADD      R1,SP,#+36
   \      0x12C   0x.... 0x....      BL       ??Subroutine29_0
   1043          
   1044              SE_addDataOutput(se_cmd, &tag_out);
   \                     ??CrossCallReturnLabel_181: (+1)
   \      0x130   0x.... 0x....      BL       ?Subroutine39
   1045          
   1046              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_248: (+1)
   \      0x134   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_255: (+1)
   \      0x138   0x0005             MOVS     R5,R0
   1047              if (status != SL_STATUS_OK) {
   \      0x13A   0xD064             BEQ.N    ??sl_se_ccm_multipart_starts_6
   1048                memset(ccm_ctx->mode_specific_buffer.tagbuf, 0, sizeof(ccm_ctx->mode_specific_buffer.tagbuf));
   \      0x13C   0x2110             MOVS     R1,#+16
   \      0x13E   0xF104 0x003D      ADD      R0,R4,#+61
   \      0x142   0xE05E             B.N      ??sl_se_ccm_multipart_starts_7
   1049              }
   1050              return status;
   1051            }
   1052            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \                     ??sl_se_ccm_multipart_starts_4: (+1)
   \      0x144   0x....             ADR.N    R1,?_27
   \      0x146   0xE8B1 0x1008      LDM      R1!,{R3,R12}
   \      0x14A   0xAA0F             ADD      R2,SP,#+60
   \      0x14C   0xE8A2 0x1008      STM      R2!,{R3,R12}
   \      0x150   0x680B             LDR      R3,[R1, #+0]
   1053            SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \      0x152   0xBF00             Nop
   \      0x154   0x....             ADR.N    R1,?_28
   \      0x156   0x6013             STR      R3,[R2, #+0]
   \      0x158   0x970F             STR      R7,[SP, #+60]
   \      0x15A   0x9011             STR      R0,[SP, #+68]
   \      0x15C   0xE891 0x000D      LDM      R1,{R0,R2,R3}
   \      0x160   0xAF0C             ADD      R7,SP,#+48
   1054            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \      0x162   0xBF00             Nop
   \      0x164   0x....             ADR.N    R1,?_29
   \      0x166   0xE887 0x000D      STM      R7,{R0,R2,R3}
   \      0x16A   0xF8CD 0x9030      STR      R9,[SP, #+48]
   \      0x16E   0xF8CD 0xE038      STR      LR,[SP, #+56]
   \      0x172   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x176   0xAF09             ADD      R7,SP,#+36
   \      0x178   0xF104 0x091D      ADD      R9,R4,#+29
   \      0x17C   0xE887 0x400C      STM      R7,{R2,R3,LR}
   \      0x180   0xF8CD 0x9024      STR      R9,[SP, #+36]
   1055          
   1056            SE_DataTransfer_t message_length_in = SE_DATATRANSFER_DEFAULT(&total_message_length, sizeof(uint32_t));
   \      0x184   0x....             ADR.N    R0,?_30
   \      0x186   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x18A   0xAF06             ADD      R7,SP,#+24
   \      0x18C   0xF10D 0x0E70      ADD      LR,SP,#+112
   \      0x190   0xE887 0x000E      STM      R7,{R1-R3}
   \      0x194   0xF8CD 0xE018      STR      LR,[SP, #+24]
   1057          
   1058            sli_se_command_init(cmd_ctx,
   1059                                ((ccm_ctx->mode == SL_SE_DECRYPT)
   1060                                 ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1061                                | SLI_SE_COMMAND_OPTION_CONTEXT_START);
   \      0x198   0x7F20             LDRB     R0,[R4, #+28]
   \      0x19A   0x2801             CMP      R0,#+1
   \      0x19C   0xBF0C             ITE      EQ
   \      0x19E   0x.... 0x....      LDREQ.W  R0,??DataTable118
   \      0x1A2   0x.... 0x....      LDRNE.W  R0,??DataTable118_1
   \      0x1A6   0x.... 0x....      BL       ?Subroutine7
   1062          
   1063            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x1AA   0x4630             MOV      R0,R6
   \      0x1AC   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x1B0   0x2800             CMP      R0,#+0
   \      0x1B2   0xD12B             BNE.N    ??sl_se_ccm_multipart_starts_3
   \      0x1B4   0x.... 0x....      BL       ?Subroutine18
   1064          
   1065            SE_addParameter(se_cmd, ((iv_len & 0xFFFF) << 16) | (tag_len & 0xFFFF));
   \                     ??CrossCallReturnLabel_36: (+1)
   \      0x1B8   0x4651             MOV      R1,R10
   \      0x1BA   0x.... 0x....      BL       ??Subroutine24_0
   1066            SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_131: (+1)
   \      0x1BE   0x4641             MOV      R1,R8
   \      0x1C0   0x.... 0x....      BL       ??Subroutine24_0
   1067            SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_130: (+1)
   \      0x1C4   0x.... 0x....      BL       ?Subroutine24
   1068          
   1069            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_135: (+1)
   \      0x1C8   0x.... 0x....      BL       ?Subroutine26
   \                     ??CrossCallReturnLabel_152: (+1)
   \      0x1CC   0xB9F0             CBNZ.N   R0,??sl_se_ccm_multipart_starts_3
   \      0x1CE   0xA903             ADD      R1,SP,#+12
   \      0x1D0   0x.... 0x....      BL       ??Subroutine29_0
   1070            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_180: (+1)
   \      0x1D4   0x.... 0x....      BL       ?Subroutine35
   \                     ??CrossCallReturnLabel_224: (+1)
   \      0x1D8   0xB9C0             CBNZ.N   R0,??sl_se_ccm_multipart_starts_3
   \      0x1DA   0x.... 0x....      BL       ?Subroutine13
   1071          
   1072            SE_addDataInput(se_cmd, &message_length_in);
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x1DE   0xA906             ADD      R1,SP,#+24
   \      0x1E0   0x.... 0x....      BL       ??Subroutine29_0
   1073          
   1074            SE_addDataInput(se_cmd, &iv_in);
   \                     ??CrossCallReturnLabel_179: (+1)
   \      0x1E4   0xA90F             ADD      R1,SP,#+60
   \      0x1E6   0x.... 0x....      BL       ??Subroutine29_0
   1075            SE_addDataInput(se_cmd, &add_in);
   \                     ??CrossCallReturnLabel_178: (+1)
   \      0x1EA   0x.... 0x....      BL       ?Subroutine29
   1076            SE_addDataOutput(se_cmd, &ctx_out);
   \                     ??CrossCallReturnLabel_185: (+1)
   \      0x1EE   0xA909             ADD      R1,SP,#+36
   \      0x1F0   0x.... 0x....      BL       ??Subroutine39_0
   1077          
   1078            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_246: (+1)
   \      0x1F4   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_254: (+1)
   \      0x1F8   0x0005             MOVS     R5,R0
   1079            if (status != SL_STATUS_OK) {
   \      0x1FA   0xD006             BEQ.N    ??sl_se_ccm_multipart_starts_8
   1080              memset(ccm_ctx->se_ctx, 0, sizeof(ccm_ctx->se_ctx));
   \      0x1FC   0x2120             MOVS     R1,#+32
   \      0x1FE   0xF104 0x001D      ADD      R0,R4,#+29
   \                     ??sl_se_ccm_multipart_starts_7: (+1)
   \      0x202   0x.... 0x....      BL       __aeabi_memclr
   1081              return status;
   \                     ??sl_se_ccm_multipart_starts_6: (+1)
   \      0x206   0x4628             MOV      R0,R5
   \      0x208   0xE000             B.N      ??sl_se_ccm_multipart_starts_3
   1082            }
   1083          
   1084            return status;
   \                     ??sl_se_ccm_multipart_starts_8: (+1)
   \      0x20A   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ccm_multipart_starts_3: (+1)
   \      0x20C                      REQUIRE ?Subroutine1
   \      0x20C                      ;; // Fall through to label ?Subroutine1
   1085          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x9900             LDR      R1,[SP, #+0]
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0xF36B 0x4A1F      BFI      R10,R11,#+16,#+16
   \        0x8   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x6028             STR      R0,[R5, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6068             STR      R0,[R5, #+4]
   \        0x6   0x60A8             STR      R0,[R5, #+8]
   \        0x8   0x61E8             STR      R0,[R5, #+28]
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine40: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \        0x0   0xA90C             ADD      R1,SP,#+48
   \                     ??Subroutine29_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??Subroutine24_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      sli_se_key_to_keyspec

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine39: (+1)
   \        0x0   0xA906             ADD      R1,SP,#+24
   \                     ??Subroutine39_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \                     ??Subroutine35_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      sli_se_get_key_input_output

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \        0x0   0xA903             ADD      R1,SP,#+12
   \                     ??Subroutine26_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      sli_se_get_auth_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_30:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004
   1086          #endif
   1087          
   1088          /***************************************************************************//**
   1089           *   This function feeds an input buffer into an ongoing CCM computation.
   1090           *   It is called between sl_se_ccm_multipart_starts() and sl_se_ccm_multipart_finish().
   1091           *   Can be called repeatedly.
   1092           ******************************************************************************/
   1093          #if defined(SLI_SE_MAJOR_VERSION_TWO)

   \                                 In section .text, align 4, keep-with-next
   1094          sl_status_t sl_se_ccm_multipart_update(sl_se_ccm_multipart_context_t *ccm_ctx,
   1095                                                 sl_se_command_context_t *cmd_ctx,
   1096                                                 const sl_se_key_descriptor_t *key,
   1097                                                 size_t length,
   1098                                                 const uint8_t *input,
   1099                                                 uint8_t *output,
   1100                                                 size_t *output_length)
   1101          {
   \                     sl_se_ccm_multipart_update: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x0005             MOVS     R5,R0
   1102            sl_status_t status = SL_STATUS_OK;
   1103          
   1104            // Check input parameters.
   1105            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL) {
   \        0x8   0xD03A             BEQ.N    ??sl_se_ccm_multipart_update_0
   \        0xA   0x000E             MOVS     R6,R1
   \        0xC   0xBF1C             ITT      NE
   \        0xE   0x9200             STRNE    R2,[SP, #+0]
   \       0x10   0x2A00             CMPNE    R2,#+0
   \       0x12   0xD035             BEQ.N    ??sl_se_ccm_multipart_update_0
   \       0x14   0x001C             MOVS     R4,R3
   1106              return SL_STATUS_INVALID_PARAMETER;
   1107            }
   1108          
   1109            if (length == 0) {
   \       0x16   0xD044             BEQ.N    ??sl_se_ccm_multipart_update_1
   1110              return SL_STATUS_OK;
   1111            }
   1112          
   1113            if (ccm_ctx->processed_message_length + length > ccm_ctx->total_message_length) {
   \       0x18   0x6828             LDR      R0,[R5, #+0]
   \       0x1A   0x686A             LDR      R2,[R5, #+4]
   \       0x1C   0x1821             ADDS     R1,R4,R0
   \       0x1E   0x428A             CMP      R2,R1
   \       0x20   0xBF22             ITTT     CS
   \       0x22   0xF04F 0x31FF      MOVCS    R1,#+4294967295
   \       0x26   0x1B09             SUBCS    R1,R1,R4
   \       0x28   0x4281             CMPCS    R1,R0
   1114              return SL_STATUS_INVALID_PARAMETER;
   1115            }
   1116          
   1117            // Check variable overflow
   1118            if (ccm_ctx->processed_message_length > 0xFFFFFFFF - length) {
   \       0x2A   0xD329             BCC.N    ??sl_se_ccm_multipart_update_0
   \       0x2C   0x9F1E             LDR      R7,[SP, #+120]
   \       0x2E   0x2F00             CMP      R7,#+0
   \       0x30   0xBF1C             ITT      NE
   \       0x32   0xF8DD 0x807C      LDRNE    R8,[SP, #+124]
   \       0x36   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x3A   0xD021             BEQ.N    ??sl_se_ccm_multipart_update_0
   1119              return SL_STATUS_INVALID_PARAMETER;
   1120            }
   1121          
   1122            if (length > 0 && (input == NULL || output == NULL)) {
   1123              return SL_STATUS_INVALID_PARAMETER;
   1124            }
   1125          
   1126          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
   1127            if ((uint32_t)output + length > RAM_MEM_END) {
   \       0x3C   0xEB04 0x0108      ADD      R1,R4,R8
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable116
   \       0x44   0x4281             CMP      R1,R0
   \       0x46   0xD21B             BCS.N    ??sl_se_ccm_multipart_update_0
   \       0x48   0xF8DD 0xB080      LDR      R11,[SP, #+128]
   1128              return SL_STATUS_INVALID_PARAMETER;
   1129            }
   1130          #endif // SLI_SE_MANAGER_HOST_SYSTEM
   1131          
   1132            SE_Command_t *se_cmd = &cmd_ctx->command;
   1133            *output_length = 0;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xF8CB 0x0000      STR      R0,[R11, #+0]
   1134          
   1135            // Approach:
   1136            // Encrypt or decrypt regularly with context store. The crypto DMA must have input data in the 'END' operation, thus,
   1137            // some data must be saved in the context.
   1138          
   1139            if ((ccm_ctx->final_data_length + length) < 16 && length < 16) {
   \       0x52   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \       0x56   0x1821             ADDS     R1,R4,R0
   \       0x58   0x2910             CMP      R1,#+16
   \       0x5A   0xBF38             IT       CC
   \       0x5C   0x2C10             CMPCC    R4,#+16
   \       0x5E   0xD206             BCS.N    ??sl_se_ccm_multipart_update_2
   1140              if (ccm_ctx->final_data_length > 16) {
   \       0x60   0x2810             CMP      R0,#+16
   \       0x62   0xDC0D             BGT.N    ??sl_se_ccm_multipart_update_0
   1141                // Context is not valid.
   1142                return SL_STATUS_INVALID_PARAMETER;
   1143              }
   1144          
   1145              memcpy(ccm_ctx->mode_specific_buffer.final_data + ccm_ctx->final_data_length, input, length);
   \       0x64   0x4428             ADD      R0,R5,R0
   \       0x66   0x4622             MOV      R2,R4
   \       0x68   0x4639             MOV      R1,R7
   \       0x6A   0x303D             ADDS     R0,R0,#+61
   \       0x6C   0xE09B             B.N      ??sl_se_ccm_multipart_update_3
   1146              ccm_ctx->final_data_length += length;
   1147              return SL_STATUS_OK;
   1148            }
   1149          
   1150            // If there is data in final_data, this must be processed first
   1151            if (ccm_ctx->final_data_length) {
   \                     ??sl_se_ccm_multipart_update_2: (+1)
   \       0x6E   0x.... 0x....      LDR.W    R9,??DataTable119
   \       0x72   0x.... 0x....      LDR.W    R10,??DataTable119_1
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xF000 0x808F      BEQ.W    ??sl_se_ccm_multipart_update_4
   1152              if (ccm_ctx->final_data_length > 16) {
   \       0x7C   0x2810             CMP      R0,#+16
   \       0x7E   0xDD01             BLE.N    ??sl_se_ccm_multipart_update_5
   1153                // Context is not valid.
   1154                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_update_0: (+1)
   \       0x80   0x2021             MOVS     R0,#+33
   \       0x82   0xE12B             B.N      ??sl_se_ccm_multipart_update_6
   1155              }
   1156          
   1157              // Fill up the remainder of the buffer.
   1158              memcpy(ccm_ctx->mode_specific_buffer.final_data + ccm_ctx->final_data_length, input, 16 - ccm_ctx->final_data_length);
   \                     ??sl_se_ccm_multipart_update_5: (+1)
   \       0x84   0xF1C0 0x0210      RSB      R2,R0,#+16
   \       0x88   0x4428             ADD      R0,R5,R0
   \       0x8A   0x4639             MOV      R1,R7
   \       0x8C   0x303D             ADDS     R0,R0,#+61
   \       0x8E   0x.... 0x....      BL       __aeabi_memcpy
   1159          
   1160              if (ccm_ctx->processed_message_length + 16 == ccm_ctx->total_message_length ) {
   \       0x92   0x6829             LDR      R1,[R5, #+0]
   \       0x94   0x6868             LDR      R0,[R5, #+4]
   \       0x96   0x3110             ADDS     R1,R1,#+16
   \       0x98   0x4281             CMP      R1,R0
   \       0x9A   0xD103             BNE.N    ??sl_se_ccm_multipart_update_7
   1161                // The finish operation must have some data or the SE fails.
   1162                ccm_ctx->final_data_length = 16;
   \       0x9C   0x2110             MOVS     R1,#+16
   \       0x9E   0xF885 0x104D      STRB     R1,[R5, #+77]
   1163                return SL_STATUS_OK;
   \                     ??sl_se_ccm_multipart_update_1: (+1)
   \       0xA2   0xE11A             B.N      ??sl_se_ccm_multipart_update_8
   1164              }
   1165          
   1166              SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \                     ??sl_se_ccm_multipart_update_7: (+1)
   \       0xA4   0x.... 0x....      ADR.W    R0,?_31
   \       0xA8   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xAC   0xAB11             ADD      R3,SP,#+68
   \       0xAE   0xF105 0x001D      ADD      R0,R5,#+29
   \       0xB2   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xB6   0x9011             STR      R0,[SP, #+68]
   1167          
   1168              SE_DataTransfer_t data_in =
   1169                SE_DATATRANSFER_DEFAULT(ccm_ctx->mode_specific_buffer.final_data, 16);
   \       0xB8   0x.... 0x....      ADR.W    R0,?_32
   \       0xBC   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xC0   0xAB0E             ADD      R3,SP,#+56
   \       0xC2   0xF105 0x003D      ADD      R0,R5,#+61
   \       0xC6   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xCA   0x900E             STR      R0,[SP, #+56]
   1170              SE_DataTransfer_t data_out =
   1171                SE_DATATRANSFER_DEFAULT(output, 16);
   \       0xCC   0x.... 0x....      ADR.W    R0,?_33
   \       0xD0   0xE890 0x1006      LDM      R0,{R1,R2,R12}
   \       0xD4   0xAB0B             ADD      R3,SP,#+44
   1172          
   1173              SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \       0xD6   0xF10D 0x0E20      ADD      LR,SP,#+32
   \       0xDA   0xE883 0x1006      STM      R3,{R1,R2,R12}
   \       0xDE   0xF8CD 0x802C      STR      R8,[SP, #+44]
   \       0xE2   0x.... 0x....      ADR.W    R1,?_34
   \       0xE6   0xE891 0x000D      LDM      R1,{R0,R2,R3}
   \       0xEA   0xE88E 0x000D      STM      LR,{R0,R2,R3}
   \       0xEE   0xF105 0x001D      ADD      R0,R5,#+29
   \       0xF2   0x9008             STR      R0,[SP, #+32]
   1174          
   1175              sli_se_command_init(cmd_ctx,
   1176                                  ((ccm_ctx->mode == SL_SE_DECRYPT)
   1177                                   ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1178                                  | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \       0xF4   0x7F29             LDRB     R1,[R5, #+28]
   \       0xF6   0x2901             CMP      R1,#+1
   \       0xF8   0xBF0C             ITE      EQ
   \       0xFA   0x4650             MOVEQ    R0,R10
   \       0xFC   0x4648             MOVNE    R0,R9
   \       0xFE   0x6030             STR      R0,[R6, #+0]
   \      0x100   0x.... 0x....      BL       ??Subroutine9_0
   1179          
   1180              sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_9: (+1)
   \      0x104   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_25: (+1)
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD12F             BNE.N    ??sl_se_ccm_multipart_update_9
   \      0x10C   0x.... 0x....      BL       ?Subroutine25
   1181          
   1182              SE_addParameter(se_cmd, 16);
   \                     ??CrossCallReturnLabel_149: (+1)
   \      0x110   0x2110             MOVS     R1,#+16
   \      0x112   0x.... 0x....      BL       ??Subroutine25_0
   1183          
   1184              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_143: (+1)
   \      0x116   0x9800             LDR      R0,[SP, #+0]
   \      0x118   0xA905             ADD      R1,SP,#+20
   \      0x11A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD124             BNE.N    ??sl_se_ccm_multipart_update_9
   \      0x122   0xA905             ADD      R1,SP,#+20
   \      0x124   0x.... 0x....      BL       ??Subroutine30_0
   1185              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_203: (+1)
   \      0x128   0x9800             LDR      R0,[SP, #+0]
   \      0x12A   0xA902             ADD      R1,SP,#+8
   \      0x12C   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD11B             BNE.N    ??sl_se_ccm_multipart_update_9
   \      0x134   0xA902             ADD      R1,SP,#+8
   \      0x136   0x.... 0x....      BL       ??Subroutine30_0
   1186          
   1187              SE_addDataInput(se_cmd, &iv_ctx_in);
   \                     ??CrossCallReturnLabel_202: (+1)
   \      0x13A   0x.... 0x....      BL       ?Subroutine30
   1188              SE_addDataInput(se_cmd, &data_in);
   \                     ??CrossCallReturnLabel_208: (+1)
   \      0x13E   0xA90E             ADD      R1,SP,#+56
   \      0x140   0x.... 0x....      BL       ??Subroutine30_0
   1189          
   1190              SE_addDataOutput(se_cmd, &data_out);
   \                     ??CrossCallReturnLabel_201: (+1)
   \      0x144   0xA90B             ADD      R1,SP,#+44
   \      0x146   0x.... 0x....      BL       ?Subroutine38
   1191              SE_addDataOutput(se_cmd, &ctx_out);
   \                     ??CrossCallReturnLabel_239: (+1)
   \      0x14A   0xA908             ADD      R1,SP,#+32
   \      0x14C   0x.... 0x....      BL       ?Subroutine38
   1192          
   1193              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_238: (+1)
   \      0x150   0x.... 0x....      BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_260: (+1)
   \      0x154   0x9001             STR      R0,[SP, #+4]
   1194              if (status != SL_STATUS_OK) {
   \      0x156   0xB150             CBZ.N    R0,??sl_se_ccm_multipart_update_10
   1195                memset(output, 0, length);
   \      0x158   0x4621             MOV      R1,R4
   \      0x15A   0x4640             MOV      R0,R8
   \      0x15C   0x.... 0x....      BL       __aeabi_memclr
   1196                memset(ccm_ctx->se_ctx, 0, sizeof(ccm_ctx->se_ctx));
   \      0x160   0x.... 0x....      BL       ?Subroutine48
   1197                *output_length = 0;
   \                     ??CrossCallReturnLabel_277: (+1)
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0xF8CB 0x0000      STR      R0,[R11, #+0]
   1198                return status;
   \      0x16A   0x9801             LDR      R0,[SP, #+4]
   \                     ??sl_se_ccm_multipart_update_9: (+1)
   \      0x16C   0xE0B6             B.N      ??sl_se_ccm_multipart_update_6
   1199              }
   1200              ccm_ctx->processed_message_length += 16;
   \                     ??sl_se_ccm_multipart_update_10: (+1)
   \      0x16E   0x6828             LDR      R0,[R5, #+0]
   1201              output += 16;
   \      0x170   0xF108 0x0810      ADD      R8,R8,#+16
   \      0x174   0x3010             ADDS     R0,R0,#+16
   \      0x176   0x6028             STR      R0,[R5, #+0]
   1202              length -= (16 - ccm_ctx->final_data_length);
   \      0x178   0xF895 0x104D      LDRB     R1,[R5, #+77]
   \      0x17C   0xF1C1 0x0010      RSB      R0,R1,#+16
   \      0x180   0x1A24             SUBS     R4,R4,R0
   1203              input += (16 - ccm_ctx->final_data_length);
   \      0x182   0x4249             RSBS     R1,R1,#+0
   \      0x184   0x1878             ADDS     R0,R7,R1
   1204              ccm_ctx->final_data_length = 0;
   \      0x186   0x2100             MOVS     R1,#+0
   \      0x188   0xF100 0x0710      ADD      R7,R0,#+16
   \      0x18C   0xF885 0x104D      STRB     R1,[R5, #+77]
   1205              *output_length += 16;
   \      0x190   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x194   0x3010             ADDS     R0,R0,#+16
   \      0x196   0xF8CB 0x0000      STR      R0,[R11, #+0]
   1206            }
   1207          
   1208            if (length < 16) {
   \                     ??sl_se_ccm_multipart_update_4: (+1)
   \      0x19A   0x2C10             CMP      R4,#+16
   \      0x19C   0xD20B             BCS.N    ??sl_se_ccm_multipart_update_11
   1209              memcpy(ccm_ctx->mode_specific_buffer.final_data, input, length);
   \      0x19E   0x4622             MOV      R2,R4
   \      0x1A0   0x4639             MOV      R1,R7
   \      0x1A2   0xF105 0x003D      ADD      R0,R5,#+61
   \                     ??sl_se_ccm_multipart_update_3: (+1)
   \      0x1A6   0x.... 0x....      BL       __aeabi_memcpy
   1210              ccm_ctx->final_data_length += length;
   \      0x1AA   0xF895 0x004D      LDRB     R0,[R5, #+77]
   \      0x1AE   0x1824             ADDS     R4,R4,R0
   \      0x1B0   0xF885 0x404D      STRB     R4,[R5, #+77]
   1211              return SL_STATUS_OK;
   \      0x1B4   0xE091             B.N      ??sl_se_ccm_multipart_update_8
   1212            }
   1213          
   1214            // Run only multiples of 16 and store residue data in context
   1215            if (length % 16 != 0) {
   \                     ??sl_se_ccm_multipart_update_11: (+1)
   \      0x1B6   0xF014 0x0F0F      TST      R4,#0xF
   \      0x1BA   0xD00D             BEQ.N    ??sl_se_ccm_multipart_update_12
   1216              uint8_t residue_data_length = length % 16;
   \      0x1BC   0xF004 0x000F      AND      R0,R4,#0xF
   \      0x1C0   0x9001             STR      R0,[SP, #+4]
   1217              memcpy(ccm_ctx->mode_specific_buffer.final_data, input + (length - residue_data_length), residue_data_length);
   \      0x1C2   0x4602             MOV      R2,R0
   \      0x1C4   0x1A20             SUBS     R0,R4,R0
   \      0x1C6   0x1839             ADDS     R1,R7,R0
   \      0x1C8   0xF105 0x003D      ADD      R0,R5,#+61
   \      0x1CC   0x.... 0x....      BL       __aeabi_memcpy
   1218              length -= residue_data_length;
   \      0x1D0   0x9801             LDR      R0,[SP, #+4]
   \      0x1D2   0x1A24             SUBS     R4,R4,R0
   1219              ccm_ctx->final_data_length = residue_data_length;
   \      0x1D4   0xF885 0x004D      STRB     R0,[R5, #+77]
   1220            }
   1221          
   1222            if ((ccm_ctx->total_message_length == ccm_ctx->processed_message_length + length) && !ccm_ctx->final_data_length) {
   \                     ??sl_se_ccm_multipart_update_12: (+1)
   \      0x1D8   0x6829             LDR      R1,[R5, #+0]
   \      0x1DA   0x6868             LDR      R0,[R5, #+4]
   \      0x1DC   0x1861             ADDS     R1,R4,R1
   \      0x1DE   0x4288             CMP      R0,R1
   \      0x1E0   0xBF04             ITT      EQ
   \      0x1E2   0xF895 0x004D      LDRBEQ   R0,[R5, #+77]
   \      0x1E6   0x2800             CMPEQ    R0,#+0
   \      0x1E8   0xD10B             BNE.N    ??sl_se_ccm_multipart_update_13
   1223              // The finish operation must have some data or the SE fails.
   1224              memcpy(ccm_ctx->mode_specific_buffer.final_data, input + (length - 16), 16);
   \      0x1EA   0x1939             ADDS     R1,R7,R4
   \      0x1EC   0x2210             MOVS     R2,#+16
   \      0x1EE   0x3910             SUBS     R1,R1,#+16
   \      0x1F0   0xF105 0x003D      ADD      R0,R5,#+61
   \      0x1F4   0x.... 0x....      BL       __aeabi_memcpy
   1225              ccm_ctx->final_data_length = 16;
   \      0x1F8   0x2010             MOVS     R0,#+16
   \      0x1FA   0xF885 0x004D      STRB     R0,[R5, #+77]
   1226              length -= 16;
   \      0x1FE   0x3C10             SUBS     R4,R4,#+16
   1227              if (!length) {
   \      0x200   0xD06B             BEQ.N    ??sl_se_ccm_multipart_update_8
   1228                return SL_STATUS_OK;
   1229              }
   1230            }
   1231          
   1232            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \                     ??sl_se_ccm_multipart_update_13: (+1)
   \      0x202   0x.... 0x....      ADR.W    LR,?_35
   \      0x206   0xE89E 0x000E      LDM      LR,{R1-R3}
   \      0x20A   0xA810             ADD      R0,SP,#+64
   \      0x20C   0xE880 0x000E      STM      R0,{R1-R3}
   1233          
   1234            SE_DataTransfer_t data_in =
   1235              SE_DATATRANSFER_DEFAULT(input, length);
   \      0x210   0x....             ADR.N    R1,?_36
   \      0x212   0xF105 0x001D      ADD      R0,R5,#+29
   \      0x216   0x9010             STR      R0,[SP, #+64]
   \      0x218   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x21C   0xA80D             ADD      R0,SP,#+52
   \      0x21E   0xF044 0x5100      ORR      R1,R4,#0x20000000
   \      0x222   0xE880 0x400C      STM      R0,{R2,R3,LR}
   \      0x226   0x970D             STR      R7,[SP, #+52]
   \      0x228   0x910F             STR      R1,[SP, #+60]
   1236            SE_DataTransfer_t data_out =
   1237              SE_DATATRANSFER_DEFAULT(output, length);
   \      0x22A   0xBF00             Nop
   \      0x22C   0x....             ADR.N    R2,?_37
   \      0x22E   0xE892 0x4088      LDM      R2,{R3,R7,LR}
   \      0x232   0xA80A             ADD      R0,SP,#+40
   \      0x234   0xE880 0x4088      STM      R0,{R3,R7,LR}
   \      0x238   0xF8CD 0x8028      STR      R8,[SP, #+40]
   \      0x23C   0x910C             STR      R1,[SP, #+48]
   1238          
   1239            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \      0x23E   0xBF00             Nop
   \      0x240   0x....             ADR.N    R7,?_38
   \      0x242   0xE897 0x0007      LDM      R7,{R0-R2}
   \      0x246   0xAB07             ADD      R3,SP,#+28
   \      0x248   0xF105 0x0E1D      ADD      LR,R5,#+29
   \      0x24C   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x250   0xF8CD 0xE01C      STR      LR,[SP, #+28]
   1240          
   1241            sli_se_command_init(cmd_ctx,
   1242                                ((ccm_ctx->mode == SL_SE_DECRYPT)
   1243                                 ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1244                                | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \      0x254   0x7F28             LDRB     R0,[R5, #+28]
   \      0x256   0x2801             CMP      R0,#+1
   \      0x258   0xBF08             IT       EQ
   \      0x25A   0x46D1             MOVEQ    R9,R10
   \      0x25C   0xF8C6 0x9000      STR      R9,[R6, #+0]
   \      0x260   0x2100             MOVS     R1,#+0
   \      0x262   0x6071             STR      R1,[R6, #+4]
   \      0x264   0x60B1             STR      R1,[R6, #+8]
   \      0x266   0x61F1             STR      R1,[R6, #+28]
   1245          
   1246            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x268   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_24: (+1)
   \      0x26C   0x2800             CMP      R0,#+0
   \      0x26E   0xD135             BNE.N    ??sl_se_ccm_multipart_update_6
   \      0x270   0x.... 0x....      BL       ?Subroutine25
   1247          
   1248            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_148: (+1)
   \      0x274   0x4621             MOV      R1,R4
   \      0x276   0x.... 0x....      BL       ??Subroutine25_0
   1249          
   1250            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_142: (+1)
   \      0x27A   0x9800             LDR      R0,[SP, #+0]
   \      0x27C   0xA904             ADD      R1,SP,#+16
   \      0x27E   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x282   0xBB58             CBNZ.N   R0,??sl_se_ccm_multipart_update_6
   \      0x284   0xA904             ADD      R1,SP,#+16
   \      0x286   0x.... 0x....      BL       ??Subroutine30_0
   1251            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_200: (+1)
   \      0x28A   0x9800             LDR      R0,[SP, #+0]
   \      0x28C   0xA901             ADD      R1,SP,#+4
   \      0x28E   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x292   0xBB18             CBNZ.N   R0,??sl_se_ccm_multipart_update_6
   \      0x294   0xA901             ADD      R1,SP,#+4
   \      0x296   0x.... 0x....      BL       ??Subroutine30_0
   1252          
   1253            SE_addDataInput(se_cmd, &iv_ctx_in);
   \                     ??CrossCallReturnLabel_199: (+1)
   \      0x29A   0xA910             ADD      R1,SP,#+64
   \      0x29C   0x.... 0x....      BL       ??Subroutine30_0
   1254            SE_addDataInput(se_cmd, &data_in);
   \                     ??CrossCallReturnLabel_198: (+1)
   \      0x2A0   0xA90D             ADD      R1,SP,#+52
   \      0x2A2   0x.... 0x....      BL       ??Subroutine30_0
   1255          
   1256            SE_addDataOutput(se_cmd, &data_out);
   \                     ??CrossCallReturnLabel_197: (+1)
   \      0x2A6   0xA90A             ADD      R1,SP,#+40
   \      0x2A8   0x.... 0x....      BL       ?Subroutine38
   1257            SE_addDataOutput(se_cmd, &ctx_out);
   \                     ??CrossCallReturnLabel_237: (+1)
   \      0x2AC   0xA907             ADD      R1,SP,#+28
   \      0x2AE   0x.... 0x....      BL       ?Subroutine38
   1258          
   1259            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_236: (+1)
   \      0x2B2   0x.... 0x....      BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_259: (+1)
   \      0x2B6   0x0006             MOVS     R6,R0
   1260            if (status != SL_STATUS_OK) {
   \      0x2B8   0xD007             BEQ.N    ??sl_se_ccm_multipart_update_14
   1261              memset(output, 0, length);
   \      0x2BA   0x4621             MOV      R1,R4
   \      0x2BC   0x4640             MOV      R0,R8
   \      0x2BE   0x.... 0x....      BL       __aeabi_memclr
   1262              memset(ccm_ctx->se_ctx, 0, sizeof(ccm_ctx->se_ctx));
   \      0x2C2   0x.... 0x....      BL       ?Subroutine48
   1263              return status;
   \                     ??CrossCallReturnLabel_278: (+1)
   \      0x2C6   0x4630             MOV      R0,R6
   \      0x2C8   0xE008             B.N      ??sl_se_ccm_multipart_update_6
   1264            }
   1265          
   1266            *output_length += length;
   \                     ??sl_se_ccm_multipart_update_14: (+1)
   \      0x2CA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x2CE   0x1820             ADDS     R0,R4,R0
   \      0x2D0   0xF8CB 0x0000      STR      R0,[R11, #+0]
   1267            ccm_ctx->processed_message_length += length;
   \      0x2D4   0x6829             LDR      R1,[R5, #+0]
   \      0x2D6   0x1864             ADDS     R4,R4,R1
   \      0x2D8   0x602C             STR      R4,[R5, #+0]
   1268          
   1269            return status;
   \                     ??sl_se_ccm_multipart_update_8: (+1)
   \      0x2DA   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ccm_multipart_update_6: (+1)
   \      0x2DC   0x....             B.N      ?Subroutine2
   1270          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x9800             LDR      R0,[SP, #+0]
   \        0x2   0xA901             ADD      R1,SP,#+4
   \        0x4   0x.... 0x....      B.W      sli_se_key_to_keyspec

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_37:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
   1271          #endif
   1272          
   1273          /***************************************************************************//**
   1274           *   Finish a CCM streaming operation and return the resulting CCM tag.
   1275           *   It is called after sl_se_ccm_multipart_update().
   1276           ******************************************************************************/
   1277          #if defined(SLI_SE_MAJOR_VERSION_TWO)

   \                                 In section .text, align 4, keep-with-next
   1278          sl_status_t sl_se_ccm_multipart_finish(sl_se_ccm_multipart_context_t *ccm_ctx,
   1279                                                 sl_se_command_context_t *cmd_ctx,
   1280                                                 const sl_se_key_descriptor_t *key,
   1281                                                 uint8_t *tag,
   1282                                                 uint8_t tag_size,
   1283                                                 uint8_t *output,
   1284                                                 uint8_t output_size,
   1285                                                 uint8_t *output_length)
   1286          {
   \                     sl_se_ccm_multipart_finish: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB093             SUB      SP,SP,#+76
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x461E             MOV      R6,R3
   1287            //Check input parameters
   1288            if (ccm_ctx == NULL || cmd_ctx == NULL || key == NULL || tag == NULL) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2D00             CMPNE    R5,#+0
   \       0x12   0xD00C             BEQ.N    ??sl_se_ccm_multipart_finish_0
   \       0x14   0x2F00             CMP      R7,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2E00             CMPNE    R6,#+0
   \       0x1A   0xD008             BEQ.N    ??sl_se_ccm_multipart_finish_0
   \       0x1C   0x981A             LDR      R0,[SP, #+104]
   1289              return SL_STATUS_INVALID_PARAMETER;
   1290            }
   1291          
   1292            if (tag_size < ccm_ctx->tag_len || output_size < ccm_ctx->final_data_length) {
   \       0x1E   0x69A2             LDR      R2,[R4, #+24]
   \       0x20   0x4290             CMP      R0,R2
   \       0x22   0xBF22             ITTT     CS
   \       0x24   0x981C             LDRCS    R0,[SP, #+112]
   \       0x26   0xF894 0x104D      LDRBCS   R1,[R4, #+77]
   \       0x2A   0x4288             CMPCS    R0,R1
   \       0x2C   0xD201             BCS.N    ??sl_se_ccm_multipart_finish_1
   1293              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ccm_multipart_finish_0: (+1)
   \       0x2E   0x2021             MOVS     R0,#+33
   \       0x30   0xE099             B.N      ??sl_se_ccm_multipart_finish_2
   1294            }
   1295          
   1296            sl_status_t status = SL_STATUS_OK;
   1297          
   1298            if (ccm_ctx->total_message_length == 0) {
   \                     ??sl_se_ccm_multipart_finish_1: (+1)
   \       0x32   0x6860             LDR      R0,[R4, #+4]
   \       0x34   0xB990             CBNZ.N   R0,??sl_se_ccm_multipart_finish_3
   1299              if (ccm_ctx->mode == SL_SE_DECRYPT) {
   \       0x36   0x7F20             LDRB     R0,[R4, #+28]
   \       0x38   0xF104 0x013D      ADD      R1,R4,#+61
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0x4630             MOV      R0,R6
   \       0x40   0xD109             BNE.N    ??sl_se_ccm_multipart_finish_4
   1300                if (memcmp_time_cst(tag, ccm_ctx->mode_specific_buffer.tagbuf, ccm_ctx->tag_len) != 0) {
   \       0x42   0x.... 0x....      BL       memcmp_time_cst
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD007             BEQ.N    ??sl_se_ccm_multipart_finish_5
   1301                  memset(tag, 0, ccm_ctx->tag_len);
   \       0x4A   0x69A1             LDR      R1,[R4, #+24]
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       __aeabi_memclr
   1302                  return SL_STATUS_INVALID_SIGNATURE;
   \       0x52   0x202C             MOVS     R0,#+44
   \       0x54   0xE087             B.N      ??sl_se_ccm_multipart_finish_2
   1303                }
   1304              } else {
   1305                memcpy(tag, ccm_ctx->mode_specific_buffer.tagbuf, ccm_ctx->tag_len);
   \                     ??sl_se_ccm_multipart_finish_4: (+1)
   \       0x56   0x.... 0x....      BL       __aeabi_memcpy
   1306              }
   1307              return SL_STATUS_OK;
   \                     ??sl_se_ccm_multipart_finish_5: (+1)
   \       0x5A   0xE083             B.N      ??sl_se_ccm_multipart_finish_6
   1308            }
   1309          
   1310            SE_Command_t *se_cmd = &cmd_ctx->command;
   1311          
   1312            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(ccm_ctx->se_ctx, sizeof(ccm_ctx->se_ctx));
   \                     ??sl_se_ccm_multipart_finish_3: (+1)
   \       0x5C   0x....             ADR.N    R0,?_39
   \       0x5E   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x62   0xF10D 0x0E40      ADD      LR,SP,#+64
   \       0x66   0xF104 0x081D      ADD      R8,R4,#+29
   \       0x6A   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0x6E   0xF8CD 0x8040      STR      R8,[SP, #+64]
   1313          
   1314            SE_DataTransfer_t data_in =
   1315              SE_DATATRANSFER_DEFAULT(ccm_ctx->mode_specific_buffer.final_data, ccm_ctx->final_data_length);
   \       0x72   0xBF00             Nop
   \       0x74   0x....             ADR.N    R0,?_40
   \       0x76   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x7A   0xF10D 0x0E34      ADD      LR,SP,#+52
   \       0x7E   0xF104 0x083D      ADD      R8,R4,#+61
   \       0x82   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0x86   0xF8CD 0x8034      STR      R8,[SP, #+52]
   \       0x8A   0xF894 0x004D      LDRB     R0,[R4, #+77]
   1316          
   1317            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, ccm_ctx->final_data_length);
   \       0x8E   0xF10D 0x0E28      ADD      LR,SP,#+40
   \       0x92   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0x96   0x900F             STR      R0,[SP, #+60]
   \       0x98   0x....             ADR.N    R0,?_41
   \       0x9A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x9E   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   \       0xA2   0xE88E 0x000E      STM      LR,{R1-R3}
   1318            SE_DataTransfer_t tag_buf = SE_DATATRANSFER_DEFAULT(tag,
   1319                                                                ccm_ctx->tag_len);
   \       0xA6   0xBF00             Nop
   \       0xA8   0x....             ADR.N    R1,?_42
   \       0xAA   0xF8CD 0x8028      STR      R8,[SP, #+40]
   \       0xAE   0xF894 0x004D      LDRB     R0,[R4, #+77]
   \       0xB2   0xF10D 0x0E04      ADD      LR,SP,#+4
   \       0xB6   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xBA   0x900C             STR      R0,[SP, #+48]
   \       0xBC   0xE891 0x010C      LDM      R1,{R2,R3,R8}
   \       0xC0   0xE88E 0x010C      STM      LR,{R2,R3,R8}
   \       0xC4   0x9601             STR      R6,[SP, #+4]
   \       0xC6   0x69A0             LDR      R0,[R4, #+24]
   \       0xC8   0xF040 0x5E00      ORR      LR,R0,#0x20000000
   \       0xCC   0xF8CD 0xE00C      STR      LR,[SP, #+12]
   1320          
   1321            sli_se_command_init(cmd_ctx,
   1322                                ((ccm_ctx->mode == SL_SE_DECRYPT)
   1323                                 ? SLI_SE_COMMAND_AES_CCM_DECRYPT : SLI_SE_COMMAND_AES_CCM_ENCRYPT)
   1324                                | SLI_SE_COMMAND_OPTION_CONTEXT_END);
   \       0xD0   0x7F20             LDRB     R0,[R4, #+28]
   \       0xD2   0x2801             CMP      R0,#+1
   \       0xD4   0xBF0C             ITE      EQ
   \       0xD6   0x.... 0x....      LDREQ.W  R0,??DataTable122
   \       0xDA   0x.... 0x....      LDRNE.W  R0,??DataTable122_1
   \       0xDE   0x.... 0x....      BL       ?Subroutine7
   1325          
   1326            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xE2   0x4638             MOV      R0,R7
   \       0xE4   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD13C             BNE.N    ??sl_se_ccm_multipart_finish_2
   \       0xEC   0x.... 0x....      BL       ?Subroutine19
   1327          
   1328            SE_addParameter(se_cmd, (ccm_ctx->tag_len & 0xFFFF));
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0xF0   0x69A1             LDR      R1,[R4, #+24]
   \       0xF2   0x4628             MOV      R0,R5
   \       0xF4   0xB289             UXTH     R1,R1
   \       0xF6   0x.... 0x....      BL       SE_addParameter
   1329          
   1330            SE_addParameter(se_cmd, ccm_ctx->final_data_length);
   \       0xFA   0xF894 0x104D      LDRB     R1,[R4, #+77]
   \       0xFE   0x.... 0x....      BL       ??Subroutine24_0
   1331          
   1332            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_129: (+1)
   \      0x102   0xA907             ADD      R1,SP,#+28
   \      0x104   0x.... 0x....      BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_154: (+1)
   \      0x108   0xBB68             CBNZ.N   R0,??sl_se_ccm_multipart_finish_2
   \      0x10A   0xA907             ADD      R1,SP,#+28
   \      0x10C   0x.... 0x....      BL       ??Subroutine29_0
   1333            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_177: (+1)
   \      0x110   0xA904             ADD      R1,SP,#+16
   \      0x112   0x.... 0x....      BL       ??Subroutine36_0
   \                     ??CrossCallReturnLabel_226: (+1)
   \      0x116   0xBB30             CBNZ.N   R0,??sl_se_ccm_multipart_finish_2
   \      0x118   0xA904             ADD      R1,SP,#+16
   \      0x11A   0x.... 0x....      BL       ??Subroutine29_0
   1334          
   1335            SE_addDataInput(se_cmd, &iv_ctx_in);
   \                     ??CrossCallReturnLabel_176: (+1)
   \      0x11E   0xA910             ADD      R1,SP,#+64
   \      0x120   0x.... 0x....      BL       ??Subroutine29_0
   1336            SE_addDataInput(se_cmd, &data_in);
   \                     ??CrossCallReturnLabel_175: (+1)
   \      0x124   0xA90D             ADD      R1,SP,#+52
   \      0x126   0x.... 0x....      BL       ??Subroutine29_0
   1337          
   1338            SE_addDataOutput(se_cmd, &data_out);
   \                     ??CrossCallReturnLabel_174: (+1)
   \      0x12A   0xA90A             ADD      R1,SP,#+40
   \      0x12C   0x.... 0x....      BL       ??Subroutine39_0
   1339            if (ccm_ctx->mode == SL_SE_DECRYPT) {
   \                     ??CrossCallReturnLabel_245: (+1)
   \      0x130   0x7F20             LDRB     R0,[R4, #+28]
   \      0x132   0xA901             ADD      R1,SP,#+4
   \      0x134   0x2801             CMP      R0,#+1
   \      0x136   0x4628             MOV      R0,R5
   \      0x138   0xD102             BNE.N    ??sl_se_ccm_multipart_finish_7
   1340              SE_addDataInput(se_cmd, &tag_buf);
   \      0x13A   0x.... 0x....      BL       SE_addDataInput
   \      0x13E   0xE001             B.N      ??sl_se_ccm_multipart_finish_8
   1341            } else {
   1342              SE_addDataOutput(se_cmd, &tag_buf);
   \                     ??sl_se_ccm_multipart_finish_7: (+1)
   \      0x140   0x.... 0x....      BL       SE_addDataOutput
   1343            }
   1344            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??sl_se_ccm_multipart_finish_8: (+1)
   \      0x144   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_253: (+1)
   \      0x148   0x0005             MOVS     R5,R0
   \      0x14A   0x9F1D             LDR      R7,[SP, #+116]
   1345          
   1346            if (status != SL_STATUS_OK) {
   \      0x14C   0xD007             BEQ.N    ??sl_se_ccm_multipart_finish_9
   1347              memset(tag, 0, ccm_ctx->tag_len);
   \      0x14E   0x69A1             LDR      R1,[R4, #+24]
   \      0x150   0x4630             MOV      R0,R6
   \      0x152   0x.... 0x....      BL       __aeabi_memclr
   1348              *output_length = 0;
   \      0x156   0x2000             MOVS     R0,#+0
   \      0x158   0x7038             STRB     R0,[R7, #+0]
   1349              return status;
   \      0x15A   0x4628             MOV      R0,R5
   \      0x15C   0xE003             B.N      ??sl_se_ccm_multipart_finish_2
   1350            }
   1351          
   1352            *output_length = ccm_ctx->final_data_length;
   \                     ??sl_se_ccm_multipart_finish_9: (+1)
   \      0x15E   0xF894 0x104D      LDRB     R1,[R4, #+77]
   \      0x162   0x7039             STRB     R1,[R7, #+0]
   1353          
   1354            return SL_STATUS_OK;
   \                     ??sl_se_ccm_multipart_finish_6: (+1)
   \      0x164   0x2000             MOVS     R0,#+0
   \                     ??sl_se_ccm_multipart_finish_2: (+1)
   \      0x166   0xB014             ADD      SP,SP,#+80
   \      0x168   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1355          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x9900             LDR      R1,[SP, #+0]
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 4, keep-with-next
   \                     ?_39:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_40:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_41:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_42:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1356          #endif
   1357          
   1358          /***************************************************************************//**
   1359           * This function calculates the full generic CMAC on the input buffer with
   1360           * the provided key.
   1361           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1362          sl_status_t sl_se_cmac(sl_se_command_context_t *cmd_ctx,
   1363                                 const sl_se_key_descriptor_t *key,
   1364                                 const unsigned char *input,
   1365                                 size_t input_len,
   1366                                 unsigned char *output)
   1367          {
   \                     sl_se_cmac: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460F             MOV      R7,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x4698             MOV      R8,R3
   1368            if (cmd_ctx == NULL || key == NULL || input == NULL || output == NULL) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2F00             CMPNE    R7,#+0
   \       0x12   0xD01F             BEQ.N    ??sl_se_cmac_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x9E12             LDRNE    R6,[SP, #+72]
   \       0x1A   0x2E00             CMPNE    R6,#+0
   \       0x1C   0xD01A             BEQ.N    ??sl_se_cmac_0
   1369              return SL_STATUS_INVALID_PARAMETER;
   1370            }
   1371          
   1372            SE_Command_t *se_cmd = &cmd_ctx->command;
   1373            sl_status_t status = SL_STATUS_OK;
   1374          
   1375            switch (key->type) {
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x2810             CMP      R0,#+16
   \       0x22   0xBF1C             ITT      NE
   \       0x24   0x2818             CMPNE    R0,#+24
   \       0x26   0x2820             CMPNE    R0,#+32
   \       0x28   0xD114             BNE.N    ??sl_se_cmac_0
   1376              case SL_SE_KEY_TYPE_AES_128:
   1377              case SL_SE_KEY_TYPE_AES_192:
   1378              case SL_SE_KEY_TYPE_AES_256:
   1379                break;
   1380          
   1381              default:
   1382                return SL_STATUS_INVALID_PARAMETER;
   1383            }
   1384          
   1385            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CMAC);
   \       0x2A   0x.... 0x....      LDR.W    R2,??DataTable122_2
   \       0x2E   0x6022             STR      R2,[R4, #+0]
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x6061             STR      R1,[R4, #+4]
   \       0x34   0x60A1             STR      R1,[R4, #+8]
   \       0x36   0x61E1             STR      R1,[R4, #+28]
   1386          
   1387            // Add key parameter to command.
   1388            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x38   0x4669             MOV      R1,SP
   \       0x3A   0x4638             MOV      R0,R7
   \       0x3C   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD126             BNE.N    ??CrossCallReturnLabel_116
   \       0x44   0x.... 0x....      BL       ?Subroutine17
   1389          
   1390            // Message size parameter.
   1391            SE_addParameter(se_cmd, input_len);
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x48   0x.... 0x....      BL       ?Subroutine21
   1392          
   1393            // Key metadata.
   1394            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_98: (+1)
   \       0x4C   0x.... 0x....      BL       ?Subroutine27
   \                     ??CrossCallReturnLabel_155: (+1)
   \       0x50   0xB110             CBZ.N    R0,??sl_se_cmac_1
   \       0x52   0xE01E             B.N      ??CrossCallReturnLabel_116
   \                     ??sl_se_cmac_0: (+1)
   \       0x54   0x2021             MOVS     R0,#+33
   \       0x56   0xE01C             B.N      ??CrossCallReturnLabel_116
   \                     ??sl_se_cmac_1: (+1)
   \       0x58   0xA909             ADD      R1,SP,#+36
   \       0x5A   0x.... 0x....      BL       ??Subroutine20_1
   1395            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x5E   0x.... 0x....      BL       ?Subroutine36
   \                     ??CrossCallReturnLabel_227: (+1)
   \       0x62   0xB9B0             CBNZ.N   R0,??CrossCallReturnLabel_116
   \       0x64   0xA906             ADD      R1,SP,#+24
   \       0x66   0x.... 0x....      BL       ??Subroutine20_1
   1396          
   1397            // Data input.
   1398            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(input, input_len);
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x6A   0xBF00             Nop
   \       0x6C   0x....             ADR.N    R0,?_43
   \       0x6E   0x.... 0x....      BL       ?Subroutine34
   \                     ??CrossCallReturnLabel_221: (+1)
   \       0x72   0x9503             STR      R5,[SP, #+12]
   \       0x74   0x.... 0x....      BL       ?Subroutine20
   1399            SE_addDataInput(se_cmd, &in_data);
   1400          
   1401            // Data output.
   1402            SE_DataTransfer_t out_tag = SE_DATATRANSFER_DEFAULT(output, 16);
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x78   0x....             ADR.N    R0,?_44
   \       0x7A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x7E   0x466D             MOV      R5,SP
   1403            SE_addDataOutput(se_cmd, &out_tag);
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0xE885 0x000E      STM      R5,{R1-R3}
   \       0x86   0x9600             STR      R6,[SP, #+0]
   \       0x88   0x4669             MOV      R1,SP
   \       0x8A   0x.... 0x....      BL       SE_addDataOutput
   1404          
   1405            return sli_se_execute_and_wait(cmd_ctx);
   \       0x8E   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_116: (+1)
   \       0x92                      REQUIRE ?Subroutine0
   \       0x92                      ;; // Fall through to label ?Subroutine0
   1406          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_43:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_44:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1407          
   1408          /***************************************************************************//**
   1409           *   Finish a CMAC streaming operation and return the resulting CMAC tag.
   1410           *   It is called after sl_se_cmac_update().
   1411           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1412          sl_status_t sl_se_cmac_multipart_finish(sl_se_cmac_multipart_context_t *cmac_ctx,
   1413                                                  sl_se_command_context_t *cmd_ctx,
   1414                                                  const sl_se_key_descriptor_t *key,
   1415                                                  uint8_t *output)
   1416          {
   \                     sl_se_cmac_multipart_finish: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461F             MOV      R7,R3
   1417            sl_status_t status = SL_STATUS_OK;
   1418          
   1419            if (cmac_ctx == NULL || cmd_ctx == NULL || key == NULL || output == NULL) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2D00             CMPNE    R5,#+0
   \       0x12   0xD003             BEQ.N    ??sl_se_cmac_multipart_finish_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xBF18             IT       NE
   \       0x18   0x2F00             CMPNE    R7,#+0
   \       0x1A   0xD101             BNE.N    ??sl_se_cmac_multipart_finish_1
   1420              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_cmac_multipart_finish_0: (+1)
   \       0x1C   0x2021             MOVS     R0,#+33
   \       0x1E   0xE074             B.N      ??CrossCallReturnLabel_252
   1421            }
   1422          
   1423            if (cmac_ctx->length >= 16U) {
   \                     ??sl_se_cmac_multipart_finish_1: (+1)
   \       0x20   0x6B21             LDR      R1,[R4, #+48]
   \       0x22   0x2910             CMP      R1,#+16
   \       0x24   0xD30B             BCC.N    ??sl_se_cmac_multipart_finish_2
   1424              // Compute previous input block by decryption of current data.
   1425              status = sl_se_aes_crypt_ecb(cmd_ctx,
   1426                                           key,
   1427                                           SL_SE_DECRYPT,
   1428                                           16U,
   1429                                           cmac_ctx->data_out,
   1430                                           cmac_ctx->state);  // Keep decrypted data in 'state'
   \       0x26   0xF104 0x0020      ADD      R0,R4,#+32
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x9401             STR      R4,[SP, #+4]
   \       0x2E   0x2310             MOVS     R3,#+16
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x4631             MOV      R1,R6
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       sl_se_aes_crypt_ecb
   1431            }
   1432          
   1433            if (status == SL_STATUS_OK) {
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD165             BNE.N    ??CrossCallReturnLabel_252
   1434              // Feed previous block and unprocessed data (if any) to CMAC,
   1435              // or on data < 16 just use accumulated data in context.
   1436              SE_Command_t *se_cmd = &cmd_ctx->command;
   1437              sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_CMAC);
   \                     ??sl_se_cmac_multipart_finish_2: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable122_2
   \       0x42   0x6028             STR      R0,[R5, #+0]
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x606A             STR      R2,[R5, #+4]
   \       0x48   0x60AA             STR      R2,[R5, #+8]
   \       0x4A   0x61EA             STR      R2,[R5, #+28]
   1438          
   1439              // Add key parameter to command.
   1440              sli_add_key_parameters(cmd_ctx, key, status);
   \       0x4C   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD15A             BNE.N    ??CrossCallReturnLabel_252
   \       0x54   0x.... 0x....      BL       ?Subroutine19
   1441          
   1442              // Message size parameter.
   1443              if (cmac_ctx->length >= 16U) {
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x58   0x6B21             LDR      R1,[R4, #+48]
   \       0x5A   0x2910             CMP      R1,#+16
   \       0x5C   0xBF24             ITT      CS
   \       0x5E   0xF001 0x010F      ANDCS    R1,R1,#0xF
   \       0x62   0x3110             ADDCS    R1,R1,#+16
   1444                SE_addParameter(se_cmd, 16U + (cmac_ctx->length & 0xFU));
   1445              } else {
   1446                SE_addParameter(se_cmd, cmac_ctx->length);
   \       0x64   0x.... 0x....      BL       ??Subroutine24_0
   1447              }
   1448          
   1449              // Key metadata.
   1450              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_128: (+1)
   \       0x68   0xA90F             ADD      R1,SP,#+60
   \       0x6A   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_151: (+1)
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD14B             BNE.N    ??CrossCallReturnLabel_252
   \       0x72   0xA90F             ADD      R1,SP,#+60
   \       0x74   0x.... 0x....      BL       ??Subroutine29_0
   1451              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_173: (+1)
   \       0x78   0xA90C             ADD      R1,SP,#+48
   \       0x7A   0x.... 0x....      BL       ??Subroutine35_0
   \                     ??CrossCallReturnLabel_223: (+1)
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD143             BNE.N    ??CrossCallReturnLabel_252
   \       0x82   0x.... 0x....      BL       ?Subroutine29
   1452          
   1453              SE_DataTransfer_t in_data1 = SE_DATATRANSFER_DEFAULT(cmac_ctx->state, 16U);
   \                     ??CrossCallReturnLabel_184: (+1)
   \       0x86   0xBF00             Nop
   \       0x88   0x....             ADR.N    R1,?_45
   \       0x8A   0xE891 0x0700      LDM      R1,{R8-R10}
   \       0x8E   0x4668             MOV      R0,SP
   1454              SE_DataTransfer_t in_data2 = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_in,
   1455                                                                   cmac_ctx->length & 0xFU);
   \       0x90   0xAB09             ADD      R3,SP,#+36
   \       0x92   0xE880 0x0700      STM      R0,{R8-R10}
   \       0x96   0x9400             STR      R4,[SP, #+0]
   \       0x98   0x....             ADR.N    R0,?_46
   \       0x9A   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \       0x9E   0xF104 0x0E10      ADD      LR,R4,#+16
   \       0xA2   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \       0xA6   0xF8CD 0xE024      STR      LR,[SP, #+36]
   \       0xAA   0xF894 0x0030      LDRB     R0,[R4, #+48]
   1456              SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_in,
   1457                                                                  cmac_ctx->length);
   \       0xAE   0xAE06             ADD      R6,SP,#+24
   \       0xB0   0xF000 0x000F      AND      R0,R0,#0xF
   \       0xB4   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xB8   0xF8CD 0x002C      STR.W    R0,[SP, #+44]
   \       0xBC   0x....             ADR.N    R0,?_47
   \       0xBE   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC2   0xE886 0x000E      STM      R6,{R1-R3}
   \       0xC6   0xF8CD 0xE018      STR      LR,[SP, #+24]
   \       0xCA   0x6B20             LDR      R0,[R4, #+48]
   \       0xCC   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xD0   0x9008             STR      R0,[SP, #+32]
   1458              // Data input.
   1459              if (cmac_ctx->length >= 16U) {
   \       0xD2   0x6B20             LDR      R0,[R4, #+48]
   \       0xD4   0x2810             CMP      R0,#+16
   \       0xD6   0xD308             BCC.N    ??sl_se_cmac_multipart_finish_3
   1460                // Collect data from two sources.
   1461                in_data1.length &= ~SE_DATATRANSFER_REALIGN;
   \       0xD8   0x9802             LDR      R0,[SP, #+8]
   1462                SE_addDataInput(se_cmd, &in_data1);
   \       0xDA   0x4669             MOV      R1,SP
   \       0xDC   0xF020 0x5000      BIC      R0,R0,#0x20000000
   \       0xE0   0x9002             STR      R0,[SP, #+8]
   \       0xE2   0x.... 0x....      BL       ??Subroutine29_0
   1463                SE_addDataInput(se_cmd, &in_data2);
   \                     ??CrossCallReturnLabel_172: (+1)
   \       0xE6   0xA909             ADD      R1,SP,#+36
   \       0xE8   0xE000             B.N      ??sl_se_cmac_multipart_finish_4
   1464              } else {
   1465                SE_addDataInput(se_cmd, &in_data);
   \                     ??sl_se_cmac_multipart_finish_3: (+1)
   \       0xEA   0xA906             ADD      R1,SP,#+24
   1466              }
   \                     ??sl_se_cmac_multipart_finish_4: (+1)
   \       0xEC   0x.... 0x....      BL       ??Subroutine29_0
   1467          
   1468              // Data output.
   1469              SE_DataTransfer_t out_tag = SE_DATATRANSFER_DEFAULT(output, 16U);
   \                     ??CrossCallReturnLabel_171: (+1)
   \       0xF0   0x....             ADR.N    R0,?_48
   \       0xF2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xF6   0xAC03             ADD      R4,SP,#+12
   1470              SE_addDataOutput(se_cmd, &out_tag);
   \       0xF8   0x4628             MOV      R0,R5
   \       0xFA   0xE884 0x000E      STM      R4,{R1-R3}
   \       0xFE   0x9703             STR      R7,[SP, #+12]
   \      0x100   0xA903             ADD      R1,SP,#+12
   \      0x102   0x.... 0x....      BL       SE_addDataOutput
   1471          
   1472              status = sli_se_execute_and_wait(cmd_ctx);
   \      0x106   0x.... 0x....      BL       ?Subroutine40
   1473            }
   1474            return status;
   \                     ??CrossCallReturnLabel_252: (+1)
   \      0x10A   0x.... 0x....      B.W      ?Subroutine5
   1475          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xB012             ADD      SP,SP,#+72
   \        0x2   0xE8BD 0x87F0      POP      {R4-R10,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ?_45:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_46:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_47:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_48:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1476          
   1477          /***************************************************************************//**
   1478           *   Prepare a CMAC streaming command context object to be used in subsequent
   1479           *   CMAC streaming function calls.
   1480           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1481          sl_status_t sl_se_cmac_multipart_starts(sl_se_cmac_multipart_context_t *cmac_ctx,
   1482                                                  sl_se_command_context_t *cmd_ctx,
   1483                                                  const sl_se_key_descriptor_t *key)
   1484          {
   \                     sl_se_cmac_multipart_starts: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1485            if (cmac_ctx == NULL || cmd_ctx == NULL || key == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD00B             BEQ.N    ??sl_se_cmac_multipart_starts_0
   \        0xA   0xB152             CBZ.N    R2,??sl_se_cmac_multipart_starts_0
   1486              return SL_STATUS_INVALID_PARAMETER;
   1487            }
   1488          
   1489            switch (key->type) {
   \        0xC   0x6812             LDR      R2,[R2, #+0]
   \        0xE   0x2A10             CMP      R2,#+16
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2A18             CMPNE    R2,#+24
   \       0x14   0x2A20             CMPNE    R2,#+32
   \       0x16   0xD104             BNE.N    ??sl_se_cmac_multipart_starts_0
   1490              case SL_SE_KEY_TYPE_AES_128:
   1491              case SL_SE_KEY_TYPE_AES_192:
   1492              case SL_SE_KEY_TYPE_AES_256:
   1493                break;
   1494          
   1495              default:
   1496                return SL_STATUS_INVALID_PARAMETER;
   1497            }
   1498          
   1499            memset(cmac_ctx, 0, sizeof(sl_se_cmac_multipart_context_t));
   \       0x18   0x2134             MOVS     R1,#+52
   \       0x1A   0x.... 0x....      BL       __aeabi_memclr4
   1500            return SL_STATUS_OK;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD02             POP      {R1,PC}
   \                     ??sl_se_cmac_multipart_starts_0: (+1)
   \       0x22   0x2021             MOVS     R0,#+33
   \       0x24   0xBD02             POP      {R1,PC}
   1501          }
   1502          
   1503          /***************************************************************************//**
   1504           *   This function feeds an input buffer into an ongoing CMAC computation.
   1505           *   It is called between sl_se_cmac_starts() and sl_se_cmac_finish().
   1506           *   Can be called repeatedly.
   1507           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1508          sl_status_t sl_se_cmac_multipart_update(sl_se_cmac_multipart_context_t *cmac_ctx,
   1509                                                  sl_se_command_context_t *cmd_ctx,
   1510                                                  const sl_se_key_descriptor_t *key,
   1511                                                  const uint8_t *input,
   1512                                                  size_t input_len)
   1513          {
   \                     sl_se_cmac_multipart_update: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4605             MOV      R5,R0
   1514            sl_status_t status = SL_STATUS_OK;
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0xB098             SUB      SP,SP,#+96
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x461F             MOV      R7,R3
   1515          
   1516            if (cmac_ctx == NULL || cmd_ctx == NULL || key == NULL || input == NULL) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0xD004             BEQ.N    ??sl_se_cmac_multipart_update_0
   \       0x16   0x9200             STR      R2,[SP, #+0]
   \       0x18   0x0010             MOVS     R0,R2
   \       0x1A   0xBF18             IT       NE
   \       0x1C   0x2F00             CMPNE    R7,#+0
   \       0x1E   0xD103             BNE.N    ??sl_se_cmac_multipart_update_1
   1517              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_cmac_multipart_update_0: (+1)
   \       0x20   0x2021             MOVS     R0,#+33
   \                     ??sl_se_cmac_multipart_update_2: (+1)
   \       0x22   0xB019             ADD      SP,SP,#+100
   \       0x24   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1518            }
   1519          
   1520            size_t pending = cmac_ctx->length & 0xFU;
   \                     ??sl_se_cmac_multipart_update_1: (+1)
   \       0x28   0x6B29             LDR      R1,[R5, #+48]
   \       0x2A   0xF8DD 0xB088      LDR      R11,[SP, #+136]
   \       0x2E   0xF001 0x080F      AND      R8,R1,#0xF
   1521          
   1522            if ((cmac_ctx->length / 16U) != ((cmac_ctx->length + input_len) / 16U)) {
   \       0x32   0x0908             LSRS     R0,R1,#+4
   \       0x34   0x4459             ADD      R1,R11,R1
   \       0x36   0xEBB0 0x1F11      CMP      R0,R1, LSR #+4
   \       0x3A   0xF000 0x8098      BEQ.W    ??sl_se_cmac_multipart_update_3
   1523              // Process one or more 16 byte blocks.
   1524              size_t bytes_to_process = (pending + input_len) & 0xFFFFFFF0U;
   \       0x3E   0xEB0B 0x0908      ADD      R9,R11,R8
   1525          
   1526              SE_Command_t *se_cmd = &cmd_ctx->command;
   1527              sli_se_command_init(cmd_ctx,
   1528                                  SLI_SE_COMMAND_AES_ENCRYPT
   1529                                  | SLI_SE_COMMAND_OPTION_MODE_CBC
   1530                                  | SLI_SE_COMMAND_OPTION_CONTEXT_ADD);
   \       0x42   0x.... 0x....      LDR.W    R2,??DataTable123
   \       0x46   0xEA4F 0x1019      LSR      R0,R9,#+4
   \       0x4A   0x6032             STR      R2,[R6, #+0]
   \       0x4C   0xEA4F 0x1A00      LSL      R10,R0,#+4
   \       0x50   0x6074             STR      R4,[R6, #+4]
   \       0x52   0x60B4             STR      R4,[R6, #+8]
   \       0x54   0x61F4             STR      R4,[R6, #+28]
   1531          
   1532              // Add key parameters to command.
   1533              sli_add_key_parameters(cmd_ctx, key, status);
   \       0x56   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x5A   0x0004             MOVS     R4,R0
   \       0x5C   0xD113             BNE.N    ??sl_se_cmac_multipart_update_4
   \       0x5E   0x.... 0x....      BL       ?Subroutine25
   1534              // Message size (number of bytes)
   1535              SE_addParameter(se_cmd, bytes_to_process);
   \                     ??CrossCallReturnLabel_147: (+1)
   \       0x62   0x4651             MOV      R1,R10
   \       0x64   0x.... 0x....      BL       ??Subroutine25_0
   1536          
   1537              // Add key metadata block to command.
   1538              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_141: (+1)
   \       0x68   0x9800             LDR      R0,[SP, #+0]
   \       0x6A   0xA915             ADD      R1,SP,#+84
   \       0x6C   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x70   0x0004             MOVS     R4,R0
   \       0x72   0xD108             BNE.N    ??sl_se_cmac_multipart_update_4
   \       0x74   0xA915             ADD      R1,SP,#+84
   \       0x76   0x.... 0x....      BL       ??Subroutine30_0
   1539              // Add key input block to command.
   1540              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_196: (+1)
   \       0x7A   0x9800             LDR      R0,[SP, #+0]
   \       0x7C   0xA912             ADD      R1,SP,#+72
   \       0x7E   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x82   0x0004             MOVS     R4,R0
   \       0x84   0xD001             BEQ.N    ??sl_se_cmac_multipart_update_5
   \                     ??sl_se_cmac_multipart_update_4: (+1)
   \       0x86   0x4620             MOV      R0,R4
   \       0x88   0xE7CB             B.N      ??sl_se_cmac_multipart_update_2
   \                     ??sl_se_cmac_multipart_update_5: (+1)
   \       0x8A   0xA912             ADD      R1,SP,#+72
   \       0x8C   0x.... 0x....      BL       ??Subroutine30_0
   1541          
   1542              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(cmac_ctx->state, 16U);
   \                     ??CrossCallReturnLabel_195: (+1)
   \       0x90   0x....             ADR.N    R0,?_49
   \       0x92   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \       0x96   0xAB0F             ADD      R3,SP,#+60
   1543              SE_addDataInput(se_cmd, &iv_in);
   \       0x98   0x4630             MOV      R0,R6
   \       0x9A   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \       0x9E   0x950F             STR      R5,[SP, #+60]
   \       0xA0   0xA90F             ADD      R1,SP,#+60
   \       0xA2   0x.... 0x....      BL       SE_addDataInput
   1544          
   1545              // Data input, collect data from two sources.
   1546              SE_DataTransfer_t in1 = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_in, pending);
   \       0xA6   0xBF00             Nop
   \       0xA8   0x....             ADR.N    R0,?_50
   \       0xAA   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \       0xAE   0xAB03             ADD      R3,SP,#+12
   \       0xB0   0xF105 0x0E10      ADD      LR,R5,#+16
   \       0xB4   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \       0xB8   0xF8CD 0xE00C      STR      LR,[SP, #+12]
   \       0xBC   0xF048 0x5300      ORR      R3,R8,#0x20000000
   \       0xC0   0x9305             STR      R3,[SP, #+20]
   1547              SE_DataTransfer_t in2 = SE_DATATRANSFER_DEFAULT(input, bytes_to_process - pending);
   \       0xC2   0xBF00             Nop
   \       0xC4   0x....             ADR.N    R1,?_51
   \       0xC6   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \       0xCA   0xAC0C             ADD      R4,SP,#+48
   \       0xCC   0xEBAA 0x0008      SUB      R0,R10,R8
   \       0xD0   0xE884 0x400C      STM      R4,{R2,R3,LR}
   \       0xD4   0x970C             STR      R7,[SP, #+48]
   \       0xD6   0xF040 0x5800      ORR      R8,R0,#0x20000000
   \       0xDA   0xF8CD 0x8038      STR      R8,[SP, #+56]
   1548              in1.length &= ~SE_DATATRANSFER_REALIGN;
   \       0xDE   0x9905             LDR      R1,[SP, #+20]
   1549              SE_addDataInput(se_cmd, &in1);
   \       0xE0   0x4630             MOV      R0,R6
   \       0xE2   0xEBA9 0x090A      SUB      R9,R9,R10
   \       0xE6   0xF021 0x5100      BIC      R1,R1,#0x20000000
   \       0xEA   0x9105             STR      R1,[SP, #+20]
   \       0xEC   0xA903             ADD      R1,SP,#+12
   \       0xEE   0x.... 0x....      BL       SE_addDataInput
   1550              SE_addDataInput(se_cmd, &in2);
   \       0xF2   0xA90C             ADD      R1,SP,#+48
   \       0xF4   0x.... 0x....      BL       ??Subroutine30_0
   1551          
   1552              // Data output, discard everything except the last 16 bytes.
   1553              SE_DataTransfer_t out1 = SE_DATATRANSFER_DEFAULT(NULL, bytes_to_process - 16U);
   \                     ??CrossCallReturnLabel_194: (+1)
   \       0xF8   0x....             ADR.N    R0,?_52
   \       0xFA   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \       0xFE   0x466B             MOV      R3,SP
   \      0x100   0xF1AA 0x0010      SUB      R0,R10,#+16
   \      0x104   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \      0x108   0xF040 0x5E00      ORR      LR,R0,#0x20000000
   \      0x10C   0xF8CD 0xE008      STR      LR,[SP, #+8]
   1554              SE_DataTransfer_t out2 = SE_DATATRANSFER_DEFAULT(cmac_ctx->data_out, 16U);
   \      0x110   0x....             ADR.N    R0,?_53
   \      0x112   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \      0x116   0xAB09             ADD      R3,SP,#+36
   \      0x118   0xF105 0x0E20      ADD      LR,R5,#+32
   \      0x11C   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \      0x120   0xF8CD 0xE024      STR      LR,[SP, #+36]
   1555              out1.length |= SE_DATATRANSFER_DISCARD;
   \      0x124   0x9802             LDR      R0,[SP, #+8]
   1556              out1.length &= ~SE_DATATRANSFER_REALIGN;
   1557              SE_addDataOutput(se_cmd, &out1);
   \      0x126   0x4669             MOV      R1,SP
   \      0x128   0x....             ADR.N    R4,?_54
   \      0x12A   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x12E   0x9002             STR      R0,[SP, #+8]
   \      0x130   0x9802             LDR      R0,[SP, #+8]
   \      0x132   0xF020 0x5000      BIC      R0,R0,#0x20000000
   \      0x136   0x9002             STR      R0,[SP, #+8]
   \      0x138   0x.... 0x....      BL       ?Subroutine38
   1558              SE_addDataOutput(se_cmd, &out2);
   \                     ??CrossCallReturnLabel_235: (+1)
   \      0x13C   0xA909             ADD      R1,SP,#+36
   \      0x13E   0x.... 0x....      BL       ?Subroutine38
   1559          
   1560              SE_DataTransfer_t iv_out = SE_DATATRANSFER_DEFAULT(cmac_ctx->state, 16U);
   \                     ??CrossCallReturnLabel_234: (+1)
   \      0x142   0xE894 0x0007      LDM      R4,{R0-R2}
   \      0x146   0xAB06             ADD      R3,SP,#+24
   \      0x148   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x14C   0x9506             STR      R5,[SP, #+24]
   1561              SE_addDataOutput(se_cmd, &iv_out);
   \      0x14E   0xA906             ADD      R1,SP,#+24
   \      0x150   0x.... 0x....      BL       ?Subroutine38
   1562          
   1563              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_233: (+1)
   \      0x154   0x.... 0x....      BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_258: (+1)
   \      0x158   0x4604             MOV      R4,R0
   1564          
   1565              // Store leftover data.
   1566              size_t leftover = pending + input_len - bytes_to_process;
   1567              memcpy(cmac_ctx->data_in, input + input_len - leftover, leftover);
   \      0x15A   0x464A             MOV      R2,R9
   \      0x15C   0xEB07 0x000B      ADD      R0,R7,R11
   \      0x160   0xF1C9 0x0900      RSB      R9,R9,#+0
   \      0x164   0xEB00 0x0109      ADD      R1,R0,R9
   \      0x168   0xF105 0x0010      ADD      R0,R5,#+16
   \      0x16C   0xE004             B.N      ??sl_se_cmac_multipart_update_6
   1568            } else {
   1569              // Not a complete 16 byte block yet, save input data for later.
   1570              memcpy(cmac_ctx->data_in + pending, input, input_len);
   \                     ??sl_se_cmac_multipart_update_3: (+1)
   \      0x16E   0xF105 0x0010      ADD      R0,R5,#+16
   \      0x172   0x465A             MOV      R2,R11
   \      0x174   0x4639             MOV      R1,R7
   \      0x176   0x4440             ADD      R0,R0,R8
   \                     ??sl_se_cmac_multipart_update_6: (+1)
   \      0x178   0x.... 0x....      BL       __aeabi_memcpy
   1571            }
   1572            cmac_ctx->length += input_len;
   \      0x17C   0x6B29             LDR      R1,[R5, #+48]
   \      0x17E   0x448B             ADD      R11,R11,R1
   \      0x180   0xF8C5 0xB030      STR      R11,[R5, #+48]
   \      0x184   0xE77F             B.N      ??sl_se_cmac_multipart_update_4
   1573            return status;
   1574          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_49:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_50:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_51:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_52:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_53:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_54:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1575          
   1576          /***************************************************************************//**
   1577           *   Compute a HMAC on a full message.
   1578           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1579          sl_status_t sl_se_hmac(sl_se_command_context_t *cmd_ctx,
   1580                                 const sl_se_key_descriptor_t *key,
   1581                                 sl_se_hash_type_t hash_type,
   1582                                 const uint8_t *message,
   1583                                 size_t message_len,
   1584                                 uint8_t *output,
   1585                                 size_t output_len)
   1586          {
   \                     sl_se_hmac: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x461D             MOV      R5,R3
   1587            if (cmd_ctx == NULL || key == NULL || message == NULL || output == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x12   0xD022             BEQ.N    ??sl_se_hmac_1
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x9E15             LDRNE    R6,[SP, #+84]
   \       0x1A   0x2E00             CMPNE    R6,#+0
   \       0x1C   0xD01D             BEQ.N    ??sl_se_hmac_1
   1588              return SL_STATUS_INVALID_PARAMETER;
   1589            }
   1590          
   1591            SE_Command_t *se_cmd = &cmd_ctx->command;
   1592            sl_status_t status = SL_STATUS_OK;
   1593            uint32_t command_word;
   1594            size_t hmac_len;
   1595          
   1596            switch (hash_type) {
   \       0x1E   0x1E52             SUBS     R2,R2,#+1
   \       0x20   0x2A04             CMP      R2,#+4
   \       0x22   0xD81A             BHI.N    ??sl_se_hmac_1
   \       0x24   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??sl_se_hmac_0:
   \       0x28   0x03 0x07          DC8      0x3,0x7,0xB,0xF
   \              0x0B 0x0F
   \       0x2C   0x13 0x00          DC8      0x13,0x0
   1597              case SL_SE_HASH_SHA1:
   1598                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA1;
   \                     ??sl_se_hmac_2: (+1)
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable124
   1599                // SHA1 digest size is 20 bytes
   1600                hmac_len = 20;
   \       0x32   0x2714             MOVS     R7,#+20
   1601                break;
   \       0x34   0xE00E             B.N      ??sl_se_hmac_3
   1602          
   1603              case SL_SE_HASH_SHA224:
   1604                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA224;
   \                     ??sl_se_hmac_4: (+1)
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable124_1
   1605                // SHA224 digest size is 28 bytes
   1606                hmac_len = 28;
   \       0x3A   0x271C             MOVS     R7,#+28
   1607                break;
   \       0x3C   0xE00A             B.N      ??sl_se_hmac_3
   1608          
   1609              case SL_SE_HASH_SHA256:
   1610                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA256;
   \                     ??sl_se_hmac_5: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable124_2
   1611                // SHA256 digest size is 32 bytes
   1612                hmac_len = 32;
   \       0x42   0x2720             MOVS     R7,#+32
   1613                break;
   \       0x44   0xE006             B.N      ??sl_se_hmac_3
   1614          
   1615          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
   1616              case SL_SE_HASH_SHA384:
   1617                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA384;
   \                     ??sl_se_hmac_6: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable124_3
   1618                // SHA384 digest size is 48 bytes
   1619                hmac_len = 48;
   \       0x4A   0x2730             MOVS     R7,#+48
   1620                break;
   \       0x4C   0xE002             B.N      ??sl_se_hmac_3
   1621          
   1622              case SL_SE_HASH_SHA512:
   1623                command_word = SLI_SE_COMMAND_HMAC | SLI_SE_COMMAND_OPTION_HASH_SHA512;
   \                     ??sl_se_hmac_7: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable125
   1624                // SHA512 digest size is 64 bytes
   1625                hmac_len = 64;
   \       0x52   0x2740             MOVS     R7,#+64
   1626                break;
   \                     ??sl_se_hmac_3: (+1)
   \       0x54   0x9916             LDR      R1,[SP, #+88]
   1627          
   1628          #endif
   1629              default:
   1630                return SL_STATUS_INVALID_PARAMETER;
   1631            }
   1632          
   1633            if (output_len < hmac_len) {
   \       0x56   0x42B9             CMP      R1,R7
   \       0x58   0xD201             BCS.N    ??sl_se_hmac_8
   1634              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_hmac_1: (+1)
   \       0x5A   0x2021             MOVS     R0,#+33
   \       0x5C   0xE038             B.N      ??CrossCallReturnLabel_115
   1635            }
   1636          
   1637            sli_se_command_init(cmd_ctx, command_word);
   \                     ??sl_se_hmac_8: (+1)
   \       0x5E   0x.... 0x....      BL       ?Subroutine6
   1638          
   1639            // Add key parameter to command.
   1640            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD134             BNE.N    ??CrossCallReturnLabel_115
   \       0x66   0x9900             LDR      R1,[SP, #+0]
   \       0x68   0xF8DD 0x9050      LDR      R9,[SP, #+80]
   \       0x6C   0x.... 0x....      BL       ??Subroutine21_0
   1641          
   1642            // Message size parameter.
   1643            SE_addParameter(se_cmd, message_len);
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x70   0x4649             MOV      R1,R9
   \       0x72   0x.... 0x....      BL       ??Subroutine21_0
   1644          
   1645            // Key metadata.
   1646            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0x76   0xA909             ADD      R1,SP,#+36
   \       0x78   0x4640             MOV      R0,R8
   \       0x7A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x7E   0xBB38             CBNZ.N   R0,??CrossCallReturnLabel_115
   \       0x80   0xA909             ADD      R1,SP,#+36
   \       0x82   0x.... 0x....      BL       ??Subroutine20_1
   1647          
   1648            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0x86   0xA906             ADD      R1,SP,#+24
   \       0x88   0x4640             MOV      R0,R8
   \       0x8A   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x8E   0xB9F8             CBNZ.N   R0,??CrossCallReturnLabel_115
   \       0x90   0xA906             ADD      R1,SP,#+24
   \       0x92   0x.... 0x....      BL       ??Subroutine20_1
   1649          
   1650            // Data input.
   1651            SE_DataTransfer_t in_data = SE_DATATRANSFER_DEFAULT(message, message_len);
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x96   0xBF00             Nop
   \       0x98   0x....             ADR.N    R0,?_55
   \       0x9A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x9E   0xF10D 0x080C      ADD      R8,SP,#+12
   \       0xA2   0xF049 0x5900      ORR      R9,R9,#0x20000000
   \       0xA6   0xE888 0x000E      STM      R8,{R1-R3}
   \       0xAA   0x9503             STR      R5,[SP, #+12]
   \       0xAC   0xF8CD 0x9014      STR      R9,[SP, #+20]
   1652            SE_addDataInput(se_cmd, &in_data);
   \       0xB0   0x.... 0x....      BL       ??Subroutine20_0
   1653          
   1654            // Data output.
   1655            SE_DataTransfer_t out_hmac = SE_DATATRANSFER_DEFAULT(output, hmac_len);
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0xB4   0x....             ADR.N    R0,?_56
   \       0xB6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xBA   0x466D             MOV      R5,SP
   \       0xBC   0xF047 0x5700      ORR      R7,R7,#0x20000000
   \       0xC0   0xE885 0x000E      STM      R5,{R1-R3}
   \       0xC4   0x9600             STR      R6,[SP, #+0]
   \       0xC6   0x9702             STR      R7,[SP, #+8]
   1656            SE_addDataOutput(se_cmd, &out_hmac);
   \       0xC8   0x.... 0x....      BL       ?Subroutine11
   1657          
   1658            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0xCC   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_115: (+1)
   \       0xD0   0xB00D             ADD      SP,SP,#+52
   \       0xD2   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1659          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6020             STR      R0,[R4, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6060             STR      R0,[R4, #+4]
   \        0x6   0x60A0             STR      R0,[R4, #+8]
   \        0x8   0x61E0             STR      R0,[R4, #+28]
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x4640             MOV      R0,R8
   \        0xE   0x.... 0x....      B.W      sli_se_key_to_keyspec

   \                                 In section .text, align 4, keep-with-next
   \                     ?_55:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_56:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1660          
   1661          /***************************************************************************//**
   1662           * GCM buffer encryption or decryption.
   1663           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1664          sl_status_t sl_se_gcm_crypt_and_tag(sl_se_command_context_t *cmd_ctx,
   1665                                              const sl_se_key_descriptor_t *key,
   1666                                              sl_se_cipher_operation_t mode,
   1667                                              size_t length,
   1668                                              const unsigned char *iv,
   1669                                              size_t iv_len,
   1670                                              const unsigned char *add,
   1671                                              size_t add_len,
   1672                                              const unsigned char *input,
   1673                                              unsigned char *output,
   1674                                              size_t tag_len,
   1675                                              unsigned char *tag)
   1676          {
   \                     sl_se_gcm_crypt_and_tag: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09D             SUB      SP,SP,#+116
   \        0x6   0x0005             MOVS     R5,R0
   1677            // Check input parameters.
   1678            if (cmd_ctx == NULL || key == NULL || iv == NULL || tag == NULL
   1679                || ((add_len > 0) && (add == NULL))
   1680                || ((length > 0) && (input == NULL || output == NULL))
   1681                || ((tag_len < 4) || (tag_len > 16))) {
   \        0x8   0xBF1C             ITT      NE
   \        0xA   0x9100             STRNE    R1,[SP, #+0]
   \        0xC   0x2900             CMPNE    R1,#+0
   \        0xE   0xD033             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x10   0x9E26             LDR      R6,[SP, #+152]
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x982D             LDRNE    R0,[SP, #+180]
   \       0x18   0x2800             CMPNE    R0,#+0
   \       0x1A   0xD02D             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x1C   0x9829             LDR      R0,[SP, #+164]
   \       0x1E   0x9F28             LDR      R7,[SP, #+160]
   \       0x20   0xB100             CBZ.N    R0,??sl_se_gcm_crypt_and_tag_1
   \       0x22   0xB34F             CBZ.N    R7,??sl_se_gcm_crypt_and_tag_0
   \                     ??sl_se_gcm_crypt_and_tag_1: (+1)
   \       0x24   0x9301             STR      R3,[SP, #+4]
   \       0x26   0xF8DD 0x80A8      LDR      R8,[SP, #+168]
   \       0x2A   0x9C2B             LDR      R4,[SP, #+172]
   \       0x2C   0xB123             CBZ.N    R3,??sl_se_gcm_crypt_and_tag_2
   \       0x2E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x32   0xBF18             IT       NE
   \       0x34   0x2C00             CMPNE    R4,#+0
   \       0x36   0xD01F             BEQ.N    ??sl_se_gcm_crypt_and_tag_0
   \                     ??sl_se_gcm_crypt_and_tag_2: (+1)
   \       0x38   0xF8DD 0xB0B0      LDR      R11,[SP, #+176]
   \       0x3C   0xF1AB 0x0004      SUB      R0,R11,#+4
   \       0x40   0x280C             CMP      R0,#+12
   \       0x42   0xD819             BHI.N    ??sl_se_gcm_crypt_and_tag_0
   \       0x44   0x9827             LDR      R0,[SP, #+156]
   1682              return SL_STATUS_INVALID_PARAMETER;
   1683            }
   1684          
   1685            SE_Command_t *se_cmd = &cmd_ctx->command;
   1686            uint8_t tagbuf[16];
   1687            sl_status_t status = SL_STATUS_OK;
   1688          
   1689            if (// IV length is required to be 96 bits for SE.
   1690              (iv_len != 96 / 8)
   1691              // AD is limited to 2^64 bits, so 2^61 bytes.
   1692              // However, on 32 bit platforms, that amount of continous data cannot be
   1693              // available.
   1694              // || (((uint64_t)add_len) >> 61 != 0)
   1695              ) {
   \       0x46   0x280C             CMP      R0,#+12
   \       0x48   0xD116             BNE.N    ??sl_se_gcm_crypt_and_tag_0
   1696              return SL_STATUS_INVALID_PARAMETER;
   1697            }
   1698            switch (key->type) {
   \       0x4A   0x6808             LDR      R0,[R1, #+0]
   \       0x4C   0x2810             CMP      R0,#+16
   \       0x4E   0xBF1C             ITT      NE
   \       0x50   0x2818             CMPNE    R0,#+24
   \       0x52   0x2820             CMPNE    R0,#+32
   \       0x54   0xD110             BNE.N    ??sl_se_gcm_crypt_and_tag_0
   1699              case SL_SE_KEY_TYPE_AES_128:
   1700              case SL_SE_KEY_TYPE_AES_192:
   1701              case SL_SE_KEY_TYPE_AES_256:
   1702                break;
   1703          
   1704              default:
   1705                return SL_STATUS_INVALID_PARAMETER;
   1706            }
   1707          
   1708            if (mode == SL_SE_DECRYPT) {
   \       0x56   0x9829             LDR      R0,[SP, #+164]
   \       0x58   0xF043 0x5900      ORR      R9,R3,#0x20000000
   \       0x5C   0x.... 0x....      LDR.W    R10,??DataTable125_1
   \       0x60   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0x64   0x9003             STR      R0,[SP, #+12]
   \       0x66   0x2A01             CMP      R2,#+1
   \       0x68   0xF040 0x807E      BNE.W    ??sl_se_gcm_crypt_and_tag_3
   1709              // Extract plaintext first.
   1710              sli_se_command_init(cmd_ctx,
   1711                                  SLI_SE_COMMAND_AES_GCM_DECRYPT | ((tag_len & 0xFF) << 8));
   \       0x6C   0x.... 0x....      BL       ?Subroutine50
   \                     ??CrossCallReturnLabel_281: (+1)
   \       0x70   0x.... 0x....      BL       ?Subroutine14
   1712          
   1713              sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_288: (+1)
   \       0x74   0xB110             CBZ.N    R0,??sl_se_gcm_crypt_and_tag_4
   \       0x76   0xE0E9             B.N      ??sl_se_gcm_crypt_and_tag_5
   \                     ??sl_se_gcm_crypt_and_tag_0: (+1)
   \       0x78   0x2021             MOVS     R0,#+33
   \                     ??sl_se_gcm_crypt_and_tag_6: (+1)
   \       0x7A   0xE0E7             B.N      ??sl_se_gcm_crypt_and_tag_5
   \                     ??sl_se_gcm_crypt_and_tag_4: (+1)
   \       0x7C   0x9902             LDR      R1,[SP, #+8]
   \       0x7E   0x.... 0x....      BL       ??Subroutine24_0
   1714              SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_127: (+1)
   \       0x82   0x9929             LDR      R1,[SP, #+164]
   \       0x84   0x.... 0x....      BL       ??Subroutine24_0
   1715              SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_126: (+1)
   \       0x88   0x9901             LDR      R1,[SP, #+4]
   \       0x8A   0x.... 0x....      BL       ??Subroutine24_0
   1716          
   1717              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_125: (+1)
   \       0x8E   0x9800             LDR      R0,[SP, #+0]
   \       0x90   0xA916             ADD      R1,SP,#+88
   \       0x92   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD1EF             BNE.N    ??sl_se_gcm_crypt_and_tag_6
   \       0x9A   0xA916             ADD      R1,SP,#+88
   \       0x9C   0x.... 0x....      BL       ??Subroutine29_0
   1718              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_170: (+1)
   \       0xA0   0x9800             LDR      R0,[SP, #+0]
   \       0xA2   0xA913             ADD      R1,SP,#+76
   \       0xA4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD1E6             BNE.N    ??sl_se_gcm_crypt_and_tag_6
   \       0xAC   0xA913             ADD      R1,SP,#+76
   \       0xAE   0x.... 0x....      BL       ??Subroutine29_0
   1719          
   1720              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \                     ??CrossCallReturnLabel_169: (+1)
   \       0xB2   0xBF00             Nop
   \       0xB4   0x....             ADR.N    R1,?_57
   \       0xB6   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \       0xBA   0xA810             ADD      R0,SP,#+64
   1721              SE_addDataInput(se_cmd, &iv_in);
   \       0xBC   0xA910             ADD      R1,SP,#+64
   \       0xBE   0xE880 0x400C      STM      R0,{R2,R3,LR}
   \       0xC2   0x9610             STR      R6,[SP, #+64]
   \       0xC4   0xF8CD 0xA048      STR      R10,[SP, #+72]
   \       0xC8   0x.... 0x....      BL       ??Subroutine29_0
   1722          
   1723              SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \                     ??CrossCallReturnLabel_168: (+1)
   \       0xCC   0x....             ADR.N    R0,?_58
   \       0xCE   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xD2   0xAB0D             ADD      R3,SP,#+52
   1724              SE_addDataInput(se_cmd, &aad_in);
   \       0xD4   0x4628             MOV      R0,R5
   \       0xD6   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xDA   0x970D             STR      R7,[SP, #+52]
   \       0xDC   0x9B03             LDR      R3,[SP, #+12]
   \       0xDE   0xA90D             ADD      R1,SP,#+52
   \       0xE0   0x930F             STR      R3,[SP, #+60]
   \       0xE2   0x.... 0x....      BL       SE_addDataInput
   1725          
   1726              SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0xE6   0xBF00             Nop
   \       0xE8   0x....             ADR.N    R1,?_59
   \       0xEA   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \       0xEE   0xA80A             ADD      R0,SP,#+40
   1727              SE_addDataInput(se_cmd, &data_in);
   \       0xF0   0xA90A             ADD      R1,SP,#+40
   \       0xF2   0xE880 0x400C      STM      R0,{R2,R3,LR}
   \       0xF6   0xF8CD 0x8028      STR      R8,[SP, #+40]
   \       0xFA   0xF8CD 0x9030      STR      R9,[SP, #+48]
   \       0xFE   0x.... 0x....      BL       ??Subroutine29_0
   1728          
   1729              SE_DataTransfer_t tag_in = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \                     ??CrossCallReturnLabel_167: (+1)
   \      0x102   0xBF00             Nop
   \      0x104   0x....             ADR.N    R0,?_60
   \      0x106   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \      0x10A   0xF8DD 0x80B4      LDR      R8,[SP, #+180]
   \      0x10E   0xAB07             ADD      R3,SP,#+28
   \      0x110   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \      0x114   0xF8CD 0x801C      STR      R8,[SP, #+28]
   \      0x118   0xF04B 0x5100      ORR      R1,R11,#0x20000000
   \      0x11C   0x9109             STR      R1,[SP, #+36]
   1730              SE_addDataInput(se_cmd, &tag_in);
   \      0x11E   0xA907             ADD      R1,SP,#+28
   \      0x120   0x.... 0x....      BL       ??Subroutine29_0
   1731          
   1732              SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_166: (+1)
   \      0x124   0x....             ADR.N    R1,?_61
   \      0x126   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x12A   0xF10D 0x0C10      ADD      R12,SP,#+16
   \      0x12E   0xE88C 0x400C      STM      R12,{R2,R3,LR}
   \      0x132   0x9404             STR      R4,[SP, #+16]
   \      0x134   0xF8CD 0x9018      STR      R9,[SP, #+24]
   1733              if (output == NULL) {
   \      0x138   0xB91C             CBNZ.N   R4,??sl_se_gcm_crypt_and_tag_7
   1734                data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x13A   0x9806             LDR      R0,[SP, #+24]
   \      0x13C   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x140   0x9006             STR      R0,[SP, #+24]
   1735              }
   1736              SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_crypt_and_tag_7: (+1)
   \      0x142   0xA904             ADD      R1,SP,#+16
   \      0x144   0x.... 0x....      BL       ??Subroutine39_0
   1737          
   1738              // Execute GCM operation.
   1739              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_244: (+1)
   \      0x148   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_251: (+1)
   \      0x14C   0xEA5F 0x0800      MOVS     R8,R0
   1740              if ((status != SL_STATUS_OK) && (status != SL_STATUS_INVALID_SIGNATURE)) {
   \      0x150   0xBF18             IT       NE
   \      0x152   0xF1B8 0x0F2C      CMPNE    R8,#+44
   \      0x156   0xD005             BEQ.N    ??sl_se_gcm_crypt_and_tag_8
   1741                memset(output, 0, length);
   \      0x158   0x9901             LDR      R1,[SP, #+4]
   \      0x15A   0x4620             MOV      R0,R4
   \      0x15C   0x.... 0x....      BL       __aeabi_memclr
   1742                return status;
   \      0x160   0x4640             MOV      R0,R8
   \      0x162   0xE073             B.N      ??sl_se_gcm_crypt_and_tag_5
   1743              }
   1744          
   1745              // Re-encrypt the extracted plaintext to generate the tag to match.
   1746              input = output;
   \                     ??sl_se_gcm_crypt_and_tag_8: (+1)
   \      0x164   0x46A0             MOV      R8,R4
   1747              output = NULL;
   \      0x166   0x2400             MOVS     R4,#+0
   1748            }
   1749          
   1750            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_AES_GCM_ENCRYPT);
   \                     ??sl_se_gcm_crypt_and_tag_3: (+1)
   \      0x168   0x.... 0x....      LDR.W    R1,??DataTable125_2
   \      0x16C   0x.... 0x....      BL       ?Subroutine14
   1751          
   1752            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_287: (+1)
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD16B             BNE.N    ??sl_se_gcm_crypt_and_tag_5
   \      0x174   0x9902             LDR      R1,[SP, #+8]
   \      0x176   0x.... 0x....      BL       ??Subroutine24_0
   1753            SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_124: (+1)
   \      0x17A   0x9929             LDR      R1,[SP, #+164]
   \      0x17C   0x.... 0x....      BL       ??Subroutine24_0
   1754            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_123: (+1)
   \      0x180   0x9901             LDR      R1,[SP, #+4]
   \      0x182   0x.... 0x....      BL       ??Subroutine24_0
   1755          
   1756            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_122: (+1)
   \      0x186   0x.... 0x....      BL       ?Subroutine28
   \                     ??CrossCallReturnLabel_159: (+1)
   \      0x18A   0x2800             CMP      R0,#+0
   \      0x18C   0xD15E             BNE.N    ??sl_se_gcm_crypt_and_tag_5
   \      0x18E   0xA914             ADD      R1,SP,#+80
   \      0x190   0x.... 0x....      BL       ??Subroutine29_0
   1757            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_165: (+1)
   \      0x194   0x.... 0x....      BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_231: (+1)
   \      0x198   0x2800             CMP      R0,#+0
   \      0x19A   0xD157             BNE.N    ??sl_se_gcm_crypt_and_tag_5
   \      0x19C   0xA911             ADD      R1,SP,#+68
   \      0x19E   0x.... 0x....      BL       ??Subroutine29_0
   1758          
   1759            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \                     ??CrossCallReturnLabel_164: (+1)
   \      0x1A2   0xBF00             Nop
   \      0x1A4   0x....             ADR.N    R1,?_62
   \      0x1A6   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x1AA   0xA80E             ADD      R0,SP,#+56
   1760            SE_addDataInput(se_cmd, &iv_in);
   \      0x1AC   0xA90E             ADD      R1,SP,#+56
   \      0x1AE   0xE880 0x400C      STM      R0,{R2,R3,LR}
   \      0x1B2   0x960E             STR      R6,[SP, #+56]
   \      0x1B4   0xF8CD 0xA040      STR      R10,[SP, #+64]
   \      0x1B8   0x.... 0x....      BL       ??Subroutine29_0
   1761          
   1762            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \                     ??CrossCallReturnLabel_163: (+1)
   \      0x1BC   0x....             ADR.N    R0,?_63
   \      0x1BE   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \      0x1C2   0xAB0B             ADD      R3,SP,#+44
   1763            SE_addDataInput(se_cmd, &aad_in);
   \      0x1C4   0x4628             MOV      R0,R5
   \      0x1C6   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \      0x1CA   0x970B             STR      R7,[SP, #+44]
   \      0x1CC   0x9B03             LDR      R3,[SP, #+12]
   \      0x1CE   0xA90B             ADD      R1,SP,#+44
   \      0x1D0   0x930D             STR      R3,[SP, #+52]
   \      0x1D2   0x.... 0x....      BL       SE_addDataInput
   1764          
   1765            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \      0x1D6   0xBF00             Nop
   \      0x1D8   0x....             ADR.N    R1,?_64
   \      0x1DA   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \      0x1DE   0xA808             ADD      R0,SP,#+32
   1766            SE_addDataInput(se_cmd, &data_in);
   \      0x1E0   0xA908             ADD      R1,SP,#+32
   \      0x1E2   0xE880 0x004C      STM      R0,{R2,R3,R6}
   \      0x1E6   0xF8CD 0x8020      STR      R8,[SP, #+32]
   \      0x1EA   0xF8CD 0x9028      STR      R9,[SP, #+40]
   \      0x1EE   0x.... 0x....      BL       ??Subroutine29_0
   1767          
   1768            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_162: (+1)
   \      0x1F2   0xBF00             Nop
   \      0x1F4   0x....             ADR.N    R1,?_65
   \      0x1F6   0xE891 0x008C      LDM      R1,{R2,R3,R7}
   \      0x1FA   0xAE02             ADD      R6,SP,#+8
   \      0x1FC   0xE886 0x008C      STM      R6,{R2,R3,R7}
   \      0x200   0x9402             STR      R4,[SP, #+8]
   \      0x202   0xF8CD 0x9010      STR      R9,[SP, #+16]
   1769            if (output == NULL) {
   \      0x206   0xB91C             CBNZ.N   R4,??sl_se_gcm_crypt_and_tag_9
   1770              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x208   0x9804             LDR      R0,[SP, #+16]
   \      0x20A   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x20E   0x9004             STR      R0,[SP, #+16]
   1771            }
   1772            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_crypt_and_tag_9: (+1)
   \      0x210   0xA902             ADD      R1,SP,#+8
   \      0x212   0x.... 0x....      BL       ??Subroutine39_0
   1773          
   1774            SE_DataTransfer_t mac_out = SE_DATATRANSFER_DEFAULT(tagbuf, sizeof(tagbuf));
   \                     ??CrossCallReturnLabel_243: (+1)
   \      0x216   0xBF00             Nop
   \      0x218   0x....             ADR.N    R0,?_66
   \      0x21A   0xE890 0x0046      LDM      R0,{R1,R2,R6}
   \      0x21E   0xAB05             ADD      R3,SP,#+20
   \      0x220   0xAF19             ADD      R7,SP,#+100
   \      0x222   0xE883 0x0046      STM      R3,{R1,R2,R6}
   \      0x226   0x9705             STR      R7,[SP, #+20]
   1775            SE_addDataOutput(se_cmd, &mac_out);
   \      0x228   0xA905             ADD      R1,SP,#+20
   \      0x22A   0x.... 0x....      BL       ??Subroutine39_0
   1776          
   1777            // Execute GCM operation.
   1778            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_242: (+1)
   \      0x22E   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_250: (+1)
   \      0x232   0x0005             MOVS     R5,R0
   1779            if (status == SL_STATUS_OK) {
   \      0x234   0xD105             BNE.N    ??sl_se_gcm_crypt_and_tag_10
   1780              // For encryption, copy requested tag size to output tag buffer.
   1781              memcpy(tag, tagbuf, tag_len);
   \      0x236   0x982D             LDR      R0,[SP, #+180]
   \      0x238   0x465A             MOV      R2,R11
   \      0x23A   0xA919             ADD      R1,SP,#+100
   \      0x23C   0x.... 0x....      BL       __aeabi_memcpy
   1782            } else {
   \      0x240   0xE003             B.N      ??sl_se_gcm_crypt_and_tag_11
   1783              memset(output, 0, length);
   \                     ??sl_se_gcm_crypt_and_tag_10: (+1)
   \      0x242   0x9901             LDR      R1,[SP, #+4]
   \      0x244   0x4620             MOV      R0,R4
   \      0x246   0x.... 0x....      BL       __aeabi_memclr
   1784            }
   1785          
   1786            return status;
   \                     ??sl_se_gcm_crypt_and_tag_11: (+1)
   \      0x24A   0x4628             MOV      R0,R5
   \                     ??sl_se_gcm_crypt_and_tag_5: (+1)
   \      0x24C   0x.... 0x....      B.W      ?Subroutine4
   1787          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine50: (+1)
   \        0x0   0xEA4F 0x210B      LSL      R1,R11,#+8
   \        0x4   0xF401 0x417F      AND      R1,R1,#0xFF00
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable127
   \        0xC   0x4301             ORRS     R1,R0,R1
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x6029             STR      R1,[R5, #+0]
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x606A             STR      R2,[R5, #+4]
   \        0x6   0x60AA             STR      R2,[R5, #+8]
   \        0x8   0x61EA             STR      R2,[R5, #+28]
   \        0xA                      REQUIRE ??Subroutine51_0
   \        0xA                      ;; // Fall through to label ??Subroutine51_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xB01D             ADD      SP,SP,#+116
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ?_57:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_58:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_59:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_60:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_61:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_62:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_63:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_64:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_65:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_66:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   1788          
   1789          /***************************************************************************//**
   1790           * GCM buffer decryption and authentication.
   1791           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1792          sl_status_t sl_se_gcm_auth_decrypt(sl_se_command_context_t *cmd_ctx,
   1793                                             const sl_se_key_descriptor_t *key,
   1794                                             size_t length,
   1795                                             const unsigned char *iv,
   1796                                             size_t iv_len,
   1797                                             const unsigned char *add,
   1798                                             size_t add_len,
   1799                                             const unsigned char *input,
   1800                                             unsigned char *output,
   1801                                             size_t tag_len,
   1802                                             const unsigned char *tag)
   1803          {
   \                     sl_se_gcm_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB097             SUB      SP,SP,#+92
   \        0x6   0x0006             MOVS     R6,R0
   1804            // Check input parameters.
   1805            if (cmd_ctx == NULL || key == NULL || iv == NULL || tag == NULL
   1806                || ((add_len > 0) && (add == NULL))
   1807                || ((length > 0) && (input == NULL || output == NULL))
   1808                || ((tag_len < 4) || (tag_len > 16))) {
   \        0x8   0xD01C             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \        0xA   0x9100             STR      R1,[SP, #+0]
   \        0xC   0x0008             MOVS     R0,R1
   \        0xE   0xD019             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x10   0x9303             STR      R3,[SP, #+12]
   \       0x12   0x0018             MOVS     R0,R3
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x9F26             LDRNE    R7,[SP, #+152]
   \       0x18   0x2F00             CMPNE    R7,#+0
   \       0x1A   0xD013             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \       0x1C   0xF8DD 0x8088      LDR      R8,[SP, #+136]
   \       0x20   0xF8DD 0x9084      LDR      R9,[SP, #+132]
   \       0x24   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x28   0xD002             BEQ.N    ??sl_se_gcm_auth_decrypt_1
   \       0x2A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x2E   0xD009             BEQ.N    ??sl_se_gcm_auth_decrypt_0
   \                     ??sl_se_gcm_auth_decrypt_1: (+1)
   \       0x30   0x9201             STR      R2,[SP, #+4]
   \       0x32   0xF8DD 0xA08C      LDR      R10,[SP, #+140]
   \       0x36   0x9D24             LDR      R5,[SP, #+144]
   \       0x38   0x0010             MOVS     R0,R2
   \       0x3A   0xD005             BEQ.N    ??sl_se_gcm_auth_decrypt_2
   \       0x3C   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x40   0xBF18             IT       NE
   \       0x42   0x2D00             CMPNE    R5,#+0
   \                     ??sl_se_gcm_auth_decrypt_0: (+1)
   \       0x44   0xF000 0x808B      BEQ.W    ??sl_se_gcm_auth_decrypt_3
   \                     ??sl_se_gcm_auth_decrypt_2: (+1)
   \       0x48   0xF8DD 0xB094      LDR      R11,[SP, #+148]
   \       0x4C   0xF1AB 0x0004      SUB      R0,R11,#+4
   \       0x50   0x280C             CMP      R0,#+12
   \       0x52   0xD807             BHI.N    ??sl_se_gcm_auth_decrypt_4
   \       0x54   0x9820             LDR      R0,[SP, #+128]
   1809              return SL_STATUS_INVALID_PARAMETER;
   1810            }
   1811          
   1812            SE_Command_t *se_cmd = &cmd_ctx->command;
   1813            sl_status_t status = SL_STATUS_OK;
   1814          
   1815            if (// IV length is required to be 96 bits for SE.
   1816              (iv_len != 96 / 8)
   1817              // AD is limited to 2^64 bits, so 2^61 bytes.
   1818              // However, on 32 bit platforms, that amount of continous data cannot be
   1819              // available.
   1820              // || (((uint64_t)add_len) >> 61 != 0)
   1821              ) {
   \       0x56   0x280C             CMP      R0,#+12
   \       0x58   0xD104             BNE.N    ??sl_se_gcm_auth_decrypt_4
   1822              return SL_STATUS_INVALID_PARAMETER;
   1823            }
   1824            switch (key->type) {
   \       0x5A   0x6808             LDR      R0,[R1, #+0]
   \       0x5C   0x2810             CMP      R0,#+16
   \       0x5E   0xBF1C             ITT      NE
   \       0x60   0x2818             CMPNE    R0,#+24
   \       0x62   0x2820             CMPNE    R0,#+32
   \                     ??sl_se_gcm_auth_decrypt_4: (+1)
   \       0x64   0xF040 0x807B      BNE.W    ??sl_se_gcm_auth_decrypt_3
   1825              case SL_SE_KEY_TYPE_AES_128: // Fallthrough
   1826              case SL_SE_KEY_TYPE_AES_192: // Fallthrough
   1827              case SL_SE_KEY_TYPE_AES_256:
   1828                break;
   1829          
   1830              default:
   1831                return SL_STATUS_INVALID_PARAMETER;
   1832            }
   1833          
   1834            sli_se_command_init(cmd_ctx,
   1835                                SLI_SE_COMMAND_AES_GCM_DECRYPT | ((tag_len & 0xFF) << 8));
   \       0x68   0x.... 0x....      BL       ?Subroutine50
   \                     ??CrossCallReturnLabel_282: (+1)
   \       0x6C   0x6031             STR      R1,[R6, #+0]
   \       0x6E   0x2200             MOVS     R2,#+0
   \       0x70   0x6072             STR      R2,[R6, #+4]
   \       0x72   0x60B2             STR      R2,[R6, #+8]
   \       0x74   0x61F2             STR      R2,[R6, #+28]
   1836          
   1837            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x76   0x.... 0x....      BL       ??Subroutine51_0
   \                     ??CrossCallReturnLabel_286: (+1)
   \       0x7A   0x0004             MOVS     R4,R0
   \       0x7C   0xD16C             BNE.N    ??sl_se_gcm_auth_decrypt_5
   \       0x7E   0x9902             LDR      R1,[SP, #+8]
   \       0x80   0x.... 0x....      BL       ??Subroutine25_0
   1838            SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_140: (+1)
   \       0x84   0x4641             MOV      R1,R8
   \       0x86   0x.... 0x....      BL       ??Subroutine25_0
   1839            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_139: (+1)
   \       0x8A   0x.... 0x....      BL       ?Subroutine25
   1840          
   1841            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_146: (+1)
   \       0x8E   0x.... 0x....      BL       ?Subroutine28
   \                     ??CrossCallReturnLabel_158: (+1)
   \       0x92   0x0004             MOVS     R4,R0
   \       0x94   0xD160             BNE.N    ??sl_se_gcm_auth_decrypt_5
   \       0x96   0xA914             ADD      R1,SP,#+80
   \       0x98   0x.... 0x....      BL       ??Subroutine30_0
   1842            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_193: (+1)
   \       0x9C   0x.... 0x....      BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_230: (+1)
   \       0xA0   0x0004             MOVS     R4,R0
   \       0xA2   0xD159             BNE.N    ??sl_se_gcm_auth_decrypt_5
   \       0xA4   0x....             ADR.N    R4,?_67
   \       0xA6   0x.... 0x....      BL       ?Subroutine30
   1843          
   1844            SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \                     ??CrossCallReturnLabel_207: (+1)
   \       0xAA   0xE894 0x0007      LDM      R4,{R0-R2}
   \       0xAE   0xF8DD 0xE00C      LDR      LR,[SP, #+12]
   \       0xB2   0xAB0E             ADD      R3,SP,#+56
   \       0xB4   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xB8   0xF8CD 0xE038      STR      LR,[SP, #+56]
   \       0xBC   0x.... 0x....      LDR.W    R1,??DataTable125_1
   \       0xC0   0x9110             STR      R1,[SP, #+64]
   1845            SE_addDataInput(se_cmd, &iv_in);
   \       0xC2   0xA90E             ADD      R1,SP,#+56
   \       0xC4   0x.... 0x....      BL       ??Subroutine30_0
   1846          
   1847            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \                     ??CrossCallReturnLabel_192: (+1)
   \       0xC8   0x....             ADR.N    R0,?_68
   \       0xCA   0xE890 0x0016      LDM      R0,{R1,R2,R4}
   \       0xCE   0xAB0B             ADD      R3,SP,#+44
   \       0xD0   0xF048 0x5800      ORR      R8,R8,#0x20000000
   \       0xD4   0xE883 0x0016      STM      R3,{R1,R2,R4}
   \       0xD8   0xF8CD 0x902C      STR      R9,[SP, #+44]
   \       0xDC   0xF8CD 0x8034      STR      R8,[SP, #+52]
   1848            SE_addDataInput(se_cmd, &aad_in);
   \       0xE0   0xA90B             ADD      R1,SP,#+44
   \       0xE2   0x.... 0x....      BL       ??Subroutine30_0
   1849          
   1850            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \                     ??CrossCallReturnLabel_191: (+1)
   \       0xE6   0xBF00             Nop
   \       0xE8   0x....             ADR.N    R0,?_69
   \       0xEA   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xEE   0xAC08             ADD      R4,SP,#+32
   1851            SE_addDataInput(se_cmd, &data_in);
   \       0xF0   0x4630             MOV      R0,R6
   \       0xF2   0xE884 0x000E      STM      R4,{R1-R3}
   \       0xF6   0xF8CD 0xA020      STR      R10,[SP, #+32]
   \       0xFA   0x9C01             LDR      R4,[SP, #+4]
   \       0xFC   0xA908             ADD      R1,SP,#+32
   \       0xFE   0xF04B 0x5B00      ORR      R11,R11,#0x20000000
   \      0x102   0xF044 0x5400      ORR      R4,R4,#0x20000000
   \      0x106   0x940A             STR      R4,[SP, #+40]
   \      0x108   0x.... 0x....      BL       SE_addDataInput
   1852          
   1853            SE_DataTransfer_t tag_in = SE_DATATRANSFER_DEFAULT(tag, tag_len);
   \      0x10C   0x.... 0x....      ADR.W    LR,?_70
   \      0x110   0xE89E 0x0007      LDM      LR,{R0-R2}
   \      0x114   0xAB05             ADD      R3,SP,#+20
   \      0x116   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x11A   0x9705             STR      R7,[SP, #+20]
   \      0x11C   0xF8CD 0xB01C      STR      R11,[SP, #+28]
   1854            SE_addDataInput(se_cmd, &tag_in);
   \      0x120   0xA905             ADD      R1,SP,#+20
   \      0x122   0x.... 0x....      BL       ??Subroutine30_0
   1855          
   1856            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_190: (+1)
   \      0x126   0xBF00             Nop
   \      0x128   0x....             ADR.N    R1,?_71
   \      0x12A   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x12E   0xAF02             ADD      R7,SP,#+8
   \      0x130   0xE887 0x400C      STM      R7,{R2,R3,LR}
   \      0x134   0x9502             STR      R5,[SP, #+8]
   \      0x136   0x9404             STR      R4,[SP, #+16]
   1857            if (output == NULL) {
   \      0x138   0xB91D             CBNZ.N   R5,??sl_se_gcm_auth_decrypt_6
   1858              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x13A   0x9804             LDR      R0,[SP, #+16]
   \      0x13C   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x140   0x9004             STR      R0,[SP, #+16]
   1859            }
   1860            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_gcm_auth_decrypt_6: (+1)
   \      0x142   0xA902             ADD      R1,SP,#+8
   \      0x144   0x.... 0x....      BL       ?Subroutine38
   1861          
   1862            // Execute GCM operation.
   1863            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_232: (+1)
   \      0x148   0x.... 0x....      BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_257: (+1)
   \      0x14C   0x0004             MOVS     R4,R0
   1864          
   1865            if (status != SL_STATUS_OK) {
   \      0x14E   0xD003             BEQ.N    ??sl_se_gcm_auth_decrypt_5
   1866              memset(output, 0, length);
   \      0x150   0x9901             LDR      R1,[SP, #+4]
   \      0x152   0x4628             MOV      R0,R5
   \      0x154   0x.... 0x....      BL       __aeabi_memclr
   1867            }
   1868          
   1869            return status;
   \                     ??sl_se_gcm_auth_decrypt_5: (+1)
   \      0x158   0x4620             MOV      R0,R4
   \                     ??sl_se_gcm_auth_decrypt_7: (+1)
   \      0x15A   0x.... 0x....      B.W      ?Subroutine3
   \                     ??sl_se_gcm_auth_decrypt_3: (+1)
   \      0x15E   0x2021             MOVS     R0,#+33
   \      0x160   0xE7FB             B.N      ??sl_se_gcm_auth_decrypt_7
   1870          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_67:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_68:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_69:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_70:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_71:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   1871          
   1872          #if defined(SLI_SE_MAJOR_VERSION_TWO)
   1873          /***************************************************************************//**
   1874           * GCM  multipart encryption/decryption, initial stage.
   1875           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1876          sl_status_t sl_se_gcm_multipart_starts(sl_se_gcm_multipart_context_t *gcm_ctx,
   1877                                                 sl_se_command_context_t *cmd_ctx,
   1878                                                 const sl_se_key_descriptor_t *key,
   1879                                                 sl_se_cipher_operation_t mode,
   1880                                                 const uint8_t *iv,
   1881                                                 size_t iv_len,
   1882                                                 const uint8_t *add,
   1883                                                 size_t add_len)
   1884          {
   \                     sl_se_gcm_multipart_starts: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x469B             MOV      R11,R3
   1885            sl_status_t status = SL_STATUS_OK;
   1886          
   1887            // Check input parameters.
   1888            if (gcm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL
   1889                || (add_len > 0 && add == NULL)) {
   \        0xA   0xD010             BEQ.N    ??sl_se_gcm_multipart_starts_0
   \        0xC   0x000D             MOVS     R5,R1
   \        0xE   0xBF18             IT       NE
   \       0x10   0xEA5F 0x0A02      MOVSNE   R10,R2
   \       0x14   0xD00B             BEQ.N    ??sl_se_gcm_multipart_starts_0
   \       0x16   0x9E18             LDR      R6,[SP, #+96]
   \       0x18   0xB14E             CBZ.N    R6,??sl_se_gcm_multipart_starts_0
   \       0x1A   0xF8DD 0x906C      LDR      R9,[SP, #+108]
   \       0x1E   0x9F1A             LDR      R7,[SP, #+104]
   \       0x20   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x24   0xD000             BEQ.N    ??sl_se_gcm_multipart_starts_1
   \       0x26   0xB117             CBZ.N    R7,??sl_se_gcm_multipart_starts_0
   \                     ??sl_se_gcm_multipart_starts_1: (+1)
   \       0x28   0x9819             LDR      R0,[SP, #+100]
   1890              return SL_STATUS_INVALID_PARAMETER;
   1891            }
   1892            if ((iv_len != 12)
   1893                // AD are limited to 2^64 bits, so 2^61 bytes.
   1894                // However, on 32 bit platforms, that amount of continous data cannot be
   1895                // available.
   1896                // || (((uint64_t)add_len) >> 61 != 0)
   1897                ) {
   \       0x2A   0x280C             CMP      R0,#+12
   \       0x2C   0xD001             BEQ.N    ??sl_se_gcm_multipart_starts_2
   1898              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_starts_0: (+1)
   \       0x2E   0x2021             MOVS     R0,#+33
   \       0x30   0xE074             B.N      ??sl_se_gcm_multipart_starts_3
   1899            }
   1900          
   1901            memset(gcm_ctx, 0, sizeof(sl_se_gcm_multipart_context_t));
   \                     ??sl_se_gcm_multipart_starts_2: (+1)
   \       0x32   0x2148             MOVS     R1,#+72
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x.... 0x....      BL       __aeabi_memclr4
   1902          
   1903            gcm_ctx->mode = mode;
   \       0x3A   0xF104 0x0841      ADD      R8,R4,#+65
   \       0x3E   0xF888 0xB000      STRB     R11,[R8, #+0]
   1904            gcm_ctx->len = 0;
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0xE9C4 0x2200      STRD     R2,R2,[R4, #+0]
   1905            gcm_ctx->add_len = add_len;
   \       0x48   0xE9C4 0x9202      STRD     R9,R2,[R4, #+8]
   1906          
   1907            SE_Command_t *se_cmd = &cmd_ctx->command;
   1908          
   1909            // The start context requires some data, either additional data or input data.
   1910            // Case add_len > 0: Run start command with additonal data to create ctx_out.
   1911            // Case add_len = 0: Store iv in gcm_ctx and run start function with input data
   1912            // in sl_se_gcm_multipart_update. In the case of zero input data or
   1913            // input data < 16 run sl_se_gcm_auth_decrypt()/sl_se_gcm_crypt_and_tag() in
   1914            // sl_se_gcm_multipart_finish.
   1915            if ( add_len > 0 ) {
   \       0x4C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x50   0xD05A             BEQ.N    ??sl_se_gcm_multipart_starts_4
   1916              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   \       0x52   0x.... 0x....      ADR.W    LR,?_72
   \       0x56   0xE89E 0x0007      LDM      LR,{R0-R2}
   \       0x5A   0xAB0C             ADD      R3,SP,#+48
   \       0x5C   0x.... 0x....      LDR.W    R11,??DataTable125_1
   \       0x60   0xE883 0x0007      STM      R3,{R0-R2}
   \       0x64   0x960C             STR      R6,[SP, #+48]
   \       0x66   0xF8CD 0xB038      STR      R11,[SP, #+56]
   1917              SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \       0x6A   0x.... 0x....      ADR.W    R1,?_73
   \       0x6E   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \       0x72   0xAE09             ADD      R6,SP,#+36
   1918              SE_DataTransfer_t ctx_out =
   1919                SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   \       0x74   0x.... 0x....      ADR.W    R1,?_74
   \       0x78   0xE886 0x400C      STM      R6,{R2,R3,LR}
   \       0x7C   0x9709             STR      R7,[SP, #+36]
   \       0x7E   0xF049 0x5700      ORR      R7,R9,#0x20000000
   \       0x82   0x970B             STR      R7,[SP, #+44]
   \       0x84   0xE891 0x008C      LDM      R1,{R2,R3,R7}
   \       0x88   0xAE06             ADD      R6,SP,#+24
   \       0x8A   0xF104 0x0E10      ADD      LR,R4,#+16
   \       0x8E   0xE886 0x008C      STM      R6,{R2,R3,R7}
   \       0x92   0xF8CD 0xE018      STR      LR,[SP, #+24]
   1920          
   1921              sli_se_command_init(cmd_ctx,
   1922                                  (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   1923                                   : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   1924                                  | SLI_SE_COMMAND_OPTION_CONTEXT_START);
   \       0x96   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x9A   0x2801             CMP      R0,#+1
   \       0x9C   0xBF0C             ITE      EQ
   \       0x9E   0x.... 0x....      LDREQ.W  R0,??DataTable127_1
   \       0xA2   0x.... 0x....      LDRNE.W  R0,??DataTable127_2
   \       0xA6   0x.... 0x....      BL       ?Subroutine7
   1925          
   1926              sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xAA   0x4650             MOV      R0,R10
   \       0xAC   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD133             BNE.N    ??sl_se_gcm_multipart_starts_3
   \       0xB4   0x.... 0x....      BL       ?Subroutine19
   1927              SE_addParameter(se_cmd, add_len);
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0xB8   0x4649             MOV      R1,R9
   \       0xBA   0x.... 0x....      BL       ??Subroutine24_0
   1928              SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_121: (+1)
   \       0xBE   0x.... 0x....      BL       ?Subroutine24
   1929          
   1930              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_134: (+1)
   \       0xC2   0xA903             ADD      R1,SP,#+12
   \       0xC4   0x4650             MOV      R0,R10
   \       0xC6   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xCA   0xBB38             CBNZ.N   R0,??sl_se_gcm_multipart_starts_3
   \       0xCC   0xA903             ADD      R1,SP,#+12
   \       0xCE   0x.... 0x....      BL       ??Subroutine29_0
   1931              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_161: (+1)
   \       0xD2   0x4669             MOV      R1,SP
   \       0xD4   0x4650             MOV      R0,R10
   \       0xD6   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xDA   0xB9F8             CBNZ.N   R0,??sl_se_gcm_multipart_starts_3
   \       0xDC   0x.... 0x....      BL       ?Subroutine13
   1932          
   1933              SE_addDataInput(se_cmd, &iv_in);
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0xE0   0x.... 0x....      BL       ?Subroutine29
   1934              SE_addDataInput(se_cmd, &add_in);
   \                     ??CrossCallReturnLabel_183: (+1)
   \       0xE4   0xA909             ADD      R1,SP,#+36
   \       0xE6   0x.... 0x....      BL       ??Subroutine29_0
   1935              SE_addDataOutput(se_cmd, &ctx_out);
   \                     ??CrossCallReturnLabel_160: (+1)
   \       0xEA   0x.... 0x....      BL       ?Subroutine39
   1936          
   1937              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_247: (+1)
   \       0xEE   0x.... 0x....      BL       ?Subroutine40
   \                     ??CrossCallReturnLabel_249: (+1)
   \       0xF2   0x0005             MOVS     R5,R0
   1938              if (status != SL_STATUS_OK) {
   \       0xF4   0xD006             BEQ.N    ??sl_se_gcm_multipart_starts_5
   1939                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   \       0xF6   0x2120             MOVS     R1,#+32
   \       0xF8   0xF104 0x0010      ADD      R0,R4,#+16
   \       0xFC   0x.... 0x....      BL       __aeabi_memclr4
   1940                return status;
   \      0x100   0x4628             MOV      R0,R5
   \      0x102   0xE00B             B.N      ??sl_se_gcm_multipart_starts_3
   1941              }
   1942              gcm_ctx->first_operation = false;
   \                     ??sl_se_gcm_multipart_starts_5: (+1)
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0xE006             B.N      ??sl_se_gcm_multipart_starts_6
   1943            } else {
   1944              memcpy(gcm_ctx->se_ctx, iv, iv_len);
   \                     ??sl_se_gcm_multipart_starts_4: (+1)
   \      0x108   0x220C             MOVS     R2,#+12
   \      0x10A   0x4631             MOV      R1,R6
   \      0x10C   0xF104 0x0010      ADD      R0,R4,#+16
   \      0x110   0x.... 0x....      BL       __aeabi_memcpy
   1945              gcm_ctx->first_operation = true;
   \      0x114   0x2001             MOVS     R0,#+1
   \                     ??sl_se_gcm_multipart_starts_6: (+1)
   \      0x116   0xF888 0x0001      STRB     R0,[R8, #+1]
   1946            }
   1947            return SL_STATUS_OK;
   \      0x11A   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_starts_3: (+1)
   \      0x11C   0xB00F             ADD      SP,SP,#+60
   \      0x11E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1948          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_72:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_73:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_74:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
   1949          
   1950          #else
   1951          /***************************************************************************//**
   1952           * GCM  multipart encryption/decryption, initial stage.
   1953           ******************************************************************************/
   1954          sl_status_t sl_se_gcm_multipart_starts(sl_se_gcm_multipart_context_t *gcm_ctx,
   1955                                                 sl_se_command_context_t *cmd_ctx,
   1956                                                 const sl_se_key_descriptor_t *key,
   1957                                                 sl_se_cipher_operation_t mode,
   1958                                                 const uint8_t *iv,
   1959                                                 size_t iv_len,
   1960                                                 const uint8_t *add,
   1961                                                 size_t add_len)
   1962          {
   1963            sl_status_t status = SL_STATUS_OK;
   1964          
   1965            // Check input parameters.
   1966            if (gcm_ctx == NULL || cmd_ctx == NULL || key == NULL || iv == NULL
   1967                || (add_len > 0 && add == NULL)) {
   1968              return SL_STATUS_INVALID_PARAMETER;
   1969            }
   1970            if ((iv_len != 12)
   1971                // AD are limited to 2^64 bits, so 2^61 bytes.
   1972                // However, on 32 bit platforms, that amount of continous data cannot be
   1973                // available.
   1974                // || (((uint64_t)add_len) >> 61 != 0)
   1975                ) {
   1976              return SL_STATUS_INVALID_PARAMETER;
   1977            }
   1978          
   1979            memset(gcm_ctx, 0, sizeof(sl_se_gcm_multipart_context_t));
   1980          
   1981            gcm_ctx->mode = mode;
   1982            gcm_ctx->len = 0;
   1983            gcm_ctx->add_len = add_len;
   1984          
   1985            // The start context requires some data, either additional data or input data.
   1986            // Case add_len > 0: Run start command with additonal data to create ctx_out.
   1987            // Case add_len = 0: Store iv in gcm_ctx and run start function with input data
   1988            // in sl_se_gcm_multipart_update. In the case of zero input data or
   1989            // input data < 16 run sl_se_gcm_auth_decrypt()/sl_se_gcm_crypt_and_tag() in
   1990            // sl_se_gcm_multipart_finish.
   1991            if ( add_len > 0 ) {
   1992              // Encrypt: Compute tag and store it in context and output tag in finish.
   1993              // Decrypt: Compute tag and store it in context and compare it to the
   1994              // input tag in finish to verify it.
   1995          
   1996              // Explanation:The end-context in finish is currently not supporting 0 input data
   1997              // for this config. For add_len = 0 and input_length = 0 we can run
   1998              // sl_se_gcm_auth_decrypt()/sl_se_gcm_crypt_and_tag() in finish, so this is only
   1999              // an issue for 0 input data and add_len != 0.
   2000              SE_Command_t *se_cmd = &cmd_ctx->command;
   2001              SE_DataTransfer_t iv_in = SE_DATATRANSFER_DEFAULT(iv, iv_len);
   2002              SE_DataTransfer_t add_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   2003              SE_DataTransfer_t tag_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->tagbuf,
   2004                                                                  sizeof(gcm_ctx->tagbuf));
   2005              sli_se_command_init(cmd_ctx,
   2006                                  SLI_SE_COMMAND_AES_GCM_ENCRYPT
   2007                                  | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   2008          
   2009              sli_add_key_parameters(cmd_ctx, key, status);
   2010              SE_addParameter(se_cmd, add_len);
   2011              SE_addParameter(se_cmd, 0);
   2012          
   2013              sli_add_key_metadata(cmd_ctx, key, status);
   2014              sli_add_key_input(cmd_ctx, key, status);
   2015          
   2016              SE_addDataInput(se_cmd, &iv_in);
   2017              SE_addDataInput(se_cmd, &add_in);
   2018              SE_addDataOutput(se_cmd, &tag_out);
   2019          
   2020              status = sli_se_execute_and_wait(cmd_ctx);
   2021              if (status != SL_STATUS_OK) {
   2022                memset(gcm_ctx->tagbuf, 0, sizeof(gcm_ctx->tagbuf));
   2023                return status;
   2024              }
   2025          
   2026              SE_DataTransfer_t ctx_out =
   2027                SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2028          
   2029              // Reuse the values of the command context object from the previous
   2030              // operation, and only update the command word and the output data pointer.
   2031              cmd_ctx->command.command =
   2032                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2033                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2034                | SLI_SE_COMMAND_OPTION_CONTEXT_START;
   2035          
   2036              cmd_ctx->command.data_out = &ctx_out;
   2037          
   2038              status = sli_se_execute_and_wait(cmd_ctx);
   2039              if (status != SL_STATUS_OK) {
   2040                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2041                return status;
   2042              }
   2043              gcm_ctx->first_operation = false;
   2044            } else {
   2045              memcpy(gcm_ctx->se_ctx, iv, iv_len);
   2046              gcm_ctx->first_operation = true;
   2047            }
   2048            return SL_STATUS_OK;
   2049          }
   2050          #endif
   2051          
   2052          #if defined(SLI_SE_MAJOR_VERSION_TWO)
   2053          /***************************************************************************//**
   2054           * GCM multipart encryption/decryption, update stage.
   2055           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2056          sl_status_t sl_se_gcm_multipart_update(sl_se_gcm_multipart_context_t *gcm_ctx,
   2057                                                 sl_se_command_context_t *cmd_ctx,
   2058                                                 const sl_se_key_descriptor_t *key,
   2059                                                 size_t length,
   2060                                                 const uint8_t *input,
   2061                                                 uint8_t *output,
   2062                                                 size_t *output_length)
   2063          {
   \                     sl_se_gcm_multipart_update: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x9D1E             LDR      R5,[SP, #+120]
   \        0x8   0x000C             MOVS     R4,R1
   2064            sl_status_t status = SL_STATUS_OK;
   2065            uint8_t stored_res_length = 0;
   \        0xA   0x9501             STR      R5,[SP, #+4]
   2066          
   2067            // Check input parameters.
   2068            if (cmd_ctx == NULL || key == NULL || gcm_ctx == NULL) {
   \        0xC   0xBF1C             ITT      NE
   \        0xE   0x9200             STRNE    R2,[SP, #+0]
   \       0x10   0x2A00             CMPNE    R2,#+0
   \       0x12   0xD028             BEQ.N    ??sl_se_gcm_multipart_update_0
   \       0x14   0x0006             MOVS     R6,R0
   \       0x16   0xD026             BEQ.N    ??sl_se_gcm_multipart_update_0
   \       0x18   0xEA5F 0x0803      MOVS     R8,R3
   2069              return SL_STATUS_INVALID_PARAMETER;
   2070            }
   2071            if (length == 0) {
   \       0x1C   0xD038             BEQ.N    ??sl_se_gcm_multipart_update_1
   2072              return SL_STATUS_OK;
   2073            }
   2074            if (length > 0 && (input == NULL || output == NULL || output_length == NULL)) {
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xBF1F             ITTTT    NE
   \       0x22   0xF8DD 0xA07C      LDRNE    R10,[SP, #+124]
   \       0x26   0xF1BA 0x0F00      CMPNE    R10,#+0
   \       0x2A   0xF8DD 0xB080      LDRNE    R11,[SP, #+128]
   \       0x2E   0xF1BB 0x0F00      CMPNE    R11,#+0
   \       0x32   0xD018             BEQ.N    ??sl_se_gcm_multipart_update_0
   2075              return SL_STATUS_INVALID_PARAMETER;
   2076            }
   2077          
   2078            *output_length = 0;
   \       0x34   0x2700             MOVS     R7,#+0
   \       0x36   0xF8CB 0x7000      STR      R7,[R11, #+0]
   2079          
   2080            // Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes.
   2081            // Also check for possible overflow.
   2082            if (gcm_ctx->len + length < gcm_ctx->len
   2083                || (uint64_t)gcm_ctx->len + length > 0xFFFFFFFE0ULL) {
   \       0x3A   0xE9D6 0x0100      LDRD     R0,R1,[R6, #+0]
   \       0x3E   0x46B9             MOV      R9,R7
   \       0x40   0xEB10 0x0208      ADDS     R2,R0,R8
   \       0x44   0xEB41 0x0309      ADC      R3,R1,R9
   \       0x48   0x428B             CMP      R3,R1
   \       0x4A   0xD30C             BCC.N    ??sl_se_gcm_multipart_update_0
   \       0x4C   0xD801             BHI.N    ??sl_se_gcm_multipart_update_2
   \       0x4E   0x4282             CMP      R2,R0
   \       0x50   0xD309             BCC.N    ??sl_se_gcm_multipart_update_0
   \                     ??sl_se_gcm_multipart_update_2: (+1)
   \       0x52   0x4619             MOV      R1,R3
   \       0x54   0x4610             MOV      R0,R2
   \       0x56   0x230F             MOVS     R3,#+15
   \       0x58   0xF06F 0x021E      MVN      R2,#+30
   \       0x5C   0x4299             CMP      R1,R3
   \       0x5E   0xD304             BCC.N    ??sl_se_gcm_multipart_update_3
   \       0x60   0xD801             BHI.N    ??sl_se_gcm_multipart_update_0
   \       0x62   0x4290             CMP      R0,R2
   \       0x64   0xD301             BCC.N    ??sl_se_gcm_multipart_update_3
   2084              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_update_0: (+1)
   \       0x66   0x2021             MOVS     R0,#+33
   \       0x68   0xE15E             B.N      ??sl_se_gcm_multipart_update_4
   2085            }
   2086            SE_Command_t *se_cmd = &cmd_ctx->command;
   2087          
   2088            // The update context only support an input length as a multiple of 16. Hence, there
   2089            // there is a few cases that can happen.
   2090          
   2091            // Always:
   2092            //  Case length = 0: Return SL_STATUS_OK
   2093          
   2094            // If there is no data in gcm_ctx->final_data:
   2095            //  Case length < 16: Store data in gcm_ctx->final_data and return SL_STATUS_OK
   2096            //  Case length == 16: Run update as normal
   2097            //  Case length > 16 and length is a multiple of 16: Run update as normal
   2098            //  Case length > 16 and length is not a multiple of 16: Run update as normal on the largest multiple
   2099            //  and save the residue bytes in gcm_ctx->final_data.
   2100          
   2101            // If there is data in gcm_ctx->final_data:
   2102            //  Case final_data_length + length < 16: Store input data in gcm_ctx and return SL_STATUS_OKAY
   2103            //  Case final_data_length + length > 16: Add data to fill up the gcm_ctx->final_data-buffer, run update
   2104            //  on the gcm_ctx->final_data-buffer and finally run update as explained above on the rest of the data.
   2105          
   2106            if (gcm_ctx->final_data_length) {
   \                     ??sl_se_gcm_multipart_update_3: (+1)
   \       0x6A   0xF106 0x0740      ADD      R7,R6,#+64
   \       0x6E   0x7838             LDRB     R0,[R7, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xF000 0x80B3      BEQ.W    ??sl_se_gcm_multipart_update_5
   2107              if ((gcm_ctx->final_data_length + length) < 16) {
   \       0x76   0x1833             ADDS     R3,R6,R0
   \       0x78   0xEB08 0x0100      ADD      R1,R8,R0
   \       0x7C   0x2910             CMP      R1,#+16
   \       0x7E   0xD208             BCS.N    ??sl_se_gcm_multipart_update_6
   2108                memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, length);
   \       0x80   0x4642             MOV      R2,R8
   \       0x82   0x.... 0x....      BL       ?Subroutine44
   2109                gcm_ctx->final_data_length += length;
   \                     ??CrossCallReturnLabel_266: (+1)
   \       0x86   0x7838             LDRB     R0,[R7, #+0]
   \       0x88   0x4440             ADD      R0,R8,R0
   \       0x8A   0x7038             STRB     R0,[R7, #+0]
   2110                *output_length = 0;
   \       0x8C   0xF8CB 0x9000      STR      R9,[R11, #+0]
   2111                return SL_STATUS_OK;
   \                     ??sl_se_gcm_multipart_update_1: (+1)
   \       0x90   0xE149             B.N      ??sl_se_gcm_multipart_update_7
   2112              }
   2113              stored_res_length = 16 - gcm_ctx->final_data_length;
   \                     ??sl_se_gcm_multipart_update_6: (+1)
   \       0x92   0xF1C0 0x0010      RSB      R0,R0,#+16
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0x9001             STR      R0,[SP, #+4]
   2114              memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, stored_res_length);
   \       0x9A   0x4602             MOV      R2,R0
   \       0x9C   0x.... 0x....      BL       ?Subroutine44
   2115          
   2116              //The gcm_ctx->se_ctx buffer contain iv data with length 12 if gcm_ctx->first_operation = true
   2117              SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2118                                                                    gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   \                     ??CrossCallReturnLabel_267: (+1)
   \       0xA0   0x.... 0x....      ADR.W    R0,?_75
   \       0xA4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xA8   0xF10D 0x0E48      ADD      LR,SP,#+72
   \       0xAC   0xF106 0x0910      ADD      R9,R6,#+16
   \       0xB0   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xB4   0xF8CD 0x9048      STR      R9,[SP, #+72]
   \       0xB8   0x78B8             LDRB     R0,[R7, #+2]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xBF14             ITE      NE
   \       0xBE   0x.... 0x....      LDRNE.W  R0,??DataTable125_1
   \       0xC2   0x.... 0x....      LDREQ.W  R0,??DataTable127_3
   \       0xC6   0x9014             STR      R0,[SP, #+80]
   2119          
   2120              SE_DataTransfer_t data_in =
   2121                SE_DATATRANSFER_DEFAULT(gcm_ctx->final_data, 16);
   \       0xC8   0x.... 0x....      ADR.W    R0,?_76
   \       0xCC   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xD0   0xAB0F             ADD      R3,SP,#+60
   \       0xD2   0xF106 0x0930      ADD      R9,R6,#+48
   \       0xD6   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xDA   0xF8CD 0x903C      STR      R9,[SP, #+60]
   2122          
   2123              SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, 16);
   \       0xDE   0x.... 0x....      ADR.W    R12,?_77
   \       0xE2   0xE89C 0x0007      LDM      R12,{R0-R2}
   \       0xE6   0xAB0C             ADD      R3,SP,#+48
   2124              SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2125                                                                  sizeof(gcm_ctx->se_ctx));
   \       0xE8   0xF10D 0x0E24      ADD      LR,SP,#+36
   \       0xEC   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xF0   0xF8CD 0xA030      STR      R10,[SP, #+48]
   \       0xF4   0x.... 0x....      ADR.W    R1,?_78
   \       0xF8   0xE891 0x020C      LDM      R1,{R2,R3,R9}
   \       0xFC   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x100   0xE88E 0x020C      STM      LR,{R2,R3,R9}
   \      0x104   0x9009             STR      R0,[SP, #+36]
   2126          
   2127              sli_se_command_init(cmd_ctx,
   2128                                  (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2129                                   : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2130                                  | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   \      0x106   0x7879             LDRB     R1,[R7, #+1]
   \      0x108   0x2901             CMP      R1,#+1
   \      0x10A   0xBF0C             ITE      EQ
   \      0x10C   0x.... 0x....      LDREQ.W  R1,??DataTable127
   \      0x110   0x.... 0x....      LDRNE.W  R1,??DataTable127_4
   \      0x114   0x78B8             LDRB     R0,[R7, #+2]
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xBF14             ITE      NE
   \      0x11A   0x2001             MOVNE    R0,#+1
   \      0x11C   0x2003             MOVEQ    R0,#+3
   \      0x11E   0x4301             ORRS     R1,R0,R1
   \      0x120   0x.... 0x....      BL       ?Subroutine10
   2131          
   2132              sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_11: (+1)
   \      0x124   0x.... 0x....      BL       ??Subroutine51_0
   \                     ??CrossCallReturnLabel_285: (+1)
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD12C             BNE.N    ??sl_se_gcm_multipart_update_8
   \      0x12C   0x9902             LDR      R1,[SP, #+8]
   \      0x12E   0x.... 0x....      BL       ??Subroutine21_0
   2133              SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_88: (+1)
   \      0x132   0x2100             MOVS     R1,#+0
   \      0x134   0x.... 0x....      BL       ??Subroutine21_0
   2134              SE_addParameter(se_cmd, 16);
   \                     ??CrossCallReturnLabel_87: (+1)
   \      0x138   0x2110             MOVS     R1,#+16
   \      0x13A   0x.... 0x....      BL       ??Subroutine21_0
   2135          
   2136              sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_86: (+1)
   \      0x13E   0x9800             LDR      R0,[SP, #+0]
   \      0x140   0xA906             ADD      R1,SP,#+24
   \      0x142   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xD11D             BNE.N    ??sl_se_gcm_multipart_update_8
   \      0x14A   0xA906             ADD      R1,SP,#+24
   \      0x14C   0x.... 0x....      BL       ??Subroutine20_1
   2137              sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_55: (+1)
   \      0x150   0x9800             LDR      R0,[SP, #+0]
   \      0x152   0xA903             ADD      R1,SP,#+12
   \      0x154   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD114             BNE.N    ??sl_se_gcm_multipart_update_8
   \      0x15C   0x.... 0x....      BL       ??Subroutine20_0
   2138          
   2139              SE_addDataInput(se_cmd, &iv_ctx_in);
   \                     ??CrossCallReturnLabel_77: (+1)
   \      0x160   0xA912             ADD      R1,SP,#+72
   \      0x162   0x.... 0x....      BL       ??Subroutine20_1
   2140              SE_addDataInput(se_cmd, &data_in);
   \                     ??CrossCallReturnLabel_54: (+1)
   \      0x166   0xA90F             ADD      R1,SP,#+60
   \      0x168   0x.... 0x....      BL       ??Subroutine20_1
   2141          
   2142              SE_addDataOutput(se_cmd, &data_out);
   \                     ??CrossCallReturnLabel_53: (+1)
   \      0x16C   0xA90C             ADD      R1,SP,#+48
   \      0x16E   0x.... 0x....      BL       ?Subroutine22
   2143          
   2144              SE_addDataOutput(se_cmd, &ctx_out);
   \                     ??CrossCallReturnLabel_107: (+1)
   \      0x172   0xA909             ADD      R1,SP,#+36
   \      0x174   0x.... 0x....      BL       ?Subroutine22
   2145          
   2146              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_106: (+1)
   \      0x178   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_114: (+1)
   \      0x17C   0x9002             STR      R0,[SP, #+8]
   2147          
   2148              if (status != SL_STATUS_OK) {
   \      0x17E   0xB118             CBZ.N    R0,??sl_se_gcm_multipart_update_9
   2149                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   \      0x180   0x.... 0x....      BL       ?Subroutine49
   2150                return status;
   \                     ??CrossCallReturnLabel_279: (+1)
   \      0x184   0x9802             LDR      R0,[SP, #+8]
   \                     ??sl_se_gcm_multipart_update_8: (+1)
   \      0x186   0xE0CF             B.N      ??sl_se_gcm_multipart_update_4
   2151              }
   2152              gcm_ctx->first_operation = false;
   \                     ??sl_se_gcm_multipart_update_9: (+1)
   \      0x188   0xF04F 0x0C00      MOV      R12,#+0
   \      0x18C   0xF887 0xC002      STRB     R12,[R7, #+2]
   2153              gcm_ctx->len += 16;
   \      0x190   0xE9D6 0x2300      LDRD     R2,R3,[R6, #+0]
   2154              output += 16;
   \      0x194   0xF10A 0x0A10      ADD      R10,R10,#+16
   \      0x198   0xF112 0x0010      ADDS     R0,R2,#+16
   \      0x19C   0xF143 0x0100      ADC      R1,R3,#+0
   \      0x1A0   0xE9C6 0x0100      STRD     R0,R1,[R6, #+0]
   2155          
   2156              if ((length - stored_res_length) < 16) {
   \      0x1A4   0x9A01             LDR      R2,[SP, #+4]
   \      0x1A6   0xEBA8 0x0202      SUB      R2,R8,R2
   \      0x1AA   0x2A10             CMP      R2,#+16
   \      0x1AC   0xD20B             BCS.N    ??sl_se_gcm_multipart_update_10
   2157                memcpy(gcm_ctx->final_data, input + stored_res_length, length - stored_res_length);
   \      0x1AE   0x9801             LDR      R0,[SP, #+4]
   \      0x1B0   0x1829             ADDS     R1,R5,R0
   \      0x1B2   0x.... 0x....      BL       ?Subroutine47
   2158                gcm_ctx->final_data_length = length - stored_res_length;
   \                     ??CrossCallReturnLabel_274: (+1)
   \      0x1B6   0x9801             LDR      R0,[SP, #+4]
   2159                *output_length = 16;
   \      0x1B8   0x2110             MOVS     R1,#+16
   \      0x1BA   0xEBA8 0x0000      SUB      R0,R8,R0
   \      0x1BE   0x7038             STRB     R0,[R7, #+0]
   \      0x1C0   0xF8CB 0x1000      STR      R1,[R11, #+0]
   2160                return SL_STATUS_OK;
   \      0x1C4   0xE0AF             B.N      ??sl_se_gcm_multipart_update_7
   2161              }
   2162          
   2163              length -= stored_res_length;
   2164              gcm_ctx->final_data_length = 0;
   \                     ??sl_se_gcm_multipart_update_10: (+1)
   \      0x1C6   0xF887 0xC000      STRB     R12,[R7, #+0]
   2165              *output_length += 16;
   \      0x1CA   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x1CE   0x4690             MOV      R8,R2
   \      0x1D0   0x3110             ADDS     R1,R1,#+16
   \      0x1D2   0xF8CB 0x1000      STR      R1,[R11, #+0]
   \      0x1D6   0x9801             LDR      R0,[SP, #+4]
   \      0x1D8   0x4428             ADD      R0,R5,R0
   \      0x1DA   0x9001             STR      R0,[SP, #+4]
   2166            }
   2167            if (length % 16 != 0) {
   \                     ??sl_se_gcm_multipart_update_5: (+1)
   \      0x1DC   0xF018 0x0F0F      TST      R8,#0xF
   \      0x1E0   0xD00E             BEQ.N    ??sl_se_gcm_multipart_update_11
   2168              if (length > 16) {
   \      0x1E2   0xF1B8 0x0F10      CMP      R8,#+16
   \      0x1E6   0xD926             BLS.N    ??sl_se_gcm_multipart_update_12
   2169                // Input length is larger than, and a non multiple of, 16
   2170                memcpy(gcm_ctx->final_data, input + stored_res_length + (length - (length % 16)), length % 16);
   \      0x1E8   0x9801             LDR      R0,[SP, #+4]
   \      0x1EA   0xF008 0x020F      AND      R2,R8,#0xF
   \      0x1EE   0xEBA8 0x0502      SUB      R5,R8,R2
   \      0x1F2   0x1941             ADDS     R1,R0,R5
   \      0x1F4   0x.... 0x....      BL       ?Subroutine47
   2171                gcm_ctx->final_data_length = length % 16;
   \                     ??CrossCallReturnLabel_275: (+1)
   \      0x1F8   0xF008 0x000F      AND      R0,R8,#0xF
   \      0x1FC   0x7038             STRB     R0,[R7, #+0]
   2172                length -= length % 16;
   \      0x1FE   0x46A8             MOV      R8,R5
   2173              } else {
   2174                // Input length is not a multiple of 16
   2175                memcpy(gcm_ctx->final_data, input + stored_res_length, length);
   2176                gcm_ctx->final_data_length = length;
   2177                *output_length = 0;
   2178                return SL_STATUS_OK;
   2179              }
   2180            }
   2181            gcm_ctx->len += length;
   \                     ??sl_se_gcm_multipart_update_11: (+1)
   \      0x200   0xE9D6 0x0100      LDRD     R0,R1,[R6, #+0]
   \      0x204   0x2200             MOVS     R2,#+0
   2182          
   2183            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2184                                                                  gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   \      0x206   0xF10D 0x0E40      ADD      LR,SP,#+64
   \      0x20A   0xEB10 0x0008      ADDS     R0,R0,R8
   \      0x20E   0x4151             ADCS     R1,R1,R2
   \      0x210   0xE9C6 0x0100      STRD     R0,R1,[R6, #+0]
   \      0x214   0x.... 0x....      ADR.W    R0,?_79
   \      0x218   0xE890 0x002C      LDM      R0,{R2,R3,R5}
   \      0x21C   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x220   0xE88E 0x002C      STM      LR,{R2,R3,R5}
   \      0x224   0x9010             STR      R0,[SP, #+64]
   \      0x226   0x78B8             LDRB     R0,[R7, #+2]
   \      0x228   0x2800             CMP      R0,#+0
   \      0x22A   0xBF14             ITE      NE
   \      0x22C   0x.... 0x....      LDRNE.W  R0,??DataTable125_1
   \      0x230   0x.... 0x....      LDREQ.W  R0,??DataTable127_3
   \      0x234   0xE009             B.N      ??sl_se_gcm_multipart_update_13
   \                     ??sl_se_gcm_multipart_update_12: (+1)
   \      0x236   0x9901             LDR      R1,[SP, #+4]
   \      0x238   0x4642             MOV      R2,R8
   \      0x23A   0x.... 0x....      BL       ?Subroutine47
   \                     ??CrossCallReturnLabel_276: (+1)
   \      0x23E   0xF887 0x8000      STRB     R8,[R7, #+0]
   \      0x242   0x2000             MOVS     R0,#+0
   \      0x244   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \      0x248   0xE06E             B.N      ??sl_se_gcm_multipart_update_4
   2185          
   2186            SE_DataTransfer_t data_in =
   2187              SE_DATATRANSFER_DEFAULT(input + stored_res_length, length);
   \                     ??sl_se_gcm_multipart_update_13: (+1)
   \      0x24A   0x.... 0x....      ADR.W    R5,?_80
   \      0x24E   0x9012             STR      R0,[SP, #+72]
   \      0x250   0xE895 0x000E      LDM      R5,{R1-R3}
   \      0x254   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \      0x258   0xA80D             ADD      R0,SP,#+52
   \      0x25A   0xE880 0x000E      STM      R0,{R1-R3}
   \      0x25E   0xF8CD 0xC034      STR      R12,[SP, #+52]
   \      0x262   0xF048 0x5100      ORR      R1,R8,#0x20000000
   \      0x266   0x910F             STR      R1,[SP, #+60]
   2188          
   2189            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x268   0x.... 0x....      ADR.W    R2,?_81
   \      0x26C   0xE892 0x0228      LDM      R2,{R3,R5,R9}
   \      0x270   0xF10D 0x0E28      ADD      LR,SP,#+40
   2190            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2191                                                                sizeof(gcm_ctx->se_ctx));
   \      0x274   0x.... 0x....      ADR.W    R0,?_82
   \      0x278   0xE88E 0x0228      STM      LR,{R3,R5,R9}
   \      0x27C   0xF8CD 0xA028      STR      R10,[SP, #+40]
   \      0x280   0x910C             STR      R1,[SP, #+48]
   \      0x282   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x286   0xAD07             ADD      R5,SP,#+28
   \      0x288   0xF106 0x0E10      ADD      LR,R6,#+16
   \      0x28C   0xE885 0x000E      STM      R5,{R1-R3}
   \      0x290   0xF8CD 0xE01C      STR      LR,[SP, #+28]
   2192          
   2193            sli_se_command_init(cmd_ctx,
   2194                                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2195                                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2196                                | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   \      0x294   0x7878             LDRB     R0,[R7, #+1]
   \      0x296   0x2801             CMP      R0,#+1
   \      0x298   0xBF0C             ITE      EQ
   \      0x29A   0x.... 0x....      LDREQ.W  R1,??DataTable127
   \      0x29E   0x.... 0x....      LDRNE.W  R1,??DataTable127_4
   \      0x2A2   0x78B8             LDRB     R0,[R7, #+2]
   \      0x2A4   0x2800             CMP      R0,#+0
   \      0x2A6   0xBF14             ITE      NE
   \      0x2A8   0x2001             MOVNE    R0,#+1
   \      0x2AA   0x2003             MOVEQ    R0,#+3
   \      0x2AC   0x4301             ORRS     R1,R0,R1
   \      0x2AE   0x6021             STR      R1,[R4, #+0]
   \      0x2B0   0x2100             MOVS     R1,#+0
   \      0x2B2   0x6061             STR      R1,[R4, #+4]
   \      0x2B4   0x60A1             STR      R1,[R4, #+8]
   \      0x2B6   0x61E1             STR      R1,[R4, #+28]
   2197          
   2198            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x2B8   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_22: (+1)
   \      0x2BC   0x2800             CMP      R0,#+0
   \      0x2BE   0xD133             BNE.N    ??sl_se_gcm_multipart_update_4
   \      0x2C0   0x9901             LDR      R1,[SP, #+4]
   \      0x2C2   0x.... 0x....      BL       ??Subroutine21_0
   2199            SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_85: (+1)
   \      0x2C6   0x2100             MOVS     R1,#+0
   \      0x2C8   0x.... 0x....      BL       ??Subroutine21_0
   2200            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_84: (+1)
   \      0x2CC   0x.... 0x....      BL       ?Subroutine21
   2201          
   2202            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_97: (+1)
   \      0x2D0   0x9800             LDR      R0,[SP, #+0]
   \      0x2D2   0xA904             ADD      R1,SP,#+16
   \      0x2D4   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x2D8   0xBB30             CBNZ.N   R0,??sl_se_gcm_multipart_update_4
   \      0x2DA   0xA904             ADD      R1,SP,#+16
   \      0x2DC   0x.... 0x....      BL       ??Subroutine20_1
   2203            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_52: (+1)
   \      0x2E0   0x9800             LDR      R0,[SP, #+0]
   \      0x2E2   0xA901             ADD      R1,SP,#+4
   \      0x2E4   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x2E8   0xB9F0             CBNZ.N   R0,??sl_se_gcm_multipart_update_4
   \      0x2EA   0xA901             ADD      R1,SP,#+4
   \      0x2EC   0x.... 0x....      BL       ??Subroutine20_1
   2204          
   2205            SE_addDataInput(se_cmd, &iv_ctx_in);
   \                     ??CrossCallReturnLabel_51: (+1)
   \      0x2F0   0xA910             ADD      R1,SP,#+64
   \      0x2F2   0x.... 0x....      BL       ??Subroutine20_1
   2206            SE_addDataInput(se_cmd, &data_in);
   \                     ??CrossCallReturnLabel_50: (+1)
   \      0x2F6   0xA90D             ADD      R1,SP,#+52
   \      0x2F8   0x.... 0x....      BL       ??Subroutine20_1
   2207          
   2208            SE_addDataOutput(se_cmd, &data_out);
   \                     ??CrossCallReturnLabel_49: (+1)
   \      0x2FC   0xA90A             ADD      R1,SP,#+40
   \      0x2FE   0x.... 0x....      BL       ?Subroutine22
   2209          
   2210            SE_addDataOutput(se_cmd, &ctx_out);
   \                     ??CrossCallReturnLabel_105: (+1)
   \      0x302   0xA907             ADD      R1,SP,#+28
   \      0x304   0x.... 0x....      BL       ?Subroutine22
   2211          
   2212            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_104: (+1)
   \      0x308   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_113: (+1)
   \      0x30C   0x0004             MOVS     R4,R0
   2213          
   2214            if (status != SL_STATUS_OK) {
   \      0x30E   0xD003             BEQ.N    ??sl_se_gcm_multipart_update_14
   2215              memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   \      0x310   0x.... 0x....      BL       ?Subroutine49
   2216              return status;
   \                     ??CrossCallReturnLabel_280: (+1)
   \      0x314   0x4620             MOV      R0,R4
   \      0x316   0xE007             B.N      ??sl_se_gcm_multipart_update_4
   2217            }
   2218            *output_length += length;
   \                     ??sl_se_gcm_multipart_update_14: (+1)
   \      0x318   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   2219            gcm_ctx->first_operation = false;
   \      0x31C   0x2100             MOVS     R1,#+0
   \      0x31E   0x4440             ADD      R0,R8,R0
   \      0x320   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \      0x324   0x70B9             STRB     R1,[R7, #+2]
   2220            return SL_STATUS_OK;
   \                     ??sl_se_gcm_multipart_update_7: (+1)
   \      0x326   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_update_4: (+1)
   \      0x328   0x.... 0x....      B.W      ?Subroutine2
   2221          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_75:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_76:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_77:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_78:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_79:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_80:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_81:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_82:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
   2222          
   2223          #else // SLI_SE_MAJOR_VERSION_ONE
   2224          /***************************************************************************//**
   2225           * GCM multipart encryption/decryption, update stage.
   2226           ******************************************************************************/
   2227          sl_status_t sl_se_gcm_multipart_update(sl_se_gcm_multipart_context_t *gcm_ctx,
   2228                                                 sl_se_command_context_t *cmd_ctx,
   2229                                                 const sl_se_key_descriptor_t *key,
   2230                                                 size_t length,
   2231                                                 const uint8_t *input,
   2232                                                 uint8_t *output,
   2233                                                 size_t *output_length)
   2234          {
   2235            sl_status_t status = SL_STATUS_OK;
   2236            uint8_t stored_res_length = 0;
   2237          
   2238            // Check input parameters.
   2239            if (cmd_ctx == NULL || key == NULL || gcm_ctx == NULL) {
   2240              return SL_STATUS_INVALID_PARAMETER;
   2241            }
   2242            if (length == 0) {
   2243              return SL_STATUS_OK;
   2244            }
   2245            if (length > 0 && (input == NULL || output == NULL || output_length == NULL)) {
   2246              return SL_STATUS_INVALID_PARAMETER;
   2247            }
   2248          
   2249            *output_length = 0;
   2250          
   2251            // Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes.
   2252            // Also check for possible overflow.
   2253            if (gcm_ctx->len + length < gcm_ctx->len
   2254                || (uint64_t)gcm_ctx->len + length > 0xFFFFFFFE0ULL) {
   2255              return SL_STATUS_INVALID_PARAMETER;
   2256            }
   2257            SE_Command_t *se_cmd = &cmd_ctx->command;
   2258          
   2259            // The finish command will return the wrong tag or INVALID SIGNATURE if there is no
   2260            // input data. There is no way to know when sl_se_gcm_multipart_update is called for the last time, so there must
   2261            // always be data stored.
   2262            // The update context only support an input length as a multiple of 16. Hence, there
   2263            // there is a few cases that can happen.
   2264          
   2265            // Always:
   2266            //  Case length = 0: Return SL_STATUS_OK
   2267          
   2268            // If there is no data in gcm_ctx->final_data
   2269            //  Case length < 16: Store data in gcm_ctx->final_data and return SL_STATUS_OK
   2270            //  Case length > 16 and length is not a multiple of 16: Run update as normal on the largest multiple
   2271            //  and save the residue bytes in gcm_ctx->final_data.
   2272            //  Case length == 16: store the current se_ctx in gcm_ctx->previous_se_ctx and store input data in final_data,
   2273            //  then run update as normal on the input data.
   2274            //  Case length > 16 and length is a multible of 16: run update twice, one with all input data and one with
   2275            //  all input data except the last 16 bytes. The out_ctx from each run are stored in gcm_ctx->se_ctx and
   2276            //  gcm_ctx->previous_se_ctx respectively. The last 16 bytes are then stored in final_data.
   2277            //  NOTE:output_length will include all encrypted/decrypted data.
   2278          
   2279            // If there is data in gcm_ctx->final_data
   2280            //  Case final_data_length + length < 16: Store input data in gcm_ctx and return SL_STATUS_OKAY
   2281            //  Case final_data_length + length > 16: Add data to fill up the gcm_ctx->final_data-buffer, run update
   2282            //  on the gcm_ctx->final_data-buffer and finally run update as explained above on the rest of the data.
   2283          
   2284            // Our drivers only support full or no overlap between input and output
   2285            // buffers. So in the case of partial overlap, copy the input buffer into
   2286            // the output buffer and process it in place as if the buffers fully
   2287            // overlapped.
   2288            if ((output > input) && (output < (input + length))) {
   2289              memmove(output, input, length);
   2290              input = output;
   2291            }
   2292          
   2293            // Check for data in final_data_length.
   2294            if (gcm_ctx->final_data_length && gcm_ctx->final_data_length != 16) {
   2295              if ((gcm_ctx->final_data_length + length) < 16) {
   2296                memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, length);
   2297                gcm_ctx->final_data_length += length;
   2298                *output_length = 0;
   2299                return SL_STATUS_OK;
   2300              }
   2301          
   2302              if ((gcm_ctx->final_data_length + length) == 16) {
   2303                memcpy(gcm_ctx->previous_se_ctx, gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2304              }
   2305              stored_res_length = 16 - gcm_ctx->final_data_length;
   2306              memcpy(gcm_ctx->final_data + gcm_ctx->final_data_length, input, stored_res_length);
   2307          
   2308              SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2309                                                                    gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   2310          
   2311              SE_DataTransfer_t data_in =
   2312                SE_DATATRANSFER_DEFAULT(gcm_ctx->final_data, 16);
   2313          
   2314              SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, 16);
   2315              SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2316                                                                  sizeof(gcm_ctx->se_ctx));
   2317          
   2318              sli_se_command_init(cmd_ctx,
   2319                                  (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2320                                   : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2321                                  | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   2322          
   2323              sli_add_key_parameters(cmd_ctx, key, status);
   2324              SE_addParameter(se_cmd, 0);
   2325              SE_addParameter(se_cmd, 16);
   2326          
   2327              sli_add_key_metadata(cmd_ctx, key, status);
   2328              sli_add_key_input(cmd_ctx, key, status);
   2329          
   2330              SE_addDataInput(se_cmd, &iv_ctx_in);
   2331              SE_addDataInput(se_cmd, &data_in);
   2332          
   2333              SE_addDataOutput(se_cmd, &data_out);
   2334          
   2335              SE_addDataOutput(se_cmd, &ctx_out);
   2336          
   2337              status = sli_se_execute_and_wait(cmd_ctx);
   2338          
   2339              if (status != SL_STATUS_OK) {
   2340                memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2341                return status;
   2342              }
   2343              gcm_ctx->first_operation = false;
   2344              gcm_ctx->len += 16;
   2345              output += 16;
   2346          
   2347              if ((gcm_ctx->final_data_length + length) == 16) {
   2348                gcm_ctx->final_data_length = 16;
   2349                *output_length = 16;
   2350                return SL_STATUS_OK;
   2351              }
   2352          
   2353              if ((length - stored_res_length) < 16) {
   2354                memcpy(gcm_ctx->final_data, input + stored_res_length, length - stored_res_length);
   2355                gcm_ctx->final_data_length = length - stored_res_length;
   2356                *output_length = 16;
   2357                return SL_STATUS_OK;
   2358              }
   2359          
   2360              length -= stored_res_length;
   2361              gcm_ctx->final_data_length = 0;
   2362              *output_length += 16;
   2363            }
   2364            if (length % 16 != 0) {
   2365              if (length > 16) {
   2366                //Input length is larger than, and a non multiple of, 16
   2367                memcpy(gcm_ctx->final_data, input + stored_res_length + (length - (length % 16)), length % 16);
   2368                gcm_ctx->final_data_length = length % 16;
   2369                length -= length % 16;
   2370              } else {
   2371                //Input length is not a multiple of 16
   2372                memcpy(gcm_ctx->final_data, input + stored_res_length, length);
   2373                gcm_ctx->final_data_length = length;
   2374                *output_length = 0;
   2375                return SL_STATUS_OK;
   2376              }
   2377            } else {
   2378              if (length > 16) {
   2379                //If length is larger than, and a multiple of, 16, we must compute a context without the last 16 bytes
   2380                //and store it as the previous context in case there is no more data.
   2381                memcpy(gcm_ctx->final_data, input + stored_res_length + (length - 16), 16);
   2382                gcm_ctx->final_data_length = 16;
   2383          
   2384                //The gcm_ctx->se_ctx buffer contain iv data with length 12 if gcm_ctx->first_operation = true
   2385                SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2386                                                                      gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   2387          
   2388                SE_DataTransfer_t data_in =
   2389                  SE_DATATRANSFER_DEFAULT(input + stored_res_length, length - 16);
   2390          
   2391                SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length - 16);
   2392                SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2393                                                                    sizeof(gcm_ctx->se_ctx));
   2394          
   2395                sli_se_command_init(cmd_ctx,
   2396                                    (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2397                                     : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2398                                    | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   2399          
   2400                sli_add_key_parameters(cmd_ctx, key, status);
   2401                SE_addParameter(se_cmd, 0);
   2402                SE_addParameter(se_cmd, length - 16);
   2403          
   2404                sli_add_key_metadata(cmd_ctx, key, status);
   2405                sli_add_key_input(cmd_ctx, key, status);
   2406          
   2407                SE_addDataInput(se_cmd, &iv_ctx_in);
   2408                SE_addDataInput(se_cmd, &data_in);
   2409          
   2410                SE_addDataOutput(se_cmd, &data_out);
   2411          
   2412                SE_addDataOutput(se_cmd, &ctx_out);
   2413          
   2414                status = sli_se_execute_and_wait(cmd_ctx);
   2415          
   2416                if (status != SL_STATUS_OK) {
   2417                  memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2418                  return status;
   2419                }
   2420          
   2421                // Only process the last 16 bytes in the last operation.
   2422                output += (length - 16);
   2423                input += (length - 16);
   2424                gcm_ctx->first_operation = false;
   2425                gcm_ctx->len += (length - 16);
   2426                *output_length += (length - 16);
   2427          
   2428                length = 16;
   2429          
   2430                memcpy(gcm_ctx->previous_se_ctx, gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2431              } else {
   2432                memcpy(gcm_ctx->previous_se_ctx, gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   2433                memcpy(gcm_ctx->final_data, input + stored_res_length, length);
   2434                gcm_ctx->final_data_length = length;
   2435              }
   2436            }
   2437            gcm_ctx->len += length;
   2438          
   2439            // The gcm_ctx->se_ctx buffer contain iv data with length 12 if gcm_ctx->first_operation = true
   2440            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2441                                                                  gcm_ctx->first_operation ? 12 : sizeof(gcm_ctx->se_ctx));
   2442          
   2443            SE_DataTransfer_t data_in =
   2444              SE_DATATRANSFER_DEFAULT(input + stored_res_length, length);
   2445          
   2446            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   2447            SE_DataTransfer_t ctx_out = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx,
   2448                                                                sizeof(gcm_ctx->se_ctx));
   2449          
   2450            sli_se_command_init(cmd_ctx,
   2451                                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2452                                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2453                                | (gcm_ctx->first_operation ? SLI_SE_COMMAND_OPTION_CONTEXT_START : SLI_SE_COMMAND_OPTION_CONTEXT_ADD));
   2454          
   2455            sli_add_key_parameters(cmd_ctx, key, status);
   2456            SE_addParameter(se_cmd, 0);
   2457            SE_addParameter(se_cmd, length);
   2458          
   2459            sli_add_key_metadata(cmd_ctx, key, status);
   2460            sli_add_key_input(cmd_ctx, key, status);
   2461          
   2462            SE_addDataInput(se_cmd, &iv_ctx_in);
   2463            SE_addDataInput(se_cmd, &data_in);
   2464          
   2465            SE_addDataOutput(se_cmd, &data_out);
   2466          
   2467            SE_addDataOutput(se_cmd, &ctx_out);
   2468          
   2469            status = sli_se_execute_and_wait(cmd_ctx);
   2470          
   2471            if (status != SL_STATUS_OK) {
   2472              memset(gcm_ctx->se_ctx, 0, sizeof(gcm_ctx->se_ctx));
   2473              return status;
   2474            }
   2475            *output_length += length;
   2476            gcm_ctx->first_operation = false;
   2477            return SL_STATUS_OK;
   2478          }
   2479          #endif
   2480          
   2481          /***************************************************************************//**
   2482           * GCM multipart encryption/decryption, finish stage.
   2483           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2484          sl_status_t sl_se_gcm_multipart_finish(sl_se_gcm_multipart_context_t *gcm_ctx,
   2485                                                 sl_se_command_context_t *cmd_ctx,
   2486                                                 const sl_se_key_descriptor_t *key,
   2487                                                 uint8_t *tag,
   2488                                                 uint8_t tag_length,
   2489                                                 uint8_t *output,
   2490                                                 uint8_t output_size,
   2491                                                 uint8_t *output_length)
   2492          {
   \                     sl_se_gcm_multipart_finish: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB09D             SUB      SP,SP,#+116
   \        0x6   0x000C             MOVS     R4,R1
   2493            sl_status_t status = SL_STATUS_OK;
   2494            uint32_t tmpbuf[4];
   2495            uint8_t length;
   2496            if (cmd_ctx == NULL || key == NULL || gcm_ctx == NULL || tag == NULL || tag_length < 4 || tag_length > 16) {
   \        0x8   0xD013             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \        0xA   0x9209             STR      R2,[SP, #+36]
   \        0xC   0x0011             MOVS     R1,R2
   \        0xE   0xD010             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x10   0x0002             MOVS     R2,R0
   \       0x12   0xD00E             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x14   0x9308             STR      R3,[SP, #+32]
   \       0x16   0x0018             MOVS     R0,R3
   \       0x18   0xD00B             BEQ.N    ??sl_se_gcm_multipart_finish_0
   \       0x1A   0x9B26             LDR      R3,[SP, #+152]
   \       0x1C   0x1F18             SUBS     R0,R3,#+4
   \       0x1E   0x280C             CMP      R0,#+12
   \       0x20   0xD807             BHI.N    ??sl_se_gcm_multipart_finish_0
   2497              return SL_STATUS_INVALID_PARAMETER;
   2498            }
   2499          
   2500            if ((gcm_ctx->final_data_length != 16)
   2501                && (output_size < gcm_ctx->final_data_length)) {
   \       0x22   0xF102 0x0540      ADD      R5,R2,#+64
   \       0x26   0x782E             LDRB     R6,[R5, #+0]
   \       0x28   0x2E10             CMP      R6,#+16
   \       0x2A   0xD004             BEQ.N    ??sl_se_gcm_multipart_finish_1
   \       0x2C   0x9828             LDR      R0,[SP, #+160]
   \       0x2E   0x42B0             CMP      R0,R6
   \       0x30   0xD201             BCS.N    ??sl_se_gcm_multipart_finish_1
   2502              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_gcm_multipart_finish_0: (+1)
   \       0x32   0x2021             MOVS     R0,#+33
   \       0x34   0xE113             B.N      ??sl_se_gcm_multipart_finish_2
   2503            }
   2504          
   2505            SE_Command_t *se_cmd = &cmd_ctx->command;
   2506            length = gcm_ctx->final_data_length;
   2507            gcm_ctx->len += ((length % 16 != 0) ? length : 0);
   \                     ??sl_se_gcm_multipart_finish_1: (+1)
   \       0x36   0xF016 0x0F0F      TST      R6,#0xF
   \       0x3A   0xBF14             ITE      NE
   \       0x3C   0x46B0             MOVNE    R8,R6
   \       0x3E   0xF04F 0x0800      MOVEQ    R8,#+0
   \       0x42   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   2508          
   2509            #if defined(SLI_SE_MAJOR_VERSION_ONE)
   2510            if ((gcm_ctx->add_len > 0) && (gcm_ctx->len == 0)) {
   2511              if (gcm_ctx->mode == SL_SE_DECRYPT) {
   2512                if (memcmp_time_cst(tag, gcm_ctx->tagbuf, tag_length)) {
   2513                  memset(tag, 0, tag_length);
   2514                  return SL_STATUS_INVALID_SIGNATURE;
   2515                }
   2516              } else {
   2517                memcpy(tag, gcm_ctx->tagbuf, tag_length);
   2518              }
   2519              return SL_STATUS_OK;
   2520            }
   2521            #endif
   2522          
   2523          #if defined(SLI_SE_MAJOR_VERSION_ONE)
   2524            // For xG21 devices, since the multipart finish command cannot handle cases without
   2525            // more data being passed as part of the finish call, there are two cases for which
   2526            // a finish call can condense into a one-shot operation:
   2527            // 1. The 'first operation' flag is set, meaning no multipart context has been started
   2528            // 2. There was no AAD input and the total input length equals 16 bytes. In such a case,
   2529            //    all information needed for a one-shot operation is still present in the context,
   2530            //    being the 16 bytes of input in the lookback buffer. In such a case, be careful to
   2531            //    not return ciphertext/plaintext to the user a second time, since it has already
   2532            //    been returned as part of the initial call to `_update`.
   2533            if (gcm_ctx->first_operation || (gcm_ctx->add_len == 0 && gcm_ctx->len == 16)) {
   2534          #else
   2535            // Devices xG23 or newer support a finish call without data, so the only case for
   2536            // condensing a multipart finish operation into a one-shot operation is when the
   2537            // 'first operation' flag is set, meaning no multipart context has been started
   2538            if (gcm_ctx->first_operation) {
   \       0x46   0x461F             MOV      R7,R3
   \       0x48   0xEB10 0x0008      ADDS     R0,R0,R8
   \       0x4C   0xEB41 0x71D8      ADC      R1,R1,R8, LSR #+31
   \       0x50   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0x54   0xE9DD 0xAB00      LDRD     R10,R11,[SP, #+0]
   \       0x58   0xE9C2 0xAB00      STRD     R10,R11,[R2, #+0]
   \       0x5C   0x78A8             LDRB     R0,[R5, #+2]
   \       0x5E   0xF8DD 0xC09C      LDR      R12,[SP, #+156]
   \       0x62   0xF8DD 0x80A4      LDR      R8,[SP, #+164]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD03F             BEQ.N    ??sl_se_gcm_multipart_finish_3
   2539          #endif
   2540              if (gcm_ctx->mode == SL_SE_ENCRYPT) {
   \       0x6A   0x7868             LDRB     R0,[R5, #+1]
   \       0x6C   0xB9D0             CBNZ.N   R0,??sl_se_gcm_multipart_finish_4
   2541                status = sl_se_gcm_crypt_and_tag(cmd_ctx,
   2542                                                 key,
   2543                                                 gcm_ctx->mode,
   2544                                                 length,
   2545                                                 gcm_ctx->se_ctx, //iv
   2546                                                 12,  //iv_len
   2547                                                 NULL,
   2548                                                 0,
   2549                                                 gcm_ctx->final_data,
   2550                                                 (length < 16 ? output : (unsigned char*)tmpbuf),
   2551                                                 tag_length,
   2552                                                 tag);
   \       0x6E   0x2E10             CMP      R6,#+16
   \       0x70   0xBFA8             IT       GE
   \       0x72   0xF10D 0x0C28      ADDGE    R12,SP,#+40
   \       0x76   0x9808             LDR      R0,[SP, #+32]
   \       0x78   0xF102 0x0330      ADD      R3,R2,#+48
   \       0x7C   0x9304             STR      R3,[SP, #+16]
   \       0x7E   0x9007             STR      R0,[SP, #+28]
   \       0x80   0x200C             MOVS     R0,#+12
   \       0x82   0xF102 0x0310      ADD      R3,R2,#+16
   \       0x86   0x9909             LDR      R1,[SP, #+36]
   \       0x88   0x2500             MOVS     R5,#+0
   \       0x8A   0x9001             STR      R0,[SP, #+4]
   \       0x8C   0x9300             STR      R3,[SP, #+0]
   \       0x8E   0x9706             STR      R7,[SP, #+24]
   \       0x90   0xF8CD 0xC014      STR      R12,[SP, #+20]
   \       0x94   0x9503             STR      R5,[SP, #+12]
   \       0x96   0x9502             STR      R5,[SP, #+8]
   \       0x98   0x4633             MOV      R3,R6
   \       0x9A   0x2200             MOVS     R2,#+0
   \       0x9C   0x4620             MOV      R0,R4
   \       0x9E   0x.... 0x....      BL       sl_se_gcm_crypt_and_tag
   \       0xA2   0xE017             B.N      ??sl_se_gcm_multipart_finish_5
   2553              } else {
   2554                status = sl_se_gcm_auth_decrypt(cmd_ctx,
   2555                                                key,
   2556                                                length,
   2557                                                gcm_ctx->se_ctx, //iv
   2558                                                12,   //iv_len
   2559                                                NULL,
   2560                                                0,
   2561                                                gcm_ctx->final_data,
   2562                                                (length < 16 ? output : (unsigned char*)tmpbuf),
   2563                                                tag_length,
   2564                                                tag);
   \                     ??sl_se_gcm_multipart_finish_4: (+1)
   \       0xA4   0x2E10             CMP      R6,#+16
   \       0xA6   0xBFA8             IT       GE
   \       0xA8   0xF10D 0x0C28      ADDGE    R12,SP,#+40
   \       0xAC   0x9808             LDR      R0,[SP, #+32]
   \       0xAE   0x2300             MOVS     R3,#+0
   \       0xB0   0x9302             STR      R3,[SP, #+8]
   \       0xB2   0x9006             STR      R0,[SP, #+24]
   \       0xB4   0x9301             STR      R3,[SP, #+4]
   \       0xB6   0x200C             MOVS     R0,#+12
   \       0xB8   0x9909             LDR      R1,[SP, #+36]
   \       0xBA   0xF102 0x0530      ADD      R5,R2,#+48
   \       0xBE   0x9000             STR      R0,[SP, #+0]
   \       0xC0   0xF102 0x0310      ADD      R3,R2,#+16
   \       0xC4   0x9705             STR      R7,[SP, #+20]
   \       0xC6   0xF8CD 0xC010      STR      R12,[SP, #+16]
   \       0xCA   0x9503             STR      R5,[SP, #+12]
   \       0xCC   0x4632             MOV      R2,R6
   \       0xCE   0x4620             MOV      R0,R4
   \       0xD0   0x.... 0x....      BL       sl_se_gcm_auth_decrypt
   \                     ??sl_se_gcm_multipart_finish_5: (+1)
   \       0xD4   0x0004             MOVS     R4,R0
   2565              }
   2566              if (status != SL_STATUS_OK) {
   \       0xD6   0xF000 0x80BC      BEQ.W    ??sl_se_gcm_multipart_finish_6
   2567                *output_length = 0;
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xF888 0x0000      STRB     R0,[R8, #+0]
   2568                memset(tag, 0, tag_length);
   \       0xE0   0x9808             LDR      R0,[SP, #+32]
   \       0xE2   0x4639             MOV      R1,R7
   \       0xE4   0x.... 0x....      BL       __aeabi_memclr
   2569                return status;
   \       0xE8   0xE0B1             B.N      ??sl_se_gcm_multipart_finish_7
   2570              }
   2571              if (length < 16) {
   2572                *output_length = length;
   2573              } else {
   2574                *output_length = 0;
   2575              }
   2576              return SL_STATUS_OK;
   2577            }
   2578          
   2579            // Construct GCM LenA || LenC block into temporary buffer
   2580            tmpbuf[0] = __REV(gcm_ctx->add_len >> 29);
   \                     ??sl_se_gcm_multipart_finish_3: (+1)
   \       0xEA   0xE9D2 0xAB02      LDRD     R10,R11,[R2, #+8]
   2581            tmpbuf[1] = __REV((gcm_ctx->add_len << 3) & 0xFFFFFFFFUL);
   \       0xEE   0xF10D 0x0E28      ADD      LR,SP,#+40
   \       0xF2   0xEA4F 0x705A      LSR      R0,R10,#+29
   \       0xF6   0xEA40 0x00CB      ORR      R0,R0,R11, LSL #+3
   \       0xFA   0xBA00             REV      R0,R0
   \       0xFC   0x900A             STR      R0,[SP, #+40]
   \       0xFE   0xEA4F 0x01CA      LSL      R1,R10,#+3
   \      0x102   0xBA08             REV      R0,R1
   \      0x104   0xF8CE 0x0004      STR      R0,[LR, #+4]
   2582            tmpbuf[2] = __REV(gcm_ctx->len >> 29);
   \      0x108   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   2583            tmpbuf[3] = __REV((gcm_ctx->len << 3) & 0xFFFFFFFFUL);
   2584          
   2585            SE_DataTransfer_t data_in =
   2586              SE_DATATRANSFER_DEFAULT(gcm_ctx->final_data, length);
   \      0x10C   0xF10D 0x0A68      ADD      R10,SP,#+104
   \      0x110   0x0F40             LSRS     R0,R0,#+29
   \      0x112   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \      0x116   0xBA00             REV      R0,R0
   \      0x118   0xF8CE 0x0008      STR      R0,[LR, #+8]
   \      0x11C   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x120   0x00C0             LSLS     R0,R0,#+3
   \      0x122   0xBA00             REV      R0,R0
   \      0x124   0xF8CE 0x000C      STR      R0,[LR, #+12]
   \      0x128   0x.... 0x....      ADR.W    R0,?_83
   \      0x12C   0xE890 0x4A00      LDM      R0,{R9,R11,LR}
   \      0x130   0xF102 0x0030      ADD      R0,R2,#+48
   2587          
   2588            #if defined(SLI_SE_MAJOR_VERSION_ONE)
   2589            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT((length % 16 != 0 || length == 0) ? gcm_ctx->se_ctx : gcm_ctx->previous_se_ctx, sizeof(gcm_ctx->previous_se_ctx));
   2590            #else
   2591            SE_DataTransfer_t iv_ctx_in = SE_DATATRANSFER_DEFAULT(gcm_ctx->se_ctx, sizeof(gcm_ctx->se_ctx));
   \      0x134   0x.... 0x....      ADR.W    R1,?_84
   \      0x138   0xE88A 0x4A00      STM      R10,{R9,R11,LR}
   \      0x13C   0x901A             STR      R0,[SP, #+104]
   \      0x13E   0xF046 0x5E00      ORR      LR,R6,#0x20000000
   \      0x142   0xF8CD 0xE070      STR      LR,[SP, #+112]
   \      0x146   0xE891 0x0E00      LDM      R1,{R9-R11}
   \      0x14A   0xA817             ADD      R0,SP,#+92
   \      0x14C   0xF102 0x0110      ADD      R1,R2,#+16
   \      0x150   0xE880 0x0E00      STM      R0,{R9-R11}
   \      0x154   0x9117             STR      R1,[SP, #+92]
   2592            #endif
   2593          
   2594            SE_DataTransfer_t lenalenc_in = SE_DATATRANSFER_DEFAULT(&tmpbuf[0],
   2595                                                                    sizeof(tmpbuf));
   \      0x156   0x.... 0x....      ADR.W    R10,?_85
   \      0x15A   0xE89A 0x0206      LDM      R10,{R1,R2,R9}
   \      0x15E   0xA814             ADD      R0,SP,#+80
   2596          
   2597            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x160   0xF10D 0x0B04      ADD      R11,SP,#+4
   \      0x164   0xE880 0x0206      STM      R0,{R1,R2,R9}
   \      0x168   0xA90A             ADD      R1,SP,#+40
   \      0x16A   0x9114             STR      R1,[SP, #+80]
   \      0x16C   0x.... 0x....      ADR.W    R2,?_86
   \      0x170   0xE892 0x0601      LDM      R2,{R0,R9,R10}
   2598            if (length == 16) {
   \      0x174   0x2E10             CMP      R6,#+16
   \      0x176   0xE88B 0x0601      STM      R11,{R0,R9,R10}
   \      0x17A   0xF8CD 0xC004      STR      R12,[SP, #+4]
   \      0x17E   0xF8CD 0xE00C      STR      LR,[SP, #+12]
   \      0x182   0xD105             BNE.N    ??sl_se_gcm_multipart_finish_8
   2599              data_out.data = NULL;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0x9001             STR      R0,[SP, #+4]
   2600              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x188   0x9803             LDR      R0,[SP, #+12]
   \      0x18A   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x18E   0x9003             STR      R0,[SP, #+12]
   2601            }
   2602          
   2603            SE_DataTransfer_t gcm_tag = SE_DATATRANSFER_DEFAULT(tag, tag_length);
   \                     ??sl_se_gcm_multipart_finish_8: (+1)
   \      0x190   0x.... 0x....      ADR.W    R0,?_87
   \      0x194   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \      0x198   0xF8DD 0xA020      LDR      R10,[SP, #+32]
   \      0x19C   0xF10D 0x0910      ADD      R9,SP,#+16
   \      0x1A0   0xE889 0x4006      STM      R9,{R1,R2,LR}
   \      0x1A4   0xF8CD 0xA010      STR      R10,[SP, #+16]
   \      0x1A8   0xF047 0x5100      ORR      R1,R7,#0x20000000
   \      0x1AC   0x9106             STR      R1,[SP, #+24]
   2604          
   2605            sli_se_command_init(cmd_ctx,
   2606                                (gcm_ctx->mode == SL_SE_DECRYPT ? SLI_SE_COMMAND_AES_GCM_DECRYPT
   2607                                 : SLI_SE_COMMAND_AES_GCM_ENCRYPT)
   2608                                | tag_length << 8 | SLI_SE_COMMAND_OPTION_CONTEXT_END);
   \      0x1AE   0x7869             LDRB     R1,[R5, #+1]
   \      0x1B0   0x2901             CMP      R1,#+1
   \      0x1B2   0xBF0C             ITE      EQ
   \      0x1B4   0x.... 0x....      LDREQ.W  R0,??DataTable127
   \      0x1B8   0x....             LDRNE.N  R0,??DataTable125_2
   \      0x1BA   0xEA40 0x2003      ORR      R0,R0,R3, LSL #+8
   2609          
   2610            sli_add_key_parameters(cmd_ctx, key, status);
   \      0x1BE   0x4669             MOV      R1,SP
   \      0x1C0   0xF040 0x0002      ORR      R0,R0,#0x2
   \      0x1C4   0x6020             STR      R0,[R4, #+0]
   \      0x1C6   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_12: (+1)
   \      0x1CA   0x9809             LDR      R0,[SP, #+36]
   \      0x1CC   0x.... 0x....      BL       sli_se_key_to_keyspec
   \      0x1D0   0x2800             CMP      R0,#+0
   \      0x1D2   0xD144             BNE.N    ??sl_se_gcm_multipart_finish_2
   \      0x1D4   0x.... 0x....      BL       ?Subroutine17
   2611            SE_addParameter(se_cmd, 0);
   \                     ??CrossCallReturnLabel_30: (+1)
   \      0x1D8   0x2100             MOVS     R1,#+0
   \      0x1DA   0x.... 0x....      BL       ??Subroutine21_0
   2612            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_83: (+1)
   \      0x1DE   0x4631             MOV      R1,R6
   \      0x1E0   0x.... 0x....      BL       ??Subroutine21_0
   2613          
   2614            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_82: (+1)
   \      0x1E4   0x9809             LDR      R0,[SP, #+36]
   \      0x1E6   0xA911             ADD      R1,SP,#+68
   \      0x1E8   0x.... 0x....      BL       sli_se_get_auth_buffer
   \      0x1EC   0x2800             CMP      R0,#+0
   \      0x1EE   0xD136             BNE.N    ??sl_se_gcm_multipart_finish_2
   \      0x1F0   0xA911             ADD      R1,SP,#+68
   \      0x1F2   0x.... 0x....      BL       ??Subroutine20_1
   2615            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_48: (+1)
   \      0x1F6   0x9809             LDR      R0,[SP, #+36]
   \      0x1F8   0xA90E             ADD      R1,SP,#+56
   \      0x1FA   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x1FE   0xBB70             CBNZ.N   R0,??sl_se_gcm_multipart_finish_2
   \      0x200   0xA90E             ADD      R1,SP,#+56
   \      0x202   0x.... 0x....      BL       ??Subroutine20_1
   2616          
   2617            SE_addDataInput(se_cmd, &iv_ctx_in);
   \                     ??CrossCallReturnLabel_47: (+1)
   \      0x206   0xA917             ADD      R1,SP,#+92
   \      0x208   0x.... 0x....      BL       ??Subroutine20_1
   2618            SE_addDataInput(se_cmd, &data_in);
   \                     ??CrossCallReturnLabel_46: (+1)
   \      0x20C   0xA91A             ADD      R1,SP,#+104
   \      0x20E   0x.... 0x....      BL       ??Subroutine20_1
   2619            SE_addDataInput(se_cmd, &lenalenc_in);
   \                     ??CrossCallReturnLabel_45: (+1)
   \      0x212   0xA914             ADD      R1,SP,#+80
   \      0x214   0x.... 0x....      BL       ??Subroutine20_1
   2620          
   2621            if (gcm_ctx->mode == SL_SE_DECRYPT) {
   \                     ??CrossCallReturnLabel_44: (+1)
   \      0x218   0x7868             LDRB     R0,[R5, #+1]
   \      0x21A   0x2801             CMP      R0,#+1
   \      0x21C   0xD102             BNE.N    ??CrossCallReturnLabel_43
   2622              SE_addDataInput(se_cmd, &gcm_tag);
   \      0x21E   0xA904             ADD      R1,SP,#+16
   \      0x220   0x.... 0x....      BL       ??Subroutine20_1
   2623            }
   2624          
   2625            SE_addDataOutput(se_cmd, &data_out);
   \                     ??CrossCallReturnLabel_43: (+1)
   \      0x224   0xA901             ADD      R1,SP,#+4
   \      0x226   0x.... 0x....      BL       ?Subroutine22
   2626          
   2627            if (gcm_ctx->mode == SL_SE_ENCRYPT) {
   \                     ??CrossCallReturnLabel_103: (+1)
   \      0x22A   0x7868             LDRB     R0,[R5, #+1]
   \      0x22C   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_102
   2628              SE_addDataOutput(se_cmd, &gcm_tag);
   \      0x22E   0xA904             ADD      R1,SP,#+16
   \      0x230   0x.... 0x....      BL       ?Subroutine22
   2629            }
   2630          
   2631            status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_102: (+1)
   \      0x234   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_112: (+1)
   \      0x238   0x0004             MOVS     R4,R0
   2632          
   2633            if (status != SL_STATUS_OK) {
   \      0x23A   0xD00A             BEQ.N    ??sl_se_gcm_multipart_finish_6
   2634              if (gcm_ctx->mode == SL_SE_ENCRYPT) {
   \      0x23C   0x7868             LDRB     R0,[R5, #+1]
   \      0x23E   0xB918             CBNZ.N   R0,??sl_se_gcm_multipart_finish_9
   2635                memset(tag, 0, tag_length);
   \      0x240   0x9808             LDR      R0,[SP, #+32]
   \      0x242   0x4639             MOV      R1,R7
   \      0x244   0x.... 0x....      BL       __aeabi_memclr
   2636              }
   2637              *output_length = 0;
   \                     ??sl_se_gcm_multipart_finish_9: (+1)
   \      0x248   0x2000             MOVS     R0,#+0
   \      0x24A   0xF888 0x0000      STRB     R0,[R8, #+0]
   2638              return status;
   \                     ??sl_se_gcm_multipart_finish_7: (+1)
   \      0x24E   0x4620             MOV      R0,R4
   \      0x250   0xE005             B.N      ??sl_se_gcm_multipart_finish_2
   2639            }
   2640          
   2641            if (length < 16) {
   \                     ??sl_se_gcm_multipart_finish_6: (+1)
   \      0x252   0x2E10             CMP      R6,#+16
   \      0x254   0xBFA8             IT       GE
   \      0x256   0x2600             MOVGE    R6,#+0
   2642              *output_length = length;
   2643            } else {
   2644              *output_length = 0;
   2645            }
   2646          
   2647            return SL_STATUS_OK;
   \      0x258   0xF888 0x6000      STRB     R6,[R8, #+0]
   \      0x25C   0x2000             MOVS     R0,#+0
   \                     ??sl_se_gcm_multipart_finish_2: (+1)
   \      0x25E                      REQUIRE ?Subroutine4
   \      0x25E                      ;; // Fall through to label ?Subroutine4
   2648          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_83:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_84:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_85:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_86:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_87:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   2649          
   2650          #if (defined(_SILICON_LABS_SECURITY_FEATURE) \
   2651            && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT))
   2652          /***************************************************************************//**
   2653           * ChaCha20 buffer encryption/decryption, as defined by RFC8439 section 2.4.
   2654           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2655          sl_status_t sl_se_chacha20_crypt(sl_se_command_context_t *cmd_ctx,
   2656                                           sl_se_cipher_operation_t mode,
   2657                                           const sl_se_key_descriptor_t *key,
   2658                                           size_t length,
   2659                                           const unsigned char initial_counter[4],
   2660                                           const unsigned char nonce[12],
   2661                                           const unsigned char *input,
   2662                                           unsigned char *output)
   2663          {
   \                     sl_se_chacha20_crypt: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x469A             MOV      R10,R3
   2664            if (cmd_ctx == NULL || key == NULL || initial_counter == NULL || nonce == NULL
   2665                || input == NULL || output == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x12   0xD011             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x14   0x9F1A             LDR      R7,[SP, #+104]
   \       0x16   0x2F00             CMP      R7,#+0
   \       0x18   0xBF1C             ITT      NE
   \       0x1A   0x9D1B             LDRNE    R5,[SP, #+108]
   \       0x1C   0x2D00             CMPNE    R5,#+0
   \       0x1E   0xD00B             BEQ.N    ??sl_se_chacha20_crypt_0
   \       0x20   0x9E1C             LDR      R6,[SP, #+112]
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xBF1C             ITT      NE
   \       0x26   0xF8DD 0x9074      LDRNE    R9,[SP, #+116]
   \       0x2A   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x2E   0xD003             BEQ.N    ??sl_se_chacha20_crypt_0
   2666              return SL_STATUS_INVALID_PARAMETER;
   2667            }
   2668          
   2669            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \       0x30   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x34   0x2820             CMP      R0,#+32
   \       0x36   0xD001             BEQ.N    ??sl_se_chacha20_crypt_1
   2670              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_chacha20_crypt_0: (+1)
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0xE057             B.N      ??CrossCallReturnLabel_111
   2671            }
   2672          
   2673            SE_Command_t *se_cmd = &cmd_ctx->command;
   2674            sl_status_t status;
   2675          
   2676            sli_se_command_init(cmd_ctx,
   2677                                (mode == SL_SE_ENCRYPT
   2678                                 ? SLI_SE_COMMAND_CHACHA20_ENCRYPT
   2679                                 : SLI_SE_COMMAND_CHACHA20_DECRYPT)
   2680                                | SLI_SE_COMMAND_OPTION_CONTEXT_WHOLE);
   \                     ??sl_se_chacha20_crypt_1: (+1)
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xBF0C             ITE      EQ
   \       0x40   0x.... 0x....      LDREQ.W  R0,??DataTable127_5
   \       0x44   0x.... 0x....      LDRNE.W  R0,??DataTable127_6
   \       0x48   0x.... 0x....      BL       ?Subroutine6
   2681          
   2682            // Add key parameters to command
   2683            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD14D             BNE.N    ??CrossCallReturnLabel_111
   \       0x50   0x.... 0x....      BL       ?Subroutine17
   2684            // Message size (number of bytes)
   2685            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x54   0x4651             MOV      R1,R10
   \       0x56   0x.... 0x....      BL       ??Subroutine21_0
   2686          
   2687            // Add key metadata block to command
   2688            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x5A   0xA90F             ADD      R1,SP,#+60
   \       0x5C   0x4640             MOV      R0,R8
   \       0x5E   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD142             BNE.N    ??CrossCallReturnLabel_111
   \       0x66   0xA90F             ADD      R1,SP,#+60
   \       0x68   0x.... 0x....      BL       ??Subroutine20_1
   2689            // Add key input block to command
   2690            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x6C   0xA90C             ADD      R1,SP,#+48
   \       0x6E   0x4640             MOV      R0,R8
   \       0x70   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD139             BNE.N    ??CrossCallReturnLabel_111
   \       0x78   0xA90C             ADD      R1,SP,#+48
   \       0x7A   0x.... 0x....      BL       ??Subroutine20_1
   2691          
   2692            // Add initial counter to command
   2693            SE_DataTransfer_t counter = SE_DATATRANSFER_DEFAULT(initial_counter, 4);
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x7E   0x.... 0x....      ADR.W    R0,?_88
   \       0x82   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x86   0xF10D 0x0E24      ADD      LR,SP,#+36
   2694            SE_addDataInput(se_cmd, &counter);
   \       0x8A   0x4620             MOV      R0,R4
   \       0x8C   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0x90   0x9709             STR      R7,[SP, #+36]
   \       0x92   0xA909             ADD      R1,SP,#+36
   \       0x94   0x.... 0x....      BL       SE_addDataInput
   2695          
   2696            // Add nonce/IV to command
   2697            SE_DataTransfer_t iv = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \       0x98   0x.... 0x....      ADR.W    R0,?_89
   \       0x9C   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xA0   0xAF06             ADD      R7,SP,#+24
   2698            SE_addDataInput(se_cmd, &iv);
   \       0xA2   0x4620             MOV      R0,R4
   \       0xA4   0xE887 0x000E      STM      R7,{R1-R3}
   \       0xA8   0x9506             STR      R5,[SP, #+24]
   \       0xAA   0xA906             ADD      R1,SP,#+24
   \       0xAC   0x.... 0x....      BL       SE_addDataInput
   2699          
   2700            // Add input data to command
   2701            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0xB0   0x.... 0x....      ADR.W    R0,?_90
   \       0xB4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xB8   0xAD03             ADD      R5,SP,#+12
   \       0xBA   0xF04A 0x5A00      ORR      R10,R10,#0x20000000
   \       0xBE   0xE885 0x000E      STM      R5,{R1-R3}
   \       0xC2   0x9603             STR      R6,[SP, #+12]
   \       0xC4   0xF8CD 0xA014      STR      R10,[SP, #+20]
   2702            SE_addDataInput(se_cmd, &in);
   \       0xC8   0x.... 0x....      BL       ??Subroutine20_0
   2703          
   2704            // Request output data from command
   2705            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0xCC   0x.... 0x....      ADR.W    R1,?_91
   \       0xD0   0xE891 0x002C      LDM      R1,{R2,R3,R5}
   \       0xD4   0x4668             MOV      R0,SP
   2706            SE_addDataOutput(se_cmd, &out);
   \       0xD6   0x4669             MOV      R1,SP
   \       0xD8   0xE880 0x002C      STM      R0,{R2,R3,R5}
   \       0xDC   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0xE0   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0xE4   0x.... 0x....      BL       ?Subroutine22
   2707          
   2708            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_101: (+1)
   \       0xE8   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_111: (+1)
   \       0xEC                      REQUIRE ?Subroutine5
   \       0xEC                      ;; // Fall through to label ?Subroutine5
   2709          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_88:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'916
   \              0x0000'0001  
   \              0x2000'0004

   \                                 In section .text, align 4, keep-with-next
   \                     ?_89:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .text, align 4, keep-with-next
   \                     ?_90:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_91:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   2710          
   2711          /***************************************************************************//**
   2712           * ChaCha20-Poly1305 authenticated encryption with additional data, as defined
   2713           * by RFC8439 section 2.8.
   2714           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2715          sl_status_t sl_se_chacha20_poly1305_encrypt_and_tag(sl_se_command_context_t *cmd_ctx,
   2716                                                              const sl_se_key_descriptor_t *key,
   2717                                                              size_t length,
   2718                                                              const unsigned char nonce[12],
   2719                                                              const unsigned char *add, size_t add_len,
   2720                                                              const unsigned char *input,
   2721                                                              unsigned char *output,
   2722                                                              unsigned char *tag)
   2723          {
   \                     sl_se_chacha20_poly1305_encrypt_and_tag: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0xEA5F 0x0A00      MOVS     R10,R0
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x4614             MOV      R4,R2
   \        0xE   0x4698             MOV      R8,R3
   2724            // Check input parameters.
   2725            if (cmd_ctx == NULL || key == NULL || nonce == NULL
   2726                || ((add_len > 0) && (add == NULL))
   2727                || ((length > 0) && (input == NULL))) {
   \       0x10   0xBF1C             ITT      NE
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x18   0xD00C             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_0
   \       0x1A   0x9F1F             LDR      R7,[SP, #+124]
   \       0x1C   0x9D1E             LDR      R5,[SP, #+120]
   \       0x1E   0xB107             CBZ.N    R7,??sl_se_chacha20_poly1305_encrypt_and_tag_1
   \       0x20   0xB145             CBZ.N    R5,??sl_se_chacha20_poly1305_encrypt_and_tag_0
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_1: (+1)
   \       0x22   0xF8DD 0x9080      LDR      R9,[SP, #+128]
   \       0x26   0xB114             CBZ.N    R4,??sl_se_chacha20_poly1305_encrypt_and_tag_2
   \       0x28   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x2C   0xD002             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_0
   2728              return SL_STATUS_INVALID_PARAMETER;
   2729            }
   2730          
   2731            SE_Command_t *se_cmd = &cmd_ctx->command;
   2732            sl_status_t status;
   2733          
   2734            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_2: (+1)
   \       0x2E   0x6830             LDR      R0,[R6, #+0]
   \       0x30   0x2820             CMP      R0,#+32
   \       0x32   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_3
   2735              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_0: (+1)
   \       0x34   0x2021             MOVS     R0,#+33
   \       0x36   0xE079             B.N      ??sl_se_chacha20_poly1305_encrypt_and_tag_4
   2736            }
   2737          
   2738            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHACHAPOLY_ENCRYPT);
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_3: (+1)
   \       0x38   0xF04F 0x6240      MOV      R2,#+201326592
   \       0x3C   0xF8CA 0x2000      STR      R2,[R10, #+0]
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0xF8CA 0x1004      STR      R1,[R10, #+4]
   \       0x46   0xF8CA 0x1008      STR      R1,[R10, #+8]
   \       0x4A   0xF8CA 0x101C      STR      R1,[R10, #+28]
   2739          
   2740            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x4E   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD16A             BNE.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_4
   \       0x56   0x9900             LDR      R1,[SP, #+0]
   \       0x58   0x4650             MOV      R0,R10
   \       0x5A   0x.... 0x....      BL       SE_addParameter
   2741            SE_addParameter(se_cmd, add_len);
   \       0x5E   0x4639             MOV      R1,R7
   \       0x60   0x4650             MOV      R0,R10
   \       0x62   0x.... 0x....      BL       SE_addParameter
   2742            SE_addParameter(se_cmd, length);
   \       0x66   0x4621             MOV      R1,R4
   \       0x68   0x4650             MOV      R0,R10
   \       0x6A   0x.... 0x....      BL       SE_addParameter
   2743          
   2744            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x6E   0xA912             ADD      R1,SP,#+72
   \       0x70   0x.... 0x....      BL       ??Subroutine26_0
   \                     ??CrossCallReturnLabel_150: (+1)
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD159             BNE.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_4
   \       0x78   0xA912             ADD      R1,SP,#+72
   \       0x7A   0x.... 0x....      BL       ?Subroutine31
   2745            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_213: (+1)
   \       0x7E   0xA90F             ADD      R1,SP,#+60
   \       0x80   0x.... 0x....      BL       ??Subroutine35_0
   \                     ??CrossCallReturnLabel_222: (+1)
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD151             BNE.N    ??sl_se_chacha20_poly1305_encrypt_and_tag_4
   \       0x88   0x9E21             LDR      R6,[SP, #+132]
   \       0x8A   0xA90F             ADD      R1,SP,#+60
   \       0x8C   0x.... 0x....      BL       ?Subroutine31
   2746          
   2747            SE_DataTransfer_t nonce_in = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \                     ??CrossCallReturnLabel_212: (+1)
   \       0x90   0x.... 0x....      ADR.W    R0,?_92
   \       0x94   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0x98   0xAB0C             ADD      R3,SP,#+48
   2748            SE_addDataInput(se_cmd, &nonce_in);
   \       0x9A   0x4650             MOV      R0,R10
   \       0x9C   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xA0   0x.... 0x....      BL       ?Subroutine32
   2749          
   2750            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \                     ??CrossCallReturnLabel_215: (+1)
   \       0xA4   0x.... 0x....      ADR.W    R0,?_93
   \       0xA8   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xAC   0xAB09             ADD      R3,SP,#+36
   \       0xAE   0xF047 0x5700      ORR      R7,R7,#0x20000000
   \       0xB2   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xB6   0x9509             STR      R5,[SP, #+36]
   \       0xB8   0x970B             STR      R7,[SP, #+44]
   2751            SE_addDataInput(se_cmd, &aad_in);
   \       0xBA   0xA909             ADD      R1,SP,#+36
   \       0xBC   0x.... 0x....      BL       ?Subroutine31
   2752          
   2753            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \                     ??CrossCallReturnLabel_211: (+1)
   \       0xC0   0x.... 0x....      ADR.W    R0,?_94
   \       0xC4   0xE890 0x0026      LDM      R0,{R1,R2,R5}
   \       0xC8   0xAB06             ADD      R3,SP,#+24
   \       0xCA   0xF044 0x5400      ORR      R4,R4,#0x20000000
   \       0xCE   0xE883 0x0026      STM      R3,{R1,R2,R5}
   \       0xD2   0xF8CD 0x9018      STR      R9,[SP, #+24]
   \       0xD6   0x9408             STR      R4,[SP, #+32]
   2754            SE_addDataInput(se_cmd, &data_in);
   \       0xD8   0xA906             ADD      R1,SP,#+24
   \       0xDA   0x.... 0x....      BL       ?Subroutine31
   2755          
   2756            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \                     ??CrossCallReturnLabel_210: (+1)
   \       0xDE   0x.... 0x....      ADR.W    R1,?_95
   \       0xE2   0xE891 0x008C      LDM      R1,{R2,R3,R7}
   \       0xE6   0x466D             MOV      R5,SP
   \       0xE8   0xE885 0x008C      STM      R5,{R2,R3,R7}
   \       0xEC   0x9600             STR      R6,[SP, #+0]
   \       0xEE   0x9402             STR      R4,[SP, #+8]
   2757            if (output == NULL) {
   \       0xF0   0xB91E             CBNZ.N   R6,??sl_se_chacha20_poly1305_encrypt_and_tag_5
   2758              data_out.length |= SE_DATATRANSFER_DISCARD;
   \       0xF2   0x9802             LDR      R0,[SP, #+8]
   \       0xF4   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \       0xF8   0x9002             STR      R0,[SP, #+8]
   2759            }
   2760            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_5: (+1)
   \       0xFA   0x.... 0x....      ADR.W    R5,?_96
   \       0xFE   0x9C22             LDR      R4,[SP, #+136]
   \      0x100   0x4669             MOV      R1,SP
   \      0x102   0x4650             MOV      R0,R10
   \      0x104   0x.... 0x....      BL       SE_addDataOutput
   2761          
   2762            SE_DataTransfer_t mac_out = SE_DATATRANSFER_DEFAULT(tag, 16);
   \      0x108   0xE895 0x0007      LDM      R5,{R0-R2}
   \      0x10C   0xAB03             ADD      R3,SP,#+12
   \      0x10E   0xE883 0x0007      STM      R3,{R0-R2}
   \      0x112   0x9403             STR      R4,[SP, #+12]
   2763            if (tag == NULL) {
   \      0x114   0xB91C             CBNZ.N   R4,??sl_se_chacha20_poly1305_encrypt_and_tag_6
   2764              mac_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x116   0x9805             LDR      R0,[SP, #+20]
   \      0x118   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x11C   0x9005             STR      R0,[SP, #+20]
   2765            }
   2766            SE_addDataOutput(se_cmd, &mac_out);
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_6: (+1)
   \      0x11E   0xA903             ADD      R1,SP,#+12
   \      0x120   0x4650             MOV      R0,R10
   \      0x122   0x.... 0x....      BL       SE_addDataOutput
   2767          
   2768            // Execute AEAD operation.
   2769            return sli_se_execute_and_wait(cmd_ctx);
   \      0x126   0x4650             MOV      R0,R10
   \      0x128   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_chacha20_poly1305_encrypt_and_tag_4: (+1)
   \      0x12C   0xB016             ADD      SP,SP,#+88
   \      0x12E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2770          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \        0x0   0x4650             MOV      R0,R10
   \        0x2   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \        0x0   0xF8CD 0x8030      STR      R8,[SP, #+48]
   \        0x4   0xA90C             ADD      R1,SP,#+48
   \        0x6   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 4, keep-with-next
   \                     ?_92:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .text, align 4, keep-with-next
   \                     ?_93:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_94:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_95:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_96:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010
   2771          
   2772          /***************************************************************************//**
   2773           * ChaCha20-Poly1305 authenticated decryption with additional data, as defined
   2774           * by RFC8439 section 2.8.
   2775           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2776          sl_status_t sl_se_chacha20_poly1305_auth_decrypt(sl_se_command_context_t *cmd_ctx,
   2777                                                           const sl_se_key_descriptor_t *key,
   2778                                                           size_t length,
   2779                                                           const unsigned char nonce[12],
   2780                                                           const unsigned char *add, size_t add_len,
   2781                                                           const unsigned char *input,
   2782                                                           unsigned char *output,
   2783                                                           const unsigned char tag[16])
   2784          {
   \                     sl_se_chacha20_poly1305_auth_decrypt: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0xEA5F 0x0B00      MOVS     R11,R0
   \        0xA   0x4689             MOV      R9,R1
   2785            // Check input parameters.
   2786            if (cmd_ctx == NULL || key == NULL || nonce == NULL || tag == NULL
   2787                || ((add_len > 0) && (add == NULL))
   2788                || ((length > 0) && (input == NULL))) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x12   0xD014             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \       0x14   0xEA5F 0x0803      MOVS     R8,R3
   \       0x18   0xBF1C             ITT      NE
   \       0x1A   0x9C22             LDRNE    R4,[SP, #+136]
   \       0x1C   0x2C00             CMPNE    R4,#+0
   \       0x1E   0xD00E             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   \       0x20   0x9D1F             LDR      R5,[SP, #+124]
   \       0x22   0x9E1E             LDR      R6,[SP, #+120]
   \       0x24   0xB105             CBZ.N    R5,??sl_se_chacha20_poly1305_auth_decrypt_1
   \       0x26   0xB156             CBZ.N    R6,??sl_se_chacha20_poly1305_auth_decrypt_0
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_1: (+1)
   \       0x28   0x0017             MOVS     R7,R2
   \       0x2A   0xF8DD 0xA080      LDR      R10,[SP, #+128]
   \       0x2E   0xD002             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_2
   \       0x30   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x34   0xD003             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_0
   2789              return SL_STATUS_INVALID_PARAMETER;
   2790            }
   2791          
   2792            SE_Command_t *se_cmd = &cmd_ctx->command;
   2793            sl_status_t status;
   2794          
   2795            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_2: (+1)
   \       0x36   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x3A   0x2820             CMP      R0,#+32
   \       0x3C   0xD001             BEQ.N    ??sl_se_chacha20_poly1305_auth_decrypt_3
   2796              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_0: (+1)
   \       0x3E   0x2021             MOVS     R0,#+33
   \       0x40   0xE077             B.N      ??sl_se_chacha20_poly1305_auth_decrypt_4
   2797            }
   2798          
   2799            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CHACHAPOLY_DECRYPT);
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_3: (+1)
   \       0x42   0x....             LDR.N    R1,??DataTable127_7
   \       0x44   0xF8CB 0x1000      STR      R1,[R11, #+0]
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \       0x4E   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \       0x52   0xF8CB 0x001C      STR      R0,[R11, #+28]
   2800          
   2801            sli_add_key_parameters(cmd_ctx, key, status);
   \       0x56   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD169             BNE.N    ??sl_se_chacha20_poly1305_auth_decrypt_4
   \       0x5E   0x9900             LDR      R1,[SP, #+0]
   \       0x60   0x4658             MOV      R0,R11
   \       0x62   0x.... 0x....      BL       SE_addParameter
   2802            SE_addParameter(se_cmd, add_len);
   \       0x66   0x4629             MOV      R1,R5
   \       0x68   0x4658             MOV      R0,R11
   \       0x6A   0x.... 0x....      BL       SE_addParameter
   2803            SE_addParameter(se_cmd, length);
   \       0x6E   0x4639             MOV      R1,R7
   \       0x70   0x4658             MOV      R0,R11
   \       0x72   0x.... 0x....      BL       SE_addParameter
   2804          
   2805            sli_add_key_metadata(cmd_ctx, key, status);
   \       0x76   0xA912             ADD      R1,SP,#+72
   \       0x78   0x4648             MOV      R0,R9
   \       0x7A   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD157             BNE.N    ??sl_se_chacha20_poly1305_auth_decrypt_4
   \       0x82   0xA912             ADD      R1,SP,#+72
   \       0x84   0x.... 0x....      BL       ?Subroutine33
   2806            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_219: (+1)
   \       0x88   0xA90F             ADD      R1,SP,#+60
   \       0x8A   0x4648             MOV      R0,R9
   \       0x8C   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD14E             BNE.N    ??sl_se_chacha20_poly1305_auth_decrypt_4
   \       0x94   0xF8DD 0x9084      LDR      R9,[SP, #+132]
   \       0x98   0xA90F             ADD      R1,SP,#+60
   \       0x9A   0x.... 0x....      BL       ?Subroutine33
   2807          
   2808            SE_DataTransfer_t nonce_in = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \                     ??CrossCallReturnLabel_218: (+1)
   \       0x9E   0xBF00             Nop
   \       0xA0   0x....             ADR.N    R0,?_97
   \       0xA2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xA6   0xF10D 0x0E30      ADD      LR,SP,#+48
   2809            SE_addDataInput(se_cmd, &nonce_in);
   \       0xAA   0x4658             MOV      R0,R11
   \       0xAC   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xB0   0x.... 0x....      BL       ?Subroutine32
   2810          
   2811            SE_DataTransfer_t aad_in = SE_DATATRANSFER_DEFAULT(add, add_len);
   \                     ??CrossCallReturnLabel_214: (+1)
   \       0xB4   0x.... 0x....      ADR.W    LR,?_98
   \       0xB8   0xE89E 0x0007      LDM      LR,{R0-R2}
   \       0xBC   0xAB09             ADD      R3,SP,#+36
   \       0xBE   0xF045 0x5500      ORR      R5,R5,#0x20000000
   \       0xC2   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xC6   0x9609             STR      R6,[SP, #+36]
   \       0xC8   0x950B             STR      R5,[SP, #+44]
   2812            SE_addDataInput(se_cmd, &aad_in);
   \       0xCA   0xA909             ADD      R1,SP,#+36
   \       0xCC   0x.... 0x....      BL       ?Subroutine33
   2813          
   2814            SE_DataTransfer_t data_in = SE_DATATRANSFER_DEFAULT(input, length);
   \                     ??CrossCallReturnLabel_217: (+1)
   \       0xD0   0x....             ADR.N    R0,?_99
   \       0xD2   0xE890 0x0026      LDM      R0,{R1,R2,R5}
   \       0xD6   0xAB06             ADD      R3,SP,#+24
   \       0xD8   0xF047 0x5700      ORR      R7,R7,#0x20000000
   \       0xDC   0xE883 0x0026      STM      R3,{R1,R2,R5}
   \       0xE0   0xF8CD 0xA018      STR      R10,[SP, #+24]
   \       0xE4   0x9708             STR      R7,[SP, #+32]
   2815            SE_addDataInput(se_cmd, &data_in);
   \       0xE6   0xA906             ADD      R1,SP,#+24
   \       0xE8   0x.... 0x....      BL       ?Subroutine33
   2816          
   2817            SE_DataTransfer_t mac_in = SE_DATATRANSFER_DEFAULT(tag, 16);
   \                     ??CrossCallReturnLabel_216: (+1)
   \       0xEC   0x....             ADR.N    R0,?_100
   \       0xEE   0xE890 0x0026      LDM      R0,{R1,R2,R5}
   \       0xF2   0xAB03             ADD      R3,SP,#+12
   2818            SE_addDataInput(se_cmd, &mac_in);
   \       0xF4   0x4658             MOV      R0,R11
   \       0xF6   0xE883 0x0026      STM      R3,{R1,R2,R5}
   \       0xFA   0x9403             STR      R4,[SP, #+12]
   \       0xFC   0xA903             ADD      R1,SP,#+12
   \       0xFE   0x.... 0x....      BL       SE_addDataInput
   2819          
   2820            SE_DataTransfer_t data_out = SE_DATATRANSFER_DEFAULT(output, length);
   \      0x102   0xBF00             Nop
   \      0x104   0x....             ADR.N    R1,?_101
   \      0x106   0xE891 0x002C      LDM      R1,{R2,R3,R5}
   \      0x10A   0x466C             MOV      R4,SP
   2821            if (output == NULL) {
   \      0x10C   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x110   0xE884 0x002C      STM      R4,{R2,R3,R5}
   \      0x114   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x118   0x9702             STR      R7,[SP, #+8]
   \      0x11A   0xD103             BNE.N    ??sl_se_chacha20_poly1305_auth_decrypt_5
   2822              data_out.length |= SE_DATATRANSFER_DISCARD;
   \      0x11C   0x9802             LDR      R0,[SP, #+8]
   \      0x11E   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x122   0x9002             STR      R0,[SP, #+8]
   2823            }
   2824            SE_addDataOutput(se_cmd, &data_out);
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_5: (+1)
   \      0x124   0x4669             MOV      R1,SP
   \      0x126   0x4658             MOV      R0,R11
   \      0x128   0x.... 0x....      BL       SE_addDataOutput
   2825          
   2826            // Execute AEAD operation.
   2827            return sli_se_execute_and_wait(cmd_ctx);
   \      0x12C   0x4658             MOV      R0,R11
   \      0x12E   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_chacha20_poly1305_auth_decrypt_4: (+1)
   \      0x132   0x.... 0x....      B.W      ?Subroutine2
   2828          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \        0x0   0x4658             MOV      R0,R11
   \        0x2   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 4, keep-with-next
   \                     ?_97:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .text, align 4, keep-with-next
   \                     ?_98:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_99:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_100:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ?_101:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
   2829          
   2830          /***************************************************************************//**
   2831           * Generate a MAC (message authentication code) for a given message, according
   2832           * to RFC8439 section 2.8 but bypassing the encryption step.
   2833           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2834          sl_status_t sl_se_poly1305_genkey_tag(sl_se_command_context_t *cmd_ctx,
   2835                                                const sl_se_key_descriptor_t *key,
   2836                                                size_t length,
   2837                                                const unsigned char nonce[12],
   2838                                                const unsigned char *input,
   2839                                                unsigned char *tag)
   2840          {
   \                     sl_se_poly1305_genkey_tag: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0x4614             MOV      R4,R2
   \        0xC   0x4698             MOV      R8,R3
   2841            if (cmd_ctx == NULL || key == NULL || nonce == NULL || tag == NULL
   2842                || ((length > 0) && (input == NULL))) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x14   0xD00C             BEQ.N    ??sl_se_poly1305_genkey_tag_0
   \       0x16   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x1A   0xBF1C             ITT      NE
   \       0x1C   0x9D17             LDRNE    R5,[SP, #+92]
   \       0x1E   0x2D00             CMPNE    R5,#+0
   \       0x20   0xD006             BEQ.N    ??sl_se_poly1305_genkey_tag_0
   \       0x22   0x9F16             LDR      R7,[SP, #+88]
   \       0x24   0xB104             CBZ.N    R4,??sl_se_poly1305_genkey_tag_1
   \       0x26   0xB11F             CBZ.N    R7,??sl_se_poly1305_genkey_tag_0
   2843              return SL_STATUS_INVALID_PARAMETER;
   2844            }
   2845          
   2846            if (key->type != SL_SE_KEY_TYPE_CHACHA20) {
   \                     ??sl_se_poly1305_genkey_tag_1: (+1)
   \       0x28   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x2C   0x2820             CMP      R0,#+32
   \       0x2E   0xD001             BEQ.N    ??sl_se_poly1305_genkey_tag_2
   2847              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_poly1305_genkey_tag_0: (+1)
   \       0x30   0x2021             MOVS     R0,#+33
   \       0x32   0xE046             B.N      ??CrossCallReturnLabel_256
   2848            }
   2849          
   2850            SE_Command_t *se_cmd = &cmd_ctx->command;
   2851            sl_status_t status;
   2852          
   2853            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_POLY1305_KEY_MAC);
   \                     ??sl_se_poly1305_genkey_tag_2: (+1)
   \       0x34   0x....             LDR.N    R2,??DataTable127_8
   \       0x36   0x.... 0x....      BL       ?Subroutine9
   2854          
   2855            // Add key parameters to command
   2856            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x3A   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD13F             BNE.N    ??CrossCallReturnLabel_256
   \       0x42   0x9900             LDR      R1,[SP, #+0]
   \       0x44   0x.... 0x....      BL       ??Subroutine25_0
   2857            // Message size (number of bytes)
   2858            SE_addParameter(se_cmd, length);
   \                     ??CrossCallReturnLabel_138: (+1)
   \       0x48   0x4621             MOV      R1,R4
   \       0x4A   0x.... 0x....      BL       ??Subroutine25_0
   2859          
   2860            // Add key metadata block to command
   2861            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_137: (+1)
   \       0x4E   0xA90C             ADD      R1,SP,#+48
   \       0x50   0x4648             MOV      R0,R9
   \       0x52   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD133             BNE.N    ??CrossCallReturnLabel_256
   \       0x5A   0xA90C             ADD      R1,SP,#+48
   \       0x5C   0x.... 0x....      BL       ??Subroutine30_0
   2862            // Add key input block to command
   2863            sli_add_key_input(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_189: (+1)
   \       0x60   0xA909             ADD      R1,SP,#+36
   \       0x62   0x4648             MOV      R0,R9
   \       0x64   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0x68   0xBB58             CBNZ.N   R0,??CrossCallReturnLabel_256
   \       0x6A   0xA909             ADD      R1,SP,#+36
   \       0x6C   0x.... 0x....      BL       ??Subroutine30_0
   2864          
   2865            // Add nonce/IV to command
   2866            SE_DataTransfer_t iv = SE_DATATRANSFER_DEFAULT(nonce, 12);
   \                     ??CrossCallReturnLabel_188: (+1)
   \       0x70   0x....             ADR.N    R0,?_102
   \       0x72   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x76   0xF10D 0x0E18      ADD      LR,SP,#+24
   2867            SE_addDataInput(se_cmd, &iv);
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0x80   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0x84   0xA906             ADD      R1,SP,#+24
   \       0x86   0x.... 0x....      BL       SE_addDataInput
   2868          
   2869            // Add input data to command
   2870            SE_DataTransfer_t in = SE_DATATRANSFER_DEFAULT(input, length);
   \       0x8A   0xBF00             Nop
   \       0x8C   0x....             ADR.N    R0,?_103
   \       0x8E   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x92   0xF10D 0x080C      ADD      R8,SP,#+12
   \       0x96   0xF044 0x5400      ORR      R4,R4,#0x20000000
   \       0x9A   0xE888 0x000E      STM      R8,{R1-R3}
   \       0x9E   0x9703             STR      R7,[SP, #+12]
   \       0xA0   0x9405             STR      R4,[SP, #+20]
   2871            SE_addDataInput(se_cmd, &in);
   \       0xA2   0xA903             ADD      R1,SP,#+12
   \       0xA4   0x.... 0x....      BL       ??Subroutine30_0
   2872          
   2873            // Request tag from command
   2874            SE_DataTransfer_t out = SE_DATATRANSFER_DEFAULT(tag, 16);
   \                     ??CrossCallReturnLabel_187: (+1)
   \       0xA8   0x....             ADR.N    R0,?_104
   \       0xAA   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xAE   0x466C             MOV      R4,SP
   2875            SE_addDataOutput(se_cmd, &out);
   \       0xB0   0x4630             MOV      R0,R6
   \       0xB2   0xE884 0x000E      STM      R4,{R1-R3}
   \       0xB6   0x9500             STR      R5,[SP, #+0]
   \       0xB8   0x4669             MOV      R1,SP
   \       0xBA   0x.... 0x....      BL       SE_addDataOutput
   2876          
   2877            return sli_se_execute_and_wait(cmd_ctx);
   \       0xBE   0x.... 0x....      BL       ?Subroutine41
   \                     ??CrossCallReturnLabel_256: (+1)
   \       0xC2   0xB00F             ADD      SP,SP,#+60
   \       0xC4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2878          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_102:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'924
   \              0x0000'0001  
   \              0x2000'000C

   \                                 In section .text, align 4, keep-with-next
   \                     ?_103:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_104:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'928
   \              0x0000'0001  
   \              0x2000'0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112:
   \        0x0   0x0400'0100        DC32     0x4000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_1:
   \        0x0   0x0401'0100        DC32     0x4010100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_2:
   \        0x0   0x0400'0203        DC32     0x4000203

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_3:
   \        0x0   0x0401'0203        DC32     0x4010203

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113:
   \        0x0   0x0400'0403        DC32     0x4000403

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_1:
   \        0x0   0x0401'0403        DC32     0x4010403

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine48: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0xF105 0x001D      ADD      R0,R5,#+29
   \        0x6   0x.... 0x....      B.W      __aeabi_memclr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable115:
   \        0x0   0x0400'0303        DC32     0x4000303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116:
   \        0x0   0x2004'0000        DC32     0x20040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_1:
   \        0x0   0x0405'0000        DC32     0x4050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable117:
   \        0x0   0x0406'0000        DC32     0x4060000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118:
   \        0x0   0x0406'0001        DC32     0x4060001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118_1:
   \        0x0   0x0405'0001        DC32     0x4050001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119:
   \        0x0   0x0405'0003        DC32     0x4050003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_1:
   \        0x0   0x0406'0003        DC32     0x4060003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122:
   \        0x0   0x0406'0002        DC32     0x4060002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122_1:
   \        0x0   0x0405'0002        DC32     0x4050002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122_2:
   \        0x0   0x0404'0000        DC32     0x4040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123:
   \        0x0   0x0400'0203        DC32     0x4000203

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine49: (+1)
   \        0x0   0x2120             MOVS     R1,#+32
   \        0x2   0xF106 0x0010      ADD      R0,R6,#+16
   \        0x6   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine47: (+1)
   \        0x0   0xF106 0x0030      ADD      R0,R6,#+48
   \        0x4   0x.... 0x....      B.W      __aeabi_memcpy

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine44: (+1)
   \        0x0   0x4629             MOV      R1,R5
   \        0x2   0xF103 0x0030      ADD      R0,R3,#+48
   \        0x6   0x.... 0x....      B.W      __aeabi_memcpy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable124:
   \        0x0   0x0302'0200        DC32     0x3020200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable124_1:
   \        0x0   0x0302'0300        DC32     0x3020300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable124_2:
   \        0x0   0x0302'0400        DC32     0x3020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable124_3:
   \        0x0   0x0302'0500        DC32     0x3020500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable125:
   \        0x0   0x0302'0600        DC32     0x3020600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable125_1:
   \        0x0   0x2000'000C        DC32     0x2000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable125_2:
   \        0x0   0x0402'0000        DC32     0x4020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127:
   \        0x0   0x0403'0000        DC32     0x4030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_1:
   \        0x0   0x0403'0001        DC32     0x4030001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_2:
   \        0x0   0x0402'0001        DC32     0x4020001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_3:
   \        0x0   0x2000'0020        DC32     0x20000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_4:
   \        0x0   0x0402'0000        DC32     0x4020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_5:
   \        0x0   0x0C02'0000        DC32     0xc020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_6:
   \        0x0   0x0C03'0000        DC32     0xc030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_7:
   \        0x0   0x0C01'0000        DC32     0xc010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_8:
   \        0x0   0x0C04'0000        DC32     0xc040000
   2879          #endif
   2880          
   2881          /** @} (end addtogroup sl_se) */
   2882          
   2883          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   memcmp_time_cst
     112   sl_se_aes_crypt_cbc
       112   -> SE_addDataInput
       112   -> SE_addDataOutput
       112   -> SE_addParameter
       112   -> sli_se_execute_and_wait
       112   -> sli_se_get_auth_buffer
       112   -> sli_se_get_key_input_output
       112   -> sli_se_key_to_keyspec
     120   sl_se_aes_crypt_cfb128
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sl_se_aes_crypt_ecb
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
      64   sl_se_aes_crypt_cfb8
        64   -> __aeabi_memcpy
        64   -> sl_se_aes_crypt_ecb
     128   sl_se_aes_crypt_ctr
       128   -> SE_addDataInput
       128   -> SE_addDataOutput
       128   -> SE_addParameter
       128   -> sl_se_aes_crypt_ecb
       128   -> sli_se_execute_and_wait
       128   -> sli_se_get_auth_buffer
       128   -> sli_se_get_key_input_output
       128   -> sli_se_key_to_keyspec
      72   sl_se_aes_crypt_ecb
        72   -> SE_addDataInput
        72   -> SE_addDataOutput
        72   -> SE_addParameter
        72   -> sli_se_execute_and_wait
        72   -> sli_se_get_auth_buffer
        72   -> sli_se_get_key_input_output
        72   -> sli_se_key_to_keyspec
     128   sl_se_ccm_auth_decrypt
       128   -> SE_addDataInput
       128   -> SE_addDataOutput
       128   -> SE_addParameter
       128   -> __aeabi_memclr
       128   -> sli_se_execute_and_wait
       128   -> sli_se_get_auth_buffer
       128   -> sli_se_get_key_input_output
       128   -> sli_se_key_to_keyspec
     120   sl_se_ccm_encrypt_and_tag
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     104   sl_se_ccm_multipart_finish
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> __aeabi_memclr
       104   -> __aeabi_memcpy
       104   -> memcmp_time_cst
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec
     112   sl_se_ccm_multipart_starts
       112   -> SE_addDataInput
       112   -> SE_addDataOutput
       112   -> SE_addParameter
       112   -> __aeabi_memclr
       112   -> __aeabi_memclr4
       112   -> __aeabi_memcpy
       112   -> sli_se_execute_and_wait
       112   -> sli_se_get_auth_buffer
       112   -> sli_se_get_key_input_output
       112   -> sli_se_key_to_keyspec
     120   sl_se_ccm_multipart_update
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> __aeabi_memclr
       120   -> __aeabi_memcpy
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     104   sl_se_chacha20_crypt
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec
     120   sl_se_chacha20_poly1305_auth_decrypt
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
     120   sl_se_chacha20_poly1305_encrypt_and_tag
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
      72   sl_se_cmac
        72   -> SE_addDataInput
        72   -> SE_addDataOutput
        72   -> SE_addParameter
        72   -> sli_se_execute_and_wait
        72   -> sli_se_get_auth_buffer
        72   -> sli_se_get_key_input_output
        72   -> sli_se_key_to_keyspec
     104   sl_se_cmac_multipart_finish
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sl_se_aes_crypt_ecb
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec
       8   sl_se_cmac_multipart_starts
         8   -> __aeabi_memclr4
     136   sl_se_cmac_multipart_update
       136   -> SE_addDataInput
       136   -> SE_addDataOutput
       136   -> SE_addParameter
       136   -> __aeabi_memcpy
       136   -> sli_se_execute_and_wait
       136   -> sli_se_get_auth_buffer
       136   -> sli_se_get_key_input_output
       136   -> sli_se_key_to_keyspec
     128   sl_se_gcm_auth_decrypt
       128   -> SE_addDataInput
       128   -> SE_addDataOutput
       128   -> SE_addParameter
       128   -> __aeabi_memclr
       128   -> sli_se_execute_and_wait
       128   -> sli_se_get_auth_buffer
       128   -> sli_se_get_key_input_output
       128   -> sli_se_key_to_keyspec
     152   sl_se_gcm_crypt_and_tag
       152   -> SE_addDataInput
       152   -> SE_addDataOutput
       152   -> SE_addParameter
       152   -> __aeabi_memclr
       152   -> __aeabi_memcpy
       152   -> sli_se_execute_and_wait
       152   -> sli_se_get_auth_buffer
       152   -> sli_se_get_key_input_output
       152   -> sli_se_key_to_keyspec
     152   sl_se_gcm_multipart_finish
       152   -> SE_addDataInput
       152   -> SE_addDataOutput
       152   -> SE_addParameter
       152   -> __aeabi_memclr
       152   -> sl_se_gcm_auth_decrypt
       152   -> sl_se_gcm_crypt_and_tag
       152   -> sli_se_execute_and_wait
       152   -> sli_se_get_auth_buffer
       152   -> sli_se_get_key_input_output
       152   -> sli_se_key_to_keyspec
      96   sl_se_gcm_multipart_starts
        96   -> SE_addDataInput
        96   -> SE_addDataOutput
        96   -> SE_addParameter
        96   -> __aeabi_memclr4
        96   -> __aeabi_memcpy
        96   -> sli_se_execute_and_wait
        96   -> sli_se_get_auth_buffer
        96   -> sli_se_get_key_input_output
        96   -> sli_se_key_to_keyspec
     120   sl_se_gcm_multipart_update
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> __aeabi_memclr4
       120   -> __aeabi_memcpy
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
      80   sl_se_hmac
        80   -> SE_addDataInput
        80   -> SE_addDataOutput
        80   -> SE_addParameter
        80   -> sli_se_execute_and_wait
        80   -> sli_se_get_auth_buffer
        80   -> sli_se_get_key_input_output
        80   -> sli_se_key_to_keyspec
      88   sl_se_poly1305_genkey_tag
        88   -> SE_addDataInput
        88   -> SE_addDataOutput
        88   -> SE_addParameter
        88   -> sli_se_execute_and_wait
        88   -> sli_se_get_auth_buffer
        88   -> sli_se_get_key_input_output
        88   -> sli_se_key_to_keyspec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable112
       4  ??DataTable112_1
       4  ??DataTable112_2
       4  ??DataTable112_3
       4  ??DataTable113
       4  ??DataTable113_1
       4  ??DataTable115
       4  ??DataTable116
       4  ??DataTable116_1
       4  ??DataTable117
       4  ??DataTable118
       4  ??DataTable118_1
       4  ??DataTable119
       4  ??DataTable119_1
       4  ??DataTable122
       4  ??DataTable122_1
       4  ??DataTable122_2
       4  ??DataTable123
       4  ??DataTable124
       4  ??DataTable124_1
       4  ??DataTable124_2
       4  ??DataTable124_3
       4  ??DataTable125
       4  ??DataTable125_1
       4  ??DataTable125_2
       4  ??DataTable127
       4  ??DataTable127_1
       4  ??DataTable127_2
       4  ??DataTable127_3
       4  ??DataTable127_4
       4  ??DataTable127_5
       4  ??DataTable127_6
       4  ??DataTable127_7
       4  ??DataTable127_8
       8  ??Subroutine51_0
       6  ?Subroutine0
       6  ?Subroutine1
      12  ?Subroutine10
       8  ?Subroutine11
       8  ?Subroutine12
       8  ?Subroutine13
      10  ?Subroutine14
       8  ?Subroutine15
       8  ?Subroutine16
       8  ?Subroutine17
      12  ?Subroutine18
       8  ?Subroutine19
       6  ?Subroutine2
      12  ?Subroutine20
       8  ?Subroutine21
       6  ?Subroutine22
       6  ?Subroutine23
       8  ?Subroutine24
       8  ?Subroutine25
       8  ?Subroutine26
       8  ?Subroutine27
       8  ?Subroutine28
       8  ?Subroutine29
       6  ?Subroutine3
       8  ?Subroutine30
       6  ?Subroutine31
      10  ?Subroutine32
       6  ?Subroutine33
      16  ?Subroutine34
       8  ?Subroutine35
       8  ?Subroutine36
       8  ?Subroutine37
       6  ?Subroutine38
       8  ?Subroutine39
       6  ?Subroutine4
       6  ?Subroutine40
       6  ?Subroutine41
      26  ?Subroutine42
      12  ?Subroutine43
      10  ?Subroutine44
      14  ?Subroutine45
      12  ?Subroutine46
       8  ?Subroutine47
      10  ?Subroutine48
      10  ?Subroutine49
       6  ?Subroutine5
      16  ?Subroutine50
      18  ?Subroutine6
      14  ?Subroutine7
      14  ?Subroutine8
      12  ?Subroutine9
      12  ?_0
      12  ?_1
      12  ?_10
      12  ?_100
      12  ?_101
      12  ?_102
      12  ?_103
      12  ?_104
      12  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      12  ?_2
      12  ?_20
      12  ?_21
      12  ?_22
      12  ?_23
      12  ?_24
      12  ?_25
      12  ?_26
      12  ?_27
      12  ?_28
      12  ?_29
      12  ?_3
      12  ?_30
      12  ?_31
      12  ?_32
      12  ?_33
      12  ?_34
      12  ?_35
      12  ?_36
      12  ?_37
      12  ?_38
      12  ?_39
      12  ?_4
      12  ?_40
      12  ?_41
      12  ?_42
      12  ?_43
      12  ?_44
      12  ?_45
      12  ?_46
      12  ?_47
      12  ?_48
      12  ?_49
      12  ?_5
      12  ?_50
      12  ?_51
      12  ?_52
      12  ?_53
      12  ?_54
      12  ?_55
      12  ?_56
      12  ?_57
      12  ?_58
      12  ?_59
      12  ?_6
      12  ?_60
      12  ?_61
      12  ?_62
      12  ?_63
      12  ?_64
      12  ?_65
      12  ?_66
      12  ?_67
      12  ?_68
      12  ?_69
      12  ?_7
      12  ?_70
      12  ?_71
      12  ?_72
      12  ?_73
      12  ?_74
      12  ?_75
      12  ?_76
      12  ?_77
      12  ?_78
      12  ?_79
      12  ?_8
      12  ?_80
      12  ?_81
      12  ?_82
      12  ?_83
      12  ?_84
      12  ?_85
      12  ?_86
      12  ?_87
      12  ?_88
      12  ?_89
      12  ?_9
      12  ?_90
      12  ?_91
      12  ?_92
      12  ?_93
      12  ?_94
      12  ?_95
      12  ?_96
      12  ?_97
      12  ?_98
      12  ?_99
      30  memcmp_time_cst
     218  sl_se_aes_crypt_cbc
     444  sl_se_aes_crypt_cfb128
     136  sl_se_aes_crypt_cfb8
     350  sl_se_aes_crypt_ctr
     144  sl_se_aes_crypt_ecb
     392  sl_se_ccm_auth_decrypt
     356  sl_se_ccm_encrypt_and_tag
     364  sl_se_ccm_multipart_finish
     524  sl_se_ccm_multipart_starts
     734  sl_se_ccm_multipart_update
     236  sl_se_chacha20_crypt
     310  sl_se_chacha20_poly1305_auth_decrypt
     306  sl_se_chacha20_poly1305_encrypt_and_tag
     146  sl_se_cmac
     270  sl_se_cmac_multipart_finish
      38  sl_se_cmac_multipart_starts
     390  sl_se_cmac_multipart_update
     354  sl_se_gcm_auth_decrypt
     592  sl_se_gcm_crypt_and_tag
     606  sl_se_gcm_multipart_finish
     290  sl_se_gcm_multipart_starts
     812  sl_se_gcm_multipart_update
     214  sl_se_hmac
     200  sl_se_poly1305_genkey_tag

 
 10'338 bytes in section .text
 
 10'338 bytes of CODE memory

Errors: none
Warnings: none
