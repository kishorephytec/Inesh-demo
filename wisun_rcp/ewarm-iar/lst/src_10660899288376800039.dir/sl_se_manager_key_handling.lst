###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:16:57
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_key_handling.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_key_handling.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_key_handling.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_key_handling.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir\sl_se_manager_key_handling.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_key_handling.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_key_handling.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager key handling.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include <string.h>
     32          #include "sl_se_manager.h"
     33          
     34          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
     35          
     36          #include "sli_se_manager_internal.h"
     37          #include "sl_se_manager_key_handling.h"
     38          
     39          /***************************************************************************//**
     40           * \addtogroup sl_se_key SE key handling API
     41           * @{
     42           ******************************************************************************/
     43          
     44          // -----------------------------------------------------------------------------
     45          // Defines
     46          
     47          #define KEYSPEC_TYPE_MASK                   0xf0000000
     48          #define KEYSPEC_TYPE_OFFSET                 28
     49          #define KEYSPEC_TYPE_RAW                    (uint32_t)(0x0UL << KEYSPEC_TYPE_OFFSET)
     50          
     51          #define KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME  (uint32_t)(0x8UL << KEYSPEC_TYPE_OFFSET)
     52          
     53          #define KEYSPEC_MODE_MASK                   0x0c000000
     54          #define KEYSPEC_MODE_OFFSET                 26
     55          #define KEYSPEC_MODE_UNPROTECTED            (0UL << KEYSPEC_MODE_OFFSET)
     56          #define KEYSPEC_MODE_VOLATILE               (1UL << KEYSPEC_MODE_OFFSET)
     57          
     58          #define KEYSPEC_RESTRICTION_MASK            0x03000000U
     59          #define KEYSPEC_RESTRICTION_OFFSET          24U
     60          
     61          #define KEYSPEC_RESTRICTION_UNLOCKED        (0U << KEYSPEC_RESTRICTION_OFFSET)
     62          
     63          #define KEYSPEC_INDEX_MASK                  0x00ff0000U
     64          #define KEYSPEC_INDEX_OFFSET                16U
     65          
     66          #define KEYSPEC_TRANSFER_MODE_MASK          0x00000300U
     67          #define KEYSPEC_TRANSFER_MODE_OFFSET        8U
     68          #define KEYSPEC_TRANSFER_INDEX_MASK         0x000000ffU
     69          #define KEYSPEC_TRANSFER_INDEX_OFFSET       0U
     70          #define KEYSPEC_TRANSFER_PROT_BIT_MASK      0xffe00000U
     71          #define KEYSPEC_TRANSFER_PROT_BIT_OFFSET    21U
     72          
     73          #define KEYSPEC_NOPROT_MASK                 0x00008000U
     74          #define KEYSPEC_NOPROT_OFFSET               15U
     75          
     76          #define KEYSPEC_ATTRIBUTES_MASK             0x00007fffU
     77          #define KEYSPEC_ATTRIBUTES_OFFSET           0U
     78          
     79          #define KEYSPEC_ATTRIBUTES_ECC_PRIVATE_MASK (1U << 14)
     80          #define KEYSPEC_ATTRIBUTES_ECC_PUBLIC_MASK  (1U << 13)
     81          #define KEYSPEC_ATTRIBUTES_ECC_DOMAIN       (1U << 12)
     82          #define KEYSPEC_ATTRIBUTES_ECC_SIGN         (1U << 10)
     83          #define KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK    0x0000007fU
     84          
     85          #define KEYSPEC_TYPE_ECC_EDWARDS    ((uint32_t)(0xaUL << KEYSPEC_TYPE_OFFSET))
     86          #define KEYSPEC_TYPE_ECC_MONTGOMERY ((uint32_t)(0xbUL << KEYSPEC_TYPE_OFFSET))
     87          #define KEYSPEC_TYPE_ECC_EDDSA      ((uint32_t)(0xcUL << KEYSPEC_TYPE_OFFSET))
     88          
     89          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
     90          
     91            #define KEYSPEC_MODE_WRAPPED \
     92            (2UL << KEYSPEC_MODE_OFFSET)
     93          
     94            #define KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_ZERO \
     95            (1U << 9)
     96            #define KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_MINUS_THREE \
     97            (1U << 8)
     98          
     99          #endif
    100          
    101          #define KEYSPEC_RESTRICTION_LOCKED          (1UL << KEYSPEC_RESTRICTION_OFFSET)
    102          #define KEYSPEC_RESTRICTION_INTERNAL        (2UL << KEYSPEC_RESTRICTION_OFFSET)
    103          #define KEYSPEC_RESTRICTION_RESTRICTED      (3UL << KEYSPEC_RESTRICTION_OFFSET)
    104          
    105          // -----------------------------------------------------------------------------
    106          // Local Functions
    107          

   \                                 In section .text, align 2, keep-with-next
    108          sl_status_t sli_key_get_storage_size(const sl_se_key_descriptor_t* key,
    109                                               uint32_t *storage_size)
    110          {
   \                     sli_key_get_storage_size: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    111            if (key == NULL || storage_size == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2D00             CMPNE    R5,#+0
   \        0xA   0xD034             BEQ.N    ??sli_key_get_storage_size_0
    112              return SL_STATUS_INVALID_PARAMETER;
    113            }
    114          
    115            uint32_t key_size = 0;
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x9200             STR      R2,[SP, #+0]
    116            sl_status_t status = sli_key_get_size(key, &key_size);
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x.... 0x....      BL       sli_key_get_size
    117            if (status != SL_STATUS_OK) {
   \       0x16   0xB9E0             CBNZ.N   R0,??sli_key_get_storage_size_1
    118              return status;
    119            }
    120          
    121            uint32_t key_type = (key->type & KEYSPEC_TYPE_MASK);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
    122          
    123            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    124            // Round up to word length
    125            key_size = (key_size + 3U) & ~0x03U;
    126            #endif
    127          
    128            if (key_type == KEYSPEC_TYPE_RAW) {
   \       0x1E   0xD102             BNE.N    ??sli_key_get_storage_size_2
    129              *storage_size = key_size;
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0x6028             STR      R0,[R5, #+0]
    130              return SL_STATUS_OK;
   \       0x24   0xE014             B.N      ??sli_key_get_storage_size_3
    131            }
    132          
    133            bool has_private_key =
    134              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY) != 0);
   \                     ??sli_key_get_storage_size_2: (+1)
   \       0x26   0x68A2             LDR      R2,[R4, #+8]
   \       0x28   0x0B91             LSRS     R1,R2,#+14
   \       0x2A   0xF001 0x0101      AND      R1,R1,#0x1
    135            bool has_public_key =
    136              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY) != 0);
   \       0x2E   0x0B54             LSRS     R4,R2,#+13
    137          
    138            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    139            bool has_custom_curve =
    140              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) != 0);
   \       0x30   0x0B12             LSRS     R2,R2,#+12
   \       0x32   0xF004 0x0401      AND      R4,R4,#0x1
   \       0x36   0xF002 0x0201      AND      R2,R2,#0x1
    141            #else
    142            bool has_custom_curve = false;
    143            #endif
    144          
    145            if ((key_type == KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME)) {
   \       0x3A   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \       0x3E   0xD109             BNE.N    ??sli_key_get_storage_size_4
    146              *storage_size = key_size * (1 * has_private_key + 2 * has_public_key + 6 * has_custom_curve);
   \       0x40   0xEB01 0x0144      ADD      R1,R1,R4, LSL #+1
   \       0x44   0x2006             MOVS     R0,#+6
   \       0x46   0x9B00             LDR      R3,[SP, #+0]
   \       0x48   0xFB10 0x1102      SMLABB   R1,R0,R2,R1
   \       0x4C   0x4359             MULS     R1,R1,R3
    147            } else if (key_type == KEYSPEC_TYPE_ECC_EDWARDS) {
    148              *storage_size = key_size * (has_private_key + has_public_key + 5 * has_custom_curve);
    149            } else if ((key_type == KEYSPEC_TYPE_ECC_MONTGOMERY)
    150                       || (key_type == KEYSPEC_TYPE_ECC_EDDSA)) {
    151              *storage_size = key_size * (has_private_key + has_public_key);
    152            } else {
    153              return SL_STATUS_INVALID_PARAMETER;
    154            }
    155          
    156            return SL_STATUS_OK;
   \                     ??sli_key_get_storage_size_5: (+1)
   \       0x4E   0x6029             STR      R1,[R5, #+0]
   \                     ??sli_key_get_storage_size_3: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \                     ??sli_key_get_storage_size_1: (+1)
   \       0x52   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??sli_key_get_storage_size_4: (+1)
   \       0x54   0x1861             ADDS     R1,R4,R1
   \       0x56   0xF1B0 0x4F20      CMP      R0,#+2684354560
   \       0x5A   0xD105             BNE.N    ??sli_key_get_storage_size_6
   \       0x5C   0xEB02 0x0282      ADD      R2,R2,R2, LSL #+2
   \       0x60   0x9800             LDR      R0,[SP, #+0]
   \       0x62   0x1851             ADDS     R1,R2,R1
   \                     ??sli_key_get_storage_size_7: (+1)
   \       0x64   0x4341             MULS     R1,R1,R0
   \       0x66   0xE7F2             B.N      ??sli_key_get_storage_size_5
   \                     ??sli_key_get_storage_size_6: (+1)
   \       0x68   0xF1B0 0x4F30      CMP      R0,#+2952790016
   \       0x6C   0xBF14             ITE      NE
   \       0x6E   0xF1B0 0x4F40      CMPNE    R0,#+3221225472
   \       0x72   0x9800             LDREQ    R0,[SP, #+0]
   \       0x74   0xD0F6             BEQ.N    ??sli_key_get_storage_size_7
   \                     ??sli_key_get_storage_size_0: (+1)
   \       0x76   0x2021             MOVS     R0,#+33
   \       0x78   0xBD32             POP      {R1,R4,R5,PC}
    157          }
    158          
    159          #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    160          /***************************************************************************//**
    161           * @brief
    162           *   Clear the additional bytes of a key that is not word-aligned.
    163           *   Does nothing for aligned or asymmetric keys, or non-plaintext keys.
    164           *
    165           * @param key
    166           *   Key descriptor for the key.
    167           *
    168           * @returns
    169           *   Status code, @ref sl_status.h.
    170           ******************************************************************************/
    171          static sl_status_t clear_padding(const sl_se_key_descriptor_t *key)
    172          {
    173            if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT
    174                && (key->type & KEYSPEC_TYPE_MASK) == KEYSPEC_TYPE_RAW) {
    175              uint32_t key_size = 0;
    176              if (sli_key_get_size(key, &key_size) != SL_STATUS_OK) {
    177                return SL_STATUS_INVALID_PARAMETER;
    178              }
    179              if (key_size & 0x03) {
    180                if (key_size > key->storage.location.buffer.size) {
    181                  return SL_STATUS_WOULD_OVERFLOW;
    182                }
    183                uint8_t *padding_ptr = key->storage.location.buffer.pointer + key_size;
    184                uint32_t padding_size = (key->storage.location.buffer.size - key_size) & 0x3;
    185                memset(padding_ptr, 0, padding_size);
    186              }
    187            }
    188            return SL_STATUS_OK;
    189          }
    190          #endif
    191          
    192          // -----------------------------------------------------------------------------
    193          // Global Functions
    194          

   \                                 In section .text, align 2, keep-with-next
    195          sl_status_t sli_key_get_size(const sl_se_key_descriptor_t *key, uint32_t *size)
    196          {
   \                     sli_key_get_size: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    197            if (key == NULL || size == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD025             BEQ.N    ??sli_key_get_size_0
    198              return SL_STATUS_INVALID_PARAMETER;
    199            }
    200          
    201            // Find size from key_type
    202            uint32_t key_type = (key->type & KEYSPEC_TYPE_MASK);
   \        0xA   0x6803             LDR      R3,[R0, #+0]
   \        0xC   0xF013 0x4270      ANDS     R2,R3,#0xF0000000
    203            if (key_type == KEYSPEC_TYPE_RAW) {
   \       0x10   0xBF08             IT       EQ
   \       0x12   0xF3C3 0x030E      UBFXEQ   R3,R3,#+0,#+15
    204              *size = (key->type & KEYSPEC_ATTRIBUTES_MASK);
   \       0x16   0xD019             BEQ.N    ??sli_key_get_size_1
    205            } else if ((key_type == KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME)
    206                       || (key_type == KEYSPEC_TYPE_ECC_EDWARDS)
    207                       || (key_type == KEYSPEC_TYPE_ECC_MONTGOMERY)
    208                       || (key_type == KEYSPEC_TYPE_ECC_EDDSA)) {
   \       0x18   0xF1B2 0x4F00      CMP      R2,#+2147483648
   \       0x1C   0xBF18             IT       NE
   \       0x1E   0xF1B2 0x4F20      CMPNE    R2,#+2684354560
   \       0x22   0xD005             BEQ.N    ??sli_key_get_size_2
   \       0x24   0xF1B2 0x4F30      CMP      R2,#+2952790016
   \       0x28   0xBF18             IT       NE
   \       0x2A   0xF1B2 0x4F40      CMPNE    R2,#+3221225472
   \       0x2E   0xD112             BNE.N    ??sli_key_get_size_0
    209          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    210              bool has_custom_curve =
    211                ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) != 0);
    212          #endif
    213          
    214          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    215              if (has_custom_curve) {
   \                     ??sli_key_get_size_2: (+1)
   \       0x30   0x6884             LDR      R4,[R0, #+8]
   \       0x32   0x04E2             LSLS     R2,R4,#+19
   \       0x34   0xD508             BPL.N    ??sli_key_get_size_3
    216                if (key->domain == NULL) {
   \       0x36   0x69C2             LDR      R2,[R0, #+28]
   \       0x38   0xB16A             CBZ.N    R2,??sli_key_get_size_0
    217                  return SL_STATUS_INVALID_PARAMETER;
    218                }
    219                if (key->type & SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM) {
   \       0x3A   0x2B00             CMP      R3,#+0
   \       0x3C   0xD502             BPL.N    ??sli_key_get_size_4
    220                  sl_se_custom_weierstrass_prime_domain_t *domain = (sl_se_custom_weierstrass_prime_domain_t*)key->domain;
    221                  *size = domain->size;
   \       0x3E   0x6812             LDR      R2,[R2, #+0]
   \       0x40   0x600A             STR      R2,[R1, #+0]
   \       0x42   0xE004             B.N      ??sli_key_get_size_5
    222                } else {
    223                  return SL_STATUS_NOT_SUPPORTED;
   \                     ??sli_key_get_size_4: (+1)
   \       0x44   0x200F             MOVS     R0,#+15
   \       0x46   0xBD10             POP      {R4,PC}
    224                }
    225              } else
    226          #endif
    227              {
    228                *size = (key->type & KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK);
   \                     ??sli_key_get_size_3: (+1)
   \       0x48   0xF003 0x037F      AND      R3,R3,#0x7F
   \                     ??sli_key_get_size_1: (+1)
   \       0x4C   0x600B             STR      R3,[R1, #+0]
    229              }
    230            } else {
    231              return SL_STATUS_INVALID_PARAMETER;
    232            }
    233          
    234          // If the key type didn't contain a size, use the one in the dedicated size
    235          // field
    236            if (*size == 0) {
   \                     ??sli_key_get_size_5: (+1)
   \       0x4E   0x680A             LDR      R2,[R1, #+0]
   \       0x50   0xB922             CBNZ.N   R2,??sli_key_get_size_6
    237              if (key->size == 0) {
   \       0x52   0x6840             LDR      R0,[R0, #+4]
   \       0x54   0xB908             CBNZ.N   R0,??sli_key_get_size_7
    238                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_get_size_0: (+1)
   \       0x56   0x2021             MOVS     R0,#+33
   \       0x58   0xBD10             POP      {R4,PC}
    239              }
    240              *size = key->size;
   \                     ??sli_key_get_size_7: (+1)
   \       0x5A   0x6008             STR      R0,[R1, #+0]
    241            }
    242          
    243            return SL_STATUS_OK;
   \                     ??sli_key_get_size_6: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xBD10             POP      {R4,PC}
    244          }
    245          

   \                                 In section .text, align 2, keep-with-next
    246          sl_status_t sli_key_check_equivalent(const sl_se_key_descriptor_t *key_1,
    247                                               const sl_se_key_descriptor_t *key_2,
    248                                               bool check_key_flag,
    249                                               bool public_export)
    250          {
   \                     sli_key_check_equivalent: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0x461E             MOV      R6,R3
    251            sl_status_t status;
    252          
    253            if (key_1 == NULL || key_2 == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2C00             CMPNE    R4,#+0
   \        0xE   0xD049             BEQ.N    ??sli_key_check_equivalent_0
    254              return SL_STATUS_INVALID_PARAMETER;
    255            }
    256          
    257            if (key_1->type != key_2->type) {
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6829             LDR      R1,[R5, #+0]
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD01E             BEQ.N    ??sli_key_check_equivalent_1
    258              // The type fields are different, but this may be due to one of the keys
    259              // not containing the size in the type, but rather in the size field.
    260              if (((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    261                   == SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM)
    262                  || ((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    263                      == SL_SE_KEY_TYPE_ECC_EDDSA)) {
   \       0x18   0xF001 0x4370      AND      R3,R1,#0xF0000000
   \       0x1C   0xF1B3 0x4F00      CMP      R3,#+2147483648
   \       0x20   0xBF1C             ITT      NE
   \       0x22   0xF001 0x4270      ANDNE    R2,R1,#0xF0000000
   \       0x26   0xF1B2 0x4F40      CMPNE    R2,#+3221225472
   \       0x2A   0xD13B             BNE.N    ??sli_key_check_equivalent_0
    264                if ((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    265                    == (key_2->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)) {
   \       0x2C   0xF001 0x4170      AND      R1,R1,#0xF0000000
   \       0x30   0xF000 0x4070      AND      R0,R0,#0xF0000000
   \       0x34   0x4281             CMP      R1,R0
   \       0x36   0xD10E             BNE.N    ??sli_key_check_equivalent_1
    266                  // Assume that the sizes are equal for now (this will be checked later)
    267                  uint32_t key_size = 0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x9000             STR      R0,[SP, #+0]
    268                  if (sli_key_get_size(key_1, &key_size) == SL_STATUS_OK) {
   \       0x3C   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD12F             BNE.N    ??sli_key_check_equivalent_0
    269                    // Add the key sizes to both key types, and check for equality then
    270                    sl_se_key_type_t type_1 = key_1->type | (SL_SE_KEY_TYPE_ATTRIBUTES_MASK & key_size);
    271                    sl_se_key_type_t type_2 = key_2->type | (SL_SE_KEY_TYPE_ATTRIBUTES_MASK & key_size);
    272                    if (type_1 != type_2) {
   \       0x44   0x9A00             LDR      R2,[SP, #+0]
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0xF3C2 0x020E      UBFX     R2,R2,#+0,#+15
   \       0x4E   0x4310             ORRS     R0,R2,R0
   \       0x50   0x430A             ORRS     R2,R2,R1
   \       0x52   0x4290             CMP      R0,R2
   \       0x54   0xD126             BNE.N    ??sli_key_check_equivalent_0
    273                      return SL_STATUS_INVALID_PARAMETER;
    274                    }
    275                  } else {
    276                    return SL_STATUS_INVALID_PARAMETER;
    277                  }
    278                }
    279              } else {
    280                return SL_STATUS_INVALID_PARAMETER;
    281              }
    282            }
    283          
    284            // Verify asymmetry flags
    285            if ((key_1->type & SL_SE_KEY_TYPE_ALGORITHM_MASK)
    286                >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \                     ??sli_key_check_equivalent_1: (+1)
   \       0x56   0x6828             LDR      R0,[R5, #+0]
   \       0x58   0xF000 0x4070      AND      R0,R0,#0xF0000000
   \       0x5C   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \       0x60   0xD310             BCC.N    ??sli_key_check_equivalent_2
    287              uint32_t consistent_flags =
    288                (public_export) ? SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN
    289                : (SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY
    290                   | SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY
    291                   | SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN);
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xBF14             ITE      NE
   \       0x66   0xF44F 0x5180      MOVNE    R1,#+4096
   \       0x6A   0xF44F 0x41E0      MOVEQ    R1,#+28672
    292              if (check_key_flag && (key_1->flags & consistent_flags) ^ (key_2->flags & consistent_flags)) {
   \       0x6E   0x2F00             CMP      R7,#+0
   \       0x70   0xBF1F             ITTTT    NE
   \       0x72   0x68AA             LDRNE    R2,[R5, #+8]
   \       0x74   0x68A0             LDRNE    R0,[R4, #+8]
   \       0x76   0x4042             EORNE    R2,R0,R2
   \       0x78   0x4211             TSTNE    R1,R2
   \       0x7A   0xD113             BNE.N    ??sli_key_check_equivalent_0
    293                return SL_STATUS_INVALID_PARAMETER;
    294              }
    295          
    296              if (public_export
    297                  && (!(key_2->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY))) {
   \       0x7C   0xB116             CBZ.N    R6,??sli_key_check_equivalent_2
   \       0x7E   0x68A1             LDR      R1,[R4, #+8]
   \       0x80   0x0488             LSLS     R0,R1,#+18
   \       0x82   0xD50F             BPL.N    ??sli_key_check_equivalent_0
    298                return SL_STATUS_INVALID_PARAMETER;
    299              }
    300            }
    301          
    302            // Verify key sizes
    303            uint32_t key_1_size = 0;
   \                     ??sli_key_check_equivalent_2: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x9001             STR      R0,[SP, #+4]
    304            status = sli_key_get_size(key_1, &key_1_size);
   \       0x88   0xA901             ADD      R1,SP,#+4
   \       0x8A   0x.... 0x....      BL       ??Subroutine8_0
    305            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x8E   0xB960             CBNZ.N   R0,??sli_key_check_equivalent_3
    306              return status;
    307            }
    308            uint32_t key_2_size = 0;
   \       0x90   0x9000             STR      R0,[SP, #+0]
    309            status = sli_key_get_size(key_2, &key_2_size);
   \       0x92   0x4669             MOV      R1,SP
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0x.... 0x....      BL       sli_key_get_size
    310            if (status != SL_STATUS_OK) {
   \       0x9A   0xB930             CBNZ.N   R0,??sli_key_check_equivalent_3
    311              return status;
    312            }
    313          
    314            if (key_1_size != key_2_size) {
   \       0x9C   0x9901             LDR      R1,[SP, #+4]
   \       0x9E   0x9800             LDR      R0,[SP, #+0]
   \       0xA0   0x4281             CMP      R1,R0
   \       0xA2   0xD001             BEQ.N    ??sli_key_check_equivalent_4
    315              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_key_check_equivalent_0: (+1)
   \       0xA4   0x2021             MOVS     R0,#+33
   \       0xA6   0xBDFE             POP      {R1-R7,PC}
    316            }
    317          
    318            return SL_STATUS_OK;
   \                     ??sli_key_check_equivalent_4: (+1)
   \       0xA8   0x2000             MOVS     R0,#+0
   \                     ??sli_key_check_equivalent_3: (+1)
   \       0xAA   0xBDFE             POP      {R1-R7,PC}
    319          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \                     ??Subroutine8_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....             B.N      sli_key_get_size
    320          
    321          /***************************************************************************//**
    322           * @brief
    323           *   Convert key descriptor struct to a 32-bit keyspec value to pass into an SE
    324           *   command.
    325           *
    326           * @return
    327           *   Status code, @ref sl_status.h.
    328           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    329          sl_status_t sli_se_key_to_keyspec(const sl_se_key_descriptor_t *key,
    330                                            uint32_t *keyspec)
    331          {
   \                     sli_se_key_to_keyspec: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x460E             MOV      R6,R1
    332            if (key == NULL || keyspec == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2E00             CMPNE    R6,#+0
   \        0xA   0xF000 0x80AF      BEQ.W    ??sli_se_key_to_keyspec_1
    333              return SL_STATUS_INVALID_PARAMETER;
    334            }
    335          
    336            // Clear output
    337            *keyspec = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x6030             STR      R0,[R6, #+0]
    338          
    339            // ---------------------
    340            // Key type [31-28]
    341          
    342            *keyspec = (key->type & KEYSPEC_TYPE_MASK);
   \       0x12   0x6829             LDR      R1,[R5, #+0]
   \       0x14   0xF001 0x4170      AND      R1,R1,#0xF0000000
   \       0x18   0x6031             STR      R1,[R6, #+0]
    343          
    344            // ---------------------
    345            // Key mode [27-26]
    346          
    347            switch (key->storage.method) {
   \       0x1A   0x68E8             LDR      R0,[R5, #+12]
   \       0x1C   0x2803             CMP      R0,#+3
   \       0x1E   0xD826             BHI.N    ??sli_se_key_to_keyspec_2
   \       0x20   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??sli_se_key_to_keyspec_0:
   \       0x24   0x08 0x02          DC8      0x8,0x2,0x5,0x5
   \              0x05 0x05
    348              case SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT:
    349                *keyspec |= KEYSPEC_MODE_UNPROTECTED;
    350                break;
    351          
    352          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    353              case SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED:
    354                *keyspec |= KEYSPEC_MODE_WRAPPED;
   \                     ??sli_se_key_to_keyspec_3: (+1)
   \       0x28   0xF041 0x6100      ORR      R1,R1,#0x8000000
   \       0x2C   0xE001             B.N      ??sli_se_key_to_keyspec_4
    355                break;
    356          
    357              case SL_SE_KEY_STORAGE_INTERNAL_VOLATILE:
    358                *keyspec |= KEYSPEC_MODE_VOLATILE;
    359                break;
    360          #endif
    361          
    362              case SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE:
    363                *keyspec |= KEYSPEC_MODE_VOLATILE;
   \                     ??sli_se_key_to_keyspec_5: (+1)
   \       0x2E   0xF041 0x6180      ORR      R1,R1,#0x4000000
   \                     ??sli_se_key_to_keyspec_4: (+1)
   \       0x32   0x6031             STR      R1,[R6, #+0]
    364                break;
    365          
    366              default:
    367                return SL_STATUS_INVALID_PARAMETER;
    368            }
    369          
    370            // ---------------------
    371            // Key restriction [25-24]
    372          
    373            uint32_t keyspec_restriction = 0;
    374            if (key->flags & SL_SE_KEY_FLAG_NON_EXPORTABLE) {
   \                     ??sli_se_key_to_keyspec_6: (+1)
   \       0x34   0x68A9             LDR      R1,[R5, #+8]
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x01CA             LSLS     R2,R1,#+7
   \       0x3A   0xBF48             IT       MI
   \       0x3C   0xF04F 0x7080      MOVMI    R0,#+16777216
    375              keyspec_restriction = KEYSPEC_RESTRICTION_LOCKED;
    376            }
    377            if (key->flags & SL_SE_KEY_FLAG_IS_DEVICE_GENERATED) {
   \       0x40   0x018A             LSLS     R2,R1,#+6
   \       0x42   0xBF48             IT       MI
   \       0x44   0xF04F 0x7000      MOVMI    R0,#+33554432
    378              keyspec_restriction = KEYSPEC_RESTRICTION_INTERNAL;
    379            }
    380            if ((key->flags & SL_SE_KEY_FLAG_IS_RESTRICTED) == SL_SE_KEY_FLAG_IS_RESTRICTED) {
   \       0x48   0xF001 0x7140      AND      R1,R1,#0x3000000
   \       0x4C   0xF1B1 0x7F40      CMP      R1,#+50331648
   \       0x50   0xBF08             IT       EQ
   \       0x52   0xF04F 0x7040      MOVEQ    R0,#+50331648
    381              keyspec_restriction = KEYSPEC_RESTRICTION_RESTRICTED;
    382            }
    383            // Key restrictions are only applicable to volatile and wrapped keys
    384            if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \       0x56   0x68E9             LDR      R1,[R5, #+12]
   \       0x58   0xB909             CBNZ.N   R1,??sli_se_key_to_keyspec_7
    385              if (keyspec_restriction != 0) {
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD162             BNE.N    ??sli_se_key_to_keyspec_8
    386                return SL_STATUS_INVALID_PARAMETER;
    387              }
    388            }
    389          
    390            *keyspec = (*keyspec & ~KEYSPEC_RESTRICTION_MASK)
    391                       | (keyspec_restriction & KEYSPEC_RESTRICTION_MASK);
   \                     ??sli_se_key_to_keyspec_7: (+1)
   \       0x5E   0x6832             LDR      R2,[R6, #+0]
   \       0x60   0x4310             ORRS     R0,R0,R2
   \       0x62   0x6030             STR      R0,[R6, #+0]
    392          
    393            // ---------------------
    394            // Key index [23-16]
    395          
    396          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    397            if (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE) {
   \       0x64   0x68E9             LDR      R1,[R5, #+12]
   \       0x66   0x2902             CMP      R1,#+2
   \       0x68   0xD107             BNE.N    ??sli_se_key_to_keyspec_9
    398              if (key->storage.location.slot > SL_SE_KEY_SLOT_VOLATILE_3) {
   \       0x6A   0x6929             LDR      R1,[R5, #+16]
   \       0x6C   0x2903             CMP      R1,#+3
   \                     ??sli_se_key_to_keyspec_2: (+1)
   \       0x6E   0xD87D             BHI.N    ??sli_se_key_to_keyspec_1
    399                return SL_STATUS_INVALID_PARAMETER;
    400              }
    401              *keyspec = (*keyspec & ~KEYSPEC_INDEX_MASK)
    402                         | ((key->storage.location.slot << KEYSPEC_INDEX_OFFSET)
    403                            & KEYSPEC_INDEX_MASK);
   \       0x70   0x0409             LSLS     R1,R1,#+16
   \       0x72   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \       0x76   0x4308             ORRS     R0,R1,R0
   \       0x78   0x6030             STR      R0,[R6, #+0]
    404            }
    405          #endif
    406          
    407            if (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE) {
   \                     ??sli_se_key_to_keyspec_9: (+1)
   \       0x7A   0x68E8             LDR      R0,[R5, #+12]
   \       0x7C   0x2803             CMP      R0,#+3
   \       0x7E   0xD106             BNE.N    ??sli_se_key_to_keyspec_10
    408              if (key->storage.location.slot
    409                  < SL_SE_KEY_SLOT_INTERNAL_MIN) {
   \       0x80   0x6929             LDR      R1,[R5, #+16]
   \       0x82   0x29F7             CMP      R1,#+247
   \       0x84   0xD372             BCC.N    ??sli_se_key_to_keyspec_1
    410                return SL_STATUS_INVALID_PARAMETER;
    411              }
    412              *keyspec = (*keyspec & ~KEYSPEC_INDEX_MASK)
    413                         | ((key->storage.location.slot << KEYSPEC_INDEX_OFFSET)
    414                            & KEYSPEC_INDEX_MASK);
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0xF361 0x4017      BFI      R0,R1,#+16,#+8
   \       0x8C   0x6030             STR      R0,[R6, #+0]
    415            }
    416          
    417            // ---------------------
    418            // Key NoProt [15]
    419          
    420            if (key->flags & SL_SE_KEY_FLAG_ALLOW_ANY_ACCESS) {
   \                     ??sli_se_key_to_keyspec_10: (+1)
   \       0x8E   0x68AA             LDR      R2,[R5, #+8]
   \       0x90   0x0411             LSLS     R1,R2,#+16
   \       0x92   0xD503             BPL.N    ??sli_se_key_to_keyspec_11
    421              *keyspec = (*keyspec & ~KEYSPEC_NOPROT_MASK) | (1 << KEYSPEC_NOPROT_OFFSET);
   \       0x94   0x6830             LDR      R0,[R6, #+0]
   \       0x96   0xF440 0x4000      ORR      R0,R0,#0x8000
   \       0x9A   0x6030             STR      R0,[R6, #+0]
    422            }
    423          
    424            // ---------------------
    425            // Key attributes [14-0]
    426          
    427            // Set general properties from key->type
    428            if (key->storage.method != SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE) {
   \                     ??sli_se_key_to_keyspec_11: (+1)
   \       0x9C   0x68E9             LDR      R1,[R5, #+12]
   \       0x9E   0x2903             CMP      R1,#+3
   \       0xA0   0xD005             BEQ.N    ??sli_se_key_to_keyspec_12
    429              *keyspec = (*keyspec & ~KEYSPEC_ATTRIBUTES_MASK)
    430                         | (key->type & KEYSPEC_ATTRIBUTES_MASK);
   \       0xA2   0x6829             LDR      R1,[R5, #+0]
   \       0xA4   0x6830             LDR      R0,[R6, #+0]
   \       0xA6   0xF3C1 0x010E      UBFX     R1,R1,#+0,#+15
   \       0xAA   0x4308             ORRS     R0,R1,R0
   \       0xAC   0x6030             STR      R0,[R6, #+0]
    431            }
    432          
    433            // Set public/private flags
    434            bool has_private_key =
    435              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY) != 0);
   \                     ??sli_se_key_to_keyspec_12: (+1)
   \       0xAE   0x68AC             LDR      R4,[R5, #+8]
    436            bool has_public_key =
    437              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY) != 0);
    438          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    439            bool has_custom_curve =
    440              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) != 0);
    441          #endif
    442            bool signing_only =
    443              ((key->flags & SL_SE_KEY_FLAG_ASYMMETRIC_SIGNING_ONLY) != 0);
    444          
    445            if ((key->type & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \       0xB0   0x682B             LDR      R3,[R5, #+0]
   \       0xB2   0x0BA0             LSRS     R0,R4,#+14
   \       0xB4   0x0B61             LSRS     R1,R4,#+13
   \       0xB6   0xF000 0x0001      AND      R0,R0,#0x1
   \       0xBA   0xF001 0x0101      AND      R1,R1,#0x1
   \       0xBE   0x0B27             LSRS     R7,R4,#+12
   \       0xC0   0x0AA4             LSRS     R4,R4,#+10
   \       0xC2   0xF003 0x4370      AND      R3,R3,#0xF0000000
   \       0xC6   0xF007 0x0701      AND      R7,R7,#0x1
   \       0xCA   0xF004 0x0401      AND      R4,R4,#0x1
   \       0xCE   0xEA41 0x0200      ORR      R2,R1,R0
   \       0xD2   0xF1B3 0x4F00      CMP      R3,#+2147483648
   \       0xD6   0xD311             BCC.N    ??sli_se_key_to_keyspec_13
    446              if (has_private_key) {
   \       0xD8   0xB118             CBZ.N    R0,??sli_se_key_to_keyspec_14
    447                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_PRIVATE_MASK;
   \       0xDA   0x6830             LDR      R0,[R6, #+0]
   \       0xDC   0xF440 0x4080      ORR      R0,R0,#0x4000
   \       0xE0   0x6030             STR      R0,[R6, #+0]
    448              }
    449              if (has_public_key) {
   \                     ??sli_se_key_to_keyspec_14: (+1)
   \       0xE2   0xB119             CBZ.N    R1,??sli_se_key_to_keyspec_15
    450                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_PUBLIC_MASK;
   \       0xE4   0x6830             LDR      R0,[R6, #+0]
   \       0xE6   0xF440 0x5000      ORR      R0,R0,#0x2000
   \       0xEA   0x6030             STR      R0,[R6, #+0]
    451              }
    452            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    453              if (has_custom_curve) {
   \                     ??sli_se_key_to_keyspec_15: (+1)
   \       0xEC   0x0038             MOVS     R0,R7
   \       0xEE   0xD003             BEQ.N    ??sli_se_key_to_keyspec_16
    454                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_DOMAIN;
   \       0xF0   0x6830             LDR      R0,[R6, #+0]
   \       0xF2   0xF440 0x5080      ORR      R0,R0,#0x1000
   \       0xF6   0x6030             STR      R0,[R6, #+0]
    455              }
    456            #endif
    457              if (!(has_private_key || has_public_key)) {
   \                     ??sli_se_key_to_keyspec_16: (+1)
   \       0xF8   0x0010             MOVS     R0,R2
   \       0xFA   0xD037             BEQ.N    ??sli_se_key_to_keyspec_1
    458                return SL_STATUS_INVALID_PARAMETER;
    459              }
    460            }
    461          
    462            if ((key->type & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME
    463                && (key->type & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_EDDSA) {
   \                     ??sli_se_key_to_keyspec_13: (+1)
   \       0xFC   0x6828             LDR      R0,[R5, #+0]
   \       0xFE   0xF000 0x4070      AND      R0,R0,#0xF0000000
   \      0x102   0xF100 0x4000      ADD      R0,R0,#+2147483648
   \      0x106   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \      0x10A   0xD204             BCS.N    ??sli_se_key_to_keyspec_17
    464              if (signing_only) {
   \      0x10C   0xB11C             CBZ.N    R4,??sli_se_key_to_keyspec_17
    465                *keyspec |= KEYSPEC_ATTRIBUTES_ECC_SIGN;
   \      0x10E   0x6830             LDR      R0,[R6, #+0]
   \      0x110   0xF440 0x6080      ORR      R0,R0,#0x400
   \      0x114   0x6030             STR      R0,[R6, #+0]
    466              }
    467            }
    468          
    469            // Ensure that symmetric keys don't have asymmetric flags
    470            if ((key->type & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \                     ??sli_se_key_to_keyspec_17: (+1)
   \      0x116   0x6829             LDR      R1,[R5, #+0]
   \      0x118   0xF001 0x4170      AND      R1,R1,#0xF0000000
   \      0x11C   0xF1B1 0x4F00      CMP      R1,#+2147483648
   \      0x120   0xD201             BCS.N    ??sli_se_key_to_keyspec_18
    471              if (has_private_key || has_public_key || signing_only) {
   \      0x122   0x4322             ORRS     R2,R4,R2
   \                     ??sli_se_key_to_keyspec_8: (+1)
   \      0x124   0xD122             BNE.N    ??sli_se_key_to_keyspec_1
    472                return SL_STATUS_INVALID_PARAMETER;
    473              }
    474            }
    475          
    476            // Set or adjust the key attributes for different key types
    477            uint32_t size = 0;
   \                     ??sli_se_key_to_keyspec_18: (+1)
   \      0x126   0x2200             MOVS     R2,#+0
   \      0x128   0x9200             STR      R2,[SP, #+0]
    478            sl_status_t status;
    479            status = sli_key_get_size(key, &size);
   \      0x12A   0x.... 0x....      BL       ?Subroutine8
    480            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_33: (+1)
   \      0x12E   0xBB98             CBNZ.N   R0,??sli_se_key_to_keyspec_19
    481              return status;
    482            }
    483          
    484            // Symmetric and raw keys
    485            uint32_t key_type = (key->type & KEYSPEC_TYPE_MASK);
   \      0x130   0x6828             LDR      R0,[R5, #+0]
   \      0x132   0xF010 0x4070      ANDS     R0,R0,#0xF0000000
    486            if (key_type == KEYSPEC_TYPE_RAW) {
   \      0x136   0xD104             BNE.N    ??sli_se_key_to_keyspec_20
    487              *keyspec = (*keyspec & ~KEYSPEC_ATTRIBUTES_MASK)
    488                         | (size & KEYSPEC_ATTRIBUTES_MASK);
   \      0x138   0x9A00             LDR      R2,[SP, #+0]
   \      0x13A   0x6831             LDR      R1,[R6, #+0]
   \      0x13C   0xF362 0x010E      BFI      R1,R2,#+0,#+15
   \      0x140   0xE010             B.N      ??sli_se_key_to_keyspec_21
    489            } else if ((key_type == KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME)
    490                       || (key_type == KEYSPEC_TYPE_ECC_EDWARDS)
    491                       || (key_type == KEYSPEC_TYPE_ECC_MONTGOMERY)
    492                       || (key_type == KEYSPEC_TYPE_ECC_EDDSA)) {
   \                     ??sli_se_key_to_keyspec_20: (+1)
   \      0x142   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x146   0xBF18             IT       NE
   \      0x148   0xF1B0 0x4F20      CMPNE    R0,#+2684354560
   \      0x14C   0xD005             BEQ.N    ??sli_se_key_to_keyspec_22
   \      0x14E   0xF1B0 0x4F30      CMP      R0,#+2952790016
   \      0x152   0xBF18             IT       NE
   \      0x154   0xF1B0 0x4F40      CMPNE    R0,#+3221225472
   \      0x158   0xD108             BNE.N    ??sli_se_key_to_keyspec_1
    493              *keyspec = (*keyspec & ~KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK)
    494                         | ((size - 1) & KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK);
   \                     ??sli_se_key_to_keyspec_22: (+1)
   \      0x15A   0x9A00             LDR      R2,[SP, #+0]
   \      0x15C   0x6831             LDR      R1,[R6, #+0]
   \      0x15E   0x1E52             SUBS     R2,R2,#+1
   \      0x160   0xF362 0x0106      BFI      R1,R2,#+0,#+7
   \                     ??sli_se_key_to_keyspec_21: (+1)
   \      0x164   0x6031             STR      R1,[R6, #+0]
    495            } else {
    496              return SL_STATUS_INVALID_PARAMETER;
    497            }
    498          
    499            // Custom domain
    500          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    501            if (has_custom_curve) {
   \      0x166   0xB1B7             CBZ.N    R7,??sli_se_key_to_keyspec_23
    502              if (key->domain == NULL) {
   \      0x168   0x69E9             LDR      R1,[R5, #+28]
   \      0x16A   0xB909             CBNZ.N   R1,??sli_se_key_to_keyspec_24
    503                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_key_to_keyspec_1: (+1)
   \      0x16C   0x2021             MOVS     R0,#+33
   \      0x16E   0xBDF2             POP      {R1,R4-R7,PC}
    504              }
    505              if (key_type == SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM) {
   \                     ??sli_se_key_to_keyspec_24: (+1)
   \      0x170   0xF1B0 0x4F00      CMP      R0,#+2147483648
   \      0x174   0xD111             BNE.N    ??sli_se_key_to_keyspec_25
    506                sl_se_custom_weierstrass_prime_domain_t *domain = (sl_se_custom_weierstrass_prime_domain_t*)key->domain;
    507                if (domain->a_is_zero && signing_only) {
   \      0x176   0x7F08             LDRB     R0,[R1, #+28]
   \      0x178   0xB120             CBZ.N    R0,??sli_se_key_to_keyspec_26
   \      0x17A   0xB164             CBZ.N    R4,??sli_se_key_to_keyspec_23
    508                  *keyspec |= KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_ZERO;
   \      0x17C   0x6830             LDR      R0,[R6, #+0]
   \      0x17E   0xF440 0x7000      ORR      R0,R0,#0x200
   \      0x182   0x6030             STR      R0,[R6, #+0]
    509                }
    510                if (domain->a_is_minus_three && signing_only) {
   \                     ??sli_se_key_to_keyspec_26: (+1)
   \      0x184   0x7F48             LDRB     R0,[R1, #+29]
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xBF18             IT       NE
   \      0x18A   0x2C00             CMPNE    R4,#+0
   \      0x18C   0xD003             BEQ.N    ??sli_se_key_to_keyspec_23
    511                  *keyspec |= KEYSPEC_ECC_WEIERSTRASS_PRIME_A_IS_MINUS_THREE;
   \      0x18E   0x6830             LDR      R0,[R6, #+0]
   \      0x190   0xF440 0x7080      ORR      R0,R0,#0x100
   \      0x194   0x6030             STR      R0,[R6, #+0]
    512                }
    513              } else {
    514                return SL_STATUS_NOT_SUPPORTED;
    515              }
    516            }
    517          #endif
    518          
    519            return SL_STATUS_OK;
   \                     ??sli_se_key_to_keyspec_23: (+1)
   \      0x196   0x2000             MOVS     R0,#+0
   \                     ??sli_se_key_to_keyspec_19: (+1)
   \      0x198   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??sli_se_key_to_keyspec_25: (+1)
   \      0x19A   0x200F             MOVS     R0,#+15
   \      0x19C   0xBDF2             POP      {R1,R4-R7,PC}
    520          }
    521          
    522          /***************************************************************************//**
    523           * @brief
    524           *   Convert a 32-bit SE compatible keyspec value to a key descriptor struct.
    525           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    526          sl_status_t sli_se_keyspec_to_key(const uint32_t keyspec,
    527                                            sl_se_key_descriptor_t* key)
    528          {
   \                     sli_se_keyspec_to_key: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x4602             MOV      R2,R0
   \        0x4   0x688D             LDR      R5,[R1, #+8]
    529            if (key == NULL) {
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD074             BEQ.N    ??sli_se_keyspec_to_key_0
    530              return SL_STATUS_INVALID_PARAMETER;
    531            }
    532          
    533            // Clear output
    534            key->type = 0;
   \        0xA   0x2400             MOVS     R4,#+0
   \        0xC   0x600C             STR      R4,[R1, #+0]
    535            key->storage.method = 0;
   \        0xE   0x60CC             STR      R4,[R1, #+12]
    536            key->storage.location.slot = 0;
   \       0x10   0x2300             MOVS     R3,#+0
    537            key->size = 0;
   \       0x12   0x604C             STR      R4,[R1, #+4]
   \       0x14   0x610B             STR      R3,[R1, #+16]
    538            key->flags = 0;
   \       0x16   0x2500             MOVS     R5,#+0
    539          
    540            // ---------------------
    541            // Key type [31-28]
    542            key->type = keyspec & KEYSPEC_TYPE_MASK;
   \       0x18   0xF002 0x4470      AND      R4,R2,#0xF0000000
   \       0x1C   0x600C             STR      R4,[R1, #+0]
    543          
    544            // ---------------------
    545            // Key mode [27-26] and key index [23-16]
    546          
    547            if ((keyspec & KEYSPEC_MODE_MASK) == KEYSPEC_MODE_UNPROTECTED) {
   \       0x1E   0xF012 0x6F40      TST      R2,#0xC000000
   \       0x22   0xD005             BEQ.N    ??sli_se_keyspec_to_key_1
    548              key->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT;
    549            }
    550          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    551            else if ((keyspec & KEYSPEC_MODE_MASK) == KEYSPEC_MODE_WRAPPED) {
   \       0x24   0xF002 0x6040      AND      R0,R2,#0xC000000
   \       0x28   0xF1B0 0x6F00      CMP      R0,#+134217728
   \       0x2C   0xD102             BNE.N    ??sli_se_keyspec_to_key_2
    552              key->storage.method = SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED;
   \       0x2E   0x2301             MOVS     R3,#+1
   \                     ??sli_se_keyspec_to_key_1: (+1)
   \       0x30   0x60CB             STR      R3,[R1, #+12]
   \       0x32   0xE012             B.N      ??sli_se_keyspec_to_key_3
    553            }
    554          #endif
    555            else if ((keyspec & KEYSPEC_MODE_MASK) == KEYSPEC_MODE_VOLATILE) {
   \                     ??sli_se_keyspec_to_key_2: (+1)
   \       0x34   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x38   0xD15C             BNE.N    ??sli_se_keyspec_to_key_0
    556              // Volatile can mean either internal-volatile or internal-immutable
    557              // Check which is which based on key index
    558              uint32_t key_index = (keyspec & KEYSPEC_INDEX_MASK) >> KEYSPEC_INDEX_OFFSET;
   \       0x3A   0xF3C2 0x4007      UBFX     R0,R2,#+16,#+8
    559          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    560              if (key_index <= SL_SE_KEY_SLOT_VOLATILE_3) {
   \       0x3E   0x2804             CMP      R0,#+4
   \       0x40   0xBF38             IT       CC
   \       0x42   0x2502             MOVCC    R5,#+2
    561                key->storage.method = SL_SE_KEY_STORAGE_INTERNAL_VOLATILE;
   \       0x44   0xD304             BCC.N    ??sli_se_keyspec_to_key_4
    562              } else
    563          #endif
    564              if ((key_index <= SL_SE_KEY_SLOT_APPLICATION_ATTESTATION_KEY)
    565                  && (key_index >= SL_SE_KEY_SLOT_INTERNAL_MIN)) {
   \       0x46   0xF1A0 0x03F7      SUB      R3,R0,#+247
   \       0x4A   0x2B08             CMP      R3,#+8
   \       0x4C   0xD252             BCS.N    ??sli_se_keyspec_to_key_0
    566                key->storage.method = SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE;
   \       0x4E   0x2503             MOVS     R5,#+3
    567              } else {
    568                return SL_STATUS_INVALID_PARAMETER;
    569              }
    570              key->storage.location.slot = key_index;
   \                     ??sli_se_keyspec_to_key_4: (+1)
   \       0x50   0x2300             MOVS     R3,#+0
   \       0x52   0x608B             STR      R3,[R1, #+8]
   \       0x54   0x60CD             STR      R5,[R1, #+12]
   \       0x56   0x6108             STR      R0,[R1, #+16]
   \       0x58   0x688D             LDR      R5,[R1, #+8]
    571            } else {
    572              return SL_STATUS_INVALID_PARAMETER;
    573            }
    574          
    575            // ---------------------
    576            // Key restriction [25-24]
    577          
    578            uint32_t keyspec_restriction = (keyspec & KEYSPEC_RESTRICTION_MASK);
   \                     ??sli_se_keyspec_to_key_3: (+1)
   \       0x5A   0xF002 0x7040      AND      R0,R2,#0x3000000
    579            if (keyspec_restriction == KEYSPEC_RESTRICTION_LOCKED) {
   \       0x5E   0xF1B0 0x7F80      CMP      R0,#+16777216
   \       0x62   0xBF08             IT       EQ
   \       0x64   0xF045 0x7580      ORREQ    R5,R5,#0x1000000
    580              key->flags |= SL_SE_KEY_FLAG_NON_EXPORTABLE;
   \       0x68   0xD00B             BEQ.N    ??sli_se_keyspec_to_key_5
    581            } else if (keyspec_restriction == KEYSPEC_RESTRICTION_UNLOCKED) {
   \       0x6A   0xB168             CBZ.N    R0,??sli_se_keyspec_to_key_6
    582              // no-op
    583            }
    584          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    585            else if (keyspec_restriction == KEYSPEC_RESTRICTION_INTERNAL) {
   \       0x6C   0xF1B0 0x7F00      CMP      R0,#+33554432
   \       0x70   0xBF08             IT       EQ
   \       0x72   0xF045 0x7500      ORREQ    R5,R5,#0x2000000
    586              key->flags |= SL_SE_KEY_FLAG_IS_DEVICE_GENERATED;
   \       0x76   0xD004             BEQ.N    ??sli_se_keyspec_to_key_5
    587            } else if (keyspec_restriction == KEYSPEC_RESTRICTION_RESTRICTED) {
   \       0x78   0xF1B0 0x7F40      CMP      R0,#+50331648
   \       0x7C   0xD13A             BNE.N    ??sli_se_keyspec_to_key_0
    588              key->flags |= SL_SE_KEY_FLAG_IS_RESTRICTED;
   \       0x7E   0xF045 0x7540      ORR      R5,R5,#0x3000000
    589            }
    590          #endif
    591            else {
    592              return SL_STATUS_INVALID_PARAMETER;
    593            }
    594          
    595            // Key restrictions are only applicable to volatile and wrapped keys
    596            if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \                     ??sli_se_keyspec_to_key_5: (+1)
   \       0x82   0x68CB             LDR      R3,[R1, #+12]
   \       0x84   0xB903             CBNZ.N   R3,??sli_se_keyspec_to_key_6
    597              if (keyspec_restriction != 0) {
   \       0x86   0xBBA8             CBNZ.N   R0,??sli_se_keyspec_to_key_0
    598                return SL_STATUS_INVALID_PARAMETER;
    599              }
    600            }
    601          
    602            // ---------------------
    603            // Key NoProt [15]
    604          
    605            if ((keyspec & KEYSPEC_NOPROT_MASK) == (1 << KEYSPEC_NOPROT_OFFSET)) {
   \                     ??sli_se_keyspec_to_key_6: (+1)
   \       0x88   0x0410             LSLS     R0,R2,#+16
   \       0x8A   0xBF48             IT       MI
   \       0x8C   0xF445 0x4500      ORRMI    R5,R5,#0x8000
    606              key->flags |= SL_SE_KEY_FLAG_ALLOW_ANY_ACCESS;
    607            }
    608          
    609            // ---------------------
    610            // Key attributes [14-0]
    611          
    612            // Set public/private flags
    613            bool has_private_key = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_PRIVATE_MASK) != 0);
   \       0x90   0x0B90             LSRS     R0,R2,#+14
    614            bool has_public_key = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_PUBLIC_MASK) != 0);
   \       0x92   0x0B53             LSRS     R3,R2,#+13
   \       0x94   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x98   0xF003 0x0301      AND      R3,R3,#0x1
    615          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    616            bool has_custom_curve = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_DOMAIN) != 0);
    617          #endif
    618            bool signing_only = ((keyspec & KEYSPEC_ATTRIBUTES_ECC_SIGN) != 0);
   \       0x9C   0x0A96             LSRS     R6,R2,#+10
   \       0x9E   0xF006 0x0601      AND      R6,R6,#0x1
    619          
    620            if ((keyspec & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \       0xA2   0xEA43 0x0700      ORR      R7,R3,R0
   \       0xA6   0xF1B4 0x4F00      CMP      R4,#+2147483648
   \       0xAA   0xD315             BCC.N    ??sli_se_keyspec_to_key_7
    621              if (has_private_key) {
   \       0xAC   0xB108             CBZ.N    R0,??sli_se_keyspec_to_key_8
    622                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY;
   \       0xAE   0xF445 0x4580      ORR      R5,R5,#0x4000
    623              }
    624              if (has_public_key) {
   \                     ??sli_se_keyspec_to_key_8: (+1)
   \       0xB2   0xB10B             CBZ.N    R3,??sli_se_keyspec_to_key_9
    625                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY;
   \       0xB4   0xF445 0x5500      ORR      R5,R5,#0x2000
    626              }
    627          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    628              if (has_custom_curve) {
   \                     ??sli_se_keyspec_to_key_9: (+1)
   \       0xB8   0x04D0             LSLS     R0,R2,#+19
   \       0xBA   0xD504             BPL.N    ??sli_se_keyspec_to_key_10
    629                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN;
   \       0xBC   0xF445 0x5580      ORR      R5,R5,#0x1000
   \       0xC0   0x608D             STR      R5,[R1, #+8]
    630          
    631                // TODO: custom curve parameter injection?
    632                return SL_STATUS_NOT_SUPPORTED;
   \       0xC2   0x200F             MOVS     R0,#+15
   \       0xC4   0xBDF0             POP      {R4-R7,PC}
    633              }
    634          #endif
    635              if (!(has_private_key || has_public_key)) {
   \                     ??sli_se_keyspec_to_key_10: (+1)
   \       0xC6   0x0038             MOVS     R0,R7
   \       0xC8   0xD014             BEQ.N    ??sli_se_keyspec_to_key_0
    636                return SL_STATUS_INVALID_PARAMETER;
    637              }
    638          
    639              // For ECC keys, their length is encoded in the type
    640              key->type = (key->type & ~SL_SE_KEY_TYPE_ATTRIBUTES_MASK) | ((keyspec & KEYSPEC_ATTRIBUTES_ECC_SIZE_MASK) + 1);
   \       0xCA   0xF002 0x007F      AND      R0,R2,#0x7F
   \       0xCE   0x0BE3             LSRS     R3,R4,#+15
   \       0xD0   0x1C40             ADDS     R0,R0,#+1
   \       0xD2   0xEA40 0x33C3      ORR      R3,R0,R3, LSL #+15
   \       0xD6   0x600B             STR      R3,[R1, #+0]
    641            }
    642          
    643            if ((keyspec & KEYSPEC_TYPE_MASK) >= KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME
    644                && (keyspec & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_EDDSA) {
   \                     ??sli_se_keyspec_to_key_7: (+1)
   \       0xD8   0xF104 0x4300      ADD      R3,R4,#+2147483648
   \       0xDC   0xF1B3 0x4F80      CMP      R3,#+1073741824
   \       0xE0   0xD203             BCS.N    ??sli_se_keyspec_to_key_11
    645              if (signing_only) {
   \       0xE2   0x0030             MOVS     R0,R6
   \       0xE4   0xBF18             IT       NE
   \       0xE6   0xF445 0x6580      ORRNE    R5,R5,#0x400
    646                key->flags |= SL_SE_KEY_FLAG_ASYMMETRIC_SIGNING_ONLY;
    647              }
    648            }
    649          
    650            // Ensure that symmetric keys don't have asymmetric flags
    651            if ((keyspec & KEYSPEC_TYPE_MASK) < KEYSPEC_TYPE_ECC_WEIERSTRASS_PRIME) {
   \                     ??sli_se_keyspec_to_key_11: (+1)
   \       0xEA   0xF1B4 0x4F00      CMP      R4,#+2147483648
   \       0xEE   0xD20F             BCS.N    ??sli_se_keyspec_to_key_12
    652              if (has_private_key || has_public_key || signing_only) {
   \       0xF0   0x433E             ORRS     R6,R6,R7
   \       0xF2   0xD002             BEQ.N    ??sli_se_keyspec_to_key_13
    653                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_keyspec_to_key_0: (+1)
   \       0xF4   0x608D             STR      R5,[R1, #+8]
   \       0xF6   0x2021             MOVS     R0,#+33
   \       0xF8   0xBDF0             POP      {R4-R7,PC}
    654              }
    655          
    656              key->size = keyspec & KEYSPEC_ATTRIBUTES_MASK;
   \                     ??sli_se_keyspec_to_key_13: (+1)
   \       0xFA   0xF3C2 0x000E      UBFX     R0,R2,#+0,#+15
   \       0xFE   0x6048             STR      R0,[R1, #+4]
    657          
    658              switch ((keyspec & KEYSPEC_ATTRIBUTES_MASK)) {
   \      0x100   0x2810             CMP      R0,#+16
   \      0x102   0xBF1C             ITT      NE
   \      0x104   0x2818             CMPNE    R0,#+24
   \      0x106   0x2820             CMPNE    R0,#+32
   \      0x108   0xD102             BNE.N    ??sli_se_keyspec_to_key_12
    659                case SL_SE_KEY_TYPE_AES_128:
    660                case SL_SE_KEY_TYPE_AES_192:
    661                case SL_SE_KEY_TYPE_AES_256:
    662                  key->type = keyspec & (KEYSPEC_TYPE_MASK | KEYSPEC_ATTRIBUTES_MASK);
   \      0x10A   0xF36F 0x32DB      BFC      R2,#+15,#+13
   \      0x10E   0x600A             STR      R2,[R1, #+0]
    663                  break;
    664                default:
    665                  break;
    666              }
    667            }
    668          
    669            return SL_STATUS_OK;
   \                     ??sli_se_keyspec_to_key_12: (+1)
   \      0x110   0x608D             STR      R5,[R1, #+8]
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0xBDF0             POP      {R4-R7,PC}
    670          }
    671          
    672          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)

   \                                 In section .text, align 4, keep-with-next
    673          static const uint32_t default_auth_data[2] = { 0 };
   \                     default_auth_data:
   \        0x0   0x0000'0000        DC32 0, 0
   \              0x0000'0000
    674          #endif
    675          

   \                                 In section .text, align 2, keep-with-next
    676          sl_status_t sli_se_get_auth_buffer(const sl_se_key_descriptor_t *key,
    677                                             SE_DataTransfer_t *auth_buffer)
    678          {
    679            if (key == NULL || auth_buffer == NULL) {
   \                     sli_se_get_auth_buffer: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF18             IT       NE
   \        0x4   0x2900             CMPNE    R1,#+0
   \        0x6   0xD101             BNE.N    ??sli_se_get_auth_buffer_0
    680              return SL_STATUS_INVALID_PARAMETER;
   \        0x8   0x2021             MOVS     R0,#+33
   \        0xA   0x4770             BX       LR
    681            }
    682          
    683            auth_buffer->next = (void*)SE_DATATRANSFER_STOP;
   \                     ??sli_se_get_auth_buffer_0: (+1)
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0x604A             STR      R2,[R1, #+4]
    684          
    685          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    686            if ((key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
    687                || (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED)) {
   \       0x10   0x68C2             LDR      R2,[R0, #+12]
   \       0x12   0x2A02             CMP      R2,#+2
   \       0x14   0xBF18             IT       NE
   \       0x16   0x2A01             CMPNE    R2,#+1
   \       0x18   0xD109             BNE.N    ??sli_se_get_auth_buffer_1
    688              if (key->password) {
   \       0x1A   0x6980             LDR      R0,[R0, #+24]
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable6
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xBF06             ITTE     EQ
   \       0x24   0x.... 0x....      ADREQ.W  R0,default_auth_data
   \       0x28   0x6008             STREQ    R0,[R1, #+0]
   \       0x2A   0x6008             STRNE    R0,[R1, #+0]
    689                auth_buffer->data = key->password;
    690                auth_buffer->length = sizeof(default_auth_data) | SE_DATATRANSFER_REALIGN;
    691              } else {
    692                auth_buffer->data = (void*)default_auth_data;
   \       0x2C   0xE001             B.N      ??sli_se_get_auth_buffer_2
    693                auth_buffer->length = sizeof(default_auth_data) | SE_DATATRANSFER_REALIGN;
    694              }
    695            } else {
    696              auth_buffer->length = 0 | SE_DATATRANSFER_REALIGN;
   \                     ??sli_se_get_auth_buffer_1: (+1)
   \       0x2E   0xF04F 0x5200      MOV      R2,#+536870912
   \                     ??sli_se_get_auth_buffer_2: (+1)
   \       0x32   0x608A             STR      R2,[R1, #+8]
    697            }
    698          #else
    699            (void)key;
    700            auth_buffer->length = 0 | SE_DATATRANSFER_REALIGN;
    701          #endif
    702          
    703            return SL_STATUS_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x4770             BX       LR
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          sl_status_t sli_se_get_key_input_output(const sl_se_key_descriptor_t *key,
    707                                                  SE_DataTransfer_t *buffer)
    708          {
   \                     sli_se_get_key_input_output: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    709            if (key == NULL || buffer == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2D00             CMPNE    R5,#+0
   \        0xA   0xD029             BEQ.N    ??sli_se_get_key_input_output_0
    710              return SL_STATUS_INVALID_PARAMETER;
    711            }
    712          
    713            buffer->next = (void*)SE_DATATRANSFER_STOP;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x6068             STR      R0,[R5, #+4]
    714          
    715            if ((key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
    716          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    717                || (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED)
    718          #endif
    719                ) {
   \       0x10   0x68E0             LDR      R0,[R4, #+12]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xBF18             IT       NE
   \       0x16   0x2801             CMPNE    R0,#+1
   \       0x18   0xD11B             BNE.N    ??sli_se_get_key_input_output_1
    720              // Set or adjust the key attributes for different key types
    721              uint32_t storage_size = 0;
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x9200             STR      R2,[SP, #+0]
    722              sl_status_t status = sli_key_get_storage_size(key, &storage_size);
   \       0x1E   0x4669             MOV      R1,SP
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       sli_key_get_storage_size
    723              if (status != SL_STATUS_OK) {
   \       0x26   0xB998             CBNZ.N   R0,??sli_se_get_key_input_output_2
    724                return status;
    725              }
    726          
    727              uint32_t total_storage_size = 0;
    728              if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \       0x28   0x68E0             LDR      R0,[R4, #+12]
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0xB908             CBNZ.N   R0,??sli_se_get_key_input_output_3
    729                total_storage_size = storage_size;
   \       0x2E   0x9900             LDR      R1,[SP, #+0]
   \       0x30   0xE003             B.N      ??sli_se_get_key_input_output_4
    730              }
    731          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    732              else if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED) {
   \                     ??sli_se_get_key_input_output_3: (+1)
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xBF04             ITT      EQ
   \       0x36   0x9900             LDREQ    R1,[SP, #+0]
   \       0x38   0x311C             ADDEQ    R1,R1,#+28
    733                total_storage_size = storage_size + SLI_SE_WRAPPED_KEY_OVERHEAD;
    734              }
    735          #endif
    736          
    737              if (total_storage_size > key->storage.location.buffer.size) {
   \                     ??sli_se_get_key_input_output_4: (+1)
   \       0x3A   0x6960             LDR      R0,[R4, #+20]
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xD201             BCS.N    ??sli_se_get_key_input_output_5
    738                return SL_STATUS_WOULD_OVERFLOW;
   \       0x40   0x201D             MOVS     R0,#+29
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    739              }
    740          
    741              buffer->data = key->storage.location.buffer.pointer;
   \                     ??sli_se_get_key_input_output_5: (+1)
   \       0x44   0x6920             LDR      R0,[R4, #+16]
    742              buffer->length = total_storage_size | SE_DATATRANSFER_REALIGN;
   \       0x46   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \       0x4A   0x6028             STR      R0,[R5, #+0]
   \       0x4C   0x60A9             STR      R1,[R5, #+8]
    743            } else if ((key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)
    744          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    745                       || (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
    746          #endif
    747                       ) {
    748              buffer->length = 0;
    749            } else {
    750              return SL_STATUS_INVALID_PARAMETER;
    751            }
    752          
    753            return SL_STATUS_OK;
   \                     ??sli_se_get_key_input_output_6: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??sli_se_get_key_input_output_2: (+1)
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??sli_se_get_key_input_output_1: (+1)
   \       0x52   0x2803             CMP      R0,#+3
   \       0x54   0xBF18             IT       NE
   \       0x56   0x2802             CMPNE    R0,#+2
   \       0x58   0xD102             BNE.N    ??sli_se_get_key_input_output_0
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x60A8             STR      R0,[R5, #+8]
   \       0x5E   0xE7F6             B.N      ??sli_se_get_key_input_output_6
   \                     ??sli_se_get_key_input_output_0: (+1)
   \       0x60   0x2021             MOVS     R0,#+33
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    754          }
    755          
    756          /***************************************************************************//**
    757           * Validate key descriptor.
    758           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    759          sl_status_t sl_se_validate_key(const sl_se_key_descriptor_t *key)
    760          {
   \                     sl_se_validate_key: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB087             SUB      SP,SP,#+28
    761            sl_status_t status = SL_STATUS_OK;
    762            uint32_t keyspec = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
    763          
    764            if (key == NULL) {
   \        0xA   0xB90C             CBNZ.N   R4,??sl_se_validate_key_0
    765              return SL_STATUS_INVALID_PARAMETER;
   \        0xC   0x2021             MOVS     R0,#+33
   \        0xE   0xE00D             B.N      ??sl_se_validate_key_1
    766            }
    767          
    768            status = sli_se_key_to_keyspec(key, &keyspec);
   \                     ??sl_se_validate_key_0: (+1)
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       sli_se_key_to_keyspec
    769            if (status != SL_STATUS_OK) {
   \       0x18   0xB940             CBNZ.N   R0,??sl_se_validate_key_1
    770              return status;
    771            }
    772          
    773            SE_DataTransfer_t auth_buffer;
    774            status = sli_se_get_auth_buffer(key, &auth_buffer);
   \       0x1A   0xA904             ADD      R1,SP,#+16
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       sli_se_get_auth_buffer
    775            if (status != SL_STATUS_OK) {
   \       0x22   0xB918             CBNZ.N   R0,??sl_se_validate_key_1
    776              return status;
    777            }
    778          
    779            SE_DataTransfer_t key_buffer;
    780            status = sli_se_get_key_input_output(key, &key_buffer);
    781            if (status != SL_STATUS_OK) {
    782              return status;
   \       0x24   0xA901             ADD      R1,SP,#+4
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       sli_se_get_key_input_output
   \                     ??sl_se_validate_key_1: (+1)
   \       0x2C   0xB008             ADD      SP,SP,#+32
   \       0x2E   0xBD10             POP      {R4,PC}
    783            }
    784          
    785            return status;
    786          }
    787          
    788          /***************************************************************************//**
    789           * Generate a random key adhering to the given key descriptor
    790           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    791          sl_status_t sl_se_generate_key(sl_se_command_context_t *cmd_ctx,
    792                                         const sl_se_key_descriptor_t *key_out)
    793          {
   \                     sl_se_generate_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB098             SUB      SP,SP,#+96
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
    794            sl_status_t status;
    795          
    796            if (cmd_ctx == NULL || key_out == NULL) {
   \        0x8   0xBF14             ITE      NE
   \        0xA   0x2D00             CMPNE    R5,#+0
   \        0xC   0x2021             MOVEQ    R0,#+33
    797              return SL_STATUS_INVALID_PARAMETER;
   \        0xE   0xD05D             BEQ.N    ??CrossCallReturnLabel_19
    798            }
    799          
    800            // Initialize command
    801            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_CREATE_KEY);
   \       0x10   0xF04F 0x7200      MOV      R2,#+33554432
   \       0x14   0x6022             STR      R2,[R4, #+0]
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x6061             STR      R1,[R4, #+4]
   \       0x1A   0x60A1             STR      R1,[R4, #+8]
   \       0x1C   0x61E1             STR      R1,[R4, #+28]
    802          
    803            // Add key parameters to command
    804            sli_add_key_parameters(cmd_ctx, key_out, status);
   \       0x1E   0x.... 0x....      BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD152             BNE.N    ??CrossCallReturnLabel_19
   \       0x26   0x.... 0x....      BL       ?Subroutine3
    805          
    806          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    807            SE_Command_t *se_cmd = &cmd_ctx->command;
    808            // Custom curve domain
    809            SE_DataTransfer_t domain_p_buffer;
    810            SE_DataTransfer_t domain_N_buffer;
    811            SE_DataTransfer_t domain_Gx_buffer;
    812            SE_DataTransfer_t domain_Gy_buffer;
    813            SE_DataTransfer_t domain_a_buffer;
    814            SE_DataTransfer_t domain_b_buffer;
    815          
    816            if (key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) {
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x2A   0x68A9             LDR      R1,[R5, #+8]
   \       0x2C   0x04C8             LSLS     R0,R1,#+19
   \       0x2E   0xD53A             BPL.N    ??sl_se_generate_key_0
    817              if (key_out->type & SL_SE_KEY_TYPE_ECC_WEIERSTRASS_PRIME_CUSTOM) {
   \       0x30   0x6829             LDR      R1,[R5, #+0]
   \       0x32   0x2900             CMP      R1,#+0
   \       0x34   0xD53C             BPL.N    ??sl_se_generate_key_1
    818                sl_se_custom_weierstrass_prime_domain_t *domain = (sl_se_custom_weierstrass_prime_domain_t*)key_out->domain;
   \       0x36   0x69EF             LDR      R7,[R5, #+28]
    819                uint32_t domain_size = domain->size;
    820          
    821                domain_p_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x38   0x2101             MOVS     R1,#+1
    822                domain_p_buffer.data = (void*)domain->p;
    823                domain_p_buffer.length = domain_size;
    824                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_p_buffer);
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x683E             LDR      R6,[R7, #+0]
   \       0x3E   0x9110             STR      R1,[SP, #+64]
   \       0x40   0x6879             LDR      R1,[R7, #+4]
   \       0x42   0x910F             STR      R1,[SP, #+60]
   \       0x44   0x9611             STR      R6,[SP, #+68]
   \       0x46   0xA90F             ADD      R1,SP,#+60
   \       0x48   0x.... 0x....      BL       SE_addDataInput
    825          
    826                domain_N_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0x900D             STR      R0,[SP, #+52]
    827                domain_N_buffer.data = (void*)domain->N;
   \       0x50   0x68B9             LDR      R1,[R7, #+8]
    828                domain_N_buffer.length = domain_size;
    829                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_N_buffer);
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x910C             STR      R1,[SP, #+48]
   \       0x56   0x960E             STR      R6,[SP, #+56]
   \       0x58   0xA90C             ADD      R1,SP,#+48
   \       0x5A   0x.... 0x....      BL       SE_addDataInput
    830          
    831                domain_Gx_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0x900A             STR      R0,[SP, #+40]
    832                domain_Gx_buffer.data = (void*)domain->Gx;
   \       0x62   0x68F9             LDR      R1,[R7, #+12]
    833                domain_Gx_buffer.length = domain_size;
    834                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_Gx_buffer);
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x9109             STR      R1,[SP, #+36]
   \       0x68   0x960B             STR      R6,[SP, #+44]
   \       0x6A   0xA909             ADD      R1,SP,#+36
   \       0x6C   0x.... 0x....      BL       SE_addDataInput
    835          
    836                domain_Gy_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0x9007             STR      R0,[SP, #+28]
    837                domain_Gy_buffer.data = (void*)domain->Gy;
   \       0x74   0x6939             LDR      R1,[R7, #+16]
    838                domain_Gy_buffer.length = domain_size;
    839                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_Gy_buffer);
   \       0x76   0x4620             MOV      R0,R4
   \       0x78   0x9106             STR      R1,[SP, #+24]
   \       0x7A   0x9608             STR      R6,[SP, #+32]
   \       0x7C   0xA906             ADD      R1,SP,#+24
   \       0x7E   0x.... 0x....      BL       SE_addDataInput
    840          
    841                domain_a_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0x9004             STR      R0,[SP, #+16]
    842                domain_a_buffer.data = (void*)domain->a;
   \       0x86   0x6979             LDR      R1,[R7, #+20]
    843                domain_a_buffer.length = domain_size;
    844                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_a_buffer);
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0x9103             STR      R1,[SP, #+12]
   \       0x8C   0x9605             STR      R6,[SP, #+20]
   \       0x8E   0xA903             ADD      R1,SP,#+12
   \       0x90   0x.... 0x....      BL       SE_addDataInput
    845          
    846                domain_b_buffer.next = (void*)SE_DATATRANSFER_STOP;
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0x9001             STR      R0,[SP, #+4]
    847                domain_b_buffer.data = (void*)domain->b;
   \       0x98   0x69B9             LDR      R1,[R7, #+24]
    848                domain_b_buffer.length = domain_size;
    849                SE_addDataInput(se_cmd, (SE_DataTransfer_t*)&domain_b_buffer);
   \       0x9A   0x4620             MOV      R0,R4
   \       0x9C   0x9100             STR      R1,[SP, #+0]
   \       0x9E   0x9602             STR      R6,[SP, #+8]
   \       0xA0   0x4669             MOV      R1,SP
   \       0xA2   0x.... 0x....      BL       SE_addDataInput
    850              } else {
    851                return SL_STATUS_NOT_SUPPORTED;
    852              }
    853            }
    854          #endif
    855          
    856            // Add key metadata block to command
    857            sli_add_key_metadata(cmd_ctx, key_out, status);
   \                     ??sl_se_generate_key_0: (+1)
   \       0xA6   0xA915             ADD      R1,SP,#+84
   \       0xA8   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xAC   0xB110             CBZ.N    R0,??sl_se_generate_key_2
   \       0xAE   0xE00D             B.N      ??CrossCallReturnLabel_19
   \                     ??sl_se_generate_key_1: (+1)
   \       0xB0   0x200F             MOVS     R0,#+15
   \       0xB2   0xE00B             B.N      ??CrossCallReturnLabel_19
   \                     ??sl_se_generate_key_2: (+1)
   \       0xB4   0xA915             ADD      R1,SP,#+84
   \       0xB6   0x.... 0x....      BL       ??Subroutine2_0
    858            // Add key output block to command
    859            sli_add_key_output(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0xBA   0xA912             ADD      R1,SP,#+72
   \       0xBC   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0xC0   0xB920             CBNZ.N   R0,??CrossCallReturnLabel_19
   \       0xC2   0xA912             ADD      R1,SP,#+72
   \       0xC4   0x.... 0x....      BL       ??Subroutine7_0
    860          
    861            // Execute command
    862            status = sli_se_execute_and_wait(cmd_ctx);
    863          
    864            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
    865            // Clear padding for plaintext keys upon success
    866            if (status == SL_STATUS_OK) {
    867              status = clear_padding(key_out);
    868            }
    869            #endif
    870          
    871            return status;
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0xC8   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0xCC   0xB019             ADD      SP,SP,#+100
   \       0xCE   0xBDF0             POP      {R4-R7,PC}
    872          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....             B.N      sli_se_get_key_input_output

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x9900             LDR      R1,[SP, #+0]
   \                     ??Subroutine3_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine12_0: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....             B.N      sli_se_key_to_keyspec

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xA906             ADD      R1,SP,#+24
   \                     ??Subroutine2_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x....             B.N      sli_se_get_auth_buffer
    873          
    874          /***************************************************************************//**
    875           * Export the public key of an ECC keypair
    876           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    877          sl_status_t sl_se_export_public_key(sl_se_command_context_t *cmd_ctx,
    878                                              const sl_se_key_descriptor_t *key_in,
    879                                              const sl_se_key_descriptor_t *key_out)
    880          {
   \                     sl_se_export_public_key: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4614             MOV      R4,R2
    881            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x2E00             CMPNE    R6,#+0
   \        0xE   0x2C00             CMPNE    R4,#+0
   \       0x10   0xD037             BEQ.N    ??sl_se_export_public_key_0
    882              return SL_STATUS_INVALID_PARAMETER;
    883            }
    884          
    885            SE_Command_t *se_cmd = &cmd_ctx->command;
    886            sl_status_t status;
    887          
    888            // Check input/output key type and size relationship
    889            status = sli_key_check_equivalent(key_in, key_out, true, true);
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0x2201             MOVS     R2,#+1
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x.... 0x....      BL       sli_key_check_equivalent
    890            if (status != SL_STATUS_OK) {
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD154             BNE.N    ??sl_se_export_public_key_1
    891              return status;
    892            }
    893          
    894            // Check that the input key has a private or public key
    895            if (!(key_in->flags & (SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY
    896                                   | SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY))) {
   \       0x22   0x68B0             LDR      R0,[R6, #+8]
   \       0x24   0xF410 0x4FC0      TST      R0,#0x6000
   \       0x28   0xD02B             BEQ.N    ??sl_se_export_public_key_0
    897              return SL_STATUS_INVALID_PARAMETER;
    898            }
    899            if (!(key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY)
    900                || (key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY)) {
   \       0x2A   0x68A0             LDR      R0,[R4, #+8]
   \       0x2C   0xF400 0x40C0      AND      R0,R0,#0x6000
   \       0x30   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x34   0xD125             BNE.N    ??sl_se_export_public_key_0
    901              return SL_STATUS_INVALID_PARAMETER;
    902            }
    903          
    904            // Initialize command
    905            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_READPUB_KEY);
   \       0x36   0x....             LDR.N    R2,??DataTable6_1
   \       0x38   0x602A             STR      R2,[R5, #+0]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6068             STR      R0,[R5, #+4]
   \       0x3E   0x60A8             STR      R0,[R5, #+8]
   \       0x40   0x61E8             STR      R0,[R5, #+28]
    906          
    907            // Add key parameters to command
    908            sli_add_key_parameters(cmd_ctx, key_in, status);
   \       0x42   0x.... 0x....      BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD140             BNE.N    ??sl_se_export_public_key_1
   \       0x4A   0x9900             LDR      R1,[SP, #+0]
   \       0x4C   0x4628             MOV      R0,R5
   \       0x4E   0x.... 0x....      BL       SE_addParameter
    909            // Add key metadata block to command
    910            sli_add_key_metadata(cmd_ctx, key_in, status);
   \       0x52   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD138             BNE.N    ??sl_se_export_public_key_1
   \       0x5A   0xA907             ADD      R1,SP,#+28
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0x.... 0x....      BL       SE_addDataInput
    911            // Add key input block to command
    912            sli_add_key_input(cmd_ctx, key_in, status);
   \       0x62   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x66   0xBB88             CBNZ.N   R0,??sl_se_export_public_key_1
   \       0x68   0xA904             ADD      R1,SP,#+16
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x.... 0x....      BL       SE_addDataInput
    913          
    914            // Pubkey buffer
    915            // Check for correct storage and flags
    916            if ((key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
    917                || (key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PRIVATE_KEY)
    918                || !(key_out->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY)) {
   \       0x70   0x68E0             LDR      R0,[R4, #+12]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xBF02             ITTT     EQ
   \       0x76   0x68A0             LDREQ    R0,[R4, #+8]
   \       0x78   0xF400 0x40C0      ANDEQ    R0,R0,#0x6000
   \       0x7C   0xF5B0 0x5F00      CMPEQ    R0,#+8192
   \       0x80   0xD001             BEQ.N    ??sl_se_export_public_key_2
    919              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_export_public_key_0: (+1)
   \       0x82   0x2021             MOVS     R0,#+33
   \       0x84   0xE022             B.N      ??sl_se_export_public_key_1
    920            }
    921          
    922            uint32_t required_storage_size;
    923            status = sli_key_get_storage_size(key_out, &required_storage_size);
   \                     ??sl_se_export_public_key_2: (+1)
   \       0x86   0x4669             MOV      R1,SP
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0x.... 0x....      BL       sli_key_get_storage_size
    924            if (status != SL_STATUS_OK) {
   \       0x8E   0xB9E8             CBNZ.N   R0,??sl_se_export_public_key_1
    925              return status;
    926            }
    927          
    928            if (required_storage_size > key_out->storage.location.buffer.size) {
   \       0x90   0x6961             LDR      R1,[R4, #+20]
   \       0x92   0x9800             LDR      R0,[SP, #+0]
   \       0x94   0x4281             CMP      R1,R0
   \       0x96   0xBF38             IT       CC
   \       0x98   0x201D             MOVCC    R0,#+29
    929              return SL_STATUS_WOULD_OVERFLOW;
   \       0x9A   0xD317             BCC.N    ??sl_se_export_public_key_1
    930            }
    931          
    932            SE_DataTransfer_t pubkey_buffer = SE_DATATRANSFER_DEFAULT(
    933              key_out->storage.location.buffer.pointer, required_storage_size);
   \       0x9C   0x....             ADR.N    R0,?_0
   \       0x9E   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xA2   0xAE01             ADD      R6,SP,#+4
   \       0xA4   0xE886 0x000E      STM      R6,{R1-R3}
   \       0xA8   0x6924             LDR      R4,[R4, #+16]
    934            SE_addDataOutput(se_cmd, &pubkey_buffer);
   \       0xAA   0xA901             ADD      R1,SP,#+4
   \       0xAC   0x9401             STR      R4,[SP, #+4]
   \       0xAE   0x9800             LDR      R0,[SP, #+0]
   \       0xB0   0x2403             MOVS     R4,#+3
   \       0xB2   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xB6   0x9003             STR      R0,[SP, #+12]
   \       0xB8   0x4628             MOV      R0,R5
   \       0xBA   0x.... 0x....      BL       SE_addDataOutput
    935          
    936            // Execute command.
    937            // The retries are necessary in order to reduce the risk of random failures
    938            // in the accelerated point multiplication. This mainly affects very small or
    939            // large scalars, which in this case would be the private key.
    940            for (size_t i = 0; i < SLI_SE_MAX_POINT_MULT_RETRIES; ++i) {
    941              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??sl_se_export_public_key_3: (+1)
   \       0xBE   0x4628             MOV      R0,R5
   \       0xC0   0x.... 0x....      BL       sli_se_execute_and_wait
    942              if (status != SL_STATUS_FAIL) {
   \       0xC4   0x2801             CMP      R0,#+1
   \       0xC6   0xD101             BNE.N    ??sl_se_export_public_key_1
    943                break;
    944              }
    945            }
   \       0xC8   0x1E64             SUBS     R4,R4,#+1
   \       0xCA   0xD1F8             BNE.N    ??sl_se_export_public_key_3
    946            return status;
   \                     ??sl_se_export_public_key_1: (+1)
   \       0xCC   0xB00A             ADD      SP,SP,#+40
   \       0xCE   0xBD70             POP      {R4-R6,PC}
    947          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0xA907             ADD      R1,SP,#+28
   \                     ??Subroutine11_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x....             B.N      sli_se_get_auth_buffer

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xA904             ADD      R1,SP,#+16
   \                     ??Subroutine10_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x....             B.N      sli_se_get_key_input_output

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x....             B.N      sli_se_key_to_keyspec

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    948          
    949          /***************************************************************************//**
    950           * Returns the required storage size for the given key
    951           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    952          sl_status_t sl_se_get_storage_size(const sl_se_key_descriptor_t *key, uint32_t *storage_size)
    953          {
   \                     sl_se_get_storage_size: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    954            if (key == NULL || storage_size == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2D00             CMPNE    R5,#+0
   \        0xA   0xD015             BEQ.N    ??sl_se_get_storage_size_0
    955              return SL_STATUS_INVALID_PARAMETER;
    956            }
    957          
    958            if ((key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
    959          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    960                || (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED)
    961          #endif
    962                ) {
   \        0xC   0x68E0             LDR      R0,[R4, #+12]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xBF18             IT       NE
   \       0x12   0x2801             CMPNE    R0,#+1
   \       0x14   0xD10B             BNE.N    ??sl_se_get_storage_size_1
    963              // Set or adjust the key attributes for different key types
    964              sl_status_t status = sli_key_get_storage_size(key, storage_size);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       sli_key_get_storage_size
    965              if (status != SL_STATUS_OK) {
   \       0x1C   0xB930             CBNZ.N   R0,??sl_se_get_storage_size_2
    966                return status;
    967              }
    968          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    969              if (key->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED) {
   \       0x1E   0x68E1             LDR      R1,[R4, #+12]
   \       0x20   0x2901             CMP      R1,#+1
   \       0x22   0xD102             BNE.N    ??sl_se_get_storage_size_3
    970                *storage_size = *storage_size + SLI_SE_WRAPPED_KEY_OVERHEAD;
   \       0x24   0x6828             LDR      R0,[R5, #+0]
   \       0x26   0x301C             ADDS     R0,R0,#+28
   \                     ??sl_se_get_storage_size_4: (+1)
   \       0x28   0x6028             STR      R0,[R5, #+0]
    971              }
    972          #endif
    973            } else if ((key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)
    974          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    975                       || (key->storage.method == SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
    976          #endif
    977                       ) {
    978              *storage_size = 0;
    979            } else {
    980              return SL_STATUS_INVALID_PARAMETER;
    981            }
    982          
    983            return SL_STATUS_OK;
   \                     ??sl_se_get_storage_size_3: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??sl_se_get_storage_size_2: (+1)
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??sl_se_get_storage_size_1: (+1)
   \       0x2E   0x2803             CMP      R0,#+3
   \       0x30   0xBF14             ITE      NE
   \       0x32   0x2802             CMPNE    R0,#+2
   \       0x34   0x2000             MOVEQ    R0,#+0
   \       0x36   0xD0F7             BEQ.N    ??sl_se_get_storage_size_4
   \                     ??sl_se_get_storage_size_0: (+1)
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    984          }
    985          
    986          #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    987          /***************************************************************************//**
    988           * Protect a plaintext key using the SE
    989           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    990          sl_status_t sl_se_import_key(sl_se_command_context_t *cmd_ctx,
    991                                       const sl_se_key_descriptor_t *key_in,
    992                                       const sl_se_key_descriptor_t *key_out)
    993          {
   \                     sl_se_import_key: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
    994            sl_status_t status;
    995          
    996            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2E00             CMPNE    R6,#+0
   \        0xE   0xD00B             BEQ.N    ??sl_se_import_key_0
   \       0x10   0xB155             CBZ.N    R5,??sl_se_import_key_0
    997              return SL_STATUS_INVALID_PARAMETER;
    998            }
    999          
   1000            // Check input/output key type and size relationship
   1001            status = sli_key_check_equivalent(key_in, key_out, true, false);
   \       0x12   0x.... 0x....      BL       ?Subroutine9
   1002            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD123             BNE.N    ??CrossCallReturnLabel_18
   1003              return status;
   1004            }
   1005          
   1006            if ((key_in->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1007                || ((key_out->storage.method != SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
   1008                    && (key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED))) {
   \       0x1A   0x68F0             LDR      R0,[R6, #+12]
   \       0x1C   0xB920             CBNZ.N   R0,??sl_se_import_key_0
   \       0x1E   0x68E8             LDR      R0,[R5, #+12]
   \       0x20   0x2802             CMP      R0,#+2
   \       0x22   0xBF18             IT       NE
   \       0x24   0x2801             CMPNE    R0,#+1
   \       0x26   0xD001             BEQ.N    ??sl_se_import_key_1
   1009              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_import_key_0: (+1)
   \       0x28   0x2021             MOVS     R0,#+33
   \       0x2A   0xE01A             B.N      ??CrossCallReturnLabel_18
   1010            }
   1011          
   1012            // Initialize command
   1013            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_WRAP_KEY);
   \                     ??sl_se_import_key_1: (+1)
   \       0x2C   0xF04F 0x7280      MOV      R2,#+16777216
   \       0x30   0x.... 0x....      BL       ?Subroutine0
   1014          
   1015            // Add key parameters to command
   1016            sli_add_key_parameters(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0x34   0xB9A8             CBNZ.N   R0,??CrossCallReturnLabel_18
   \       0x36   0x.... 0x....      BL       ?Subroutine3
   1017          
   1018            // Add key input block to command
   1019            sli_add_key_input(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x3A   0xA906             ADD      R1,SP,#+24
   \       0x3C   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x40   0xB978             CBNZ.N   R0,??CrossCallReturnLabel_18
   \       0x42   0x.... 0x....      BL       ?Subroutine2
   1020          
   1021            // Add key metadata block to command
   1022            sli_add_key_metadata(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x46   0xA903             ADD      R1,SP,#+12
   \       0x48   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x4C   0xB948             CBNZ.N   R0,??CrossCallReturnLabel_18
   \       0x4E   0xA903             ADD      R1,SP,#+12
   \       0x50   0x.... 0x....      BL       ??Subroutine2_0
   1023          
   1024            // Add key output block to command
   1025            sli_add_key_output(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x54   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x58   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_18
   \       0x5A   0x.... 0x....      BL       ?Subroutine7
   1026          
   1027            status = sli_se_execute_and_wait(cmd_ctx);
   1028            return status;
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x5E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x62   0xB00A             ADD      SP,SP,#+40
   \       0x64   0xBD70             POP      {R4-R6,PC}
   1029          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x6022             STR      R2,[R4, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6060             STR      R0,[R4, #+4]
   \        0x6   0x60A0             STR      R0,[R4, #+8]
   \        0x8   0x61E0             STR      R0,[R4, #+28]
   \        0xA                      REQUIRE ??Subroutine12_0
   \        0xA                      ;; // Fall through to label ??Subroutine12_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4629             MOV      R1,R5
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x....             B.N      sli_key_check_equivalent
   1030          
   1031          /***************************************************************************//**
   1032           * Export a volatile or wrapped key back to plaintext if allowed
   1033           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1034          sl_status_t sl_se_export_key(sl_se_command_context_t *cmd_ctx,
   1035                                       const sl_se_key_descriptor_t *key_in,
   1036                                       const sl_se_key_descriptor_t *key_out)
   1037          {
   \                     sl_se_export_key: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   1038            sl_status_t status;
   1039          
   1040            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2E00             CMPNE    R6,#+0
   \        0xE   0xD00B             BEQ.N    ??sl_se_export_key_0
   \       0x10   0xB155             CBZ.N    R5,??sl_se_export_key_0
   1041              return SL_STATUS_INVALID_PARAMETER;
   1042            }
   1043          
   1044            // Check input/output key type and size relationship
   1045            status = sli_key_check_equivalent(key_in, key_out, true, false);
   \       0x12   0x.... 0x....      BL       ?Subroutine9
   1046            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD123             BNE.N    ??CrossCallReturnLabel_17
   1047              return status;
   1048            }
   1049          
   1050            if ((key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1051                || ((key_in->storage.method != SL_SE_KEY_STORAGE_INTERNAL_VOLATILE)
   1052                    && (key_in->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_WRAPPED))) {
   \       0x1A   0x68E8             LDR      R0,[R5, #+12]
   \       0x1C   0xB920             CBNZ.N   R0,??sl_se_export_key_0
   \       0x1E   0x68F0             LDR      R0,[R6, #+12]
   \       0x20   0x2802             CMP      R0,#+2
   \       0x22   0xBF18             IT       NE
   \       0x24   0x2801             CMPNE    R0,#+1
   \       0x26   0xD001             BEQ.N    ??sl_se_export_key_1
   1053              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_export_key_0: (+1)
   \       0x28   0x2021             MOVS     R0,#+33
   \       0x2A   0xE01A             B.N      ??CrossCallReturnLabel_17
   1054            }
   1055          
   1056            // Initialize command
   1057            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_UNWRAP_KEY);
   \                     ??sl_se_export_key_1: (+1)
   \       0x2C   0xF04F 0x7281      MOV      R2,#+16908288
   \       0x30   0x.... 0x....      BL       ?Subroutine1
   1058          
   1059            // Add key parameters to command
   1060            sli_add_key_parameters(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x34   0xB9A8             CBNZ.N   R0,??CrossCallReturnLabel_17
   \       0x36   0x.... 0x....      BL       ?Subroutine3
   1061          
   1062            // Add key metadata block to command
   1063            sli_add_key_metadata(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x3A   0xA906             ADD      R1,SP,#+24
   \       0x3C   0x.... 0x....      BL       ??Subroutine11_0
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x40   0xB978             CBNZ.N   R0,??CrossCallReturnLabel_17
   \       0x42   0x.... 0x....      BL       ?Subroutine2
   1064          
   1065            // Add key input block to command
   1066            sli_add_key_input(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x46   0xA903             ADD      R1,SP,#+12
   \       0x48   0x.... 0x....      BL       ??Subroutine10_0
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x4C   0xB948             CBNZ.N   R0,??CrossCallReturnLabel_17
   \       0x4E   0xA903             ADD      R1,SP,#+12
   \       0x50   0x.... 0x....      BL       ??Subroutine2_0
   1067          
   1068            // Add key output block to command
   1069            sli_add_key_output(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x54   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x58   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_17
   \       0x5A   0x.... 0x....      BL       ?Subroutine7
   1070          
   1071            status = sli_se_execute_and_wait(cmd_ctx);
   1072          
   1073            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1074            // The SE will only output word-aligned data. Clear the extra padding before
   1075            // returning
   1076            if (status == SL_STATUS_OK) {
   1077              status = clear_padding(key_out);
   1078            }
   1079            #endif
   1080          
   1081            return status;
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x5E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x62   0xB00A             ADD      SP,SP,#+40
   \       0x64   0xBD70             POP      {R4-R6,PC}
   1082          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6022             STR      R2,[R4, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6060             STR      R0,[R4, #+4]
   \        0x6   0x60A0             STR      R0,[R4, #+8]
   \        0x8   0x61E0             STR      R0,[R4, #+28]
   \        0xA                      REQUIRE ??Subroutine13_0
   \        0xA                      ;; // Fall through to label ??Subroutine13_0
   1083          
   1084          /***************************************************************************//**
   1085           * Transfer a protected (volatile/wrapped) key
   1086           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1087          sl_status_t sl_se_transfer_key(sl_se_command_context_t *cmd_ctx,
   1088                                         const sl_se_key_descriptor_t *key_in,
   1089                                         const sl_se_key_descriptor_t *key_out)
   1090          {
   \                     sl_se_transfer_key: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB08D             SUB      SP,SP,#+52
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   1091            if (cmd_ctx == NULL || key_in == NULL || key_out == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2E00             CMPNE    R6,#+0
   \        0xE   0xD00E             BEQ.N    ??sl_se_transfer_key_0
   \       0x10   0xB16D             CBZ.N    R5,??sl_se_transfer_key_0
   1092              return SL_STATUS_INVALID_PARAMETER;
   1093            }
   1094          
   1095            SE_Command_t *se_cmd = &cmd_ctx->command;
   1096            sl_status_t status;
   1097            SE_DataTransfer_t auth_buffer_out;
   1098            uint32_t key_update_index;
   1099            uint32_t key_update_mode;
   1100          
   1101            // Check input/output key type and size relationship
   1102            status = sli_key_check_equivalent(key_in, key_out, true, false);
   \       0x12   0x.... 0x....      BL       ?Subroutine9
   1103            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD141             BNE.N    ??CrossCallReturnLabel_16
   1104              return status;
   1105            }
   1106          
   1107            if ((key_in->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1108                || (key_in->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)
   1109                || (key_out->storage.method == SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT)
   1110                || (key_out->storage.method == SL_SE_KEY_STORAGE_INTERNAL_IMMUTABLE)) {
   \       0x1A   0x68F0             LDR      R0,[R6, #+12]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xBF18             IT       NE
   \       0x20   0x2803             CMPNE    R0,#+3
   \       0x22   0xD004             BEQ.N    ??sl_se_transfer_key_0
   \       0x24   0x68E8             LDR      R0,[R5, #+12]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xBF18             IT       NE
   \       0x2A   0x2803             CMPNE    R0,#+3
   \       0x2C   0xD101             BNE.N    ??sl_se_transfer_key_1
   1111              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_transfer_key_0: (+1)
   \       0x2E   0x2021             MOVS     R0,#+33
   \       0x30   0xE035             B.N      ??CrossCallReturnLabel_16
   1112            }
   1113          
   1114            // Create command
   1115            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_TRANSFER_KEY);
   \                     ??sl_se_transfer_key_1: (+1)
   \       0x32   0xF04F 0x7283      MOV      R2,#+17170432
   \       0x36   0x.... 0x....      BL       ?Subroutine1
   1116          
   1117            // Add key input parameters to command
   1118            sli_add_key_parameters(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD12F             BNE.N    ??CrossCallReturnLabel_16
   \       0x3E   0x.... 0x....      BL       ?Subroutine3
   1119          
   1120            // Add key update parameters to command
   1121            uint32_t keyspec_out;
   1122            status = sli_se_key_to_keyspec(key_out, &keyspec_out);
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x42   0x.... 0x....      BL       ??Subroutine12_0
   1123            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD129             BNE.N    ??CrossCallReturnLabel_16
   1124              return status;
   1125            }
   1126            key_update_index = ((keyspec_out & KEYSPEC_INDEX_MASK) >> KEYSPEC_INDEX_OFFSET);
   1127            key_update_mode = ((keyspec_out & KEYSPEC_MODE_MASK) >> KEYSPEC_MODE_OFFSET);
   1128            keyspec_out = (keyspec_out & ~KEYSPEC_TRANSFER_INDEX_MASK)
   1129                          | ((key_update_index << KEYSPEC_TRANSFER_INDEX_OFFSET)
   1130                             & KEYSPEC_TRANSFER_INDEX_MASK);
   1131            keyspec_out = (keyspec_out & ~KEYSPEC_TRANSFER_MODE_MASK)
   1132                          | ((key_update_mode << KEYSPEC_TRANSFER_MODE_OFFSET)
   1133                             & KEYSPEC_TRANSFER_MODE_MASK);
   1134            keyspec_out = (keyspec_out & ~KEYSPEC_TRANSFER_PROT_BIT_MASK);
   \       0x4A   0x9900             LDR      R1,[SP, #+0]
   \       0x4C   0x9A00             LDR      R2,[SP, #+0]
   \       0x4E   0x....             LDR.N    R0,??DataTable6_2
   \       0x50   0x4001             ANDS     R1,R0,R1
   \       0x52   0xF3C2 0x4007      UBFX     R0,R2,#+16,#+8
   \       0x56   0x4301             ORRS     R1,R0,R1
   \       0x58   0x0C90             LSRS     R0,R2,#+18
   \       0x5A   0xF400 0x7040      AND      R0,R0,#0x300
   \       0x5E   0x4301             ORRS     R1,R0,R1
   \       0x60   0x9100             STR      R1,[SP, #+0]
   1135            SE_addParameter(se_cmd, keyspec_out);
   \       0x62   0x.... 0x....      BL       ??Subroutine3_0
   1136          
   1137            // Add key input metadata block to command
   1138            sli_add_key_metadata(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x66   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x6A   0xB9C0             CBNZ.N   R0,??CrossCallReturnLabel_16
   \       0x6C   0xA907             ADD      R1,SP,#+28
   \       0x6E   0x.... 0x....      BL       ??Subroutine2_0
   1139            // Add key input block to command
   1140            sli_add_key_input(cmd_ctx, key_in, status);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x72   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x76   0xB990             CBNZ.N   R0,??CrossCallReturnLabel_16
   \       0x78   0xA904             ADD      R1,SP,#+16
   \       0x7A   0x.... 0x....      BL       ??Subroutine2_0
   1141          
   1142            // Add key output metadata block to command
   1143            status = sli_se_get_auth_buffer(key_out, &auth_buffer_out);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x7E   0xA90A             ADD      R1,SP,#+40
   \       0x80   0x.... 0x....      BL       ?Subroutine5
   1144            if (status != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x84   0xB958             CBNZ.N   R0,??CrossCallReturnLabel_16
   1145              return status;
   1146            }
   1147            SE_addDataInput(se_cmd, &auth_buffer_out);
   \       0x86   0xA90A             ADD      R1,SP,#+40
   \       0x88   0x.... 0x....      BL       ??Subroutine2_0
   1148          
   1149            // Add key output block to command
   1150            sli_add_key_output(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x8C   0xA901             ADD      R1,SP,#+4
   \       0x8E   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x92   0xB920             CBNZ.N   R0,??CrossCallReturnLabel_16
   \       0x94   0xA901             ADD      R1,SP,#+4
   \       0x96   0x.... 0x....      BL       ??Subroutine7_0
   1151          
   1152            status = sli_se_execute_and_wait(cmd_ctx);
   1153          
   1154            #if defined(SLI_SE_KEY_PADDING_REQUIRED)
   1155            // Clear padding bytes for plaintext keys upon success
   1156            if (status == SL_STATUS_OK) {
   1157              status = clear_padding(key_out);
   1158            }
   1159            #endif
   1160          
   1161            return status;
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x9A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x9E   0xB00E             ADD      SP,SP,#+56
   \       0xA0   0xBD70             POP      {R4-R6,PC}
   1162          }
   1163          
   1164          /***************************************************************************//**
   1165           * Delete a key a volatile SE storage slot
   1166           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1167          sl_status_t sl_se_delete_key(sl_se_command_context_t *cmd_ctx,
   1168                                       const sl_se_key_descriptor_t *key)
   1169          {
   \                     sl_se_delete_key: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1170            sl_status_t status;
   1171          
   1172            if (cmd_ctx == NULL || key == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2D00             CMPNE    R5,#+0
   \        0xA   0xD101             BNE.N    ??sl_se_delete_key_0
   1173              return SL_STATUS_INVALID_PARAMETER;
   \        0xC   0x2021             MOVS     R0,#+33
   \        0xE   0xBD3E             POP      {R1-R5,PC}
   1174            }
   1175          
   1176            // Initialize command
   1177            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DELETE_KEY);
   \                     ??sl_se_delete_key_0: (+1)
   \       0x10   0x....             LDR.N    R2,??DataTable6_3
   \       0x12   0x.... 0x....      BL       ?Subroutine0
   1178          
   1179            // Add key parameters to command
   1180            sli_add_key_parameters(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x16   0xB950             CBNZ.N   R0,??CrossCallReturnLabel_15
   \       0x18   0x.... 0x....      BL       ?Subroutine3
   1181            // Add key metadata block to command
   1182            sli_add_key_metadata(cmd_ctx, key, status);
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x22   0xB920             CBNZ.N   R0,??CrossCallReturnLabel_15
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x.... 0x....      BL       ??Subroutine2_0
   1183          
   1184            // Execute command
   1185            status = sli_se_execute_and_wait(cmd_ctx);
   1186            return status;
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x2A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x2E   0xBD3E             POP      {R1-R5,PC}
   1187          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x2000'0008        DC32     0x20000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x0201'0000        DC32     0x2010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x001F'FC00        DC32     0x1ffc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x0105'0000        DC32     0x1050000
   1188          #endif
   1189          
   1190          /** @} (end addtogroup sl_se_key) */
   1191          
   1192          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   sl_se_delete_key
        24   -> SE_addDataInput
        24   -> SE_addParameter
        24   -> sli_se_execute_and_wait
        24   -> sli_se_get_auth_buffer
        24   -> sli_se_key_to_keyspec
      56   sl_se_export_key
        56   -> SE_addDataInput
        56   -> SE_addDataOutput
        56   -> SE_addParameter
        56   -> sli_key_check_equivalent
        56   -> sli_se_execute_and_wait
        56   -> sli_se_get_auth_buffer
        56   -> sli_se_get_key_input_output
        56   -> sli_se_key_to_keyspec
      56   sl_se_export_public_key
        56   -> SE_addDataInput
        56   -> SE_addDataOutput
        56   -> SE_addParameter
        56   -> sli_key_check_equivalent
        56   -> sli_key_get_storage_size
        56   -> sli_se_execute_and_wait
        56   -> sli_se_get_auth_buffer
        56   -> sli_se_get_key_input_output
        56   -> sli_se_key_to_keyspec
     120   sl_se_generate_key
       120   -> SE_addDataInput
       120   -> SE_addDataOutput
       120   -> SE_addParameter
       120   -> sli_se_execute_and_wait
       120   -> sli_se_get_auth_buffer
       120   -> sli_se_get_key_input_output
       120   -> sli_se_key_to_keyspec
      16   sl_se_get_storage_size
        16   -> sli_key_get_storage_size
      56   sl_se_import_key
        56   -> SE_addDataInput
        56   -> SE_addDataOutput
        56   -> SE_addParameter
        56   -> sli_key_check_equivalent
        56   -> sli_se_execute_and_wait
        56   -> sli_se_get_auth_buffer
        56   -> sli_se_get_key_input_output
        56   -> sli_se_key_to_keyspec
      72   sl_se_transfer_key
        72   -> SE_addDataInput
        72   -> SE_addDataOutput
        72   -> SE_addParameter
        72   -> sli_key_check_equivalent
        72   -> sli_se_execute_and_wait
        72   -> sli_se_get_auth_buffer
        72   -> sli_se_get_key_input_output
        72   -> sli_se_key_to_keyspec
      40   sl_se_validate_key
        40   -> sli_se_get_auth_buffer
        40   -> sli_se_get_key_input_output
        40   -> sli_se_key_to_keyspec
      32   sli_key_check_equivalent
        32   -> sli_key_get_size
       8   sli_key_get_size
      16   sli_key_get_storage_size
        16   -> sli_key_get_size
       0   sli_se_get_auth_buffer
      16   sli_se_get_key_input_output
        16   -> sli_key_get_storage_size
      24   sli_se_key_to_keyspec
        24   -> sli_key_get_size
      20   sli_se_keyspec_to_key


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       6  ??Subroutine12_0
       6  ??Subroutine13_0
      10  ?Subroutine0
      10  ?Subroutine1
       6  ?Subroutine10
       6  ?Subroutine11
       8  ?Subroutine2
       8  ?Subroutine3
       6  ?Subroutine4
       4  ?Subroutine5
       6  ?Subroutine6
       8  ?Subroutine7
       6  ?Subroutine8
      10  ?Subroutine9
      12  ?_0
       8  default_auth_data
      48  sl_se_delete_key
     102  sl_se_export_key
     208  sl_se_export_public_key
     208  sl_se_generate_key
      60  sl_se_get_storage_size
     102  sl_se_import_key
     162  sl_se_transfer_key
      48  sl_se_validate_key
     172  sli_key_check_equivalent
      96  sli_key_get_size
     122  sli_key_get_storage_size
      56  sli_se_get_auth_buffer
     100  sli_se_get_key_input_output
     414  sli_se_key_to_keyspec
     278  sli_se_keyspec_to_key

 
 2'312 bytes in section .text
 
 2'312 bytes of CODE memory

Errors: none
Warnings: none
