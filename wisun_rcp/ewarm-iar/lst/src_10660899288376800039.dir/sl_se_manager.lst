###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:58
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir\sl_se_manager.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD407             BMI.N    ??__NVIC_ClearPendingIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....             LDR.N    R3,??DataTable8
   \        0xE   0x0940             LSRS     R0,R0,#+5
   \       0x10   0xF843 0x2020      STR      R2,[R3, R0, LSL #+2]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x14   0x4770             BX       LR
     32          
     33          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED) || defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
     34          #if !defined(SL_CATALOG_TZ_SECURE_KEY_LIBRARY_NS_PRESENT)
     35          
     36          #include "sli_se_manager_internal.h"
     37          #include "em_se.h"
     38          #include "sl_assert.h"
     39          #if defined(_CMU_CLKEN1_SEMAILBOXHOST_MASK)
     40          #include "em_bus.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void BUS_RegBitWrite(uint32_t volatile *, unsigned int, unsigned int)
   \                     BUS_RegBitWrite: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x2D20             CMP      R5,#+32
   \        0xA   0xD303             BCC.N    ??BUS_RegBitWrite_0
   \        0xC   0x2191             MOVS     R1,#+145
   \        0xE   0x....             LDR.N    R0,??DataTable8_1
   \       0x10   0x.... 0x....      BL       assertEFM
   \                     ??BUS_RegBitWrite_0: (+1)
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xBF14             ITE      NE
   \       0x18   0xF506 0x5680      ADDNE    R6,R6,#+4096
   \       0x1C   0xF506 0x5600      ADDEQ    R6,R6,#+8192
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xFA00 0xF505      LSL      R5,R0,R5
   \       0x26   0x6035             STR      R5,[R6, #+0]
   \       0x28   0xBD70             POP      {R4-R6,PC}
     41          #endif
     42          #if !defined(SLI_SE_MANAGER_HOST_SYSTEM)
     43          #include "sli_se_manager_osal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t se_manager_osal_kernel_lock(void)
   \                     se_manager_osal_kernel_lock: (+1)
   \        0x0   0x.... 0x....      B.W      osKernelLock

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp int32_t se_manager_osal_kernel_restore_lock(int32_t)
   \                     se_manager_osal_kernel_restore_lock: (+1)
   \        0x0   0x.... 0x....      B.W      osKernelRestoreLock

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp osKernelState_t se_manager_osal_kernel_get_state(void)
   \                     se_manager_osal_kernel_get_state: (+1)
   \        0x0   0x.... 0x....      B.W      osKernelGetState
     44          #endif
     45          
     46          #include <string.h>
     47          
     48          /// @addtogroup sl_se_managers
     49          /// @{
     50          
     51          // -----------------------------------------------------------------------------
     52          // Locals
     53          
     54          #if defined(SL_SE_MANAGER_THREADING) \
     55            || defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
     56          
     57          // Flag to indicate that the SE Manager is initialized or not.

   \                                 In section .bss, align 1
     58          static volatile bool se_manager_initialized = false;
   \                     se_manager_initialized:
   \        0x0                      DS8 1
     59          
     60            #if defined(SL_SE_MANAGER_THREADING)
     61          // Lock mutex for synchronizing multiple threads calling into the
     62          // SE Manager API.

   \                                 In section .bss, align 4
     63          static se_manager_osal_mutex_t se_lock = { 0 };
   \                     se_lock:
   \        0x0                      DS8 100
     64          
     65            #define SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_START                     \
     66            int32_t kernel_lock_state = 0;                                           \
     67            osKernelState_t kernel_state = se_manager_osal_kernel_get_state();       \
     68            if (kernel_state != osKernelInactive && kernel_state != osKernelReady) { \
     69              kernel_lock_state = se_manager_osal_kernel_lock();                     \
     70              if (kernel_lock_state < 0) {                                           \
     71                return SL_STATUS_FAIL;                                               \
     72              }                                                                      \
     73            }
     74          
     75            #define SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_END                       \
     76            if (kernel_state != osKernelInactive && kernel_state != osKernelReady) { \
     77              if (se_manager_osal_kernel_restore_lock(kernel_lock_state) < 0) {      \
     78                return SL_STATUS_FAIL;                                               \
     79              }                                                                      \
     80            }
     81          
     82            #endif // SL_SE_MANAGER_THREADING
     83          
     84            #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
     85          // SE command completion.

   \                                 In section .data, align 4
     86          static se_manager_osal_completion_t se_command_completion;
   \                     se_command_completion:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4                      DS8 4
   \        0x8   0x0000'0000        DC32 0x0
   \        0xC                      DS8 4
   \       0x10   0x0000'0000        DC32 0x0, 0x0, 0x0, 0x0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20                      DS8 4
   \       0x24   0x0000'0000        DC32 0x0
   \       0x28                      DS8 4
   \       0x2C   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0x34                      DS8 4
   \       0x38   0x0000'0000        DC32 0x0
   \       0x3C                      DS8 4
   \       0x40   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0x48                      DS8 24
   \       0x60   0x0000'0000        DC32 0x0
   \       0x64                      DS8 0
   \       0x64   0x0005'0000        DC32 327'680
     87          // SE mailbox command response code. This value is read from the SEMAILBOX
     88          // in ISR in order to clear the command complete interrupt condition.
     89          static SE_Response_t se_manager_command_response = SLI_SE_RESPONSE_INTERNAL_ERROR;
     90            #endif // SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION
     91          
     92          #endif // #if defined (SL_SE_MANAGER_THREADING)
     93          //   || defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
     94          
     95          // -----------------------------------------------------------------------------
     96          // Global functions
     97          
     98          /***************************************************************************//**
     99           * Initialize the SE Manager.
    100           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    101          sl_status_t sl_se_init(void)
    102          {
   \                     sl_se_init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    103            sl_status_t ret = SL_STATUS_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    104            #if defined (SL_SE_MANAGER_THREADING) \
    105            || defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    106          
    107            #if defined(SL_SE_MANAGER_THREADING)
    108            SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_START
   \        0x6   0x.... 0x....      BL       se_manager_osal_kernel_get_state
   \        0xA   0x46A8             MOV      R8,R5
   \        0xC   0x0004             MOVS     R4,R0
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2C01             CMPNE    R4,#+1
   \       0x12   0xD004             BEQ.N    ??sl_se_init_0
   \       0x14   0x.... 0x....      BL       se_manager_osal_kernel_lock
   \       0x18   0xEA5F 0x0800      MOVS     R8,R0
   \       0x1C   0xD42D             BMI.N    ??sl_se_init_1
    109            #endif
    110          
    111            if ( !se_manager_initialized ) {
   \                     ??sl_se_init_0: (+1)
   \       0x1E   0x....             LDR.N    R7,??DataTable8_2
   \       0x20   0x7838             LDRB     R0,[R7, #+0]
   \       0x22   0xBB08             CBNZ.N   R0,??sl_se_init_2
    112                #if defined(SL_SE_MANAGER_THREADING)
    113              // Initialize SE lock
    114              ret = se_manager_osal_init_mutex(&se_lock);
   \       0x24   0x....             LDR.N    R6,??DataTable8_3
   \       0x26   0x2300             MOVS     R3,#+0
   \       0x28   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0x.... 0x....      BL       osMutexNew
   \       0x32   0xB170             CBZ.N    R0,??sl_se_init_3
   \       0x34   0x6630             STR      R0,[R6, #+96]
    115                #endif
    116                #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    117              if (ret == SL_STATUS_OK) {
    118                // Initialize command completion object.
    119                ret = se_manager_osal_init_completion(&se_command_completion);
   \       0x36   0x....             LDR.N    R6,??DataTable8_4
   \       0x38   0x2300             MOVS     R3,#+0
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x40   0x4632             MOV      R2,R6
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x.... 0x....      BL       osSemaphoreNew
   \       0x4A   0x6630             STR      R0,[R6, #+96]
   \       0x4C   0xB920             CBNZ.N   R0,??sl_se_init_4
   \       0x4E   0x2501             MOVS     R5,#+1
   \       0x50   0xE00A             B.N      ??sl_se_init_2
   \                     ??sl_se_init_3: (+1)
   \       0x52   0x2501             MOVS     R5,#+1
   \       0x54   0x6630             STR      R0,[R6, #+96]
   \       0x56   0xE007             B.N      ??sl_se_init_2
    120                if (ret == SL_STATUS_OK) {
    121                  // Enable SE RX mailbox interrupt in NVIC, but not in SEMAILBOX
    122                  // which will be enabled if the yield parameter in
    123                  // sli_se_execute_and_wait is true.
    124                  NVIC_SetPriority(SEMBRX_IRQn, SE_MANAGER_SEMBRX_IRQ_PRIORITY);
   \                     ??sl_se_init_4: (+1)
   \       0x58   0x2330             MOVS     R3,#+48
   \       0x5A   0x....             LDR.N    R2,??DataTable8_5
   \       0x5C   0x7013             STRB     R3,[R2, #+0]
    125                  NVIC_EnableIRQ(SEMBRX_IRQn);
   \       0x5E   0x2108             MOVS     R1,#+8
   \       0x60   0x....             LDR.N    R0,??DataTable8_6
   \       0x62   0x6001             STR      R1,[R0, #+0]
    126                }
    127              }
    128                #endif // SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION
    129              if (ret == SL_STATUS_OK) {
    130                se_manager_initialized = true;
   \       0x64   0x2301             MOVS     R3,#+1
   \       0x66   0x703B             STRB     R3,[R7, #+0]
    131              }
    132            }
    133          
    134            #if defined(SL_SE_MANAGER_THREADING)
    135            SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_END
   \                     ??sl_se_init_2: (+1)
   \       0x68   0x2C00             CMP      R4,#+0
   \       0x6A   0xBF18             IT       NE
   \       0x6C   0x2C01             CMPNE    R4,#+1
   \       0x6E   0xD006             BEQ.N    ??sl_se_init_5
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x.... 0x....      BL       se_manager_osal_kernel_restore_lock
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD501             BPL.N    ??sl_se_init_5
   \                     ??sl_se_init_1: (+1)
   \       0x7A   0x2001             MOVS     R0,#+1
   \       0x7C   0xE000             B.N      ??sl_se_init_6
    136            #endif
    137          
    138            #endif // #if defined (SL_SE_MANAGER_THREADING)
    139            //   || defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    140          
    141            return ret;
   \                     ??sl_se_init_5: (+1)
   \       0x7E   0x4628             MOV      R0,R5
   \                     ??sl_se_init_6: (+1)
   \       0x80   0xE8BD 0x81F0      POP      {R4-R8,PC}
    142          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0xE886 0x000F      STM      R6,{R0-R3}
   \        0x8   0xF106 0x0110      ADD      R1,R6,#+16
   \        0xC   0x60B1             STR      R1,[R6, #+8]
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0x60F0             STR      R0,[R6, #+12]
   \       0x12   0x4770             BX       LR
    143          
    144          /***************************************************************************//**
    145           * Denitialize the SE Manager.
    146           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          sl_status_t sl_se_deinit(void)
    148          {
   \                     sl_se_deinit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    149            sl_status_t ret = SL_STATUS_OK;
   \        0x2   0x2500             MOVS     R5,#+0
    150          
    151            #if defined (SL_SE_MANAGER_THREADING) \
    152            || defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    153          
    154            #if defined(SL_SE_MANAGER_THREADING)
    155            SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_START
   \        0x4   0x2700             MOVS     R7,#+0
   \        0x6   0x.... 0x....      BL       se_manager_osal_kernel_get_state
   \        0xA   0x0004             MOVS     R4,R0
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2C01             CMPNE    R4,#+1
   \       0x10   0xD003             BEQ.N    ??sl_se_deinit_0
   \       0x12   0x.... 0x....      BL       osKernelLock
   \       0x16   0x0007             MOVS     R7,R0
   \       0x18   0xD431             BMI.N    ??sl_se_deinit_1
    156            #endif
    157          
    158            if ( se_manager_initialized ) {
   \                     ??sl_se_deinit_0: (+1)
   \       0x1A   0x....             LDR.N    R6,??DataTable8_2
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0xB328             CBZ.N    R0,??sl_se_deinit_2
    159              // We need to exit the critical section in case the SE lock is held by a
    160              // thread, and we want to take it before de-initializing.
    161              #if defined(SL_SE_MANAGER_THREADING)
    162              SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_END
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xBF18             IT       NE
   \       0x24   0x2C01             CMPNE    R4,#+1
   \       0x26   0xD004             BEQ.N    ??sl_se_deinit_3
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0x.... 0x....      BL       se_manager_osal_kernel_restore_lock
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD425             BMI.N    ??sl_se_deinit_1
    163              #endif
    164          
    165              // Acquire the SE lock to make sure no thread is executing SE commands
    166              // when we de-initialize.
    167              ret = sli_se_lock_acquire();
   \                     ??sl_se_deinit_3: (+1)
   \       0x32   0x.... 0x....      BL       sli_se_lock_acquire
   \       0x36   0x0005             MOVS     R5,R0
    168              if (ret != SL_STATUS_OK) {
   \       0x38   0xD116             BNE.N    ??sl_se_deinit_4
    169                return ret;
    170              }
    171          
    172                #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    173              // Disable SE RX mailbox interrupt in NVIC.
    174              NVIC_ClearPendingIRQ(SEMBRX_IRQn);
   \       0x3A   0x2043             MOVS     R0,#+67
   \       0x3C   0x.... 0x....      BL       __NVIC_ClearPendingIRQ
    175              NVIC_DisableIRQ(SEMBRX_IRQn);
   \       0x40   0x2108             MOVS     R1,#+8
   \       0x42   0x....             LDR.N    R0,??DataTable8_7
   \       0x44   0x6001             STR      R1,[R0, #+0]
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0xF3BF 0x8F6F      ISB      SY
    176              // Free command completion object.
    177              ret = se_manager_osal_free_completion(&se_command_completion);
   \       0x4E   0x....             LDR.N    R2,??DataTable8_4
   \       0x50   0x6E10             LDR      R0,[R2, #+96]
   \       0x52   0x.... 0x....      BL       osSemaphoreDelete
   \       0x56   0xB920             CBNZ.N   R0,??sl_se_deinit_5
    178                #endif // SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION
    179          
    180                #if defined(SL_SE_MANAGER_THREADING)
    181              if (ret == SL_STATUS_OK) {
    182                // Free the SE lock mutex
    183                ret = se_manager_osal_free_mutex(&se_lock);
   \       0x58   0x....             LDR.N    R0,??DataTable8_3
   \       0x5A   0x6E00             LDR      R0,[R0, #+96]
   \       0x5C   0x.... 0x....      BL       osMutexDelete
   \       0x60   0xB100             CBZ.N    R0,??sl_se_deinit_6
   \                     ??sl_se_deinit_5: (+1)
   \       0x62   0x2501             MOVS     R5,#+1
    184              }
    185                #endif
    186          
    187              // Mark the SE Manager as un-initialized.
    188              se_manager_initialized = false;
   \                     ??sl_se_deinit_6: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x7030             STRB     R0,[R6, #+0]
    189            }
    190            #if defined(SL_SE_MANAGER_THREADING)
    191            else {
    192              SLI_SE_MANAGER_KERNEL_CRITICAL_SECTION_END
    193            }
    194            #endif
    195          
    196            #endif // #if defined (SL_SE_MANAGER_THREADING)
    197            //   || defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    198          
    199            return ret;
   \                     ??sl_se_deinit_4: (+1)
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??sl_se_deinit_2: (+1)
   \       0x6C   0x2C00             CMP      R4,#+0
   \       0x6E   0xBF18             IT       NE
   \       0x70   0x2C01             CMPNE    R4,#+1
   \       0x72   0xD0F9             BEQ.N    ??sl_se_deinit_4
   \       0x74   0x4638             MOV      R0,R7
   \       0x76   0x.... 0x....      BL       osKernelRestoreLock
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD5F4             BPL.N    ??sl_se_deinit_4
   \                     ??sl_se_deinit_1: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xBDF2             POP      {R1,R4-R7,PC}
    200          }
    201          
    202          /***************************************************************************//**
    203           * @brief
    204           *   Translate SE response codes to sl_status_t codes.
    205           *
    206           * @return
    207           *   Status code, @ref sl_status.h.
    208           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          sl_status_t sli_se_to_sl_status(SE_Response_t res)
    210          {
   \                     sli_se_to_sl_status: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD100             BNE.N    ??sli_se_to_sl_status_0
   \        0x4   0x4770             BX       LR
   \                     ??sli_se_to_sl_status_0: (+1)
   \        0x6   0xB580             PUSH     {R7,LR}
    211            switch (res) {
   \        0x8   0xF5B0 0x3F80      CMP      R0,#+65536
   \        0xC   0xD01B             BEQ.N    ??sli_se_to_sl_status_1
   \        0xE   0xF5B0 0x3F00      CMP      R0,#+131072
   \       0x12   0xD01A             BEQ.N    ??sli_se_to_sl_status_2
   \       0x14   0xF5B0 0x3F40      CMP      R0,#+196608
   \       0x18   0xD019             BEQ.N    ??sli_se_to_sl_status_3
   \       0x1A   0xF5B0 0x2F80      CMP      R0,#+262144
   \       0x1E   0xD018             BEQ.N    ??sli_se_to_sl_status_4
   \       0x20   0xF5B0 0x2FA0      CMP      R0,#+327680
   \       0x24   0xBF18             IT       NE
   \       0x26   0xF5B0 0x2FC0      CMPNE    R0,#+393216
   \       0x2A   0xD020             BEQ.N    ??sli_se_to_sl_status_5
   \       0x2C   0xF5B0 0x2FE0      CMP      R0,#+458752
   \       0x30   0xD011             BEQ.N    ??sli_se_to_sl_status_6
   \       0x32   0xF5B0 0x2F20      CMP      R0,#+655360
   \       0x36   0xD012             BEQ.N    ??sli_se_to_sl_status_7
   \       0x38   0xF5B0 0x2F30      CMP      R0,#+720896
   \       0x3C   0xD011             BEQ.N    ??sli_se_to_sl_status_8
   \       0x3E   0xF5B0 0x0F7F      CMP      R0,#+16711680
   \       0x42   0xD00A             BEQ.N    ??sli_se_to_sl_status_9
   \       0x44   0xE00F             B.N      ??sli_se_to_sl_status_10
    212              case SLI_SE_RESPONSE_OK:
    213                return SL_STATUS_OK;
    214              case SLI_SE_RESPONSE_INVALID_COMMAND:
    215                return SL_STATUS_COMMAND_IS_INVALID;
   \                     ??sli_se_to_sl_status_1: (+1)
   \       0x46   0x2048             MOVS     R0,#+72
   \       0x48   0xBD02             POP      {R1,PC}
    216              case SLI_SE_RESPONSE_AUTHORIZATION_ERROR:
    217                return SL_STATUS_INVALID_CREDENTIALS;
   \                     ??sli_se_to_sl_status_2: (+1)
   \       0x4A   0x202A             MOVS     R0,#+42
   \       0x4C   0xBD02             POP      {R1,PC}
    218              case SLI_SE_RESPONSE_INVALID_SIGNATURE:
    219                return SL_STATUS_INVALID_SIGNATURE;
   \                     ??sli_se_to_sl_status_3: (+1)
   \       0x4E   0x202C             MOVS     R0,#+44
   \       0x50   0xBD02             POP      {R1,PC}
    220              case SLI_SE_RESPONSE_BUS_ERROR:
    221                return SL_STATUS_BUS_ERROR;
   \                     ??sli_se_to_sl_status_4: (+1)
   \       0x52   0x204B             MOVS     R0,#+75
   \       0x54   0xBD02             POP      {R1,PC}
    222              case SLI_SE_RESPONSE_INTERNAL_ERROR:
    223                return SL_STATUS_FAIL;
    224              case SLI_SE_RESPONSE_CRYPTO_ERROR:
    225                return SL_STATUS_FAIL;
    226              case SLI_SE_RESPONSE_INVALID_PARAMETER:
    227                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sli_se_to_sl_status_6: (+1)
   \       0x56   0x2021             MOVS     R0,#+33
   \       0x58   0xBD02             POP      {R1,PC}
    228              case SLI_SE_RESPONSE_ABORT:
    229                return SL_STATUS_ABORT;
   \                     ??sli_se_to_sl_status_9: (+1)
   \       0x5A   0x2006             MOVS     R0,#+6
   \       0x5C   0xBD02             POP      {R1,PC}
    230              case SLI_SE_RESPONSE_SELFTEST_ERROR:
    231                return SL_STATUS_INITIALIZATION;
   \                     ??sli_se_to_sl_status_7: (+1)
   \       0x5E   0x2010             MOVS     R0,#+16
   \       0x60   0xBD02             POP      {R1,PC}
    232              case SLI_SE_RESPONSE_NOT_INITIALIZED:
    233                return SL_STATUS_NOT_INITIALIZED;
   \                     ??sli_se_to_sl_status_8: (+1)
   \       0x62   0x2011             MOVS     R0,#+17
   \       0x64   0xBD02             POP      {R1,PC}
    234          #if defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)
    235              case SLI_SE_RESPONSE_MAILBOX_INVALID:
    236                return SL_STATUS_COMMAND_IS_INVALID;
    237          #endif
    238              default:
    239                // Assert we do not get a bad SE response code.
    240                EFM_ASSERT(false);
   \                     ??sli_se_to_sl_status_10: (+1)
   \       0x66   0x21F0             MOVS     R1,#+240
   \       0x68   0x....             LDR.N    R0,??DataTable8_8
   \       0x6A   0x.... 0x....      BL       assertEFM
   \                     ??sli_se_to_sl_status_5: (+1)
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xBD02             POP      {R1,PC}
    241                return SL_STATUS_FAIL;
    242            }
    243          }
    244          
    245          /***************************************************************************//**
    246           * Acquire the SE lock for exclusive access if necessary (thread mode).
    247           * Enable the SEMAILBOX clock if necessary.
    248           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    249          sl_status_t sli_se_lock_acquire(void)
    250          {
   \                     sli_se_lock_acquire: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    251            #if defined(SL_SE_MANAGER_THREADING)
    252            sl_status_t status = se_manager_osal_take_mutex(&se_lock);
   \        0x2   0x.... 0x....      BL       osKernelGetState
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD106             BNE.N    ??sli_se_lock_acquire_0
   \        0xA   0x....             LDR.N    R0,??DataTable8_3
   \        0xC   0x6E00             LDR      R0,[R0, #+96]
   \        0xE   0xF04F 0x31FF      MOV      R1,#+4294967295
   \       0x12   0x.... 0x....      BL       osMutexAcquire
   \       0x16   0xB930             CBNZ.N   R0,??sli_se_lock_acquire_1
    253            #else
    254            sl_status_t status = SL_STATUS_OK;
    255            #endif
    256            #if defined(_CMU_CLKEN1_SEMAILBOXHOST_MASK)
    257            if (status == SL_STATUS_OK) {
    258              BUS_RegBitWrite(&CMU->CLKEN1, _CMU_CLKEN1_SEMAILBOXHOST_SHIFT, 1);
   \                     ??sli_se_lock_acquire_0: (+1)
   \       0x18   0x2201             MOVS     R2,#+1
   \       0x1A   0x210A             MOVS     R1,#+10
   \       0x1C   0x....             LDR.N    R0,??DataTable8_9
   \       0x1E   0x2400             MOVS     R4,#+0
   \       0x20   0x.... 0x....      BL       BUS_RegBitWrite
   \       0x24   0xE000             B.N      ??sli_se_lock_acquire_2
    259            }
   \                     ??sli_se_lock_acquire_1: (+1)
   \       0x26   0x2401             MOVS     R4,#+1
    260            #endif
    261            return status;
   \                     ??sli_se_lock_acquire_2: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0xBD10             POP      {R4,PC}
    262          }
    263          
    264          /***************************************************************************//**
    265           * Release the SE lock if necessary (thread mode).
    266           * Disable the SEMAILBOX clock if necessary.
    267           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    268          sl_status_t sli_se_lock_release(void)
    269          {
   \                     sli_se_lock_release: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    270            #if defined(_CMU_CLKEN1_SEMAILBOXHOST_MASK)
    271            BUS_RegBitWrite(&CMU->CLKEN1, _CMU_CLKEN1_SEMAILBOXHOST_SHIFT, 0);
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x210A             MOVS     R1,#+10
   \        0x6   0x....             LDR.N    R0,??DataTable8_9
   \        0x8   0x.... 0x....      BL       BUS_RegBitWrite
    272            #endif
    273            #if defined(SL_SE_MANAGER_THREADING)
    274            return se_manager_osal_give_mutex(&se_lock);
   \        0xC   0x.... 0x....      BL       osKernelGetState
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xD106             BNE.N    ??sli_se_lock_release_0
   \       0x14   0x....             LDR.N    R0,??DataTable8_3
   \       0x16   0x6E00             LDR      R0,[R0, #+96]
   \       0x18   0x.... 0x....      BL       osMutexRelease
   \       0x1C   0xB110             CBZ.N    R0,??sli_se_lock_release_1
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD02             POP      {R1,PC}
   \                     ??sli_se_lock_release_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \                     ??sli_se_lock_release_1: (+1)
   \       0x24   0xBD02             POP      {R1,PC}
    275            #else
    276            return SL_STATUS_OK;
    277            #endif
    278          }
    279          
    280          #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    281          
    282          /***************************************************************************//**
    283           * @brief
    284           *   SE Mailbox Interrupt Service Routine
    285           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    286          void SEMBRX_IRQHandler(void)
    287          {
   \                     SEMBRX_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    288            sl_status_t status;
    289            // Check if the SE mailbox is the source of the interrupt.
    290            if (SEMAILBOX_HOST->RX_STATUS & SEMAILBOX_RX_STATUS_RXINT) {
   \        0x2   0x....             LDR.N    R5,??DataTable8_10
   \        0x4   0x6829             LDR      R1,[R5, #+0]
   \        0x6   0x....             LDR.N    R4,??DataTable8_4
   \        0x8   0x02C8             LSLS     R0,R1,#+11
   \        0xA   0xD50E             BPL.N    ??SEMBRX_IRQHandler_0
    291              // Signal SE mailbox completion.
    292              status = se_manager_osal_complete(&se_command_completion);
   \        0xC   0x.... 0x....      BL       osKernelGetState
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xBF18             IT       NE
   \       0x14   0x2803             CMPNE    R0,#+3
   \       0x16   0xD108             BNE.N    ??SEMBRX_IRQHandler_0
   \       0x18   0x6E20             LDR      R0,[R4, #+96]
   \       0x1A   0x.... 0x....      BL       osSemaphoreRelease
   \       0x1E   0xB120             CBZ.N    R0,??SEMBRX_IRQHandler_0
   \       0x20   0xF240 0x1125      MOVW     R1,#+293
   \       0x24   0x....             LDR.N    R0,??DataTable8_8
   \       0x26   0x.... 0x....      BL       assertEFM
   \                     ??SEMBRX_IRQHandler_0: (+1)
   \       0x2A   0x6829             LDR      R1,[R5, #+0]
   \       0x2C   0x02C8             LSLS     R0,R1,#+11
   \       0x2E   0xD5FC             BPL.N    ??SEMBRX_IRQHandler_0
   \       0x30   0x6929             LDR      R1,[R5, #+16]
    293              EFM_ASSERT(status == SL_STATUS_OK);
    294            }
    295            // Get command response (clears interrupt condition in SEMAILBOX)
    296            se_manager_command_response = SE_readCommandResponse();
    297            // Clear interrupt condition in NVIC
    298            NVIC_ClearPendingIRQ(SEMBRX_IRQn);
   \       0x32   0x2043             MOVS     R0,#+67
   \       0x34   0xF401 0x2170      AND      R1,R1,#0xF0000
   \       0x38   0x6661             STR      R1,[R4, #+100]
   \       0x3A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x3E   0x....             B.N      __NVIC_ClearPendingIRQ
    299          }
    300          
    301          #endif // #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    302          
    303          /***************************************************************************//**
    304           * Set the yield attribute of the SE command context object.
    305           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    306          sl_status_t sl_se_set_yield(sl_se_command_context_t *cmd_ctx,
    307                                      bool yield)
    308          {
    309            if (cmd_ctx == NULL) {
   \                     sl_se_set_yield: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??sl_se_set_yield_0
    310              return SL_STATUS_INVALID_PARAMETER;
   \        0x2   0x2021             MOVS     R0,#+33
   \        0x4   0x4770             BX       LR
    311            }
    312          
    313            #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    314            cmd_ctx->yield = yield;
   \                     ??sl_se_set_yield_0: (+1)
   \        0x6   0xF880 0x1020      STRB     R1,[R0, #+32]
    315            return SL_STATUS_OK;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    316            #else
    317            if (yield) {
    318              return SL_STATUS_NOT_AVAILABLE;
    319            } else {
    320              (void) cmd_ctx;
    321              return SL_STATUS_OK;
    322            }
    323            #endif
    324          }
    325          
    326          /***************************************************************************//**
    327           * @brief
    328           *   Execute and wait for SE mailbox command to complete.
    329           *
    330           * @return
    331           *   Status code, @ref sl_status.h.
    332           ******************************************************************************/
    333          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED) && !defined(SLI_SE_MANAGER_HOST_SYSTEM)

   \                                 In section .text, align 2, keep-with-next
    334          sl_status_t sli_se_execute_and_wait(sl_se_command_context_t *cmd_ctx)
    335          {
   \                     sli_se_execute_and_wait: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
    336            sl_status_t status;
    337            SE_Response_t command_response;
    338          
    339            if (cmd_ctx == NULL) {
   \        0x4   0xD101             BNE.N    ??sli_se_execute_and_wait_0
    340              return SL_STATUS_INVALID_PARAMETER;
   \        0x6   0x2021             MOVS     R0,#+33
   \        0x8   0xBD70             POP      {R4-R6,PC}
    341            }
    342          
    343            // Try to acquire SE lock
    344            status = sli_se_lock_acquire();
   \                     ??sli_se_execute_and_wait_0: (+1)
   \        0xA   0x.... 0x....      BL       sli_se_lock_acquire
   \        0xE   0x0004             MOVS     R4,R0
    345            if (status != SL_STATUS_OK) {
   \       0x10   0xD12F             BNE.N    ??sli_se_execute_and_wait_1
    346              return status;
    347            }
    348          
    349            // Execute SE mailbox command
    350            SE_executeCommand(&cmd_ctx->command);
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       SE_executeCommand
    351          
    352            #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    353            if (cmd_ctx->yield) {
   \       0x18   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x1C   0x....             LDR.N    R6,??DataTable8_10
   \       0x1E   0xB1D8             CBZ.N    R0,??sli_se_execute_and_wait_2
    354              // Enable SEMAILBOX RXINT interrupt
    355              SE_enableInterrupt(SEMAILBOX_CONFIGURATION_RXINTEN);
   \       0x20   0x6970             LDR      R0,[R6, #+20]
    356          
    357              // Yield and Wait for the command completion signal
    358              status = se_manager_osal_wait_completion(&se_command_completion,
    359                                                       SE_MANAGER_OSAL_WAIT_FOREVER);
   \       0x22   0x....             LDR.N    R5,??DataTable8_4
   \       0x24   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x28   0x6170             STR      R0,[R6, #+20]
   \       0x2A   0x.... 0x....      BL       osKernelGetState
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD106             BNE.N    ??sli_se_execute_and_wait_3
   \       0x32   0x6E28             LDR      R0,[R5, #+96]
   \       0x34   0xF04F 0x31FF      MOV      R1,#+4294967295
   \       0x38   0x.... 0x....      BL       osSemaphoreAcquire
   \       0x3C   0xB100             CBZ.N    R0,??sli_se_execute_and_wait_3
   \       0x3E   0x2401             MOVS     R4,#+1
    360          
    361              // Disable SEMAILBOX RXINT interrupt.
    362              SE_disableInterrupt(SEMAILBOX_CONFIGURATION_RXINTEN);
   \                     ??sli_se_execute_and_wait_3: (+1)
   \       0x40   0x6970             LDR      R0,[R6, #+20]
   \       0x42   0xF020 0x0002      BIC      R0,R0,#0x2
   \       0x46   0x6170             STR      R0,[R6, #+20]
    363          
    364              if (status != SL_STATUS_OK) {
   \       0x48   0xB10C             CBZ.N    R4,??sli_se_execute_and_wait_4
    365                return status;
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0xBD70             POP      {R4-R6,PC}
    366              }
    367          
    368              // Get response which is read in the ISR to clear interrupt condition.
    369              command_response = se_manager_command_response;
   \                     ??sli_se_execute_and_wait_4: (+1)
   \       0x4E   0x6E6C             LDR      R4,[R5, #+100]
    370              // Default to an error.
    371              se_manager_command_response = SLI_SE_RESPONSE_INTERNAL_ERROR;
   \       0x50   0xF44F 0x20A0      MOV      R0,#+327680
   \       0x54   0x6668             STR      R0,[R5, #+100]
   \       0x56   0xE005             B.N      ??sli_se_execute_and_wait_5
    372            } else {
   \                     ??sli_se_execute_and_wait_2: (+1)
   \       0x58   0x6831             LDR      R1,[R6, #+0]
   \       0x5A   0x02C8             LSLS     R0,R1,#+11
   \       0x5C   0xD5FC             BPL.N    ??sli_se_execute_and_wait_2
   \       0x5E   0x6934             LDR      R4,[R6, #+16]
   \       0x60   0xF404 0x2470      AND      R4,R4,#0xF0000
    373              // Wait for command completion and get command response
    374              command_response = SE_readCommandResponse();
    375            }
    376          
    377            #else // #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    378          
    379            // Wait for command completion and get command response
    380            command_response = SE_readCommandResponse();
    381          
    382            #endif // #if defined(SL_SE_MANAGER_YIELD_WHILE_WAITING_FOR_COMMAND_COMPLETION)
    383          
    384            // Release SE lock
    385            status = sli_se_lock_release();
   \                     ??sli_se_execute_and_wait_5: (+1)
   \       0x64   0x.... 0x....      BL       sli_se_lock_release
    386          
    387            // Return sl_status_t code.
    388            if (command_response == SLI_SE_RESPONSE_OK) {
   \       0x68   0xB11C             CBZ.N    R4,??sli_se_execute_and_wait_1
    389              return status;
    390            } else {
    391              // Convert from SE_Response_t to sl_status_t code and return.
    392              return sli_se_to_sl_status(command_response);
   \       0x6A   0x4620             MOV      R0,R4
   \       0x6C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x70   0x....             B.N      sli_se_to_sl_status
    393            }
   \                     ??sli_se_execute_and_wait_1: (+1)
   \       0x72   0xBD70             POP      {R4-R6,PC}
    394          }
    395          
    396          #elif defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED) // SLI_MAILBOX_COMMAND_SUPPORTED
    397          
    398          sl_status_t sli_se_execute_and_wait(sl_se_command_context_t *cmd_ctx)
    399          {
    400            sl_status_t status;
    401          
    402            if (cmd_ctx == NULL) {
    403              return SL_STATUS_INVALID_PARAMETER;
    404            }
    405          
    406            // Try to acquire SE lock
    407            status = sli_se_lock_acquire();
    408            if (status != SL_STATUS_OK) {
    409              return status;
    410            }
    411          
    412            // Execute SE mailbox command
    413            SE_executeCommand(&cmd_ctx->command);
    414          
    415            return SL_STATUS_FAIL; // Should never get to this point
    416          }
    417          
    418          /***************************************************************************//**
    419           * From VSE mailbox read which command, if any, was executed.
    420           ******************************************************************************/
    421          sl_status_t sl_se_read_executed_command(sl_se_command_context_t *cmd_ctx)
    422          {
    423            sl_status_t status;
    424          
    425            if (cmd_ctx == NULL) {
    426              return SL_STATUS_INVALID_PARAMETER;
    427            }
    428          
    429            // Try to acquire SE lock
    430            status = sli_se_lock_acquire();
    431            if (status != SL_STATUS_OK) {
    432              return status;
    433            }
    434          
    435            // Read command
    436            cmd_ctx->command.command = SE_readExecutedCommand();
    437          
    438            // Release SE lock
    439            status = sli_se_lock_release();
    440          
    441            // Return sl_status_t code.
    442            if (cmd_ctx->command.command == SE_RESPONSE_MAILBOX_INVALID) {
    443              // Convert from SE_Response_t to sl_status_t code and return.
    444              return sli_se_to_sl_status(SE_RESPONSE_MAILBOX_INVALID);
    445            } else {
    446              return status;
    447            }
    448          }
    449          
    450          /***************************************************************************//**
    451           * Acknowledge and get status and output data of a completed command.
    452           ******************************************************************************/
    453          sl_status_t sl_se_ack_command(sl_se_command_context_t *cmd_ctx)
    454          {
    455            sl_status_t status;
    456            SE_Response_t command_response;
    457          
    458            if (cmd_ctx == NULL) {
    459              return SL_STATUS_INVALID_PARAMETER;
    460            }
    461          
    462            // Try to acquire SE lock
    463            status = sli_se_lock_acquire();
    464            if (status != SL_STATUS_OK) {
    465              return status;
    466            }
    467          
    468            // Acknowledge VSE mailbox command
    469            command_response = SE_ackCommand(&cmd_ctx->command);
    470          
    471            // Release SE lock
    472            status = sli_se_lock_release();
    473          
    474            // Return sl_status_t code.
    475            if (command_response == SLI_SE_RESPONSE_OK) {
    476              return status;
    477            } else {
    478              // Convert from SE_Response_t to sl_status_t code and return.
    479              return sli_se_to_sl_status(command_response);
    480            }
    481          }
    482          
    483          #endif // SLI_VSE_MAILBOX_COMMAND_SUPPORTED
    484          
    485          #endif // !SL_CATALOG_TZ_SECURE_KEY_LIBRARY_NS_PRESENT
    486          
    487          /***************************************************************************//**
    488           * Initialize an SE command context object
    489           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    490          sl_status_t sl_se_init_command_context(sl_se_command_context_t *cmd_ctx)
    491          {
   \                     sl_se_init_command_context: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    492            sl_se_command_context_t v = SL_SE_COMMAND_CONTEXT_INIT;
    493          
    494            if (cmd_ctx == NULL) {
   \        0x2   0xB908             CBNZ.N   R0,??sl_se_init_command_context_0
    495              return SL_STATUS_INVALID_PARAMETER;
   \        0x4   0x2021             MOVS     R0,#+33
   \        0x6   0xBD02             POP      {R1,PC}
    496            }
    497          
    498            *cmd_ctx = v;
   \                     ??sl_se_init_command_context_0: (+1)
   \        0x8   0x....             B.N      ?Subroutine0
    499            return SL_STATUS_OK;
    500          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2124             MOVS     R1,#+36
   \        0x2   0x.... 0x....      BL       __aeabi_memclr4
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0x0, 0x0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x20   0x00               DC8 0
   \       0x21                      DS8 3
    501          
    502          /***************************************************************************//**
    503           * De-initialize an SE command context object
    504           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    505          sl_status_t sl_se_deinit_command_context(sl_se_command_context_t *cmd_ctx)
    506          {
   \                     sl_se_deinit_command_context: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    507            if (cmd_ctx == NULL) {
   \        0x2   0xB908             CBNZ.N   R0,??sl_se_deinit_command_context_0
    508              return SL_STATUS_INVALID_PARAMETER;
   \        0x4   0x2021             MOVS     R0,#+33
   \        0x6   0xBD02             POP      {R1,PC}
    509            }
    510          
    511            return sl_se_init_command_context(cmd_ctx);
   \                     ??sl_se_deinit_command_context_0: (+1)
   \        0x8                      REQUIRE ?Subroutine0
   \        0x8                      ;; // Fall through to label ?Subroutine0
    512          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     se_manager_initialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     se_lock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     se_command_completion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0xE000'E443        DC32     0xe000e443

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0xE000'E108        DC32     0xe000e108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0xE000'E188        DC32     0xe000e188

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x5000'8068        DC32     0x50008068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x4C00'0044        DC32     0x4c000044

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x65          DC8 0x5C, 0x65, 0x6D, 0x6C, 0x69, 0x62, 0x5C, 0x69
   \              0x6D 0x6C    
   \              0x69 0x62    
   \              0x5C 0x69
   \       0x58   0x6E 0x63          DC8 0x6E, 0x63, 0x5C, 0x65, 0x6D, 0x5F, 0x62, 0x75
   \              0x5C 0x65    
   \              0x6D 0x5F    
   \              0x62 0x75
   \       0x60   0x73 0x2E          DC8 0x73, 0x2E, 0x68, 0
   \              0x68 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x70 0x6C          DC8 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D
   \       0x50   0x5C 0x73          DC8 0x5C, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74
   \              0x65 0x63    
   \              0x75 0x72    
   \              0x69 0x74
   \       0x58   0x79 0x5C          DC8 0x79, 0x5C, 0x73, 0x6C, 0x5F, 0x63, 0x6F, 0x6D
   \              0x73 0x6C    
   \              0x5F 0x63    
   \              0x6F 0x6D
   \       0x60   0x70 0x6F          DC8 0x70, 0x6F, 0x6E, 0x65, 0x6E, 0x74, 0x5C, 0x73
   \              0x6E 0x65    
   \              0x6E 0x74    
   \              0x5C 0x73
   \       0x68   0x65 0x5F          DC8 0x65, 0x5F, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65
   \              0x6D 0x61    
   \              0x6E 0x61    
   \              0x67 0x65
   \       0x70   0x72 0x5C          DC8 0x72, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x73, 0x6C
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x6C
   \       0x78   0x5F 0x73          DC8 0x5F, 0x73, 0x65, 0x5F, 0x6D, 0x61, 0x6E, 0x61
   \              0x65 0x5F    
   \              0x6D 0x61    
   \              0x6E 0x61
   \       0x80   0x67 0x65          DC8 0x67, 0x65, 0x72, 0x2E, 0x63, 0
   \              0x72 0x2E    
   \              0x63 0x00
   \       0x86                      DS8 2
    513          
    514          /** @} (end addtogroup sl_se) */
    515          
    516          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED) || defined(SLI_VSE_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BUS_RegBitWrite
        16   -> assertEFM
      16   SEMBRX_IRQHandler
         0   -> __NVIC_ClearPendingIRQ
        16   -> assertEFM
        16   -> osKernelGetState
        16   -> osSemaphoreRelease
       0   __NVIC_ClearPendingIRQ
       0   se_manager_osal_kernel_get_state
         0   -> osKernelGetState
       0   se_manager_osal_kernel_lock
         0   -> osKernelLock
       0   se_manager_osal_kernel_restore_lock
         0   -> osKernelRestoreLock
      24   sl_se_deinit
        24   -> __NVIC_ClearPendingIRQ
        24   -> osKernelLock
        24   -> osKernelRestoreLock
        24   -> osMutexDelete
        24   -> osSemaphoreDelete
        24   -> se_manager_osal_kernel_get_state
        24   -> se_manager_osal_kernel_restore_lock
        24   -> sli_se_lock_acquire
       8   sl_se_deinit_command_context
         8   -> __aeabi_memclr4
      24   sl_se_init
        24   -> osMutexNew
        24   -> osSemaphoreNew
        24   -> se_manager_osal_kernel_get_state
        24   -> se_manager_osal_kernel_lock
        24   -> se_manager_osal_kernel_restore_lock
       8   sl_se_init_command_context
         8   -> __aeabi_memclr4
       0   sl_se_set_yield
      16   sli_se_execute_and_wait
        16   -> SE_executeCommand
        16   -> osKernelGetState
        16   -> osSemaphoreAcquire
        16   -> sli_se_lock_acquire
        16   -> sli_se_lock_release
         0   -> sli_se_to_sl_status
       8   sli_se_lock_acquire
         8   -> BUS_RegBitWrite
         8   -> osKernelGetState
         8   -> osMutexAcquire
       8   sli_se_lock_release
         8   -> BUS_RegBitWrite
         8   -> osKernelGetState
         8   -> osMutexRelease
       8   sli_se_to_sl_status
         8   -> assertEFM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      10  ?Subroutine0
      20  ?Subroutine1
     100  ?_0
     136  ?_1
      36  ?_2
      42  BUS_RegBitWrite
      64  SEMBRX_IRQHandler
      22  __NVIC_ClearPendingIRQ
     104  se_command_completion
          se_manager_command_response
     100  se_lock
       1  se_manager_initialized
       4  se_manager_osal_kernel_get_state
       4  se_manager_osal_kernel_lock
       4  se_manager_osal_kernel_restore_lock
     130  sl_se_deinit
       8  sl_se_deinit_command_context
     132  sl_se_init
      10  sl_se_init_command_context
      14  sl_se_set_yield
     116  sli_se_execute_and_wait
      44  sli_se_lock_acquire
      38  sli_se_lock_release
     114  sli_se_to_sl_status

 
 101 bytes in section .bss
 104 bytes in section .data
 272 bytes in section .rodata
 820 bytes in section .text
 
 820 bytes of CODE  memory
 272 bytes of CONST memory
 205 bytes of DATA  memory

Errors: none
Warnings: none
