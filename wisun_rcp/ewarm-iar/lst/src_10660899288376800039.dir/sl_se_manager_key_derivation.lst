###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:16:58
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_key_derivation.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_key_derivation.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_key_derivation.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_key_derivation.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\src_10660899288376800039.dir\sl_se_manager_key_derivation.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\src_10660899288376800039.dir\sl_se_manager_key_derivation.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\sl_se_manager_key_derivation.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs Secure Engine Manager API.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: Zlib
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc.
     12           *
     13           * This software is provided 'as-is', without any express or implied
     14           * warranty. In no event will the authors be held liable for any damages
     15           * arising from the use of this software.
     16           *
     17           * Permission is granted to anyone to use this software for any purpose,
     18           * including commercial applications, and to alter it and redistribute it
     19           * freely, subject to the following restrictions:
     20           *
     21           * 1. The origin of this software must not be misrepresented; you must not
     22           *    claim that you wrote the original software. If you use this software
     23           *    in a product, an acknowledgment in the product documentation would be
     24           *    appreciated but is not required.
     25           * 2. Altered source versions must be plainly marked as such, and must not be
     26           *    misrepresented as being the original software.
     27           * 3. This notice may not be removed or altered from any source distribution.
     28           *
     29           ******************************************************************************/
     30          
     31          #include "sl_se_manager.h"
     32          
     33          #if defined(SLI_MAILBOX_COMMAND_SUPPORTED)
     34          
     35          #include "sli_se_manager_internal.h"
     36          #include "em_se.h"
     37          #include <string.h>
     38          
     39          /***************************************************************************//**
     40           * \addtogroup sl_se Secure Engine Manager API
     41           * @{
     42           ******************************************************************************/
     43          
     44          // -----------------------------------------------------------------------------
     45          // Defines
     46          
     47          #define KEYSPEC_DH_RESERVED                 0x00000780U
     48          // Constant from RFC 4492.
     49          #define SL_SE_ECP_TLS_NAMED_CURVE   3   ///< ECCurveType's named_curve
     50          #define SL_SE_TLSID_ECC_P256        23  ///< Named curve value for SECP256R1
     51          
     52          // -----------------------------------------------------------------------------
     53          // Locals
     54          
     55          // ECJPAKE role

   \                                 In section .text, align 4, keep-with-next
     56          static const char * const ecjpake_id[] = {
   \                     ecjpake_id:
   \        0x0   0x....'....        DC32 ?_0, ?_1
   \              0x....'....
     57            "client",
     58            "server"
     59          };
     60          
     61          // -----------------------------------------------------------------------------
     62          // Global Functions
     63          
     64          // -------------------------------
     65          // Elliptic-curve Diffie–Hellman
     66          
     67          /***************************************************************************//**
     68           * ECDH shared secret computation.
     69           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          sl_status_t sl_se_ecdh_compute_shared_secret(sl_se_command_context_t *cmd_ctx,
     71                                                       const sl_se_key_descriptor_t *key_in_priv,
     72                                                       const sl_se_key_descriptor_t *key_in_pub,
     73                                                       const sl_se_key_descriptor_t *key_out)
     74          {
   \                     sl_se_ecdh_compute_shared_secret: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB092             SUB      SP,SP,#+72
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
     75            sl_status_t status;
     76            uint32_t keyspec_out;
     77            uint32_t keyspec_in;
     78            uint32_t key_pubkey_size;
     79            SE_DataTransfer_t pubkey_input_buffer;
     80            SE_DataTransfer_t auth_buffer_out;
     81          
     82            if (cmd_ctx == NULL
     83                || key_in_priv == NULL || key_in_pub == NULL || key_out == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2C00             CMPNE    R4,#+0
   \       0x10   0xD029             BEQ.N    ??sl_se_ecdh_compute_shared_secret_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xBF18             IT       NE
   \       0x16   0x2F00             CMPNE    R7,#+0
   \       0x18   0xD025             BEQ.N    ??sl_se_ecdh_compute_shared_secret_0
     84              return SL_STATUS_INVALID_PARAMETER;
     85            }
     86          
     87            status = sli_key_check_equivalent(key_in_priv, key_in_pub, false, false);
   \       0x1A   0x2300             MOVS     R3,#+0
   \       0x1C   0x2200             MOVS     R2,#+0
   \       0x1E   0x4631             MOV      R1,R6
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       sli_key_check_equivalent
     88            if (status != SL_STATUS_OK) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD104             BNE.N    ??sl_se_ecdh_compute_shared_secret_1
     89              return status;
     90            }
     91            status = sli_key_get_size(key_in_pub, &key_pubkey_size);
   \       0x2A   0xA901             ADD      R1,SP,#+4
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0x.... 0x....      BL       sli_key_get_size
     92            if (status != SL_STATUS_OK) {
   \       0x32   0x2800             CMP      R0,#+0
   \                     ??sl_se_ecdh_compute_shared_secret_1: (+1)
   \       0x34   0xD17D             BNE.N    ??sl_se_ecdh_compute_shared_secret_2
     93              return status;
     94            }
     95          
     96            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
     97            // The key out buffer size needs be large enough for non-volatile keys
     98            if (key_out->storage.method != SL_SE_KEY_STORAGE_INTERNAL_VOLATILE) {
   \       0x36   0x68F8             LDR      R0,[R7, #+12]
   \       0x38   0x2802             CMP      R0,#+2
   \       0x3A   0xD012             BEQ.N    ??sl_se_ecdh_compute_shared_secret_3
     99              if (key_in_priv->type == SL_SE_KEY_TYPE_ECC_X25519
    100                  || key_in_priv->type == SL_SE_KEY_TYPE_ECC_X448) {
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable46
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xBF1C             ITT      NE
   \       0x46   0x.... 0x....      LDRNE.W  R2,??DataTable46_1
   \       0x4A   0x4290             CMPNE    R0,R2
   \       0x4C   0xD104             BNE.N    ??sl_se_ecdh_compute_shared_secret_4
    101                if (key_pubkey_size > key_out->storage.location.buffer.size) {
   \       0x4E   0x6979             LDR      R1,[R7, #+20]
   \       0x50   0x9801             LDR      R0,[SP, #+4]
   \       0x52   0x4281             CMP      R1,R0
   \       0x54   0xD205             BCS.N    ??sl_se_ecdh_compute_shared_secret_3
   \       0x56   0xE006             B.N      ??sl_se_ecdh_compute_shared_secret_0
    102                  return SL_STATUS_INVALID_PARAMETER;
    103                }
    104              } else {
    105                if ((key_pubkey_size * 2) > key_out->storage.location.buffer.size) {
   \                     ??sl_se_ecdh_compute_shared_secret_4: (+1)
   \       0x58   0x6979             LDR      R1,[R7, #+20]
   \       0x5A   0x9A01             LDR      R2,[SP, #+4]
   \       0x5C   0xEBB1 0x0F42      CMP      R1,R2, LSL #+1
   \       0x60   0xD301             BCC.N    ??sl_se_ecdh_compute_shared_secret_0
    106                  return SL_STATUS_INVALID_PARAMETER;
    107                }
    108              }
    109            }
    110            #else
    111            if (key_in_priv->type == SL_SE_KEY_TYPE_ECC_X25519) {
    112              if (key_pubkey_size > key_out->storage.location.buffer.size) {
    113                return SL_STATUS_INVALID_PARAMETER;
    114              }
    115            } else {
    116              if ((key_pubkey_size * 2) > key_out->storage.location.buffer.size) {
    117                return SL_STATUS_INVALID_PARAMETER;
    118              }
    119            }
    120            #endif
    121          
    122            // Output of DH must be in RAW format
    123            if (key_out->type != SL_SE_KEY_TYPE_SYMMETRIC) {
   \                     ??sl_se_ecdh_compute_shared_secret_3: (+1)
   \       0x62   0x6838             LDR      R0,[R7, #+0]
   \       0x64   0xB108             CBZ.N    R0,??sl_se_ecdh_compute_shared_secret_5
    124              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecdh_compute_shared_secret_0: (+1)
   \       0x66   0x2021             MOVS     R0,#+33
   \       0x68   0xE063             B.N      ??sl_se_ecdh_compute_shared_secret_2
    125            }
    126          
    127            // Initialize command
    128            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DH);
   \                     ??sl_se_ecdh_compute_shared_secret_5: (+1)
   \       0x6A   0xF04F 0x6260      MOV      R2,#+234881024
   \       0x6E   0x602A             STR      R2,[R5, #+0]
   \       0x70   0x2100             MOVS     R1,#+0
   \       0x72   0x6068             STR      R0,[R5, #+4]
   \       0x74   0x60A9             STR      R1,[R5, #+8]
   \       0x76   0x61E8             STR      R0,[R5, #+28]
    129          
    130            // Add key parameters to command
    131            status = sli_se_key_to_keyspec(key_in_priv, &keyspec_in);
   \       0x78   0x4669             MOV      R1,SP
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x.... 0x....      BL       sli_se_key_to_keyspec
    132            if (status != SL_STATUS_OK) {
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD156             BNE.N    ??sl_se_ecdh_compute_shared_secret_2
    133              return status;
    134            }
    135            keyspec_in = keyspec_in & ~KEYSPEC_DH_RESERVED;
   \       0x84   0x9800             LDR      R0,[SP, #+0]
   \       0x86   0xF420 0x60F0      BIC      R0,R0,#0x780
   \       0x8A   0x9000             STR      R0,[SP, #+0]
    136            SE_addParameter(&cmd_ctx->command, keyspec_in);
   \       0x8C   0x4601             MOV      R1,R0
   \       0x8E   0x4628             MOV      R0,R5
   \       0x90   0x.... 0x....      BL       SE_addParameter
    137          
    138            status = sli_se_key_to_keyspec(key_out, &keyspec_out);
   \       0x94   0xA902             ADD      R1,SP,#+8
   \       0x96   0x4638             MOV      R0,R7
   \       0x98   0x.... 0x....      BL       sli_se_key_to_keyspec
    139            if (status != SL_STATUS_OK) {
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD148             BNE.N    ??sl_se_ecdh_compute_shared_secret_2
    140              return status;
    141            }
    142            SE_addParameter(&cmd_ctx->command, keyspec_out);
   \       0xA0   0x9902             LDR      R1,[SP, #+8]
   \       0xA2   0x4628             MOV      R0,R5
   \       0xA4   0x.... 0x....      BL       SE_addParameter
    143          
    144            // Add key input metadata block to command
    145            sli_add_key_metadata(cmd_ctx, key_in_priv, status);
   \       0xA8   0xA90C             ADD      R1,SP,#+48
   \       0xAA   0x4620             MOV      R0,R4
   \       0xAC   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD13E             BNE.N    ??sl_se_ecdh_compute_shared_secret_2
   \       0xB4   0xA90C             ADD      R1,SP,#+48
   \       0xB6   0x.... 0x....      BL       ?Subroutine9
    146            // Add key input block to command
    147            sli_add_key_input(cmd_ctx, key_in_priv, status);
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0xBA   0xA909             ADD      R1,SP,#+36
   \       0xBC   0x4620             MOV      R0,R4
   \       0xBE   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD135             BNE.N    ??sl_se_ecdh_compute_shared_secret_2
   \       0xC6   0xA909             ADD      R1,SP,#+36
   \       0xC8   0x.... 0x....      BL       ?Subroutine9
    148          
    149            if (key_out->storage.method != SL_SE_KEY_STORAGE_EXTERNAL_PLAINTEXT) {
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0xCC   0x68F8             LDR      R0,[R7, #+12]
   \       0xCE   0xB138             CBZ.N    R0,??CrossCallReturnLabel_74
    150              // Add key output metadata block to command
    151              status = sli_se_get_auth_buffer(key_out, &auth_buffer_out);
   \       0xD0   0xA90F             ADD      R1,SP,#+60
   \       0xD2   0x4638             MOV      R0,R7
   \       0xD4   0x.... 0x....      BL       sli_se_get_auth_buffer
    152              if (status != SL_STATUS_OK) {
   \       0xD8   0xBB58             CBNZ.N   R0,??sl_se_ecdh_compute_shared_secret_2
    153                return status;
    154              }
    155              SE_addDataInput(&cmd_ctx->command, &auth_buffer_out);
   \       0xDA   0xA90F             ADD      R1,SP,#+60
   \       0xDC   0x.... 0x....      BL       ?Subroutine9
    156            }
    157            // Add key of other party
    158            status = sli_se_get_key_input_output(key_in_pub, &pubkey_input_buffer);
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0xE0   0xA903             ADD      R1,SP,#+12
   \       0xE2   0x4630             MOV      R0,R6
   \       0xE4   0x.... 0x....      BL       sli_se_get_key_input_output
    159            if (status != SL_STATUS_OK) {
   \       0xE8   0xBB18             CBNZ.N   R0,??sl_se_ecdh_compute_shared_secret_2
    160              return status;
    161            }
    162          
    163            #if (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT)
    164            if (key_in_pub->flags & SL_SE_KEY_FLAG_ASYMMETRIC_USES_CUSTOM_DOMAIN) {
   \       0xEA   0x68B1             LDR      R1,[R6, #+8]
   \       0xEC   0x04C8             LSLS     R0,R1,#+19
   \       0xEE   0xD50C             BPL.N    ??sl_se_ecdh_compute_shared_secret_6
    165              if (key_in_pub->flags & SL_SE_KEY_FLAG_ASYMMETRIC_BUFFER_HAS_PUBLIC_KEY) {
   \       0xF0   0x0489             LSLS     R1,R1,#+18
   \       0xF2   0xD520             BPL.N    ??sl_se_ecdh_compute_shared_secret_7
    166                // If using custom domain, the key buffer stores domain parameters,
    167                // however when computing the shared secret only the key is of interest.
    168                uint32_t domain_size = ((sl_se_custom_weierstrass_prime_domain_t*)key_in_pub->domain)->size;
   \       0xF4   0x69F0             LDR      R0,[R6, #+28]
    169                pubkey_input_buffer.data = &key_in_pub->storage.location.buffer.pointer[domain_size * 6];
   \       0xF6   0x2106             MOVS     R1,#+6
   \       0xF8   0x6932             LDR      R2,[R6, #+16]
   \       0xFA   0x6800             LDR      R0,[R0, #+0]
   \       0xFC   0x4341             MULS     R1,R1,R0
   \       0xFE   0x4411             ADD      R1,R2,R1
    170                pubkey_input_buffer.length = (domain_size * 2) | SE_DATATRANSFER_REALIGN;
   \      0x100   0x0040             LSLS     R0,R0,#+1
   \      0x102   0x9103             STR      R1,[SP, #+12]
   \      0x104   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \      0x108   0x9005             STR      R0,[SP, #+20]
    171              } else {
    172                // Does not contain a public key.
    173                return SL_STATUS_INVALID_KEY;
    174              }
    175            }
    176            #endif
    177          
    178            SE_addDataInput(&cmd_ctx->command, &pubkey_input_buffer);
   \                     ??sl_se_ecdh_compute_shared_secret_6: (+1)
   \      0x10A   0xA903             ADD      R1,SP,#+12
   \      0x10C   0x.... 0x....      BL       ?Subroutine9
    179          
    180            // Add key output block to command
    181            sli_add_key_output(cmd_ctx, key_out, status);
   \                     ??CrossCallReturnLabel_73: (+1)
   \      0x110   0xA906             ADD      R1,SP,#+24
   \      0x112   0x4638             MOV      R0,R7
   \      0x114   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x118   0xB958             CBNZ.N   R0,??sl_se_ecdh_compute_shared_secret_2
   \      0x11A   0xA906             ADD      R1,SP,#+24
   \      0x11C   0x4628             MOV      R0,R5
   \      0x11E   0x.... 0x....      BL       SE_addDataOutput
    182          
    183            // Execute command.
    184            // The retries are necessary in order to reduce the risk of random failures
    185            // in the accelerated point multiplication. This mainly affects very small or
    186            // large scalars, which in this case would be the private key.
    187            for (size_t i = 0; i < SLI_SE_MAX_POINT_MULT_RETRIES; ++i) {
   \      0x122   0x2403             MOVS     R4,#+3
    188              status = sli_se_execute_and_wait(cmd_ctx);
   \                     ??sl_se_ecdh_compute_shared_secret_8: (+1)
   \      0x124   0x4628             MOV      R0,R5
   \      0x126   0x.... 0x....      BL       sli_se_execute_and_wait
    189              if (status != SL_STATUS_FAIL) {
   \      0x12A   0x2801             CMP      R0,#+1
   \      0x12C   0xD101             BNE.N    ??sl_se_ecdh_compute_shared_secret_2
    190                break;
    191              }
    192            }
   \      0x12E   0x1E64             SUBS     R4,R4,#+1
   \      0x130   0xD1F8             BNE.N    ??sl_se_ecdh_compute_shared_secret_8
    193            return status;
   \                     ??sl_se_ecdh_compute_shared_secret_2: (+1)
   \      0x132   0xB013             ADD      SP,SP,#+76
   \      0x134   0xBDF0             POP      {R4-R7,PC}
   \                     ??sl_se_ecdh_compute_shared_secret_7: (+1)
   \      0x136   0x2029             MOVS     R0,#+41
   \      0x138   0xE7FB             B.N      ??sl_se_ecdh_compute_shared_secret_2
    194          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x.... 0x....      B.W      SE_addDataInput
    195          
    196          // -------------------------------
    197          // ECJPAKE
    198          
    199          /***************************************************************************//**
    200           * Parse a ECJPAKE TLS point.
    201           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    202          static sl_status_t ecjpake_parse_tls_point(const uint8_t **ibuf,
    203                                                     size_t *ilen,
    204                                                     size_t *rlen,
    205                                                     uint8_t **obuf, size_t *olen)
    206          {
   \                     ecjpake_parse_tls_point: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x4698             MOV      R8,R3
    207            if (ilen == NULL || ibuf == NULL || obuf == NULL || olen == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E00             CMPNE    R6,#+0
   \       0x10   0xD02D             BEQ.N    ??ecjpake_parse_tls_point_0
   \       0x12   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x9F08             LDRNE    R7,[SP, #+32]
   \       0x1A   0x2F00             CMPNE    R7,#+0
   \       0x1C   0xD027             BEQ.N    ??ecjpake_parse_tls_point_0
    208              return SL_STATUS_INVALID_PARAMETER;
    209            }
    210          
    211            if (*ilen == 0 || *ibuf == NULL || *obuf == NULL) {
   \       0x1E   0x6829             LDR      R1,[R5, #+0]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xBF1C             ITT      NE
   \       0x24   0x6832             LDRNE    R2,[R6, #+0]
   \       0x26   0x2A00             CMPNE    R2,#+0
   \       0x28   0xD021             BEQ.N    ??ecjpake_parse_tls_point_0
   \       0x2A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x2E   0xB1F0             CBZ.N    R0,??ecjpake_parse_tls_point_0
    212              return SL_STATUS_INVALID_PARAMETER;
    213            }
    214          
    215            // Consume first byte, length of what follows.
    216            size_t field_length = **ibuf;
   \       0x30   0xF812 0x9B01      LDRB     R9,[R2], #+1
    217            *ibuf += 1;
    218            *ilen -= 1;
   \       0x34   0x1E49             SUBS     R1,R1,#+1
   \       0x36   0x6032             STR      R2,[R6, #+0]
   \       0x38   0x6029             STR      R1,[R5, #+0]
    219            if (rlen != NULL) {
   \       0x3A   0xB114             CBZ.N    R4,??ecjpake_parse_tls_point_1
    220              *rlen += 1;
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x1C49             ADDS     R1,R1,#+1
   \       0x40   0x6021             STR      R1,[R4, #+0]
    221            }
    222          
    223            if (field_length > *ilen) {
   \                     ??ecjpake_parse_tls_point_1: (+1)
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x4549             CMP      R1,R9
   \       0x46   0xD312             BCC.N    ??ecjpake_parse_tls_point_0
    224              return SL_STATUS_INVALID_PARAMETER;
    225            }
    226          
    227            // Consume second byte, point type.
    228            uint8_t point_type = **ibuf;
   \       0x48   0x6833             LDR      R3,[R6, #+0]
    229            size_t point_length = field_length - 1;
    230            *ibuf += 1;
    231            *ilen -= 1;
   \       0x4A   0x1E49             SUBS     R1,R1,#+1
   \       0x4C   0xF1A9 0x0A01      SUB      R10,R9,#+1
   \       0x50   0xF813 0x2B01      LDRB     R2,[R3], #+1
   \       0x54   0x6033             STR      R3,[R6, #+0]
   \       0x56   0x6029             STR      R1,[R5, #+0]
    232          
    233            switch (point_type) {
   \       0x58   0xB122             CBZ.N    R2,??ecjpake_parse_tls_point_2
   \       0x5A   0x2A04             CMP      R2,#+4
   \       0x5C   0xD004             BEQ.N    ??ecjpake_parse_tls_point_3
   \       0x5E   0x2A05             CMP      R2,#+5
   \       0x60   0xD007             BEQ.N    ??ecjpake_parse_tls_point_4
   \       0x62   0xE004             B.N      ??ecjpake_parse_tls_point_0
    234              case 0x0:
    235                // Why would we ever get a zero-point?
    236                return SL_STATUS_INVALID_KEY;
   \                     ??ecjpake_parse_tls_point_2: (+1)
   \       0x64   0x2029             MOVS     R0,#+41
   \       0x66   0xE01F             B.N      ??ecjpake_parse_tls_point_5
    237              case 0x04:
    238                break;
    239              case 0x05:
    240                // We don't support compressed points...
    241                return SL_STATUS_NOT_SUPPORTED;
    242              default:
    243                return SL_STATUS_INVALID_PARAMETER;
    244            }
    245          
    246            // Copy out binary point.
    247            if (point_length > *olen) {
   \                     ??ecjpake_parse_tls_point_3: (+1)
   \       0x68   0x6839             LDR      R1,[R7, #+0]
   \       0x6A   0x4551             CMP      R1,R10
   \       0x6C   0xD203             BCS.N    ??ecjpake_parse_tls_point_6
    248              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_point_0: (+1)
   \       0x6E   0x2021             MOVS     R0,#+33
   \       0x70   0xE01A             B.N      ??ecjpake_parse_tls_point_5
    249            }
   \                     ??ecjpake_parse_tls_point_4: (+1)
   \       0x72   0x200F             MOVS     R0,#+15
   \       0x74   0xE018             B.N      ??ecjpake_parse_tls_point_5
    250          
    251            memcpy(*obuf, *ibuf, point_length);
   \                     ??ecjpake_parse_tls_point_6: (+1)
   \       0x76   0x6831             LDR      R1,[R6, #+0]
   \       0x78   0x4652             MOV      R2,R10
   \       0x7A   0x.... 0x....      BL       __aeabi_memcpy
    252            *ibuf += point_length;
   \       0x7E   0x6832             LDR      R2,[R6, #+0]
   \       0x80   0x4452             ADD      R2,R2,R10
   \       0x82   0x6032             STR      R2,[R6, #+0]
    253            *ilen -= point_length;
   \       0x84   0x682B             LDR      R3,[R5, #+0]
   \       0x86   0xEBA3 0x030A      SUB      R3,R3,R10
   \       0x8A   0x602B             STR      R3,[R5, #+0]
    254            *obuf += point_length;
   \       0x8C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x90   0x4450             ADD      R0,R0,R10
   \       0x92   0xF8C8 0x0000      STR      R0,[R8, #+0]
    255            *olen -= point_length;
   \       0x96   0x6839             LDR      R1,[R7, #+0]
   \       0x98   0xEBA1 0x000A      SUB      R0,R1,R10
   \       0x9C   0x6038             STR      R0,[R7, #+0]
    256            if (rlen != NULL) {
   \       0x9E   0xB114             CBZ.N    R4,??ecjpake_parse_tls_point_7
    257              *rlen += field_length;
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x4448             ADD      R0,R9,R0
   \       0xA4   0x6020             STR      R0,[R4, #+0]
    258            }
    259          
    260            return SL_STATUS_OK;
   \                     ??ecjpake_parse_tls_point_7: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_parse_tls_point_5: (+1)
   \       0xA8   0xE8BD 0x87F0      POP      {R4-R10,PC}
    261          }
    262          
    263          /***************************************************************************//**
    264           * Parse a ECJPAKE TLS zkp.
    265           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          static sl_status_t ecjpake_parse_tls_zkp(const uint8_t **ibuf,
    267                                                   size_t *ilen,
    268                                                   size_t *rlen,
    269                                                   uint8_t **obuf,
    270                                                   size_t *olen)
    271          {
   \                     ecjpake_parse_tls_zkp: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461C             MOV      R4,R3
    272            if (ilen == NULL || ibuf == NULL || obuf == NULL || olen == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E00             CMPNE    R6,#+0
   \       0x10   0xD02C             BEQ.N    ??ecjpake_parse_tls_zkp_0
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x9F0A             LDRNE    R7,[SP, #+40]
   \       0x18   0x2F00             CMPNE    R7,#+0
   \       0x1A   0xD027             BEQ.N    ??ecjpake_parse_tls_zkp_0
    273              return SL_STATUS_INVALID_PARAMETER;
    274            }
    275          
    276            if (*ilen == 0 || *ibuf == NULL || *obuf == NULL || *olen < 96) {
   \       0x1C   0x6828             LDR      R0,[R5, #+0]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xBF1C             ITT      NE
   \       0x22   0x6831             LDRNE    R1,[R6, #+0]
   \       0x24   0x2900             CMPNE    R1,#+0
   \       0x26   0xD021             BEQ.N    ??ecjpake_parse_tls_zkp_0
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0xB1F8             CBZ.N    R0,??ecjpake_parse_tls_zkp_0
   \       0x2C   0x6839             LDR      R1,[R7, #+0]
   \       0x2E   0x2960             CMP      R1,#+96
   \       0x30   0xD31C             BCC.N    ??ecjpake_parse_tls_zkp_0
    277              return SL_STATUS_INVALID_PARAMETER;
    278            }
    279          
    280            int ret = ecjpake_parse_tls_point(ibuf, ilen, rlen, obuf, olen);
   \       0x32   0x9700             STR      R7,[SP, #+0]
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x.... 0x....      BL       ecjpake_parse_tls_point
    281            if (ret != SL_STATUS_OK) {
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD144             BNE.N    ??ecjpake_parse_tls_zkp_1
    282              return ret;
    283            }
    284          
    285            if (*ilen < 1) {
   \       0x40   0x6828             LDR      R0,[R5, #+0]
   \       0x42   0xB198             CBZ.N    R0,??ecjpake_parse_tls_zkp_0
    286              return SL_STATUS_INVALID_PARAMETER;
    287            }
    288          
    289            // Consume first byte, length of what follows.
    290            size_t field_length = **ibuf;
   \       0x44   0x6831             LDR      R1,[R6, #+0]
    291            *ibuf += 1;
    292            *ilen -= 1;
   \       0x46   0x1E40             SUBS     R0,R0,#+1
    293            if (rlen != NULL) {
   \       0x48   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x4C   0xF811 0x9B01      LDRB     R9,[R1], #+1
   \       0x50   0x6031             STR      R1,[R6, #+0]
   \       0x52   0x6028             STR      R0,[R5, #+0]
   \       0x54   0xD004             BEQ.N    ??ecjpake_parse_tls_zkp_2
    294              *rlen += 1;
   \       0x56   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x5A   0x1C40             ADDS     R0,R0,#+1
   \       0x5C   0xF8C8 0x0000      STR      R0,[R8, #+0]
    295            }
    296          
    297            if (field_length > *ilen || field_length > *olen) {
   \                     ??ecjpake_parse_tls_zkp_2: (+1)
   \       0x60   0x6829             LDR      R1,[R5, #+0]
   \       0x62   0x4549             CMP      R1,R9
   \       0x64   0xBF24             ITT      CS
   \       0x66   0x6838             LDRCS    R0,[R7, #+0]
   \       0x68   0x4548             CMPCS    R0,R9
   \       0x6A   0xD201             BCS.N    ??ecjpake_parse_tls_zkp_3
    298              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_parse_tls_zkp_0: (+1)
   \       0x6C   0x2021             MOVS     R0,#+33
   \       0x6E   0xE02C             B.N      ??ecjpake_parse_tls_zkp_1
    299            }
    300          
    301            if (field_length == 0) {
   \                     ??ecjpake_parse_tls_zkp_3: (+1)
   \       0x70   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x74   0xBF08             IT       EQ
   \       0x76   0x2029             MOVEQ    R0,#+41
    302              // Scalar cannot be zero.
    303              return SL_STATUS_INVALID_KEY;
   \       0x78   0xD027             BEQ.N    ??ecjpake_parse_tls_zkp_1
    304            }
    305          
    306            // Right-adjust.
    307            size_t adjust_length = 32 - field_length;
    308            memset(*obuf, 0, adjust_length);
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0xF1C9 0x0A20      RSB      R10,R9,#+32
   \       0x80   0x4651             MOV      R1,R10
   \       0x82   0x.... 0x....      BL       __aeabi_memclr
    309            *obuf += adjust_length;
    310            *olen -= adjust_length;
   \       0x86   0x6839             LDR      R1,[R7, #+0]
   \       0x88   0x6820             LDR      R0,[R4, #+0]
    311          
    312            // Consume field.
    313            memcpy(*obuf, *ibuf, field_length);
   \       0x8A   0x464A             MOV      R2,R9
   \       0x8C   0xEBA1 0x010A      SUB      R1,R1,R10
   \       0x90   0x4450             ADD      R0,R0,R10
   \       0x92   0x6039             STR      R1,[R7, #+0]
   \       0x94   0x6020             STR      R0,[R4, #+0]
   \       0x96   0x6831             LDR      R1,[R6, #+0]
   \       0x98   0x.... 0x....      BL       __aeabi_memcpy
    314            *obuf += field_length;
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
    315            *olen -= field_length;
    316            *ibuf += field_length;
    317            *ilen -= field_length;
    318          
    319            if (rlen != NULL) {
   \       0x9E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xA2   0x4448             ADD      R0,R0,R9
   \       0xA4   0x6020             STR      R0,[R4, #+0]
   \       0xA6   0x6839             LDR      R1,[R7, #+0]
   \       0xA8   0xEBA1 0x0109      SUB      R1,R1,R9
   \       0xAC   0x6039             STR      R1,[R7, #+0]
   \       0xAE   0x6832             LDR      R2,[R6, #+0]
   \       0xB0   0x444A             ADD      R2,R2,R9
   \       0xB2   0x6032             STR      R2,[R6, #+0]
   \       0xB4   0x682B             LDR      R3,[R5, #+0]
   \       0xB6   0xEBA3 0x0309      SUB      R3,R3,R9
   \       0xBA   0x602B             STR      R3,[R5, #+0]
   \       0xBC   0xD004             BEQ.N    ??ecjpake_parse_tls_zkp_4
    320              *rlen += field_length;
   \       0xBE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xC2   0x4448             ADD      R0,R9,R0
   \       0xC4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    321            }
    322          
    323            return SL_STATUS_OK;
   \                     ??ecjpake_parse_tls_zkp_4: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_parse_tls_zkp_1: (+1)
   \       0xCA   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    324          }
    325          
    326          /***************************************************************************//**
    327           * Write a ECJPAKE TLS point.
    328           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          static sl_status_t ecjpake_write_tls_point(uint8_t **obuf,
    330                                                     size_t *olen,
    331                                                     size_t *wlen,
    332                                                     const uint8_t **ibuf,
    333                                                     size_t *ilen,
    334                                                     size_t point_length)
    335          {
   \                     ecjpake_write_tls_point: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0xEA5F 0x0903      MOVS     R9,R3
    336            if (ibuf == NULL || obuf == NULL || olen == NULL || ilen == NULL) {
   \        0xE   0xBF18             IT       NE
   \       0x10   0x2E00             CMPNE    R6,#+0
   \       0x12   0xD015             BEQ.N    ??ecjpake_write_tls_point_0
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xBF1C             ITT      NE
   \       0x18   0x9F08             LDRNE    R7,[SP, #+32]
   \       0x1A   0x2F00             CMPNE    R7,#+0
   \       0x1C   0xD010             BEQ.N    ??ecjpake_write_tls_point_0
    337              return SL_STATUS_INVALID_PARAMETER;
    338            }
    339          
    340            if (*obuf == NULL || *ibuf == NULL) {
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xBF1C             ITT      NE
   \       0x24   0xF8D9 0x1000      LDRNE    R1,[R9, #+0]
   \       0x28   0x2900             CMPNE    R1,#+0
   \       0x2A   0xD009             BEQ.N    ??ecjpake_write_tls_point_0
   \       0x2C   0x9D09             LDR      R5,[SP, #+36]
    341              return SL_STATUS_INVALID_PARAMETER;
    342            }
    343          
    344            // We can only output uncompressed points here.
    345            if (*olen < point_length + 2) {
   \       0x2E   0x6822             LDR      R2,[R4, #+0]
   \       0x30   0x1CA9             ADDS     R1,R5,#+2
   \       0x32   0x428A             CMP      R2,R1
   \       0x34   0xBF38             IT       CC
   \       0x36   0x201D             MOVCC    R0,#+29
    346              return SL_STATUS_WOULD_OVERFLOW;
   \       0x38   0xD331             BCC.N    ??ecjpake_write_tls_point_1
    347            }
    348          
    349            if (*ilen < point_length) {
   \       0x3A   0x6839             LDR      R1,[R7, #+0]
   \       0x3C   0x42A9             CMP      R1,R5
   \       0x3E   0xD201             BCS.N    ??ecjpake_write_tls_point_2
    350              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_point_0: (+1)
   \       0x40   0x2021             MOVS     R0,#+33
   \       0x42   0xE02C             B.N      ??ecjpake_write_tls_point_1
    351            }
    352          
    353            **obuf = point_length + 1;
   \                     ??ecjpake_write_tls_point_2: (+1)
   \       0x44   0x1C69             ADDS     R1,R5,#+1
   \       0x46   0x7001             STRB     R1,[R0, #+0]
    354            *obuf += 1;
    355            *olen -= 1;
   \       0x48   0x6822             LDR      R2,[R4, #+0]
   \       0x4A   0x6830             LDR      R0,[R6, #+0]
    356          
    357            **obuf = 0x04;
   \       0x4C   0x2104             MOVS     R1,#+4
   \       0x4E   0x1E52             SUBS     R2,R2,#+1
   \       0x50   0x1C40             ADDS     R0,R0,#+1
   \       0x52   0x6022             STR      R2,[R4, #+0]
   \       0x54   0x6030             STR      R0,[R6, #+0]
   \       0x56   0x7001             STRB     R1,[R0, #+0]
    358            *obuf += 1;
    359            *olen -= 1;
   \       0x58   0x6823             LDR      R3,[R4, #+0]
   \       0x5A   0x6830             LDR      R0,[R6, #+0]
    360          
    361            memcpy(*obuf, *ibuf, point_length);
   \       0x5C   0x462A             MOV      R2,R5
   \       0x5E   0x1E5B             SUBS     R3,R3,#+1
   \       0x60   0x1C40             ADDS     R0,R0,#+1
   \       0x62   0x6023             STR      R3,[R4, #+0]
   \       0x64   0x6030             STR      R0,[R6, #+0]
   \       0x66   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x6A   0x.... 0x....      BL       __aeabi_memcpy
    362          
    363            *obuf += point_length;
   \       0x6E   0x6830             LDR      R0,[R6, #+0]
   \       0x70   0x1940             ADDS     R0,R0,R5
   \       0x72   0x6030             STR      R0,[R6, #+0]
    364            *olen -= point_length;
   \       0x74   0x6822             LDR      R2,[R4, #+0]
   \       0x76   0x1B52             SUBS     R2,R2,R5
   \       0x78   0x6022             STR      R2,[R4, #+0]
    365            *ibuf += point_length;
   \       0x7A   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x7E   0x1949             ADDS     R1,R1,R5
   \       0x80   0xF8C9 0x1000      STR      R1,[R9, #+0]
    366            *ilen -= point_length;
   \       0x84   0x683B             LDR      R3,[R7, #+0]
   \       0x86   0x1B5B             SUBS     R3,R3,R5
   \       0x88   0x603B             STR      R3,[R7, #+0]
    367          
    368            if (wlen != NULL) {
   \       0x8A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x8E   0xD005             BEQ.N    ??ecjpake_write_tls_point_3
    369              *wlen += point_length + 2;
   \       0x90   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x94   0x182D             ADDS     R5,R5,R0
   \       0x96   0x1CAD             ADDS     R5,R5,#+2
   \       0x98   0xF8C8 0x5000      STR      R5,[R8, #+0]
    370            }
    371          
    372            return SL_STATUS_OK;
   \                     ??ecjpake_write_tls_point_3: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_write_tls_point_1: (+1)
   \       0x9E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    373          }
    374          
    375          /***************************************************************************//**
    376           * Write a ECJPAKE TLS zkp.
    377           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    378          static sl_status_t ecjpake_write_tls_zkp(uint8_t **obuf,
    379                                                   size_t *olen,
    380                                                   size_t *wlen,
    381                                                   const uint8_t **ibuf,
    382                                                   size_t *ilen,
    383                                                   size_t point_length)
    384          {
   \                     ecjpake_write_tls_zkp: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001D             MOVS     R5,R3
    385            sl_status_t ret = SL_STATUS_OK;
    386          
    387            if (ibuf == NULL || obuf == NULL || olen == NULL || ilen == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2E00             CMPNE    R6,#+0
   \       0x10   0xD018             BEQ.N    ??ecjpake_write_tls_zkp_0
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xBF1C             ITT      NE
   \       0x16   0x9F08             LDRNE    R7,[SP, #+32]
   \       0x18   0x2F00             CMPNE    R7,#+0
   \       0x1A   0xD013             BEQ.N    ??ecjpake_write_tls_zkp_0
    388              return SL_STATUS_INVALID_PARAMETER;
    389            }
    390          
    391            if (*obuf == NULL || *ibuf == NULL) {
   \       0x1C   0x6831             LDR      R1,[R6, #+0]
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xBF1C             ITT      NE
   \       0x22   0x6828             LDRNE    R0,[R5, #+0]
   \       0x24   0x2800             CMPNE    R0,#+0
   \       0x26   0xD00D             BEQ.N    ??ecjpake_write_tls_zkp_0
    392              return SL_STATUS_INVALID_PARAMETER;
    393            }
    394          
    395            ret = ecjpake_write_tls_point(obuf, olen, wlen, ibuf, ilen, point_length);
   \       0x28   0x9809             LDR      R0,[SP, #+36]
   \       0x2A   0x9700             STR      R7,[SP, #+0]
   \       0x2C   0x4621             MOV      R1,R4
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x.... 0x....      BL       ecjpake_write_tls_point
    396          
    397            if (ret != SL_STATUS_OK) {
   \       0x36   0xBB58             CBNZ.N   R0,??ecjpake_write_tls_zkp_1
    398              return ret;
    399            }
    400          
    401            size_t zkp_length = 32;
    402          
    403            if (*olen < zkp_length + 1 || *ilen < zkp_length) {
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x2920             CMP      R1,#+32
   \       0x3C   0xD902             BLS.N    ??ecjpake_write_tls_zkp_0
   \       0x3E   0x6838             LDR      R0,[R7, #+0]
   \       0x40   0x2820             CMP      R0,#+32
   \       0x42   0xD201             BCS.N    ??ecjpake_write_tls_zkp_2
    404              return SL_STATUS_INVALID_PARAMETER;
   \                     ??ecjpake_write_tls_zkp_0: (+1)
   \       0x44   0x2021             MOVS     R0,#+33
   \       0x46   0xE023             B.N      ??ecjpake_write_tls_zkp_1
    405            }
    406          
    407            **obuf = zkp_length;
   \                     ??ecjpake_write_tls_zkp_2: (+1)
   \       0x48   0x6830             LDR      R0,[R6, #+0]
   \       0x4A   0x2120             MOVS     R1,#+32
   \       0x4C   0x7001             STRB     R1,[R0, #+0]
    408            *obuf += 1;
    409            *olen -= 1;
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0x6832             LDR      R2,[R6, #+0]
   \       0x52   0x1E49             SUBS     R1,R1,#+1
   \       0x54   0x6021             STR      R1,[R4, #+0]
   \       0x56   0x1C50             ADDS     R0,R2,#+1
    410          
    411            memcpy(*obuf, *ibuf, zkp_length);
   \       0x58   0x6030             STR      R0,[R6, #+0]
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x2220             MOVS     R2,#+32
   \       0x5E   0x.... 0x....      BL       __aeabi_memcpy
    412          
    413            *obuf += zkp_length;
   \       0x62   0x6831             LDR      R1,[R6, #+0]
   \       0x64   0xF101 0x0020      ADD      R0,R1,#+32
   \       0x68   0x6030             STR      R0,[R6, #+0]
    414            *olen -= zkp_length;
   \       0x6A   0x6822             LDR      R2,[R4, #+0]
   \       0x6C   0x3A20             SUBS     R2,R2,#+32
   \       0x6E   0x6022             STR      R2,[R4, #+0]
    415            *ibuf += zkp_length;
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0xF101 0x0020      ADD      R0,R1,#+32
   \       0x76   0x6028             STR      R0,[R5, #+0]
    416            *ilen -= zkp_length;
   \       0x78   0x683A             LDR      R2,[R7, #+0]
   \       0x7A   0x3A20             SUBS     R2,R2,#+32
   \       0x7C   0x603A             STR      R2,[R7, #+0]
    417          
    418            if (wlen != NULL) {
   \       0x7E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x82   0xD004             BEQ.N    ??ecjpake_write_tls_zkp_3
    419              *wlen += zkp_length + 1;
   \       0x84   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x88   0x3021             ADDS     R0,R0,#+33
   \       0x8A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    420            }
    421          
    422            return SL_STATUS_OK;
   \                     ??ecjpake_write_tls_zkp_3: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \                     ??ecjpake_write_tls_zkp_1: (+1)
   \       0x90   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    423          }
    424          
    425          /***************************************************************************//**
    426           * Check if an ECJPAKE context is ready for use.
    427           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    428          sl_status_t sl_se_ecjpake_check(const sl_se_ecjpake_context_t *ctx)
    429          {
    430            if (ctx == NULL) {
   \                     sl_se_ecjpake_check: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF1C             ITT      NE
   \        0x4   0x6840             LDRNE    R0,[R0, #+4]
   \        0x6   0x2800             CMPNE    R0,#+0
    431              return SL_STATUS_INVALID_PARAMETER;
    432            }
    433          
    434            if (ctx->curve_flags == 0) {
   \        0x8   0xD101             BNE.N    ??sl_se_ecjpake_check_0
    435              return SL_STATUS_INVALID_PARAMETER;
   \        0xA   0x2021             MOVS     R0,#+33
   \        0xC   0x4770             BX       LR
    436            }
    437          
    438            return SL_STATUS_OK;
   \                     ??sl_se_ecjpake_check_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
    439          }
    440          
    441          /***************************************************************************//**
    442           * Derive the shared secret.
    443           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    444          sl_status_t sl_se_ecjpake_derive_secret(sl_se_ecjpake_context_t *ctx,
    445                                                  unsigned char *buf,
    446                                                  size_t len,
    447                                                  size_t *olen)
    448          {
   \                     sl_se_ecjpake_derive_secret: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x461C             MOV      R4,R3
    449            sl_se_command_context_t *cmd_ctx;
    450            SE_Command_t *se_cmd;
    451          
    452            if (ctx == NULL || buf == NULL || olen == NULL) {
   \        0xA   0xBF18             IT       NE
   \        0xC   0x2900             CMPNE    R1,#+0
   \        0xE   0xD000             BEQ.N    ??sl_se_ecjpake_derive_secret_0
   \       0x10   0xB90C             CBNZ.N   R4,??sl_se_ecjpake_derive_secret_1
    453              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_derive_secret_0: (+1)
   \       0x12   0x2021             MOVS     R0,#+33
   \       0x14   0xE06F             B.N      ??sl_se_ecjpake_derive_secret_2
    454            }
    455          
    456            if (len < 32) {
   \                     ??sl_se_ecjpake_derive_secret_1: (+1)
   \       0x16   0x2A20             CMP      R2,#+32
   \       0x18   0xBF38             IT       CC
   \       0x1A   0x201D             MOVCC    R0,#+29
    457              return SL_STATUS_WOULD_OVERFLOW;
   \       0x1C   0xD36B             BCC.N    ??sl_se_ecjpake_derive_secret_2
    458            }
    459          
    460            cmd_ctx = ctx->cmd_ctx;
   \       0x1E   0x682E             LDR      R6,[R5, #+0]
    461            se_cmd = &ctx->cmd_ctx->command;
    462          
    463            // Generated session key needs to come out unprotected.
    464            uint32_t gen_key_flags = 32;
    465          
    466            // SE command structures.
    467            sli_se_command_init(cmd_ctx,
    468                                SLI_SE_COMMAND_JPAKE_GEN_SESSIONKEY
    469                                | SLI_SE_COMMAND_OPTION_HASH_SHA256);
   \       0x20   0x.... 0x....      LDR.W    R3,??DataTable47
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x6033             STR      R3,[R6, #+0]
   \       0x28   0x6072             STR      R2,[R6, #+4]
   \       0x2A   0x60B2             STR      R2,[R6, #+8]
   \       0x2C   0x61F2             STR      R2,[R6, #+28]
    470            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0x2E   0x.... 0x....      ADR.W    R0,?_2
   \       0x32   0xE890 0x008C      LDM      R0,{R2,R3,R7}
    471            SE_DataTransfer_t pwd_in = SE_DATATRANSFER_DEFAULT(ctx->pwd, ctx->pwd_len);
   \       0x36   0x.... 0x....      ADR.W    R0,?_3
   \       0x3A   0xE890 0x0700      LDM      R0,{R8-R10}
   \       0x3E   0xF10D 0x0C3C      ADD      R12,SP,#+60
   \       0x42   0xF10D 0x0B30      ADD      R11,SP,#+48
   \       0x46   0xE88C 0x008C      STM      R12,{R2,R3,R7}
   \       0x4A   0xE88B 0x0700      STM      R11,{R8-R10}
   \       0x4E   0xF105 0x0009      ADD      R0,R5,#+9
   \       0x52   0x900C             STR      R0,[SP, #+48]
   \       0x54   0x6AEA             LDR      R2,[R5, #+44]
    472            SE_DataTransfer_t r_in = SE_DATATRANSFER_DEFAULT(ctx->r, 32);
   \       0x56   0x.... 0x....      ADR.W    R0,?_4
   \       0x5A   0xAF09             ADD      R7,SP,#+36
   \       0x5C   0xF042 0x5200      ORR      R2,R2,#0x20000000
   \       0x60   0x920E             STR      R2,[SP, #+56]
   \       0x62   0xE890 0x400C      LDM      R0,{R2,R3,LR}
   \       0x66   0xF105 0x0930      ADD      R9,R5,#+48
    473            SE_DataTransfer_t Xp2_in = SE_DATATRANSFER_DEFAULT(ctx->Xp2, 64);
   \       0x6A   0x.... 0x....      ADR.W    R0,?_5
   \       0x6E   0xE887 0x400C      STM      R7,{R2,R3,LR}
   \       0x72   0xF8CD 0x9024      STR      R9,[SP, #+36]
   \       0x76   0xE890 0x010C      LDM      R0,{R2,R3,R8}
   \       0x7A   0xAF06             ADD      R7,SP,#+24
   \       0x7C   0xF505 0x7988      ADD      R9,R5,#+272
   \       0x80   0xE887 0x010C      STM      R7,{R2,R3,R8}
   \       0x84   0xF8CD 0x9018      STR      R9,[SP, #+24]
    474            SE_DataTransfer_t Xp_in = SE_DATATRANSFER_DEFAULT(ctx->Xp, 64);
   \       0x88   0x.... 0x....      ADR.W    R0,?_6
   \       0x8C   0xE890 0x008C      LDM      R0,{R2,R3,R7}
   \       0x90   0xF10D 0x0E0C      ADD      LR,SP,#+12
   \       0x94   0xF505 0x79A8      ADD      R9,R5,#+336
   \       0x98   0xE88E 0x008C      STM      LR,{R2,R3,R7}
   \       0x9C   0xF8CD 0x900C      STR      R9,[SP, #+12]
    475            SE_DataTransfer_t key_out = SE_DATATRANSFER_DEFAULT(buf, 32);
   \       0xA0   0x.... 0x....      ADR.W    R2,?_7
   \       0xA4   0xE892 0x0188      LDM      R2,{R3,R7,R8}
   \       0xA8   0x46EE             MOV      LR,SP
    476          
    477            SE_addDataInput(se_cmd, &domain_in);
   \       0xAA   0x4630             MOV      R0,R6
   \       0xAC   0xE88E 0x0188      STM      LR,{R3,R7,R8}
   \       0xB0   0x9100             STR      R1,[SP, #+0]
   \       0xB2   0xA90F             ADD      R1,SP,#+60
   \       0xB4   0x.... 0x....      BL       SE_addDataInput
    478            SE_addDataInput(se_cmd, &pwd_in);
   \       0xB8   0x.... 0x....      BL       ?Subroutine3
    479            SE_addDataInput(se_cmd, &r_in);
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0xBC   0xA909             ADD      R1,SP,#+36
   \       0xBE   0x.... 0x....      BL       ??Subroutine3_0
    480            SE_addDataInput(se_cmd, &Xp2_in);
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0xC2   0xA906             ADD      R1,SP,#+24
   \       0xC4   0x.... 0x....      BL       ??Subroutine3_0
    481            SE_addDataInput(se_cmd, &Xp_in);
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0xC8   0xA903             ADD      R1,SP,#+12
   \       0xCA   0x.... 0x....      BL       ??Subroutine3_0
    482          
    483            SE_addDataOutput(se_cmd, &key_out);
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0xCE   0x4669             MOV      R1,SP
   \       0xD0   0x4630             MOV      R0,R6
   \       0xD2   0x.... 0x....      BL       SE_addDataOutput
    484          
    485            SE_addParameter(se_cmd, ctx->curve_flags);
   \       0xD6   0x6869             LDR      R1,[R5, #+4]
   \       0xD8   0x.... 0x....      BL       ??Subroutine4_0
    486            SE_addParameter(se_cmd, ctx->pwd_len);
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0xDC   0x6AE9             LDR      R1,[R5, #+44]
   \       0xDE   0x.... 0x....      BL       ??Subroutine4_0
    487            SE_addParameter(se_cmd, gen_key_flags);
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0xE2   0x2120             MOVS     R1,#+32
   \       0xE4   0x.... 0x....      BL       ??Subroutine4_0
    488          
    489            sl_status_t ret = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0xE8   0x.... 0x....      BL       ?Subroutine5
    490          
    491            if (ret == SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xBF0C             ITE      EQ
   \       0xF0   0x2120             MOVEQ    R1,#+32
   \       0xF2   0x2100             MOVNE    R1,#+0
    492              *olen = 32;
    493            } else {
    494              *olen = 0;
   \       0xF4   0x6021             STR      R1,[R4, #+0]
    495            }
    496            return ret;
   \                     ??sl_se_ecjpake_derive_secret_2: (+1)
   \       0xF6   0xB013             ADD      SP,SP,#+76
   \       0xF8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    497          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x.... 0x....      B.W      sli_se_execute_and_wait

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \                     ??Subroutine4_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xA90C             ADD      R1,SP,#+48
   \                     ??Subroutine3_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020
    498          
    499          /***************************************************************************//**
    500           * This clears an ECJPAKE context.
    501           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    502          sl_status_t sl_se_ecjpake_free(sl_se_ecjpake_context_t *ctx)
    503          {
   \                     sl_se_ecjpake_free: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    504            if (ctx == NULL) {
   \        0x2   0xB908             CBNZ.N   R0,??sl_se_ecjpake_free_0
    505              return SL_STATUS_INVALID_PARAMETER;
   \        0x4   0x2021             MOVS     R0,#+33
   \        0x6   0xBD02             POP      {R1,PC}
    506            }
    507          
    508            memset(ctx, 0, sizeof(*ctx));
   \                     ??sl_se_ecjpake_free_0: (+1)
   \        0x8   0xF44F 0x71C8      MOV      R1,#+400
   \        0xC   0x.... 0x....      BL       __aeabi_memclr4
    509          
    510            return SL_STATUS_OK;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD02             POP      {R1,PC}
    511          }
    512          
    513          /***************************************************************************//**
    514           * Initialize an ECJPAKE context.
    515           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    516          sl_status_t sl_se_ecjpake_init(sl_se_ecjpake_context_t *ctx,
    517                                         sl_se_command_context_t *cmd_ctx)
    518          {
   \                     sl_se_ecjpake_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x460C             MOV      R4,R1
    519            if (ctx == NULL || cmd_ctx == NULL) {
   \        0x6   0xBF18             IT       NE
   \        0x8   0x2C00             CMPNE    R4,#+0
   \        0xA   0xD101             BNE.N    ??sl_se_ecjpake_init_0
    520              return SL_STATUS_INVALID_PARAMETER;
   \        0xC   0x2021             MOVS     R0,#+33
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    521            }
    522          
    523            memset(ctx, 0, sizeof(*ctx));
   \                     ??sl_se_ecjpake_init_0: (+1)
   \       0x10   0xF44F 0x71C8      MOV      R1,#+400
   \       0x14   0x.... 0x....      BL       __aeabi_memclr4
    524          
    525            // store pointer to command context object
    526            ctx->cmd_ctx = cmd_ctx;
   \       0x18   0x602C             STR      R4,[R5, #+0]
    527          
    528            return SL_STATUS_OK;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
    529          }
    530          
    531          /***************************************************************************//**
    532           * Read and process the first round message.
    533           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          sl_status_t sl_se_ecjpake_read_round_one(sl_se_ecjpake_context_t *ctx,
    535                                                   const unsigned char *buf,
    536                                                   size_t len)
    537          {
   \                     sl_se_ecjpake_read_round_one: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB0C8             SUB      SP,SP,#+288
   \        0x6   0x0004             MOVS     R4,R0
    538            sl_status_t ret = SL_STATUS_OK;
    539          
    540            if (ctx == NULL || buf == NULL) {
   \        0x8   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_one_0
   \        0xA   0x0008             MOVS     R0,R1
   \        0xC   0xD101             BNE.N    ??sl_se_ecjpake_read_round_one_1
    541              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_read_round_one_0: (+1)
   \        0xE   0x2021             MOVS     R0,#+33
   \                     ??sl_se_ecjpake_read_round_one_2: (+1)
   \       0x10   0xE0AE             B.N      ??CrossCallReturnLabel_41
    542            }
    543            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_read_round_one_1: (+1)
   \       0x12   0x6826             LDR      R6,[R4, #+0]
    544            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
   \       0x14   0x2160             MOVS     R1,#+96
   \       0x16   0xA830             ADD      R0,SP,#+192
   \       0x18   0x.... 0x....      BL       __aeabi_memclr4
   \       0x1C   0x2160             MOVS     R1,#+96
   \       0x1E   0xA818             ADD      R0,SP,#+96
   \       0x20   0x.... 0x....      BL       __aeabi_memclr4
    545          
    546            // We should receive 2 binary points and 2 ZKP's.
    547          
    548            // Local storage for ZKP's.
    549            uint8_t zkp1[32 + 64] = { 0 };
    550            uint8_t zkp2[32 + 64] = { 0 };
    551          
    552            uint8_t *obuf = ctx->Xp1;
    553            size_t olen = 64;
   \       0x24   0x2140             MOVS     R1,#+64
    554          
    555            // Parse structures.
    556            ret = ecjpake_parse_tls_point(&buf, &len, NULL, &obuf, &olen);
   \       0x26   0xAA01             ADD      R2,SP,#+4
   \       0x28   0xF104 0x08D0      ADD      R8,R4,#+208
   \       0x2C   0x9101             STR      R1,[SP, #+4]
   \       0x2E   0x9200             STR      R2,[SP, #+0]
   \       0x30   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \       0x34   0x.... 0x....      BL       ?Subroutine1
    557            if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD1E9             BNE.N    ??sl_se_ecjpake_read_round_one_2
    558              return ret;
    559            }
    560          
    561            obuf = zkp1;
   \       0x3C   0xAA30             ADD      R2,SP,#+192
   \       0x3E   0x.... 0x....      BL       ?Subroutine2
    562            olen = 96;
    563            ret = ecjpake_parse_tls_zkp(&buf, &len, NULL, &obuf, &olen);
    564            if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD112             BNE.N    ??sl_se_ecjpake_read_round_one_3
    565              return ret;
    566            }
    567          
    568            obuf = ctx->Xp2;
    569            olen = 64;
   \       0x46   0x2140             MOVS     R1,#+64
    570            ret = ecjpake_parse_tls_point(&buf, &len, NULL, &obuf, &olen);
   \       0x48   0xAA01             ADD      R2,SP,#+4
   \       0x4A   0xF504 0x7788      ADD      R7,R4,#+272
   \       0x4E   0x9101             STR      R1,[SP, #+4]
   \       0x50   0x9200             STR      R2,[SP, #+0]
   \       0x52   0x9702             STR      R7,[SP, #+8]
   \       0x54   0x.... 0x....      BL       ?Subroutine1
    571            if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD107             BNE.N    ??sl_se_ecjpake_read_round_one_3
    572              return ret;
    573            }
    574          
    575            obuf = zkp2;
   \       0x5C   0xAA18             ADD      R2,SP,#+96
   \       0x5E   0x.... 0x....      BL       ?Subroutine2
    576            olen = 96;
    577            ret = ecjpake_parse_tls_zkp(&buf, &len, NULL, &obuf, &olen);
    578            if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD102             BNE.N    ??sl_se_ecjpake_read_round_one_3
    579              return ret;
    580            }
    581          
    582            if (len > 0) {
   \       0x66   0x984A             LDR      R0,[SP, #+296]
   \       0x68   0xB108             CBZ.N    R0,??sl_se_ecjpake_read_round_one_4
    583              // Too much input.
    584              return SL_STATUS_WOULD_OVERFLOW;
   \       0x6A   0x201D             MOVS     R0,#+29
   \                     ??sl_se_ecjpake_read_round_one_3: (+1)
   \       0x6C   0xE080             B.N      ??CrossCallReturnLabel_41
    585            }
    586          
    587            // SE command structures.
    588            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R1_VERIFY);
   \                     ??sl_se_ecjpake_read_round_one_4: (+1)
   \       0x6E   0x.... 0x....      LDR.W    R2,??DataTable47_1
   \       0x72   0x.... 0x....      BL       ?Subroutine11
    589            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x76   0x.... 0x....      ADR.W    R0,?_8
   \       0x7A   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x7E   0xF10D 0x0C54      ADD      R12,SP,#+84
    590            SE_DataTransfer_t userid_mine = SE_DATATRANSFER_DEFAULT(
    591              (void*)ecjpake_id[ctx->role], strlen(ecjpake_id[ctx->role]));
   \       0x82   0xF10D 0x0B48      ADD      R11,SP,#+72
   \       0x86   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x8A   0x.... 0x....      ADR.W    R1,?_9
   \       0x8E   0xE891 0x0601      LDM      R1,{R0,R9,R10}
   \       0x92   0x.... 0x....      ADR.W    R5,ecjpake_id
   \       0x96   0xE88B 0x0601      STM      R11,{R0,R9,R10}
   \       0x9A   0x7A21             LDRB     R1,[R4, #+8]
   \       0x9C   0xF855 0x0021      LDR      R0,[R5, R1, LSL #+2]
   \       0xA0   0x9012             STR      R0,[SP, #+72]
   \       0xA2   0x7A21             LDRB     R1,[R4, #+8]
   \       0xA4   0xF855 0x0021      LDR      R0,[R5, R1, LSL #+2]
   \       0xA8   0x.... 0x....      BL       strlen
   \       0xAC   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xB0   0x9014             STR      R0,[SP, #+80]
    592            SE_DataTransfer_t userid_peer = SE_DATATRANSFER_DEFAULT(
    593              (void*)ecjpake_id[1 - ctx->role], strlen(ecjpake_id[1 - ctx->role]));
   \       0xB2   0x.... 0x....      ADR.W    LR,?_10
   \       0xB6   0xE89E 0x0007      LDM      LR,{R0-R2}
   \       0xBA   0xAB0F             ADD      R3,SP,#+60
   \       0xBC   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xC0   0x7A23             LDRB     R3,[R4, #+8]
   \       0xC2   0x1D28             ADDS     R0,R5,#+4
   \       0xC4   0x425B             RSBS     R3,R3,#+0
   \       0xC6   0xF850 0x1023      LDR      R1,[R0, R3, LSL #+2]
   \       0xCA   0x910F             STR      R1,[SP, #+60]
   \       0xCC   0x7A21             LDRB     R1,[R4, #+8]
   \       0xCE   0x.... 0x....      BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0xD2   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xD6   0x9011             STR      R0,[SP, #+68]
    594            SE_DataTransfer_t Xp1_in = SE_DATATRANSFER_DEFAULT(ctx->Xp1, 64);
   \       0xD8   0x.... 0x....      ADR.W    R1,?_11
   \       0xDC   0xE891 0x040C      LDM      R1,{R2,R3,R10}
   \       0xE0   0xF10D 0x0E30      ADD      LR,SP,#+48
    595            SE_DataTransfer_t zkp1_in = SE_DATATRANSFER_DEFAULT(zkp1, sizeof(zkp1));
   \       0xE4   0xA909             ADD      R1,SP,#+36
   \       0xE6   0xE88E 0x040C      STM      LR,{R2,R3,R10}
   \       0xEA   0xF8CD 0x8030      STR      R8,[SP, #+48]
   \       0xEE   0x.... 0x....      ADR.W    R2,?_12
   \       0xF2   0xE892 0x0901      LDM      R2,{R0,R8,R11}
   \       0xF6   0xF10D 0x0AC0      ADD      R10,SP,#+192
    596            SE_DataTransfer_t Xp2_in = SE_DATATRANSFER_DEFAULT(ctx->Xp2, 64);
   \       0xFA   0xF10D 0x0E18      ADD      LR,SP,#+24
   \       0xFE   0xE881 0x0901      STM      R1,{R0,R8,R11}
   \      0x102   0xF8CD 0xA024      STR      R10,[SP, #+36]
   \      0x106   0x.... 0x....      ADR.W    R1,?_13
   \      0x10A   0xE891 0x010C      LDM      R1,{R2,R3,R8}
    597            SE_DataTransfer_t zkp2_in = SE_DATATRANSFER_DEFAULT(zkp2, sizeof(zkp2));
   \      0x10E   0xF10D 0x0B0C      ADD      R11,SP,#+12
   \      0x112   0xA918             ADD      R1,SP,#+96
   \      0x114   0xE88E 0x010C      STM      LR,{R2,R3,R8}
   \      0x118   0x9706             STR      R7,[SP, #+24]
   \      0x11A   0x.... 0x....      ADR.W    R7,?_14
   \      0x11E   0xE897 0x4401      LDM      R7,{R0,R10,LR}
   \      0x122   0xE88B 0x4401      STM      R11,{R0,R10,LR}
   \      0x126   0x9103             STR      R1,[SP, #+12]
    598          
    599            SE_addDataInput(se_cmd, &domain_in);
   \      0x128   0xA915             ADD      R1,SP,#+84
   \      0x12A   0x.... 0x....      BL       ??Subroutine3_0
    600            SE_addDataInput(se_cmd, &userid_mine);
   \                     ??CrossCallReturnLabel_19: (+1)
   \      0x12E   0xA912             ADD      R1,SP,#+72
   \      0x130   0x.... 0x....      BL       ??Subroutine3_0
    601            SE_addDataInput(se_cmd, &userid_peer);
   \                     ??CrossCallReturnLabel_18: (+1)
   \      0x134   0xA90F             ADD      R1,SP,#+60
   \      0x136   0x.... 0x....      BL       ??Subroutine3_0
    602            SE_addDataInput(se_cmd, &Xp1_in);
   \                     ??CrossCallReturnLabel_17: (+1)
   \      0x13A   0x.... 0x....      BL       ?Subroutine3
    603            SE_addDataInput(se_cmd, &zkp1_in);
   \                     ??CrossCallReturnLabel_25: (+1)
   \      0x13E   0xA909             ADD      R1,SP,#+36
   \      0x140   0x.... 0x....      BL       ??Subroutine3_0
    604            SE_addDataInput(se_cmd, &Xp2_in);
   \                     ??CrossCallReturnLabel_16: (+1)
   \      0x144   0xA906             ADD      R1,SP,#+24
   \      0x146   0x.... 0x....      BL       ??Subroutine3_0
    605            SE_addDataInput(se_cmd, &zkp2_in);
   \                     ??CrossCallReturnLabel_15: (+1)
   \      0x14A   0xA903             ADD      R1,SP,#+12
   \      0x14C   0x.... 0x....      BL       ??Subroutine3_0
    606          
    607            SE_addParameter(se_cmd, ctx->curve_flags);
   \                     ??CrossCallReturnLabel_14: (+1)
   \      0x150   0x6861             LDR      R1,[R4, #+4]
   \      0x152   0x.... 0x....      BL       ??Subroutine4_0
    608            SE_addParameter(se_cmd, strlen(ecjpake_id[ctx->role]));
   \                     ??CrossCallReturnLabel_32: (+1)
   \      0x156   0x7A20             LDRB     R0,[R4, #+8]
   \      0x158   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \      0x15C   0x.... 0x....      BL       strlen
   \      0x160   0x.... 0x....      BL       ?Subroutine4
    609            SE_addParameter(se_cmd, strlen(ecjpake_id[1 - ctx->role]));
   \                     ??CrossCallReturnLabel_38: (+1)
   \      0x164   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_85: (+1)
   \      0x168   0x.... 0x....      BL       ?Subroutine4
    610          
    611            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_37: (+1)
   \      0x16C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_41: (+1)
   \      0x170   0x....             B.N      ?Subroutine0
    612          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x9202             STR      R2,[SP, #+8]
   \        0x2   0x2160             MOVS     R1,#+96
   \        0x4   0xAA01             ADD      R2,SP,#+4
   \        0x6   0x9101             STR      R1,[SP, #+4]
   \        0x8   0x9200             STR      R2,[SP, #+0]
   \        0xA   0xAB02             ADD      R3,SP,#+8
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0xA94A             ADD      R1,SP,#+296
   \       0x10   0xA849             ADD      R0,SP,#+292
   \       0x12   0x....             B.N      ecjpake_parse_tls_zkp

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xAB02             ADD      R3,SP,#+8
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0xA94A             ADD      R1,SP,#+296
   \        0x6   0xA849             ADD      R0,SP,#+292
   \        0x8   0x....             B.N      ecjpake_parse_tls_point

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x7A21             LDRB     R1,[R4, #+8]
   \        0x2   0x1D28             ADDS     R0,R5,#+4
   \                     ??Subroutine13_0: (+1)
   \        0x4   0x4249             RSBS     R1,R1,#+0
   \        0x6   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \        0xA   0x.... 0x....      B.W      strlen

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x6032             STR      R2,[R6, #+0]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6071             STR      R1,[R6, #+4]
   \        0x6   0x60B0             STR      R0,[R6, #+8]
   \        0x8   0x61F1             STR      R1,[R6, #+28]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB04B             ADD      SP,SP,#+300
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    613          
    614          /***************************************************************************//**
    615           * Read and process the second round message.
    616           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    617          sl_status_t sl_se_ecjpake_read_round_two(sl_se_ecjpake_context_t *ctx,
    618                                                   const unsigned char *buf,
    619                                                   size_t len)
    620          {
   \                     sl_se_ecjpake_read_round_two: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB0B0             SUB      SP,SP,#+192
   \        0x6   0x0004             MOVS     R4,R0
    621            if (ctx == NULL || buf == NULL) {
   \        0x8   0xBF18             IT       NE
   \        0xA   0x2900             CMPNE    R1,#+0
   \        0xC   0xD00A             BEQ.N    ??sl_se_ecjpake_read_round_two_0
    622              return SL_STATUS_INVALID_PARAMETER;
    623            }
    624          
    625            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
    626            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
    627            sl_status_t ret = SL_STATUS_OK;
    628          
    629            // Local storage for ZKP.
    630            uint8_t zkpB[32 + 64];
    631          
    632            if (ctx->role == SL_SE_ECJPAKE_CLIENT) {
   \        0xE   0x7A20             LDRB     R0,[R4, #+8]
   \       0x10   0x6826             LDR      R6,[R4, #+0]
   \       0x12   0xB9D0             CBNZ.N   R0,??sl_se_ecjpake_read_round_two_1
    633              uint16_t tls_id;
    634          
    635              if (len < 3) {
   \       0x14   0x2A03             CMP      R2,#+3
   \       0x16   0xD305             BCC.N    ??sl_se_ecjpake_read_round_two_0
    636                return SL_STATUS_INVALID_PARAMETER;
    637              }
    638          
    639              // First byte is curve_type; only named_curve is handled.
    640              if (*(buf++) != SL_SE_ECP_TLS_NAMED_CURVE) {
   \       0x18   0x1C48             ADDS     R0,R1,#+1
   \       0x1A   0x9031             STR      R0,[SP, #+196]
   \       0x1C   0xF810 0x1D01      LDRB     R1,[R0, #-1]!
   \       0x20   0x2903             CMP      R1,#+3
   \       0x22   0xD001             BEQ.N    ??sl_se_ecjpake_read_round_two_2
    641                return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_read_round_two_0: (+1)
   \       0x24   0x2021             MOVS     R0,#+33
   \                     ??sl_se_ecjpake_read_round_two_3: (+1)
   \       0x26   0xE0AA             B.N      ??CrossCallReturnLabel_40
    642              }
    643          
    644              // Next two bytes are the namedcurve value.
    645              tls_id = *(buf++);
   \                     ??sl_se_ecjpake_read_round_two_2: (+1)
   \       0x28   0x9831             LDR      R0,[SP, #+196]
   \       0x2A   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \       0x2E   0x9031             STR      R0,[SP, #+196]
    646              tls_id <<= 8;
    647              tls_id |= *(buf++);
   \       0x30   0x7800             LDRB     R0,[R0, #+0]
   \       0x32   0x9A31             LDR      R2,[SP, #+196]
   \       0x34   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \       0x38   0x1C51             ADDS     R1,R2,#+1
   \       0x3A   0x9131             STR      R1,[SP, #+196]
    648          
    649              // We support only one curve.
    650              if (tls_id != SL_SE_TLSID_ECC_P256) {
   \       0x3C   0x2817             CMP      R0,#+23
   \       0x3E   0xBF18             IT       NE
   \       0x40   0x200F             MOVNE    R0,#+15
    651                return SL_STATUS_NOT_SUPPORTED;
   \       0x42   0xD1F0             BNE.N    ??sl_se_ecjpake_read_round_two_3
    652              }
    653          
    654              len -= 3;
   \       0x44   0x9832             LDR      R0,[SP, #+200]
   \       0x46   0x1EC0             SUBS     R0,R0,#+3
   \       0x48   0x9032             STR      R0,[SP, #+200]
    655            }
    656          
    657            // We should receive 1 binary point and 1 ZKP.
    658            uint8_t *obuf = ctx->Xp;
   \                     ??sl_se_ecjpake_read_round_two_1: (+1)
   \       0x4A   0xF504 0x77A8      ADD      R7,R4,#+336
    659            size_t olen = 64;
   \       0x4E   0x2140             MOVS     R1,#+64
   \       0x50   0x9702             STR      R7,[SP, #+8]
   \       0x52   0x9101             STR      R1,[SP, #+4]
    660          
    661            // Parse structures.
    662            ret = ecjpake_parse_tls_point(&buf, &len, NULL, &obuf, &olen);
   \       0x54   0xA801             ADD      R0,SP,#+4
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \       0x58   0xAB02             ADD      R3,SP,#+8
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0xA932             ADD      R1,SP,#+200
   \       0x5E   0xA831             ADD      R0,SP,#+196
   \       0x60   0x.... 0x....      BL       ecjpake_parse_tls_point
    663            if (ret != SL_STATUS_OK) {
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD10C             BNE.N    ??sl_se_ecjpake_read_round_two_4
    664              return ret;
    665            }
    666          
    667            obuf = zkpB;
   \       0x68   0xA918             ADD      R1,SP,#+96
   \       0x6A   0x9102             STR      R1,[SP, #+8]
    668            olen = sizeof(zkpB);
   \       0x6C   0x2260             MOVS     R2,#+96
    669            ret = ecjpake_parse_tls_zkp(&buf, &len, NULL, &obuf, &olen);
   \       0x6E   0xA901             ADD      R1,SP,#+4
   \       0x70   0x9201             STR      R2,[SP, #+4]
   \       0x72   0x9100             STR      R1,[SP, #+0]
   \       0x74   0xAB02             ADD      R3,SP,#+8
   \       0x76   0x2200             MOVS     R2,#+0
   \       0x78   0xA932             ADD      R1,SP,#+200
   \       0x7A   0xA831             ADD      R0,SP,#+196
   \       0x7C   0x.... 0x....      BL       ecjpake_parse_tls_zkp
    670            if (ret != SL_STATUS_OK) {
   \       0x80   0x2800             CMP      R0,#+0
   \                     ??sl_se_ecjpake_read_round_two_4: (+1)
   \       0x82   0xD17C             BNE.N    ??CrossCallReturnLabel_40
    671              return ret;
    672            }
    673          
    674            if (len > 0) {
   \       0x84   0x9832             LDR      R0,[SP, #+200]
   \       0x86   0xB108             CBZ.N    R0,??sl_se_ecjpake_read_round_two_5
    675              // Too much input.
    676              return SL_STATUS_WOULD_OVERFLOW;
   \       0x88   0x201D             MOVS     R0,#+29
   \       0x8A   0xE078             B.N      ??CrossCallReturnLabel_40
    677            }
    678          
    679            // SE command structures.
    680            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R2_VERIFY);
   \                     ??sl_se_ecjpake_read_round_two_5: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R2,??DataTable47_2
   \       0x90   0x.... 0x....      BL       ?Subroutine11
    681            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x94   0x.... 0x....      ADR.W    R0,?_15
   \       0x98   0xE890 0x000E      LDM      R0,{R1-R3}
    682            SE_DataTransfer_t userid_peer = SE_DATATRANSFER_DEFAULT(
    683              (void*)ecjpake_id[1 - ctx->role], strlen(ecjpake_id[1 - ctx->role]));
   \       0x9C   0x.... 0x....      ADR.W    R0,?_16
   \       0xA0   0xE890 0x0B00      LDM      R0,{R8,R9,R11}
   \       0xA4   0xF10D 0x0C54      ADD      R12,SP,#+84
   \       0xA8   0xF10D 0x0A48      ADD      R10,SP,#+72
   \       0xAC   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0xB0   0xE88A 0x0B00      STM      R10,{R8,R9,R11}
   \       0xB4   0x7A21             LDRB     R1,[R4, #+8]
   \       0xB6   0x.... 0x....      ADR.W    R5,ecjpake_id
   \       0xBA   0x1D28             ADDS     R0,R5,#+4
   \       0xBC   0x4249             RSBS     R1,R1,#+0
   \       0xBE   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0xC2   0x1D29             ADDS     R1,R5,#+4
   \       0xC4   0x.... 0x....      ADR.W    R9,?_17
   \       0xC8   0x9012             STR      R0,[SP, #+72]
   \       0xCA   0x7A20             LDRB     R0,[R4, #+8]
   \       0xCC   0xF104 0x0A50      ADD      R10,R4,#+80
   \       0xD0   0xF10D 0x0B0C      ADD      R11,SP,#+12
   \       0xD4   0x4240             RSBS     R0,R0,#+0
   \       0xD6   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0xDA   0x.... 0x....      BL       strlen
   \       0xDE   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xE2   0x9014             STR      R0,[SP, #+80]
    684            SE_DataTransfer_t Xm1_in = SE_DATATRANSFER_DEFAULT(ctx->Xm1, 64);
   \       0xE4   0xE899 0x0007      LDM      R9,{R0-R2}
   \       0xE8   0xAB0F             ADD      R3,SP,#+60
    685            SE_DataTransfer_t Xm2_in = SE_DATATRANSFER_DEFAULT(ctx->Xm2, 64);
   \       0xEA   0xF10D 0x0E30      ADD      LR,SP,#+48
   \       0xEE   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xF2   0xF8CD 0xA03C      STR      R10,[SP, #+60]
   \       0xF6   0x.... 0x....      ADR.W    R0,?_18
   \       0xFA   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xFE   0xF104 0x0990      ADD      R9,R4,#+144
    686            SE_DataTransfer_t Xp1_in = SE_DATATRANSFER_DEFAULT(ctx->Xp1, 64);
   \      0x102   0x.... 0x....      ADR.W    R0,?_19
   \      0x106   0xE88E 0x000E      STM      LR,{R1-R3}
   \      0x10A   0xF8CD 0x9030      STR      R9,[SP, #+48]
   \      0x10E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x112   0xF10D 0x0E24      ADD      LR,SP,#+36
   \      0x116   0xF104 0x0AD0      ADD      R10,R4,#+208
   \      0x11A   0xE88E 0x000E      STM      LR,{R1-R3}
   \      0x11E   0xF8CD 0xA024      STR      R10,[SP, #+36]
    687            SE_DataTransfer_t Xp_in = SE_DATATRANSFER_DEFAULT(ctx->Xp, 64);
   \      0x122   0x.... 0x....      ADR.W    R1,?_20
   \      0x126   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x12A   0xF10D 0x0918      ADD      R9,SP,#+24
    688            SE_DataTransfer_t zkpB_in = SE_DATATRANSFER_DEFAULT(zkpB, sizeof(zkpB));
   \      0x12E   0xA918             ADD      R1,SP,#+96
   \      0x130   0xE889 0x400C      STM      R9,{R2,R3,LR}
   \      0x134   0x9706             STR      R7,[SP, #+24]
   \      0x136   0x.... 0x....      ADR.W    R7,?_21
   \      0x13A   0xE897 0x0601      LDM      R7,{R0,R9,R10}
   \      0x13E   0xE88B 0x0601      STM      R11,{R0,R9,R10}
   \      0x142   0x9103             STR      R1,[SP, #+12]
    689          
    690            SE_addDataInput(se_cmd, &domain_in);
   \      0x144   0xA915             ADD      R1,SP,#+84
   \      0x146   0x.... 0x....      BL       ??Subroutine3_0
    691            SE_addDataInput(se_cmd, &userid_peer);
   \                     ??CrossCallReturnLabel_13: (+1)
   \      0x14A   0xA912             ADD      R1,SP,#+72
   \      0x14C   0x.... 0x....      BL       ??Subroutine3_0
    692            SE_addDataInput(se_cmd, &Xm1_in);
   \                     ??CrossCallReturnLabel_12: (+1)
   \      0x150   0xA90F             ADD      R1,SP,#+60
   \      0x152   0x.... 0x....      BL       ??Subroutine3_0
    693            SE_addDataInput(se_cmd, &Xm2_in);
   \                     ??CrossCallReturnLabel_11: (+1)
   \      0x156   0x.... 0x....      BL       ?Subroutine3
    694            SE_addDataInput(se_cmd, &Xp1_in);
   \                     ??CrossCallReturnLabel_24: (+1)
   \      0x15A   0xA909             ADD      R1,SP,#+36
   \      0x15C   0x.... 0x....      BL       ??Subroutine3_0
    695            SE_addDataInput(se_cmd, &Xp_in);
   \                     ??CrossCallReturnLabel_10: (+1)
   \      0x160   0xA906             ADD      R1,SP,#+24
   \      0x162   0x.... 0x....      BL       ??Subroutine3_0
    696            SE_addDataInput(se_cmd, &zkpB_in);
   \                     ??CrossCallReturnLabel_9: (+1)
   \      0x166   0xA903             ADD      R1,SP,#+12
   \      0x168   0x.... 0x....      BL       ??Subroutine3_0
    697          
    698            SE_addParameter(se_cmd, ctx->curve_flags);
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x16C   0x6861             LDR      R1,[R4, #+4]
   \      0x16E   0x.... 0x....      BL       ??Subroutine4_0
    699            SE_addParameter(se_cmd, strlen(ecjpake_id[1 - ctx->role]));
   \                     ??CrossCallReturnLabel_31: (+1)
   \      0x172   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_84: (+1)
   \      0x176   0x.... 0x....      BL       ?Subroutine4
    700          
    701            return sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_36: (+1)
   \      0x17A   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_40: (+1)
   \      0x17E   0xB033             ADD      SP,SP,#+204
   \      0x180   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    702          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    703          
    704          /***************************************************************************//**
    705           * Set up an ECJPAKE context for use.
    706           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    707          sl_status_t sl_se_ecjpake_setup(sl_se_ecjpake_context_t *ctx,
    708                                          sl_se_ecjpake_role_t role,
    709                                          sl_se_hash_type_t hash,
    710                                          uint32_t curve,
    711                                          const unsigned char *secret,
    712                                          size_t len)
    713          {
   \                     sl_se_ecjpake_setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    714            if (ctx == NULL || (len > 0 && secret == NULL)) {
   \        0x2   0xB128             CBZ.N    R0,??sl_se_ecjpake_setup_0
   \        0x4   0x9D05             LDR      R5,[SP, #+20]
   \        0x6   0x9C04             LDR      R4,[SP, #+16]
   \        0x8   0xB125             CBZ.N    R5,??sl_se_ecjpake_setup_1
   \        0xA   0xB10C             CBZ.N    R4,??sl_se_ecjpake_setup_0
    715              return SL_STATUS_INVALID_PARAMETER;
    716            }
    717          
    718            // SE only supports passphrases of maximum 32 bytes.
    719            if (len > sizeof(ctx->pwd)) {
   \        0xC   0x2D21             CMP      R5,#+33
   \        0xE   0xD301             BCC.N    ??sl_se_ecjpake_setup_1
    720              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_setup_0: (+1)
   \       0x10   0x2021             MOVS     R0,#+33
   \       0x12   0xBD32             POP      {R1,R4,R5,PC}
    721            }
    722          
    723            // SE currently only supports SHA256 as JPAKE hashing mechanism.
    724            if (hash != SL_SE_HASH_SHA256) {
   \                     ??sl_se_ecjpake_setup_1: (+1)
   \       0x14   0x2A03             CMP      R2,#+3
   \       0x16   0xBF04             ITT      EQ
   \       0x18   0x.... 0x....      LDREQ.W  R2,??DataTable47_3
   \       0x1C   0x4293             CMPEQ    R3,R2
    725              return SL_STATUS_NOT_SUPPORTED;
    726            }
    727          
    728            // SE currently only supports ECDSA secp256r1 as curve.
    729            if (curve != SL_SE_KEY_TYPE_ECC_P256) {
   \       0x1E   0xD001             BEQ.N    ??sl_se_ecjpake_setup_2
    730              return SL_STATUS_NOT_SUPPORTED;
   \       0x20   0x200F             MOVS     R0,#+15
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
    731            }
    732          
    733            ctx->curve_flags = 0x8000001FUL;
   \                     ??sl_se_ecjpake_setup_2: (+1)
   \       0x24   0x.... 0x....      LDR.W    R3,??DataTable47_4
   \       0x28   0x6043             STR      R3,[R0, #+4]
    734            ctx->role = role;
   \       0x2A   0x7201             STRB     R1,[R0, #+8]
    735            ctx->pwd_len = len;
   \       0x2C   0x62C5             STR      R5,[R0, #+44]
    736            memcpy(ctx->pwd, secret, len);
   \       0x2E   0x462A             MOV      R2,R5
   \       0x30   0x4621             MOV      R1,R4
   \       0x32   0x3009             ADDS     R0,R0,#+9
   \       0x34   0x.... 0x....      BL       __aeabi_memcpy
    737          
    738            return SL_STATUS_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    739          }
    740          
    741          /***************************************************************************//**
    742           * Generate and write the first round message.
    743           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    744          sl_status_t sl_se_ecjpake_write_round_one(sl_se_ecjpake_context_t *ctx,
    745                                                    unsigned char *buf,
    746                                                    size_t len,
    747                                                    size_t *olen)
    748          {
   \                     sl_se_ecjpake_write_round_one: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0xB0CA             SUB      SP,SP,#+296
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x461E             MOV      R6,R3
    749            sl_status_t ret = SL_STATUS_OK;
    750          
    751            if (ctx == NULL || buf == NULL || olen == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2D00             CMPNE    R5,#+0
   \       0x10   0xD000             BEQ.N    ??sl_se_ecjpake_write_round_one_0
   \       0x12   0xB90E             CBNZ.N   R6,??sl_se_ecjpake_write_round_one_1
    752              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_write_round_one_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE09E             B.N      ??CrossCallReturnLabel_77
    753            }
    754          
    755            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_write_round_one_1: (+1)
   \       0x18   0x6827             LDR      R7,[R4, #+0]
    756            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
    757            *olen = 0;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x6031             STR      R1,[R6, #+0]
    758          
    759            // Local storage for ZKP's.
    760            uint8_t zkp1[32 + 64];
    761            uint8_t zkp2[32 + 64];
    762          
    763            // SE command structures.
    764            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R1_GENERATE);
   \       0x1E   0xF04F 0x6230      MOV      R2,#+184549376
   \       0x22   0x603A             STR      R2,[R7, #+0]
   \       0x24   0x6079             STR      R1,[R7, #+4]
   \       0x26   0x60B9             STR      R1,[R7, #+8]
   \       0x28   0x61F9             STR      R1,[R7, #+28]
    765            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0x2A   0x.... 0x....      ADR.W    R0,?_22
   \       0x2E   0xE890 0x0B00      LDM      R0,{R8,R9,R11}
    766            SE_DataTransfer_t userid = SE_DATATRANSFER_DEFAULT(
    767              (void*)ecjpake_id[ctx->role], strlen(ecjpake_id[ctx->role]));
   \       0x32   0x.... 0x....      ADR.W    R0,?_23
   \       0x36   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0x3A   0xF10D 0x0C50      ADD      R12,SP,#+80
   \       0x3E   0xF10D 0x0A5C      ADD      R10,SP,#+92
   \       0x42   0xE88C 0x000E      STM      R12,{R1-R3}
   \       0x46   0xE88A 0x0B00      STM      R10,{R8,R9,R11}
   \       0x4A   0xF894 0xE008      LDRB     LR,[R4, #+8]
   \       0x4E   0x.... 0x....      ADR.W    R9,ecjpake_id
   \       0x52   0xF104 0x0830      ADD      R8,R4,#+48
   \       0x56   0xF859 0x002E      LDR      R0,[R9, LR, LSL #+2]
   \       0x5A   0xF10D 0x0AC8      ADD      R10,SP,#+200
   \       0x5E   0x9014             STR      R0,[SP, #+80]
   \       0x60   0x7A21             LDRB     R1,[R4, #+8]
   \       0x62   0xF859 0x0021      LDR      R0,[R9, R1, LSL #+2]
   \       0x66   0x.... 0x....      BL       strlen
   \       0x6A   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0x6E   0x9016             STR      R0,[SP, #+88]
    768            SE_DataTransfer_t r_out = SE_DATATRANSFER_DEFAULT(ctx->r, 32);
   \       0x70   0x.... 0x....      ADR.W    R0,?_24
   \       0x74   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0x78   0xAB11             ADD      R3,SP,#+68
    769            SE_DataTransfer_t Xm1_out = SE_DATATRANSFER_DEFAULT(ctx->Xm1, 64);
   \       0x7A   0x.... 0x....      ADR.W    R0,?_25
   \       0x7E   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0x82   0xF8CD 0x8044      STR      R8,[SP, #+68]
   \       0x86   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0x8A   0xAB0E             ADD      R3,SP,#+56
   \       0x8C   0xF104 0x0850      ADD      R8,R4,#+80
   \       0x90   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0x94   0xF8CD 0x8038      STR      R8,[SP, #+56]
    770            SE_DataTransfer_t zkp1_out = SE_DATATRANSFER_DEFAULT(zkp1, sizeof(zkp1));
   \       0x98   0x.... 0x....      ADR.W    R0,?_26
   \       0x9C   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xA0   0xAB0B             ADD      R3,SP,#+44
    771            SE_DataTransfer_t Xm2_out = SE_DATATRANSFER_DEFAULT(ctx->Xm2, 64);
   \       0xA2   0x.... 0x....      ADR.W    R0,?_27
   \       0xA6   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xAA   0xF8CD 0xA02C      STR      R10,[SP, #+44]
   \       0xAE   0xE890 0x0106      LDM      R0,{R1,R2,R8}
   \       0xB2   0xAB08             ADD      R3,SP,#+32
    772            SE_DataTransfer_t zkp2_out = SE_DATATRANSFER_DEFAULT(zkp2, sizeof(zkp2));
   \       0xB4   0x.... 0x....      ADR.W    R0,?_28
   \       0xB8   0xE883 0x0106      STM      R3,{R1,R2,R8}
   \       0xBC   0xF104 0x0890      ADD      R8,R4,#+144
   \       0xC0   0xF8CD 0x8020      STR      R8,[SP, #+32]
   \       0xC4   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC8   0xF10D 0x0E14      ADD      LR,SP,#+20
   \       0xCC   0xF10D 0x0A68      ADD      R10,SP,#+104
   \       0xD0   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xD4   0xF8CD 0xA014      STR      R10,[SP, #+20]
    773          
    774            SE_addDataInput(se_cmd, &domain_in);
   \       0xD8   0x.... 0x....      BL       ?Subroutine6
    775            SE_addDataInput(se_cmd, &userid);
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0xDC   0xA914             ADD      R1,SP,#+80
   \       0xDE   0x.... 0x....      BL       ??Subroutine6_0
    776          
    777            SE_addDataOutput(se_cmd, &r_out);
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0xE2   0xA911             ADD      R1,SP,#+68
   \       0xE4   0x.... 0x....      BL       ??Subroutine8_0
    778            SE_addDataOutput(se_cmd, &Xm1_out);
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0xE8   0xA90E             ADD      R1,SP,#+56
   \       0xEA   0x.... 0x....      BL       ??Subroutine8_0
    779            SE_addDataOutput(se_cmd, &zkp1_out);
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0xEE   0xA90B             ADD      R1,SP,#+44
   \       0xF0   0x.... 0x....      BL       ??Subroutine8_0
    780            SE_addDataOutput(se_cmd, &Xm2_out);
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0xF4   0x.... 0x....      BL       ?Subroutine8
    781            SE_addDataOutput(se_cmd, &zkp2_out);
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0xF8   0xA905             ADD      R1,SP,#+20
   \       0xFA   0x.... 0x....      BL       ??Subroutine8_0
    782          
    783            SE_addParameter(se_cmd, ctx->curve_flags);
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0xFE   0x.... 0x....      BL       ?Subroutine7
    784            SE_addParameter(se_cmd, strlen(ecjpake_id[ctx->role]));
   \                     ??CrossCallReturnLabel_64: (+1)
   \      0x102   0x7A20             LDRB     R0,[R4, #+8]
   \      0x104   0xF859 0x0020      LDR      R0,[R9, R0, LSL #+2]
   \      0x108   0x.... 0x....      BL       strlen
   \      0x10C   0x4601             MOV      R1,R0
   \      0x10E   0x.... 0x....      BL       ??Subroutine7_0
    785          
    786            ret = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_62: (+1)
   \      0x112   0x4638             MOV      R0,R7
   \      0x114   0x.... 0x....      BL       sli_se_execute_and_wait
    787          
    788            if (ret == SL_STATUS_OK) {
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD11C             BNE.N    ??CrossCallReturnLabel_77
    789              // To write TLS structures of ECJ-PAKE, we need to write:
    790              // Xm1, zkp1, Xm2 and zkp2.
    791              uint8_t *obuf = buf;
    792              const uint8_t *ibuf = ctx->Xm1;
   \      0x11C   0xF104 0x0150      ADD      R1,R4,#+80
    793              size_t ilen = 64;
   \      0x120   0x2240             MOVS     R2,#+64
    794          
    795              ret = ecjpake_write_tls_point(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x122   0xA802             ADD      R0,SP,#+8
   \      0x124   0x9103             STR      R1,[SP, #+12]
   \      0x126   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_81: (+1)
   \      0x12A   0x.... 0x....      BL       ?Subroutine14
    796              if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_88: (+1)
   \      0x12E   0xB990             CBNZ.N   R0,??CrossCallReturnLabel_77
    797                return ret;
    798              }
    799          
    800              ibuf = zkp1;
   \      0x130   0xA932             ADD      R1,SP,#+200
   \      0x132   0x.... 0x....      BL       ?Subroutine10
    801              ilen = 96;
    802              ret = ecjpake_write_tls_zkp(&obuf, &len, olen, &ibuf, &ilen, 64);
    803              if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_78: (+1)
   \      0x136   0xB970             CBNZ.N   R0,??CrossCallReturnLabel_77
    804                return ret;
    805              }
    806          
    807              ibuf = ctx->Xm2;
    808              ilen = 64;
   \      0x138   0x2140             MOVS     R1,#+64
    809              ret = ecjpake_write_tls_point(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x13A   0xAA02             ADD      R2,SP,#+8
   \      0x13C   0x9102             STR      R1,[SP, #+8]
   \      0x13E   0x9101             STR      R1,[SP, #+4]
   \      0x140   0x9200             STR      R2,[SP, #+0]
   \      0x142   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \      0x146   0xAB03             ADD      R3,SP,#+12
   \      0x148   0x4632             MOV      R2,R6
   \      0x14A   0x.... 0x....      BL       ?Subroutine14
    810              if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_87: (+1)
   \      0x14E   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_77
    811                return ret;
    812              }
    813          
    814              ibuf = zkp2;
   \      0x150   0xA91A             ADD      R1,SP,#+104
   \      0x152   0x.... 0x....      BL       ?Subroutine10
    815              ilen = 96;
    816              ret = ecjpake_write_tls_zkp(&obuf, &len, olen, &ibuf, &ilen, 64);
    817            }
    818            return ret;
   \                     ??CrossCallReturnLabel_77: (+1)
   \      0x156                      REQUIRE ?Subroutine0
   \      0x156                      ;; // Fall through to label ?Subroutine0
    819          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0xA94A             ADD      R1,SP,#+296
   \                     ??Subroutine14_0: (+1)
   \        0x2   0xA804             ADD      R0,SP,#+16
   \        0x4   0x....             B.N      ecjpake_write_tls_point

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x9103             STR      R1,[SP, #+12]
   \        0x2   0x2260             MOVS     R2,#+96
   \        0x4   0x2140             MOVS     R1,#+64
   \        0x6   0xAB02             ADD      R3,SP,#+8
   \        0x8   0x9202             STR      R2,[SP, #+8]
   \        0xA   0x9101             STR      R1,[SP, #+4]
   \        0xC   0x9300             STR      R3,[SP, #+0]
   \        0xE   0xAB03             ADD      R3,SP,#+12
   \       0x10   0x4632             MOV      R2,R6
   \       0x12   0xA94A             ADD      R1,SP,#+296
   \       0x14   0xA804             ADD      R0,SP,#+16
   \       0x16   0x....             B.N      ecjpake_write_tls_zkp

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x9202             STR      R2,[SP, #+8]
   \        0x2   0x9201             STR      R2,[SP, #+4]
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x9504             STR      R5,[SP, #+16]
   \        0x8   0xAB03             ADD      R3,SP,#+12
   \        0xA   0x4632             MOV      R2,R6
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0xA908             ADD      R1,SP,#+32
   \                     ??Subroutine8_0: (+1)
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      SE_addDataOutput

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x6861             LDR      R1,[R4, #+4]
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      SE_addParameter

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xA917             ADD      R1,SP,#+92
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x.... 0x....      B.W      SE_addDataInput

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    820          
    821          /***************************************************************************//**
    822           * Generate and write the second round message.
    823           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    824          sl_status_t sl_se_ecjpake_write_round_two(sl_se_ecjpake_context_t *ctx,
    825                                                    unsigned char *buf,
    826                                                    size_t len,
    827                                                    size_t *olen)
    828          {
   \                     sl_se_ecjpake_write_round_two: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0xB0C8             SUB      SP,SP,#+288
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x461E             MOV      R6,R3
    829            sl_status_t ret = SL_STATUS_OK;
    830          
    831            if (ctx == NULL || buf == NULL || olen == NULL) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2D00             CMPNE    R5,#+0
   \       0x10   0xD000             BEQ.N    ??sl_se_ecjpake_write_round_two_0
   \       0x12   0xB90E             CBNZ.N   R6,??sl_se_ecjpake_write_round_two_1
    832              return SL_STATUS_INVALID_PARAMETER;
   \                     ??sl_se_ecjpake_write_round_two_0: (+1)
   \       0x14   0x2021             MOVS     R0,#+33
   \       0x16   0xE0D0             B.N      ??sl_se_ecjpake_write_round_two_2
    833            }
    834            sl_se_command_context_t *cmd_ctx = ctx->cmd_ctx;
   \                     ??sl_se_ecjpake_write_round_two_1: (+1)
   \       0x18   0x6827             LDR      R7,[R4, #+0]
    835            SE_Command_t *se_cmd = &ctx->cmd_ctx->command;
    836          
    837            *olen = 0;
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x6032             STR      R2,[R6, #+0]
    838          
    839            uint8_t zkpA[32 + 64];
    840            uint8_t xA[64];
    841          
    842            // SE command structures.
    843            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_JPAKE_R2_GENERATE);
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable47_5
   \       0x22   0x6039             STR      R1,[R7, #+0]
   \       0x24   0x607A             STR      R2,[R7, #+4]
   \       0x26   0x60BA             STR      R2,[R7, #+8]
   \       0x28   0x61FA             STR      R2,[R7, #+28]
    844            SE_DataTransfer_t domain_in = SE_DATATRANSFER_DEFAULT(NULL, 0);
   \       0x2A   0x.... 0x....      ADR.W    R0,?_29
   \       0x2E   0xE890 0x0700      LDM      R0,{R8-R10}
    845            SE_DataTransfer_t pwd_in = SE_DATATRANSFER_DEFAULT(ctx->pwd, ctx->pwd_len);
   \       0x32   0x.... 0x....      ADR.W    R0,?_30
   \       0x36   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0x3A   0xF10D 0x0B74      ADD      R11,SP,#+116
   \       0x3E   0xE88B 0x0700      STM      R11,{R8-R10}
   \       0x42   0xAB1A             ADD      R3,SP,#+104
   \       0x44   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0x48   0xF104 0x0B09      ADD      R11,R4,#+9
   \       0x4C   0xF8CD 0xB068      STR      R11,[SP, #+104]
   \       0x50   0x6AE0             LDR      R0,[R4, #+44]
    846            SE_DataTransfer_t userid = SE_DATATRANSFER_DEFAULT(
    847              (void*)ecjpake_id[ctx->role], strlen(ecjpake_id[ctx->role]));
   \       0x52   0x.... 0x....      ADR.W    LR,?_31
   \       0x56   0xAB17             ADD      R3,SP,#+92
   \       0x58   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0x5C   0x901C             STR      R0,[SP, #+112]
   \       0x5E   0xE89E 0x0007      LDM      LR,{R0-R2}
   \       0x62   0x.... 0x....      ADR.W    R8,ecjpake_id
   \       0x66   0xF104 0x0930      ADD      R9,R4,#+48
   \       0x6A   0xE883 0x0007      STM      R3,{R0-R2}
   \       0x6E   0x7A23             LDRB     R3,[R4, #+8]
   \       0x70   0xF104 0x0A50      ADD      R10,R4,#+80
   \       0x74   0xF858 0x0023      LDR      R0,[R8, R3, LSL #+2]
   \       0x78   0x9017             STR      R0,[SP, #+92]
   \       0x7A   0x7A21             LDRB     R1,[R4, #+8]
   \       0x7C   0xF858 0x0021      LDR      R0,[R8, R1, LSL #+2]
   \       0x80   0x.... 0x....      BL       strlen
   \       0x84   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0x88   0x9019             STR      R0,[SP, #+100]
    848            SE_DataTransfer_t r_in = SE_DATATRANSFER_DEFAULT(ctx->r, 32);
   \       0x8A   0x.... 0x....      ADR.W    R0,?_32
   \       0x8E   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0x92   0xAB14             ADD      R3,SP,#+80
    849            SE_DataTransfer_t Xm1_in = SE_DATATRANSFER_DEFAULT(ctx->Xm1, 64);
   \       0x94   0x.... 0x....      ADR.W    R0,?_33
   \       0x98   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0x9C   0xF8CD 0x9050      STR      R9,[SP, #+80]
   \       0xA0   0xE890 0x4006      LDM      R0,{R1,R2,LR}
   \       0xA4   0xAB11             ADD      R3,SP,#+68
    850            SE_DataTransfer_t Xp1_in = SE_DATATRANSFER_DEFAULT(ctx->Xp1, 64);
   \       0xA6   0x.... 0x....      ADR.W    R9,?_34
   \       0xAA   0xE883 0x4006      STM      R3,{R1,R2,LR}
   \       0xAE   0xF8CD 0xA044      STR      R10,[SP, #+68]
   \       0xB2   0xE899 0x0007      LDM      R9,{R0-R2}
   \       0xB6   0xAB0E             ADD      R3,SP,#+56
   \       0xB8   0xF104 0x0AD0      ADD      R10,R4,#+208
   \       0xBC   0xE883 0x0007      STM      R3,{R0-R2}
   \       0xC0   0xF8CD 0xA038      STR      R10,[SP, #+56]
    851            SE_DataTransfer_t Xp2_in = SE_DATATRANSFER_DEFAULT(ctx->Xp2, 64);
   \       0xC4   0x.... 0x....      ADR.W    R0,?_35
   \       0xC8   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xCC   0xF10D 0x0E2C      ADD      LR,SP,#+44
   \       0xD0   0xF504 0x7988      ADD      R9,R4,#+272
   \       0xD4   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xD8   0xF8CD 0x902C      STR      R9,[SP, #+44]
    852            SE_DataTransfer_t xA_out = SE_DATATRANSFER_DEFAULT(xA, sizeof(xA));
   \       0xDC   0x.... 0x....      ADR.W    R0,?_36
   \       0xE0   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xE4   0xF10D 0x0E20      ADD      LR,SP,#+32
   \       0xE8   0xF10D 0x0980      ADD      R9,SP,#+128
   \       0xEC   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xF0   0xF8CD 0x9020      STR      R9,[SP, #+32]
    853            SE_DataTransfer_t zkpA_out = SE_DATATRANSFER_DEFAULT(zkpA, sizeof(zkpA));
   \       0xF4   0x.... 0x....      ADR.W    R0,?_37
   \       0xF8   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xFC   0xF10D 0x0E14      ADD      LR,SP,#+20
   \      0x100   0xF10D 0x09C0      ADD      R9,SP,#+192
   \      0x104   0xE88E 0x000E      STM      LR,{R1-R3}
   \      0x108   0xF8CD 0x9014      STR      R9,[SP, #+20]
    854          
    855            SE_addDataInput(se_cmd, &domain_in);
   \      0x10C   0xA91D             ADD      R1,SP,#+116
   \      0x10E   0x.... 0x....      BL       ??Subroutine6_0
    856            SE_addDataInput(se_cmd, &pwd_in);
   \                     ??CrossCallReturnLabel_52: (+1)
   \      0x112   0xA91A             ADD      R1,SP,#+104
   \      0x114   0x.... 0x....      BL       ??Subroutine6_0
    857            SE_addDataInput(se_cmd, &userid);
   \                     ??CrossCallReturnLabel_51: (+1)
   \      0x118   0x.... 0x....      BL       ?Subroutine6
    858            SE_addDataInput(se_cmd, &r_in);
   \                     ??CrossCallReturnLabel_54: (+1)
   \      0x11C   0xA914             ADD      R1,SP,#+80
   \      0x11E   0x.... 0x....      BL       ??Subroutine6_0
    859            SE_addDataInput(se_cmd, &Xm1_in);
   \                     ??CrossCallReturnLabel_50: (+1)
   \      0x122   0xA911             ADD      R1,SP,#+68
   \      0x124   0x.... 0x....      BL       ??Subroutine6_0
    860            SE_addDataInput(se_cmd, &Xp1_in);
   \                     ??CrossCallReturnLabel_49: (+1)
   \      0x128   0xA90E             ADD      R1,SP,#+56
   \      0x12A   0x.... 0x....      BL       ??Subroutine6_0
    861            SE_addDataInput(se_cmd, &Xp2_in);
   \                     ??CrossCallReturnLabel_48: (+1)
   \      0x12E   0xA90B             ADD      R1,SP,#+44
   \      0x130   0x.... 0x....      BL       ??Subroutine6_0
    862          
    863            SE_addDataOutput(se_cmd, &xA_out);
   \                     ??CrossCallReturnLabel_47: (+1)
   \      0x134   0x.... 0x....      BL       ?Subroutine8
    864            SE_addDataOutput(se_cmd, &zkpA_out);
   \                     ??CrossCallReturnLabel_71: (+1)
   \      0x138   0xA905             ADD      R1,SP,#+20
   \      0x13A   0x.... 0x....      BL       ??Subroutine8_0
    865          
    866            SE_addParameter(se_cmd, ctx->curve_flags);
   \                     ??CrossCallReturnLabel_66: (+1)
   \      0x13E   0x.... 0x....      BL       ?Subroutine7
    867            SE_addParameter(se_cmd, ctx->pwd_len);
   \                     ??CrossCallReturnLabel_63: (+1)
   \      0x142   0x6AE1             LDR      R1,[R4, #+44]
   \      0x144   0x.... 0x....      BL       ??Subroutine7_0
    868            SE_addParameter(se_cmd, strlen(ecjpake_id[ctx->role]));
   \                     ??CrossCallReturnLabel_61: (+1)
   \      0x148   0x7A20             LDRB     R0,[R4, #+8]
   \      0x14A   0xF858 0x0020      LDR      R0,[R8, R0, LSL #+2]
   \      0x14E   0x.... 0x....      BL       strlen
   \      0x152   0x4601             MOV      R1,R0
   \      0x154   0x.... 0x....      BL       ??Subroutine7_0
    869          
    870            ret = sli_se_execute_and_wait(cmd_ctx);
   \                     ??CrossCallReturnLabel_60: (+1)
   \      0x158   0x4638             MOV      R0,R7
   \      0x15A   0x.... 0x....      BL       sli_se_execute_and_wait
    871          
    872            if (ret == SLI_SE_RESPONSE_OK) {
   \      0x15E   0xBB60             CBNZ.N   R0,??sl_se_ecjpake_write_round_two_2
    873              // If we are the server, we need to write out the ECParams.
    874              if (ctx->role == SL_SE_ECJPAKE_SERVER) {
   \      0x160   0x7A20             LDRB     R0,[R4, #+8]
   \      0x162   0x2801             CMP      R0,#+1
   \      0x164   0xD111             BNE.N    ??sl_se_ecjpake_write_round_two_3
    875                if (len < 3 + 66 + 66 + 33) {
   \      0x166   0x9848             LDR      R0,[SP, #+288]
   \      0x168   0x28A8             CMP      R0,#+168
   \      0x16A   0xBF38             IT       CC
   \      0x16C   0x201D             MOVCC    R0,#+29
    876                  return SL_STATUS_WOULD_OVERFLOW;
   \      0x16E   0xD324             BCC.N    ??sl_se_ecjpake_write_round_two_2
    877                }
    878                // First byte is curve_type, always named_curve.
    879                *(buf++) = SL_SE_ECP_TLS_NAMED_CURVE;
   \      0x170   0x2103             MOVS     R1,#+3
   \      0x172   0x7029             STRB     R1,[R5, #+0]
    880          
    881                // Next two bytes are the namedcurve value, we only support one.
    882                *(buf++) = SL_SE_TLSID_ECC_P256 >> 8;
   \      0x174   0x2200             MOVS     R2,#+0
    883                *(buf++) = SL_SE_TLSID_ECC_P256 & 0xFF;
   \      0x176   0x2017             MOVS     R0,#+23
   \      0x178   0x706A             STRB     R2,[R5, #+1]
   \      0x17A   0x70A8             STRB     R0,[R5, #+2]
    884          
    885                *olen += 3;
   \      0x17C   0x6831             LDR      R1,[R6, #+0]
   \      0x17E   0x1CED             ADDS     R5,R5,#+3
   \      0x180   0x1CC9             ADDS     R1,R1,#+3
   \      0x182   0x6031             STR      R1,[R6, #+0]
    886                len -= 3;
   \      0x184   0x9848             LDR      R0,[SP, #+288]
   \      0x186   0x1EC0             SUBS     R0,R0,#+3
   \      0x188   0x9048             STR      R0,[SP, #+288]
    887              }
    888          
    889              // To write TLS structures of ECJ-PAKE, we need to write:
    890              // xA in uncompressed form and zkpA in uncompressed form
    891              uint8_t *obuf = buf;
    892              const uint8_t *ibuf = xA;
   \                     ??sl_se_ecjpake_write_round_two_3: (+1)
   \      0x18A   0xAB20             ADD      R3,SP,#+128
    893              size_t ilen = 64;
   \      0x18C   0x2240             MOVS     R2,#+64
    894          
    895              ret = ecjpake_write_tls_point(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x18E   0xA802             ADD      R0,SP,#+8
   \      0x190   0x9303             STR      R3,[SP, #+12]
   \      0x192   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_82: (+1)
   \      0x196   0xA948             ADD      R1,SP,#+288
   \      0x198   0x.... 0x....      BL       ??Subroutine14_0
    896              if (ret != SL_STATUS_OK) {
   \                     ??CrossCallReturnLabel_86: (+1)
   \      0x19C   0xB968             CBNZ.N   R0,??sl_se_ecjpake_write_round_two_2
    897                return ret;
    898              }
    899          
    900              ibuf = zkpA;
   \      0x19E   0xA930             ADD      R1,SP,#+192
   \      0x1A0   0x9103             STR      R1,[SP, #+12]
    901              ilen = 96;
   \      0x1A2   0x2260             MOVS     R2,#+96
    902              ret = ecjpake_write_tls_zkp(&obuf, &len, olen, &ibuf, &ilen, 64);
   \      0x1A4   0x2340             MOVS     R3,#+64
   \      0x1A6   0xA902             ADD      R1,SP,#+8
   \      0x1A8   0x9202             STR      R2,[SP, #+8]
   \      0x1AA   0x9301             STR      R3,[SP, #+4]
   \      0x1AC   0x9100             STR      R1,[SP, #+0]
   \      0x1AE   0xAB03             ADD      R3,SP,#+12
   \      0x1B0   0x4632             MOV      R2,R6
   \      0x1B2   0xA948             ADD      R1,SP,#+288
   \      0x1B4   0xA804             ADD      R0,SP,#+16
   \      0x1B6   0x.... 0x....      BL       ecjpake_write_tls_zkp
    903            }
    904          
    905            return ret;
   \                     ??sl_se_ecjpake_write_round_two_2: (+1)
   \      0x1BA   0xB049             ADD      SP,SP,#+292
   \      0x1BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    906          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'912
   \              0x0000'0001  
   \              0x2000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_30:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'944
   \              0x0000'0001  
   \              0x2000'0020

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'870'976
   \              0x0000'0001  
   \              0x2000'0040

   \                                 In section .text, align 4, keep-with-next
   \                     ?_37:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 536'871'008
   \              0x0000'0001  
   \              0x2000'0060
    907          
    908          // -------------------------------
    909          // Key derivation functions
    910          
    911          #if (defined(_SILICON_LABS_SECURITY_FEATURE) \
    912            && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT))
    913          /***************************************************************************//**
    914           * HKDF key derivation.
    915           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    916          sl_status_t sl_se_derive_key_hkdf(sl_se_command_context_t *cmd_ctx,
    917                                            const sl_se_key_descriptor_t *in_key,
    918                                            sl_se_hash_type_t hash,
    919                                            const unsigned char *salt,
    920                                            size_t salt_len,
    921                                            const unsigned char *info,
    922                                            size_t info_len,
    923                                            sl_se_key_descriptor_t *out_key)
    924          {
   \                     sl_se_derive_key_hkdf: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB092             SUB      SP,SP,#+72
   \        0x6   0x0006             MOVS     R6,R0
   \        0x8   0x468A             MOV      R10,R1
   \        0xA   0x4698             MOV      R8,R3
    925            uint32_t hash_mask;
    926            sl_status_t status = SL_STATUS_OK;
    927          
    928            if ((cmd_ctx == NULL) || (in_key == NULL) || (out_key == NULL)) {
   \        0xC   0xBF1E             ITTT     NE
   \        0xE   0xF1BA 0x0F00      CMPNE    R10,#+0
   \       0x12   0xF8DD 0x9074      LDRNE    R9,[SP, #+116]
   \       0x16   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x1A   0xD024             BEQ.N    ??sl_se_derive_key_hkdf_1
   \       0x1C   0x9F1A             LDR      R7,[SP, #+104]
    929              return SL_STATUS_INVALID_PARAMETER;
    930            }
    931            if ((salt == NULL) && (salt_len != 0U)) {
   \       0x1E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x22   0xD100             BNE.N    ??sl_se_derive_key_hkdf_2
   \       0x24   0xB9FF             CBNZ.N   R7,??sl_se_derive_key_hkdf_1
   \                     ??sl_se_derive_key_hkdf_2: (+1)
   \       0x26   0x9C1B             LDR      R4,[SP, #+108]
   \       0x28   0x9D1C             LDR      R5,[SP, #+112]
    932              return SL_STATUS_INVALID_PARAMETER;
    933            }
    934            if ((info == NULL) && (info_len != 0U)) {
   \       0x2A   0xB904             CBNZ.N   R4,??sl_se_derive_key_hkdf_3
   \       0x2C   0xB9DD             CBNZ.N   R5,??sl_se_derive_key_hkdf_1
    935              return SL_STATUS_INVALID_PARAMETER;
    936            }
    937          
    938            switch (hash) {
   \                     ??sl_se_derive_key_hkdf_3: (+1)
   \       0x2E   0x1E52             SUBS     R2,R2,#+1
   \       0x30   0x2A04             CMP      R2,#+4
   \       0x32   0xD818             BHI.N    ??sl_se_derive_key_hkdf_1
   \       0x34   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??sl_se_derive_key_hkdf_0:
   \       0x38   0x03 0x0F          DC8      0x3,0xF,0x11,0x13
   \              0x11 0x13
   \       0x3C   0x15 0x00          DC8      0x15,0x0
    939              case SL_SE_HASH_SHA1:
    940                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA1;
   \                     ??sl_se_derive_key_hkdf_4: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable47_6
    941                break;
    942          
    943              case SL_SE_HASH_SHA224:
    944                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA224;
    945                break;
    946          
    947              case SL_SE_HASH_SHA256:
    948                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA256;
    949                break;
    950          
    951              case SL_SE_HASH_SHA384:
    952                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA384;
    953                break;
    954          
    955              case SL_SE_HASH_SHA512:
    956                hash_mask = SLI_SE_COMMAND_OPTION_HASH_SHA512;
    957                break;
    958          
    959              default:
    960                return SL_STATUS_INVALID_PARAMETER;
    961                break;
    962            }
    963          
    964            // SE command structures.
    965            SE_Command_t *se_cmd = &cmd_ctx->command;
    966            sli_se_command_init(cmd_ctx, SLI_SE_COMMAND_DERIVE_KEY_HKDF | hash_mask);
   \                     ??sl_se_derive_key_hkdf_5: (+1)
   \       0x40   0x6030             STR      R0,[R6, #+0]
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x6071             STR      R1,[R6, #+4]
   \       0x46   0x60B1             STR      R1,[R6, #+8]
   \       0x48   0x61F1             STR      R1,[R6, #+28]
    967          
    968            sli_add_key_parameters(cmd_ctx, in_key, status);
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x4650             MOV      R0,R10
   \       0x4E   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x52   0xB150             CBZ.N    R0,??sl_se_derive_key_hkdf_6
   \       0x54   0xE05D             B.N      ??CrossCallReturnLabel_39
   \                     ??sl_se_derive_key_hkdf_7: (+1)
   \       0x56   0x....             LDR.N    R0,??DataTable47_7
   \       0x58   0xE7F2             B.N      ??sl_se_derive_key_hkdf_5
   \                     ??sl_se_derive_key_hkdf_8: (+1)
   \       0x5A   0x....             LDR.N    R0,??DataTable47_8
   \       0x5C   0xE7F0             B.N      ??sl_se_derive_key_hkdf_5
   \                     ??sl_se_derive_key_hkdf_9: (+1)
   \       0x5E   0x....             LDR.N    R0,??DataTable47_9
   \       0x60   0xE7EE             B.N      ??sl_se_derive_key_hkdf_5
   \                     ??sl_se_derive_key_hkdf_10: (+1)
   \       0x62   0x....             LDR.N    R0,??DataTable47_10
   \       0x64   0xE7EC             B.N      ??sl_se_derive_key_hkdf_5
   \                     ??sl_se_derive_key_hkdf_1: (+1)
   \       0x66   0x2021             MOVS     R0,#+33
   \       0x68   0xE053             B.N      ??CrossCallReturnLabel_39
   \                     ??sl_se_derive_key_hkdf_6: (+1)
   \       0x6A   0x9900             LDR      R1,[SP, #+0]
   \       0x6C   0x.... 0x....      BL       ??Subroutine4_0
    969            SE_addParameter(se_cmd, salt_len);
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x70   0x4639             MOV      R1,R7
   \       0x72   0x.... 0x....      BL       ??Subroutine4_0
    970            SE_addParameter(se_cmd, info_len);
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x76   0x4629             MOV      R1,R5
   \       0x78   0x.... 0x....      BL       ??Subroutine4_0
    971            sli_add_key_parameters(cmd_ctx, out_key, status);
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x7C   0x4669             MOV      R1,SP
   \       0x7E   0x4648             MOV      R0,R9
   \       0x80   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD144             BNE.N    ??CrossCallReturnLabel_39
   \       0x88   0x9900             LDR      R1,[SP, #+0]
   \       0x8A   0x.... 0x....      BL       ??Subroutine4_0
    972          
    973            sli_add_key_metadata(cmd_ctx, in_key, status);
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x8E   0xA90F             ADD      R1,SP,#+60
   \       0x90   0x4650             MOV      R0,R10
   \       0x92   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD13B             BNE.N    ??CrossCallReturnLabel_39
   \       0x9A   0xA90F             ADD      R1,SP,#+60
   \       0x9C   0x.... 0x....      BL       ??Subroutine3_0
    974            sli_add_key_input(cmd_ctx, in_key, status);
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0xA0   0xA90C             ADD      R1,SP,#+48
   \       0xA2   0x4650             MOV      R0,R10
   \       0xA4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD132             BNE.N    ??CrossCallReturnLabel_39
   \       0xAC   0x.... 0x....      BL       ?Subroutine3
    975          
    976            sli_add_key_metadata_custom(cmd_ctx, auth_data, out_key, status);
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xB0   0xA909             ADD      R1,SP,#+36
   \       0xB2   0x4648             MOV      R0,R9
   \       0xB4   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xB8   0xBB58             CBNZ.N   R0,??CrossCallReturnLabel_39
   \       0xBA   0xA909             ADD      R1,SP,#+36
   \       0xBC   0x.... 0x....      BL       ??Subroutine3_0
    977          
    978            SE_DataTransfer_t salt_in = SE_DATATRANSFER_DEFAULT(salt, salt_len);
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0xC0   0x....             ADR.N    R0,?_38
   \       0xC2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xC6   0xF10D 0x0A18      ADD      R10,SP,#+24
   \       0xCA   0xF047 0x5700      ORR      R7,R7,#0x20000000
   \       0xCE   0xE88A 0x000E      STM      R10,{R1-R3}
   \       0xD2   0xF8CD 0x8018      STR      R8,[SP, #+24]
   \       0xD6   0x9708             STR      R7,[SP, #+32]
    979            SE_addDataInput(se_cmd, &salt_in);
   \       0xD8   0xA906             ADD      R1,SP,#+24
   \       0xDA   0x.... 0x....      BL       ??Subroutine3_0
    980          
    981            SE_DataTransfer_t info_in = SE_DATATRANSFER_DEFAULT(info, info_len);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0xDE   0xBF00             Nop
   \       0xE0   0x....             ADR.N    R0,?_39
   \       0xE2   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xE6   0xF10D 0x0A0C      ADD      R10,SP,#+12
   \       0xEA   0xF045 0x5500      ORR      R5,R5,#0x20000000
   \       0xEE   0xE88A 0x000E      STM      R10,{R1-R3}
   \       0xF2   0x9403             STR      R4,[SP, #+12]
   \       0xF4   0x9505             STR      R5,[SP, #+20]
    982            SE_addDataInput(se_cmd, &info_in);
   \       0xF6   0xA903             ADD      R1,SP,#+12
   \       0xF8   0x.... 0x....      BL       ??Subroutine3_0
    983          
    984            sli_add_key_output(cmd_ctx, out_key, status);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xFC   0x4669             MOV      R1,SP
   \       0xFE   0x4648             MOV      R0,R9
   \      0x100   0x.... 0x....      BL       sli_se_get_key_input_output
   \      0x104   0xB928             CBNZ.N   R0,??CrossCallReturnLabel_39
   \      0x106   0x4669             MOV      R1,SP
   \      0x108   0x4630             MOV      R0,R6
   \      0x10A   0x.... 0x....      BL       SE_addDataOutput
    985          
    986            status = sli_se_execute_and_wait(cmd_ctx);
    987          
    988            return status;
   \      0x10E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_39: (+1)
   \      0x112   0xB012             ADD      SP,SP,#+72
   \      0x114   0xE8BD 0x87F0      POP      {R4-R10,PC}
    989          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_39:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000
    990          #endif // _SILICON_LABS_SECURITY_FEATURE_VAULT
    991          
    992          #if (defined(_SILICON_LABS_SECURITY_FEATURE) \
    993            && (_SILICON_LABS_SECURITY_FEATURE == _SILICON_LABS_SECURITY_FEATURE_VAULT))
    994          /***************************************************************************//**
    995           * PBKDF2 key derivation.
    996           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    997          sl_status_t sl_se_derive_key_pbkdf2(sl_se_command_context_t *cmd_ctx,
    998                                              const sl_se_key_descriptor_t *in_key,
    999                                              sl_se_pbkdf2_prf_type_t prf,
   1000                                              const unsigned char *salt,
   1001                                              size_t salt_len,
   1002                                              uint32_t iterations,
   1003                                              sl_se_key_descriptor_t *out_key)
   1004          {
   \                     sl_se_derive_key_pbkdf2: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x461D             MOV      R5,R3
   1005            sl_status_t status = SL_STATUS_OK;
   1006            uint32_t command_word = 0U;
   1007          
   1008            if ((cmd_ctx == NULL) || (in_key == NULL) || (out_key == NULL)) {
   \        0xC   0xBF18             IT       NE
   \        0xE   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x12   0xD02B             BEQ.N    ??sl_se_derive_key_pbkdf2_1
   \       0x14   0x9C18             LDR      R4,[SP, #+96]
   \       0x16   0xB34C             CBZ.N    R4,??sl_se_derive_key_pbkdf2_1
   \       0x18   0x9E16             LDR      R6,[SP, #+88]
   1009              return SL_STATUS_INVALID_PARAMETER;
   1010            }
   1011            if ((salt == NULL) && (salt_len != 0U)) {
   \       0x1A   0xB905             CBNZ.N   R5,??sl_se_derive_key_pbkdf2_2
   \       0x1C   0xBB36             CBNZ.N   R6,??sl_se_derive_key_pbkdf2_1
   \                     ??sl_se_derive_key_pbkdf2_2: (+1)
   \       0x1E   0xF8DD 0x905C      LDR      R9,[SP, #+92]
   1012              return SL_STATUS_INVALID_PARAMETER;
   1013            }
   1014            // Too many iterations will trigger SE watchdog.
   1015            if ((iterations == 0U) || (iterations > 16384U)) {
   \       0x22   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x26   0xD021             BEQ.N    ??sl_se_derive_key_pbkdf2_1
   \       0x28   0xF244 0x0001      MOVW     R0,#+16385
   \       0x2C   0x4581             CMP      R9,R0
   \       0x2E   0xD21D             BCS.N    ??sl_se_derive_key_pbkdf2_1
   1016              return SL_STATUS_INVALID_PARAMETER;
   1017            }
   1018          
   1019            switch (prf) {
   \       0x30   0x2A05             CMP      R2,#+5
   \       0x32   0xD81B             BHI.N    ??sl_se_derive_key_pbkdf2_1
   \       0x34   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??sl_se_derive_key_pbkdf2_0:
   \       0x38   0x18 0x03          DC8      0x18,0x3,0x10,0x12
   \              0x10 0x12
   \       0x3C   0x14 0x16          DC8      0x14,0x16
   1020              case SL_SE_PRF_HMAC_SHA1:
   1021                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1022                               | SLI_SE_COMMAND_OPTION_HASH_SHA1;
   \                     ??sl_se_derive_key_pbkdf2_3: (+1)
   \       0x3E   0xF04F 0x3002      MOV      R0,#+33686018
   1023                break;
   1024          
   1025              case SL_SE_PRF_HMAC_SHA224:
   1026                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1027                               | SLI_SE_COMMAND_OPTION_HASH_SHA224;
   1028                break;
   1029          
   1030              case SL_SE_PRF_HMAC_SHA256:
   1031                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1032                               | SLI_SE_COMMAND_OPTION_HASH_SHA256;
   1033                break;
   1034          
   1035              case SL_SE_PRF_HMAC_SHA384:
   1036                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1037                               | SLI_SE_COMMAND_OPTION_HASH_SHA384;
   1038                break;
   1039          
   1040              case SL_SE_PRF_HMAC_SHA512:
   1041                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_HMAC
   1042                               | SLI_SE_COMMAND_OPTION_HASH_SHA512;
   1043                break;
   1044          
   1045          #if defined(SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_CMAC_AVAILABLE)
   1046              // PBKDF2 with CMAC as the PRF was first supported on EFR32xG23.
   1047              case SL_SE_PRF_AES_CMAC_128:
   1048                command_word = SLI_SE_COMMAND_DERIVE_KEY_PBKDF2_CMAC;
   1049                break;
   1050          #endif
   1051          
   1052              default:
   1053                return SL_STATUS_INVALID_PARAMETER;
   1054                break;
   1055            }
   1056          
   1057            // SE command structures.
   1058            SE_Command_t *se_cmd = &cmd_ctx->command;
   1059            sli_se_command_init(cmd_ctx, command_word);
   \                     ??sl_se_derive_key_pbkdf2_4: (+1)
   \       0x42   0x6038             STR      R0,[R7, #+0]
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x6079             STR      R1,[R7, #+4]
   \       0x48   0x60B9             STR      R1,[R7, #+8]
   \       0x4A   0x61F9             STR      R1,[R7, #+28]
   1060          
   1061            sli_add_key_parameters(cmd_ctx, in_key, status);
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x4640             MOV      R0,R8
   \       0x50   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x54   0xB160             CBZ.N    R0,??sl_se_derive_key_pbkdf2_5
   \       0x56   0xE04E             B.N      ??sl_se_derive_key_pbkdf2_6
   \                     ??sl_se_derive_key_pbkdf2_7: (+1)
   \       0x58   0x....             LDR.N    R0,??DataTable47_11
   \       0x5A   0xE7F2             B.N      ??sl_se_derive_key_pbkdf2_4
   \                     ??sl_se_derive_key_pbkdf2_8: (+1)
   \       0x5C   0x....             LDR.N    R0,??DataTable47_12
   \       0x5E   0xE7F0             B.N      ??sl_se_derive_key_pbkdf2_4
   \                     ??sl_se_derive_key_pbkdf2_9: (+1)
   \       0x60   0x....             LDR.N    R0,??DataTable47_13
   \       0x62   0xE7EE             B.N      ??sl_se_derive_key_pbkdf2_4
   \                     ??sl_se_derive_key_pbkdf2_10: (+1)
   \       0x64   0x....             LDR.N    R0,??DataTable47_14
   \       0x66   0xE7EC             B.N      ??sl_se_derive_key_pbkdf2_4
   \                     ??sl_se_derive_key_pbkdf2_11: (+1)
   \       0x68   0x....             LDR.N    R0,??DataTable47_15
   \       0x6A   0xE7EA             B.N      ??sl_se_derive_key_pbkdf2_4
   \                     ??sl_se_derive_key_pbkdf2_1: (+1)
   \       0x6C   0x2021             MOVS     R0,#+33
   \       0x6E   0xE042             B.N      ??sl_se_derive_key_pbkdf2_6
   \                     ??sl_se_derive_key_pbkdf2_5: (+1)
   \       0x70   0x9900             LDR      R1,[SP, #+0]
   \       0x72   0x.... 0x....      BL       ??Subroutine7_0
   1062            SE_addParameter(se_cmd, salt_len);
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x76   0x4631             MOV      R1,R6
   \       0x78   0x.... 0x....      BL       ??Subroutine7_0
   1063            SE_addParameter(se_cmd, iterations);
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x7C   0x4649             MOV      R1,R9
   \       0x7E   0x.... 0x....      BL       ??Subroutine7_0
   1064            sli_add_key_parameters(cmd_ctx, out_key, status);
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0x82   0x4669             MOV      R1,SP
   \       0x84   0x4620             MOV      R0,R4
   \       0x86   0x.... 0x....      BL       sli_se_key_to_keyspec
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD133             BNE.N    ??sl_se_derive_key_pbkdf2_6
   \       0x8E   0x9900             LDR      R1,[SP, #+0]
   \       0x90   0x.... 0x....      BL       ??Subroutine7_0
   1065          
   1066            sli_add_key_metadata(cmd_ctx, in_key, status);
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x94   0xA90C             ADD      R1,SP,#+48
   \       0x96   0x4640             MOV      R0,R8
   \       0x98   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0x9C   0xBB58             CBNZ.N   R0,??sl_se_derive_key_pbkdf2_6
   \       0x9E   0xA90C             ADD      R1,SP,#+48
   \       0xA0   0x.... 0x....      BL       ??Subroutine6_0
   1067            sli_add_key_input(cmd_ctx, in_key, status);
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0xA4   0xA909             ADD      R1,SP,#+36
   \       0xA6   0x4640             MOV      R0,R8
   \       0xA8   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xAC   0xBB18             CBNZ.N   R0,??sl_se_derive_key_pbkdf2_6
   \       0xAE   0xA909             ADD      R1,SP,#+36
   \       0xB0   0x.... 0x....      BL       ??Subroutine6_0
   1068          
   1069            sli_add_key_metadata_custom(cmd_ctx, auth_data, out_key, status);
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0xB4   0xA906             ADD      R1,SP,#+24
   \       0xB6   0x4620             MOV      R0,R4
   \       0xB8   0x.... 0x....      BL       sli_se_get_auth_buffer
   \       0xBC   0xB9D8             CBNZ.N   R0,??sl_se_derive_key_pbkdf2_6
   \       0xBE   0xA906             ADD      R1,SP,#+24
   \       0xC0   0x.... 0x....      BL       ??Subroutine6_0
   1070          
   1071            SE_DataTransfer_t salt_in = SE_DATATRANSFER_DEFAULT(salt, salt_len);
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0xC4   0x....             ADR.N    R0,?_40
   \       0xC6   0xE890 0x000E      LDM      R0,{R1-R3}
   \       0xCA   0xF10D 0x0E0C      ADD      LR,SP,#+12
   \       0xCE   0xF046 0x5600      ORR      R6,R6,#0x20000000
   \       0xD2   0xE88E 0x000E      STM      LR,{R1-R3}
   \       0xD6   0x9503             STR      R5,[SP, #+12]
   \       0xD8   0x9605             STR      R6,[SP, #+20]
   1072            SE_addDataInput(se_cmd, &salt_in);
   \       0xDA   0xA903             ADD      R1,SP,#+12
   \       0xDC   0x.... 0x....      BL       ??Subroutine6_0
   1073          
   1074            sli_add_key_output(cmd_ctx, out_key, status);
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0xE0   0x4669             MOV      R1,SP
   \       0xE2   0x4620             MOV      R0,R4
   \       0xE4   0x.... 0x....      BL       sli_se_get_key_input_output
   \       0xE8   0xB928             CBNZ.N   R0,??sl_se_derive_key_pbkdf2_6
   \       0xEA   0x4669             MOV      R1,SP
   \       0xEC   0x.... 0x....      BL       ??Subroutine8_0
   1075          
   1076            status = sli_se_execute_and_wait(cmd_ctx);
   1077          
   1078            return status;
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0xF0   0x4638             MOV      R0,R7
   \       0xF2   0x.... 0x....      BL       sli_se_execute_and_wait
   \                     ??sl_se_derive_key_pbkdf2_6: (+1)
   \       0xF6   0xB00F             ADD      SP,SP,#+60
   \       0xF8   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1079          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_40:
   \        0x0   0x0000'0000        DC32 0x0, 0x1, 0
   \              0x0000'0001  
   \              0x0000'0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0xB000'0020        DC32     0xb0000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \        0x0   0xB000'0038        DC32     0xb0000038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \        0x0   0x0B02'0400        DC32     0xb020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_1:
   \        0x0   0x0B00'0100        DC32     0xb000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_2:
   \        0x0   0x0B01'0100        DC32     0xb010100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_3:
   \        0x0   0x8000'0020        DC32     0x80000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_4:
   \        0x0   0x8000'001F        DC32     0x8000001f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_5:
   \        0x0   0x0B01'0000        DC32     0xb010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_6:
   \        0x0   0x0202'0203        DC32     0x2020203

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_7:
   \        0x0   0x0202'0303        DC32     0x2020303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_8:
   \        0x0   0x0202'0403        DC32     0x2020403

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_9:
   \        0x0   0x0202'0503        DC32     0x2020503

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_10:
   \        0x0   0x0202'0603        DC32     0x2020603

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_11:
   \        0x0   0x0202'0302        DC32     0x2020302

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_12:
   \        0x0   0x0202'0402        DC32     0x2020402

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_13:
   \        0x0   0x0202'0502        DC32     0x2020502

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_14:
   \        0x0   0x0202'0602        DC32     0x2020602

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_15:
   \        0x0   0x0202'0010        DC32     0x2020010

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x63 0x6C          DC8 "client"
   \              0x69 0x65    
   \              0x6E 0x74    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x73 0x65          DC8 "server"
   \              0x72 0x76    
   \              0x65 0x72    
   \              0x00
   \        0x7                      DS8 1
   1080          #endif // _SILICON_LABS_SECURITY_FEATURE_VAULT
   1081          
   1082          /** @} (end addtogroup sl_se) */
   1083          
   1084          #endif // defined(SLI_MAILBOX_COMMAND_SUPPORTED)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ecjpake_parse_tls_point
        32   -> __aeabi_memcpy
      40   ecjpake_parse_tls_zkp
        40   -> __aeabi_memclr
        40   -> __aeabi_memcpy
        40   -> ecjpake_parse_tls_point
      32   ecjpake_write_tls_point
        32   -> __aeabi_memcpy
      32   ecjpake_write_tls_zkp
        32   -> __aeabi_memcpy
        32   -> ecjpake_write_tls_point
     104   sl_se_derive_key_hkdf
       104   -> SE_addDataInput
       104   -> SE_addDataOutput
       104   -> SE_addParameter
       104   -> sli_se_execute_and_wait
       104   -> sli_se_get_auth_buffer
       104   -> sli_se_get_key_input_output
       104   -> sli_se_key_to_keyspec
      88   sl_se_derive_key_pbkdf2
        88   -> SE_addDataInput
        88   -> SE_addDataOutput
        88   -> SE_addParameter
        88   -> sli_se_execute_and_wait
        88   -> sli_se_get_auth_buffer
        88   -> sli_se_get_key_input_output
        88   -> sli_se_key_to_keyspec
      96   sl_se_ecdh_compute_shared_secret
        96   -> SE_addDataInput
        96   -> SE_addDataOutput
        96   -> SE_addParameter
        96   -> sli_key_check_equivalent
        96   -> sli_key_get_size
        96   -> sli_se_execute_and_wait
        96   -> sli_se_get_auth_buffer
        96   -> sli_se_get_key_input_output
        96   -> sli_se_key_to_keyspec
       0   sl_se_ecjpake_check
     112   sl_se_ecjpake_derive_secret
       112   -> SE_addDataInput
       112   -> SE_addDataOutput
       112   -> SE_addParameter
       112   -> sli_se_execute_and_wait
       8   sl_se_ecjpake_free
         8   -> __aeabi_memclr4
      16   sl_se_ecjpake_init
        16   -> __aeabi_memclr4
     336   sl_se_ecjpake_read_round_one
       336   -> SE_addDataInput
       336   -> SE_addParameter
       336   -> __aeabi_memclr4
       336   -> ecjpake_parse_tls_point
       336   -> ecjpake_parse_tls_zkp
       336   -> sli_se_execute_and_wait
       336   -> strlen
     240   sl_se_ecjpake_read_round_two
       240   -> SE_addDataInput
       240   -> SE_addParameter
       240   -> ecjpake_parse_tls_point
       240   -> ecjpake_parse_tls_zkp
       240   -> sli_se_execute_and_wait
       240   -> strlen
      16   sl_se_ecjpake_setup
        16   -> __aeabi_memcpy
     336   sl_se_ecjpake_write_round_one
       336   -> SE_addDataInput
       336   -> SE_addDataOutput
       336   -> SE_addParameter
       336   -> ecjpake_write_tls_point
       336   -> ecjpake_write_tls_zkp
       336   -> sli_se_execute_and_wait
       336   -> strlen
     328   sl_se_ecjpake_write_round_two
       328   -> SE_addDataInput
       328   -> SE_addDataOutput
       328   -> SE_addParameter
       328   -> ecjpake_write_tls_point
       328   -> ecjpake_write_tls_zkp
       328   -> sli_se_execute_and_wait
       328   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable47_10
       4  ??DataTable47_11
       4  ??DataTable47_12
       4  ??DataTable47_13
       4  ??DataTable47_14
       4  ??DataTable47_15
       4  ??DataTable47_2
       4  ??DataTable47_3
       4  ??DataTable47_4
       4  ??DataTable47_5
       4  ??DataTable47_6
       4  ??DataTable47_7
       4  ??DataTable47_8
       4  ??DataTable47_9
       6  ?Subroutine0
      10  ?Subroutine1
      24  ?Subroutine10
      12  ?Subroutine11
      14  ?Subroutine12
      14  ?Subroutine13
       6  ?Subroutine14
      20  ?Subroutine2
       8  ?Subroutine3
       8  ?Subroutine4
       6  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
       8  ?Subroutine8
       6  ?Subroutine9
       8  ?_0
       8  ?_1
      12  ?_10
      12  ?_11
      12  ?_12
      12  ?_13
      12  ?_14
      12  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      12  ?_2
      12  ?_20
      12  ?_21
      12  ?_22
      12  ?_23
      12  ?_24
      12  ?_25
      12  ?_26
      12  ?_27
      12  ?_28
      12  ?_29
      12  ?_3
      12  ?_30
      12  ?_31
      12  ?_32
      12  ?_33
      12  ?_34
      12  ?_35
      12  ?_36
      12  ?_37
      12  ?_38
      12  ?_39
      12  ?_4
      12  ?_40
      12  ?_5
      12  ?_6
      12  ?_7
      12  ?_8
      12  ?_9
       8  ecjpake_id
     172  ecjpake_parse_tls_point
     206  ecjpake_parse_tls_zkp
     162  ecjpake_write_tls_point
     148  ecjpake_write_tls_zkp
     280  sl_se_derive_key_hkdf
     252  sl_se_derive_key_pbkdf2
     314  sl_se_ecdh_compute_shared_secret
      18  sl_se_ecjpake_check
     252  sl_se_ecjpake_derive_secret
      20  sl_se_ecjpake_free
      30  sl_se_ecjpake_init
     370  sl_se_ecjpake_read_round_one
     388  sl_se_ecjpake_read_round_two
      60  sl_se_ecjpake_setup
     342  sl_se_ecjpake_write_round_one
     448  sl_se_ecjpake_write_round_two

 
    16 bytes in section .rodata
 4'168 bytes in section .text
 
 4'168 bytes of CODE  memory
    16 bytes of CONST memory

Errors: none
Warnings: none
