###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:18
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\queue.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\queue.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\queue.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\kernel_15789286914859001271.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\queue.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\kernel_15789286914859001271.dir\queue.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\queue.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\queue.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          
     14          /*
     15           * FreeRTOS Kernel V10.4.3
     16           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
     17           *
     18           * Permission is hereby granted, free of charge, to any person obtaining a copy of
     19           * this software and associated documentation files (the "Software"), to deal in
     20           * the Software without restriction, including without limitation the rights to
     21           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     22           * the Software, and to permit persons to whom the Software is furnished to do so,
     23           * subject to the following conditions:
     24           *
     25           * The above copyright notice and this permission notice shall be included in all
     26           * copies or substantial portions of the Software.
     27           *
     28           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     29           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     30           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     31           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     32           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     33           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     34           *
     35           * https://www.FreeRTOS.org
     36           * https://github.com/FreeRTOS
     37           *
     38           */
     39          
     40          #include <stdlib.h>
     41          #include <string.h>
     42          
     43          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     44           * all the API functions to use the MPU wrappers.  That should only be done when
     45           * task.h is included from an application file. */
     46          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     47          
     48          #include "FreeRTOS.h"
     49          #include "task.h"
     50          #include "queue.h"
     51          
     52          #if ( configUSE_CO_ROUTINES == 1 )
     53              #include "croutine.h"
     54          #endif
     55          
     56          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
     57           * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     58           * for the header files above, but not in this file, in order to generate the
     59           * correct privileged Vs unprivileged linkage and placement. */
     60          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     61          
     62          
     63          /* Constants used with the cRxLock and cTxLock structure members. */
     64          #define queueUNLOCKED             ( ( int8_t ) -1 )
     65          #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
     66          #define queueINT8_MAX             ( ( int8_t ) 127 )
     67          
     68          /* When the Queue_t structure is used to represent a base queue its pcHead and
     69           * pcTail members are used as pointers into the queue storage area.  When the
     70           * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
     71           * not necessary, and the pcHead pointer is set to NULL to indicate that the
     72           * structure instead holds a pointer to the mutex holder (if any).  Map alternative
     73           * names to the pcHead and structure member to ensure the readability of the code
     74           * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
     75           * a union as their usage is mutually exclusive dependent on what the queue is
     76           * being used for. */
     77          #define uxQueueType               pcHead
     78          #define queueQUEUE_IS_MUTEX       NULL
     79          
     80          typedef struct QueuePointers
     81          {
     82              int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
     83              int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the structure is used as a queue. */
     84          } QueuePointers_t;
     85          
     86          typedef struct SemaphoreData
     87          {
     88              TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */
     89              UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
     90          } SemaphoreData_t;
     91          
     92          /* Semaphores do not actually store or copy data, so have an item size of
     93           * zero. */
     94          #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
     95          #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
     96          
     97          #if ( configUSE_PREEMPTION == 0 )
     98          
     99          /* If the cooperative scheduler is being used then a yield should not be
    100           * performed just because a higher priority task has been woken. */
    101              #define queueYIELD_IF_USING_PREEMPTION()
    102          #else
    103              #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
    104          #endif
    105          
    106          /*
    107           * Definition of the queue used by the scheduler.
    108           * Items are queued by copy, not reference.  See the following link for the
    109           * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
    110           */
    111          typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */
    112          {
    113              int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */
    114              int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */
    115          
    116              union
    117              {
    118                  QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a queue. */
    119                  SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
    120              } u;
    121          
    122              List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
    123              List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
    124          
    125              volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */
    126              UBaseType_t uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
    127              UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */
    128          
    129              volatile int8_t cRxLock;                /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    130              volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    131          
    132              #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    133                  uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
    134              #endif
    135          
    136              #if ( configUSE_QUEUE_SETS == 1 )
    137                  struct QueueDefinition * pxQueueSetContainer;
    138              #endif
    139          
    140              #if ( configUSE_TRACE_FACILITY == 1 )
    141                  UBaseType_t uxQueueNumber;
    142                  uint8_t ucQueueType;
    143              #endif
    144          } xQUEUE;
    145          
    146          /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
    147           * name below to enable the use of older kernel aware debuggers. */
    148          typedef xQUEUE Queue_t;
    149          
    150          /*-----------------------------------------------------------*/
    151          
    152          /*
    153           * The queue registry is just a means for kernel aware debuggers to locate
    154           * queue structures.  It has no other purpose so is an optional component.
    155           */
    156          #if ( configQUEUE_REGISTRY_SIZE > 0 )
    157          
    158          /* The type stored within the queue registry array.  This allows a name
    159           * to be assigned to each queue making kernel aware debugging a little
    160           * more user friendly. */
    161              typedef struct QUEUE_REGISTRY_ITEM
    162              {
    163                  const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    164                  QueueHandle_t xHandle;
    165              } xQueueRegistryItem;
    166          
    167          /* The old xQueueRegistryItem name is maintained above then typedefed to the
    168           * new xQueueRegistryItem name below to enable the use of older kernel aware
    169           * debuggers. */
    170              typedef xQueueRegistryItem QueueRegistryItem_t;
    171          
    172          /* The queue registry is simply an array of QueueRegistryItem_t structures.
    173           * The pcQueueName member of a structure being NULL is indicative of the
    174           * array position being vacant. */

   \                                 In section .bss, align 4
    175              PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
   \                     xQueueRegistry:
   \        0x0                      DS8 80
    176          
    177          #endif /* configQUEUE_REGISTRY_SIZE */
    178          
    179          /*
    180           * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
    181           * prevent an ISR from adding or removing items to the queue, but does prevent
    182           * an ISR from removing tasks from the queue event lists.  If an ISR finds a
    183           * queue is locked it will instead increment the appropriate queue lock count
    184           * to indicate that a task may require unblocking.  When the queue in unlocked
    185           * these lock counts are inspected, and the appropriate action taken.
    186           */
    187          static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    188          
    189          /*
    190           * Uses a critical section to determine if there is any data in a queue.
    191           *
    192           * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
    193           */
    194          static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
    195          
    196          /*
    197           * Uses a critical section to determine if there is any space in a queue.
    198           *
    199           * @return pdTRUE if there is no space, otherwise pdFALSE;
    200           */
    201          static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
    202          
    203          /*
    204           * Copies an item into the queue, either at the front of the queue or the
    205           * back of the queue.
    206           */
    207          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
    208                                                const void * pvItemToQueue,
    209                                                const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
    210          
    211          /*
    212           * Copies an item out of a queue.
    213           */
    214          static void prvCopyDataFromQueue( Queue_t * const pxQueue,
    215                                            void * const pvBuffer ) PRIVILEGED_FUNCTION;
    216          
    217          #if ( configUSE_QUEUE_SETS == 1 )
    218          
    219          /*
    220           * Checks to see if a queue is a member of a queue set, and if so, notifies
    221           * the queue set that the queue contains data.
    222           */
    223              static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    224          #endif
    225          
    226          /*
    227           * Called after a Queue_t structure has been allocated either statically or
    228           * dynamically to fill in the structure's members.
    229           */
    230          static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
    231                                             const UBaseType_t uxItemSize,
    232                                             uint8_t * pucQueueStorage,
    233                                             const uint8_t ucQueueType,
    234                                             Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
    235          
    236          /*
    237           * Mutexes are a special type of queue.  When a mutex is created, first the
    238           * queue is created, then prvInitialiseMutex() is called to configure the queue
    239           * as a mutex.
    240           */
    241          #if ( configUSE_MUTEXES == 1 )
    242              static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
    243          #endif
    244          
    245          #if ( configUSE_MUTEXES == 1 )
    246          
    247          /*
    248           * If a task waiting for a mutex causes the mutex holder to inherit a
    249           * priority, but the waiting task times out, then the holder should
    250           * disinherit the priority - but only down to the highest priority of any
    251           * other tasks that are waiting for the same mutex.  This function returns
    252           * that priority.
    253           */
    254              static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    255          #endif
    256          /*-----------------------------------------------------------*/
    257          
    258          /*
    259           * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
    260           * accessing the queue event lists.
    261           */
    262          #define prvLockQueue( pxQueue )                            \
    263              taskENTER_CRITICAL();                                  \
    264              {                                                      \
    265                  if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
    266                  {                                                  \
    267                      ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
    268                  }                                                  \
    269                  if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
    270                  {                                                  \
    271                      ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
    272                  }                                                  \
    273              }                                                      \
    274              taskEXIT_CRITICAL()
    275          /*-----------------------------------------------------------*/
    276          

   \                                 In section .text, align 2, keep-with-next
    277          BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
    278                                         BaseType_t xNewQueue )
    279          {
   \                     xQueueGenericReset: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    280              Queue_t * const pxQueue = xQueue;
    281          
    282              configASSERT( pxQueue );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_9
   \        0x8   0xF44F 0x718D      MOV      R1,#+282
   \        0xC   0x.... 0x....      BL       ?Subroutine3
    283          
    284              taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x10   0x.... 0x....      BL       vPortEnterCritical
    285              {
    286                  pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x14   0x6C20             LDR      R0,[R4, #+64]
   \       0x16   0x6BE1             LDR      R1,[R4, #+60]
   \       0x18   0x6822             LDR      R2,[R4, #+0]
    287                  pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   \       0x1A   0x2300             MOVS     R3,#+0
   \       0x1C   0xFB00 0xF601      MUL      R6,R0,R1
    288                  pxQueue->pcWriteTo = pxQueue->pcHead;
    289                  pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x20   0x1E49             SUBS     R1,R1,#+1
   \       0x22   0x4348             MULS     R0,R0,R1
   \       0x24   0x4416             ADD      R6,R2,R6
   \       0x26   0x60A6             STR      R6,[R4, #+8]
   \       0x28   0x4410             ADD      R0,R2,R0
   \       0x2A   0x63A3             STR      R3,[R4, #+56]
   \       0x2C   0x60E0             STR      R0,[R4, #+12]
   \       0x2E   0x6062             STR      R2,[R4, #+4]
    290                  pxQueue->cRxLock = queueUNLOCKED;
   \       0x30   0xF104 0x0144      ADD      R1,R4,#+68
   \       0x34   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x38   0x7008             STRB     R0,[R1, #+0]
    291                  pxQueue->cTxLock = queueUNLOCKED;
   \       0x3A   0x7048             STRB     R0,[R1, #+1]
    292          
    293                  if( xNewQueue == pdFALSE )
   \       0x3C   0xB94D             CBNZ.N   R5,??xQueueGenericReset_0
    294                  {
    295                      /* If there are tasks blocked waiting to read from the queue, then
    296                       * the tasks will remain blocked as after this function exits the queue
    297                       * will still be empty.  If there are tasks blocked waiting to write to
    298                       * the queue, then one should be unblocked as after this function exits
    299                       * it will be possible to write to it. */
    300                      if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \       0x3E   0x6920             LDR      R0,[R4, #+16]
   \       0x40   0xB178             CBZ.N    R0,??xQueueGenericReset_1
    301                      {
    302                          if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x42   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x46   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x4A   0xB150             CBZ.N    R0,??xQueueGenericReset_1
    303                          {
    304                              queueYIELD_IF_USING_PREEMPTION();
   \       0x4C   0x.... 0x....      BL       vPortYield
   \       0x50   0xE007             B.N      ??xQueueGenericReset_1
    305                          }
    306                          else
    307                          {
    308                              mtCOVERAGE_TEST_MARKER();
    309                          }
    310                      }
    311                      else
    312                      {
    313                          mtCOVERAGE_TEST_MARKER();
    314                      }
    315                  }
    316                  else
    317                  {
    318                      /* Ensure the event queues start in the correct state. */
    319                      vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   \                     ??xQueueGenericReset_0: (+1)
   \       0x52   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x56   0x.... 0x....      BL       vListInitialise
    320                      vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   \       0x5A   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x5E   0x.... 0x....      BL       vListInitialise
    321                  }
    322              }
    323              taskEXIT_CRITICAL();
   \                     ??xQueueGenericReset_1: (+1)
   \       0x62   0x.... 0x....      BL       vPortExitCritical
    324          
    325              /* A value is returned for calling semantic consistency with previous
    326               * versions. */
    327              return pdPASS;
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xBD70             POP      {R4-R6,PC}
    328          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16
   \        0x2   0x.... 0x....      B.W      assertEFM
    329          /*-----------------------------------------------------------*/
    330          
    331          #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    332          

   \                                 In section .text, align 2, keep-with-next
    333              QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
    334                                                       const UBaseType_t uxItemSize,
    335                                                       uint8_t * pucQueueStorage,
    336                                                       StaticQueue_t * pxStaticQueue,
    337                                                       const uint8_t ucQueueType )
    338              {
   \                     xQueueGenericCreateStatic: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461D             MOV      R5,R3
    339                  Queue_t * pxNewQueue;
    340          
    341                  configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable16
   \       0x10   0xD103             BNE.N    ??CrossCallReturnLabel_44
   \       0x12   0xF240 0x1155      MOVW     R1,#+341
   \       0x16   0x.... 0x....      BL       ?Subroutine7
    342          
    343                  /* The StaticQueue_t structure and the queue storage area must be
    344                   * supplied. */
    345                  configASSERT( pxStaticQueue != NULL );
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x1A   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_43
   \       0x1C   0xF240 0x1159      MOVW     R1,#+345
   \       0x20   0x.... 0x....      BL       ?Subroutine7
    346          
    347                  /* A queue storage area should be provided if the item size is not 0, and
    348                   * should not be provided if the item size is 0. */
    349                  configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x24   0xB11F             CBZ.N    R7,??xQueueGenericCreateStatic_0
   \       0x26   0xB93C             CBNZ.N   R4,??CrossCallReturnLabel_42
   \       0x28   0xF240 0x115D      MOVW     R1,#+349
   \       0x2C   0xE002             B.N      ??xQueueGenericCreateStatic_1
   \                     ??xQueueGenericCreateStatic_0: (+1)
   \       0x2E   0xB11C             CBZ.N    R4,??CrossCallReturnLabel_42
   \       0x30   0xF44F 0x71AF      MOV      R1,#+350
   \                     ??xQueueGenericCreateStatic_1: (+1)
   \       0x34   0x.... 0x....      BL       ?Subroutine7
    350                  configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
    351          
    352                  #if ( configASSERT_DEFINED == 1 )
    353                      {
    354                          /* Sanity check that the size of the structure used to declare a
    355                           * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
    356                           * the real queue and semaphore structures. */
    357                          volatile size_t xSize = sizeof( StaticQueue_t );
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x38   0x2050             MOVS     R0,#+80
   \       0x3A   0x9000             STR      R0,[SP, #+0]
    358                          configASSERT( xSize == sizeof( Queue_t ) );
   \       0x3C   0x9900             LDR      R1,[SP, #+0]
   \       0x3E   0x2950             CMP      R1,#+80
   \       0x40   0xD003             BEQ.N    ??CrossCallReturnLabel_41
   \       0x42   0xF44F 0x71B3      MOV      R1,#+358
   \       0x46   0x.... 0x....      BL       ?Subroutine7
    359                          ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
    360                      }
    361                  #endif /* configASSERT_DEFINED */
    362          
    363                  /* The address of a statically allocated queue was passed in, use it.
    364                   * The address of a statically allocated storage area was also passed in
    365                   * but is already set. */
    366                  pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    367          
    368                  if( pxNewQueue != NULL )
   \       0x4C   0xB14D             CBZ.N    R5,??xQueueGenericCreateStatic_2
   \       0x4E   0x9B08             LDR      R3,[SP, #+32]
    369                  {
    370                      #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    371                          {
    372                              /* Queues can be allocated wither statically or dynamically, so
    373                               * note this queue was allocated statically in case the queue is
    374                               * later deleted. */
    375                              pxNewQueue->ucStaticallyAllocated = pdTRUE;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xF885 0x0046      STRB     R0,[R5, #+70]
    376                          }
    377                      #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    378          
    379                      prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   \       0x56   0x9500             STR      R5,[SP, #+0]
   \       0x58   0x463A             MOV      R2,R7
   \       0x5A   0x4621             MOV      R1,R4
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0x.... 0x....      BL       prvInitialiseNewQueue
    380                  }
    381                  else
    382                  {
    383                      traceQUEUE_CREATE_FAILED( ucQueueType );
    384                      mtCOVERAGE_TEST_MARKER();
    385                  }
    386          
    387                  return pxNewQueue;
   \                     ??xQueueGenericCreateStatic_2: (+1)
   \       0x62   0x4628             MOV      R0,R5
   \       0x64   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    388              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x.... 0x....      B.W      assertEFM
    389          
    390          #endif /* configSUPPORT_STATIC_ALLOCATION */
    391          /*-----------------------------------------------------------*/
    392          
    393          #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    394          

   \                                 In section .text, align 2, keep-with-next
    395              QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
    396                                                 const UBaseType_t uxItemSize,
    397                                                 const uint8_t ucQueueType )
    398              {
   \                     xQueueGenericCreate: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4617             MOV      R7,R2
    399                  Queue_t * pxNewQueue;
    400                  size_t xQueueSizeInBytes;
    401                  uint8_t * pucQueueStorage;
    402          
    403                  configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   \        0xA   0x.... 0x....      LDR.W    R6,??DataTable16
   \        0xE   0xD103             BNE.N    ??CrossCallReturnLabel_19
   \       0x10   0xF240 0x1193      MOVW     R1,#+403
   \       0x14   0x.... 0x....      BL       ?Subroutine4
    404          
    405                  /* Allocate enough space to hold the maximum number of items that
    406                   * can be in the queue at any time.  It is valid for uxItemSize to be
    407                   * zero in the case the queue is used as a semaphore. */
    408                  xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x18   0xFB05 0xF804      MUL      R8,R5,R4
    409          
    410                  /* Check for multiplication overflow. */
    411                  configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xBF1C             ITT      NE
   \       0x20   0xFBB8 0xF0F5      UDIVNE   R0,R8,R5
   \       0x24   0x4284             CMPNE    R4,R0
   \       0x26   0xD003             BEQ.N    ??CrossCallReturnLabel_18
   \       0x28   0xF240 0x119B      MOVW     R1,#+411
   \       0x2C   0x.... 0x....      BL       ?Subroutine4
    412          
    413                  /* Check for addition overflow. */
    414                  configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x30   0xF108 0x0950      ADD      R9,R8,#+80
   \       0x34   0x45C8             CMP      R8,R9
   \       0x36   0xD303             BCC.N    ??CrossCallReturnLabel_17
   \       0x38   0xF44F 0x71CF      MOV      R1,#+414
   \       0x3C   0x.... 0x....      BL       ?Subroutine4
    415          
    416                  /* Allocate the queue and storage area.  Justification for MISRA
    417                   * deviation as follows:  pvPortMalloc() always ensures returned memory
    418                   * blocks are aligned per the requirements of the MCU stack.  In this case
    419                   * pvPortMalloc() must return a pointer that is guaranteed to meet the
    420                   * alignment requirements of the Queue_t structure - which in this case
    421                   * is an int8_t *.  Therefore, whenever the stack alignment requirements
    422                   * are greater than or equal to the pointer to char requirements the cast
    423                   * is safe.  In other cases alignment requirements are not strict (one or
    424                   * two bytes). */
    425                  pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x40   0x4648             MOV      R0,R9
   \       0x42   0x.... 0x....      BL       pvPortMalloc
   \       0x46   0x0006             MOVS     R6,R0
    426          
    427                  if( pxNewQueue != NULL )
   \       0x48   0xD00A             BEQ.N    ??xQueueGenericCreate_0
    428                  {
    429                      /* Jump past the queue structure to find the location of the queue
    430                       * storage area. */
    431                      pucQueueStorage = ( uint8_t * ) pxNewQueue;
    432                      pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    433          
    434                      #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    435                          {
    436                              /* Queues can be created either statically or dynamically, so
    437                               * note this task was created dynamically in case it is later
    438                               * deleted. */
    439                              pxNewQueue->ucStaticallyAllocated = pdFALSE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF886 0x0046      STRB     R0,[R6, #+70]
    440                          }
    441                      #endif /* configSUPPORT_STATIC_ALLOCATION */
    442          
    443                      prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   \       0x50   0x9600             STR      R6,[SP, #+0]
   \       0x52   0x463B             MOV      R3,R7
   \       0x54   0xF106 0x0250      ADD      R2,R6,#+80
   \       0x58   0x4629             MOV      R1,R5
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x.... 0x....      BL       prvInitialiseNewQueue
    444                  }
    445                  else
    446                  {
    447                      traceQUEUE_CREATE_FAILED( ucQueueType );
    448                      mtCOVERAGE_TEST_MARKER();
    449                  }
    450          
    451                  return pxNewQueue;
   \                     ??xQueueGenericCreate_0: (+1)
   \       0x60   0x4630             MOV      R0,R6
   \       0x62   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    452              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x.... 0x....      B.W      assertEFM
    453          
    454          #endif /* configSUPPORT_STATIC_ALLOCATION */
    455          /*-----------------------------------------------------------*/
    456          

   \                                 In section .text, align 2, keep-with-next
    457          static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
    458                                             const UBaseType_t uxItemSize,
    459                                             uint8_t * pucQueueStorage,
    460                                             const uint8_t ucQueueType,
    461                                             Queue_t * pxNewQueue )
    462          {
   \                     prvInitialiseNewQueue: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x461D             MOV      R5,R3
   \        0x4   0x9C04             LDR      R4,[SP, #+16]
    463              /* Remove compiler warnings about unused parameters should
    464               * configUSE_TRACE_FACILITY not be set to 1. */
    465              ( void ) ucQueueType;
    466          
    467              if( uxItemSize == ( UBaseType_t ) 0 )
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xBF0C             ITE      EQ
   \        0xA   0x6024             STREQ    R4,[R4, #+0]
   \        0xC   0x6022             STRNE    R2,[R4, #+0]
    468              {
    469                  /* No RAM was allocated for the queue storage area, but PC head cannot
    470                   * be set to NULL because NULL is used as a key to say the queue is used as
    471                   * a mutex.  Therefore just set pcHead to point to the queue as a benign
    472                   * value that is known to be within the memory map. */
    473                  pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    474              }
    475              else
    476              {
    477                  /* Set the head to the start of the queue storage area. */
    478                  pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    479              }
    480          
    481              /* Initialise the queue members as described where the queue type is
    482               * defined. */
    483              pxNewQueue->uxLength = uxQueueLength;
   \        0xE   0x63E0             STR      R0,[R4, #+60]
    484              pxNewQueue->uxItemSize = uxItemSize;
   \       0x10   0x6421             STR      R1,[R4, #+64]
    485              ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       xQueueGenericReset
    486          
    487              #if ( configUSE_TRACE_FACILITY == 1 )
    488                  {
    489                      pxNewQueue->ucQueueType = ucQueueType;
   \       0x1A   0xF884 0x504C      STRB     R5,[R4, #+76]
    490                  }
    491              #endif /* configUSE_TRACE_FACILITY */
    492          
    493              #if ( configUSE_QUEUE_SETS == 1 )
    494                  {
    495                      pxNewQueue->pxQueueSetContainer = NULL;
    496                  }
    497              #endif /* configUSE_QUEUE_SETS */
    498          
    499              traceQUEUE_CREATE( pxNewQueue );
    500          }
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}
    501          /*-----------------------------------------------------------*/
    502          
    503          #if ( configUSE_MUTEXES == 1 )
    504          

   \                                 In section .text, align 2, keep-with-next
    505              static void prvInitialiseMutex( Queue_t * pxNewQueue )
    506              {
    507                  if( pxNewQueue != NULL )
   \                     prvInitialiseMutex: (+1)
   \        0x0   0xB130             CBZ.N    R0,??prvInitialiseMutex_0
    508                  {
    509                      /* The queue create function will set all the queue structure members
    510                      * correctly for a generic queue, but this function is creating a
    511                      * mutex.  Overwrite those members that need to be set differently -
    512                      * in particular the information required for priority inheritance. */
    513                      pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x6083             STR      R3,[R0, #+8]
    514                      pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x6002             STR      R2,[R0, #+0]
    515          
    516                      /* In case this is a recursive mutex. */
    517                      pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x60C1             STR      R1,[R0, #+12]
    518          
    519                      traceCREATE_MUTEX( pxNewQueue );
    520          
    521                      /* Start with the semaphore in the expected state. */
    522                      ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   \        0xE   0x....             B.N      xQueueGenericSend
    523                  }
    524                  else
    525                  {
    526                      traceCREATE_MUTEX_FAILED();
    527                  }
    528              }
   \                     ??prvInitialiseMutex_0: (+1)
   \       0x10   0x4770             BX       LR
    529          
    530          #endif /* configUSE_MUTEXES */
    531          /*-----------------------------------------------------------*/
    532          
    533          #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    534          

   \                                 In section .text, align 2, keep-with-next
    535              QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    536              {
   \                     xQueueCreateMutex: (+1)
   \        0x0   0x4602             MOV      R2,R0
   \        0x2   0xB510             PUSH     {R4,LR}
    537                  QueueHandle_t xNewQueue;
    538                  const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    539          
    540                  xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x.... 0x....      BL       xQueueGenericCreate
   \        0xC   0x4604             MOV      R4,R0
    541                  prvInitialiseMutex( ( Queue_t * ) xNewQueue );
   \        0xE   0x.... 0x....      BL       prvInitialiseMutex
    542          
    543                  return xNewQueue;
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}
    544              }
    545          
    546          #endif /* configUSE_MUTEXES */
    547          /*-----------------------------------------------------------*/
    548          
    549          #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    550          

   \                                 In section .text, align 2, keep-with-next
    551              QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
    552                                                     StaticQueue_t * pxStaticQueue )
    553              {
   \                     xQueueCreateMutexStatic: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460B             MOV      R3,R1
    554                  QueueHandle_t xNewQueue;
    555                  const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    556          
    557                  /* Prevent compiler warnings about unused parameters if
    558                   * configUSE_TRACE_FACILITY does not equal 1. */
    559                  ( void ) ucQueueType;
    560          
    561                  xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x.... 0x....      BL       xQueueGenericCreateStatic
   \       0x10   0x4604             MOV      R4,R0
    562                  prvInitialiseMutex( ( Queue_t * ) xNewQueue );
   \       0x12   0x.... 0x....      BL       prvInitialiseMutex
    563          
    564                  return xNewQueue;
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD16             POP      {R1,R2,R4,PC}
    565              }
    566          
    567          #endif /* configUSE_MUTEXES */
    568          /*-----------------------------------------------------------*/
    569          
    570          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    571          

   \                                 In section .text, align 2, keep-with-next
    572              TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
    573              {
   \                     xQueueGetMutexHolder: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    574                  TaskHandle_t pxReturn;
    575                  Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
    576          
    577                  /* This function is called by xSemaphoreGetMutexHolder(), and should not
    578                   * be called directly.  Note:  This is a good way of determining if the
    579                   * calling task is the mutex holder, but not a good way of determining the
    580                   * identity of the mutex holder, as the holder may change between the
    581                   * following critical section exiting and the function returning. */
    582                  taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
    583                  {
    584                      if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xBF0C             ITE      EQ
   \        0xE   0x68A4             LDREQ    R4,[R4, #+8]
   \       0x10   0x2400             MOVNE    R4,#+0
    585                      {
    586                          pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
    587                      }
    588                      else
    589                      {
    590                          pxReturn = NULL;
    591                      }
    592                  }
    593                  taskEXIT_CRITICAL();
   \       0x12   0x....             B.N      ?Subroutine0
    594          
    595                  return pxReturn;
    596              } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x.... 0x....      BL       vPortExitCritical
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0xBD10             POP      {R4,PC}
    597          
    598          #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
    599          /*-----------------------------------------------------------*/
    600          
    601          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    602          

   \                                 In section .text, align 2, keep-with-next
    603              TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
    604              {
   \                     xQueueGetMutexHolderFromISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    605                  TaskHandle_t pxReturn;
    606          
    607                  configASSERT( xSemaphore );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_8
   \        0x6   0xF240 0x215F      MOVW     R1,#+607
   \        0xA   0x.... 0x....      BL       ?Subroutine3
    608          
    609                  /* Mutexes cannot be used in interrupt service routines, so the mutex
    610                   * holder should not change in an ISR, and therefore a critical section is
    611                   * not required here. */
    612                  if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0xB909             CBNZ.N   R1,??xQueueGetMutexHolderFromISR_0
    613                  {
    614                      pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
   \       0x12   0x68A0             LDR      R0,[R4, #+8]
   \       0x14   0xBD10             POP      {R4,PC}
    615                  }
    616                  else
    617                  {
    618                      pxReturn = NULL;
   \                     ??xQueueGetMutexHolderFromISR_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
    619                  }
    620          
    621                  return pxReturn;
   \       0x18   0xBD10             POP      {R4,PC}
    622              } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    623          
    624          #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
    625          /*-----------------------------------------------------------*/
    626          
    627          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    628          

   \                                 In section .text, align 2, keep-with-next
    629              BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    630              {
   \                     xQueueGiveMutexRecursive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    631                  BaseType_t xReturn;
    632                  Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    633          
    634                  configASSERT( pxMutex );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_7
   \        0x6   0xF240 0x217A      MOVW     R1,#+634
   \        0xA   0x.... 0x....      BL       ?Subroutine3
    635          
    636                  /* If this is the task that holds the mutex then xMutexHolder will not
    637                   * change outside of this task.  If this task does not hold the mutex then
    638                   * pxMutexHolder can never coincidentally equal the tasks handle, and as
    639                   * this is the only condition we are interested in it does not matter if
    640                   * pxMutexHolder is accessed simultaneously by another task.  Therefore no
    641                   * mutual exclusion is required to test the pxMutexHolder variable. */
    642                  if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xE   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x12   0x68A1             LDR      R1,[R4, #+8]
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD10B             BNE.N    ??xQueueGiveMutexRecursive_0
    643                  {
    644                      traceGIVE_MUTEX_RECURSIVE( pxMutex );
    645          
    646                      /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
    647                       * the task handle, therefore no underflow check is required.  Also,
    648                       * uxRecursiveCallCount is only modified by the mutex holder, and as
    649                       * there can only be one, no mutual exclusion is required to modify the
    650                       * uxRecursiveCallCount member. */
    651                      ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
   \       0x18   0x68E0             LDR      R0,[R4, #+12]
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
    652          
    653                      /* Has the recursive call count unwound to 0? */
    654                      if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
   \       0x1E   0xD105             BNE.N    ??xQueueGiveMutexRecursive_1
    655                      {
    656                          /* Return the mutex.  This will automatically unblock any other
    657                           * task that might be waiting to access the mutex. */
    658                          ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       xQueueGenericSend
    659                      }
    660                      else
    661                      {
    662                          mtCOVERAGE_TEST_MARKER();
    663                      }
    664          
    665                      xReturn = pdPASS;
   \                     ??xQueueGiveMutexRecursive_1: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xBD10             POP      {R4,PC}
    666                  }
    667                  else
    668                  {
    669                      /* The mutex cannot be given because the calling task is not the
    670                       * holder. */
    671                      xReturn = pdFAIL;
   \                     ??xQueueGiveMutexRecursive_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
    672          
    673                      traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
    674                  }
    675          
    676                  return xReturn;
   \       0x32   0xBD10             POP      {R4,PC}
    677              }
    678          
    679          #endif /* configUSE_RECURSIVE_MUTEXES */
    680          /*-----------------------------------------------------------*/
    681          
    682          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    683          

   \                                 In section .text, align 2, keep-with-next
    684              BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
    685                                                   TickType_t xTicksToWait )
    686              {
   \                     xQueueTakeMutexRecursive: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    687                  BaseType_t xReturn;
    688                  Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    689          
    690                  configASSERT( pxMutex );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_6
   \        0x8   0xF240 0x21B2      MOVW     R1,#+690
   \        0xC   0x.... 0x....      BL       ?Subroutine3
    691          
    692                  /* Comments regarding mutual exclusion as per those within
    693                   * xQueueGiveMutexRecursive(). */
    694          
    695                  traceTAKE_MUTEX_RECURSIVE( pxMutex );
    696          
    697                  if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x10   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x14   0x68A1             LDR      R1,[R4, #+8]
   \       0x16   0x4281             CMP      R1,R0
   \       0x18   0xD104             BNE.N    ??xQueueTakeMutexRecursive_0
    698                  {
    699                      ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
   \       0x1A   0x68E0             LDR      R0,[R4, #+12]
   \       0x1C   0x1C40             ADDS     R0,R0,#+1
   \       0x1E   0x60E0             STR      R0,[R4, #+12]
    700                      xReturn = pdPASS;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
    701                  }
    702                  else
    703                  {
    704                      xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
   \                     ??xQueueTakeMutexRecursive_0: (+1)
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       xQueueSemaphoreTake
    705          
    706                      /* pdPASS will only be returned if the mutex was successfully
    707                       * obtained.  The calling task may have entered the Blocked state
    708                       * before reaching here. */
    709                      if( xReturn != pdFAIL )
   \       0x2C   0xB110             CBZ.N    R0,??xQueueTakeMutexRecursive_1
    710                      {
    711                          ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
   \       0x2E   0x68E1             LDR      R1,[R4, #+12]
   \       0x30   0x1C49             ADDS     R1,R1,#+1
   \       0x32   0x60E1             STR      R1,[R4, #+12]
    712                      }
    713                      else
    714                      {
    715                          traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
    716                      }
    717                  }
    718          
    719                  return xReturn;
   \                     ??xQueueTakeMutexRecursive_1: (+1)
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
    720              }
    721          
    722          #endif /* configUSE_RECURSIVE_MUTEXES */
    723          /*-----------------------------------------------------------*/
    724          
    725          #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    726          

   \                                 In section .text, align 2, keep-with-next
    727              QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
    728                                                                 const UBaseType_t uxInitialCount,
    729                                                                 StaticQueue_t * pxStaticQueue )
    730              {
   \                     xQueueCreateCountingSemaphoreStatic: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    731                  QueueHandle_t xHandle;
    732          
    733                  configASSERT( uxMaxCount != 0 );
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable16
   \        0xC   0xD103             BNE.N    ??CrossCallReturnLabel_28
   \        0xE   0xF240 0x21DD      MOVW     R1,#+733
   \       0x12   0x.... 0x....      BL       ?Subroutine5
    734                  configASSERT( uxInitialCount <= uxMaxCount );
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x16   0x42AC             CMP      R4,R5
   \       0x18   0xD203             BCS.N    ??CrossCallReturnLabel_27
   \       0x1A   0xF240 0x21DE      MOVW     R1,#+734
   \       0x1E   0x.... 0x....      BL       ?Subroutine5
    735          
    736                  xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x4633             MOV      R3,R6
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x.... 0x....      BL       xQueueGenericCreateStatic
    737          
    738                  if( xHandle != NULL )
   \       0x32   0xB100             CBZ.N    R0,??xQueueCreateCountingSemaphoreStatic_0
    739                  {
    740                      ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   \       0x34   0x6385             STR      R5,[R0, #+56]
    741          
    742                      traceCREATE_COUNTING_SEMAPHORE();
    743                  }
    744                  else
    745                  {
    746                      traceCREATE_COUNTING_SEMAPHORE_FAILED();
    747                  }
    748          
    749                  return xHandle;
   \                     ??xQueueCreateCountingSemaphoreStatic_0: (+1)
   \       0x36   0xBDF2             POP      {R1,R4-R7,PC}
    750              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4638             MOV      R0,R7
   \        0x2   0x.... 0x....      B.W      assertEFM
    751          
    752          #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
    753          /*-----------------------------------------------------------*/
    754          
    755          #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    756          

   \                                 In section .text, align 2, keep-with-next
    757              QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
    758                                                           const UBaseType_t uxInitialCount )
    759              {
   \                     xQueueCreateCountingSemaphore: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
    760                  QueueHandle_t xHandle;
    761          
    762                  configASSERT( uxMaxCount != 0 );
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable16
   \        0xA   0xD103             BNE.N    ??CrossCallReturnLabel_37
   \        0xC   0xF240 0x21FA      MOVW     R1,#+762
   \       0x10   0x.... 0x....      BL       ?Subroutine6
    763                  configASSERT( uxInitialCount <= uxMaxCount );
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x14   0x42B4             CMP      R4,R6
   \       0x16   0xD203             BCS.N    ??CrossCallReturnLabel_36
   \       0x18   0xF240 0x21FB      MOVW     R1,#+763
   \       0x1C   0x.... 0x....      BL       ?Subroutine6
    764          
    765                  xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x20   0x2202             MOVS     R2,#+2
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x.... 0x....      BL       xQueueGenericCreate
    766          
    767                  if( xHandle != NULL )
   \       0x2A   0xB100             CBZ.N    R0,??xQueueCreateCountingSemaphore_0
    768                  {
    769                      ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   \       0x2C   0x6386             STR      R6,[R0, #+56]
    770          
    771                      traceCREATE_COUNTING_SEMAPHORE();
    772                  }
    773                  else
    774                  {
    775                      traceCREATE_COUNTING_SEMAPHORE_FAILED();
    776                  }
    777          
    778                  return xHandle;
   \                     ??xQueueCreateCountingSemaphore_0: (+1)
   \       0x2E   0xBD70             POP      {R4-R6,PC}
    779              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x.... 0x....      B.W      assertEFM
    780          
    781          #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
    782          /*-----------------------------------------------------------*/
    783          

   \                                 In section .text, align 2, keep-with-next
    784          BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
    785                                        const void * const pvItemToQueue,
    786                                        TickType_t xTicksToWait,
    787                                        const BaseType_t xCopyPosition )
    788          {
   \                     xQueueGenericSend: (+1)
   \        0x0   0xE92D 0x41F6      PUSH     {R1,R2,R4-R8,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x461F             MOV      R7,R3
    789              BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   \        0xC   0x2400             MOVS     R4,#+0
    790              TimeOut_t xTimeOut;
    791              Queue_t * const pxQueue = xQueue;
    792          
    793              configASSERT( pxQueue );
   \        0xE   0x.... 0x....      LDR.W    R5,??DataTable16
   \       0x12   0xB91E             CBNZ.N   R6,??CrossCallReturnLabel_35
   \       0x14   0xF240 0x3119      MOVW     R1,#+793
   \       0x18   0x.... 0x....      BL       ?Subroutine6
    794              configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x1C   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x20   0xD105             BNE.N    ??CrossCallReturnLabel_34
   \       0x22   0x6C30             LDR      R0,[R6, #+64]
   \       0x24   0xB118             CBZ.N    R0,??CrossCallReturnLabel_34
   \       0x26   0xF240 0x311A      MOVW     R1,#+794
   \       0x2A   0x.... 0x....      BL       ?Subroutine6
    795              configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x2E   0x2F02             CMP      R7,#+2
   \       0x30   0xD106             BNE.N    ??CrossCallReturnLabel_33
   \       0x32   0x6BF0             LDR      R0,[R6, #+60]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD003             BEQ.N    ??CrossCallReturnLabel_33
   \       0x38   0xF240 0x311B      MOVW     R1,#+795
   \       0x3C   0x.... 0x....      BL       ?Subroutine6
    796              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    797                  {
    798                      configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x40   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD134             BNE.N    ??xQueueGenericSend_0
   \       0x48   0x9803             LDR      R0,[SP, #+12]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD031             BEQ.N    ??xQueueGenericSend_0
   \       0x4E   0xF240 0x311E      MOVW     R1,#+798
   \       0x52   0x.... 0x....      BL       ?Subroutine6
    799                  }
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x56   0xE02C             B.N      ??xQueueGenericSend_0
    800              #endif
    801          
    802              /*lint -save -e904 This function relaxes the coding standard somewhat to
    803               * allow return statements within the function itself.  This is done in the
    804               * interest of execution time efficiency. */
    805              for( ; ; )
    806              {
    807                  taskENTER_CRITICAL();
    808                  {
    809                      /* Is there room on the queue now?  The running task must be the
    810                       * highest priority task wanting to access the queue.  If the head item
    811                       * in the queue is to be overwritten then it does not matter if the
    812                       * queue is full. */
    813                      if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    814                      {
    815                          traceQUEUE_SEND( pxQueue );
    816          
    817                          #if ( configUSE_QUEUE_SETS == 1 )
    818                              {
    819                                  const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    820          
    821                                  xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    822          
    823                                  if( pxQueue->pxQueueSetContainer != NULL )
    824                                  {
    825                                      if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    826                                      {
    827                                          /* Do not notify the queue set as an existing item
    828                                           * was overwritten in the queue so the number of items
    829                                           * in the queue has not changed. */
    830                                          mtCOVERAGE_TEST_MARKER();
    831                                      }
    832                                      else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    833                                      {
    834                                          /* The queue is a member of a queue set, and posting
    835                                           * to the queue set caused a higher priority task to
    836                                           * unblock. A context switch is required. */
    837                                          queueYIELD_IF_USING_PREEMPTION();
    838                                      }
    839                                      else
    840                                      {
    841                                          mtCOVERAGE_TEST_MARKER();
    842                                      }
    843                                  }
    844                                  else
    845                                  {
    846                                      /* If there was a task waiting for data to arrive on the
    847                                       * queue then unblock it now. */
    848                                      if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    849                                      {
    850                                          if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    851                                          {
    852                                              /* The unblocked task has a priority higher than
    853                                               * our own so yield immediately.  Yes it is ok to
    854                                               * do this from within the critical section - the
    855                                               * kernel takes care of that. */
    856                                              queueYIELD_IF_USING_PREEMPTION();
    857                                          }
    858                                          else
    859                                          {
    860                                              mtCOVERAGE_TEST_MARKER();
    861                                          }
    862                                      }
    863                                      else if( xYieldRequired != pdFALSE )
    864                                      {
    865                                          /* This path is a special case that will only get
    866                                           * executed if the task was holding multiple mutexes
    867                                           * and the mutexes were given back in an order that is
    868                                           * different to that in which they were taken. */
    869                                          queueYIELD_IF_USING_PREEMPTION();
    870                                      }
    871                                      else
    872                                      {
    873                                          mtCOVERAGE_TEST_MARKER();
    874                                      }
    875                                  }
    876                              }
    877                          #else /* configUSE_QUEUE_SETS */
    878                              {
    879                                  xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    880          
    881                                  /* If there was a task waiting for data to arrive on the
    882                                   * queue then unblock it now. */
    883                                  if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    884                                  {
    885                                      if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    886                                      {
    887                                          /* The unblocked task has a priority higher than
    888                                           * our own so yield immediately.  Yes it is ok to do
    889                                           * this from within the critical section - the kernel
    890                                           * takes care of that. */
    891                                          queueYIELD_IF_USING_PREEMPTION();
    892                                      }
    893                                      else
    894                                      {
    895                                          mtCOVERAGE_TEST_MARKER();
    896                                      }
    897                                  }
    898                                  else if( xYieldRequired != pdFALSE )
    899                                  {
    900                                      /* This path is a special case that will only get
    901                                       * executed if the task was holding multiple mutexes and
    902                                       * the mutexes were given back in an order that is
    903                                       * different to that in which they were taken. */
    904                                      queueYIELD_IF_USING_PREEMPTION();
    905                                  }
    906                                  else
    907                                  {
    908                                      mtCOVERAGE_TEST_MARKER();
    909                                  }
    910                              }
    911                          #endif /* configUSE_QUEUE_SETS */
    912          
    913                          taskEXIT_CRITICAL();
    914                          return pdPASS;
    915                      }
    916                      else
    917                      {
    918                          if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xQueueGenericSend_1: (+1)
   \       0x58   0x9803             LDR      R0,[SP, #+12]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD045             BEQ.N    ??xQueueGenericSend_2
    919                          {
    920                              /* The queue was full and no block time is specified (or
    921                               * the block time has expired) so leave now. */
    922                              taskEXIT_CRITICAL();
    923          
    924                              /* Return to the original privilege level before exiting
    925                               * the function. */
    926                              traceQUEUE_SEND_FAILED( pxQueue );
    927                              return errQUEUE_FULL;
    928                          }
    929                          else if( xEntryTimeSet == pdFALSE )
   \       0x5E   0xB914             CBNZ.N   R4,??xQueueGenericSend_3
    930                          {
    931                              /* The queue was full and a block time was specified so
    932                               * configure the timeout structure. */
    933                              vTaskInternalSetTimeOutState( &xTimeOut );
   \       0x60   0x.... 0x....      BL       ?Subroutine12
    934                              xEntryTimeSet = pdTRUE;
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x64   0x2401             MOVS     R4,#+1
    935                          }
    936                          else
    937                          {
    938                              /* Entry time was already set. */
    939                              mtCOVERAGE_TEST_MARKER();
    940                          }
    941                      }
    942                  }
    943                  taskEXIT_CRITICAL();
   \                     ??xQueueGenericSend_3: (+1)
   \       0x66   0x.... 0x....      BL       vPortExitCritical
    944          
    945                  /* Interrupts and other tasks can send to and receive from the queue
    946                   * now the critical section has been exited. */
    947          
    948                  vTaskSuspendAll();
   \       0x6A   0x.... 0x....      BL       vTaskSuspendAll
    949                  prvLockQueue( pxQueue );
   \       0x6E   0x.... 0x....      BL       vPortEnterCritical
   \       0x72   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x76   0xBF04             ITT      EQ
   \       0x78   0x2100             MOVEQ    R1,#+0
   \       0x7A   0x7001             STRBEQ   R1,[R0, #+0]
   \       0x7C   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x80   0xBF04             ITT      EQ
   \       0x82   0x2100             MOVEQ    R1,#+0
   \       0x84   0x7041             STRBEQ   R1,[R0, #+1]
   \       0x86   0x.... 0x....      BL       vPortExitCritical
    950          
    951                  /* Update the timeout state to see if it has expired yet. */
    952                  if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   \       0x8A   0xA903             ADD      R1,SP,#+12
   \       0x8C   0x.... 0x....      BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD13C             BNE.N    ??xQueueGenericSend_4
    953                  {
    954                      if( prvIsQueueFull( pxQueue ) != pdFALSE )
   \       0x94   0x.... 0x....      BL       vPortEnterCritical
   \       0x98   0x6BB1             LDR      R1,[R6, #+56]
   \       0x9A   0x6BF0             LDR      R0,[R6, #+60]
   \       0x9C   0x4281             CMP      R1,R0
   \       0x9E   0xBF14             ITE      NE
   \       0xA0   0x2500             MOVNE    R5,#+0
   \       0xA2   0x2501             MOVEQ    R5,#+1
   \       0xA4   0x.... 0x....      BL       vPortExitCritical
   \       0xA8   0xBB1D             CBNZ.N   R5,??xQueueGenericSend_5
    955                      {
    956                          traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    957                          vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    958          
    959                          /* Unlocking the queue means queue events can effect the
    960                           * event list.  It is possible that interrupts occurring now
    961                           * remove this task from the event list again - but as the
    962                           * scheduler is suspended the task will go onto the pending
    963                           * ready last instead of the actual ready list. */
    964                          prvUnlockQueue( pxQueue );
    965          
    966                          /* Resuming the scheduler will move tasks from the pending
    967                           * ready list into the ready list - so it is feasible that this
    968                           * task is already in a ready list before it yields - in which
    969                           * case the yield will not cause a context switch unless there
    970                           * is also a higher priority task in the pending ready list. */
    971                          if( xTaskResumeAll() == pdFALSE )
    972                          {
    973                              portYIELD_WITHIN_API();
    974                          }
    975                      }
    976                      else
    977                      {
    978                          /* Try again. */
    979                          prvUnlockQueue( pxQueue );
   \       0xAA   0x.... 0x....      BL       ?Subroutine9
    980                          ( void ) xTaskResumeAll();
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0xAE   0x.... 0x....      BL       xTaskResumeAll
    981                      }
   \                     ??xQueueGenericSend_0: (+1)
   \       0xB2   0x.... 0x....      BL       vPortEnterCritical
   \       0xB6   0x6BB1             LDR      R1,[R6, #+56]
   \       0xB8   0x6BF0             LDR      R0,[R6, #+60]
   \       0xBA   0x4281             CMP      R1,R0
   \       0xBC   0xD301             BCC.N    ??xQueueGenericSend_6
   \       0xBE   0x2F02             CMP      R7,#+2
   \       0xC0   0xD1CA             BNE.N    ??xQueueGenericSend_1
   \                     ??xQueueGenericSend_6: (+1)
   \       0xC2   0x463A             MOV      R2,R7
   \       0xC4   0x4641             MOV      R1,R8
   \       0xC6   0x4630             MOV      R0,R6
   \       0xC8   0x.... 0x....      BL       prvCopyDataToQueue
   \       0xCC   0x6A71             LDR      R1,[R6, #+36]
   \       0xCE   0xB119             CBZ.N    R1,??xQueueGenericSend_7
   \       0xD0   0xF106 0x0024      ADD      R0,R6,#+36
   \       0xD4   0x.... 0x....      BL       xTaskRemoveFromEventList
   \                     ??xQueueGenericSend_7: (+1)
   \       0xD8   0xB108             CBZ.N    R0,??xQueueGenericSend_8
   \       0xDA   0x.... 0x....      BL       vPortYield
   \                     ??xQueueGenericSend_8: (+1)
   \       0xDE   0x.... 0x....      BL       vPortExitCritical
   \       0xE2   0x2001             MOVS     R0,#+1
   \                     ??xQueueGenericSend_9: (+1)
   \       0xE4   0xB004             ADD      SP,SP,#+16
   \       0xE6   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??xQueueGenericSend_2: (+1)
   \       0xEA   0x.... 0x....      BL       vPortExitCritical
   \                     ??xQueueGenericSend_10: (+1)
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0xE7F8             B.N      ??xQueueGenericSend_9
   \                     ??xQueueGenericSend_5: (+1)
   \       0xF2   0x9903             LDR      R1,[SP, #+12]
   \       0xF4   0xF106 0x0010      ADD      R0,R6,#+16
   \       0xF8   0x.... 0x....      BL       vTaskPlaceOnEventList
   \       0xFC   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_54: (+1)
   \      0x100   0x.... 0x....      BL       xTaskResumeAll
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD1D4             BNE.N    ??xQueueGenericSend_0
   \      0x108   0x.... 0x....      BL       vPortYield
   \      0x10C   0xE7D1             B.N      ??xQueueGenericSend_0
    982                  }
    983                  else
    984                  {
    985                      /* The timeout has expired. */
    986                      prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_4: (+1)
   \      0x10E   0x.... 0x....      BL       ?Subroutine9
    987                      ( void ) xTaskResumeAll();
   \                     ??CrossCallReturnLabel_53: (+1)
   \      0x112   0x.... 0x....      BL       xTaskResumeAll
    988          
    989                      traceQUEUE_SEND_FAILED( pxQueue );
    990                      return errQUEUE_FULL;
   \      0x116   0xE7EA             B.N      ??xQueueGenericSend_10
    991                  }
    992              } /*lint -restore */
    993          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x....             B.N      prvUnlockQueue

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0xA902             ADD      R1,SP,#+8
   \                     ??Subroutine13_0: (+1)
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      B.W      xTaskCheckForTimeOut

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4668             MOV      R0,SP
   \        0x2   0x.... 0x....      B.W      vTaskInternalSetTimeOutState

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0xF106 0x0044      ADD      R0,R6,#+68
   \        0x4   0xF990 0x2000      LDRSB    R2,[R0, #+0]
   \        0x8   0xF112 0x0F01      CMN      R2,#+1
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xF990 0x2001      LDRSB    R2,[R0, #+1]
   \        0x4   0xF112 0x0F01      CMN      R2,#+1
   \        0x8   0x4770             BX       LR
    994          /*-----------------------------------------------------------*/
    995          

   \                                 In section .text, align 2, keep-with-next
    996          BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
    997                                               const void * const pvItemToQueue,
    998                                               BaseType_t * const pxHigherPriorityTaskWoken,
    999                                               const BaseType_t xCopyPosition )
   1000          {
   \                     xQueueGenericSendFromISR: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
   1001              BaseType_t xReturn;
   1002              UBaseType_t uxSavedInterruptStatus;
   1003              Queue_t * const pxQueue = xQueue;
   1004          
   1005              configASSERT( pxQueue );
   \        0xC   0x.... 0x....      LDR.W    R10,??DataTable16
   \       0x10   0xD103             BNE.N    ??CrossCallReturnLabel_48
   \       0x12   0xF240 0x31ED      MOVW     R1,#+1005
   \       0x16   0x.... 0x....      BL       ?Subroutine8
   1006              configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0x1A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x1E   0xD105             BNE.N    ??CrossCallReturnLabel_47
   \       0x20   0x6C20             LDR      R0,[R4, #+64]
   \       0x22   0xB118             CBZ.N    R0,??CrossCallReturnLabel_47
   \       0x24   0xF240 0x31EE      MOVW     R1,#+1006
   \       0x28   0x.... 0x....      BL       ?Subroutine8
   1007              configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x2C   0x2E02             CMP      R6,#+2
   \       0x2E   0xD106             BNE.N    ??CrossCallReturnLabel_46
   \       0x30   0x6BE0             LDR      R0,[R4, #+60]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD003             BEQ.N    ??CrossCallReturnLabel_46
   \       0x36   0xF240 0x31EF      MOVW     R1,#+1007
   \       0x3A   0x.... 0x....      BL       ?Subroutine8
   1008          
   1009              /* RTOS ports that support interrupt nesting have the concept of a maximum
   1010               * system call (or maximum API call) interrupt priority.  Interrupts that are
   1011               * above the maximum system call priority are kept permanently enabled, even
   1012               * when the RTOS kernel is in a critical section, but cannot make any calls to
   1013               * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1014               * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1015               * failure if a FreeRTOS API function is called from an interrupt that has been
   1016               * assigned a priority above the configured maximum system call priority.
   1017               * Only FreeRTOS functions that end in FromISR can be called from interrupts
   1018               * that have been assigned a priority at or (logically) below the maximum
   1019               * system call interrupt priority.  FreeRTOS maintains a separate interrupt
   1020               * safe API to ensure interrupt entry is as fast and as simple as possible.
   1021               * More information (albeit Cortex-M specific) is provided on the following
   1022               * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   1023              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1024          
   1025              /* Similar to xQueueGenericSend, except without blocking if there is no room
   1026               * in the queue.  Also don't directly wake a task that was blocked on a queue
   1027               * read, instead return a flag to say whether a context switch is required or
   1028               * not (i.e. has a task with a higher priority than us been woken by this
   1029               * post). */
   1030              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x3E   0x.... 0x....      BL       ulSetInterruptMask
   \       0x42   0x4680             MOV      R8,R0
   1031              {
   1032                  if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   \       0x44   0x6BA1             LDR      R1,[R4, #+56]
   \       0x46   0x6BE0             LDR      R0,[R4, #+60]
   \       0x48   0x4281             CMP      R1,R0
   \       0x4A   0xD301             BCC.N    ??xQueueGenericSendFromISR_0
   \       0x4C   0x2E02             CMP      R6,#+2
   \       0x4E   0xD122             BNE.N    ??xQueueGenericSendFromISR_1
   1033                  {
   1034                      const int8_t cTxLock = pxQueue->cTxLock;
   \                     ??xQueueGenericSendFromISR_0: (+1)
   \       0x50   0xF994 0x7045      LDRSB    R7,[R4, #+69]
   1035                      const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x54   0x6BA0             LDR      R0,[R4, #+56]
   1036          
   1037                      traceQUEUE_SEND_FROM_ISR( pxQueue );
   1038          
   1039                      /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
   1040                       *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
   1041                       *  in a task disinheriting a priority and prvCopyDataToQueue() can be
   1042                       *  called here even though the disinherit function does not check if
   1043                       *  the scheduler is suspended before accessing the ready lists. */
   1044                      ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \       0x56   0x4632             MOV      R2,R6
   \       0x58   0x4649             MOV      R1,R9
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x.... 0x....      BL       prvCopyDataToQueue
   1045          
   1046                      /* The event list is not altered if the queue is locked.  This will
   1047                       * be done when the queue is unlocked later. */
   1048                      if( cTxLock == queueUNLOCKED )
   \       0x60   0xF117 0x0F01      CMN      R7,#+1
   \       0x64   0xD10C             BNE.N    ??xQueueGenericSendFromISR_2
   1049                      {
   1050                          #if ( configUSE_QUEUE_SETS == 1 )
   1051                              {
   1052                                  if( pxQueue->pxQueueSetContainer != NULL )
   1053                                  {
   1054                                      if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
   1055                                      {
   1056                                          /* Do not notify the queue set as an existing item
   1057                                           * was overwritten in the queue so the number of items
   1058                                           * in the queue has not changed. */
   1059                                          mtCOVERAGE_TEST_MARKER();
   1060                                      }
   1061                                      else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
   1062                                      {
   1063                                          /* The queue is a member of a queue set, and posting
   1064                                           * to the queue set caused a higher priority task to
   1065                                           * unblock.  A context switch is required. */
   1066                                          if( pxHigherPriorityTaskWoken != NULL )
   1067                                          {
   1068                                              *pxHigherPriorityTaskWoken = pdTRUE;
   1069                                          }
   1070                                          else
   1071                                          {
   1072                                              mtCOVERAGE_TEST_MARKER();
   1073                                          }
   1074                                      }
   1075                                      else
   1076                                      {
   1077                                          mtCOVERAGE_TEST_MARKER();
   1078                                      }
   1079                                  }
   1080                                  else
   1081                                  {
   1082                                      if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1083                                      {
   1084                                          if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1085                                          {
   1086                                              /* The task waiting has a higher priority so
   1087                                               *  record that a context switch is required. */
   1088                                              if( pxHigherPriorityTaskWoken != NULL )
   1089                                              {
   1090                                                  *pxHigherPriorityTaskWoken = pdTRUE;
   1091                                              }
   1092                                              else
   1093                                              {
   1094                                                  mtCOVERAGE_TEST_MARKER();
   1095                                              }
   1096                                          }
   1097                                          else
   1098                                          {
   1099                                              mtCOVERAGE_TEST_MARKER();
   1100                                          }
   1101                                      }
   1102                                      else
   1103                                      {
   1104                                          mtCOVERAGE_TEST_MARKER();
   1105                                      }
   1106                                  }
   1107                              }
   1108                          #else /* configUSE_QUEUE_SETS */
   1109                              {
   1110                                  if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0x66   0x6A60             LDR      R0,[R4, #+36]
   \       0x68   0xB198             CBZ.N    R0,??xQueueGenericSendFromISR_3
   1111                                  {
   1112                                      if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0x6A   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x6E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xBF18             IT       NE
   \       0x76   0x2D00             CMPNE    R5,#+0
   1113                                      {
   1114                                          /* The task waiting has a higher priority so record that a
   1115                                           * context switch is required. */
   1116                                          if( pxHigherPriorityTaskWoken != NULL )
   \       0x78   0xD00B             BEQ.N    ??xQueueGenericSendFromISR_3
   1117                                          {
   1118                                              *pxHigherPriorityTaskWoken = pdTRUE;
   \       0x7A   0x2001             MOVS     R0,#+1
   \       0x7C   0x6028             STR      R0,[R5, #+0]
   \       0x7E   0xE008             B.N      ??xQueueGenericSendFromISR_3
   1119                                          }
   1120                                          else
   1121                                          {
   1122                                              mtCOVERAGE_TEST_MARKER();
   1123                                          }
   1124                                      }
   1125                                      else
   1126                                      {
   1127                                          mtCOVERAGE_TEST_MARKER();
   1128                                      }
   1129                                  }
   1130                                  else
   1131                                  {
   1132                                      mtCOVERAGE_TEST_MARKER();
   1133                                  }
   1134          
   1135                                  /* Not used in this path. */
   1136                                  ( void ) uxPreviousMessagesWaiting;
   1137                              }
   1138                          #endif /* configUSE_QUEUE_SETS */
   1139                      }
   1140                      else
   1141                      {
   1142                          /* Increment the lock count so the task that unlocks the queue
   1143                           * knows that data was posted while it was locked. */
   1144                          configASSERT( cTxLock != queueINT8_MAX );
   \                     ??xQueueGenericSendFromISR_2: (+1)
   \       0x80   0x2F7F             CMP      R7,#+127
   \       0x82   0xD103             BNE.N    ??CrossCallReturnLabel_45
   \       0x84   0xF44F 0x618F      MOV      R1,#+1144
   \       0x88   0x.... 0x....      BL       ?Subroutine8
   1145          
   1146                          pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x8C   0x1C7F             ADDS     R7,R7,#+1
   \       0x8E   0xF884 0x7045      STRB     R7,[R4, #+69]
   1147                      }
   1148          
   1149                      xReturn = pdPASS;
   \                     ??xQueueGenericSendFromISR_3: (+1)
   \       0x92   0x2401             MOVS     R4,#+1
   \       0x94   0xE000             B.N      ??xQueueGenericSendFromISR_4
   1150                  }
   1151                  else
   1152                  {
   1153                      traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1154                      xReturn = errQUEUE_FULL;
   \                     ??xQueueGenericSendFromISR_1: (+1)
   \       0x96   0x2400             MOVS     R4,#+0
   1155                  }
   1156              }
   1157              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGenericSendFromISR_4: (+1)
   \       0x98   0x4640             MOV      R0,R8
   \       0x9A   0x....             B.N      ?Subroutine1
   1158          
   1159              return xReturn;
   1160          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4650             MOV      R0,R10
   \        0x2   0x.... 0x....      B.W      assertEFM

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      BL       vClearInterruptMask
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1161          /*-----------------------------------------------------------*/
   1162          

   \                                 In section .text, align 2, keep-with-next
   1163          BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
   1164                                        BaseType_t * const pxHigherPriorityTaskWoken )
   1165          {
   \                     xQueueGiveFromISR: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
   1166              BaseType_t xReturn;
   1167              UBaseType_t uxSavedInterruptStatus;
   1168              Queue_t * const pxQueue = xQueue;
   1169          
   1170              /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
   1171               * item size is 0.  Don't directly wake a task that was blocked on a queue
   1172               * read, instead return a flag to say whether a context switch is required or
   1173               * not (i.e. has a task with a higher priority than us been woken by this
   1174               * post). */
   1175          
   1176              configASSERT( pxQueue );
   \        0x8   0x.... 0x....      LDR.W    R6,??DataTable16
   \        0xC   0xD103             BNE.N    ??CrossCallReturnLabel_16
   \        0xE   0xF44F 0x6193      MOV      R1,#+1176
   \       0x12   0x.... 0x....      BL       ?Subroutine4
   1177          
   1178              /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
   1179               * if the item size is not 0. */
   1180              configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x16   0x6C20             LDR      R0,[R4, #+64]
   \       0x18   0xB118             CBZ.N    R0,??CrossCallReturnLabel_15
   \       0x1A   0xF240 0x419C      MOVW     R1,#+1180
   \       0x1E   0x.... 0x....      BL       ?Subroutine4
   1181          
   1182              /* Normally a mutex would not be given from an interrupt, especially if
   1183               * there is a mutex holder, as priority inheritance makes no sense for an
   1184               * interrupts, only tasks. */
   1185              configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0xB928             CBNZ.N   R0,??CrossCallReturnLabel_14
   \       0x26   0x68A0             LDR      R0,[R4, #+8]
   \       0x28   0xB118             CBZ.N    R0,??CrossCallReturnLabel_14
   \       0x2A   0xF240 0x41A1      MOVW     R1,#+1185
   \       0x2E   0x.... 0x....      BL       ?Subroutine4
   1186          
   1187              /* RTOS ports that support interrupt nesting have the concept of a maximum
   1188               * system call (or maximum API call) interrupt priority.  Interrupts that are
   1189               * above the maximum system call priority are kept permanently enabled, even
   1190               * when the RTOS kernel is in a critical section, but cannot make any calls to
   1191               * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1192               * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1193               * failure if a FreeRTOS API function is called from an interrupt that has been
   1194               * assigned a priority above the configured maximum system call priority.
   1195               * Only FreeRTOS functions that end in FromISR can be called from interrupts
   1196               * that have been assigned a priority at or (logically) below the maximum
   1197               * system call interrupt priority.  FreeRTOS maintains a separate interrupt
   1198               * safe API to ensure interrupt entry is as fast and as simple as possible.
   1199               * More information (albeit Cortex-M specific) is provided on the following
   1200               * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   1201              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1202          
   1203              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x32   0x.... 0x....      BL       ulSetInterruptMask
   \       0x36   0x4680             MOV      R8,R0
   1204              {
   1205                  const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x38   0x6BA0             LDR      R0,[R4, #+56]
   1206          
   1207                  /* When the queue is used to implement a semaphore no data is ever
   1208                   * moved through the queue but it is still valid to see if the queue 'has
   1209                   * space'. */
   1210                  if( uxMessagesWaiting < pxQueue->uxLength )
   \       0x3A   0x6BE1             LDR      R1,[R4, #+60]
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xD21E             BCS.N    ??xQueueGiveFromISR_0
   1211                  {
   1212                      const int8_t cTxLock = pxQueue->cTxLock;
   \       0x40   0xF994 0x7045      LDRSB    R7,[R4, #+69]
   1213          
   1214                      traceQUEUE_SEND_FROM_ISR( pxQueue );
   1215          
   1216                      /* A task can only have an inherited priority if it is a mutex
   1217                       * holder - and if there is a mutex holder then the mutex cannot be
   1218                       * given from an ISR.  As this is the ISR version of the function it
   1219                       * can be assumed there is no mutex holder and no need to determine if
   1220                       * priority disinheritance is needed.  Simply increase the count of
   1221                       * messages (semaphores) available. */
   1222                      pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x63A0             STR      R0,[R4, #+56]
   1223          
   1224                      /* The event list is not altered if the queue is locked.  This will
   1225                       * be done when the queue is unlocked later. */
   1226                      if( cTxLock == queueUNLOCKED )
   \       0x48   0xF117 0x0F01      CMN      R7,#+1
   \       0x4C   0xD10C             BNE.N    ??xQueueGiveFromISR_1
   1227                      {
   1228                          #if ( configUSE_QUEUE_SETS == 1 )
   1229                              {
   1230                                  if( pxQueue->pxQueueSetContainer != NULL )
   1231                                  {
   1232                                      if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
   1233                                      {
   1234                                          /* The semaphore is a member of a queue set, and
   1235                                           * posting to the queue set caused a higher priority
   1236                                           * task to unblock.  A context switch is required. */
   1237                                          if( pxHigherPriorityTaskWoken != NULL )
   1238                                          {
   1239                                              *pxHigherPriorityTaskWoken = pdTRUE;
   1240                                          }
   1241                                          else
   1242                                          {
   1243                                              mtCOVERAGE_TEST_MARKER();
   1244                                          }
   1245                                      }
   1246                                      else
   1247                                      {
   1248                                          mtCOVERAGE_TEST_MARKER();
   1249                                      }
   1250                                  }
   1251                                  else
   1252                                  {
   1253                                      if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1254                                      {
   1255                                          if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1256                                          {
   1257                                              /* The task waiting has a higher priority so
   1258                                               *  record that a context switch is required. */
   1259                                              if( pxHigherPriorityTaskWoken != NULL )
   1260                                              {
   1261                                                  *pxHigherPriorityTaskWoken = pdTRUE;
   1262                                              }
   1263                                              else
   1264                                              {
   1265                                                  mtCOVERAGE_TEST_MARKER();
   1266                                              }
   1267                                          }
   1268                                          else
   1269                                          {
   1270                                              mtCOVERAGE_TEST_MARKER();
   1271                                          }
   1272                                      }
   1273                                      else
   1274                                      {
   1275                                          mtCOVERAGE_TEST_MARKER();
   1276                                      }
   1277                                  }
   1278                              }
   1279                          #else /* configUSE_QUEUE_SETS */
   1280                              {
   1281                                  if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0x4E   0x6A60             LDR      R0,[R4, #+36]
   \       0x50   0xB198             CBZ.N    R0,??xQueueGiveFromISR_2
   1282                                  {
   1283                                      if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0x52   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x56   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xBF18             IT       NE
   \       0x5E   0x2D00             CMPNE    R5,#+0
   1284                                      {
   1285                                          /* The task waiting has a higher priority so record that a
   1286                                           * context switch is required. */
   1287                                          if( pxHigherPriorityTaskWoken != NULL )
   \       0x60   0xD00B             BEQ.N    ??xQueueGiveFromISR_2
   1288                                          {
   1289                                              *pxHigherPriorityTaskWoken = pdTRUE;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x6028             STR      R0,[R5, #+0]
   \       0x66   0xE008             B.N      ??xQueueGiveFromISR_2
   1290                                          }
   1291                                          else
   1292                                          {
   1293                                              mtCOVERAGE_TEST_MARKER();
   1294                                          }
   1295                                      }
   1296                                      else
   1297                                      {
   1298                                          mtCOVERAGE_TEST_MARKER();
   1299                                      }
   1300                                  }
   1301                                  else
   1302                                  {
   1303                                      mtCOVERAGE_TEST_MARKER();
   1304                                  }
   1305                              }
   1306                          #endif /* configUSE_QUEUE_SETS */
   1307                      }
   1308                      else
   1309                      {
   1310                          /* Increment the lock count so the task that unlocks the queue
   1311                           * knows that data was posted while it was locked. */
   1312                          configASSERT( cTxLock != queueINT8_MAX );
   \                     ??xQueueGiveFromISR_1: (+1)
   \       0x68   0x2F7F             CMP      R7,#+127
   \       0x6A   0xD103             BNE.N    ??CrossCallReturnLabel_13
   \       0x6C   0xF44F 0x61A4      MOV      R1,#+1312
   \       0x70   0x.... 0x....      BL       ?Subroutine4
   1313          
   1314                          pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x74   0x1C7F             ADDS     R7,R7,#+1
   \       0x76   0xF884 0x7045      STRB     R7,[R4, #+69]
   1315                      }
   1316          
   1317                      xReturn = pdPASS;
   \                     ??xQueueGiveFromISR_2: (+1)
   \       0x7A   0x2401             MOVS     R4,#+1
   \       0x7C   0xE000             B.N      ??xQueueGiveFromISR_3
   1318                  }
   1319                  else
   1320                  {
   1321                      traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1322                      xReturn = errQUEUE_FULL;
   \                     ??xQueueGiveFromISR_0: (+1)
   \       0x7E   0x2400             MOVS     R4,#+0
   1323                  }
   1324              }
   1325              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGiveFromISR_3: (+1)
   \       0x80   0x4640             MOV      R0,R8
   \       0x82   0x.... 0x....      BL       vClearInterruptMask
   1326          
   1327              return xReturn;
   \       0x86   0x4620             MOV      R0,R4
   \       0x88   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1328          }
   1329          /*-----------------------------------------------------------*/
   1330          

   \                                 In section .text, align 2, keep-with-next
   1331          BaseType_t xQueueReceive( QueueHandle_t xQueue,
   1332                                    void * const pvBuffer,
   1333                                    TickType_t xTicksToWait )
   1334          {
   \                     xQueueReceive: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   1335              BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1336              TimeOut_t xTimeOut;
   1337              Queue_t * const pxQueue = xQueue;
   1338          
   1339              /* Check the pointer is not NULL. */
   1340              configASSERT( ( pxQueue ) );
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable16
   \        0xC   0xB91E             CBNZ.N   R6,??CrossCallReturnLabel_31
   \        0xE   0xF240 0x513C      MOVW     R1,#+1340
   \       0x12   0x.... 0x....      BL       ?Subroutine6
   1341          
   1342              /* The buffer into which data is received can only be NULL if the data size
   1343               * is zero (so no data is copied into the buffer). */
   1344              configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x16   0xB92F             CBNZ.N   R7,??CrossCallReturnLabel_30
   \       0x18   0x6C30             LDR      R0,[R6, #+64]
   \       0x1A   0xB118             CBZ.N    R0,??CrossCallReturnLabel_30
   \       0x1C   0xF44F 0x61A8      MOV      R1,#+1344
   \       0x20   0x.... 0x....      BL       ?Subroutine6
   1345          
   1346              /* Cannot block if the scheduler is suspended. */
   1347              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1348                  {
   1349                      configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x24   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x28   0xB950             CBNZ.N   R0,??xQueueReceive_0
   \       0x2A   0x9802             LDR      R0,[SP, #+8]
   \       0x2C   0xB140             CBZ.N    R0,??xQueueReceive_0
   \       0x2E   0xF240 0x5145      MOVW     R1,#+1349
   \       0x32   0x.... 0x....      BL       ?Subroutine6
   1350                  }
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x36   0xE003             B.N      ??xQueueReceive_0
   1351              #endif
   1352          
   1353              /*lint -save -e904  This function relaxes the coding standard somewhat to
   1354               * allow return statements within the function itself.  This is done in the
   1355               * interest of execution time efficiency. */
   1356              for( ; ; )
   1357              {
   1358                  taskENTER_CRITICAL();
   1359                  {
   1360                      const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1361          
   1362                      /* Is there data in the queue now?  To be running the calling task
   1363                       * must be the highest priority task wanting to access the queue. */
   1364                      if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1365                      {
   1366                          /* Data available, remove one item. */
   1367                          prvCopyDataFromQueue( pxQueue, pvBuffer );
   1368                          traceQUEUE_RECEIVE( pxQueue );
   1369                          pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   1370          
   1371                          /* There is now space in the queue, were any tasks waiting to
   1372                           * post to the queue?  If so, unblock the highest priority waiting
   1373                           * task. */
   1374                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1375                          {
   1376                              if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1377                              {
   1378                                  queueYIELD_IF_USING_PREEMPTION();
   1379                              }
   1380                              else
   1381                              {
   1382                                  mtCOVERAGE_TEST_MARKER();
   1383                              }
   1384                          }
   1385                          else
   1386                          {
   1387                              mtCOVERAGE_TEST_MARKER();
   1388                          }
   1389          
   1390                          taskEXIT_CRITICAL();
   1391                          return pdPASS;
   1392                      }
   1393                      else
   1394                      {
   1395                          if( xTicksToWait == ( TickType_t ) 0 )
   1396                          {
   1397                              /* The queue was empty and no block time is specified (or
   1398                               * the block time has expired) so leave now. */
   1399                              taskEXIT_CRITICAL();
   1400                              traceQUEUE_RECEIVE_FAILED( pxQueue );
   1401                              return errQUEUE_EMPTY;
   1402                          }
   1403                          else if( xEntryTimeSet == pdFALSE )
   1404                          {
   1405                              /* The queue was empty and a block time was specified so
   1406                               * configure the timeout structure. */
   1407                              vTaskInternalSetTimeOutState( &xTimeOut );
   1408                              xEntryTimeSet = pdTRUE;
   1409                          }
   1410                          else
   1411                          {
   1412                              /* Entry time was already set. */
   1413                              mtCOVERAGE_TEST_MARKER();
   1414                          }
   1415                      }
   1416                  }
   1417                  taskEXIT_CRITICAL();
   1418          
   1419                  /* Interrupts and other tasks can send to and receive from the queue
   1420                   * now the critical section has been exited. */
   1421          
   1422                  vTaskSuspendAll();
   1423                  prvLockQueue( pxQueue );
   1424          
   1425                  /* Update the timeout state to see if it has expired yet. */
   1426                  if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1427                  {
   1428                      /* The timeout has not expired.  If the queue is still empty place
   1429                       * the task on the list of tasks waiting to receive from the queue. */
   1430                      if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1431                      {
   1432                          traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1433                          vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1434                          prvUnlockQueue( pxQueue );
   1435          
   1436                          if( xTaskResumeAll() == pdFALSE )
   1437                          {
   1438                              portYIELD_WITHIN_API();
   1439                          }
   1440                          else
   1441                          {
   1442                              mtCOVERAGE_TEST_MARKER();
   1443                          }
   1444                      }
   1445                      else
   1446                      {
   1447                          /* The queue contains data again.  Loop back to try and read the
   1448                           * data. */
   1449                          prvUnlockQueue( pxQueue );
   \                     ??xQueueReceive_1: (+1)
   \       0x38   0x.... 0x....      BL       ?Subroutine9
   1450                          ( void ) xTaskResumeAll();
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x3C   0x.... 0x....      BL       xTaskResumeAll
   1451                      }
   \                     ??xQueueReceive_0: (+1)
   \       0x40   0x.... 0x....      BL       vPortEnterCritical
   \       0x44   0x6BB5             LDR      R5,[R6, #+56]
   \       0x46   0xBB7D             CBNZ.N   R5,??xQueueReceive_2
   \       0x48   0x9802             LDR      R0,[SP, #+8]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD033             BEQ.N    ??xQueueReceive_3
   \       0x4E   0xB914             CBNZ.N   R4,??xQueueReceive_4
   \       0x50   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0x54   0x2401             MOVS     R4,#+1
   \                     ??xQueueReceive_4: (+1)
   \       0x56   0x.... 0x....      BL       vPortExitCritical
   \       0x5A   0x.... 0x....      BL       vTaskSuspendAll
   \       0x5E   0x.... 0x....      BL       vPortEnterCritical
   \       0x62   0xF106 0x0044      ADD      R0,R6,#+68
   \       0x66   0x5742             LDRSB    R2,[R0, R5]
   \       0x68   0xF112 0x0F01      CMN      R2,#+1
   \       0x6C   0xBF04             ITT      EQ
   \       0x6E   0x2100             MOVEQ    R1,#+0
   \       0x70   0x7001             STRBEQ   R1,[R0, #+0]
   \       0x72   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0x76   0xBF04             ITT      EQ
   \       0x78   0x2100             MOVEQ    R1,#+0
   \       0x7A   0x7041             STRBEQ   R1,[R0, #+1]
   \       0x7C   0x.... 0x....      BL       vPortExitCritical
   \       0x80   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0x4630             MOV      R0,R6
   \       0x88   0xD119             BNE.N    ??xQueueReceive_5
   \       0x8A   0x.... 0x....      BL       prvIsQueueEmpty
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD0D2             BEQ.N    ??xQueueReceive_1
   \       0x92   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0x96   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x9A   0x.... 0x....      BL       xTaskResumeAll
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD1CE             BNE.N    ??xQueueReceive_0
   \       0xA2   0x.... 0x....      BL       vPortYield
   \       0xA6   0xE7CB             B.N      ??xQueueReceive_0
   \                     ??xQueueReceive_2: (+1)
   \       0xA8   0x4639             MOV      R1,R7
   \       0xAA   0x4630             MOV      R0,R6
   \       0xAC   0x.... 0x....      BL       prvCopyDataFromQueue
   \       0xB0   0x1E6D             SUBS     R5,R5,#+1
   \       0xB2   0x63B5             STR      R5,[R6, #+56]
   \       0xB4   0x....             B.N      ?Subroutine2
   \                     ??xQueueReceive_3: (+1)
   \       0xB6   0x.... 0x....      BL       vPortExitCritical
   \                     ??xQueueReceive_6: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0xBDFE             POP      {R1-R7,PC}
   1452                  }
   1453                  else
   1454                  {
   1455                      /* Timed out.  If there is no data in the queue exit, otherwise loop
   1456                       * back and attempt to read the data. */
   1457                      prvUnlockQueue( pxQueue );
   \                     ??xQueueReceive_5: (+1)
   \       0xBE   0x.... 0x....      BL       prvUnlockQueue
   1458                      ( void ) xTaskResumeAll();
   \       0xC2   0x.... 0x....      BL       xTaskResumeAll
   1459          
   1460                      if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \       0xC6   0x4630             MOV      R0,R6
   \       0xC8   0x.... 0x....      BL       prvIsQueueEmpty
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD0B7             BEQ.N    ??xQueueReceive_0
   1461                      {
   1462                          traceQUEUE_RECEIVE_FAILED( pxQueue );
   1463                          return errQUEUE_EMPTY;
   \       0xD0   0xE7F3             B.N      ??xQueueReceive_6
   1464                      }
   1465                      else
   1466                      {
   1467                          mtCOVERAGE_TEST_MARKER();
   1468                      }
   1469                  }
   1470              } /*lint -restore */
   1471          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x9902             LDR      R1,[SP, #+8]
   \        0x2   0xF106 0x0024      ADD      R0,R6,#+36
   \        0x6   0x.... 0x....      B.W      vTaskPlaceOnEventList

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6930             LDR      R0,[R6, #+16]
   \        0x2   0xB130             CBZ.N    R0,??Subroutine2_0
   \        0x4   0xF106 0x0010      ADD      R0,R6,#+16
   \        0x8   0x.... 0x....      BL       xTaskRemoveFromEventList
   \        0xC   0xB108             CBZ.N    R0,??Subroutine2_0
   \        0xE   0x.... 0x....      BL       vPortYield
   \                     ??Subroutine2_0: (+1)
   \       0x12   0x.... 0x....      BL       vPortExitCritical
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBDFE             POP      {R1-R7,PC}
   1472          /*-----------------------------------------------------------*/
   1473          

   \                                 In section .text, align 2, keep-with-next
   1474          BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
   1475                                          TickType_t xTicksToWait )
   1476          {
   \                     xQueueSemaphoreTake: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x4606             MOV      R6,R0
   1477              BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1478              TimeOut_t xTimeOut;
   1479              Queue_t * const pxQueue = xQueue;
   1480          
   1481              #if ( configUSE_MUTEXES == 1 )
   1482                  BaseType_t xInheritanceOccurred = pdFALSE;
   \        0x8   0x2500             MOVS     R5,#+0
   1483              #endif
   1484          
   1485              /* Check the queue pointer is not NULL. */
   1486              configASSERT( ( pxQueue ) );
   \        0xA   0x.... 0x....      LDR.W    R7,??DataTable16
   \        0xE   0xB91E             CBNZ.N   R6,??CrossCallReturnLabel_26
   \       0x10   0xF240 0x51CE      MOVW     R1,#+1486
   \       0x14   0x.... 0x....      BL       ?Subroutine5
   1487          
   1488              /* Check this really is a semaphore, in which case the item size will be
   1489               * 0. */
   1490              configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x18   0x6C30             LDR      R0,[R6, #+64]
   \       0x1A   0xB118             CBZ.N    R0,??CrossCallReturnLabel_25
   \       0x1C   0xF240 0x51D2      MOVW     R1,#+1490
   \       0x20   0x.... 0x....      BL       ?Subroutine5
   1491          
   1492              /* Cannot block if the scheduler is suspended. */
   1493              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1494                  {
   1495                      configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x24   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x28   0xB950             CBNZ.N   R0,??xQueueSemaphoreTake_0
   \       0x2A   0x9802             LDR      R0,[SP, #+8]
   \       0x2C   0xB140             CBZ.N    R0,??xQueueSemaphoreTake_0
   \       0x2E   0xF240 0x51D7      MOVW     R1,#+1495
   \       0x32   0x.... 0x....      BL       ?Subroutine5
   1496                  }
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x36   0xE003             B.N      ??xQueueSemaphoreTake_0
   1497              #endif
   1498          
   1499              /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
   1500               * statements within the function itself.  This is done in the interest
   1501               * of execution time efficiency. */
   1502              for( ; ; )
   1503              {
   1504                  taskENTER_CRITICAL();
   1505                  {
   1506                      /* Semaphores are queues with an item size of 0, and where the
   1507                       * number of messages in the queue is the semaphore's count value. */
   1508                      const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   1509          
   1510                      /* Is there data in the queue now?  To be running the calling task
   1511                       * must be the highest priority task wanting to access the queue. */
   1512                      if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   1513                      {
   1514                          traceQUEUE_RECEIVE( pxQueue );
   1515          
   1516                          /* Semaphores are queues with a data size of zero and where the
   1517                           * messages waiting is the semaphore's count.  Reduce the count. */
   1518                          pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   1519          
   1520                          #if ( configUSE_MUTEXES == 1 )
   1521                              {
   1522                                  if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1523                                  {
   1524                                      /* Record the information required to implement
   1525                                       * priority inheritance should it become necessary. */
   1526                                      pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
   1527                                  }
   1528                                  else
   1529                                  {
   1530                                      mtCOVERAGE_TEST_MARKER();
   1531                                  }
   1532                              }
   1533                          #endif /* configUSE_MUTEXES */
   1534          
   1535                          /* Check to see if other tasks are blocked waiting to give the
   1536                           * semaphore, and if so, unblock the highest priority such task. */
   1537                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1538                          {
   1539                              if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1540                              {
   1541                                  queueYIELD_IF_USING_PREEMPTION();
   1542                              }
   1543                              else
   1544                              {
   1545                                  mtCOVERAGE_TEST_MARKER();
   1546                              }
   1547                          }
   1548                          else
   1549                          {
   1550                              mtCOVERAGE_TEST_MARKER();
   1551                          }
   1552          
   1553                          taskEXIT_CRITICAL();
   1554                          return pdPASS;
   1555                      }
   1556                      else
   1557                      {
   1558                          if( xTicksToWait == ( TickType_t ) 0 )
   1559                          {
   1560                              /* For inheritance to have occurred there must have been an
   1561                               * initial timeout, and an adjusted timeout cannot become 0, as
   1562                               * if it were 0 the function would have exited. */
   1563                              #if ( configUSE_MUTEXES == 1 )
   1564                                  {
   1565                                      configASSERT( xInheritanceOccurred == pdFALSE );
   1566                                  }
   1567                              #endif /* configUSE_MUTEXES */
   1568          
   1569                              /* The semaphore count was 0 and no block time is specified
   1570                               * (or the block time has expired) so exit now. */
   1571                              taskEXIT_CRITICAL();
   1572                              traceQUEUE_RECEIVE_FAILED( pxQueue );
   1573                              return errQUEUE_EMPTY;
   1574                          }
   1575                          else if( xEntryTimeSet == pdFALSE )
   1576                          {
   1577                              /* The semaphore count was 0 and a block time was specified
   1578                               * so configure the timeout structure ready to block. */
   1579                              vTaskInternalSetTimeOutState( &xTimeOut );
   1580                              xEntryTimeSet = pdTRUE;
   1581                          }
   1582                          else
   1583                          {
   1584                              /* Entry time was already set. */
   1585                              mtCOVERAGE_TEST_MARKER();
   1586                          }
   1587                      }
   1588                  }
   1589                  taskEXIT_CRITICAL();
   1590          
   1591                  /* Interrupts and other tasks can give to and take from the semaphore
   1592                   * now the critical section has been exited. */
   1593          
   1594                  vTaskSuspendAll();
   1595                  prvLockQueue( pxQueue );
   1596          
   1597                  /* Update the timeout state to see if it has expired yet. */
   1598                  if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1599                  {
   1600                      /* A block time is specified and not expired.  If the semaphore
   1601                       * count is 0 then enter the Blocked state to wait for a semaphore to
   1602                       * become available.  As semaphores are implemented with queues the
   1603                       * queue being empty is equivalent to the semaphore count being 0. */
   1604                      if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1605                      {
   1606                          traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1607          
   1608                          #if ( configUSE_MUTEXES == 1 )
   1609                              {
   1610                                  if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1611                                  {
   1612                                      taskENTER_CRITICAL();
   1613                                      {
   1614                                          xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
   1615                                      }
   1616                                      taskEXIT_CRITICAL();
   1617                                  }
   1618                                  else
   1619                                  {
   1620                                      mtCOVERAGE_TEST_MARKER();
   1621                                  }
   1622                              }
   1623                          #endif /* if ( configUSE_MUTEXES == 1 ) */
   1624          
   1625                          vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1626                          prvUnlockQueue( pxQueue );
   1627          
   1628                          if( xTaskResumeAll() == pdFALSE )
   1629                          {
   1630                              portYIELD_WITHIN_API();
   1631                          }
   1632                          else
   1633                          {
   1634                              mtCOVERAGE_TEST_MARKER();
   1635                          }
   1636                      }
   1637                      else
   1638                      {
   1639                          /* There was no timeout and the semaphore count was not 0, so
   1640                           * attempt to take the semaphore again. */
   1641                          prvUnlockQueue( pxQueue );
   \                     ??xQueueSemaphoreTake_1: (+1)
   \       0x38   0x.... 0x....      BL       ?Subroutine9
   1642                          ( void ) xTaskResumeAll();
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0x3C   0x.... 0x....      BL       xTaskResumeAll
   1643                      }
   \                     ??xQueueSemaphoreTake_0: (+1)
   \       0x40   0x.... 0x....      BL       vPortEnterCritical
   \       0x44   0x6BB0             LDR      R0,[R6, #+56]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD136             BNE.N    ??xQueueSemaphoreTake_2
   \       0x4A   0x9802             LDR      R0,[SP, #+8]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD03B             BEQ.N    ??xQueueSemaphoreTake_3
   \       0x50   0xB914             CBNZ.N   R4,??xQueueSemaphoreTake_4
   \       0x52   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x56   0x2401             MOVS     R4,#+1
   \                     ??xQueueSemaphoreTake_4: (+1)
   \       0x58   0x.... 0x....      BL       vPortExitCritical
   \       0x5C   0x.... 0x....      BL       vTaskSuspendAll
   \       0x60   0x.... 0x....      BL       vPortEnterCritical
   \       0x64   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x68   0xBF04             ITT      EQ
   \       0x6A   0x2100             MOVEQ    R1,#+0
   \       0x6C   0x7001             STRBEQ   R1,[R0, #+0]
   \       0x6E   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x72   0xBF04             ITT      EQ
   \       0x74   0x2100             MOVEQ    R1,#+0
   \       0x76   0x7041             STRBEQ   R1,[R0, #+1]
   \       0x78   0x.... 0x....      BL       vPortExitCritical
   \       0x7C   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0x4630             MOV      R0,R6
   \       0x84   0xD126             BNE.N    ??xQueueSemaphoreTake_5
   \       0x86   0x.... 0x....      BL       prvIsQueueEmpty
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD0D4             BEQ.N    ??xQueueSemaphoreTake_1
   \       0x8E   0x6830             LDR      R0,[R6, #+0]
   \       0x90   0xB938             CBNZ.N   R0,??xQueueSemaphoreTake_6
   \       0x92   0x.... 0x....      BL       vPortEnterCritical
   \       0x96   0x68B0             LDR      R0,[R6, #+8]
   \       0x98   0x.... 0x....      BL       xTaskPriorityInherit
   \       0x9C   0x4605             MOV      R5,R0
   \       0x9E   0x.... 0x....      BL       vPortExitCritical
   \                     ??xQueueSemaphoreTake_6: (+1)
   \       0xA2   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0xA6   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0xAA   0x.... 0x....      BL       xTaskResumeAll
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD1C6             BNE.N    ??xQueueSemaphoreTake_0
   \       0xB2   0x.... 0x....      BL       vPortYield
   \       0xB6   0xE7C3             B.N      ??xQueueSemaphoreTake_0
   \                     ??xQueueSemaphoreTake_2: (+1)
   \       0xB8   0x1E40             SUBS     R0,R0,#+1
   \       0xBA   0x63B0             STR      R0,[R6, #+56]
   \       0xBC   0x6830             LDR      R0,[R6, #+0]
   \       0xBE   0xB910             CBNZ.N   R0,??xQueueSemaphoreTake_7
   \       0xC0   0x.... 0x....      BL       pvTaskIncrementMutexHeldCount
   \       0xC4   0x60B0             STR      R0,[R6, #+8]
   \                     ??xQueueSemaphoreTake_7: (+1)
   \       0xC6   0x....             B.N      ?Subroutine2
   \                     ??xQueueSemaphoreTake_3: (+1)
   \       0xC8   0xB1DD             CBZ.N    R5,??xQueueSemaphoreTake_8
   \       0xCA   0xF240 0x611D      MOVW     R1,#+1565
   \       0xCE   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0xD2   0xE016             B.N      ??xQueueSemaphoreTake_8
   1644                  }
   1645                  else
   1646                  {
   1647                      /* Timed out. */
   1648                      prvUnlockQueue( pxQueue );
   \                     ??xQueueSemaphoreTake_5: (+1)
   \       0xD4   0x.... 0x....      BL       prvUnlockQueue
   1649                      ( void ) xTaskResumeAll();
   \       0xD8   0x.... 0x....      BL       xTaskResumeAll
   1650          
   1651                      /* If the semaphore count is 0 exit now as the timeout has
   1652                       * expired.  Otherwise return to attempt to take the semaphore that is
   1653                       * known to be available.  As semaphores are implemented by queues the
   1654                       * queue being empty is equivalent to the semaphore count being 0. */
   1655                      if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0x.... 0x....      BL       prvIsQueueEmpty
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD0AC             BEQ.N    ??xQueueSemaphoreTake_0
   1656                      {
   1657                          #if ( configUSE_MUTEXES == 1 )
   1658                              {
   1659                                  /* xInheritanceOccurred could only have be set if
   1660                                   * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
   1661                                   * test the mutex type again to check it is actually a mutex. */
   1662                                  if( xInheritanceOccurred != pdFALSE )
   \       0xE6   0xB175             CBZ.N    R5,??xQueueSemaphoreTake_9
   1663                                  {
   1664                                      taskENTER_CRITICAL();
   \       0xE8   0x.... 0x....      BL       vPortEnterCritical
   1665                                      {
   1666                                          UBaseType_t uxHighestWaitingPriority;
   1667          
   1668                                          /* This task blocking on the mutex caused another
   1669                                           * task to inherit this task's priority.  Now this task
   1670                                           * has timed out the priority should be disinherited
   1671                                           * again, but only as low as the next highest priority
   1672                                           * task that is waiting for the same mutex. */
   1673                                          uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
   \       0xEC   0x6A70             LDR      R0,[R6, #+36]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xBF1D             ITTTE    NE
   \       0xF2   0x6B30             LDRNE    R0,[R6, #+48]
   \       0xF4   0x6801             LDRNE    R1,[R0, #+0]
   \       0xF6   0xF1C1 0x0138      RSBNE    R1,R1,#+56
   \       0xFA   0x2100             MOVEQ    R1,#+0
   1674                                          vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
   \       0xFC   0x68B0             LDR      R0,[R6, #+8]
   \       0xFE   0x.... 0x....      BL       vTaskPriorityDisinheritAfterTimeout
   1675                                      }
   1676                                      taskEXIT_CRITICAL();
   \                     ??xQueueSemaphoreTake_8: (+1)
   \      0x102   0x.... 0x....      BL       vPortExitCritical
   1677                                  }
   1678                              }
   1679                          #endif /* configUSE_MUTEXES */
   1680          
   1681                          traceQUEUE_RECEIVE_FAILED( pxQueue );
   1682                          return errQUEUE_EMPTY;
   \                     ??xQueueSemaphoreTake_9: (+1)
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0xBDFE             POP      {R1-R7,PC}
   1683                      }
   1684                      else
   1685                      {
   1686                          mtCOVERAGE_TEST_MARKER();
   1687                      }
   1688                  }
   1689              } /*lint -restore */
   1690          }
   1691          /*-----------------------------------------------------------*/
   1692          

   \                                 In section .text, align 2, keep-with-next
   1693          BaseType_t xQueuePeek( QueueHandle_t xQueue,
   1694                                 void * const pvBuffer,
   1695                                 TickType_t xTicksToWait )
   1696          {
   \                     xQueuePeek: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   1697              BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1698              TimeOut_t xTimeOut;
   1699              int8_t * pcOriginalReadPosition;
   1700              Queue_t * const pxQueue = xQueue;
   1701          
   1702              /* Check the pointer is not NULL. */
   1703              configASSERT( ( pxQueue ) );
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable16
   \        0xC   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_22
   \        0xE   0xF240 0x61A7      MOVW     R1,#+1703
   \       0x12   0x.... 0x....      BL       ?Subroutine5
   1704          
   1705              /* The buffer into which data is received can only be NULL if the data size
   1706               * is zero (so no data is copied into the buffer. */
   1707              configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x16   0xB92E             CBNZ.N   R6,??CrossCallReturnLabel_21
   \       0x18   0x6C28             LDR      R0,[R5, #+64]
   \       0x1A   0xB118             CBZ.N    R0,??CrossCallReturnLabel_21
   \       0x1C   0xF240 0x61AB      MOVW     R1,#+1707
   \       0x20   0x.... 0x....      BL       ?Subroutine5
   1708          
   1709              /* Cannot block if the scheduler is suspended. */
   1710              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1711                  {
   1712                      configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x24   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x28   0xB958             CBNZ.N   R0,??xQueuePeek_0
   \       0x2A   0x9802             LDR      R0,[SP, #+8]
   \       0x2C   0xB148             CBZ.N    R0,??xQueuePeek_0
   \       0x2E   0xF44F 0x61D6      MOV      R1,#+1712
   \       0x32   0x.... 0x....      BL       ?Subroutine5
   1713                  }
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x36   0xE004             B.N      ??xQueuePeek_0
   1714              #endif
   1715          
   1716              /*lint -save -e904  This function relaxes the coding standard somewhat to
   1717               * allow return statements within the function itself.  This is done in the
   1718               * interest of execution time efficiency. */
   1719              for( ; ; )
   1720              {
   1721                  taskENTER_CRITICAL();
   1722                  {
   1723                      const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1724          
   1725                      /* Is there data in the queue now?  To be running the calling task
   1726                       * must be the highest priority task wanting to access the queue. */
   1727                      if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1728                      {
   1729                          /* Remember the read position so it can be reset after the data
   1730                           * is read from the queue as this function is only peeking the
   1731                           * data, not removing it. */
   1732                          pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   1733          
   1734                          prvCopyDataFromQueue( pxQueue, pvBuffer );
   1735                          traceQUEUE_PEEK( pxQueue );
   1736          
   1737                          /* The data is not being removed, so reset the read pointer. */
   1738                          pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   1739          
   1740                          /* The data is being left in the queue, so see if there are
   1741                           * any other tasks waiting for the data. */
   1742                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1743                          {
   1744                              if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1745                              {
   1746                                  /* The task waiting has a higher priority than this task. */
   1747                                  queueYIELD_IF_USING_PREEMPTION();
   1748                              }
   1749                              else
   1750                              {
   1751                                  mtCOVERAGE_TEST_MARKER();
   1752                              }
   1753                          }
   1754                          else
   1755                          {
   1756                              mtCOVERAGE_TEST_MARKER();
   1757                          }
   1758          
   1759                          taskEXIT_CRITICAL();
   1760                          return pdPASS;
   1761                      }
   1762                      else
   1763                      {
   1764                          if( xTicksToWait == ( TickType_t ) 0 )
   1765                          {
   1766                              /* The queue was empty and no block time is specified (or
   1767                               * the block time has expired) so leave now. */
   1768                              taskEXIT_CRITICAL();
   1769                              traceQUEUE_PEEK_FAILED( pxQueue );
   1770                              return errQUEUE_EMPTY;
   1771                          }
   1772                          else if( xEntryTimeSet == pdFALSE )
   1773                          {
   1774                              /* The queue was empty and a block time was specified so
   1775                               * configure the timeout structure ready to enter the blocked
   1776                               * state. */
   1777                              vTaskInternalSetTimeOutState( &xTimeOut );
   1778                              xEntryTimeSet = pdTRUE;
   1779                          }
   1780                          else
   1781                          {
   1782                              /* Entry time was already set. */
   1783                              mtCOVERAGE_TEST_MARKER();
   1784                          }
   1785                      }
   1786                  }
   1787                  taskEXIT_CRITICAL();
   1788          
   1789                  /* Interrupts and other tasks can send to and receive from the queue
   1790                   * now the critical section has been exited. */
   1791          
   1792                  vTaskSuspendAll();
   1793                  prvLockQueue( pxQueue );
   1794          
   1795                  /* Update the timeout state to see if it has expired yet. */
   1796                  if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1797                  {
   1798                      /* Timeout has not expired yet, check to see if there is data in the
   1799                      * queue now, and if not enter the Blocked state to wait for data. */
   1800                      if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1801                      {
   1802                          traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
   1803                          vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1804                          prvUnlockQueue( pxQueue );
   1805          
   1806                          if( xTaskResumeAll() == pdFALSE )
   1807                          {
   1808                              portYIELD_WITHIN_API();
   1809                          }
   1810                          else
   1811                          {
   1812                              mtCOVERAGE_TEST_MARKER();
   1813                          }
   1814                      }
   1815                      else
   1816                      {
   1817                          /* There is data in the queue now, so don't enter the blocked
   1818                           * state, instead return to try and obtain the data. */
   1819                          prvUnlockQueue( pxQueue );
   \                     ??xQueuePeek_1: (+1)
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x.... 0x....      BL       prvUnlockQueue
   1820                          ( void ) xTaskResumeAll();
   \       0x3E   0x.... 0x....      BL       xTaskResumeAll
   1821                      }
   \                     ??xQueuePeek_0: (+1)
   \       0x42   0x.... 0x....      BL       vPortEnterCritical
   \       0x46   0x6BA8             LDR      R0,[R5, #+56]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD134             BNE.N    ??xQueuePeek_2
   \       0x4C   0x9802             LDR      R0,[SP, #+8]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD041             BEQ.N    ??xQueuePeek_3
   \       0x52   0xB914             CBNZ.N   R4,??xQueuePeek_4
   \       0x54   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x58   0x2401             MOVS     R4,#+1
   \                     ??xQueuePeek_4: (+1)
   \       0x5A   0x.... 0x....      BL       vPortExitCritical
   \       0x5E   0x.... 0x....      BL       vTaskSuspendAll
   \       0x62   0x.... 0x....      BL       vPortEnterCritical
   \       0x66   0xF105 0x0044      ADD      R0,R5,#+68
   \       0x6A   0xF990 0x2000      LDRSB    R2,[R0, #+0]
   \       0x6E   0xF112 0x0F01      CMN      R2,#+1
   \       0x72   0xBF04             ITT      EQ
   \       0x74   0x2100             MOVEQ    R1,#+0
   \       0x76   0x7001             STRBEQ   R1,[R0, #+0]
   \       0x78   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x7C   0xBF04             ITT      EQ
   \       0x7E   0x2100             MOVEQ    R1,#+0
   \       0x80   0x7041             STRBEQ   R1,[R0, #+1]
   \       0x82   0x.... 0x....      BL       vPortExitCritical
   \       0x86   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0x4628             MOV      R0,R5
   \       0x8E   0xD126             BNE.N    ??xQueuePeek_5
   \       0x90   0x.... 0x....      BL       prvIsQueueEmpty
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD0CF             BEQ.N    ??xQueuePeek_1
   \       0x98   0x9902             LDR      R1,[SP, #+8]
   \       0x9A   0xF105 0x0024      ADD      R0,R5,#+36
   \       0x9E   0x.... 0x....      BL       vTaskPlaceOnEventList
   \       0xA2   0x4628             MOV      R0,R5
   \       0xA4   0x.... 0x....      BL       prvUnlockQueue
   \       0xA8   0x.... 0x....      BL       xTaskResumeAll
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD1C8             BNE.N    ??xQueuePeek_0
   \       0xB0   0x.... 0x....      BL       vPortYield
   \       0xB4   0xE7C5             B.N      ??xQueuePeek_0
   \                     ??xQueuePeek_2: (+1)
   \       0xB6   0x68EC             LDR      R4,[R5, #+12]
   \       0xB8   0x4631             MOV      R1,R6
   \       0xBA   0x4628             MOV      R0,R5
   \       0xBC   0x.... 0x....      BL       prvCopyDataFromQueue
   \       0xC0   0x60EC             STR      R4,[R5, #+12]
   \       0xC2   0x6A68             LDR      R0,[R5, #+36]
   \       0xC4   0xB130             CBZ.N    R0,??xQueuePeek_6
   \       0xC6   0xF105 0x0024      ADD      R0,R5,#+36
   \       0xCA   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0xCE   0xB108             CBZ.N    R0,??xQueuePeek_6
   \       0xD0   0x.... 0x....      BL       vPortYield
   \                     ??xQueuePeek_6: (+1)
   \       0xD4   0x....             B.N      ??Subroutine2_0
   \                     ??xQueuePeek_3: (+1)
   \       0xD6   0x.... 0x....      BL       vPortExitCritical
   \                     ??xQueuePeek_7: (+1)
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xBDFE             POP      {R1-R7,PC}
   1822                  }
   1823                  else
   1824                  {
   1825                      /* The timeout has expired.  If there is still no data in the queue
   1826                       * exit, otherwise go back and try to read the data again. */
   1827                      prvUnlockQueue( pxQueue );
   \                     ??xQueuePeek_5: (+1)
   \       0xDE   0x.... 0x....      BL       prvUnlockQueue
   1828                      ( void ) xTaskResumeAll();
   \       0xE2   0x.... 0x....      BL       xTaskResumeAll
   1829          
   1830                      if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \       0xE6   0x4628             MOV      R0,R5
   \       0xE8   0x.... 0x....      BL       prvIsQueueEmpty
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD0A8             BEQ.N    ??xQueuePeek_0
   1831                      {
   1832                          traceQUEUE_PEEK_FAILED( pxQueue );
   1833                          return errQUEUE_EMPTY;
   \       0xF0   0xE7F3             B.N      ??xQueuePeek_7
   1834                      }
   1835                      else
   1836                      {
   1837                          mtCOVERAGE_TEST_MARKER();
   1838                      }
   1839                  }
   1840              } /*lint -restore */
   1841          }
   1842          /*-----------------------------------------------------------*/
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844          BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
   1845                                           void * const pvBuffer,
   1846                                           BaseType_t * const pxHigherPriorityTaskWoken )
   1847          {
   \                     xQueueReceiveFromISR: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4615             MOV      R5,R2
   1848              BaseType_t xReturn;
   1849              UBaseType_t uxSavedInterruptStatus;
   1850              Queue_t * const pxQueue = xQueue;
   1851          
   1852              configASSERT( pxQueue );
   \        0xA   0x.... 0x....      LDR.W    R8,??DataTable16
   \        0xE   0xD103             BNE.N    ??CrossCallReturnLabel_40
   \       0x10   0xF240 0x713C      MOVW     R1,#+1852
   \       0x14   0x.... 0x....      BL       ?Subroutine7
   1853              configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x18   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x1C   0xD105             BNE.N    ??CrossCallReturnLabel_39
   \       0x1E   0x6C20             LDR      R0,[R4, #+64]
   \       0x20   0xB118             CBZ.N    R0,??CrossCallReturnLabel_39
   \       0x22   0xF240 0x713D      MOVW     R1,#+1853
   \       0x26   0x.... 0x....      BL       ?Subroutine7
   1854          
   1855              /* RTOS ports that support interrupt nesting have the concept of a maximum
   1856               * system call (or maximum API call) interrupt priority.  Interrupts that are
   1857               * above the maximum system call priority are kept permanently enabled, even
   1858               * when the RTOS kernel is in a critical section, but cannot make any calls to
   1859               * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1860               * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1861               * failure if a FreeRTOS API function is called from an interrupt that has been
   1862               * assigned a priority above the configured maximum system call priority.
   1863               * Only FreeRTOS functions that end in FromISR can be called from interrupts
   1864               * that have been assigned a priority at or (logically) below the maximum
   1865               * system call interrupt priority.  FreeRTOS maintains a separate interrupt
   1866               * safe API to ensure interrupt entry is as fast and as simple as possible.
   1867               * More information (albeit Cortex-M specific) is provided on the following
   1868               * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   1869              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1870          
   1871              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x2A   0x.... 0x....      BL       ulSetInterruptMask
   1872              {
   1873                  const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x2E   0x6BA7             LDR      R7,[R4, #+56]
   \       0x30   0x4681             MOV      R9,R0
   1874          
   1875                  /* Cannot block in an ISR, so check there is data available. */
   1876                  if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x32   0xB317             CBZ.N    R7,??xQueueReceiveFromISR_0
   1877                  {
   1878                      const int8_t cRxLock = pxQueue->cRxLock;
   \       0x34   0xF994 0x6044      LDRSB    R6,[R4, #+68]
   1879          
   1880                      traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
   1881          
   1882                      prvCopyDataFromQueue( pxQueue, pvBuffer );
   \       0x38   0x4651             MOV      R1,R10
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x.... 0x....      BL       prvCopyDataFromQueue
   1883                      pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   \       0x40   0x1E7F             SUBS     R7,R7,#+1
   \       0x42   0x63A7             STR      R7,[R4, #+56]
   1884          
   1885                      /* If the queue is locked the event list will not be modified.
   1886                       * Instead update the lock count so the task that unlocks the queue
   1887                       * will know that an ISR has removed data while the queue was
   1888                       * locked. */
   1889                      if( cRxLock == queueUNLOCKED )
   \       0x44   0xF116 0x0F01      CMN      R6,#+1
   \       0x48   0xD10C             BNE.N    ??xQueueReceiveFromISR_1
   1890                      {
   1891                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \       0x4A   0x6920             LDR      R0,[R4, #+16]
   \       0x4C   0xB198             CBZ.N    R0,??xQueueReceiveFromISR_2
   1892                          {
   1893                              if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x4E   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x52   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xBF18             IT       NE
   \       0x5A   0x2D00             CMPNE    R5,#+0
   1894                              {
   1895                                  /* The task waiting has a higher priority than us so
   1896                                   * force a context switch. */
   1897                                  if( pxHigherPriorityTaskWoken != NULL )
   \       0x5C   0xD00B             BEQ.N    ??xQueueReceiveFromISR_2
   1898                                  {
   1899                                      *pxHigherPriorityTaskWoken = pdTRUE;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0x6028             STR      R0,[R5, #+0]
   \       0x62   0xE008             B.N      ??xQueueReceiveFromISR_2
   1900                                  }
   1901                                  else
   1902                                  {
   1903                                      mtCOVERAGE_TEST_MARKER();
   1904                                  }
   1905                              }
   1906                              else
   1907                              {
   1908                                  mtCOVERAGE_TEST_MARKER();
   1909                              }
   1910                          }
   1911                          else
   1912                          {
   1913                              mtCOVERAGE_TEST_MARKER();
   1914                          }
   1915                      }
   1916                      else
   1917                      {
   1918                          /* Increment the lock count so the task that unlocks the queue
   1919                           * knows that data was removed while it was locked. */
   1920                          configASSERT( cRxLock != queueINT8_MAX );
   \                     ??xQueueReceiveFromISR_1: (+1)
   \       0x64   0x2E7F             CMP      R6,#+127
   \       0x66   0xD103             BNE.N    ??CrossCallReturnLabel_38
   \       0x68   0xF44F 0x61F0      MOV      R1,#+1920
   \       0x6C   0x.... 0x....      BL       ?Subroutine7
   1921          
   1922                          pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x70   0x1C76             ADDS     R6,R6,#+1
   \       0x72   0xF884 0x6044      STRB     R6,[R4, #+68]
   1923                      }
   1924          
   1925                      xReturn = pdPASS;
   \                     ??xQueueReceiveFromISR_2: (+1)
   \       0x76   0x2401             MOVS     R4,#+1
   \       0x78   0xE000             B.N      ??xQueueReceiveFromISR_3
   1926                  }
   1927                  else
   1928                  {
   1929                      xReturn = pdFAIL;
   \                     ??xQueueReceiveFromISR_0: (+1)
   \       0x7A   0x2400             MOVS     R4,#+0
   1930                      traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
   1931                  }
   1932              }
   1933              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueReceiveFromISR_3: (+1)
   \       0x7C   0x4648             MOV      R0,R9
   \       0x7E                      REQUIRE ?Subroutine1
   \       0x7E                      ;; // Fall through to label ?Subroutine1
   1934          
   1935              return xReturn;
   1936          }
   1937          /*-----------------------------------------------------------*/
   1938          

   \                                 In section .text, align 2, keep-with-next
   1939          BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
   1940                                        void * const pvBuffer )
   1941          {
   \                     xQueuePeekFromISR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1942              BaseType_t xReturn;
   1943              UBaseType_t uxSavedInterruptStatus;
   1944              int8_t * pcOriginalReadPosition;
   1945              Queue_t * const pxQueue = xQueue;
   1946          
   1947              configASSERT( pxQueue );
   \        0x6   0x....             LDR.N    R6,??DataTable16
   \        0x8   0xD103             BNE.N    ??CrossCallReturnLabel_12
   \        0xA   0xF240 0x719B      MOVW     R1,#+1947
   \        0xE   0x.... 0x....      BL       ?Subroutine4
   1948              configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x12   0xB92D             CBNZ.N   R5,??CrossCallReturnLabel_11
   \       0x14   0x6C20             LDR      R0,[R4, #+64]
   \       0x16   0xB128             CBZ.N    R0,??xQueuePeekFromISR_0
   \       0x18   0xF240 0x719C      MOVW     R1,#+1948
   \       0x1C   0x.... 0x....      BL       ?Subroutine4
   1949              configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x20   0x6C20             LDR      R0,[R4, #+64]
   \       0x22   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_10
   \                     ??xQueuePeekFromISR_0: (+1)
   \       0x24   0xF240 0x719D      MOVW     R1,#+1949
   \       0x28   0x.... 0x....      BL       ?Subroutine4
   1950          
   1951              /* RTOS ports that support interrupt nesting have the concept of a maximum
   1952               * system call (or maximum API call) interrupt priority.  Interrupts that are
   1953               * above the maximum system call priority are kept permanently enabled, even
   1954               * when the RTOS kernel is in a critical section, but cannot make any calls to
   1955               * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1956               * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1957               * failure if a FreeRTOS API function is called from an interrupt that has been
   1958               * assigned a priority above the configured maximum system call priority.
   1959               * Only FreeRTOS functions that end in FromISR can be called from interrupts
   1960               * that have been assigned a priority at or (logically) below the maximum
   1961               * system call interrupt priority.  FreeRTOS maintains a separate interrupt
   1962               * safe API to ensure interrupt entry is as fast and as simple as possible.
   1963               * More information (albeit Cortex-M specific) is provided on the following
   1964               * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   1965              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1966          
   1967              uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x2C   0x.... 0x....      BL       ulSetInterruptMask
   \       0x30   0x4606             MOV      R6,R0
   1968              {
   1969                  /* Cannot block in an ISR, so check there is data available. */
   1970                  if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x32   0x6BA0             LDR      R0,[R4, #+56]
   \       0x34   0xB138             CBZ.N    R0,??xQueuePeekFromISR_1
   1971                  {
   1972                      traceQUEUE_PEEK_FROM_ISR( pxQueue );
   1973          
   1974                      /* Remember the read position so it can be reset as nothing is
   1975                       * actually being removed from the queue. */
   1976                      pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   \       0x36   0x68E7             LDR      R7,[R4, #+12]
   1977                      prvCopyDataFromQueue( pxQueue, pvBuffer );
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x.... 0x....      BL       prvCopyDataFromQueue
   1978                      pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   \       0x40   0x60E7             STR      R7,[R4, #+12]
   1979          
   1980                      xReturn = pdPASS;
   \       0x42   0x2401             MOVS     R4,#+1
   \       0x44   0xE000             B.N      ??xQueuePeekFromISR_2
   1981                  }
   1982                  else
   1983                  {
   1984                      xReturn = pdFAIL;
   \                     ??xQueuePeekFromISR_1: (+1)
   \       0x46   0x2400             MOVS     R4,#+0
   1985                      traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
   1986                  }
   1987              }
   1988              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueuePeekFromISR_2: (+1)
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x.... 0x....      BL       vClearInterruptMask
   1989          
   1990              return xReturn;
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0xBDF2             POP      {R1,R4-R7,PC}
   1991          }
   1992          /*-----------------------------------------------------------*/
   1993          

   \                                 In section .text, align 2, keep-with-next
   1994          UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
   1995          {
   \                     uxQueueMessagesWaiting: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1996              UBaseType_t uxReturn;
   1997          
   1998              configASSERT( xQueue );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_5
   \        0x6   0xF240 0x71CE      MOVW     R1,#+1998
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   1999          
   2000              taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xE   0x.... 0x....      BL       vPortEnterCritical
   2001              {
   2002                  uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   \       0x12   0x6BA4             LDR      R4,[R4, #+56]
   2003              }
   2004              taskEXIT_CRITICAL();
   \       0x14                      REQUIRE ?Subroutine0
   \       0x14                      ;; // Fall through to label ?Subroutine0
   2005          
   2006              return uxReturn;
   2007          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   2008          /*-----------------------------------------------------------*/
   2009          

   \                                 In section .text, align 2, keep-with-next
   2010          UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
   2011          {
   \                     uxQueueSpacesAvailable: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2012              UBaseType_t uxReturn;
   2013              Queue_t * const pxQueue = xQueue;
   2014          
   2015              configASSERT( pxQueue );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_4
   \        0x6   0xF240 0x71DF      MOVW     R1,#+2015
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   2016          
   2017              taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xE   0x.... 0x....      BL       vPortEnterCritical
   2018              {
   2019                  uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   \       0x12   0x6BE5             LDR      R5,[R4, #+60]
   \       0x14   0x6BA0             LDR      R0,[R4, #+56]
   \       0x16   0x1A2D             SUBS     R5,R5,R0
   2020              }
   2021              taskEXIT_CRITICAL();
   \       0x18   0x.... 0x....      BL       vPortExitCritical
   2022          
   2023              return uxReturn;
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
   2024          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   2025          /*-----------------------------------------------------------*/
   2026          

   \                                 In section .text, align 2, keep-with-next
   2027          UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
   2028          {
   \                     uxQueueMessagesWaitingFromISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2029              UBaseType_t uxReturn;
   2030              Queue_t * const pxQueue = xQueue;
   2031          
   2032              configASSERT( pxQueue );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_3
   \        0x6   0xF44F 0x61FE      MOV      R1,#+2032
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   2033              uxReturn = pxQueue->uxMessagesWaiting;
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xE   0x6BA0             LDR      R0,[R4, #+56]
   2034          
   2035              return uxReturn;
   \       0x10   0xBD10             POP      {R4,PC}
   2036          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   2037          /*-----------------------------------------------------------*/
   2038          

   \                                 In section .text, align 2, keep-with-next
   2039          void vQueueDelete( QueueHandle_t xQueue )
   2040          {
   \                     vQueueDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2041              Queue_t * const pxQueue = xQueue;
   2042          
   2043              configASSERT( pxQueue );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_2
   \        0x6   0xF240 0x71FB      MOVW     R1,#+2043
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   2044              traceQUEUE_DELETE( pxQueue );
   2045          
   2046              #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2047                  {
   2048                      vQueueUnregisterQueue( pxQueue );
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       vQueueUnregisterQueue
   2049                  }
   2050              #endif
   2051          
   2052              #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
   2053                  {
   2054                      /* The queue can only have been allocated dynamically - free it
   2055                       * again. */
   2056                      vPortFree( pxQueue );
   2057                  }
   2058              #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
   2059                  {
   2060                      /* The queue could have been allocated statically or dynamically, so
   2061                       * check before attempting to free the memory. */
   2062                      if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
   \       0x14   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \       0x18   0xB920             CBNZ.N   R0,??vQueueDelete_0
   2063                      {
   2064                          vPortFree( pxQueue );
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x.... 0x....      B.W      vPortFree
   2065                      }
   2066                      else
   2067                      {
   2068                          mtCOVERAGE_TEST_MARKER();
   2069                      }
   2070                  }
   2071              #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) */
   2072                  {
   2073                      /* The queue must have been statically allocated, so is not going to be
   2074                       * deleted.  Avoid compiler warnings about the unused parameter. */
   2075                      ( void ) pxQueue;
   2076                  }
   2077              #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   2078          }
   \                     ??vQueueDelete_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   2079          /*-----------------------------------------------------------*/
   2080          
   2081          #if ( configUSE_TRACE_FACILITY == 1 )
   2082          

   \                                 In section .text, align 2, keep-with-next
   2083              UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
   2084              {
   2085                  return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   \                     uxQueueGetQueueNumber: (+1)
   \        0x0   0x6C80             LDR      R0,[R0, #+72]
   \        0x2   0x4770             BX       LR
   2086              }
   2087          
   2088          #endif /* configUSE_TRACE_FACILITY */
   2089          /*-----------------------------------------------------------*/
   2090          
   2091          #if ( configUSE_TRACE_FACILITY == 1 )
   2092          

   \                                 In section .text, align 2, keep-with-next
   2093              void vQueueSetQueueNumber( QueueHandle_t xQueue,
   2094                                         UBaseType_t uxQueueNumber )
   2095              {
   2096                  ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   \                     vQueueSetQueueNumber: (+1)
   \        0x0   0x6481             STR      R1,[R0, #+72]
   2097              }
   \        0x2   0x4770             BX       LR
   2098          
   2099          #endif /* configUSE_TRACE_FACILITY */
   2100          /*-----------------------------------------------------------*/
   2101          
   2102          #if ( configUSE_TRACE_FACILITY == 1 )
   2103          

   \                                 In section .text, align 2, keep-with-next
   2104              uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
   2105              {
   2106                  return ( ( Queue_t * ) xQueue )->ucQueueType;
   \                     ucQueueGetQueueType: (+1)
   \        0x0   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \        0x4   0x4770             BX       LR
   2107              }
   2108          
   2109          #endif /* configUSE_TRACE_FACILITY */
   2110          /*-----------------------------------------------------------*/
   2111          
   2112          #if ( configUSE_MUTEXES == 1 )
   2113          
   2114              static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
   2115              {
   2116                  UBaseType_t uxHighestPriorityOfWaitingTasks;
   2117          
   2118                  /* If a task waiting for a mutex causes the mutex holder to inherit a
   2119                   * priority, but the waiting task times out, then the holder should
   2120                   * disinherit the priority - but only down to the highest priority of any
   2121                   * other tasks that are waiting for the same mutex.  For this purpose,
   2122                   * return the priority of the highest priority task that is waiting for the
   2123                   * mutex. */
   2124                  if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   2125                  {
   2126                      uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   2127                  }
   2128                  else
   2129                  {
   2130                      uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   2131                  }
   2132          
   2133                  return uxHighestPriorityOfWaitingTasks;
   2134              }
   2135          
   2136          #endif /* configUSE_MUTEXES */
   2137          /*-----------------------------------------------------------*/
   2138          

   \                                 In section .text, align 2, keep-with-next
   2139          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
   2140                                                const void * pvItemToQueue,
   2141                                                const BaseType_t xPosition )
   2142          {
   \                     prvCopyDataToQueue: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4615             MOV      R5,R2
   2143              BaseType_t xReturn = pdFALSE;
   2144              UBaseType_t uxMessagesWaiting;
   2145          
   2146              /* This function is called from a critical section. */
   2147          
   2148              uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \        0x6   0x6BB4             LDR      R4,[R6, #+56]
   2149          
   2150              if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   \        0x8   0x6C32             LDR      R2,[R6, #+64]
   \        0xA   0x2700             MOVS     R7,#+0
   \        0xC   0xB942             CBNZ.N   R2,??prvCopyDataToQueue_0
   2151              {
   2152                  #if ( configUSE_MUTEXES == 1 )
   2153                      {
   2154                          if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \        0xE   0x6830             LDR      R0,[R6, #+0]
   \       0x10   0xBB30             CBNZ.N   R0,??prvCopyDataToQueue_1
   2155                          {
   2156                              /* The mutex is no longer being held. */
   2157                              xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   \       0x12   0x68B0             LDR      R0,[R6, #+8]
   \       0x14   0x.... 0x....      BL       xTaskPriorityDisinherit
   2158                              pxQueue->u.xSemaphore.xMutexHolder = NULL;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x4607             MOV      R7,R0
   \       0x1C   0x60B1             STR      R1,[R6, #+8]
   \       0x1E   0xE01F             B.N      ??prvCopyDataToQueue_1
   2159                          }
   2160                          else
   2161                          {
   2162                              mtCOVERAGE_TEST_MARKER();
   2163                          }
   2164                      }
   2165                  #endif /* configUSE_MUTEXES */
   2166              }
   2167              else if( xPosition == queueSEND_TO_BACK )
   \                     ??prvCopyDataToQueue_0: (+1)
   \       0x20   0xB965             CBNZ.N   R5,??prvCopyDataToQueue_2
   2168              {
   2169                  ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   \       0x22   0x6870             LDR      R0,[R6, #+4]
   \       0x24   0x.... 0x....      BL       __aeabi_memcpy
   2170                  pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   \       0x28   0x6871             LDR      R1,[R6, #+4]
   \       0x2A   0x6C30             LDR      R0,[R6, #+64]
   \       0x2C   0x4408             ADD      R0,R1,R0
   2171          
   2172                  if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \       0x2E   0x68B1             LDR      R1,[R6, #+8]
   \       0x30   0x6070             STR      R0,[R6, #+4]
   \       0x32   0x4288             CMP      R0,R1
   \       0x34   0xD314             BCC.N    ??prvCopyDataToQueue_1
   2173                  {
   2174                      pxQueue->pcWriteTo = pxQueue->pcHead;
   \       0x36   0x6830             LDR      R0,[R6, #+0]
   \       0x38   0x6070             STR      R0,[R6, #+4]
   \       0x3A   0xE011             B.N      ??prvCopyDataToQueue_1
   2175                  }
   2176                  else
   2177                  {
   2178                      mtCOVERAGE_TEST_MARKER();
   2179                  }
   2180              }
   2181              else
   2182              {
   2183                  ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   \                     ??prvCopyDataToQueue_2: (+1)
   \       0x3C   0x68F0             LDR      R0,[R6, #+12]
   \       0x3E   0x.... 0x....      BL       __aeabi_memcpy
   2184                  pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   \       0x42   0x6C30             LDR      R0,[R6, #+64]
   \       0x44   0x68F2             LDR      R2,[R6, #+12]
   \       0x46   0x4240             RSBS     R0,R0,#+0
   \       0x48   0x4402             ADD      R2,R2,R0
   \       0x4A   0x60F2             STR      R2,[R6, #+12]
   2185          
   2186                  if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \       0x4C   0x6831             LDR      R1,[R6, #+0]
   \       0x4E   0x428A             CMP      R2,R1
   \       0x50   0xD202             BCS.N    ??prvCopyDataToQueue_3
   2187                  {
   2188                      pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   \       0x52   0x68B2             LDR      R2,[R6, #+8]
   \       0x54   0x4410             ADD      R0,R2,R0
   \       0x56   0x60F0             STR      R0,[R6, #+12]
   2189                  }
   2190                  else
   2191                  {
   2192                      mtCOVERAGE_TEST_MARKER();
   2193                  }
   2194          
   2195                  if( xPosition == queueOVERWRITE )
   \                     ??prvCopyDataToQueue_3: (+1)
   \       0x58   0x2D02             CMP      R5,#+2
   \       0x5A   0xD101             BNE.N    ??prvCopyDataToQueue_1
   2196                  {
   2197                      if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x5C   0xB104             CBZ.N    R4,??prvCopyDataToQueue_1
   2198                      {
   2199                          /* An item is not being added but overwritten, so subtract
   2200                           * one from the recorded number of items in the queue so when
   2201                           * one is added again below the number of recorded items remains
   2202                           * correct. */
   2203                          --uxMessagesWaiting;
   \       0x5E   0x1E64             SUBS     R4,R4,#+1
   2204                      }
   2205                      else
   2206                      {
   2207                          mtCOVERAGE_TEST_MARKER();
   2208                      }
   2209                  }
   2210                  else
   2211                  {
   2212                      mtCOVERAGE_TEST_MARKER();
   2213                  }
   2214              }
   2215          
   2216              pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   \                     ??prvCopyDataToQueue_1: (+1)
   \       0x60   0x1C64             ADDS     R4,R4,#+1
   \       0x62   0x63B4             STR      R4,[R6, #+56]
   2217          
   2218              return xReturn;
   \       0x64   0x4638             MOV      R0,R7
   \       0x66   0xBDF2             POP      {R1,R4-R7,PC}
   2219          }
   2220          /*-----------------------------------------------------------*/
   2221          

   \                                 In section .text, align 2, keep-with-next
   2222          static void prvCopyDataFromQueue( Queue_t * const pxQueue,
   2223                                            void * const pvBuffer )
   2224          {
   \                     prvCopyDataFromQueue: (+1)
   \        0x0   0x6C02             LDR      R2,[R0, #+64]
   \        0x2   0x460B             MOV      R3,R1
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD100             BNE.N    ??prvCopyDataFromQueue_0
   \        0x8   0x4770             BX       LR
   \                     ??prvCopyDataFromQueue_0: (+1)
   \        0xA   0xB510             PUSH     {R4,LR}
   2225              if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   2226              {
   2227                  pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   \        0xC   0x68C4             LDR      R4,[R0, #+12]
   2228          
   2229                  if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   \        0xE   0x6881             LDR      R1,[R0, #+8]
   \       0x10   0x4414             ADD      R4,R4,R2
   \       0x12   0x60C4             STR      R4,[R0, #+12]
   \       0x14   0x428C             CMP      R4,R1
   \       0x16   0xBF24             ITT      CS
   \       0x18   0x6804             LDRCS    R4,[R0, #+0]
   \       0x1A   0x60C4             STRCS    R4,[R0, #+12]
   2230                  {
   2231                      pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2232                  }
   2233                  else
   2234                  {
   2235                      mtCOVERAGE_TEST_MARKER();
   2236                  }
   2237          
   2238                  ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   \       0x1C   0x68C1             LDR      R1,[R0, #+12]
   \       0x1E   0x4618             MOV      R0,R3
   \       0x20   0xE8BD 0x4010      POP      {R4,LR}
   \       0x24   0x.... 0x....      B.W      __aeabi_memcpy
   2239              }
   2240          }
   2241          /*-----------------------------------------------------------*/
   2242          

   \                                 In section .text, align 2, keep-with-next
   2243          static void prvUnlockQueue( Queue_t * const pxQueue )
   2244          {
   \                     prvUnlockQueue: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   2245              /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
   2246          
   2247              /* The lock counts contains the number of extra data items placed or
   2248               * removed from the queue while the queue was locked.  When a queue is
   2249               * locked items can be added or removed, but the event lists cannot be
   2250               * updated. */
   2251              taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   2252              {
   2253                  int8_t cTxLock = pxQueue->cTxLock;
   \        0x8   0xF105 0x0444      ADD      R4,R5,#+68
   \        0xC   0xF994 0x6001      LDRSB    R6,[R4, #+1]
   \       0x10   0xE007             B.N      ??prvUnlockQueue_0
   2254          
   2255                  /* See if data was added to the queue while it was locked. */
   2256                  while( cTxLock > queueLOCKED_UNMODIFIED )
   2257                  {
   2258                      /* Data was posted while the queue was locked.  Are any tasks
   2259                       * blocked waiting for data to become available? */
   2260                      #if ( configUSE_QUEUE_SETS == 1 )
   2261                          {
   2262                              if( pxQueue->pxQueueSetContainer != NULL )
   2263                              {
   2264                                  if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
   2265                                  {
   2266                                      /* The queue is a member of a queue set, and posting to
   2267                                       * the queue set caused a higher priority task to unblock.
   2268                                       * A context switch is required. */
   2269                                      vTaskMissedYield();
   2270                                  }
   2271                                  else
   2272                                  {
   2273                                      mtCOVERAGE_TEST_MARKER();
   2274                                  }
   2275                              }
   2276                              else
   2277                              {
   2278                                  /* Tasks that are removed from the event list will get
   2279                                   * added to the pending ready list as the scheduler is still
   2280                                   * suspended. */
   2281                                  if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2282                                  {
   2283                                      if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2284                                      {
   2285                                          /* The task waiting has a higher priority so record that a
   2286                                           * context switch is required. */
   2287                                          vTaskMissedYield();
   2288                                      }
   2289                                      else
   2290                                      {
   2291                                          mtCOVERAGE_TEST_MARKER();
   2292                                      }
   2293                                  }
   2294                                  else
   2295                                  {
   2296                                      break;
   2297                                  }
   2298                              }
   2299                          }
   2300                      #else /* configUSE_QUEUE_SETS */
   2301                          {
   2302                              /* Tasks that are removed from the event list will get added to
   2303                               * the pending ready list as the scheduler is still suspended. */
   2304                              if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2305                              {
   2306                                  if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \                     ??prvUnlockQueue_1: (+1)
   \       0x12   0xF105 0x0024      ADD      R0,R5,#+36
   \       0x16   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x1A   0xB108             CBZ.N    R0,??prvUnlockQueue_2
   2307                                  {
   2308                                      /* The task waiting has a higher priority so record that
   2309                                       * a context switch is required. */
   2310                                      vTaskMissedYield();
   \       0x1C   0x.... 0x....      BL       vTaskMissedYield
   2311                                  }
   2312                                  else
   2313                                  {
   2314                                      mtCOVERAGE_TEST_MARKER();
   2315                                  }
   2316                              }
   2317                              else
   2318                              {
   2319                                  break;
   2320                              }
   2321                          }
   2322                      #endif /* configUSE_QUEUE_SETS */
   2323          
   2324                      --cTxLock;
   \                     ??prvUnlockQueue_2: (+1)
   \       0x20   0x1E76             SUBS     R6,R6,#+1
   \                     ??prvUnlockQueue_0: (+1)
   \       0x22   0xB270             SXTB     R0,R6
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xDB02             BLT.N    ??prvUnlockQueue_3
   \       0x28   0x6A68             LDR      R0,[R5, #+36]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD1F1             BNE.N    ??prvUnlockQueue_1
   2325                  }
   2326          
   2327                  pxQueue->cTxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_3: (+1)
   \       0x2E   0xF04F 0x36FF      MOV      R6,#+4294967295
   \       0x32   0x7066             STRB     R6,[R4, #+1]
   2328              }
   2329              taskEXIT_CRITICAL();
   \       0x34   0x.... 0x....      BL       vPortExitCritical
   2330          
   2331              /* Do the same for the Rx lock. */
   2332              taskENTER_CRITICAL();
   \       0x38   0x.... 0x....      BL       vPortEnterCritical
   2333              {
   2334                  int8_t cRxLock = pxQueue->cRxLock;
   \       0x3C   0xF994 0x7000      LDRSB    R7,[R4, #+0]
   \       0x40   0xE007             B.N      ??prvUnlockQueue_4
   2335          
   2336                  while( cRxLock > queueLOCKED_UNMODIFIED )
   2337                  {
   2338                      if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2339                      {
   2340                          if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \                     ??prvUnlockQueue_5: (+1)
   \       0x42   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x46   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x4A   0xB108             CBZ.N    R0,??prvUnlockQueue_6
   2341                          {
   2342                              vTaskMissedYield();
   \       0x4C   0x.... 0x....      BL       vTaskMissedYield
   2343                          }
   2344                          else
   2345                          {
   2346                              mtCOVERAGE_TEST_MARKER();
   2347                          }
   2348          
   2349                          --cRxLock;
   \                     ??prvUnlockQueue_6: (+1)
   \       0x50   0x1E7F             SUBS     R7,R7,#+1
   2350                      }
   \                     ??prvUnlockQueue_4: (+1)
   \       0x52   0xB278             SXTB     R0,R7
   \       0x54   0x2801             CMP      R0,#+1
   \       0x56   0xDB02             BLT.N    ??prvUnlockQueue_7
   \       0x58   0x6928             LDR      R0,[R5, #+16]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD1F1             BNE.N    ??prvUnlockQueue_5
   2351                      else
   2352                      {
   2353                          break;
   2354                      }
   2355                  }
   2356          
   2357                  pxQueue->cRxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_7: (+1)
   \       0x5E   0x7026             STRB     R6,[R4, #+0]
   2358              }
   2359              taskEXIT_CRITICAL();
   \       0x60   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \       0x64   0x.... 0x....      B.W      vPortExitCritical
   2360          }
   2361          /*-----------------------------------------------------------*/
   2362          

   \                                 In section .text, align 2, keep-with-next
   2363          static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
   2364          {
   \                     prvIsQueueEmpty: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2365              BaseType_t xReturn;
   2366          
   2367              taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   2368              {
   2369                  if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x1E44             SUBS     R4,R0,#+1
   \        0xC   0x41A4             SBCS     R4,R4,R4
   2370                  {
   2371                      xReturn = pdTRUE;
   2372                  }
   2373                  else
   2374                  {
   2375                      xReturn = pdFALSE;
   2376                  }
   2377              }
   2378              taskEXIT_CRITICAL();
   \        0xE   0x.... 0x....      BL       vPortExitCritical
   2379          
   2380              return xReturn;
   \       0x12   0x0FE0             LSRS     R0,R4,#+31
   \       0x14   0xBD10             POP      {R4,PC}
   2381          }
   2382          /*-----------------------------------------------------------*/
   2383          

   \                                 In section .text, align 2, keep-with-next
   2384          BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
   2385          {
   \                     xQueueIsQueueEmptyFromISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2386              BaseType_t xReturn;
   2387              Queue_t * const pxQueue = xQueue;
   2388          
   2389              configASSERT( pxQueue );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_1
   \        0x6   0xF640 0x1155      MOVW     R1,#+2389
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   2390          
   2391              if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xE   0x6BA0             LDR      R0,[R4, #+56]
   \       0x10   0x1E40             SUBS     R0,R0,#+1
   \       0x12   0x4180             SBCS     R0,R0,R0
   \       0x14   0x0FC0             LSRS     R0,R0,#+31
   2392              {
   2393                  xReturn = pdTRUE;
   2394              }
   2395              else
   2396              {
   2397                  xReturn = pdFALSE;
   2398              }
   2399          
   2400              return xReturn;
   \       0x16   0xBD10             POP      {R4,PC}
   2401          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2402          /*-----------------------------------------------------------*/
   2403          
   2404          static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
   2405          {
   2406              BaseType_t xReturn;
   2407          
   2408              taskENTER_CRITICAL();
   2409              {
   2410                  if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   2411                  {
   2412                      xReturn = pdTRUE;
   2413                  }
   2414                  else
   2415                  {
   2416                      xReturn = pdFALSE;
   2417                  }
   2418              }
   2419              taskEXIT_CRITICAL();
   2420          
   2421              return xReturn;
   2422          }
   2423          /*-----------------------------------------------------------*/
   2424          

   \                                 In section .text, align 2, keep-with-next
   2425          BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
   2426          {
   \                     xQueueIsQueueFullFromISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2427              BaseType_t xReturn;
   2428              Queue_t * const pxQueue = xQueue;
   2429          
   2430              configASSERT( pxQueue );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_0
   \        0x6   0xF640 0x117E      MOVW     R1,#+2430
   \        0xA   0x.... 0x....      BL       ?Subroutine3
   2431          
   2432              if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xE   0x6BA0             LDR      R0,[R4, #+56]
   \       0x10   0x6BE1             LDR      R1,[R4, #+60]
   \       0x12   0x4288             CMP      R0,R1
   \       0x14   0xD101             BNE.N    ??xQueueIsQueueFullFromISR_0
   2433              {
   2434                  xReturn = pdTRUE;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD10             POP      {R4,PC}
   2435              }
   2436              else
   2437              {
   2438                  xReturn = pdFALSE;
   \                     ??xQueueIsQueueFullFromISR_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   2439              }
   2440          
   2441              return xReturn;
   \       0x1C   0xBD10             POP      {R4,PC}
   2442          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2443          /*-----------------------------------------------------------*/
   2444          
   2445          #if ( configUSE_CO_ROUTINES == 1 )
   2446          
   2447              BaseType_t xQueueCRSend( QueueHandle_t xQueue,
   2448                                       const void * pvItemToQueue,
   2449                                       TickType_t xTicksToWait )
   2450              {
   2451                  BaseType_t xReturn;
   2452                  Queue_t * const pxQueue = xQueue;
   2453          
   2454                  /* If the queue is already full we may have to block.  A critical section
   2455                   * is required to prevent an interrupt removing something from the queue
   2456                   * between the check to see if the queue is full and blocking on the queue. */
   2457                  portDISABLE_INTERRUPTS();
   2458                  {
   2459                      if( prvIsQueueFull( pxQueue ) != pdFALSE )
   2460                      {
   2461                          /* The queue is full - do we want to block or just leave without
   2462                           * posting? */
   2463                          if( xTicksToWait > ( TickType_t ) 0 )
   2464                          {
   2465                              /* As this is called from a coroutine we cannot block directly, but
   2466                               * return indicating that we need to block. */
   2467                              vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
   2468                              portENABLE_INTERRUPTS();
   2469                              return errQUEUE_BLOCKED;
   2470                          }
   2471                          else
   2472                          {
   2473                              portENABLE_INTERRUPTS();
   2474                              return errQUEUE_FULL;
   2475                          }
   2476                      }
   2477                  }
   2478                  portENABLE_INTERRUPTS();
   2479          
   2480                  portDISABLE_INTERRUPTS();
   2481                  {
   2482                      if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2483                      {
   2484                          /* There is room in the queue, copy the data into the queue. */
   2485                          prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2486                          xReturn = pdPASS;
   2487          
   2488                          /* Were any co-routines waiting for data to become available? */
   2489                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2490                          {
   2491                              /* In this instance the co-routine could be placed directly
   2492                               * into the ready list as we are within a critical section.
   2493                               * Instead the same pending ready list mechanism is used as if
   2494                               * the event were caused from within an interrupt. */
   2495                              if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2496                              {
   2497                                  /* The co-routine waiting has a higher priority so record
   2498                                   * that a yield might be appropriate. */
   2499                                  xReturn = errQUEUE_YIELD;
   2500                              }
   2501                              else
   2502                              {
   2503                                  mtCOVERAGE_TEST_MARKER();
   2504                              }
   2505                          }
   2506                          else
   2507                          {
   2508                              mtCOVERAGE_TEST_MARKER();
   2509                          }
   2510                      }
   2511                      else
   2512                      {
   2513                          xReturn = errQUEUE_FULL;
   2514                      }
   2515                  }
   2516                  portENABLE_INTERRUPTS();
   2517          
   2518                  return xReturn;
   2519              }
   2520          
   2521          #endif /* configUSE_CO_ROUTINES */
   2522          /*-----------------------------------------------------------*/
   2523          
   2524          #if ( configUSE_CO_ROUTINES == 1 )
   2525          
   2526              BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
   2527                                          void * pvBuffer,
   2528                                          TickType_t xTicksToWait )
   2529              {
   2530                  BaseType_t xReturn;
   2531                  Queue_t * const pxQueue = xQueue;
   2532          
   2533                  /* If the queue is already empty we may have to block.  A critical section
   2534                   * is required to prevent an interrupt adding something to the queue
   2535                   * between the check to see if the queue is empty and blocking on the queue. */
   2536                  portDISABLE_INTERRUPTS();
   2537                  {
   2538                      if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   2539                      {
   2540                          /* There are no messages in the queue, do we want to block or just
   2541                           * leave with nothing? */
   2542                          if( xTicksToWait > ( TickType_t ) 0 )
   2543                          {
   2544                              /* As this is a co-routine we cannot block directly, but return
   2545                               * indicating that we need to block. */
   2546                              vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
   2547                              portENABLE_INTERRUPTS();
   2548                              return errQUEUE_BLOCKED;
   2549                          }
   2550                          else
   2551                          {
   2552                              portENABLE_INTERRUPTS();
   2553                              return errQUEUE_FULL;
   2554                          }
   2555                      }
   2556                      else
   2557                      {
   2558                          mtCOVERAGE_TEST_MARKER();
   2559                      }
   2560                  }
   2561                  portENABLE_INTERRUPTS();
   2562          
   2563                  portDISABLE_INTERRUPTS();
   2564                  {
   2565                      if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2566                      {
   2567                          /* Data is available from the queue. */
   2568                          pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
   2569          
   2570                          if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
   2571                          {
   2572                              pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2573                          }
   2574                          else
   2575                          {
   2576                              mtCOVERAGE_TEST_MARKER();
   2577                          }
   2578          
   2579                          --( pxQueue->uxMessagesWaiting );
   2580                          ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2581          
   2582                          xReturn = pdPASS;
   2583          
   2584                          /* Were any co-routines waiting for space to become available? */
   2585                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2586                          {
   2587                              /* In this instance the co-routine could be placed directly
   2588                               * into the ready list as we are within a critical section.
   2589                               * Instead the same pending ready list mechanism is used as if
   2590                               * the event were caused from within an interrupt. */
   2591                              if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2592                              {
   2593                                  xReturn = errQUEUE_YIELD;
   2594                              }
   2595                              else
   2596                              {
   2597                                  mtCOVERAGE_TEST_MARKER();
   2598                              }
   2599                          }
   2600                          else
   2601                          {
   2602                              mtCOVERAGE_TEST_MARKER();
   2603                          }
   2604                      }
   2605                      else
   2606                      {
   2607                          xReturn = pdFAIL;
   2608                      }
   2609                  }
   2610                  portENABLE_INTERRUPTS();
   2611          
   2612                  return xReturn;
   2613              }
   2614          
   2615          #endif /* configUSE_CO_ROUTINES */
   2616          /*-----------------------------------------------------------*/
   2617          
   2618          #if ( configUSE_CO_ROUTINES == 1 )
   2619          
   2620              BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
   2621                                              const void * pvItemToQueue,
   2622                                              BaseType_t xCoRoutinePreviouslyWoken )
   2623              {
   2624                  Queue_t * const pxQueue = xQueue;
   2625          
   2626                  /* Cannot block within an ISR so if there is no space on the queue then
   2627                   * exit without doing anything. */
   2628                  if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2629                  {
   2630                      prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2631          
   2632                      /* We only want to wake one co-routine per ISR, so check that a
   2633                       * co-routine has not already been woken. */
   2634                      if( xCoRoutinePreviouslyWoken == pdFALSE )
   2635                      {
   2636                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2637                          {
   2638                              if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2639                              {
   2640                                  return pdTRUE;
   2641                              }
   2642                              else
   2643                              {
   2644                                  mtCOVERAGE_TEST_MARKER();
   2645                              }
   2646                          }
   2647                          else
   2648                          {
   2649                              mtCOVERAGE_TEST_MARKER();
   2650                          }
   2651                      }
   2652                      else
   2653                      {
   2654                          mtCOVERAGE_TEST_MARKER();
   2655                      }
   2656                  }
   2657                  else
   2658                  {
   2659                      mtCOVERAGE_TEST_MARKER();
   2660                  }
   2661          
   2662                  return xCoRoutinePreviouslyWoken;
   2663              }
   2664          
   2665          #endif /* configUSE_CO_ROUTINES */
   2666          /*-----------------------------------------------------------*/
   2667          
   2668          #if ( configUSE_CO_ROUTINES == 1 )
   2669          
   2670              BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
   2671                                                 void * pvBuffer,
   2672                                                 BaseType_t * pxCoRoutineWoken )
   2673              {
   2674                  BaseType_t xReturn;
   2675                  Queue_t * const pxQueue = xQueue;
   2676          
   2677                  /* We cannot block from an ISR, so check there is data available. If
   2678                   * not then just leave without doing anything. */
   2679                  if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2680                  {
   2681                      /* Copy the data from the queue. */
   2682                      pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
   2683          
   2684                      if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
   2685                      {
   2686                          pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2687                      }
   2688                      else
   2689                      {
   2690                          mtCOVERAGE_TEST_MARKER();
   2691                      }
   2692          
   2693                      --( pxQueue->uxMessagesWaiting );
   2694                      ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2695          
   2696                      if( ( *pxCoRoutineWoken ) == pdFALSE )
   2697                      {
   2698                          if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2699                          {
   2700                              if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2701                              {
   2702                                  *pxCoRoutineWoken = pdTRUE;
   2703                              }
   2704                              else
   2705                              {
   2706                                  mtCOVERAGE_TEST_MARKER();
   2707                              }
   2708                          }
   2709                          else
   2710                          {
   2711                              mtCOVERAGE_TEST_MARKER();
   2712                          }
   2713                      }
   2714                      else
   2715                      {
   2716                          mtCOVERAGE_TEST_MARKER();
   2717                      }
   2718          
   2719                      xReturn = pdPASS;
   2720                  }
   2721                  else
   2722                  {
   2723                      xReturn = pdFAIL;
   2724                  }
   2725          
   2726                  return xReturn;
   2727              }
   2728          
   2729          #endif /* configUSE_CO_ROUTINES */
   2730          /*-----------------------------------------------------------*/
   2731          
   2732          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2733          

   \                                 In section .text, align 2, keep-with-next
   2734              void vQueueAddToRegistry( QueueHandle_t xQueue,
   2735                                        const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2736              {
   \                     vQueueAddToRegistry: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2737                  UBaseType_t ux;
   2738          
   2739                  /* See if there is an empty space in the registry.  A NULL name denotes
   2740                   * a free slot. */
   2741                  for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x....             LDR.N    R3,??DataTable16_1
   2742                  {
   2743                      if( xQueueRegistry[ ux ].pcQueueName == NULL )
   \                     ??vQueueAddToRegistry_0: (+1)
   \        0x6   0xF853 0x2034      LDR      R2,[R3, R4, LSL #+3]
   \        0xA   0xB11A             CBZ.N    R2,??vQueueAddToRegistry_1
   \        0xC   0x1C64             ADDS     R4,R4,#+1
   \        0xE   0x2C0A             CMP      R4,#+10
   \       0x10   0xD3F9             BCC.N    ??vQueueAddToRegistry_0
   \       0x12   0xBD10             POP      {R4,PC}
   2744                      {
   2745                          /* Store the information on this queue. */
   2746                          xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   \                     ??vQueueAddToRegistry_1: (+1)
   \       0x14   0xF843 0x1034      STR      R1,[R3, R4, LSL #+3]
   2747                          xQueueRegistry[ ux ].xHandle = xQueue;
   \       0x18   0xEB03 0x01C4      ADD      R1,R3,R4, LSL #+3
   \       0x1C   0x6048             STR      R0,[R1, #+4]
   2748          
   2749                          traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
   2750                          break;
   2751                      }
   2752                      else
   2753                      {
   2754                          mtCOVERAGE_TEST_MARKER();
   2755                      }
   2756                  }
   2757              }
   \       0x1E   0xBD10             POP      {R4,PC}
   2758          
   2759          #endif /* configQUEUE_REGISTRY_SIZE */
   2760          /*-----------------------------------------------------------*/
   2761          
   2762          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2763          

   \                                 In section .text, align 2, keep-with-next
   2764              const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2765              {
   \                     pcQueueGetName: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xB530             PUSH     {R4,R5,LR}
   2766                  UBaseType_t ux;
   2767                  const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   \        0x4   0x2000             MOVS     R0,#+0
   2768          
   2769                  /* Note there is nothing here to protect against another task adding or
   2770                   * removing entries from the registry while it is being searched. */
   2771          
   2772                  for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x....             LDR.N    R2,??DataTable16_1
   2773                  {
   2774                      if( xQueueRegistry[ ux ].xHandle == xQueue )
   \                     ??pcQueueGetName_0: (+1)
   \        0xA   0xEB02 0x05C3      ADD      R5,R2,R3, LSL #+3
   \        0xE   0x686C             LDR      R4,[R5, #+4]
   \       0x10   0x428C             CMP      R4,R1
   \       0x12   0xD003             BEQ.N    ??pcQueueGetName_1
   \       0x14   0x1C5B             ADDS     R3,R3,#+1
   \       0x16   0x2B0A             CMP      R3,#+10
   \       0x18   0xD3F7             BCC.N    ??pcQueueGetName_0
   \       0x1A   0xBD30             POP      {R4,R5,PC}
   2775                      {
   2776                          pcReturn = xQueueRegistry[ ux ].pcQueueName;
   \                     ??pcQueueGetName_1: (+1)
   \       0x1C   0xF852 0x0033      LDR      R0,[R2, R3, LSL #+3]
   2777                          break;
   2778                      }
   2779                      else
   2780                      {
   2781                          mtCOVERAGE_TEST_MARKER();
   2782                      }
   2783                  }
   2784          
   2785                  return pcReturn;
   \       0x20   0xBD30             POP      {R4,R5,PC}
   2786              } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
   2787          
   2788          #endif /* configQUEUE_REGISTRY_SIZE */
   2789          /*-----------------------------------------------------------*/
   2790          
   2791          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2792          

   \                                 In section .text, align 2, keep-with-next
   2793              void vQueueUnregisterQueue( QueueHandle_t xQueue )
   2794              {
   \                     vQueueUnregisterQueue: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2795                  UBaseType_t ux;
   2796          
   2797                  /* See if the handle of the queue being unregistered in actually in the
   2798                   * registry. */
   2799                  for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x....             LDR.N    R1,??DataTable16_1
   2800                  {
   2801                      if( xQueueRegistry[ ux ].xHandle == xQueue )
   \                     ??vQueueUnregisterQueue_0: (+1)
   \        0x6   0xEB01 0x02C3      ADD      R2,R1,R3, LSL #+3
   \        0xA   0x6854             LDR      R4,[R2, #+4]
   \        0xC   0x4284             CMP      R4,R0
   \        0xE   0xD003             BEQ.N    ??vQueueUnregisterQueue_1
   \       0x10   0x1C5B             ADDS     R3,R3,#+1
   \       0x12   0x2B0A             CMP      R3,#+10
   \       0x14   0xD3F7             BCC.N    ??vQueueUnregisterQueue_0
   \       0x16   0xBD10             POP      {R4,PC}
   2802                      {
   2803                          /* Set the name to NULL to show that this slot if free again. */
   2804                          xQueueRegistry[ ux ].pcQueueName = NULL;
   \                     ??vQueueUnregisterQueue_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF841 0x0033      STR      R0,[R1, R3, LSL #+3]
   2805          
   2806                          /* Set the handle to NULL to ensure the same queue handle cannot
   2807                           * appear in the registry twice if it is added, removed, then
   2808                           * added again. */
   2809                          xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
   \       0x1E   0x6050             STR      R0,[R2, #+4]
   2810                          break;
   2811                      }
   2812                      else
   2813                      {
   2814                          mtCOVERAGE_TEST_MARKER();
   2815                      }
   2816                  }
   2817              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   \       0x20   0xBD10             POP      {R4,PC}
   2818          
   2819          #endif /* configQUEUE_REGISTRY_SIZE */
   2820          /*-----------------------------------------------------------*/
   2821          
   2822          #if ( configUSE_TIMERS == 1 )
   2823          

   \                                 In section .text, align 2, keep-with-next
   2824              void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
   2825                                                   TickType_t xTicksToWait,
   2826                                                   const BaseType_t xWaitIndefinitely )
   2827              {
   \                     vQueueWaitForMessageRestricted: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   2828                  Queue_t * const pxQueue = xQueue;
   2829          
   2830                  /* This function should not be called by application code hence the
   2831                   * 'Restricted' in its name.  It is not part of the public API.  It is
   2832                   * designed for use by kernel code, and has special calling requirements.
   2833                   * It can result in vListInsert() being called on a list that can only
   2834                   * possibly ever have one item in it, so the list will be fast, but even
   2835                   * so it should be called with the scheduler locked and not from a critical
   2836                   * section. */
   2837          
   2838                  /* Only do anything if there are no messages in the queue.  This function
   2839                   *  will not actually cause the task to block, just place it on a blocked
   2840                   *  list.  It will not block until the scheduler is unlocked - at which
   2841                   *  time a yield will be performed.  If an item is added to the queue while
   2842                   *  the queue is locked, and the calling task blocks on the queue, then the
   2843                   *  calling task will be immediately unblocked when the queue is unlocked. */
   2844                  prvLockQueue( pxQueue );
   \        0x8   0x.... 0x....      BL       vPortEnterCritical
   \        0xC   0xF104 0x0738      ADD      R7,R4,#+56
   \       0x10   0xF997 0x100C      LDRSB    R1,[R7, #+12]
   \       0x14   0xF111 0x0F01      CMN      R1,#+1
   \       0x18   0xBF04             ITT      EQ
   \       0x1A   0x2000             MOVEQ    R0,#+0
   \       0x1C   0x7338             STRBEQ   R0,[R7, #+12]
   \       0x1E   0xF997 0x100D      LDRSB    R1,[R7, #+13]
   \       0x22   0xF111 0x0F01      CMN      R1,#+1
   \       0x26   0xBF04             ITT      EQ
   \       0x28   0x2000             MOVEQ    R0,#+0
   \       0x2A   0x7378             STRBEQ   R0,[R7, #+13]
   \       0x2C   0x.... 0x....      BL       vPortExitCritical
   2845          
   2846                  if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   \       0x30   0x6838             LDR      R0,[R7, #+0]
   \       0x32   0xB928             CBNZ.N   R0,??vQueueWaitForMessageRestricted_0
   2847                  {
   2848                      /* There is nothing in the queue, block for the specified period. */
   2849                      vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   \       0x34   0x4632             MOV      R2,R6
   \       0x36   0x4629             MOV      R1,R5
   \       0x38   0xF104 0x0024      ADD      R0,R4,#+36
   \       0x3C   0x.... 0x....      BL       vTaskPlaceOnEventListRestricted
   2850                  }
   2851                  else
   2852                  {
   2853                      mtCOVERAGE_TEST_MARKER();
   2854                  }
   2855          
   2856                  prvUnlockQueue( pxQueue );
   \                     ??vQueueWaitForMessageRestricted_0: (+1)
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x46   0x....             B.N      prvUnlockQueue
   2857              }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     xQueueRegistry

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x75 0x74          DC8 0x75, 0x74, 0x69, 0x6C, 0x5C, 0x74, 0x68, 0x69
   \              0x69 0x6C    
   \              0x5C 0x74    
   \              0x68 0x69
   \       0x50   0x72 0x64          DC8 0x72, 0x64, 0x5F, 0x70, 0x61, 0x72, 0x74, 0x79
   \              0x5F 0x70    
   \              0x61 0x72    
   \              0x74 0x79
   \       0x58   0x5C 0x66          DC8 0x5C, 0x66, 0x72, 0x65, 0x65, 0x72, 0x74, 0x6F
   \              0x72 0x65    
   \              0x65 0x72    
   \              0x74 0x6F
   \       0x60   0x73 0x5C          DC8 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C
   \              0x6B 0x65    
   \              0x72 0x6E    
   \              0x65 0x6C
   \       0x68   0x5C 0x71          DC8 0x5C, 0x71, 0x75, 0x65, 0x75, 0x65, 0x2E, 0x63
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x2E 0x63
   \       0x70   0x00               DC8 0
   \       0x71                      DS8 3
   2858          
   2859          #endif /* configUSE_TIMERS */
   2860          /*-----------------------------------------------------------*/
   2861          
   2862          #if ( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   2863          
   2864              QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
   2865              {
   2866                  QueueSetHandle_t pxQueue;
   2867          
   2868                  pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
   2869          
   2870                  return pxQueue;
   2871              }
   2872          
   2873          #endif /* configUSE_QUEUE_SETS */
   2874          /*-----------------------------------------------------------*/
   2875          
   2876          #if ( configUSE_QUEUE_SETS == 1 )
   2877          
   2878              BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
   2879                                         QueueSetHandle_t xQueueSet )
   2880              {
   2881                  BaseType_t xReturn;
   2882          
   2883                  taskENTER_CRITICAL();
   2884                  {
   2885                      if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
   2886                      {
   2887                          /* Cannot add a queue/semaphore to more than one queue set. */
   2888                          xReturn = pdFAIL;
   2889                      }
   2890                      else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2891                      {
   2892                          /* Cannot add a queue/semaphore to a queue set if there are already
   2893                           * items in the queue/semaphore. */
   2894                          xReturn = pdFAIL;
   2895                      }
   2896                      else
   2897                      {
   2898                          ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
   2899                          xReturn = pdPASS;
   2900                      }
   2901                  }
   2902                  taskEXIT_CRITICAL();
   2903          
   2904                  return xReturn;
   2905              }
   2906          
   2907          #endif /* configUSE_QUEUE_SETS */
   2908          /*-----------------------------------------------------------*/
   2909          
   2910          #if ( configUSE_QUEUE_SETS == 1 )
   2911          
   2912              BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,
   2913                                              QueueSetHandle_t xQueueSet )
   2914              {
   2915                  BaseType_t xReturn;
   2916                  Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
   2917          
   2918                  if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
   2919                  {
   2920                      /* The queue was not a member of the set. */
   2921                      xReturn = pdFAIL;
   2922                  }
   2923                  else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2924                  {
   2925                      /* It is dangerous to remove a queue from a set when the queue is
   2926                       * not empty because the queue set will still hold pending events for
   2927                       * the queue. */
   2928                      xReturn = pdFAIL;
   2929                  }
   2930                  else
   2931                  {
   2932                      taskENTER_CRITICAL();
   2933                      {
   2934                          /* The queue is no longer contained in the set. */
   2935                          pxQueueOrSemaphore->pxQueueSetContainer = NULL;
   2936                      }
   2937                      taskEXIT_CRITICAL();
   2938                      xReturn = pdPASS;
   2939                  }
   2940          
   2941                  return xReturn;
   2942              } /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
   2943          
   2944          #endif /* configUSE_QUEUE_SETS */
   2945          /*-----------------------------------------------------------*/
   2946          
   2947          #if ( configUSE_QUEUE_SETS == 1 )
   2948          
   2949              QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
   2950                                                          TickType_t const xTicksToWait )
   2951              {
   2952                  QueueSetMemberHandle_t xReturn = NULL;
   2953          
   2954                  ( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2955                  return xReturn;
   2956              }
   2957          
   2958          #endif /* configUSE_QUEUE_SETS */
   2959          /*-----------------------------------------------------------*/
   2960          
   2961          #if ( configUSE_QUEUE_SETS == 1 )
   2962          
   2963              QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
   2964              {
   2965                  QueueSetMemberHandle_t xReturn = NULL;
   2966          
   2967                  ( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2968                  return xReturn;
   2969              }
   2970          
   2971          #endif /* configUSE_QUEUE_SETS */
   2972          /*-----------------------------------------------------------*/
   2973          
   2974          #if ( configUSE_QUEUE_SETS == 1 )
   2975          
   2976              static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
   2977              {
   2978                  Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   2979                  BaseType_t xReturn = pdFALSE;
   2980          
   2981                  /* This function must be called form a critical section. */
   2982          
   2983                  configASSERT( pxQueueSetContainer );
   2984                  configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   2985          
   2986                  if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   2987                  {
   2988                      const int8_t cTxLock = pxQueueSetContainer->cTxLock;
   2989          
   2990                      traceQUEUE_SET_SEND( pxQueueSetContainer );
   2991          
   2992                      /* The data copied is the handle of the queue that contains data. */
   2993                      xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
   2994          
   2995                      if( cTxLock == queueUNLOCKED )
   2996                      {
   2997                          if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   2998                          {
   2999                              if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   3000                              {
   3001                                  /* The task waiting has a higher priority. */
   3002                                  xReturn = pdTRUE;
   3003                              }
   3004                              else
   3005                              {
   3006                                  mtCOVERAGE_TEST_MARKER();
   3007                              }
   3008                          }
   3009                          else
   3010                          {
   3011                              mtCOVERAGE_TEST_MARKER();
   3012                          }
   3013                      }
   3014                      else
   3015                      {
   3016                          configASSERT( cTxLock != queueINT8_MAX );
   3017          
   3018                          pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
   3019                      }
   3020                  }
   3021                  else
   3022                  {
   3023                      mtCOVERAGE_TEST_MARKER();
   3024                  }
   3025          
   3026                  return xReturn;
   3027              }
   3028          
   3029          #endif /* configUSE_QUEUE_SETS */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   pcQueueGetName
       8   prvCopyDataFromQueue
         0   -> __aeabi_memcpy
      24   prvCopyDataToQueue
        24   -> __aeabi_memcpy
        24   -> xTaskPriorityDisinherit
       0   prvInitialiseMutex
         0   -> xQueueGenericSend
      16   prvInitialiseNewQueue
        16   -> xQueueGenericReset
       8   prvIsQueueEmpty
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      24   prvUnlockQueue
        24   -> vPortEnterCritical
         0   -> vPortExitCritical
        24   -> vPortExitCritical
        24   -> vTaskMissedYield
        24   -> xTaskRemoveFromEventList
       0   ucQueueGetQueueType
       0   uxQueueGetQueueNumber
       8   uxQueueMessagesWaiting
         8   -> assertEFM
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   uxQueueMessagesWaitingFromISR
         8   -> assertEFM
      16   uxQueueSpacesAvailable
        16   -> assertEFM
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       8   vQueueAddToRegistry
       8   vQueueDelete
         8   -> assertEFM
         0   -> vPortFree
         8   -> vQueueUnregisterQueue
       0   vQueueSetQueueNumber
       8   vQueueUnregisterQueue
      24   vQueueWaitForMessageRestricted
         0   -> prvUnlockQueue
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskPlaceOnEventListRestricted
      16   xQueueCreateCountingSemaphore
        16   -> assertEFM
        16   -> xQueueGenericCreate
      24   xQueueCreateCountingSemaphoreStatic
        24   -> assertEFM
        24   -> xQueueGenericCreateStatic
       8   xQueueCreateMutex
         8   -> prvInitialiseMutex
         8   -> xQueueGenericCreate
      16   xQueueCreateMutexStatic
        16   -> prvInitialiseMutex
        16   -> xQueueGenericCreateStatic
      32   xQueueGenericCreate
        32   -> assertEFM
        32   -> prvInitialiseNewQueue
        32   -> pvPortMalloc
      32   xQueueGenericCreateStatic
        32   -> assertEFM
        32   -> prvInitialiseNewQueue
      16   xQueueGenericReset
        16   -> assertEFM
        16   -> vListInitialise
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
        16   -> xTaskRemoveFromEventList
      40   xQueueGenericSend
        40   -> assertEFM
        40   -> prvCopyDataToQueue
        40   -> prvUnlockQueue
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYield
        40   -> vTaskInternalSetTimeOutState
        40   -> vTaskPlaceOnEventList
        40   -> vTaskSuspendAll
        40   -> xTaskCheckForTimeOut
        40   -> xTaskGetSchedulerState
        40   -> xTaskRemoveFromEventList
        40   -> xTaskResumeAll
      32   xQueueGenericSendFromISR
        32   -> assertEFM
        32   -> prvCopyDataToQueue
        32   -> ulSetInterruptMask
        32   -> vClearInterruptMask
        32   -> xTaskRemoveFromEventList
       8   xQueueGetMutexHolder
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   xQueueGetMutexHolderFromISR
         8   -> assertEFM
      24   xQueueGiveFromISR
        24   -> assertEFM
        24   -> ulSetInterruptMask
        24   -> vClearInterruptMask
        24   -> xTaskRemoveFromEventList
       8   xQueueGiveMutexRecursive
         8   -> assertEFM
         8   -> xQueueGenericSend
         8   -> xTaskGetCurrentTaskHandle
       8   xQueueIsQueueEmptyFromISR
         8   -> assertEFM
       8   xQueueIsQueueFullFromISR
         8   -> assertEFM
      32   xQueuePeek
        32   -> assertEFM
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      24   xQueuePeekFromISR
        24   -> assertEFM
        24   -> prvCopyDataFromQueue
        24   -> ulSetInterruptMask
        24   -> vClearInterruptMask
      32   xQueueReceive
        32   -> assertEFM
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      32   xQueueReceiveFromISR
        32   -> assertEFM
        32   -> prvCopyDataFromQueue
        32   -> ulSetInterruptMask
        32   -> vClearInterruptMask
        32   -> xTaskRemoveFromEventList
      32   xQueueSemaphoreTake
        32   -> assertEFM
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> pvTaskIncrementMutexHeldCount
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskPriorityDisinheritAfterTimeout
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskPriorityInherit
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      16   xQueueTakeMutexRecursive
        16   -> assertEFM
        16   -> xQueueSemaphoreTake
        16   -> xTaskGetCurrentTaskHandle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       8  ?Subroutine0
      10  ?Subroutine1
      10  ?Subroutine10
      14  ?Subroutine11
       6  ?Subroutine12
       8  ?Subroutine13
      10  ?Subroutine14
      26  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       6  ?Subroutine7
       6  ?Subroutine8
       4  ?Subroutine9
     116  ?_0
      34  pcQueueGetName
      40  prvCopyDataFromQueue
     104  prvCopyDataToQueue
      18  prvInitialiseMutex
      32  prvInitialiseNewQueue
      22  prvIsQueueEmpty
     104  prvUnlockQueue
       6  ucQueueGetQueueType
       4  uxQueueGetQueueNumber
      20  uxQueueMessagesWaiting
      18  uxQueueMessagesWaitingFromISR
      32  uxQueueSpacesAvailable
      32  vQueueAddToRegistry
      38  vQueueDelete
       4  vQueueSetQueueNumber
      34  vQueueUnregisterQueue
      72  vQueueWaitForMessageRestricted
      48  xQueueCreateCountingSemaphore
      56  xQueueCreateCountingSemaphoreStatic
      22  xQueueCreateMutex
      26  xQueueCreateMutexStatic
     102  xQueueGenericCreate
     104  xQueueGenericCreateStatic
     106  xQueueGenericReset
     280  xQueueGenericSend
     156  xQueueGenericSendFromISR
      20  xQueueGetMutexHolder
      26  xQueueGetMutexHolderFromISR
     140  xQueueGiveFromISR
      52  xQueueGiveMutexRecursive
      24  xQueueIsQueueEmptyFromISR
      30  xQueueIsQueueFullFromISR
     242  xQueuePeek
      82  xQueuePeekFromISR
     210  xQueueReceive
     126  xQueueReceiveFromISR
      80  xQueueRegistry
     266  xQueueSemaphoreTake
      54  xQueueTakeMutexRecursive

 
    80 bytes in section .bss
   116 bytes in section .rodata
 2'926 bytes in section .text
 
 2'926 bytes of CODE  memory
   116 bytes of CONST memory
    80 bytes of DATA  memory

Errors: none
Warnings: none
