###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:19
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\tasks.c
#    Command line                 =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\tasks.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\tasks.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\kernel_15789286914859001271.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\tasks.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\kernel_15789286914859001271.dir\tasks.lst
#    Object file                  =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\tasks.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\tasks.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          
     14          /*
     15           * FreeRTOS Kernel V10.4.3
     16           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
     17           *
     18           * Permission is hereby granted, free of charge, to any person obtaining a copy of
     19           * this software and associated documentation files (the "Software"), to deal in
     20           * the Software without restriction, including without limitation the rights to
     21           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     22           * the Software, and to permit persons to whom the Software is furnished to do so,
     23           * subject to the following conditions:
     24           *
     25           * The above copyright notice and this permission notice shall be included in all
     26           * copies or substantial portions of the Software.
     27           *
     28           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     29           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     30           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     31           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     32           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     33           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     34           *
     35           * https://www.FreeRTOS.org
     36           * https://github.com/FreeRTOS
     37           *
     38           */
     39          
     40          /* Standard includes. */
     41          #include <stdlib.h>
     42          #include <string.h>
     43          
     44          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     45           * all the API functions to use the MPU wrappers.  That should only be done when
     46           * task.h is included from an application file. */
     47          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     48          
     49          /* FreeRTOS includes. */
     50          #include "FreeRTOS.h"
     51          #include "task.h"
     52          #include "timers.h"
     53          #include "stack_macros.h"
     54          
     55          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
     56           * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     57           * for the header files above, but not in this file, in order to generate the
     58           * correct privileged Vs unprivileged linkage and placement. */
     59          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     60          
     61          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     62           * functions but without including stdio.h here. */
     63          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     64          
     65          /* At the bottom of this file are two optional functions that can be used
     66           * to generate human readable text from the raw data generated by the
     67           * uxTaskGetSystemState() function.  Note the formatting functions are provided
     68           * for convenience only, and are NOT considered part of the kernel. */
     69              #include <stdio.h>
     70          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
     71          
     72          #if ( configUSE_PREEMPTION == 0 )
     73          
     74          /* If the cooperative scheduler is being used then a yield should not be
     75           * performed just because a higher priority task has been woken. */
     76              #define taskYIELD_IF_USING_PREEMPTION()
     77          #else
     78              #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
     79          #endif
     80          
     81          /* Values that can be assigned to the ucNotifyState member of the TCB. */
     82          #define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the initialised value. */
     83          #define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
     84          #define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
     85          
     86          /*
     87           * The value used to fill the stack of a task when the task is created.  This
     88           * is used purely for checking the high water mark for tasks.
     89           */
     90          #define tskSTACK_FILL_BYTE                        ( 0xa5U )
     91          
     92          /* Bits used to recored how a task's stack and TCB were allocated. */
     93          #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
     94          #define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
     95          #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )
     96          
     97          /* If any of the following are set then task stacks are filled with a known
     98           * value so the high water mark can be determined.  If none of the following are
     99           * set then don't fill the stack so there is no unnecessary dependency on memset. */
    100          #if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
    101              #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
    102          #else
    103              #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
    104          #endif
    105          
    106          /*
    107           * Macros used by vListTask to indicate which state a task is in.
    108           */
    109          #define tskRUNNING_CHAR      ( 'X' )
    110          #define tskBLOCKED_CHAR      ( 'B' )
    111          #define tskREADY_CHAR        ( 'R' )
    112          #define tskDELETED_CHAR      ( 'D' )
    113          #define tskSUSPENDED_CHAR    ( 'S' )
    114          
    115          /*
    116           * Some kernel aware debuggers require the data the debugger needs access to be
    117           * global, rather than file scope.
    118           */
    119          #ifdef portREMOVE_STATIC_QUALIFIER
    120              #define static
    121          #endif
    122          
    123          /* The name allocated to the Idle task.  This can be overridden by defining
    124           * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
    125          #ifndef configIDLE_TASK_NAME
    126              #define configIDLE_TASK_NAME    "IDLE"
    127          #endif
    128          
    129          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    130          
    131          /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    132           * performed in a generic way that is not optimised to any particular
    133           * microcontroller architecture. */
    134          
    135          /* uxTopReadyPriority holds the priority of the highest priority ready
    136           * state task. */
    137              #define taskRECORD_READY_PRIORITY( uxPriority ) \
    138              {                                               \
    139                  if( ( uxPriority ) > uxTopReadyPriority )   \
    140                  {                                           \
    141                      uxTopReadyPriority = ( uxPriority );    \
    142                  }                                           \
    143              } /* taskRECORD_READY_PRIORITY */
    144          
    145          /*-----------------------------------------------------------*/
    146          
    147              #define taskSELECT_HIGHEST_PRIORITY_TASK()                                \
    148              {                                                                         \
    149                  UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
    150                                                                                        \
    151                  /* Find the highest priority queue that contains ready tasks. */      \
    152                  while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
    153                  {                                                                     \
    154                      configASSERT( uxTopPriority );                                    \
    155                      --uxTopPriority;                                                  \
    156                  }                                                                     \
    157                                                                                        \
    158                  /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
    159                   * the  same priority get an equal share of the processor time. */                    \
    160                  listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
    161                  uxTopReadyPriority = uxTopPriority;                                                   \
    162              } /* taskSELECT_HIGHEST_PRIORITY_TASK */
    163          
    164          /*-----------------------------------------------------------*/
    165          
    166          /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    167           * they are only required when a port optimised method of task selection is
    168           * being used. */
    169              #define taskRESET_READY_PRIORITY( uxPriority )
    170              #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    171          
    172          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    173          
    174          /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    175           * performed in a way that is tailored to the particular microcontroller
    176           * architecture being used. */
    177          
    178          /* A port optimised version is provided.  Call the port defined macros. */
    179              #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    180          
    181          /*-----------------------------------------------------------*/
    182          
    183              #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
    184              {                                                                                           \
    185                  UBaseType_t uxTopPriority;                                                              \
    186                                                                                                          \
    187                  /* Find the highest priority list that contains ready tasks. */                         \
    188                  portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
    189                  configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
    190                  listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
    191              } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    192          
    193          /*-----------------------------------------------------------*/
    194          
    195          /* A port optimised version is provided, call it only if the TCB being reset
    196           * is being referenced from a ready list.  If it is referenced from a delayed
    197           * or suspended list then it won't be in a ready list. */
    198              #define taskRESET_READY_PRIORITY( uxPriority )                                                     \
    199              {                                                                                                  \
    200                  if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 ) \
    201                  {                                                                                              \
    202                      portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                        \
    203                  }                                                                                              \
    204              }
    205          
    206          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    207          
    208          /*-----------------------------------------------------------*/
    209          
    210          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    211           * count overflows. */
    212          #define taskSWITCH_DELAYED_LISTS()                                                \
    213              {                                                                             \
    214                  List_t * pxTemp;                                                          \
    215                                                                                            \
    216                  /* The delayed tasks list should be empty when the lists are switched. */ \
    217                  configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
    218                                                                                            \
    219                  pxTemp = pxDelayedTaskList;                                               \
    220                  pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
    221                  pxOverflowDelayedTaskList = pxTemp;                                       \
    222                  xNumOfOverflows++;                                                        \
    223                  prvResetNextTaskUnblockTime();                                            \
    224              }
    225          
    226          /*-----------------------------------------------------------*/
    227          
    228          /*
    229           * Place the task represented by pxTCB into the appropriate ready list for
    230           * the task.  It is inserted at the end of the list.
    231           */
    232          #define prvAddTaskToReadyList( pxTCB )                                                                 \
    233              traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \
    234              taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                                \
    235              vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
    236              tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
    237          /*-----------------------------------------------------------*/
    238          
    239          /*
    240           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    241           * where NULL is used to indicate that the handle of the currently executing
    242           * task should be used in place of the parameter.  This macro simply checks to
    243           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    244           */
    245          #define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
    246          
    247          /* The item value of the event list item is normally used to hold the priority
    248           * of the task to which it belongs (coded to allow it to be held in reverse
    249           * priority order).  However, it is occasionally borrowed for other purposes.  It
    250           * is important its value is not updated due to a task priority change while it is
    251           * being used for another purpose.  The following bit definition is used to inform
    252           * the scheduler that the value should not be changed - in which case it is the
    253           * responsibility of whichever module is using the value to ensure it gets set back
    254           * to its original value when it is released. */
    255          #if ( configUSE_16_BIT_TICKS == 1 )
    256              #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
    257          #else
    258              #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
    259          #endif
    260          
    261          /*
    262           * Task control block.  A task control block (TCB) is allocated for each task,
    263           * and stores task state information, including a pointer to the task's context
    264           * (the task's run time environment, including register values)
    265           */
    266          typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
    267          {
    268              volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    269          
    270              #if ( portUSING_MPU_WRAPPERS == 1 )
    271                  xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    272              #endif
    273          
    274              ListItem_t xStateListItem;                  /*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    275              ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
    276              UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest priority. */
    277              StackType_t * pxStack;                      /*< Points to the start of the stack. */
    278              char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    279          
    280              #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
    281                  StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
    282              #endif
    283          
    284              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
    285                  UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    286              #endif
    287          
    288              #if ( configUSE_TRACE_FACILITY == 1 )
    289                  UBaseType_t uxTCBNumber;  /*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    290                  UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace code. */
    291              #endif
    292          
    293              #if ( configUSE_MUTEXES == 1 )
    294                  UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    295                  UBaseType_t uxMutexesHeld;
    296              #endif
    297          
    298              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
    299                  TaskHookFunction_t pxTaskTag;
    300              #endif
    301          
    302              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
    303                  void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    304              #endif
    305          
    306              #if ( configGENERATE_RUN_TIME_STATS == 1 )
    307                  uint32_t ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running state. */
    308              #endif
    309          
    310              #if ( configUSE_NEWLIB_REENTRANT == 1 )
    311          
    312                  /* Allocate a Newlib reent structure that is specific to this task.
    313                   * Note Newlib support has been included by popular demand, but is not
    314                   * used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    315                   * responsible for resulting newlib operation.  User must be familiar with
    316                   * newlib and must provide system-wide implementations of the necessary
    317                   * stubs. Be warned that (at the time of writing) the current newlib design
    318                   * implements a system-wide malloc() that must be provided with locks.
    319                   *
    320                   * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
    321                   * for additional information. */
    322                  struct  _reent xNewLib_reent;
    323              #endif
    324          
    325              #if ( configUSE_TASK_NOTIFICATIONS == 1 )
    326                  volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    327                  volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    328              #endif
    329          
    330              /* See the comments in FreeRTOS.h with the definition of
    331               * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    332              #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
    333                  uint8_t ucStaticallyAllocated;                     /*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    334              #endif
    335          
    336              #if ( INCLUDE_xTaskAbortDelay == 1 )
    337                  uint8_t ucDelayAborted;
    338              #endif
    339          
    340              #if ( configUSE_POSIX_ERRNO == 1 )
    341                  int iTaskErrno;
    342              #endif
    343          } tskTCB;
    344          
    345          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    346           * below to enable the use of older kernel aware debuggers. */
    347          typedef tskTCB TCB_t;
    348          
    349          /*lint -save -e956 A manual analysis and inspection has been used to determine
    350           * which static variables must be declared volatile. */
    351          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    352          
    353          /* Lists for ready and blocked tasks. --------------------
    354           * xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
    355           * doing so breaks some kernel aware debuggers and debuggers that rely on removing
    356           * the static qualifier. */

   \                                 In section .bss, align 4
    357          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready tasks. */
   \                     pxReadyTasksLists:
   \        0x0                      DS8 1'120
    358          PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /*< Delayed tasks. */
    359          PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    360          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /*< Points to the delayed task list currently being used. */
    361          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    362          PRIVILEGED_DATA static List_t xPendingReadyList;                         /*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    363          
    364          #if ( INCLUDE_vTaskDelete == 1 )
    365          
    366              PRIVILEGED_DATA static List_t xTasksWaitingTermination; /*< Tasks that have been deleted - but their memory not yet freed. */
    367              PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
    368          
    369          #endif
    370          
    371          #if ( INCLUDE_vTaskSuspend == 1 )
    372          
    373              PRIVILEGED_DATA static List_t xSuspendedTaskList; /*< Tasks that are currently suspended. */
    374          
    375          #endif
    376          
    377          /* Global POSIX errno. Its value is changed upon context switching to match
    378           * the errno of the currently running task. */
    379          #if ( configUSE_POSIX_ERRNO == 1 )
    380              int FreeRTOS_errno = 0;
    381          #endif
    382          
    383          /* Other file private variables. --------------------------------*/
    384          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
    385          PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    386          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
    387          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
    388          PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
    389          PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
    390          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
    391          PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
    392          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */

   \                                 In section .bss, align 4
   \        0x0                      DS8 4

   \                                 In section .data, align 4
   \                     xPendingReadyList:
   \        0x0                      DS8 4
   \        0x4   0x0000'0000        DC32 0x0
   \        0x8                      DS8 4
   \        0xC   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0x14                      DS8 0
   \       0x14                      DS8 4
   \       0x18   0x0000'0000        DC32 0x0
   \       0x1C                      DS8 4
   \       0x20   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0x28                      DS8 0
   \                     pxCurrentTCB:
   \       0x28   0x0000'0000        DC32 0x0
   \       0x2C   0x0000'0000        DC32 0x0
   \       0x30                      DS8 0
   \       0x30   0x0000'0000        DC32 0x0
   \       0x34                      DS8 0
   \       0x34   0x0000'0000        DC32 0
   \       0x38                      DS8 4
   \       0x3C   0x0000'0000        DC32 0x0
   \       0x40                      DS8 4
   \       0x44   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0x4C                      DS8 0
   \       0x4C   0x0000'0000        DC32 0
   \       0x50   0x0000'0000        DC32 0
   \       0x54   0x0000'0000        DC32 0
   \       0x58   0x0000'0000        DC32 0
   \       0x5C   0x0000'0000        DC32 0
   \       0x60   0x0000'0000        DC32 0
   \       0x64   0x0000'0000        DC32 0
   \       0x68   0x0000'0000        DC32 0
   \       0x6C   0x0000'0000        DC32 0
    393          PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          /*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    394          
    395          /* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
    396           * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
    397           * to determine the number of priority lists to read back from the remote target. */
    398          const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;
   \                     uxTopUsedPriority:
   \       0x70   0x0000'0037        DC32 55
   \       0x74   0x0000'0000        DC32 0
   \       0x78                      DS8 4
   \       0x7C   0x0000'0000        DC32 0x0
   \       0x80                      DS8 4
   \       0x84   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0x8C                      DS8 0
   \       0x8C                      DS8 4
   \       0x90   0x0000'0000        DC32 0x0
   \       0x94                      DS8 4
   \       0x98   0x0000'0000        DC32 0x0, 0x0
   \              0x0000'0000
   \       0xA0                      DS8 0
    399          
    400          /* Context switches are held pending while the scheduler is suspended.  Also,
    401           * interrupts must not manipulate the xStateListItem of a TCB, or any of the
    402           * lists the xStateListItem can be referenced from, if the scheduler is suspended.
    403           * If an interrupt needs to unblock a task while the scheduler is suspended then it
    404           * moves the task's event list item into the xPendingReadyList, ready for the
    405           * kernel to move the task from the pending ready list into the real ready list
    406           * when the scheduler is unsuspended.  The pending ready list itself can only be
    407           * accessed from a critical section. */
    408          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;
    409          
    410          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    411          
    412          /* Do not move these variables to function scope as doing so prevents the
    413           * code working with debuggers that need to remove the static qualifier. */
    414              PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;    /*< Holds the value of a timer/counter the last time a task was switched in. */
    415              PRIVILEGED_DATA static volatile uint32_t ulTotalRunTime = 0UL; /*< Holds the total amount of execution time as defined by the run time counter clock. */
    416          
    417          #endif
    418          
    419          /*lint -restore */
    420          
    421          /*-----------------------------------------------------------*/
    422          
    423          /* File private functions. --------------------------------*/
    424          
    425          /**
    426           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    427           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    428           * is in any other state.
    429           */
    430          #if ( INCLUDE_vTaskSuspend == 1 )
    431          
    432              static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    433          
    434          #endif /* INCLUDE_vTaskSuspend */
    435          
    436          /*
    437           * Utility to ready all the lists used by the scheduler.  This is called
    438           * automatically upon the creation of the first task.
    439           */
    440          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    441          
    442          /*
    443           * The idle task, which as all tasks is implemented as a never ending loop.
    444           * The idle task is automatically created and added to the ready lists upon
    445           * creation of the first user task.
    446           *
    447           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    448           * language extensions.  The equivalent prototype for this function is:
    449           *
    450           * void prvIdleTask( void *pvParameters );
    451           *
    452           */
    453          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
    454          
    455          /*
    456           * Utility to free all memory allocated by the scheduler to hold a TCB,
    457           * including the stack pointed to by the TCB.
    458           *
    459           * This does not free memory allocated by the task itself (i.e. memory
    460           * allocated by calls to pvPortMalloc from within the tasks application code).
    461           */
    462          #if ( INCLUDE_vTaskDelete == 1 )
    463          
    464              static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
    465          
    466          #endif
    467          
    468          /*
    469           * Used only by the idle task.  This checks to see if anything has been placed
    470           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    471           * and its TCB deleted.
    472           */
    473          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    474          
    475          /*
    476           * The currently executing task is entering the Blocked state.  Add the task to
    477           * either the current or the overflow delayed task list.
    478           */
    479          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
    480                                                      const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
    481          
    482          /*
    483           * Fills an TaskStatus_t structure with information on each task that is
    484           * referenced from the pxList list (which may be a ready list, a delayed list,
    485           * a suspended list, etc.).
    486           *
    487           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    488           * NORMAL APPLICATION CODE.
    489           */
    490          #if ( configUSE_TRACE_FACILITY == 1 )
    491          
    492              static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
    493                                                               List_t * pxList,
    494                                                               eTaskState eState ) PRIVILEGED_FUNCTION;
    495          
    496          #endif
    497          
    498          /*
    499           * Searches pxList for a task with name pcNameToQuery - returning a handle to
    500           * the task if it is found, or NULL if the task is not found.
    501           */
    502          #if ( INCLUDE_xTaskGetHandle == 1 )
    503          
    504              static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
    505                                                               const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
    506          
    507          #endif
    508          
    509          /*
    510           * When a task is created, the stack of the task is filled with a known value.
    511           * This function determines the 'high water mark' of the task stack by
    512           * determining how much of the stack remains at the original preset value.
    513           */
    514          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
    515          
    516              static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    517          
    518          #endif
    519          
    520          /*
    521           * Return the amount of time, in ticks, that will pass before the kernel will
    522           * next move a task from the Blocked state to the Running state.
    523           *
    524           * This conditional compilation should use inequality to 0, not equality to 1.
    525           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    526           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    527           * set to a value other than 1.
    528           */
    529          #if ( configUSE_TICKLESS_IDLE != 0 )
    530          
    531              static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    532          
    533          #endif
    534          
    535          /*
    536           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    537           * will exit the Blocked state.
    538           */
    539          static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;
    540          
    541          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    542          
    543          /*
    544           * Helper function used to pad task names with spaces when printing out
    545           * human readable tables of task information.
    546           */
    547              static char * prvWriteNameToBuffer( char * pcBuffer,
    548                                                  const char * pcTaskName ) PRIVILEGED_FUNCTION;
    549          
    550          #endif
    551          
    552          /*
    553           * Called after a Task_t structure has been allocated either statically or
    554           * dynamically to fill in the structure's members.
    555           */
    556          static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
    557                                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    558                                            const uint32_t ulStackDepth,
    559                                            void * const pvParameters,
    560                                            UBaseType_t uxPriority,
    561                                            TaskHandle_t * const pxCreatedTask,
    562                                            TCB_t * pxNewTCB,
    563                                            const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
    564          
    565          /*
    566           * Called after a new task has been created and initialised to place the task
    567           * under the control of the scheduler.
    568           */
    569          static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;
    570          
    571          /*
    572           * freertos_tasks_c_additions_init() should only be called if the user definable
    573           * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
    574           * called by the function.
    575           */
    576          #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
    577          
    578              static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
    579          
    580          #endif
    581          
    582          /*-----------------------------------------------------------*/
    583          
    584          #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    585          

   \                                 In section .text, align 2, keep-with-next
    586              TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
    587                                              const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    588                                              const uint32_t ulStackDepth,
    589                                              void * const pvParameters,
    590                                              UBaseType_t uxPriority,
    591                                              StackType_t * const puxStackBuffer,
    592                                              StaticTask_t * const pxTaskBuffer )
    593              {
   \                     xTaskCreateStatic: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x9C0F             LDR      R4,[SP, #+60]
   \        0x8   0x4606             MOV      R6,R0
   \        0xA   0x460F             MOV      R7,R1
   \        0xC   0x4690             MOV      R8,R2
   \        0xE   0x4699             MOV      R9,R3
    594                  TCB_t * pxNewTCB;
    595                  TaskHandle_t xReturn;
    596          
    597                  configASSERT( puxStackBuffer != NULL );
   \       0x10   0x.... 0x....      LDR.W    R10,??DataTable37
   \       0x14   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_6
   \       0x16   0xF240 0x2155      MOVW     R1,#+597
   \       0x1A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x1E   0x9D10             LDR      R5,[SP, #+64]
    598                  configASSERT( pxTaskBuffer != NULL );
   \       0x20   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_5
   \       0x22   0xF240 0x2156      MOVW     R1,#+598
   \       0x26   0x.... 0x....      BL       ?Subroutine3
    599          
    600                  #if ( configASSERT_DEFINED == 1 )
    601                      {
    602                          /* Sanity check that the size of the structure used to declare a
    603                           * variable of type StaticTask_t equals the size of the real task
    604                           * structure. */
    605                          volatile size_t xSize = sizeof( StaticTask_t );
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x2A   0x2060             MOVS     R0,#+96
   \       0x2C   0x9000             STR      R0,[SP, #+0]
    606                          configASSERT( xSize == sizeof( TCB_t ) );
   \       0x2E   0x9900             LDR      R1,[SP, #+0]
   \       0x30   0x2960             CMP      R1,#+96
   \       0x32   0xD003             BEQ.N    ??CrossCallReturnLabel_4
   \       0x34   0xF240 0x215E      MOVW     R1,#+606
   \       0x38   0x.... 0x....      BL       ?Subroutine3
    607                          ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
    608                      }
    609                  #endif /* configASSERT_DEFINED */
    610          
    611                  if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
   \       0x3E   0x2D00             CMP      R5,#+0
   \       0x40   0xBF18             IT       NE
   \       0x42   0x2C00             CMPNE    R4,#+0
   \       0x44   0xD014             BEQ.N    ??xTaskCreateStatic_0
    612                  {
    613                      /* The memory used for the task's TCB and stack are passed into this
    614                       * function - use them. */
    615                      pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    616                      pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
   \       0x46   0x632C             STR      R4,[R5, #+48]
   \       0x48   0x4639             MOV      R1,R7
   \       0x4A   0x4630             MOV      R0,R6
    617          
    618                      #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
    619                          {
    620                              /* Tasks can be created statically or dynamically, so note this
    621                               * task was created statically in case the task is later deleted. */
    622                              pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
   \       0x4C   0x2402             MOVS     R4,#+2
   \       0x4E   0xF885 0x405D      STRB     R4,[R5, #+93]
    623                          }
    624                      #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
    625          
    626                      prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
   \       0x52   0x9C0E             LDR      R4,[SP, #+56]
   \       0x54   0x2700             MOVS     R7,#+0
   \       0x56   0xAE04             ADD      R6,SP,#+16
   \       0x58   0x464B             MOV      R3,R9
   \       0x5A   0x4642             MOV      R2,R8
   \       0x5C   0x9703             STR      R7,[SP, #+12]
   \       0x5E   0x9502             STR      R5,[SP, #+8]
   \       0x60   0x9601             STR      R6,[SP, #+4]
   \       0x62   0x9400             STR      R4,[SP, #+0]
   \       0x64   0x.... 0x....      BL       prvInitialiseNewTask
    627                      prvAddNewTaskToReadyList( pxNewTCB );
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x.... 0x....      BL       prvAddNewTaskToReadyList
   \       0x6E   0xE001             B.N      ??xTaskCreateStatic_1
    628                  }
    629                  else
    630                  {
    631                      xReturn = NULL;
   \                     ??xTaskCreateStatic_0: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x9004             STR      R0,[SP, #+16]
    632                  }
    633          
    634                  return xReturn;
   \                     ??xTaskCreateStatic_1: (+1)
   \       0x74   0x9804             LDR      R0,[SP, #+16]
   \       0x76   0xB006             ADD      SP,SP,#+24
   \       0x78   0xE8BD 0x87F0      POP      {R4-R10,PC}
    635              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4650             MOV      R0,R10
   \        0x2   0x.... 0x....      B.W      assertEFM
    636          
    637          #endif /* SUPPORT_STATIC_ALLOCATION */
    638          /*-----------------------------------------------------------*/
    639          
    640          #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    641          
    642              BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
    643                                                      TaskHandle_t * pxCreatedTask )
    644              {
    645                  TCB_t * pxNewTCB;
    646                  BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    647          
    648                  configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
    649                  configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
    650          
    651                  if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
    652                  {
    653                      /* Allocate space for the TCB.  Where the memory comes from depends
    654                       * on the implementation of the port malloc function and whether or
    655                       * not static allocation is being used. */
    656                      pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
    657          
    658                      /* Store the stack location in the TCB. */
    659                      pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    660          
    661                      #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    662                          {
    663                              /* Tasks can be created statically or dynamically, so note this
    664                               * task was created statically in case the task is later deleted. */
    665                              pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    666                          }
    667                      #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
    668          
    669                      prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
    670                                            pxTaskDefinition->pcName,
    671                                            ( uint32_t ) pxTaskDefinition->usStackDepth,
    672                                            pxTaskDefinition->pvParameters,
    673                                            pxTaskDefinition->uxPriority,
    674                                            pxCreatedTask, pxNewTCB,
    675                                            pxTaskDefinition->xRegions );
    676          
    677                      prvAddNewTaskToReadyList( pxNewTCB );
    678                      xReturn = pdPASS;
    679                  }
    680          
    681                  return xReturn;
    682              }
    683          
    684          #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    685          /*-----------------------------------------------------------*/
    686          
    687          #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    688          
    689              BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
    690                                                TaskHandle_t * pxCreatedTask )
    691              {
    692                  TCB_t * pxNewTCB;
    693                  BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    694          
    695                  configASSERT( pxTaskDefinition->puxStackBuffer );
    696          
    697                  if( pxTaskDefinition->puxStackBuffer != NULL )
    698                  {
    699                      /* Allocate space for the TCB.  Where the memory comes from depends
    700                       * on the implementation of the port malloc function and whether or
    701                       * not static allocation is being used. */
    702                      pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    703          
    704                      if( pxNewTCB != NULL )
    705                      {
    706                          /* Store the stack location in the TCB. */
    707                          pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    708          
    709                          #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    710                              {
    711                                  /* Tasks can be created statically or dynamically, so note
    712                                   * this task had a statically allocated stack in case it is
    713                                   * later deleted.  The TCB was allocated dynamically. */
    714                                  pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
    715                              }
    716                          #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
    717          
    718                          prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
    719                                                pxTaskDefinition->pcName,
    720                                                ( uint32_t ) pxTaskDefinition->usStackDepth,
    721                                                pxTaskDefinition->pvParameters,
    722                                                pxTaskDefinition->uxPriority,
    723                                                pxCreatedTask, pxNewTCB,
    724                                                pxTaskDefinition->xRegions );
    725          
    726                          prvAddNewTaskToReadyList( pxNewTCB );
    727                          xReturn = pdPASS;
    728                      }
    729                  }
    730          
    731                  return xReturn;
    732              }
    733          
    734          #endif /* portUSING_MPU_WRAPPERS */
    735          /*-----------------------------------------------------------*/
    736          
    737          #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    738          

   \                                 In section .text, align 2, keep-with-next
    739              BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
    740                                      const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    741                                      const configSTACK_DEPTH_TYPE usStackDepth,
    742                                      void * const pvParameters,
    743                                      UBaseType_t uxPriority,
    744                                      TaskHandle_t * const pxCreatedTask )
    745              {
   \                     xTaskCreate: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0xB084             SUB      SP,SP,#+16
   \        0xA   0x4688             MOV      R8,R1
   \        0xC   0x4699             MOV      R9,R3
    746                  TCB_t * pxNewTCB;
    747                  BaseType_t xReturn;
    748          
    749                  /* If the stack grows down then allocate the stack then the TCB so the stack
    750                   * does not grow into the TCB.  Likewise if the stack grows up then allocate
    751                   * the TCB then the stack. */
    752                  #if ( portSTACK_GROWTH > 0 )
    753                      {
    754                          /* Allocate space for the TCB.  Where the memory comes from depends on
    755                           * the implementation of the port malloc function and whether or not static
    756                           * allocation is being used. */
    757                          pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    758          
    759                          if( pxNewTCB != NULL )
    760                          {
    761                              /* Allocate space for the stack used by the task being created.
    762                               * The base of the stack memory stored in the TCB so the task can
    763                               * be deleted later if required. */
    764                              pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    765          
    766                              if( pxNewTCB->pxStack == NULL )
    767                              {
    768                                  /* Could not allocate the stack.  Delete the allocated TCB. */
    769                                  vPortFree( pxNewTCB );
    770                                  pxNewTCB = NULL;
    771                              }
    772                          }
    773                      }
    774                  #else /* portSTACK_GROWTH */
    775                      {
    776                          StackType_t * pxStack;
    777          
    778                          /* Allocate space for the stack used by the task being created. */
    779                          pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
   \        0xE   0x00B8             LSLS     R0,R7,#+2
   \       0x10   0x.... 0x....      BL       pvPortMalloc
   \       0x14   0x0004             MOVS     R4,R0
    780          
    781                          if( pxStack != NULL )
   \       0x16   0xD01C             BEQ.N    ??xTaskCreate_0
    782                          {
    783                              /* Allocate space for the TCB. */
    784                              pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
   \       0x18   0x2060             MOVS     R0,#+96
   \       0x1A   0x.... 0x....      BL       pvPortMalloc
   \       0x1E   0x0005             MOVS     R5,R0
    785          
    786                              if( pxNewTCB != NULL )
   \       0x20   0xD014             BEQ.N    ??xTaskCreate_1
    787                              {
    788                                  /* Store the stack location in the TCB. */
    789                                  pxNewTCB->pxStack = pxStack;
    790                              }
    791                              else
    792                              {
    793                                  /* The stack cannot be used as the TCB was not created.  Free
    794                                   * it again. */
    795                                  vPortFree( pxStack );
    796                              }
    797                          }
    798                          else
    799                          {
    800                              pxNewTCB = NULL;
    801                          }
    802                      }
    803                  #endif /* portSTACK_GROWTH */
    804          
    805                  if( pxNewTCB != NULL )
    806                  {
    807                      #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
    808                          {
    809                              /* Tasks can be created statically or dynamically, so note this
    810                               * task was created dynamically in case it is later deleted. */
    811                              pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x632C             STR      R4,[R5, #+48]
   \       0x26   0xF885 0x105D      STRB     R1,[R5, #+93]
    812                          }
    813                      #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
    814          
    815                      prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   \       0x2A   0x9103             STR      R1,[SP, #+12]
   \       0x2C   0x990D             LDR      R1,[SP, #+52]
   \       0x2E   0x980C             LDR      R0,[SP, #+48]
   \       0x30   0x9101             STR      R1,[SP, #+4]
   \       0x32   0x9502             STR      R5,[SP, #+8]
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x464B             MOV      R3,R9
   \       0x38   0x463A             MOV      R2,R7
   \       0x3A   0x4641             MOV      R1,R8
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x.... 0x....      BL       prvInitialiseNewTask
    816                      prvAddNewTaskToReadyList( pxNewTCB );
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x.... 0x....      BL       prvAddNewTaskToReadyList
    817                      xReturn = pdPASS;
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE004             B.N      ??xTaskCreate_2
    818                  }
   \                     ??xTaskCreate_1: (+1)
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x.... 0x....      BL       vPortFree
    819                  else
    820                  {
    821                      xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   \                     ??xTaskCreate_0: (+1)
   \       0x52   0xF04F 0x30FF      MOV      R0,#+4294967295
    822                  }
    823          
    824                  return xReturn;
   \                     ??xTaskCreate_2: (+1)
   \       0x56   0xB005             ADD      SP,SP,#+20
   \       0x58   0xE8BD 0x83F0      POP      {R4-R9,PC}
    825              }
    826          
    827          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    828          /*-----------------------------------------------------------*/
    829          

   \                                 In section .text, align 2, keep-with-next
    830          static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
    831                                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    832                                            const uint32_t ulStackDepth,
    833                                            void * const pvParameters,
    834                                            UBaseType_t uxPriority,
    835                                            TaskHandle_t * const pxCreatedTask,
    836                                            TCB_t * pxNewTCB,
    837                                            const MemoryRegion_t * const xRegions )
    838          {
   \                     prvInitialiseNewTask: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x9E0A             LDR      R6,[SP, #+40]
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460C             MOV      R4,R1
    839              StackType_t * pxTopOfStack;
    840              UBaseType_t x;
    841          
    842              #if ( portUSING_MPU_WRAPPERS == 1 )
    843                  /* Should the task be created in privileged mode? */
    844                  BaseType_t xRunPrivileged;
    845          
    846                  if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    847                  {
    848                      xRunPrivileged = pdTRUE;
    849                  }
    850                  else
    851                  {
    852                      xRunPrivileged = pdFALSE;
    853                  }
    854                  uxPriority &= ~portPRIVILEGE_BIT;
    855              #endif /* portUSING_MPU_WRAPPERS == 1 */
    856          
    857              /* Avoid dependency on memset() if it is not required. */
    858              #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    859                  {
    860                      /* Fill the stack with a known value to assist debugging. */
    861                      ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   \        0xA   0x6B30             LDR      R0,[R6, #+48]
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0x4699             MOV      R9,R3
   \       0x10   0x22A5             MOVS     R2,#+165
   \       0x12   0x00B9             LSLS     R1,R7,#+2
   \       0x14   0x.... 0x....      BL       __aeabi_memset4
    862                  }
    863              #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
    864          
    865              /* Calculate the top of stack address.  This depends on whether the stack
    866               * grows from high memory to low (as per the 80x86) or vice versa.
    867               * portSTACK_GROWTH is used to make the result positive or negative as required
    868               * by the port. */
    869              #if ( portSTACK_GROWTH < 0 )
    870                  {
    871                      pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    872                      pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
   \       0x18   0x6B31             LDR      R1,[R6, #+48]
   \       0x1A   0xEB01 0x0287      ADD      R2,R1,R7, LSL #+2
   \       0x1E   0x1F17             SUBS     R7,R2,#+4
   \       0x20   0x08FF             LSRS     R7,R7,#+3
   \       0x22   0x00FF             LSLS     R7,R7,#+3
    873          
    874                      /* Check the alignment of the calculated top of stack is correct. */
    875                      configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    876          
    877                      #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
    878                          {
    879                              /* Also record the stack's high address, which may assist
    880                               * debugging. */
    881                              pxNewTCB->pxEndOfStack = pxTopOfStack;
    882                          }
    883                      #endif /* configRECORD_STACK_HIGH_ADDRESS */
    884                  }
    885              #else /* portSTACK_GROWTH */
    886                  {
    887                      pxTopOfStack = pxNewTCB->pxStack;
    888          
    889                      /* Check the alignment of the stack buffer is correct. */
    890                      configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    891          
    892                      /* The other extreme of the stack space is required if stack checking is
    893                       * performed. */
    894                      pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    895                  }
    896              #endif /* portSTACK_GROWTH */
    897          
    898              /* Store the task name in the TCB. */
    899              if( pcName != NULL )
   \       0x24   0xF106 0x0134      ADD      R1,R6,#+52
   \       0x28   0xB154             CBZ.N    R4,??prvInitialiseNewTask_0
    900              {
    901                  for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   \       0x2A   0x2200             MOVS     R2,#+0
    902                  {
    903                      pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   \                     ??prvInitialiseNewTask_1: (+1)
   \       0x2C   0x5CA3             LDRB     R3,[R4, R2]
   \       0x2E   0x548B             STRB     R3,[R1, R2]
    904          
    905                      /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
    906                       * configMAX_TASK_NAME_LEN characters just in case the memory after the
    907                       * string is not accessible (extremely unlikely). */
    908                      if( pcName[ x ] == ( char ) 0x00 )
   \       0x30   0x5CA0             LDRB     R0,[R4, R2]
   \       0x32   0xB110             CBZ.N    R0,??prvInitialiseNewTask_2
    909                      {
    910                          break;
    911                      }
    912                      else
    913                      {
    914                          mtCOVERAGE_TEST_MARKER();
    915                      }
    916                  }
   \       0x34   0x1C52             ADDS     R2,R2,#+1
   \       0x36   0x2A0A             CMP      R2,#+10
   \       0x38   0xD3F8             BCC.N    ??prvInitialiseNewTask_1
    917          
    918                  /* Ensure the name string is terminated in the case that the string length
    919                   * was greater or equal to configMAX_TASK_NAME_LEN. */
    920                  pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   \                     ??prvInitialiseNewTask_2: (+1)
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x724A             STRB     R2,[R1, #+9]
   \       0x3E   0xE001             B.N      ??prvInitialiseNewTask_3
    921              }
    922              else
    923              {
    924                  /* The task has not been given a name, so just ensure there is a NULL
    925                   * terminator when it is read out. */
    926                  pxNewTCB->pcTaskName[ 0 ] = 0x00;
   \                     ??prvInitialiseNewTask_0: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7008             STRB     R0,[R1, #+0]
   \                     ??prvInitialiseNewTask_3: (+1)
   \       0x44   0x9D08             LDR      R5,[SP, #+32]
    927              }
    928          
    929              /* This is used as an array index so must ensure it's not too large.  First
    930               * remove the privilege bit if one is present. */
    931              if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   \       0x46   0x2D37             CMP      R5,#+55
   \       0x48   0xBF88             IT       HI
   \       0x4A   0x2537             MOVHI    R5,#+55
    932              {
    933                  uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   \       0x4C   0x9C09             LDR      R4,[SP, #+36]
    934              }
    935              else
    936              {
    937                  mtCOVERAGE_TEST_MARKER();
    938              }
    939          
    940              pxNewTCB->uxPriority = uxPriority;
   \       0x4E   0x62F5             STR      R5,[R6, #+44]
    941              #if ( configUSE_MUTEXES == 1 )
    942                  {
    943                      pxNewTCB->uxBasePriority = uxPriority;
   \       0x50   0x614D             STR      R5,[R1, #+20]
    944                      pxNewTCB->uxMutexesHeld = 0;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x6188             STR      R0,[R1, #+24]
    945                  }
    946              #endif /* configUSE_MUTEXES */
    947          
    948              vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   \       0x56   0x1D30             ADDS     R0,R6,#+4
   \       0x58   0x.... 0x....      BL       vListInitialiseItem
    949              vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   \       0x5C   0xF106 0x0018      ADD      R0,R6,#+24
   \       0x60   0x.... 0x....      BL       vListInitialiseItem
    950          
    951              /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
    952               * back to  the containing TCB from a generic item in a list. */
    953              listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   \       0x64   0x6136             STR      R6,[R6, #+16]
    954          
    955              /* Event lists are always in priority order. */
    956              listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \       0x66   0xF1C5 0x0538      RSB      R5,R5,#+56
   \       0x6A   0x61B5             STR      R5,[R6, #+24]
    957              listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   \       0x6C   0x6276             STR      R6,[R6, #+36]
    958          
    959              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
    960                  {
    961                      pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
    962                  }
    963              #endif /* portCRITICAL_NESTING_IN_TCB */
    964          
    965              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
    966                  {
    967                      pxNewTCB->pxTaskTag = NULL;
    968                  }
    969              #endif /* configUSE_APPLICATION_TASK_TAG */
    970          
    971              #if ( configGENERATE_RUN_TIME_STATS == 1 )
    972                  {
    973                      pxNewTCB->ulRunTimeCounter = 0UL;
    974                  }
    975              #endif /* configGENERATE_RUN_TIME_STATS */
    976          
    977              #if ( portUSING_MPU_WRAPPERS == 1 )
    978                  {
    979                      vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
    980                  }
    981              #else
    982                  {
    983                      /* Avoid compiler warning about unreferenced parameter. */
    984                      ( void ) xRegions;
    985                  }
    986              #endif
    987          
    988              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
    989                  {
    990                      memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
   \       0x6E   0x2108             MOVS     R1,#+8
   \       0x70   0xF106 0x0050      ADD      R0,R6,#+80
   \       0x74   0x.... 0x....      BL       __aeabi_memclr
    991                  }
    992              #endif
    993          
    994              #if ( configUSE_TASK_NOTIFICATIONS == 1 )
    995                  {
    996                      memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
   \       0x78   0x2104             MOVS     R1,#+4
   \       0x7A   0xF106 0x0058      ADD      R0,R6,#+88
   \       0x7E   0x.... 0x....      BL       __aeabi_memclr
    997                      memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
   \       0x82   0xF106 0x025C      ADD      R2,R6,#+92
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x7010             STRB     R0,[R2, #+0]
    998                  }
    999              #endif
   1000          
   1001              #if ( configUSE_NEWLIB_REENTRANT == 1 )
   1002                  {
   1003                      /* Initialise this task's Newlib reent structure.
   1004                       * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
   1005                       * for additional information. */
   1006                      _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
   1007                  }
   1008              #endif
   1009          
   1010              #if ( INCLUDE_xTaskAbortDelay == 1 )
   1011                  {
   1012                      pxNewTCB->ucDelayAborted = pdFALSE;
   1013                  }
   1014              #endif
   1015          
   1016              /* Initialize the TCB stack to look as if the task was already running,
   1017               * but had been interrupted by the scheduler.  The return address is set
   1018               * to the start of the task function. Once the stack has been initialised
   1019               * the top of stack variable is updated. */
   1020              #if ( portUSING_MPU_WRAPPERS == 1 )
   1021                  {
   1022                      /* If the port has capability to detect stack overflow,
   1023                       * pass the stack end address to the stack initialization
   1024                       * function as well. */
   1025                      #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
   1026                          {
   1027                              #if ( portSTACK_GROWTH < 0 )
   1028                                  {
   1029                                      pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
   1030                                  }
   1031                              #else /* portSTACK_GROWTH */
   1032                                  {
   1033                                      pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );
   1034                                  }
   1035                              #endif /* portSTACK_GROWTH */
   1036                          }
   1037                      #else /* portHAS_STACK_OVERFLOW_CHECKING */
   1038                          {
   1039                              pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
   1040                          }
   1041                      #endif /* portHAS_STACK_OVERFLOW_CHECKING */
   1042                  }
   1043              #else /* portUSING_MPU_WRAPPERS */
   1044                  {
   1045                      /* If the port has capability to detect stack overflow,
   1046                       * pass the stack end address to the stack initialization
   1047                       * function as well. */
   1048                      #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
   1049                          {
   1050                              #if ( portSTACK_GROWTH < 0 )
   1051                                  {
   1052                                      pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
   \       0x8A   0x6B31             LDR      R1,[R6, #+48]
   \       0x8C   0x464B             MOV      R3,R9
   \       0x8E   0x4642             MOV      R2,R8
   \       0x90   0x4638             MOV      R0,R7
   \       0x92   0x.... 0x....      BL       pxPortInitialiseStack
   \       0x96   0x6030             STR      R0,[R6, #+0]
   1053                                  }
   1054                              #else /* portSTACK_GROWTH */
   1055                                  {
   1056                                      pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters );
   1057                                  }
   1058                              #endif /* portSTACK_GROWTH */
   1059                          }
   1060                      #else /* portHAS_STACK_OVERFLOW_CHECKING */
   1061                          {
   1062                              pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   1063                          }
   1064                      #endif /* portHAS_STACK_OVERFLOW_CHECKING */
   1065                  }
   1066              #endif /* portUSING_MPU_WRAPPERS */
   1067          
   1068              if( pxCreatedTask != NULL )
   \       0x98   0xB104             CBZ.N    R4,??prvInitialiseNewTask_4
   1069              {
   1070                  /* Pass the handle out in an anonymous way.  The handle can be used to
   1071                   * change the created task's priority, delete the created task, etc.*/
   1072                  *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   \       0x9A   0x6026             STR      R6,[R4, #+0]
   1073              }
   1074              else
   1075              {
   1076                  mtCOVERAGE_TEST_MARKER();
   1077              }
   1078          }
   \                     ??prvInitialiseNewTask_4: (+1)
   \       0x9C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   1079          /*-----------------------------------------------------------*/
   1080          

   \                                 In section .text, align 2, keep-with-next
   1081          static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
   1082          {
   \                     prvAddNewTaskToReadyList: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine10
   1083              /* Ensure interrupts don't access the task lists while the lists are being
   1084               * updated. */
   1085              taskENTER_CRITICAL();
   1086              {
   1087                  uxCurrentNumberOfTasks++;
   \                     ??CrossCallReturnLabel_53: (+1)
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable42
   \        0xC   0x6CE8             LDR      R0,[R5, #+76]
   1088          
   1089                  if( pxCurrentTCB == NULL )
   \        0xE   0x2614             MOVS     R6,#+20
   \       0x10   0x.... 0x....      LDR.W    R8,??DataTable43
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x64E8             STR      R0,[R5, #+76]
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0xBB28             CBNZ.N   R0,??prvAddNewTaskToReadyList_0
   1090                  {
   1091                      /* There are no other tasks, or all the other tasks are in
   1092                       * the suspended state - make this the current task. */
   1093                      pxCurrentTCB = pxNewTCB;
   \       0x1C   0x62AC             STR      R4,[R5, #+40]
   1094          
   1095                      if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   \       0x1E   0x6CE8             LDR      R0,[R5, #+76]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD129             BNE.N    ??prvAddNewTaskToReadyList_1
   1096                      {
   1097                          /* This is the first task to be created so do the preliminary
   1098                           * initialisation required.  We will not recover if this call
   1099                           * fails, but we will report the failure. */
   1100                          prvInitialiseTaskLists();
   \       0x24   0x2700             MOVS     R7,#+0
   \                     ??prvAddNewTaskToReadyList_2: (+1)
   \       0x26   0xFB06 0xF007      MUL      R0,R6,R7
   \       0x2A   0x1C7F             ADDS     R7,R7,#+1
   \       0x2C   0x4440             ADD      R0,R8,R0
   \       0x2E   0x.... 0x....      BL       vListInitialise
   \       0x32   0x2F38             CMP      R7,#+56
   \       0x34   0xD3F7             BCC.N    ??prvAddNewTaskToReadyList_2
   \       0x36   0xF105 0x0078      ADD      R0,R5,#+120
   \       0x3A   0x.... 0x....      BL       vListInitialise
   \       0x3E   0xF105 0x078C      ADD      R7,R5,#+140
   \       0x42   0x4638             MOV      R0,R7
   \       0x44   0x.... 0x....      BL       vListInitialise
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x.... 0x....      BL       vListInitialise
   \       0x4E   0xF105 0x0014      ADD      R0,R5,#+20
   \       0x52   0x.... 0x....      BL       vListInitialise
   \       0x56   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x5A   0x.... 0x....      BL       vListInitialise
   \       0x5E   0xF105 0x0078      ADD      R0,R5,#+120
   \       0x62   0x62E8             STR      R0,[R5, #+44]
   \       0x64   0x632F             STR      R7,[R5, #+48]
   1101                      }
   1102                      else
   1103                      {
   1104                          mtCOVERAGE_TEST_MARKER();
   1105                      }
   1106                  }
   \       0x66   0xE007             B.N      ??prvAddNewTaskToReadyList_1
   1107                  else
   1108                  {
   1109                      /* If the scheduler is not already running, make this task the
   1110                       * current task if it is the highest priority task to be created
   1111                       * so far. */
   1112                      if( xSchedulerRunning == pdFALSE )
   \                     ??prvAddNewTaskToReadyList_0: (+1)
   \       0x68   0x6DA8             LDR      R0,[R5, #+88]
   \       0x6A   0xB928             CBNZ.N   R0,??prvAddNewTaskToReadyList_1
   1113                      {
   1114                          if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   \       0x6C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x6E   0x6AAA             LDR      R2,[R5, #+40]
   \       0x70   0x6AD1             LDR      R1,[R2, #+44]
   \       0x72   0x4288             CMP      R0,R1
   \       0x74   0xBF28             IT       CS
   \       0x76   0x62AC             STRCS    R4,[R5, #+40]
   1115                          {
   1116                              pxCurrentTCB = pxNewTCB;
   1117                          }
   1118                          else
   1119                          {
   1120                              mtCOVERAGE_TEST_MARKER();
   1121                          }
   1122                      }
   1123                      else
   1124                      {
   1125                          mtCOVERAGE_TEST_MARKER();
   1126                      }
   1127                  }
   1128          
   1129                  uxTaskNumber++;
   \                     ??prvAddNewTaskToReadyList_1: (+1)
   \       0x78   0x6EAA             LDR      R2,[R5, #+104]
   1130          
   1131                  #if ( configUSE_TRACE_FACILITY == 1 )
   1132                      {
   1133                          /* Add a counter into the TCB for tracing only. */
   1134                          pxNewTCB->uxTCBNumber = uxTaskNumber;
   1135                      }
   1136                  #endif /* configUSE_TRACE_FACILITY */
   1137                  traceTASK_CREATE( pxNewTCB );
   1138          
   1139                  prvAddTaskToReadyList( pxNewTCB );
   \       0x7A   0x6AE0             LDR      R0,[R4, #+44]
   \       0x7C   0x1C52             ADDS     R2,R2,#+1
   \       0x7E   0x6422             STR      R2,[R4, #+64]
   \       0x80   0x6D69             LDR      R1,[R5, #+84]
   \       0x82   0x4281             CMP      R1,R0
   \       0x84   0xBF38             IT       CC
   \       0x86   0x6568             STRCC    R0,[R5, #+84]
   \       0x88   0x4346             MULS     R6,R6,R0
   \       0x8A   0x66AA             STR      R2,[R5, #+104]
   \       0x8C   0x1D21             ADDS     R1,R4,#+4
   \       0x8E   0xEB08 0x0006      ADD      R0,R8,R6
   \       0x92   0x.... 0x....      BL       vListInsertEnd
   1140          
   1141                  portSETUP_TCB( pxNewTCB );
   1142              }
   1143              taskEXIT_CRITICAL();
   \       0x96   0x.... 0x....      BL       vPortExitCritical
   1144          
   1145              if( xSchedulerRunning != pdFALSE )
   \       0x9A   0x6DA8             LDR      R0,[R5, #+88]
   \       0x9C   0xB130             CBZ.N    R0,??prvAddNewTaskToReadyList_3
   1146              {
   1147                  /* If the created task is of a higher priority than the current task
   1148                   * then it should run now. */
   1149                  if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   \       0x9E   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0xA2   0xD203             BCS.N    ??prvAddNewTaskToReadyList_3
   1150                  {
   1151                      taskYIELD_IF_USING_PREEMPTION();
   \       0xA4   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xA8   0x.... 0x....      B.W      vPortYield
   1152                  }
   1153                  else
   1154                  {
   1155                      mtCOVERAGE_TEST_MARKER();
   1156                  }
   1157              }
   1158              else
   1159              {
   1160                  mtCOVERAGE_TEST_MARKER();
   1161              }
   1162          }
   \                     ??prvAddNewTaskToReadyList_3: (+1)
   \       0xAC   0xE8BD 0x81F0      POP      {R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x.... 0x....      B.W      vPortEnterCritical

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x6AA9             LDR      R1,[R5, #+40]
   \        0x2   0x6AC8             LDR      R0,[R1, #+44]
   \        0x4   0x6AE1             LDR      R1,[R4, #+44]
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0x4770             BX       LR
   1163          /*-----------------------------------------------------------*/
   1164          
   1165          #if ( INCLUDE_vTaskDelete == 1 )
   1166          

   \                                 In section .text, align 2, keep-with-next
   1167              void vTaskDelete( TaskHandle_t xTaskToDelete )
   1168              {
   \                     vTaskDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1169                  TCB_t * pxTCB;
   1170          
   1171                  taskENTER_CRITICAL();
   1172                  {
   1173                      /* If null is passed in here then it is the calling task that is
   1174                       * being deleted. */
   1175                      pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   \                     ??CrossCallReturnLabel_52: (+1)
   \        0x6   0x.... 0x....      BL       ?Subroutine4
   1176          
   1177                      /* Remove task from the ready/delayed list. */
   1178                      if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1179                      {
   1180                          taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1181                      }
   1182                      else
   1183                      {
   1184                          mtCOVERAGE_TEST_MARKER();
   1185                      }
   1186          
   1187                      /* Is the task waiting on an event also? */
   1188                      if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0xA   0x6AA0             LDR      R0,[R4, #+40]
   \        0xC   0xB108             CBZ.N    R0,??CrossCallReturnLabel_77
   1189                      {
   1190                          ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \        0xE   0x.... 0x....      BL       ?Subroutine15
   1191                      }
   1192                      else
   1193                      {
   1194                          mtCOVERAGE_TEST_MARKER();
   1195                      }
   1196          
   1197                      /* Increment the uxTaskNumber also so kernel aware debuggers can
   1198                       * detect that the task lists need re-generating.  This is done before
   1199                       * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
   1200                       * not return. */
   1201                      uxTaskNumber++;
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x12   0x6EA8             LDR      R0,[R5, #+104]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x66A8             STR      R0,[R5, #+104]
   1202          
   1203                      if( pxTCB == pxCurrentTCB )
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD108             BNE.N    ??vTaskDelete_0
   1204                      {
   1205                          /* A task is deleting itself.  This cannot complete within the
   1206                           * task itself, as a context switch to another task is required.
   1207                           * Place the task in the termination list.  The idle task will
   1208                           * check the termination list and free up any memory allocated by
   1209                           * the scheduler for the TCB and stack of the deleted task. */
   1210                          vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   \       0x1E   0x1D21             ADDS     R1,R4,#+4
   \       0x20   0xF105 0x0014      ADD      R0,R5,#+20
   \       0x24   0x.... 0x....      BL       vListInsertEnd
   1211          
   1212                          /* Increment the ucTasksDeleted variable so the idle task knows
   1213                           * there is a task that has been deleted and that it should therefore
   1214                           * check the xTasksWaitingTermination list. */
   1215                          ++uxDeletedTasksWaitingCleanUp;
   \       0x28   0x6B68             LDR      R0,[R5, #+52]
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0x6368             STR      R0,[R5, #+52]
   \       0x2E   0xE007             B.N      ??vTaskDelete_1
   1216          
   1217                          /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
   1218                           * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
   1219                          traceTASK_DELETE( pxTCB );
   1220          
   1221                          /* The pre-delete hook is primarily for the Windows simulator,
   1222                           * in which Windows specific clean up operations are performed,
   1223                           * after which it is not possible to yield away from this task -
   1224                           * hence xYieldPending is used to latch that a context switch is
   1225                           * required. */
   1226                          portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
   1227                      }
   1228                      else
   1229                      {
   1230                          --uxCurrentNumberOfTasks;
   \                     ??vTaskDelete_0: (+1)
   \       0x30   0x6CE8             LDR      R0,[R5, #+76]
   \       0x32   0x1E40             SUBS     R0,R0,#+1
   \       0x34   0x64E8             STR      R0,[R5, #+76]
   1231                          traceTASK_DELETE( pxTCB );
   1232                          prvDeleteTCB( pxTCB );
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x.... 0x....      BL       prvDeleteTCB
   1233          
   1234                          /* Reset the next expected unblock time in case it referred to
   1235                           * the task that has just been deleted. */
   1236                          prvResetNextTaskUnblockTime();
   \       0x3C   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   1237                      }
   1238                  }
   1239                  taskEXIT_CRITICAL();
   \                     ??vTaskDelete_1: (+1)
   \       0x40   0x.... 0x....      BL       vPortExitCritical
   1240          
   1241                  /* Force a reschedule if it is the currently running task that has just
   1242                   * been deleted. */
   1243                  if( xSchedulerRunning != pdFALSE )
   \       0x44   0x6DA8             LDR      R0,[R5, #+88]
   \       0x46   0xB148             CBZ.N    R0,??vTaskDelete_2
   1244                  {
   1245                      if( pxTCB == pxCurrentTCB )
   \       0x48   0x6AA9             LDR      R1,[R5, #+40]
   \       0x4A   0x428C             CMP      R4,R1
   \       0x4C   0xD106             BNE.N    ??vTaskDelete_2
   1246                      {
   1247                          configASSERT( uxSchedulerSuspended == 0 );
   \       0x4E   0x6F68             LDR      R0,[R5, #+116]
   \       0x50   0xB118             CBZ.N    R0,??CrossCallReturnLabel_29
   \       0x52   0xF240 0x41DF      MOVW     R1,#+1247
   \       0x56   0x.... 0x....      BL       ?Subroutine5
   1248                          portYIELD_WITHIN_API();
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x5A   0x....             B.N      ?Subroutine0
   1249                      }
   1250                      else
   1251                      {
   1252                          mtCOVERAGE_TEST_MARKER();
   1253                      }
   1254                  }
   1255              }
   \                     ??vTaskDelete_2: (+1)
   \       0x5C   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x.... 0x....      LDR.W    R5,??DataTable42
   \        0x4   0xB904             CBNZ.N   R4,??Subroutine4_0
   \        0x6   0x6AAC             LDR      R4,[R5, #+40]
   \                     ??Subroutine4_0: (+1)
   \        0x8   0x1D20             ADDS     R0,R4,#+4
   \        0xA   0x.... 0x....      B.W      uxListRemove

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \        0x4   0x.... 0x....      B.W      vPortYield

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0xF104 0x0018      ADD      R0,R4,#+24
   \        0x4   0x.... 0x....      B.W      uxListRemove

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable37
   \        0x4   0x.... 0x....      B.W      assertEFM
   1256          
   1257          #endif /* INCLUDE_vTaskDelete */
   1258          /*-----------------------------------------------------------*/
   1259          
   1260          #if ( INCLUDE_xTaskDelayUntil == 1 )
   1261          

   \                                 In section .text, align 2, keep-with-next
   1262              BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
   1263                                          const TickType_t xTimeIncrement )
   1264              {
   \                     xTaskDelayUntil: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   1265                  TickType_t xTimeToWake;
   1266                  BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   \        0x8   0x2600             MOVS     R6,#+0
   1267          
   1268                  configASSERT( pxPreviousWakeTime );
   \        0xA   0x.... 0x....      LDR.W    R8,??DataTable37
   \        0xE   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_37
   \       0x10   0xF240 0x41F4      MOVW     R1,#+1268
   \       0x14   0x.... 0x....      BL       ?Subroutine6
   1269                  configASSERT( ( xTimeIncrement > 0U ) );
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x18   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_36
   \       0x1A   0xF240 0x41F5      MOVW     R1,#+1269
   \       0x1E   0x.... 0x....      BL       ?Subroutine6
   1270                  configASSERT( uxSchedulerSuspended == 0 );
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x22   0x.... 0x....      LDR.W    R7,??DataTable42
   \       0x26   0x6F78             LDR      R0,[R7, #+116]
   \       0x28   0xB118             CBZ.N    R0,??CrossCallReturnLabel_35
   \       0x2A   0xF240 0x41F6      MOVW     R1,#+1270
   \       0x2E   0x.... 0x....      BL       ?Subroutine6
   1271          
   1272                  vTaskSuspendAll();
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x32   0x.... 0x....      BL       vTaskSuspendAll
   1273                  {
   1274                      /* Minor optimisation.  The tick count cannot change in this
   1275                       * block. */
   1276                      const TickType_t xConstTickCount = xTickCount;
   \       0x36   0x6D38             LDR      R0,[R7, #+80]
   1277          
   1278                      /* Generate the tick time at which the task wants to wake. */
   1279                      xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x186D             ADDS     R5,R5,R1
   1280          
   1281                      if( xConstTickCount < *pxPreviousWakeTime )
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xD202             BCS.N    ??xTaskDelayUntil_0
   1282                      {
   1283                          /* The tick count has overflowed since this function was
   1284                           * lasted called.  In this case the only time we should ever
   1285                           * actually delay is if the wake time has also  overflowed,
   1286                           * and the wake time is greater than the tick time.  When this
   1287                           * is the case it is as if neither time had overflowed. */
   1288                          if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   \       0x40   0x428D             CMP      R5,R1
   \       0x42   0xD204             BCS.N    ??xTaskDelayUntil_1
   \       0x44   0xE001             B.N      ??xTaskDelayUntil_2
   1289                          {
   1290                              xShouldDelay = pdTRUE;
   1291                          }
   1292                          else
   1293                          {
   1294                              mtCOVERAGE_TEST_MARKER();
   1295                          }
   1296                      }
   1297                      else
   1298                      {
   1299                          /* The tick time has not overflowed.  In this case we will
   1300                           * delay if either the wake time has overflowed, and/or the
   1301                           * tick time is less than the wake time. */
   1302                          if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   \                     ??xTaskDelayUntil_0: (+1)
   \       0x46   0x428D             CMP      R5,R1
   \       0x48   0xD303             BCC.N    ??xTaskDelayUntil_3
   \                     ??xTaskDelayUntil_2: (+1)
   \       0x4A   0x42A8             CMP      R0,R5
   \       0x4C   0xD301             BCC.N    ??xTaskDelayUntil_3
   \                     ??xTaskDelayUntil_1: (+1)
   \       0x4E   0x6025             STR      R5,[R4, #+0]
   \       0x50   0xE005             B.N      ??xTaskDelayUntil_4
   1303                          {
   1304                              xShouldDelay = pdTRUE;
   \                     ??xTaskDelayUntil_3: (+1)
   \       0x52   0x6025             STR      R5,[R4, #+0]
   1305                          }
   1306                          else
   1307                          {
   1308                              mtCOVERAGE_TEST_MARKER();
   1309                          }
   1310                      }
   1311          
   1312                      /* Update the wake time ready for the next call. */
   1313                      *pxPreviousWakeTime = xTimeToWake;
   1314          
   1315                      if( xShouldDelay != pdFALSE )
   1316                      {
   1317                          traceTASK_DELAY_UNTIL( xTimeToWake );
   1318          
   1319                          /* prvAddCurrentTaskToDelayedList() needs the block time, not
   1320                           * the time to wake, so subtract the current tick count. */
   1321                          prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x1A28             SUBS     R0,R5,R0
   \       0x58   0x2601             MOVS     R6,#+1
   \       0x5A   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   1322                      }
   1323                      else
   1324                      {
   1325                          mtCOVERAGE_TEST_MARKER();
   1326                      }
   1327                  }
   1328                  xAlreadyYielded = xTaskResumeAll();
   1329          
   1330                  /* Force a reschedule if xTaskResumeAll has not already done so, we may
   1331                   * have put ourselves to sleep. */
   1332                  if( xAlreadyYielded == pdFALSE )
   \                     ??xTaskDelayUntil_4: (+1)
   \       0x5E   0x.... 0x....      BL       xTaskResumeAll
   \       0x62   0xB908             CBNZ.N   R0,??xTaskDelayUntil_5
   1333                  {
   1334                      portYIELD_WITHIN_API();
   \       0x64   0x.... 0x....      BL       vPortYield
   1335                  }
   1336                  else
   1337                  {
   1338                      mtCOVERAGE_TEST_MARKER();
   1339                  }
   1340          
   1341                  return xShouldDelay;
   \                     ??xTaskDelayUntil_5: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1342              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x.... 0x....      B.W      assertEFM
   1343          
   1344          #endif /* INCLUDE_xTaskDelayUntil */
   1345          /*-----------------------------------------------------------*/
   1346          
   1347          #if ( INCLUDE_vTaskDelay == 1 )
   1348          

   \                                 In section .text, align 2, keep-with-next
   1349              void vTaskDelay( const TickType_t xTicksToDelay )
   1350              {
   \                     vTaskDelay: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1351                  BaseType_t xAlreadyYielded = pdFALSE;
   1352          
   1353                  /* A delay time of zero just forces a reschedule. */
   1354                  if( xTicksToDelay > ( TickType_t ) 0U )
   \        0x4   0xD010             BEQ.N    ??vTaskDelay_0
   1355                  {
   1356                      configASSERT( uxSchedulerSuspended == 0 );
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable42
   \        0xA   0x6F48             LDR      R0,[R1, #+116]
   \        0xC   0xB118             CBZ.N    R0,??CrossCallReturnLabel_28
   \        0xE   0xF240 0x514C      MOVW     R1,#+1356
   \       0x12   0x.... 0x....      BL       ?Subroutine5
   1357                      vTaskSuspendAll();
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x16   0x.... 0x....      BL       vTaskSuspendAll
   1358                      {
   1359                          traceTASK_DELAY();
   1360          
   1361                          /* A task that is removed from the event list while the
   1362                           * scheduler is suspended will not get placed in the ready
   1363                           * list or removed from the blocked list until the scheduler
   1364                           * is resumed.
   1365                           *
   1366                           * This task cannot be in an event list as it is the currently
   1367                           * executing task. */
   1368                          prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   1369                      }
   1370                      xAlreadyYielded = xTaskResumeAll();
   1371                  }
   1372                  else
   1373                  {
   1374                      mtCOVERAGE_TEST_MARKER();
   1375                  }
   1376          
   1377                  /* Force a reschedule if xTaskResumeAll has not already done so, we may
   1378                   * have put ourselves to sleep. */
   1379                  if( xAlreadyYielded == pdFALSE )
   \       0x22   0x.... 0x....      BL       xTaskResumeAll
   \       0x26   0xB918             CBNZ.N   R0,??vTaskDelay_1
   1380                  {
   1381                      portYIELD_WITHIN_API();
   \                     ??vTaskDelay_0: (+1)
   \       0x28   0xE8BD 0x4010      POP      {R4,LR}
   \       0x2C   0x.... 0x....      B.W      vPortYield
   1382                  }
   1383                  else
   1384                  {
   1385                      mtCOVERAGE_TEST_MARKER();
   1386                  }
   1387              }
   \                     ??vTaskDelay_1: (+1)
   \       0x30   0xBD10             POP      {R4,PC}
   1388          
   1389          #endif /* INCLUDE_vTaskDelay */
   1390          /*-----------------------------------------------------------*/
   1391          
   1392          #if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )
   1393          

   \                                 In section .text, align 2, keep-with-next
   1394              eTaskState eTaskGetState( TaskHandle_t xTask )
   1395              {
   \                     eTaskGetState: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1396                  eTaskState eReturn;
   1397                  List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
   1398                  const TCB_t * const pxTCB = xTask;
   1399          
   1400                  configASSERT( pxTCB );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_27
   \        0x8   0xF44F 0x61AF      MOV      R1,#+1400
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   1401          
   1402                  if( pxTCB == pxCurrentTCB )
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable42
   \       0x14   0x6AB0             LDR      R0,[R6, #+40]
   \       0x16   0x4284             CMP      R4,R0
   \       0x18   0xBF08             IT       EQ
   \       0x1A   0x2000             MOVEQ    R0,#+0
   1403                  {
   1404                      /* The task calling this function is querying its own state. */
   1405                      eReturn = eRunning;
   \       0x1C   0xD025             BEQ.N    ??eTaskGetState_0
   1406                  }
   1407                  else
   1408                  {
   1409                      taskENTER_CRITICAL();
   \       0x1E   0x.... 0x....      BL       vPortEnterCritical
   1410                      {
   1411                          pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   \       0x22   0x6965             LDR      R5,[R4, #+20]
   1412                          pxDelayedList = pxDelayedTaskList;
   \       0x24   0x6AF7             LDR      R7,[R6, #+44]
   1413                          pxOverflowedDelayedList = pxOverflowDelayedTaskList;
   \       0x26   0xF8D6 0x8030      LDR      R8,[R6, #+48]
   1414                      }
   1415                      taskEXIT_CRITICAL();
   \       0x2A   0x.... 0x....      BL       vPortExitCritical
   1416          
   1417                      if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
   \       0x2E   0x42BD             CMP      R5,R7
   \       0x30   0xBF18             IT       NE
   \       0x32   0x4545             CMPNE    R5,R8
   \       0x34   0xD010             BEQ.N    ??eTaskGetState_1
   1418                      {
   1419                          /* The task being queried is referenced from one of the Blocked
   1420                           * lists. */
   1421                          eReturn = eBlocked;
   1422                      }
   1423          
   1424                      #if ( INCLUDE_vTaskSuspend == 1 )
   1425                          else if( pxStateList == &xSuspendedTaskList )
   \       0x36   0xF106 0x0138      ADD      R1,R6,#+56
   \       0x3A   0x428D             CMP      R5,R1
   \       0x3C   0xD10E             BNE.N    ??eTaskGetState_2
   1426                          {
   1427                              /* The task being queried is referenced from the suspended
   1428                               * list.  Is it genuinely suspended or is it blocked
   1429                               * indefinitely? */
   1430                              if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   \       0x3E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x40   0xB950             CBNZ.N   R0,??eTaskGetState_1
   1431                              {
   1432                                  #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   1433                                      {
   1434                                          BaseType_t x;
   1435          
   1436                                          /* The task does not appear on the event list item of
   1437                                           * and of the RTOS objects, but could still be in the
   1438                                           * blocked state if it is waiting on its notification
   1439                                           * rather than waiting on an object.  If not, is
   1440                                           * suspended. */
   1441                                          eReturn = eSuspended;
   \       0x42   0x2003             MOVS     R0,#+3
   1442          
   1443                                          for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
   \       0x44   0x2100             MOVS     R1,#+0
   1444                                          {
   1445                                              if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
   \                     ??eTaskGetState_3: (+1)
   \       0x46   0x1862             ADDS     R2,R4,R1
   \       0x48   0xF892 0x205C      LDRB     R2,[R2, #+92]
   \       0x4C   0x2A01             CMP      R2,#+1
   \       0x4E   0xD003             BEQ.N    ??eTaskGetState_1
   1446                                              {
   1447                                                  eReturn = eBlocked;
   1448                                                  break;
   1449                                              }
   1450                                          }
   \       0x50   0x1C49             ADDS     R1,R1,#+1
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xDDF7             BLE.N    ??eTaskGetState_3
   \       0x56   0xE008             B.N      ??eTaskGetState_0
   1451                                      }
   1452                                  #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
   1453                                      {
   1454                                          eReturn = eSuspended;
   1455                                      }
   1456                                  #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
   1457                              }
   1458                              else
   1459                              {
   1460                                  eReturn = eBlocked;
   \                     ??eTaskGetState_1: (+1)
   \       0x58   0x2002             MOVS     R0,#+2
   \       0x5A   0xE006             B.N      ??eTaskGetState_0
   1461                              }
   1462                          }
   1463                      #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */
   1464          
   1465                      #if ( INCLUDE_vTaskDelete == 1 )
   1466                          else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   \                     ??eTaskGetState_2: (+1)
   \       0x5C   0xF106 0x0014      ADD      R0,R6,#+20
   \       0x60   0x4285             CMP      R5,R0
   \       0x62   0xBF16             ITET     NE
   \       0x64   0x2D00             CMPNE    R5,#+0
   \       0x66   0x2004             MOVEQ    R0,#+4
   \       0x68   0x2001             MOVNE    R0,#+1
   1467                          {
   1468                              /* The task being queried is referenced from the deleted
   1469                               * tasks list, or it is not referenced from any lists at
   1470                               * all. */
   1471                              eReturn = eDeleted;
   1472                          }
   1473                      #endif
   1474          
   1475                      else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1476                      {
   1477                          /* If the task is not in any other state, it must be in the
   1478                           * Ready (including pending ready) state. */
   1479                          eReturn = eReady;
   1480                      }
   1481                  }
   1482          
   1483                  return eReturn;
   \                     ??eTaskGetState_0: (+1)
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1484              } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1485          
   1486          #endif /* INCLUDE_eTaskGetState */
   1487          /*-----------------------------------------------------------*/
   1488          
   1489          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1490          

   \                                 In section .text, align 2, keep-with-next
   1491              UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
   1492              {
   \                     uxTaskPriorityGet: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1493                  TCB_t const * pxTCB;
   1494                  UBaseType_t uxReturn;
   1495          
   1496                  taskENTER_CRITICAL();
   1497                  {
   1498                      /* If null is passed in here then it is the priority of the task
   1499                       * that called uxTaskPriorityGet() that is being queried. */
   1500                      pxTCB = prvGetTCBFromHandle( xTask );
   \                     ??CrossCallReturnLabel_51: (+1)
   \        0x6   0xB914             CBNZ.N   R4,??uxTaskPriorityGet_0
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable42
   \        0xC   0x6A84             LDR      R4,[R0, #+40]
   1501                      uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGet_0: (+1)
   \        0xE   0x6AE4             LDR      R4,[R4, #+44]
   1502                  }
   1503                  taskEXIT_CRITICAL();
   \       0x10   0x.... 0x....      BL       vPortExitCritical
   1504          
   1505                  return uxReturn;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xBD10             POP      {R4,PC}
   1506              }
   1507          
   1508          #endif /* INCLUDE_uxTaskPriorityGet */
   1509          /*-----------------------------------------------------------*/
   1510          
   1511          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1512          

   \                                 In section .text, align 2, keep-with-next
   1513              UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
   1514              {
   \                     uxTaskPriorityGetFromISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1515                  TCB_t const * pxTCB;
   1516                  UBaseType_t uxReturn, uxSavedInterruptState;
   1517          
   1518                  /* RTOS ports that support interrupt nesting have the concept of a
   1519                   * maximum  system call (or maximum API call) interrupt priority.
   1520                   * Interrupts that are  above the maximum system call priority are keep
   1521                   * permanently enabled, even when the RTOS kernel is in a critical section,
   1522                   * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1523                   * is defined in FreeRTOSConfig.h then
   1524                   * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1525                   * failure if a FreeRTOS API function is called from an interrupt that has
   1526                   * been assigned a priority above the configured maximum system call
   1527                   * priority.  Only FreeRTOS functions that end in FromISR can be called
   1528                   * from interrupts  that have been assigned a priority at or (logically)
   1529                   * below the maximum system call interrupt priority.  FreeRTOS maintains a
   1530                   * separate interrupt safe API to ensure interrupt entry is as fast and as
   1531                   * simple as possible.  More information (albeit Cortex-M specific) is
   1532                   * provided on the following link:
   1533                   * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   1534                  portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1535          
   1536                  uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   \        0x4   0x.... 0x....      BL       ulSetInterruptMask
   1537                  {
   1538                      /* If null is passed in here then it is the priority of the calling
   1539                       * task that is being queried. */
   1540                      pxTCB = prvGetTCBFromHandle( xTask );
   \        0x8   0xB914             CBNZ.N   R4,??uxTaskPriorityGetFromISR_0
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable42
   \        0xE   0x6A8C             LDR      R4,[R1, #+40]
   1541                      uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGetFromISR_0: (+1)
   \       0x10   0x6AE4             LDR      R4,[R4, #+44]
   1542                  }
   1543                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   \       0x12   0x.... 0x....      BL       vClearInterruptMask
   1544          
   1545                  return uxReturn;
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}
   1546              }
   1547          
   1548          #endif /* INCLUDE_uxTaskPriorityGet */
   1549          /*-----------------------------------------------------------*/
   1550          
   1551          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1552          

   \                                 In section .text, align 2, keep-with-next
   1553              void vTaskPrioritySet( TaskHandle_t xTask,
   1554                                     UBaseType_t uxNewPriority )
   1555              {
   \                     vTaskPrioritySet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460F             MOV      R7,R1
   1556                  TCB_t * pxTCB;
   1557                  UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1558                  BaseType_t xYieldRequired = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x4605             MOV      R5,R0
   1559          
   1560                  configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   \        0xA   0x2F37             CMP      R7,#+55
   \        0xC   0xD904             BLS.N    ??vTaskPrioritySet_0
   \        0xE   0xF44F 0x61C3      MOV      R1,#+1560
   \       0x12   0x.... 0x....      BL       ?Subroutine5
   1561          
   1562                  /* Ensure the new priority is valid. */
   1563                  if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1564                  {
   1565                      uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x16   0x2737             MOVS     R7,#+55
   1566                  }
   1567                  else
   1568                  {
   1569                      mtCOVERAGE_TEST_MARKER();
   1570                  }
   1571          
   1572                  taskENTER_CRITICAL();
   \                     ??vTaskPrioritySet_0: (+1)
   \       0x18   0x.... 0x....      BL       vPortEnterCritical
   1573                  {
   1574                      /* If null is passed in here then it is the priority of the calling
   1575                       * task that is being changed. */
   1576                      pxTCB = prvGetTCBFromHandle( xTask );
   \       0x1C   0x.... 0x....      LDR.W    R6,??DataTable42
   \       0x20   0xB905             CBNZ.N   R5,??vTaskPrioritySet_1
   \       0x22   0x6AB5             LDR      R5,[R6, #+40]
   1577          
   1578                      traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1579          
   1580                      #if ( configUSE_MUTEXES == 1 )
   1581                          {
   1582                              uxCurrentBasePriority = pxTCB->uxBasePriority;
   \                     ??vTaskPrioritySet_1: (+1)
   \       0x24   0x6CA9             LDR      R1,[R5, #+72]
   1583                          }
   1584                      #else
   1585                          {
   1586                              uxCurrentBasePriority = pxTCB->uxPriority;
   1587                          }
   1588                      #endif
   1589          
   1590                      if( uxCurrentBasePriority != uxNewPriority )
   \       0x26   0x42B9             CMP      R1,R7
   \       0x28   0xD031             BEQ.N    ??vTaskPrioritySet_2
   1591                      {
   1592                          /* The priority change may have readied a task of higher
   1593                           * priority than the calling task. */
   1594                          if( uxNewPriority > uxCurrentBasePriority )
   \       0x2A   0x6AB0             LDR      R0,[R6, #+40]
   \       0x2C   0xD206             BCS.N    ??vTaskPrioritySet_3
   1595                          {
   1596                              if( pxTCB != pxCurrentTCB )
   \       0x2E   0x4285             CMP      R5,R0
   \       0x30   0xD007             BEQ.N    ??vTaskPrioritySet_4
   1597                              {
   1598                                  /* The priority of a task other than the currently
   1599                                   * running task is being raised.  Is the priority being
   1600                                   * raised above that of the running task? */
   1601                                  if( uxNewPriority >= pxCurrentTCB->uxPriority )
   \       0x32   0x6AB2             LDR      R2,[R6, #+40]
   \       0x34   0x6AD0             LDR      R0,[R2, #+44]
   \       0x36   0x4287             CMP      R7,R0
   \       0x38   0xD303             BCC.N    ??vTaskPrioritySet_4
   1602                                  {
   1603                                      xYieldRequired = pdTRUE;
   \       0x3A   0xE001             B.N      ??vTaskPrioritySet_5
   1604                                  }
   1605                                  else
   1606                                  {
   1607                                      mtCOVERAGE_TEST_MARKER();
   1608                                  }
   1609                              }
   1610                              else
   1611                              {
   1612                                  /* The priority of the running task is being raised,
   1613                                   * but the running task must already be the highest
   1614                                   * priority task able to run so no yield is required. */
   1615                              }
   1616                          }
   1617                          else if( pxTCB == pxCurrentTCB )
   \                     ??vTaskPrioritySet_3: (+1)
   \       0x3C   0x4285             CMP      R5,R0
   \       0x3E   0xD100             BNE.N    ??vTaskPrioritySet_4
   1618                          {
   1619                              /* Setting the priority of the running task down means
   1620                               * there may now be another task of higher priority that
   1621                               * is ready to execute. */
   1622                              xYieldRequired = pdTRUE;
   \                     ??vTaskPrioritySet_5: (+1)
   \       0x40   0x2401             MOVS     R4,#+1
   1623                          }
   1624                          else
   1625                          {
   1626                              /* Setting the priority of any other task down does not
   1627                               * require a yield as the running task must be above the
   1628                               * new priority of the task being modified. */
   1629                          }
   1630          
   1631                          /* Remember the ready list the task might be referenced from
   1632                           * before its uxPriority member is changed so the
   1633                           * taskRESET_READY_PRIORITY() macro can function correctly. */
   1634                          uxPriorityUsedOnEntry = pxTCB->uxPriority;
   \                     ??vTaskPrioritySet_4: (+1)
   \       0x42   0x6AE8             LDR      R0,[R5, #+44]
   1635          
   1636                          #if ( configUSE_MUTEXES == 1 )
   1637                              {
   1638                                  /* Only change the priority being used if the task is not
   1639                                   * currently using an inherited priority. */
   1640                                  if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   \       0x44   0x4281             CMP      R1,R0
   \       0x46   0xBF08             IT       EQ
   \       0x48   0x62EF             STREQ    R7,[R5, #+44]
   1641                                  {
   1642                                      pxTCB->uxPriority = uxNewPriority;
   1643                                  }
   1644                                  else
   1645                                  {
   1646                                      mtCOVERAGE_TEST_MARKER();
   1647                                  }
   1648          
   1649                                  /* The base priority gets set whatever. */
   1650                                  pxTCB->uxBasePriority = uxNewPriority;
   1651                              }
   1652                          #else /* if ( configUSE_MUTEXES == 1 ) */
   1653                              {
   1654                                  pxTCB->uxPriority = uxNewPriority;
   1655                              }
   1656                          #endif /* if ( configUSE_MUTEXES == 1 ) */
   1657          
   1658                          /* Only reset the event list item value if the value is not
   1659                           * being used for anything else. */
   1660                          if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   \       0x4A   0x69AA             LDR      R2,[R5, #+24]
   \       0x4C   0x64AF             STR      R7,[R5, #+72]
   \       0x4E   0x2A00             CMP      R2,#+0
   \       0x50   0xBF5C             ITT      PL
   \       0x52   0xF1C7 0x0738      RSBPL    R7,R7,#+56
   \       0x56   0x61AF             STRPL    R7,[R5, #+24]
   1661                          {
   1662                              listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1663                          }
   1664                          else
   1665                          {
   1666                              mtCOVERAGE_TEST_MARKER();
   1667                          }
   1668          
   1669                          /* If the task is in the blocked or suspended list we need do
   1670                           * nothing more than change its priority variable. However, if
   1671                           * the task is in a ready list it needs to be removed and placed
   1672                           * in the list appropriate to its new priority. */
   1673                          if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   \       0x58   0xF04F 0x0814      MOV      R8,#+20
   \       0x5C   0xFB08 0xF000      MUL      R0,R8,R0
   \       0x60   0x6969             LDR      R1,[R5, #+20]
   \       0x62   0x.... 0x....      LDR.W    R7,??DataTable43
   \       0x66   0x4438             ADD      R0,R7,R0
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD10D             BNE.N    ??vTaskPrioritySet_6
   1674                          {
   1675                              /* The task is currently in its ready list - remove before
   1676                               * adding it to it's new ready list.  As we are in a critical
   1677                               * section we can do this even if the scheduler is suspended. */
   1678                              if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x6C   0x1D28             ADDS     R0,R5,#+4
   \       0x6E   0x.... 0x....      BL       uxListRemove
   1679                              {
   1680                                  /* It is known that the task is in its ready list so
   1681                                   * there is no need to check again and the port level
   1682                                   * reset macro can be called directly. */
   1683                                  portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1684                              }
   1685                              else
   1686                              {
   1687                                  mtCOVERAGE_TEST_MARKER();
   1688                              }
   1689          
   1690                              prvAddTaskToReadyList( pxTCB );
   \       0x72   0x6AE8             LDR      R0,[R5, #+44]
   \       0x74   0x6D71             LDR      R1,[R6, #+84]
   \       0x76   0x4281             CMP      R1,R0
   \       0x78   0xBF38             IT       CC
   \       0x7A   0x6570             STRCC    R0,[R6, #+84]
   \       0x7C   0xFB08 0xF200      MUL      R2,R8,R0
   \       0x80   0x1D29             ADDS     R1,R5,#+4
   \       0x82   0x18B8             ADDS     R0,R7,R2
   \       0x84   0x.... 0x....      BL       vListInsertEnd
   1691                          }
   1692                          else
   1693                          {
   1694                              mtCOVERAGE_TEST_MARKER();
   1695                          }
   1696          
   1697                          if( xYieldRequired != pdFALSE )
   \                     ??vTaskPrioritySet_6: (+1)
   \       0x88   0xB10C             CBZ.N    R4,??vTaskPrioritySet_2
   1698                          {
   1699                              taskYIELD_IF_USING_PREEMPTION();
   \       0x8A   0x.... 0x....      BL       vPortYield
   1700                          }
   1701                          else
   1702                          {
   1703                              mtCOVERAGE_TEST_MARKER();
   1704                          }
   1705          
   1706                          /* Remove compiler warning about unused variables when the port
   1707                           * optimised task selection is not being used. */
   1708                          ( void ) uxPriorityUsedOnEntry;
   1709                      }
   1710                  }
   1711                  taskEXIT_CRITICAL();
   \                     ??vTaskPrioritySet_2: (+1)
   \       0x8E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x92   0x.... 0x....      B.W      vPortExitCritical
   1712              }
   1713          
   1714          #endif /* INCLUDE_vTaskPrioritySet */
   1715          /*-----------------------------------------------------------*/
   1716          
   1717          #if ( INCLUDE_vTaskSuspend == 1 )
   1718          

   \                                 In section .text, align 2, keep-with-next
   1719              void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1720              {
   \                     vTaskSuspend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine10
   1721                  TCB_t * pxTCB;
   1722          
   1723                  taskENTER_CRITICAL();
   1724                  {
   1725                      /* If null is passed in here then it is the running task that is
   1726                       * being suspended. */
   1727                      pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   \                     ??CrossCallReturnLabel_50: (+1)
   \        0x6   0x.... 0x....      BL       ?Subroutine4
   1728          
   1729                      traceTASK_SUSPEND( pxTCB );
   1730          
   1731                      /* Remove task from the ready/delayed list and place in the
   1732                       * suspended list. */
   1733                      if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1734                      {
   1735                          taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1736                      }
   1737                      else
   1738                      {
   1739                          mtCOVERAGE_TEST_MARKER();
   1740                      }
   1741          
   1742                      /* Is the task waiting on an event also? */
   1743                      if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xA   0x6AA0             LDR      R0,[R4, #+40]
   \        0xC   0xB108             CBZ.N    R0,??CrossCallReturnLabel_76
   1744                      {
   1745                          ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \        0xE   0x.... 0x....      BL       ?Subroutine15
   1746                      }
   1747                      else
   1748                      {
   1749                          mtCOVERAGE_TEST_MARKER();
   1750                      }
   1751          
   1752                      vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0x12   0x1D21             ADDS     R1,R4,#+4
   \       0x14   0xF105 0x0038      ADD      R0,R5,#+56
   \       0x18   0x.... 0x....      BL       vListInsertEnd
   1753          
   1754                      #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   1755                          {
   1756                              BaseType_t x;
   1757          
   1758                              for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x2200             MOVS     R2,#+0
   1759                              {
   1760                                  if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
   \                     ??vTaskSuspend_0: (+1)
   \       0x20   0x1860             ADDS     R0,R4,R1
   \       0x22   0xF890 0x305C      LDRB     R3,[R0, #+92]
   \       0x26   0x2B01             CMP      R3,#+1
   \       0x28   0xBF08             IT       EQ
   \       0x2A   0xF880 0x205C      STRBEQ   R2,[R0, #+92]
   1761                                  {
   1762                                      /* The task was blocked to wait for a notification, but is
   1763                                       * now suspended, so no notification was received. */
   1764                                      pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
   1765                                  }
   1766                              }
   \       0x2E   0x1C49             ADDS     R1,R1,#+1
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xDDF5             BLE.N    ??vTaskSuspend_0
   1767                          }
   1768                      #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
   1769                  }
   1770                  taskEXIT_CRITICAL();
   \       0x34   0x.... 0x....      BL       vPortExitCritical
   1771          
   1772                  if( xSchedulerRunning != pdFALSE )
   \       0x38   0x6DA8             LDR      R0,[R5, #+88]
   \       0x3A   0xB128             CBZ.N    R0,??vTaskSuspend_1
   1773                  {
   1774                      /* Reset the next expected unblock time in case it referred to the
   1775                       * task that is now in the Suspended state. */
   1776                      taskENTER_CRITICAL();
   \       0x3C   0x.... 0x....      BL       vPortEnterCritical
   1777                      {
   1778                          prvResetNextTaskUnblockTime();
   \       0x40   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   1779                      }
   1780                      taskEXIT_CRITICAL();
   \       0x44   0x.... 0x....      BL       vPortExitCritical
   1781                  }
   1782                  else
   1783                  {
   1784                      mtCOVERAGE_TEST_MARKER();
   1785                  }
   1786          
   1787                  if( pxTCB == pxCurrentTCB )
   \                     ??vTaskSuspend_1: (+1)
   \       0x48   0x6AA9             LDR      R1,[R5, #+40]
   \       0x4A   0x428C             CMP      R4,R1
   \       0x4C   0xD112             BNE.N    ??vTaskSuspend_2
   1788                  {
   1789                      if( xSchedulerRunning != pdFALSE )
   \       0x4E   0x6DA8             LDR      R0,[R5, #+88]
   \       0x50   0xB130             CBZ.N    R0,??vTaskSuspend_3
   1790                      {
   1791                          /* The current task has just been suspended. */
   1792                          configASSERT( uxSchedulerSuspended == 0 );
   \       0x52   0x6F68             LDR      R0,[R5, #+116]
   \       0x54   0xB118             CBZ.N    R0,??CrossCallReturnLabel_25
   \       0x56   0xF44F 0x61E0      MOV      R1,#+1792
   \       0x5A   0x.... 0x....      BL       ?Subroutine5
   1793                          portYIELD_WITHIN_API();
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x5E   0x....             B.N      ?Subroutine0
   1794                      }
   1795                      else
   1796                      {
   1797                          /* The scheduler is not running, but the task that was pointed
   1798                           * to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1799                           * must be adjusted to point to a different task. */
   1800                          if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
   \                     ??vTaskSuspend_3: (+1)
   \       0x60   0x6BA9             LDR      R1,[R5, #+56]
   \       0x62   0x6CE8             LDR      R0,[R5, #+76]
   \       0x64   0x4281             CMP      R1,R0
   \       0x66   0xD102             BNE.N    ??vTaskSuspend_4
   1801                          {
   1802                              /* No other tasks are ready, so set pxCurrentTCB back to
   1803                               * NULL so when the next task is created pxCurrentTCB will
   1804                               * be set to point to it no matter what its relative priority
   1805                               * is. */
   1806                              pxCurrentTCB = NULL;
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x62A9             STR      R1,[R5, #+40]
   \       0x6C   0xBD31             POP      {R0,R4,R5,PC}
   1807                          }
   1808                          else
   1809                          {
   1810                              vTaskSwitchContext();
   \                     ??vTaskSuspend_4: (+1)
   \       0x6E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x72   0x....             B.N      vTaskSwitchContext
   1811                          }
   1812                      }
   1813                  }
   1814                  else
   1815                  {
   1816                      mtCOVERAGE_TEST_MARKER();
   1817                  }
   1818              }
   \                     ??vTaskSuspend_2: (+1)
   \       0x74   0xBD31             POP      {R0,R4,R5,PC}
   1819          
   1820          #endif /* INCLUDE_vTaskSuspend */
   1821          /*-----------------------------------------------------------*/
   1822          
   1823          #if ( INCLUDE_vTaskSuspend == 1 )
   1824          

   \                                 In section .text, align 2, keep-with-next
   1825              static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1826              {
   \                     prvTaskIsTaskSuspended: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1827                  BaseType_t xReturn = pdFALSE;
   \        0x4   0x2500             MOVS     R5,#+0
   1828                  const TCB_t * const pxTCB = xTask;
   1829          
   1830                  /* Accesses xPendingReadyList so must be called from a critical
   1831                   * section. */
   1832          
   1833                  /* It does not make sense to check if the calling task is suspended. */
   1834                  configASSERT( xTask );
   \        0x6   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_24
   \        0x8   0xF240 0x712A      MOVW     R1,#+1834
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   1835          
   1836                  /* Is the task being resumed actually in the suspended list? */
   1837                  if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x10   0x6962             LDR      R2,[R4, #+20]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable42
   \       0x16   0xF101 0x0038      ADD      R0,R1,#+56
   \       0x1A   0x4282             CMP      R2,R0
   \       0x1C   0xD104             BNE.N    ??prvTaskIsTaskSuspended_0
   1838                  {
   1839                      /* Has the task already been resumed from within an ISR? */
   1840                      if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   \       0x1E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD001             BEQ.N    ??prvTaskIsTaskSuspended_0
   1841                      {
   1842                          /* Is it in the suspended list because it is in the Suspended
   1843                           * state, or because is is blocked with no timeout? */
   1844                          if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
   \       0x24   0xB900             CBNZ.N   R0,??prvTaskIsTaskSuspended_0
   1845                          {
   1846                              xReturn = pdTRUE;
   \       0x26   0x2501             MOVS     R5,#+1
   1847                          }
   1848                          else
   1849                          {
   1850                              mtCOVERAGE_TEST_MARKER();
   1851                          }
   1852                      }
   1853                      else
   1854                      {
   1855                          mtCOVERAGE_TEST_MARKER();
   1856                      }
   1857                  }
   1858                  else
   1859                  {
   1860                      mtCOVERAGE_TEST_MARKER();
   1861                  }
   1862          
   1863                  return xReturn;
   \                     ??prvTaskIsTaskSuspended_0: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
   1864              } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1865          
   1866          #endif /* INCLUDE_vTaskSuspend */
   1867          /*-----------------------------------------------------------*/
   1868          
   1869          #if ( INCLUDE_vTaskSuspend == 1 )
   1870          

   \                                 In section .text, align 2, keep-with-next
   1871              void vTaskResume( TaskHandle_t xTaskToResume )
   1872              {
   \                     vTaskResume: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1873                  TCB_t * const pxTCB = xTaskToResume;
   1874          
   1875                  /* It does not make sense to resume the calling task. */
   1876                  configASSERT( xTaskToResume );
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable42
   \        0x8   0xD105             BNE.N    ??vTaskResume_0
   \        0xA   0xF240 0x7154      MOVW     R1,#+1876
   \        0xE   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x12   0x6AA9             LDR      R1,[R5, #+40]
   \       0x14   0xBD31             POP      {R0,R4,R5,PC}
   1877          
   1878                  /* The parameter cannot be NULL as it is impossible to resume the
   1879                   * currently executing task. */
   1880                  if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
   \                     ??vTaskResume_0: (+1)
   \       0x16   0x6AA8             LDR      R0,[R5, #+40]
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD018             BEQ.N    ??vTaskResume_1
   1881                  {
   1882                      taskENTER_CRITICAL();
   \       0x1C   0x.... 0x....      BL       vPortEnterCritical
   1883                      {
   1884                          if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       prvTaskIsTaskSuspended
   \       0x26   0xB170             CBZ.N    R0,??vTaskResume_2
   1885                          {
   1886                              traceTASK_RESUME( pxTCB );
   1887          
   1888                              /* The ready list can be accessed even if the scheduler is
   1889                               * suspended because this is inside a critical section. */
   1890                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x28   0x.... 0x....      BL       ?Subroutine14
   1891                              prvAddTaskToReadyList( pxTCB );
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0x2C   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0x30   0xBF38             IT       CC
   \       0x32   0x656A             STRCC    R2,[R5, #+84]
   \       0x34   0x.... 0x....      BL       ?Subroutine12
   1892          
   1893                              /* A higher priority task may have just been resumed. */
   1894                              if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x38   0x6AE0             LDR      R0,[R4, #+44]
   \       0x3A   0x6AAA             LDR      R2,[R5, #+40]
   \       0x3C   0x6AD1             LDR      R1,[R2, #+44]
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xBF28             IT       CS
   1895                              {
   1896                                  /* This yield may not cause the task just resumed to run,
   1897                                   * but will leave the lists in the correct state for the
   1898                                   * next yield. */
   1899                                  taskYIELD_IF_USING_PREEMPTION();
   \       0x42   0x.... 0x....      BLCS     vPortYield
   1900                              }
   1901                              else
   1902                              {
   1903                                  mtCOVERAGE_TEST_MARKER();
   1904                              }
   1905                          }
   1906                          else
   1907                          {
   1908                              mtCOVERAGE_TEST_MARKER();
   1909                          }
   1910                      }
   1911                      taskEXIT_CRITICAL();
   \                     ??vTaskResume_2: (+1)
   \       0x46   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x4A   0x.... 0x....      B.W      vPortExitCritical
   1912                  }
   1913                  else
   1914                  {
   1915                      mtCOVERAGE_TEST_MARKER();
   1916                  }
   1917              }
   \                     ??vTaskResume_1: (+1)
   \       0x4E   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x6AE2             LDR      R2,[R4, #+44]
   \        0x2   0x6D68             LDR      R0,[R5, #+84]
   \        0x4   0x4290             CMP      R0,R2
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x2014             MOVS     R0,#+20
   \        0x2   0x4342             MULS     R2,R0,R2
   \        0x4   0x.... 0x....      LDR.W    R3,??DataTable56
   \        0x8   0x1D21             ADDS     R1,R4,#+4
   \        0xA   0x1898             ADDS     R0,R3,R2
   \        0xC   0x.... 0x....      B.W      vListInsertEnd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x1D20             ADDS     R0,R4,#+4
   \        0x2   0x.... 0x....      B.W      uxListRemove
   1918          
   1919          #endif /* INCLUDE_vTaskSuspend */
   1920          
   1921          /*-----------------------------------------------------------*/
   1922          
   1923          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1924          

   \                                 In section .text, align 2, keep-with-next
   1925              BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1926              {
   \                     xTaskResumeFromISR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   1927                  BaseType_t xYieldRequired = pdFALSE;
   \        0x4   0x2500             MOVS     R5,#+0
   1928                  TCB_t * const pxTCB = xTaskToResume;
   1929                  UBaseType_t uxSavedInterruptStatus;
   1930          
   1931                  configASSERT( xTaskToResume );
   \        0x6   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_22
   \        0x8   0xF240 0x718B      MOVW     R1,#+1931
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   1932          
   1933                  /* RTOS ports that support interrupt nesting have the concept of a
   1934                   * maximum  system call (or maximum API call) interrupt priority.
   1935                   * Interrupts that are  above the maximum system call priority are keep
   1936                   * permanently enabled, even when the RTOS kernel is in a critical section,
   1937                   * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1938                   * is defined in FreeRTOSConfig.h then
   1939                   * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1940                   * failure if a FreeRTOS API function is called from an interrupt that has
   1941                   * been assigned a priority above the configured maximum system call
   1942                   * priority.  Only FreeRTOS functions that end in FromISR can be called
   1943                   * from interrupts  that have been assigned a priority at or (logically)
   1944                   * below the maximum system call interrupt priority.  FreeRTOS maintains a
   1945                   * separate interrupt safe API to ensure interrupt entry is as fast and as
   1946                   * simple as possible.  More information (albeit Cortex-M specific) is
   1947                   * provided on the following link:
   1948                   * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   1949                  portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1950          
   1951                  uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x10   0x.... 0x....      BL       ulSetInterruptMask
   \       0x14   0x4606             MOV      R6,R0
   1952                  {
   1953                      if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       prvTaskIsTaskSuspended
   \       0x1C   0xB1D0             CBZ.N    R0,??xTaskResumeFromISR_0
   1954                      {
   1955                          traceTASK_RESUME_FROM_ISR( pxTCB );
   1956          
   1957                          /* Check the ready lists can be accessed. */
   1958                          if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \       0x1E   0x.... 0x....      LDR.W    R7,??DataTable42
   \       0x22   0x6F78             LDR      R0,[R7, #+116]
   \       0x24   0xB988             CBNZ.N   R0,??xTaskResumeFromISR_1
   1959                          {
   1960                              /* Ready lists can be accessed so move the task from the
   1961                               * suspended list to the ready list directly. */
   1962                              if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x26   0x6AE0             LDR      R0,[R4, #+44]
   \       0x28   0x6ABA             LDR      R2,[R7, #+40]
   \       0x2A   0x6AD1             LDR      R1,[R2, #+44]
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD302             BCC.N    ??xTaskResumeFromISR_2
   1963                              {
   1964                                  xYieldRequired = pdTRUE;
   1965          
   1966                                  /* Mark that a yield is pending in case the user is not
   1967                                   * using the return value to initiate a context switch
   1968                                   * from the ISR using portYIELD_FROM_ISR. */
   1969                                  xYieldPending = pdTRUE;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x2501             MOVS     R5,#+1
   \       0x34   0x6638             STR      R0,[R7, #+96]
   1970                              }
   1971                              else
   1972                              {
   1973                                  mtCOVERAGE_TEST_MARKER();
   1974                              }
   1975          
   1976                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \                     ??xTaskResumeFromISR_2: (+1)
   \       0x36   0x.... 0x....      BL       ?Subroutine14
   1977                              prvAddTaskToReadyList( pxTCB );
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0x3A   0x6AE2             LDR      R2,[R4, #+44]
   \       0x3C   0x6D78             LDR      R0,[R7, #+84]
   \       0x3E   0x4290             CMP      R0,R2
   \       0x40   0xBF38             IT       CC
   \       0x42   0x657A             STRCC    R2,[R7, #+84]
   \       0x44   0x.... 0x....      BL       ?Subroutine17
   1978                          }
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0x48   0xE002             B.N      ??xTaskResumeFromISR_3
   1979                          else
   1980                          {
   1981                              /* The delayed or ready lists cannot be accessed so the task
   1982                               * is held in the pending ready list until the scheduler is
   1983                               * unsuspended. */
   1984                              vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeFromISR_1: (+1)
   \       0x4A   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x4E   0x4638             MOV      R0,R7
   \                     ??xTaskResumeFromISR_3: (+1)
   \       0x50   0x.... 0x....      BL       vListInsertEnd
   1985                          }
   1986                      }
   1987                      else
   1988                      {
   1989                          mtCOVERAGE_TEST_MARKER();
   1990                      }
   1991                  }
   1992                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskResumeFromISR_0: (+1)
   \       0x54   0x4630             MOV      R0,R6
   \       0x56   0x.... 0x....      BL       vClearInterruptMask
   1993          
   1994                  return xYieldRequired;
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0xBDF2             POP      {R1,R4-R7,PC}
   1995              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x2014             MOVS     R0,#+20
   \        0x2   0x4342             MULS     R2,R0,R2
   \        0x4   0x....             LDR.N    R3,??DataTable56
   \        0x6   0x1D21             ADDS     R1,R4,#+4
   \        0x8   0x1898             ADDS     R0,R3,R2
   \        0xA   0x4770             BX       LR
   1996          
   1997          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1998          /*-----------------------------------------------------------*/
   1999          

   \                                 In section .text, align 4, keep-with-next
   2000          void vTaskStartScheduler( void )
   2001          {
   \                     vTaskStartScheduler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   2002              BaseType_t xReturn;
   2003          
   2004              /* Add the idle task at the lowest priority. */
   2005              #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
   2006                  {
   2007                      StaticTask_t * pxIdleTaskTCBBuffer = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x9105             STR      R1,[SP, #+20]
   2008                      StackType_t * pxIdleTaskStackBuffer = NULL;
   \        0x8   0x9104             STR      R1,[SP, #+16]
   2009                      uint32_t ulIdleTaskStackSize;
   2010          
   2011                      /* The Idle task is created using user provided RAM - obtain the
   2012                       * address of the RAM then create the idle task. */
   2013                      vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   \        0xA   0xAA03             ADD      R2,SP,#+12
   \        0xC   0xA904             ADD      R1,SP,#+16
   \        0xE   0xA805             ADD      R0,SP,#+20
   \       0x10   0x.... 0x....      BL       vApplicationGetIdleTaskMemory
   2014                      xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
   2015                                                           configIDLE_TASK_NAME,
   2016                                                           ulIdleTaskStackSize,
   2017                                                           ( void * ) NULL,       /*lint !e961.  The cast is not redundant for all compilers. */
   2018                                                           portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
   2019                                                           pxIdleTaskStackBuffer,
   2020                                                           pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   2021          
   2022                      if( xIdleTaskHandle != NULL )
   \       0x14   0x9A05             LDR      R2,[SP, #+20]
   \       0x16   0x9904             LDR      R1,[SP, #+16]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x9202             STR      R2,[SP, #+8]
   \       0x1C   0x9A03             LDR      R2,[SP, #+12]
   \       0x1E   0x9101             STR      R1,[SP, #+4]
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x....             ADR.N    R1,?_1
   \       0x26   0x.... 0x....      ADR.W    R0,prvIdleTask
   \       0x2A   0x.... 0x....      LDR.W    R4,??DataTable42
   \       0x2E   0x.... 0x....      BL       xTaskCreateStatic
   \       0x32   0xB1B0             CBZ.N    R0,??CrossCallReturnLabel_21
   2023                      {
   2024                          xReturn = pdPASS;
   2025                      }
   2026                      else
   2027                      {
   2028                          xReturn = pdFAIL;
   2029                      }
   2030                  }
   2031              #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
   2032                  {
   2033                      /* The Idle task is being created using dynamically allocated RAM. */
   2034                      xReturn = xTaskCreate( prvIdleTask,
   2035                                             configIDLE_TASK_NAME,
   2036                                             configMINIMAL_STACK_SIZE,
   2037                                             ( void * ) NULL,
   2038                                             portPRIVILEGE_BIT,  /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
   2039                                             &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   2040                  }
   2041              #endif /* configSUPPORT_STATIC_ALLOCATION */
   2042          
   2043              #if ( configUSE_TIMERS == 1 )
   2044                  {
   2045                      if( xReturn == pdPASS )
   2046                      {
   2047                          xReturn = xTimerCreateTimerTask();
   \       0x34   0x.... 0x....      BL       xTimerCreateTimerTask
   2048                      }
   2049                      else
   2050                      {
   2051                          mtCOVERAGE_TEST_MARKER();
   2052                      }
   2053                  }
   2054              #endif /* configUSE_TIMERS */
   2055          
   2056              if( xReturn == pdPASS )
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD10B             BNE.N    ??vTaskStartScheduler_0
   2057              {
   2058                  /* freertos_tasks_c_additions_init() should only be called if the user
   2059                   * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
   2060                   * the only macro called by the function. */
   2061                  #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   2062                      {
   2063                          freertos_tasks_c_additions_init();
   2064                      }
   2065                  #endif
   2066          
   2067                  /* Interrupts are turned off here, to ensure a tick does not occur
   2068                   * before or during the call to xPortStartScheduler().  The stacks of
   2069                   * the created tasks contain a status word with interrupts switched on
   2070                   * so interrupts will automatically get re-enabled when the first task
   2071                   * starts to run. */
   2072                  portDISABLE_INTERRUPTS();
   \       0x3C   0x.... 0x....      BL       ulSetInterruptMask
   2073          
   2074                  #if ( configUSE_NEWLIB_REENTRANT == 1 )
   2075                      {
   2076                          /* Switch Newlib's _impure_ptr variable to point to the _reent
   2077                           * structure specific to the task that will run first.
   2078                           * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
   2079                           * for additional information. */
   2080                          _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2081                      }
   2082                  #endif /* configUSE_NEWLIB_REENTRANT */
   2083          
   2084                  xNextTaskUnblockTime = portMAX_DELAY;
   \       0x40   0xF04F 0x30FF      MOV      R0,#+4294967295
   \       0x44   0x66E0             STR      R0,[R4, #+108]
   2085                  xSchedulerRunning = pdTRUE;
   \       0x46   0x2101             MOVS     R1,#+1
   \       0x48   0x65A1             STR      R1,[R4, #+88]
   2086                  xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x6520             STR      R0,[R4, #+80]
   2087          
   2088                  /* If configGENERATE_RUN_TIME_STATS is defined then the following
   2089                   * macro must be defined to configure the timer/counter used to generate
   2090                   * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
   2091                   * is set to 0 and the following line fails to build then ensure you do not
   2092                   * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
   2093                   * FreeRTOSConfig.h file. */
   2094                  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   2095          
   2096                  traceTASK_SWITCHED_IN();
   2097          
   2098                  /* Setting up the timer tick is hardware specific and thus in the
   2099                   * portable interface. */
   2100                  if( xPortStartScheduler() != pdFALSE )
   \       0x4E   0x.... 0x....      BL       xPortStartScheduler
   \       0x52   0xE006             B.N      ??CrossCallReturnLabel_21
   2101                  {
   2102                      /* Should not reach here as if the scheduler is running the
   2103                       * function will not return. */
   2104                  }
   2105                  else
   2106                  {
   2107                      /* Should only reach here if a task calls xTaskEndScheduler(). */
   2108                  }
   2109              }
   2110              else
   2111              {
   2112                  /* This line will only be reached if the kernel could not be started,
   2113                   * because there was not enough FreeRTOS heap to create the idle task
   2114                   * or the timer task. */
   2115                  configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   \                     ??vTaskStartScheduler_0: (+1)
   \       0x54   0xF110 0x0F01      CMN      R0,#+1
   \       0x58   0xD103             BNE.N    ??CrossCallReturnLabel_21
   \       0x5A   0xF640 0x0143      MOVW     R1,#+2115
   \       0x5E   0x.... 0x....      BL       ?Subroutine5
   2116              }
   2117          
   2118              /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
   2119               * meaning xIdleTaskHandle is not used anywhere else. */
   2120              ( void ) xIdleTaskHandle;
   2121          
   2122              /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
   2123               * from getting optimized out as it is no longer used by the kernel. */
   2124              ( void ) uxTopUsedPriority;
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x62   0x6F20             LDR      R0,[R4, #+112]
   2125          }
   \       0x64   0xB006             ADD      SP,SP,#+24
   \       0x66   0xBD10             POP      {R4,PC}
   2126          /*-----------------------------------------------------------*/
   2127          

   \                                 In section .text, align 2, keep-with-next
   2128          void vTaskEndScheduler( void )
   2129          {
   \                     vTaskEndScheduler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2130              /* Stop the scheduler interrupts and call the portable scheduler end
   2131               * routine so the original ISRs can be restored if necessary.  The port
   2132               * layer must ensure interrupts enable  bit is left in the correct state. */
   2133              portDISABLE_INTERRUPTS();
   \        0x2   0x.... 0x....      BL       ulSetInterruptMask
   2134              xSchedulerRunning = pdFALSE;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable42
   \        0xC   0x6581             STR      R1,[R0, #+88]
   2135              vPortEndScheduler();
   \        0xE   0xE8BD 0x4001      POP      {R0,LR}
   \       0x12   0x.... 0x....      B.W      vPortEndScheduler
   2136          }
   2137          /*----------------------------------------------------------*/
   2138          

   \                                 In section .text, align 4, keep-with-next
   2139          void vTaskSuspendAll( void )
   2140          {
   2141              /* A critical section is not required as the variable is of type
   2142               * BaseType_t.  Please read Richard Barry's reply in the following link to a
   2143               * post in the FreeRTOS support forum before reporting this as a bug! -
   2144               * https://goo.gl/wu4acr */
   2145          
   2146              /* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
   2147               * do not otherwise exhibit real time behaviour. */
   2148              portSOFTWARE_BARRIER();
   2149          
   2150              /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
   2151               * is used to allow calls to vTaskSuspendAll() to nest. */
   2152              ++uxSchedulerSuspended;
   \                     vTaskSuspendAll: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable42
   \        0x4   0x6F48             LDR      R0,[R1, #+116]
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0x6748             STR      R0,[R1, #+116]
   2153          
   2154              /* Enforces ordering for ports and optimised compilers that may otherwise place
   2155               * the above increment elsewhere. */
   2156              portMEMORY_BARRIER();
   2157          }
   \        0xA   0x4770             BX       LR
   2158          /*----------------------------------------------------------*/
   2159          
   2160          #if ( configUSE_TICKLESS_IDLE != 0 )
   2161          
   2162              static TickType_t prvGetExpectedIdleTime( void )
   2163              {
   2164                  TickType_t xReturn;
   2165                  UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
   2166          
   2167                  /* uxHigherPriorityReadyTasks takes care of the case where
   2168                   * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
   2169                   * task that are in the Ready state, even though the idle task is
   2170                   * running. */
   2171                  #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
   2172                      {
   2173                          if( uxTopReadyPriority > tskIDLE_PRIORITY )
   2174                          {
   2175                              uxHigherPriorityReadyTasks = pdTRUE;
   2176                          }
   2177                      }
   2178                  #else
   2179                      {
   2180                          const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
   2181          
   2182                          /* When port optimised task selection is used the uxTopReadyPriority
   2183                           * variable is used as a bit map.  If bits other than the least
   2184                           * significant bit are set then there are tasks that have a priority
   2185                           * above the idle priority that are in the Ready state.  This takes
   2186                           * care of the case where the co-operative scheduler is in use. */
   2187                          if( uxTopReadyPriority > uxLeastSignificantBit )
   2188                          {
   2189                              uxHigherPriorityReadyTasks = pdTRUE;
   2190                          }
   2191                      }
   2192                  #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */
   2193          
   2194                  if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   2195                  {
   2196                      xReturn = 0;
   2197                  }
   2198                  else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   2199                  {
   2200                      /* There are other idle priority tasks in the ready state.  If
   2201                       * time slicing is used then the very next tick interrupt must be
   2202                       * processed. */
   2203                      xReturn = 0;
   2204                  }
   2205                  else if( uxHigherPriorityReadyTasks != pdFALSE )
   2206                  {
   2207                      /* There are tasks in the Ready state that have a priority above the
   2208                       * idle priority.  This path can only be reached if
   2209                       * configUSE_PREEMPTION is 0. */
   2210                      xReturn = 0;
   2211                  }
   2212                  else
   2213                  {
   2214                      xReturn = xNextTaskUnblockTime - xTickCount;
   2215                  }
   2216          
   2217                  return xReturn;
   2218              }
   2219          
   2220          #endif /* configUSE_TICKLESS_IDLE */
   2221          /*----------------------------------------------------------*/
   2222          

   \                                 In section .text, align 2, keep-with-next
   2223          BaseType_t xTaskResumeAll( void )
   2224          {
   \                     xTaskResumeAll: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   2225              TCB_t * pxTCB = NULL;
   2226              BaseType_t xAlreadyYielded = pdFALSE;
   2227          
   2228              /* If uxSchedulerSuspended is zero then this function does not match a
   2229               * previous call to vTaskSuspendAll(). */
   2230              configASSERT( uxSchedulerSuspended );
   \        0x2   0x.... 0x....      LDR.W    R6,??DataTable42
   \        0x6   0x6F70             LDR      R0,[R6, #+116]
   \        0x8   0x2400             MOVS     R4,#+0
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_20
   \        0xE   0xF640 0x01B6      MOVW     R1,#+2230
   \       0x12   0x.... 0x....      BL       ?Subroutine5
   2231          
   2232              /* It is possible that an ISR caused a task to be removed from an event
   2233               * list while the scheduler was suspended.  If this was the case then the
   2234               * removed task will have been added to the xPendingReadyList.  Once the
   2235               * scheduler has been resumed it is safe to move all the pending ready
   2236               * tasks from this list into their appropriate ready list. */
   2237              taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x16   0x.... 0x....      BL       vPortEnterCritical
   2238              {
   2239                  --uxSchedulerSuspended;
   \       0x1A   0x6F70             LDR      R0,[R6, #+116]
   \       0x1C   0x1E40             SUBS     R0,R0,#+1
   \       0x1E   0x6770             STR      R0,[R6, #+116]
   2240          
   2241                  if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \       0x20   0x6F70             LDR      R0,[R6, #+116]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD132             BNE.N    ??xTaskResumeAll_0
   2242                  {
   2243                      if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   \       0x26   0x6CF0             LDR      R0,[R6, #+76]
   \       0x28   0xB9D0             CBNZ.N   R0,??xTaskResumeAll_1
   \       0x2A   0xE02F             B.N      ??xTaskResumeAll_0
   2244                      {
   2245                          /* Move any readied tasks from the pending list into the
   2246                           * appropriate ready list. */
   2247                          while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   2248                          {
   2249                              pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \                     ??xTaskResumeAll_2: (+1)
   \       0x2C   0x68F0             LDR      R0,[R6, #+12]
   \       0x2E   0x68C4             LDR      R4,[R0, #+12]
   2250                              ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \       0x30   0x.... 0x....      BL       ?Subroutine15
   2251                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x34   0x.... 0x....      BL       ?Subroutine14
   2252                              prvAddTaskToReadyList( pxTCB );
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0x38   0x6AE3             LDR      R3,[R4, #+44]
   \       0x3A   0x6D70             LDR      R0,[R6, #+84]
   \       0x3C   0x4298             CMP      R0,R3
   \       0x3E   0xBF38             IT       CC
   \       0x40   0x6573             STRCC    R3,[R6, #+84]
   \       0x42   0x2214             MOVS     R2,#+20
   \       0x44   0x4353             MULS     R3,R2,R3
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable56
   \       0x4A   0x1D21             ADDS     R1,R4,#+4
   \       0x4C   0x4418             ADD      R0,R0,R3
   \       0x4E   0x.... 0x....      BL       vListInsertEnd
   2253          
   2254                              /* If the moved task has a priority higher than the current
   2255                               * task then a yield must be performed. */
   2256                              if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x52   0x6AE0             LDR      R0,[R4, #+44]
   \       0x54   0x6AB2             LDR      R2,[R6, #+40]
   \       0x56   0x6AD1             LDR      R1,[R2, #+44]
   \       0x58   0x4288             CMP      R0,R1
   \       0x5A   0xBF24             ITT      CS
   \       0x5C   0x2201             MOVCS    R2,#+1
   \       0x5E   0x6632             STRCS    R2,[R6, #+96]
   2257                              {
   2258                                  xYieldPending = pdTRUE;
   2259                              }
   2260                              else
   2261                              {
   2262                                  mtCOVERAGE_TEST_MARKER();
   2263                              }
   2264                          }
   \                     ??xTaskResumeAll_1: (+1)
   \       0x60   0x6830             LDR      R0,[R6, #+0]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD1E2             BNE.N    ??xTaskResumeAll_2
   2265          
   2266                          if( pxTCB != NULL )
   \       0x66   0xB10C             CBZ.N    R4,??xTaskResumeAll_3
   2267                          {
   2268                              /* A task was unblocked while the scheduler was suspended,
   2269                               * which may have prevented the next unblock time from being
   2270                               * re-calculated, in which case re-calculate it now.  Mainly
   2271                               * important for low power tickless implementations, where
   2272                               * this can prevent an unnecessary exit from low power
   2273                               * state. */
   2274                              prvResetNextTaskUnblockTime();
   \       0x68   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   2275                          }
   2276          
   2277                          /* If any ticks occurred while the scheduler was suspended then
   2278                           * they should be processed now.  This ensures the tick count does
   2279                           * not  slip, and that any delayed tasks are resumed at the correct
   2280                           * time. */
   2281                          {
   2282                              TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
   \                     ??xTaskResumeAll_3: (+1)
   \       0x6C   0x6DF4             LDR      R4,[R6, #+92]
   2283          
   2284                              if( xPendedCounts > ( TickType_t ) 0U )
   \       0x6E   0xB144             CBZ.N    R4,??xTaskResumeAll_4
   2285                              {
   2286                                  do
   2287                                  {
   2288                                      if( xTaskIncrementTick() != pdFALSE )
   \                     ??xTaskResumeAll_5: (+1)
   \       0x70   0x.... 0x....      BL       xTaskIncrementTick
   \       0x74   0xB108             CBZ.N    R0,??xTaskResumeAll_6
   2289                                      {
   2290                                          xYieldPending = pdTRUE;
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0x6630             STR      R0,[R6, #+96]
   2291                                      }
   2292                                      else
   2293                                      {
   2294                                          mtCOVERAGE_TEST_MARKER();
   2295                                      }
   2296          
   2297                                      --xPendedCounts;
   \                     ??xTaskResumeAll_6: (+1)
   \       0x7A   0x1E64             SUBS     R4,R4,#+1
   2298                                  } while( xPendedCounts > ( TickType_t ) 0U );
   \       0x7C   0xD1F8             BNE.N    ??xTaskResumeAll_5
   2299          
   2300                                  xPendedTicks = 0;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x65F0             STR      R0,[R6, #+92]
   2301                              }
   2302                              else
   2303                              {
   2304                                  mtCOVERAGE_TEST_MARKER();
   2305                              }
   2306                          }
   2307          
   2308                          if( xYieldPending != pdFALSE )
   \                     ??xTaskResumeAll_4: (+1)
   \       0x82   0x6E30             LDR      R0,[R6, #+96]
   \       0x84   0xB110             CBZ.N    R0,??xTaskResumeAll_0
   2309                          {
   2310                              #if ( configUSE_PREEMPTION != 0 )
   2311                                  {
   2312                                      xAlreadyYielded = pdTRUE;
   \       0x86   0x2501             MOVS     R5,#+1
   2313                                  }
   2314                              #endif
   2315                              taskYIELD_IF_USING_PREEMPTION();
   \       0x88   0x.... 0x....      BL       vPortYield
   2316                          }
   2317                          else
   2318                          {
   2319                              mtCOVERAGE_TEST_MARKER();
   2320                          }
   2321                      }
   2322                  }
   2323                  else
   2324                  {
   2325                      mtCOVERAGE_TEST_MARKER();
   2326                  }
   2327              }
   2328              taskEXIT_CRITICAL();
   \                     ??xTaskResumeAll_0: (+1)
   \       0x8C   0x.... 0x....      BL       vPortExitCritical
   2329          
   2330              return xAlreadyYielded;
   \       0x90   0x4628             MOV      R0,R5
   \       0x92   0xBD70             POP      {R4-R6,PC}
   2331          }
   2332          /*-----------------------------------------------------------*/
   2333          

   \                                 In section .text, align 2, keep-with-next
   2334          TickType_t xTaskGetTickCount( void )
   2335          {
   2336              TickType_t xTicks;
   2337          
   2338              /* Critical section required if running on a 16 bit processor. */
   2339              portTICK_TYPE_ENTER_CRITICAL();
   2340              {
   2341                  xTicks = xTickCount;
   2342              }
   2343              portTICK_TYPE_EXIT_CRITICAL();
   2344          
   2345              return xTicks;
   \                     xTaskGetTickCount: (+1)
   \        0x0   0x....             B.N      ?Subroutine1
   2346          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \        0x4   0x6D00             LDR      R0,[R0, #+80]
   \        0x6   0x4770             BX       LR
   2347          /*-----------------------------------------------------------*/
   2348          

   \                                 In section .text, align 4, keep-with-next
   2349          TickType_t xTaskGetTickCountFromISR( void )
   2350          {
   2351              TickType_t xReturn;
   2352              UBaseType_t uxSavedInterruptStatus;
   2353          
   2354              /* RTOS ports that support interrupt nesting have the concept of a maximum
   2355               * system call (or maximum API call) interrupt priority.  Interrupts that are
   2356               * above the maximum system call priority are kept permanently enabled, even
   2357               * when the RTOS kernel is in a critical section, but cannot make any calls to
   2358               * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   2359               * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   2360               * failure if a FreeRTOS API function is called from an interrupt that has been
   2361               * assigned a priority above the configured maximum system call priority.
   2362               * Only FreeRTOS functions that end in FromISR can be called from interrupts
   2363               * that have been assigned a priority at or (logically) below the maximum
   2364               * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
   2365               * safe API to ensure interrupt entry is as fast and as simple as possible.
   2366               * More information (albeit Cortex-M specific) is provided on the following
   2367               * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   2368              portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   2369          
   2370              uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   2371              {
   2372                  xReturn = xTickCount;
   2373              }
   2374              portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   2375          
   2376              return xReturn;
   \                     xTaskGetTickCountFromISR: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine1
   \        0x2                      ;; // Fall through to label ?Subroutine1
   2377          }
   2378          /*-----------------------------------------------------------*/
   2379          

   \                                 In section .text, align 2, keep-with-next
   2380          UBaseType_t uxTaskGetNumberOfTasks( void )
   2381          {
   2382              /* A critical section is not required because the variables are of type
   2383               * BaseType_t. */
   2384              return uxCurrentNumberOfTasks;
   \                     uxTaskGetNumberOfTasks: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \        0x4   0x6CC0             LDR      R0,[R0, #+76]
   \        0x6   0x4770             BX       LR
   2385          }
   2386          /*-----------------------------------------------------------*/
   2387          

   \                                 In section .text, align 2, keep-with-next
   2388          char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2389          {
   \                     pcTaskGetName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2390              TCB_t * pxTCB;
   2391          
   2392              /* If null is passed in here then the name of the calling task is being
   2393               * queried. */
   2394              pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   \        0x4   0xBF02             ITTT     EQ
   \        0x6   0x.... 0x....      LDREQ.W  R0,??DataTable56_1
   \        0xA   0x6A84             LDREQ    R4,[R0, #+40]
   \        0xC   0x2C00             CMPEQ    R4,#+0
   2395              configASSERT( pxTCB );
   \        0xE   0xD103             BNE.N    ??CrossCallReturnLabel_19
   \       0x10   0xF640 0x115B      MOVW     R1,#+2395
   \       0x14   0x.... 0x....      BL       ?Subroutine5
   2396              return &( pxTCB->pcTaskName[ 0 ] );
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x18   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x1C   0xBD10             POP      {R4,PC}
   2397          }
   2398          /*-----------------------------------------------------------*/
   2399          
   2400          #if ( INCLUDE_xTaskGetHandle == 1 )
   2401          
   2402              static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
   2403                                                               const char pcNameToQuery[] )
   2404              {
   2405                  TCB_t * pxNextTCB, * pxFirstTCB, * pxReturn = NULL;
   2406                  UBaseType_t x;
   2407                  char cNextChar;
   2408                  BaseType_t xBreakLoop;
   2409          
   2410                  /* This function is called with the scheduler suspended. */
   2411          
   2412                  if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   2413                  {
   2414                      listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2415          
   2416                      do
   2417                      {
   2418                          listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2419          
   2420                          /* Check each character in the name looking for a match or
   2421                           * mismatch. */
   2422                          xBreakLoop = pdFALSE;
   2423          
   2424                          for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2425                          {
   2426                              cNextChar = pxNextTCB->pcTaskName[ x ];
   2427          
   2428                              if( cNextChar != pcNameToQuery[ x ] )
   2429                              {
   2430                                  /* Characters didn't match. */
   2431                                  xBreakLoop = pdTRUE;
   2432                              }
   2433                              else if( cNextChar == ( char ) 0x00 )
   2434                              {
   2435                                  /* Both strings terminated, a match must have been
   2436                                   * found. */
   2437                                  pxReturn = pxNextTCB;
   2438                                  xBreakLoop = pdTRUE;
   2439                              }
   2440                              else
   2441                              {
   2442                                  mtCOVERAGE_TEST_MARKER();
   2443                              }
   2444          
   2445                              if( xBreakLoop != pdFALSE )
   2446                              {
   2447                                  break;
   2448                              }
   2449                          }
   2450          
   2451                          if( pxReturn != NULL )
   2452                          {
   2453                              /* The handle has been found. */
   2454                              break;
   2455                          }
   2456                      } while( pxNextTCB != pxFirstTCB );
   2457                  }
   2458                  else
   2459                  {
   2460                      mtCOVERAGE_TEST_MARKER();
   2461                  }
   2462          
   2463                  return pxReturn;
   2464              }
   2465          
   2466          #endif /* INCLUDE_xTaskGetHandle */
   2467          /*-----------------------------------------------------------*/
   2468          
   2469          #if ( INCLUDE_xTaskGetHandle == 1 )
   2470          
   2471              TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2472              {
   2473                  UBaseType_t uxQueue = configMAX_PRIORITIES;
   2474                  TCB_t * pxTCB;
   2475          
   2476                  /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
   2477                  configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
   2478          
   2479                  vTaskSuspendAll();
   2480                  {
   2481                      /* Search the ready lists. */
   2482                      do
   2483                      {
   2484                          uxQueue--;
   2485                          pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
   2486          
   2487                          if( pxTCB != NULL )
   2488                          {
   2489                              /* Found the handle. */
   2490                              break;
   2491                          }
   2492                      } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2493          
   2494                      /* Search the delayed lists. */
   2495                      if( pxTCB == NULL )
   2496                      {
   2497                          pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
   2498                      }
   2499          
   2500                      if( pxTCB == NULL )
   2501                      {
   2502                          pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
   2503                      }
   2504          
   2505                      #if ( INCLUDE_vTaskSuspend == 1 )
   2506                          {
   2507                              if( pxTCB == NULL )
   2508                              {
   2509                                  /* Search the suspended list. */
   2510                                  pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
   2511                              }
   2512                          }
   2513                      #endif
   2514          
   2515                      #if ( INCLUDE_vTaskDelete == 1 )
   2516                          {
   2517                              if( pxTCB == NULL )
   2518                              {
   2519                                  /* Search the deleted list. */
   2520                                  pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
   2521                              }
   2522                          }
   2523                      #endif
   2524                  }
   2525                  ( void ) xTaskResumeAll();
   2526          
   2527                  return pxTCB;
   2528              }
   2529          
   2530          #endif /* INCLUDE_xTaskGetHandle */
   2531          /*-----------------------------------------------------------*/
   2532          
   2533          #if ( configUSE_TRACE_FACILITY == 1 )
   2534          

   \                                 In section .text, align 2, keep-with-next
   2535              UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
   2536                                                const UBaseType_t uxArraySize,
   2537                                                uint32_t * const pulTotalRunTime )
   2538              {
   \                     uxTaskGetSystemState: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x4616             MOV      R6,R2
   2539                  UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   2540          
   2541                  vTaskSuspendAll();
   \        0xA   0x.... 0x....      BL       vTaskSuspendAll
   2542                  {
   2543                      /* Is there a space in the array for each task in the system? */
   2544                      if( uxArraySize >= uxCurrentNumberOfTasks )
   \        0xE   0x.... 0x....      LDR.W    R7,??DataTable42
   \       0x12   0x6CF8             LDR      R0,[R7, #+76]
   \       0x14   0x2500             MOVS     R5,#+0
   \       0x16   0x2438             MOVS     R4,#+56
   \       0x18   0x4581             CMP      R9,R0
   \       0x1A   0xD332             BCC.N    ??uxTaskGetSystemState_0
   2545                      {
   2546                          /* Fill in an TaskStatus_t structure with information on each
   2547                           * task in the Ready state. */
   2548                          do
   2549                          {
   2550                              uxQueue--;
   \                     ??uxTaskGetSystemState_1: (+1)
   \       0x1C   0x1E64             SUBS     R4,R4,#+1
   2551                              uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   \       0x1E   0x2014             MOVS     R0,#+20
   \       0x20   0x4360             MULS     R0,R0,R4
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable56
   \       0x26   0xF04F 0x0924      MOV      R9,#+36
   \       0x2A   0x4401             ADD      R1,R1,R0
   \       0x2C   0xFB09 0xF005      MUL      R0,R9,R5
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x.... 0x....      BL       ??Subroutine11_0
   2552                          } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0x36   0x1945             ADDS     R5,R0,R5
   \       0x38   0x2C00             CMP      R4,#+0
   \       0x3A   0xD1EF             BNE.N    ??uxTaskGetSystemState_1
   2553          
   2554                          /* Fill in an TaskStatus_t structure with information on each
   2555                           * task in the Blocked state. */
   2556                          uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   \       0x3C   0xFB09 0xF005      MUL      R0,R9,R5
   \       0x40   0x6AF9             LDR      R1,[R7, #+44]
   \       0x42   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0x46   0xEB00 0x0A05      ADD      R10,R0,R5
   2557                          uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   \       0x4A   0xFB09 0xF00A      MUL      R0,R9,R10
   \       0x4E   0x6B39             LDR      R1,[R7, #+48]
   \       0x50   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x54   0x4482             ADD      R10,R0,R10
   2558          
   2559                          #if ( INCLUDE_vTaskDelete == 1 )
   2560                              {
   2561                                  /* Fill in an TaskStatus_t structure with information on
   2562                                   * each task that has been deleted but not yet cleaned up. */
   2563                                  uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   \       0x56   0xFB09 0xF00A      MUL      R0,R9,R10
   \       0x5A   0x2204             MOVS     R2,#+4
   \       0x5C   0xF107 0x0114      ADD      R1,R7,#+20
   \       0x60   0x.... 0x....      BL       ??Subroutine11_0
   2564                              }
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0x64   0x4482             ADD      R10,R0,R10
   2565                          #endif
   2566          
   2567                          #if ( INCLUDE_vTaskSuspend == 1 )
   2568                              {
   2569                                  /* Fill in an TaskStatus_t structure with information on
   2570                                   * each task in the Suspended state. */
   2571                                  uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   \       0x66   0xFB09 0xF30A      MUL      R3,R9,R10
   \       0x6A   0x2203             MOVS     R2,#+3
   \       0x6C   0xF107 0x0138      ADD      R1,R7,#+56
   \       0x70   0xEB08 0x0003      ADD      R0,R8,R3
   \       0x74   0x.... 0x....      BL       prvListTasksWithinSingleList
   \       0x78   0xEB00 0x050A      ADD      R5,R0,R10
   2572                              }
   2573                          #endif
   2574          
   2575                          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   2576                              {
   2577                                  if( pulTotalRunTime != NULL )
   2578                                  {
   2579                                      #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2580                                          portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   2581                                      #else
   2582                                          *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2583                                      #endif
   2584                                  }
   2585                              }
   2586                          #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
   2587                              {
   2588                                  if( pulTotalRunTime != NULL )
   \       0x7C   0xB10E             CBZ.N    R6,??uxTaskGetSystemState_0
   2589                                  {
   2590                                      *pulTotalRunTime = 0;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x6030             STR      R0,[R6, #+0]
   2591                                  }
   2592                              }
   2593                          #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
   2594                      }
   2595                      else
   2596                      {
   2597                          mtCOVERAGE_TEST_MARKER();
   2598                      }
   2599                  }
   2600                  ( void ) xTaskResumeAll();
   \                     ??uxTaskGetSystemState_0: (+1)
   \       0x82   0x.... 0x....      BL       xTaskResumeAll
   2601          
   2602                  return uxTask;
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2603              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x2202             MOVS     R2,#+2
   \                     ??Subroutine11_0: (+1)
   \        0x2   0x4440             ADD      R0,R8,R0
   \        0x4   0x....             B.N      prvListTasksWithinSingleList
   2604          
   2605          #endif /* configUSE_TRACE_FACILITY */
   2606          /*----------------------------------------------------------*/
   2607          
   2608          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   2609          
   2610              TaskHandle_t xTaskGetIdleTaskHandle( void )
   2611              {
   2612                  /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   2613                   * started, then xIdleTaskHandle will be NULL. */
   2614                  configASSERT( ( xIdleTaskHandle != NULL ) );
   2615                  return xIdleTaskHandle;
   2616              }
   2617          
   2618          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   2619          /*----------------------------------------------------------*/
   2620          
   2621          /* This conditional compilation should use inequality to 0, not equality to 1.
   2622           * This is to ensure vTaskStepTick() is available when user defined low power mode
   2623           * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   2624           * 1. */
   2625          #if ( configUSE_TICKLESS_IDLE != 0 )
   2626          
   2627              void vTaskStepTick( const TickType_t xTicksToJump )
   2628              {
   2629                  /* Correct the tick count value after a period during which the tick
   2630                   * was suppressed.  Note this does *not* call the tick hook function for
   2631                   * each stepped tick. */
   2632                  configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   2633                  xTickCount += xTicksToJump;
   2634                  traceINCREASE_TICK_COUNT( xTicksToJump );
   2635              }
   2636          
   2637          #endif /* configUSE_TICKLESS_IDLE */
   2638          /*----------------------------------------------------------*/
   2639          

   \                                 In section .text, align 2, keep-with-next
   2640          BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
   2641          {
   \                     xTaskCatchUpTicks: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   2642              BaseType_t xYieldOccurred;
   2643          
   2644              /* Must not be called with the scheduler suspended as the implementation
   2645               * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
   2646              configASSERT( uxSchedulerSuspended == 0 );
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable42
   \        0x8   0x6F60             LDR      R0,[R4, #+116]
   \        0xA   0xB118             CBZ.N    R0,??CrossCallReturnLabel_18
   \        0xC   0xF640 0x2156      MOVW     R1,#+2646
   \       0x10   0x.... 0x....      BL       ?Subroutine5
   2647          
   2648              /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
   2649               * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
   2650              vTaskSuspendAll();
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x14   0x.... 0x....      BL       vTaskSuspendAll
   2651              xPendedTicks += xTicksToCatchUp;
   \       0x18   0x6DE0             LDR      R0,[R4, #+92]
   \       0x1A   0x182D             ADDS     R5,R5,R0
   \       0x1C   0x65E5             STR      R5,[R4, #+92]
   2652              xYieldOccurred = xTaskResumeAll();
   2653          
   2654              return xYieldOccurred;
   \       0x1E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x22   0x....             B.N      xTaskResumeAll
   2655          }
   2656          /*----------------------------------------------------------*/
   2657          
   2658          #if ( INCLUDE_xTaskAbortDelay == 1 )
   2659          
   2660              BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
   2661              {
   2662                  TCB_t * pxTCB = xTask;
   2663                  BaseType_t xReturn;
   2664          
   2665                  configASSERT( pxTCB );
   2666          
   2667                  vTaskSuspendAll();
   2668                  {
   2669                      /* A task can only be prematurely removed from the Blocked state if
   2670                       * it is actually in the Blocked state. */
   2671                      if( eTaskGetState( xTask ) == eBlocked )
   2672                      {
   2673                          xReturn = pdPASS;
   2674          
   2675                          /* Remove the reference to the task from the blocked list.  An
   2676                           * interrupt won't touch the xStateListItem because the
   2677                           * scheduler is suspended. */
   2678                          ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2679          
   2680                          /* Is the task waiting on an event also?  If so remove it from
   2681                           * the event list too.  Interrupts can touch the event list item,
   2682                           * even though the scheduler is suspended, so a critical section
   2683                           * is used. */
   2684                          taskENTER_CRITICAL();
   2685                          {
   2686                              if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2687                              {
   2688                                  ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2689          
   2690                                  /* This lets the task know it was forcibly removed from the
   2691                                   * blocked state so it should not re-evaluate its block time and
   2692                                   * then block again. */
   2693                                  pxTCB->ucDelayAborted = pdTRUE;
   2694                              }
   2695                              else
   2696                              {
   2697                                  mtCOVERAGE_TEST_MARKER();
   2698                              }
   2699                          }
   2700                          taskEXIT_CRITICAL();
   2701          
   2702                          /* Place the unblocked task into the appropriate ready list. */
   2703                          prvAddTaskToReadyList( pxTCB );
   2704          
   2705                          /* A task being unblocked cannot cause an immediate context
   2706                           * switch if preemption is turned off. */
   2707                          #if ( configUSE_PREEMPTION == 1 )
   2708                              {
   2709                                  /* Preemption is on, but a context switch should only be
   2710                                   *  performed if the unblocked task has a priority that is
   2711                                   *  equal to or higher than the currently executing task. */
   2712                                  if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   2713                                  {
   2714                                      /* Pend the yield to be performed when the scheduler
   2715                                       * is unsuspended. */
   2716                                      xYieldPending = pdTRUE;
   2717                                  }
   2718                                  else
   2719                                  {
   2720                                      mtCOVERAGE_TEST_MARKER();
   2721                                  }
   2722                              }
   2723                          #endif /* configUSE_PREEMPTION */
   2724                      }
   2725                      else
   2726                      {
   2727                          xReturn = pdFAIL;
   2728                      }
   2729                  }
   2730                  ( void ) xTaskResumeAll();
   2731          
   2732                  return xReturn;
   2733              }
   2734          
   2735          #endif /* INCLUDE_xTaskAbortDelay */
   2736          /*----------------------------------------------------------*/
   2737          

   \                                 In section .text, align 2, keep-with-next
   2738          BaseType_t xTaskIncrementTick( void )
   2739          {
   \                     xTaskIncrementTick: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   2740              TCB_t * pxTCB;
   2741              TickType_t xItemValue;
   2742              BaseType_t xSwitchRequired = pdFALSE;
   2743          
   2744              /* Called by the portable layer each time a tick interrupt occurs.
   2745               * Increments the tick then checks to see if the new tick value will cause any
   2746               * tasks to be unblocked. */
   2747              traceTASK_INCREMENT_TICK( xTickCount );
   2748          
   2749              if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable42
   \        0x8   0x6F70             LDR      R0,[R6, #+116]
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD151             BNE.N    ??xTaskIncrementTick_0
   2750              {
   2751                  /* Minor optimisation.  The tick count cannot change in this
   2752                   * block. */
   2753                  const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   \       0x10   0x6D34             LDR      R4,[R6, #+80]
   \       0x12   0x1C64             ADDS     R4,R4,#+1
   2754          
   2755                  /* Increment the RTOS tick, switching the delayed and overflowed
   2756                   * delayed lists if it wraps to 0. */
   2757                  xTickCount = xConstTickCount;
   \       0x14   0x6534             STR      R4,[R6, #+80]
   2758          
   2759                  if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   \       0x16   0xD10F             BNE.N    ??xTaskIncrementTick_1
   2760                  {
   2761                      taskSWITCH_DELAYED_LISTS();
   \       0x18   0x6AF0             LDR      R0,[R6, #+44]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xB118             CBZ.N    R0,??CrossCallReturnLabel_17
   \       0x1E   0xF640 0x21C9      MOVW     R1,#+2761
   \       0x22   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x26   0x6AF1             LDR      R1,[R6, #+44]
   \       0x28   0x6B30             LDR      R0,[R6, #+48]
   \       0x2A   0x62F0             STR      R0,[R6, #+44]
   \       0x2C   0x6331             STR      R1,[R6, #+48]
   \       0x2E   0x6E70             LDR      R0,[R6, #+100]
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0x6670             STR      R0,[R6, #+100]
   \       0x34   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   2762                  }
   2763                  else
   2764                  {
   2765                      mtCOVERAGE_TEST_MARKER();
   2766                  }
   2767          
   2768                  /* See if this tick has made a timeout expire.  Tasks are stored in
   2769                   * the  queue in the order of their wake time - meaning once one task
   2770                   * has been found whose block time has not expired there is no need to
   2771                   * look any further down the list. */
   2772                  if( xConstTickCount >= xNextTaskUnblockTime )
   \                     ??xTaskIncrementTick_1: (+1)
   \       0x38   0x6EF0             LDR      R0,[R6, #+108]
   \       0x3A   0xF04F 0x0914      MOV      R9,#+20
   \       0x3E   0x.... 0x....      LDR.W    R8,??DataTable56
   \       0x42   0x4284             CMP      R4,R0
   \       0x44   0xD327             BCC.N    ??xTaskIncrementTick_2
   \       0x46   0xE01F             B.N      ??xTaskIncrementTick_3
   2773                  {
   2774                      for( ; ; )
   2775                      {
   2776                          if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2777                          {
   2778                              /* The delayed list is empty.  Set xNextTaskUnblockTime
   2779                               * to the maximum possible value so it is extremely
   2780                               * unlikely that the
   2781                               * if( xTickCount >= xNextTaskUnblockTime ) test will pass
   2782                               * next time through. */
   2783                              xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2784                              break;
   2785                          }
   2786                          else
   2787                          {
   2788                              /* The delayed list is not empty, get the value of the
   2789                               * item at the head of the delayed list.  This is the time
   2790                               * at which the task at the head of the delayed list must
   2791                               * be removed from the Blocked state. */
   2792                              pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \                     ??xTaskIncrementTick_4: (+1)
   \       0x48   0x6AF1             LDR      R1,[R6, #+44]
   \       0x4A   0x68C8             LDR      R0,[R1, #+12]
   \       0x4C   0x68C7             LDR      R7,[R0, #+12]
   2793                              xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   \       0x4E   0x6878             LDR      R0,[R7, #+4]
   2794          
   2795                              if( xConstTickCount < xItemValue )
   \       0x50   0x4284             CMP      R4,R0
   \       0x52   0xD32D             BCC.N    ??xTaskIncrementTick_5
   2796                              {
   2797                                  /* It is not time to unblock this item yet, but the
   2798                                   * item value is the time at which the task at the head
   2799                                   * of the blocked list must be removed from the Blocked
   2800                                   * state -  so record the item value in
   2801                                   * xNextTaskUnblockTime. */
   2802                                  xNextTaskUnblockTime = xItemValue;
   2803                                  break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   2804                              }
   2805                              else
   2806                              {
   2807                                  mtCOVERAGE_TEST_MARKER();
   2808                              }
   2809          
   2810                              /* It is time to remove the item from the Blocked state. */
   2811                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x54   0x1D38             ADDS     R0,R7,#+4
   \       0x56   0x.... 0x....      BL       uxListRemove
   2812          
   2813                              /* Is the task waiting on an event also?  If so remove
   2814                               * it from the event list. */
   2815                              if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \       0x5A   0x6AB8             LDR      R0,[R7, #+40]
   \       0x5C   0xB118             CBZ.N    R0,??xTaskIncrementTick_6
   2816                              {
   2817                                  ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \       0x5E   0xF107 0x0018      ADD      R0,R7,#+24
   \       0x62   0x.... 0x....      BL       uxListRemove
   2818                              }
   2819                              else
   2820                              {
   2821                                  mtCOVERAGE_TEST_MARKER();
   2822                              }
   2823          
   2824                              /* Place the unblocked task into the appropriate ready
   2825                               * list. */
   2826                              prvAddTaskToReadyList( pxTCB );
   \                     ??xTaskIncrementTick_6: (+1)
   \       0x66   0x6AF8             LDR      R0,[R7, #+44]
   \       0x68   0x6D71             LDR      R1,[R6, #+84]
   \       0x6A   0x4281             CMP      R1,R0
   \       0x6C   0xBF38             IT       CC
   \       0x6E   0x6570             STRCC    R0,[R6, #+84]
   \       0x70   0xFB09 0xF000      MUL      R0,R9,R0
   \       0x74   0x1D39             ADDS     R1,R7,#+4
   \       0x76   0x4440             ADD      R0,R8,R0
   \       0x78   0x.... 0x....      BL       vListInsertEnd
   2827          
   2828                              /* A task being unblocked cannot cause an immediate
   2829                               * context switch if preemption is turned off. */
   2830                              #if ( configUSE_PREEMPTION == 1 )
   2831                                  {
   2832                                      /* Preemption is on, but a context switch should
   2833                                       * only be performed if the unblocked task has a
   2834                                       * priority that is equal to or higher than the
   2835                                       * currently executing task. */
   2836                                      if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x7C   0x6AF8             LDR      R0,[R7, #+44]
   \       0x7E   0x6AB2             LDR      R2,[R6, #+40]
   \       0x80   0x6AD1             LDR      R1,[R2, #+44]
   \       0x82   0x4288             CMP      R0,R1
   \       0x84   0xBF28             IT       CS
   \       0x86   0x2501             MOVCS    R5,#+1
   2837                                      {
   2838                                          xSwitchRequired = pdTRUE;
   2839                                      }
   2840                                      else
   2841                                      {
   2842                                          mtCOVERAGE_TEST_MARKER();
   2843                                      }
   2844                                  }
   \                     ??xTaskIncrementTick_3: (+1)
   \       0x88   0x6AF0             LDR      R0,[R6, #+44]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD1DB             BNE.N    ??xTaskIncrementTick_4
   \       0x90   0xF04F 0x31FF      MOV      R1,#+4294967295
   \       0x94   0x66F1             STR      R1,[R6, #+108]
   2845                              #endif /* configUSE_PREEMPTION */
   2846                          }
   2847                      }
   2848                  }
   2849          
   2850                  /* Tasks of equal priority to the currently running task will share
   2851                   * processing time (time slice) if preemption is on, and the application
   2852                   * writer has not explicitly turned time slicing off. */
   2853                  #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2854                      {
   2855                          if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   \                     ??xTaskIncrementTick_2: (+1)
   \       0x96   0x6AB0             LDR      R0,[R6, #+40]
   \       0x98   0x6AC0             LDR      R0,[R0, #+44]
   \       0x9A   0xFB09 0xF900      MUL      R9,R9,R0
   \       0x9E   0xF858 0x1009      LDR      R1,[R8, R9]
   \       0xA2   0x2902             CMP      R1,#+2
   \       0xA4   0xBF28             IT       CS
   \       0xA6   0x2501             MOVCS    R5,#+1
   2856                          {
   2857                              xSwitchRequired = pdTRUE;
   2858                          }
   2859                          else
   2860                          {
   2861                              mtCOVERAGE_TEST_MARKER();
   2862                          }
   2863                      }
   2864                  #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2865          
   2866                  #if ( configUSE_TICK_HOOK == 1 )
   2867                      {
   2868                          /* Guard against the tick hook being called when the pended tick
   2869                           * count is being unwound (when the scheduler is being unlocked). */
   2870                          if( xPendedTicks == ( TickType_t ) 0 )
   2871                          {
   2872                              vApplicationTickHook();
   2873                          }
   2874                          else
   2875                          {
   2876                              mtCOVERAGE_TEST_MARKER();
   2877                          }
   2878                      }
   2879                  #endif /* configUSE_TICK_HOOK */
   2880          
   2881                  #if ( configUSE_PREEMPTION == 1 )
   2882                      {
   2883                          if( xYieldPending != pdFALSE )
   \       0xA8   0x6E30             LDR      R0,[R6, #+96]
   \       0xAA   0xB130             CBZ.N    R0,??xTaskIncrementTick_7
   2884                          {
   2885                              xSwitchRequired = pdTRUE;
   \       0xAC   0x2501             MOVS     R5,#+1
   \       0xAE   0xE004             B.N      ??xTaskIncrementTick_7
   2886                          }
   2887                          else
   2888                          {
   2889                              mtCOVERAGE_TEST_MARKER();
   2890                          }
   2891                      }
   \                     ??xTaskIncrementTick_5: (+1)
   \       0xB0   0x66F0             STR      R0,[R6, #+108]
   \       0xB2   0xE7F0             B.N      ??xTaskIncrementTick_2
   2892                  #endif /* configUSE_PREEMPTION */
   2893              }
   2894              else
   2895              {
   2896                  ++xPendedTicks;
   \                     ??xTaskIncrementTick_0: (+1)
   \       0xB4   0x6DF0             LDR      R0,[R6, #+92]
   \       0xB6   0x1C40             ADDS     R0,R0,#+1
   \       0xB8   0x65F0             STR      R0,[R6, #+92]
   2897          
   2898                  /* The tick hook gets called at regular intervals, even if the
   2899                   * scheduler is locked. */
   2900                  #if ( configUSE_TICK_HOOK == 1 )
   2901                      {
   2902                          vApplicationTickHook();
   2903                      }
   2904                  #endif
   2905              }
   2906          
   2907              return xSwitchRequired;
   \                     ??xTaskIncrementTick_7: (+1)
   \       0xBA   0x4628             MOV      R0,R5
   \       0xBC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2908          }
   2909          /*-----------------------------------------------------------*/
   2910          
   2911          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2912          
   2913              void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
   2914                                               TaskHookFunction_t pxHookFunction )
   2915              {
   2916                  TCB_t * xTCB;
   2917          
   2918                  /* If xTask is NULL then it is the task hook of the calling task that is
   2919                   * getting set. */
   2920                  if( xTask == NULL )
   2921                  {
   2922                      xTCB = ( TCB_t * ) pxCurrentTCB;
   2923                  }
   2924                  else
   2925                  {
   2926                      xTCB = xTask;
   2927                  }
   2928          
   2929                  /* Save the hook function in the TCB.  A critical section is required as
   2930                   * the value can be accessed from an interrupt. */
   2931                  taskENTER_CRITICAL();
   2932                  {
   2933                      xTCB->pxTaskTag = pxHookFunction;
   2934                  }
   2935                  taskEXIT_CRITICAL();
   2936              }
   2937          
   2938          #endif /* configUSE_APPLICATION_TASK_TAG */
   2939          /*-----------------------------------------------------------*/
   2940          
   2941          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2942          
   2943              TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2944              {
   2945                  TCB_t * pxTCB;
   2946                  TaskHookFunction_t xReturn;
   2947          
   2948                  /* If xTask is NULL then set the calling task's hook. */
   2949                  pxTCB = prvGetTCBFromHandle( xTask );
   2950          
   2951                  /* Save the hook function in the TCB.  A critical section is required as
   2952                   * the value can be accessed from an interrupt. */
   2953                  taskENTER_CRITICAL();
   2954                  {
   2955                      xReturn = pxTCB->pxTaskTag;
   2956                  }
   2957                  taskEXIT_CRITICAL();
   2958          
   2959                  return xReturn;
   2960              }
   2961          
   2962          #endif /* configUSE_APPLICATION_TASK_TAG */
   2963          /*-----------------------------------------------------------*/
   2964          
   2965          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2966          
   2967              TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
   2968              {
   2969                  TCB_t * pxTCB;
   2970                  TaskHookFunction_t xReturn;
   2971                  UBaseType_t uxSavedInterruptStatus;
   2972          
   2973                  /* If xTask is NULL then set the calling task's hook. */
   2974                  pxTCB = prvGetTCBFromHandle( xTask );
   2975          
   2976                  /* Save the hook function in the TCB.  A critical section is required as
   2977                   * the value can be accessed from an interrupt. */
   2978                  uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   2979                  {
   2980                      xReturn = pxTCB->pxTaskTag;
   2981                  }
   2982                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   2983          
   2984                  return xReturn;
   2985              }
   2986          
   2987          #endif /* configUSE_APPLICATION_TASK_TAG */
   2988          /*-----------------------------------------------------------*/
   2989          
   2990          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2991          
   2992              BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
   2993                                                       void * pvParameter )
   2994              {
   2995                  TCB_t * xTCB;
   2996                  BaseType_t xReturn;
   2997          
   2998                  /* If xTask is NULL then we are calling our own task hook. */
   2999                  if( xTask == NULL )
   3000                  {
   3001                      xTCB = pxCurrentTCB;
   3002                  }
   3003                  else
   3004                  {
   3005                      xTCB = xTask;
   3006                  }
   3007          
   3008                  if( xTCB->pxTaskTag != NULL )
   3009                  {
   3010                      xReturn = xTCB->pxTaskTag( pvParameter );
   3011                  }
   3012                  else
   3013                  {
   3014                      xReturn = pdFAIL;
   3015                  }
   3016          
   3017                  return xReturn;
   3018              }
   3019          
   3020          #endif /* configUSE_APPLICATION_TASK_TAG */
   3021          /*-----------------------------------------------------------*/
   3022          

   \                                 In section .text, align 2, keep-with-next, root
   3023          void vTaskSwitchContext( void )
   3024          {
   \                     vTaskSwitchContext: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   3025              if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable42
   \        0x6   0x6F68             LDR      R0,[R5, #+116]
   \        0x8   0xB110             CBZ.N    R0,??vTaskSwitchContext_0
   3026              {
   3027                  /* The scheduler is currently suspended - do not allow a context
   3028                   * switch. */
   3029                  xYieldPending = pdTRUE;
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x662A             STR      R2,[R5, #+96]
   \        0xE   0xBDF1             POP      {R0,R4-R7,PC}
   3030              }
   3031              else
   3032              {
   3033                  xYieldPending = pdFALSE;
   \                     ??vTaskSwitchContext_0: (+1)
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6629             STR      R1,[R5, #+96]
   3034                  traceTASK_SWITCHED_OUT();
   3035          
   3036                  #if ( configGENERATE_RUN_TIME_STATS == 1 )
   3037                      {
   3038                          #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   3039                              portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   3040                          #else
   3041                              ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   3042                          #endif
   3043          
   3044                          /* Add the amount of time the task has been running to the
   3045                           * accumulated time so far.  The time the task started running was
   3046                           * stored in ulTaskSwitchedInTime.  Note that there is no overflow
   3047                           * protection here so count values are only valid until the timer
   3048                           * overflows.  The guard against negative values is to protect
   3049                           * against suspect run time stat counter implementations - which
   3050                           * are provided by the application, not the kernel. */
   3051                          if( ulTotalRunTime > ulTaskSwitchedInTime )
   3052                          {
   3053                              pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   3054                          }
   3055                          else
   3056                          {
   3057                              mtCOVERAGE_TEST_MARKER();
   3058                          }
   3059          
   3060                          ulTaskSwitchedInTime = ulTotalRunTime;
   3061                      }
   3062                  #endif /* configGENERATE_RUN_TIME_STATS */
   3063          
   3064                  /* Check for stack overflow, if configured. */
   3065                  taskCHECK_FOR_STACK_OVERFLOW();
   \       0x14   0x6AA8             LDR      R0,[R5, #+40]
   \       0x16   0x6B00             LDR      R0,[R0, #+48]
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF1B1 0x3FA5      CMP      R1,#+2779096485
   \       0x1E   0xBF04             ITT      EQ
   \       0x20   0x6841             LDREQ    R1,[R0, #+4]
   \       0x22   0xF1B1 0x3FA5      CMPEQ    R1,#+2779096485
   \       0x26   0xD107             BNE.N    ??vTaskSwitchContext_1
   \       0x28   0x6881             LDR      R1,[R0, #+8]
   \       0x2A   0xF1B1 0x3FA5      CMP      R1,#+2779096485
   \       0x2E   0xBF04             ITT      EQ
   \       0x30   0x68C0             LDREQ    R0,[R0, #+12]
   \       0x32   0xF1B0 0x3FA5      CMPEQ    R0,#+2779096485
   \       0x36   0xD005             BEQ.N    ??vTaskSwitchContext_2
   \                     ??vTaskSwitchContext_1: (+1)
   \       0x38   0x6AA8             LDR      R0,[R5, #+40]
   \       0x3A   0xF100 0x0134      ADD      R1,R0,#+52
   \       0x3E   0x6AA8             LDR      R0,[R5, #+40]
   \       0x40   0x.... 0x....      BL       vApplicationStackOverflowHook
   3066          
   3067                  /* Before the currently running task is switched out, save its errno. */
   3068                  #if ( configUSE_POSIX_ERRNO == 1 )
   3069                      {
   3070                          pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
   3071                      }
   3072                  #endif
   3073          
   3074                  /* Select a new task to run using either the generic C or port
   3075                   * optimised asm code. */
   3076                  taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \                     ??vTaskSwitchContext_2: (+1)
   \       0x44   0x6D6C             LDR      R4,[R5, #+84]
   \       0x46   0x.... 0x....      LDR.W    R6,??DataTable37
   \       0x4A   0x.... 0x....      LDR.W    R7,??DataTable56
   \       0x4E   0xE006             B.N      ??vTaskSwitchContext_3
   \                     ??vTaskSwitchContext_4: (+1)
   \       0x50   0xB924             CBNZ.N   R4,??vTaskSwitchContext_5
   \       0x52   0xF640 0x4104      MOVW     R1,#+3076
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0x.... 0x....      BL       assertEFM
   \                     ??vTaskSwitchContext_5: (+1)
   \       0x5C   0x1E64             SUBS     R4,R4,#+1
   \                     ??vTaskSwitchContext_3: (+1)
   \       0x5E   0x2114             MOVS     R1,#+20
   \       0x60   0x4361             MULS     R1,R1,R4
   \       0x62   0x5878             LDR      R0,[R7, R1]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0F3             BEQ.N    ??vTaskSwitchContext_4
   \       0x68   0x1878             ADDS     R0,R7,R1
   \       0x6A   0x6841             LDR      R1,[R0, #+4]
   \       0x6C   0x684A             LDR      R2,[R1, #+4]
   \       0x6E   0xF100 0x0108      ADD      R1,R0,#+8
   \       0x72   0x6042             STR      R2,[R0, #+4]
   \       0x74   0x428A             CMP      R2,R1
   \       0x76   0xBF04             ITT      EQ
   \       0x78   0x6852             LDREQ    R2,[R2, #+4]
   \       0x7A   0x6042             STREQ    R2,[R0, #+4]
   \       0x7C   0x6841             LDR      R1,[R0, #+4]
   \       0x7E   0x68C8             LDR      R0,[R1, #+12]
   \       0x80   0x62A8             STR      R0,[R5, #+40]
   \       0x82   0x656C             STR      R4,[R5, #+84]
   3077                  traceTASK_SWITCHED_IN();
   3078          
   3079                  /* After the new task is switched in, update the global errno. */
   3080                  #if ( configUSE_POSIX_ERRNO == 1 )
   3081                      {
   3082                          FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
   3083                      }
   3084                  #endif
   3085          
   3086                  #if ( configUSE_NEWLIB_REENTRANT == 1 )
   3087                      {
   3088                          /* Switch Newlib's _impure_ptr variable to point to the _reent
   3089                           * structure specific to this task.
   3090                           * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
   3091                           * for additional information. */
   3092                          _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   3093                      }
   3094                  #endif /* configUSE_NEWLIB_REENTRANT */
   3095              }
   3096          }
   \       0x84   0xBDF1             POP      {R0,R4-R7,PC}
   3097          /*-----------------------------------------------------------*/
   3098          

   \                                 In section .text, align 2, keep-with-next
   3099          void vTaskPlaceOnEventList( List_t * const pxEventList,
   3100                                      const TickType_t xTicksToWait )
   3101          {
   \                     vTaskPlaceOnEventList: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   3102              configASSERT( pxEventList );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_16
   \        0x8   0xF640 0x411E      MOVW     R1,#+3102
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   3103          
   3104              /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   3105               * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   3106          
   3107              /* Place the event list item of the TCB in the appropriate event list.
   3108               * This is placed in the list in priority order so the highest priority task
   3109               * is the first to be woken by the event.  The queue that contains the event
   3110               * list is locked, preventing simultaneous access from interrupts. */
   3111              vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x14   0x.... 0x....      BL       vListInsert
   3112          
   3113              prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x20   0x.... 0x....      B.W      prvAddCurrentTaskToDelayedList
   3114          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \        0x4   0x6A88             LDR      R0,[R1, #+40]
   \        0x6   0xF100 0x0118      ADD      R1,R0,#+24
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x4770             BX       LR
   3115          /*-----------------------------------------------------------*/
   3116          

   \                                 In section .text, align 2, keep-with-next
   3117          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
   3118                                               const TickType_t xItemValue,
   3119                                               const TickType_t xTicksToWait )
   3120          {
   \                     vTaskPlaceOnUnorderedEventList: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   3121              configASSERT( pxEventList );
   \        0xA   0x.... 0x....      LDR.W    R8,??DataTable37
   \        0xE   0xD103             BNE.N    ??CrossCallReturnLabel_34
   \       0x10   0xF640 0x4131      MOVW     R1,#+3121
   \       0x14   0x.... 0x....      BL       ?Subroutine6
   3122          
   3123              /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   3124               * the event groups implementation. */
   3125              configASSERT( uxSchedulerSuspended != 0 );
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x18   0x.... 0x....      LDR.W    R7,??DataTable42
   \       0x1C   0x6F78             LDR      R0,[R7, #+116]
   \       0x1E   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_33
   \       0x20   0xF640 0x4135      MOVW     R1,#+3125
   \       0x24   0x.... 0x....      BL       ?Subroutine6
   3126          
   3127              /* Store the item value in the event list item.  It is safe to access the
   3128               * event list item here as interrupts won't access the event list item of a
   3129               * task that is not in the Blocked state. */
   3130              listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x28   0x6AB8             LDR      R0,[R7, #+40]
   \       0x2A   0xF045 0x4500      ORR      R5,R5,#0x80000000
   \       0x2E   0x6185             STR      R5,[R0, #+24]
   3131          
   3132              /* Place the event list item of the TCB at the end of the appropriate event
   3133               * list.  It is safe to access the event list here because it is part of an
   3134               * event group implementation - and interrupts don't access event groups
   3135               * directly (instead they access them indirectly by pending function calls to
   3136               * the task level). */
   3137              vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \       0x30   0x6AB9             LDR      R1,[R7, #+40]
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x3118             ADDS     R1,R1,#+24
   \       0x36   0x.... 0x....      BL       vListInsertEnd
   3138          
   3139              prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x42   0x.... 0x....      B.W      prvAddCurrentTaskToDelayedList
   3140          }
   3141          /*-----------------------------------------------------------*/
   3142          
   3143          #if ( configUSE_TIMERS == 1 )
   3144          

   \                                 In section .text, align 2, keep-with-next
   3145              void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
   3146                                                    TickType_t xTicksToWait,
   3147                                                    const BaseType_t xWaitIndefinitely )
   3148              {
   \                     vTaskPlaceOnEventListRestricted: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   3149                  configASSERT( pxEventList );
   \                     ??CrossCallReturnLabel_46: (+1)
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_15
   \        0x8   0xF640 0x414D      MOVW     R1,#+3149
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   3150          
   3151                  /* This function should not be called by application code hence the
   3152                   * 'Restricted' in its name.  It is not part of the public API.  It is
   3153                   * designed for use by kernel code, and has special calling requirements -
   3154                   * it should be called with the scheduler suspended. */
   3155          
   3156          
   3157                  /* Place the event list item of the TCB in the appropriate event list.
   3158                   * In this case it is assume that this is the only task that is going to
   3159                   * be waiting on this event list, so the faster vListInsertEnd() function
   3160                   * can be used in place of vListInsert. */
   3161                  vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x14   0x.... 0x....      BL       vListInsertEnd
   3162          
   3163                  /* If the task should block indefinitely then set the block time to a
   3164                   * value that will be recognised as an indefinite delay inside the
   3165                   * prvAddCurrentTaskToDelayedList() function. */
   3166                  if( xWaitIndefinitely != pdFALSE )
   \       0x18   0xB10D             CBZ.N    R5,??vTaskPlaceOnEventListRestricted_0
   3167                  {
   3168                      xTicksToWait = portMAX_DELAY;
   \       0x1A   0xF04F 0x36FF      MOV      R6,#+4294967295
   3169                  }
   3170          
   3171                  traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
   3172                  prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   \                     ??vTaskPlaceOnEventListRestricted_0: (+1)
   \       0x1E   0x4629             MOV      R1,R5
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x26   0x.... 0x....      B.W      prvAddCurrentTaskToDelayedList
   3173              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x0004             MOVS     R4,R0
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x4770             BX       LR
   3174          
   3175          #endif /* configUSE_TIMERS */
   3176          /*-----------------------------------------------------------*/
   3177          

   \                                 In section .text, align 2, keep-with-next
   3178          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   3179          {
   \                     xTaskRemoveFromEventList: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3180              TCB_t * pxUnblockedTCB;
   3181              BaseType_t xReturn;
   3182          
   3183              /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   3184               * called from a critical section within an ISR. */
   3185          
   3186              /* The event list is sorted in priority order, so the first in the list can
   3187               * be removed as it is known to be the highest priority.  Remove the TCB from
   3188               * the delayed list, and add it to the ready list.
   3189               *
   3190               * If an event is for a queue that is locked then this function will never
   3191               * get called - the lock count on the queue will get modified instead.  This
   3192               * means exclusive access to the event list is guaranteed here.
   3193               *
   3194               * This function assumes that a check has already been made to ensure that
   3195               * pxEventList is not empty. */
   3196              pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \        0x2   0x68C0             LDR      R0,[R0, #+12]
   \        0x4   0x68C4             LDR      R4,[R0, #+12]
   3197              configASSERT( pxUnblockedTCB );
   \        0x6   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_14
   \        0x8   0xF640 0x417D      MOVW     R1,#+3197
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   3198              ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x10   0x.... 0x....      BL       ?Subroutine15
   3199          
   3200              if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0x14   0x.... 0x....      LDR.W    R5,??DataTable56_1
   \       0x18   0x6F68             LDR      R0,[R5, #+116]
   \       0x1A   0xB940             CBNZ.N   R0,??xTaskRemoveFromEventList_0
   3201              {
   3202                  ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   \       0x1C   0x.... 0x....      BL       ?Subroutine14
   3203                  prvAddTaskToReadyList( pxUnblockedTCB );
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0x20   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x24   0xBF38             IT       CC
   \       0x26   0x656A             STRCC    R2,[R5, #+84]
   \       0x28   0x.... 0x....      BL       ?Subroutine17
   3204          
   3205                  #if ( configUSE_TICKLESS_IDLE != 0 )
   3206                      {
   3207                          /* If a task is blocked on a kernel object then xNextTaskUnblockTime
   3208                           * might be set to the blocked task's time out time.  If the task is
   3209                           * unblocked for a reason other than a timeout xNextTaskUnblockTime is
   3210                           * normally left unchanged, because it is automatically reset to a new
   3211                           * value when the tick count equals xNextTaskUnblockTime.  However if
   3212                           * tickless idling is used it might be more important to enter sleep mode
   3213                           * at the earliest possible time - so reset xNextTaskUnblockTime here to
   3214                           * ensure it is updated at the earliest possible time. */
   3215                          prvResetNextTaskUnblockTime();
   3216                      }
   3217                  #endif
   3218              }
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x2C   0xE002             B.N      ??xTaskRemoveFromEventList_1
   3219              else
   3220              {
   3221                  /* The delayed and ready lists cannot be accessed, so hold this task
   3222                   * pending until the scheduler is resumed. */
   3223                  vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_0: (+1)
   \       0x2E   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x32   0x4628             MOV      R0,R5
   \                     ??xTaskRemoveFromEventList_1: (+1)
   \       0x34   0x.... 0x....      BL       vListInsertEnd
   3224              }
   3225          
   3226              if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0x38   0x6AA9             LDR      R1,[R5, #+40]
   \       0x3A   0x6AE2             LDR      R2,[R4, #+44]
   \       0x3C   0x6AC8             LDR      R0,[R1, #+44]
   \       0x3E   0x4290             CMP      R0,R2
   \       0x40   0xD203             BCS.N    ??xTaskRemoveFromEventList_2
   3227              {
   3228                  /* Return true if the task removed from the event list has a higher
   3229                   * priority than the calling task.  This allows the calling task to know if
   3230                   * it should force a context switch now. */
   3231                  xReturn = pdTRUE;
   3232          
   3233                  /* Mark that a yield is pending in case the user is not using the
   3234                   * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   3235                  xYieldPending = pdTRUE;
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x6629             STR      R1,[R5, #+96]
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}
   3236              }
   3237              else
   3238              {
   3239                  xReturn = pdFALSE;
   \                     ??xTaskRemoveFromEventList_2: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   3240              }
   3241          
   3242              return xReturn;
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
   3243          }
   3244          /*-----------------------------------------------------------*/
   3245          

   \                                 In section .text, align 2, keep-with-next
   3246          void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
   3247                                                  const TickType_t xItemValue )
   3248          {
   \                     vTaskRemoveFromUnorderedEventList: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   3249              TCB_t * pxUnblockedTCB;
   3250          
   3251              /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   3252               * the event flags implementation. */
   3253              configASSERT( uxSchedulerSuspended != pdFALSE );
   \        0x2   0x....             LDR.N    R5,??DataTable42
   \        0x4   0x6F6A             LDR      R2,[R5, #+116]
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x.... 0x....      LDR.W    R7,??DataTable56_2
   \        0xE   0xB91A             CBNZ.N   R2,??CrossCallReturnLabel_41
   \       0x10   0xF640 0x41B5      MOVW     R1,#+3253
   \       0x14   0x.... 0x....      BL       ?Subroutine7
   3254          
   3255              /* Store the new item value in the event list. */
   3256              listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x18   0xF044 0x4400      ORR      R4,R4,#0x80000000
   \       0x1C   0x6034             STR      R4,[R6, #+0]
   3257          
   3258              /* Remove the event list form the event flag.  Interrupts do not access
   3259               * event flags. */
   3260              pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \       0x1E   0x68F4             LDR      R4,[R6, #+12]
   3261              configASSERT( pxUnblockedTCB );
   \       0x20   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_40
   \       0x22   0xF640 0x41BD      MOVW     R1,#+3261
   \       0x26   0x.... 0x....      BL       ?Subroutine7
   3262              ( void ) uxListRemove( pxEventListItem );
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       uxListRemove
   3263          
   3264              #if ( configUSE_TICKLESS_IDLE != 0 )
   3265                  {
   3266                      /* If a task is blocked on a kernel object then xNextTaskUnblockTime
   3267                       * might be set to the blocked task's time out time.  If the task is
   3268                       * unblocked for a reason other than a timeout xNextTaskUnblockTime is
   3269                       * normally left unchanged, because it is automatically reset to a new
   3270                       * value when the tick count equals xNextTaskUnblockTime.  However if
   3271                       * tickless idling is used it might be more important to enter sleep mode
   3272                       * at the earliest possible time - so reset xNextTaskUnblockTime here to
   3273                       * ensure it is updated at the earliest possible time. */
   3274                      prvResetNextTaskUnblockTime();
   3275                  }
   3276              #endif
   3277          
   3278              /* Remove the task from the delayed list and add it to the ready list.  The
   3279               * scheduler is suspended so interrupts will not be accessing the ready
   3280               * lists. */
   3281              ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   \       0x30   0x.... 0x....      BL       ?Subroutine14
   3282              prvAddTaskToReadyList( pxUnblockedTCB );
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x34   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x38   0xBF38             IT       CC
   \       0x3A   0x656A             STRCC    R2,[R5, #+84]
   \       0x3C   0x.... 0x....      BL       ?Subroutine12
   3283          
   3284              if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x40   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x44   0xBF3C             ITT      CC
   \       0x46   0x2001             MOVCC    R0,#+1
   \       0x48   0x6628             STRCC    R0,[R5, #+96]
   3285              {
   3286                  /* The unblocked task has a priority above that of the calling task, so
   3287                   * a context switch is required.  This function is called with the
   3288                   * scheduler suspended so xYieldPending is set so the context switch
   3289                   * occurs immediately that the scheduler is resumed (unsuspended). */
   3290                  xYieldPending = pdTRUE;
   3291              }
   3292          }
   \       0x4A   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4638             MOV      R0,R7
   \        0x2   0x.... 0x....      B.W      assertEFM
   3293          /*-----------------------------------------------------------*/
   3294          

   \                                 In section .text, align 2, keep-with-next
   3295          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   3296          {
   \                     vTaskSetTimeOutState: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3297              configASSERT( pxTimeOut );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_13
   \        0x6   0xF640 0x41E1      MOVW     R1,#+3297
   \        0xA   0x.... 0x....      BL       ?Subroutine5
   3298              taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_13: (+1)
   \        0xE   0x.... 0x....      BL       vPortEnterCritical
   3299              {
   3300                  pxTimeOut->xOverflowCount = xNumOfOverflows;
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \       0x16   0x6E48             LDR      R0,[R1, #+100]
   \       0x18   0x6020             STR      R0,[R4, #+0]
   3301                  pxTimeOut->xTimeOnEntering = xTickCount;
   \       0x1A   0x6D09             LDR      R1,[R1, #+80]
   \       0x1C   0x6061             STR      R1,[R4, #+4]
   3302              }
   3303              taskEXIT_CRITICAL();
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x.... 0x....      B.W      vPortExitCritical
   3304          }
   3305          /*-----------------------------------------------------------*/
   3306          

   \                                 In section .text, align 2, keep-with-next
   3307          void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
   3308          {
   3309              /* For internal use only as it does not use a critical section. */
   3310              pxTimeOut->xOverflowCount = xNumOfOverflows;
   \                     vTaskInternalSetTimeOutState: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable56_1
   \        0x4   0x6E51             LDR      R1,[R2, #+100]
   \        0x6   0x6001             STR      R1,[R0, #+0]
   3311              pxTimeOut->xTimeOnEntering = xTickCount;
   \        0x8   0x6D12             LDR      R2,[R2, #+80]
   \        0xA   0x6042             STR      R2,[R0, #+4]
   3312          }
   \        0xC   0x4770             BX       LR
   3313          /*-----------------------------------------------------------*/
   3314          

   \                                 In section .text, align 2, keep-with-next
   3315          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
   3316                                           TickType_t * const pxTicksToWait )
   3317          {
   \                     xTaskCheckForTimeOut: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   3318              BaseType_t xReturn;
   3319          
   3320              configASSERT( pxTimeOut );
   \        0x6   0x....             LDR.N    R6,??DataTable37
   \        0x8   0xD104             BNE.N    ??xTaskCheckForTimeOut_0
   \        0xA   0xF640 0x41F8      MOVW     R1,#+3320
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x.... 0x....      BL       assertEFM
   3321              configASSERT( pxTicksToWait );
   \                     ??xTaskCheckForTimeOut_0: (+1)
   \       0x14   0xB925             CBNZ.N   R5,??xTaskCheckForTimeOut_1
   \       0x16   0xF640 0x41F9      MOVW     R1,#+3321
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x.... 0x....      BL       assertEFM
   3322          
   3323              taskENTER_CRITICAL();
   \                     ??xTaskCheckForTimeOut_1: (+1)
   \       0x20   0x.... 0x....      BL       vPortEnterCritical
   3324              {
   3325                  /* Minor optimisation.  The tick count cannot change in this block. */
   3326                  const TickType_t xConstTickCount = xTickCount;
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \       0x28   0xF8D0 0xC050      LDR      R12,[R0, #+80]
   3327                  const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   \       0x2C   0x6861             LDR      R1,[R4, #+4]
   3328          
   3329                  #if ( INCLUDE_xTaskAbortDelay == 1 )
   3330                      if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
   3331                      {
   3332                          /* The delay was aborted, which is not the same as a time out,
   3333                           * but has the same result. */
   3334                          pxCurrentTCB->ucDelayAborted = pdFALSE;
   3335                          xReturn = pdTRUE;
   3336                      }
   3337                      else
   3338                  #endif
   3339          
   3340                  #if ( INCLUDE_vTaskSuspend == 1 )
   3341                      if( *pxTicksToWait == portMAX_DELAY )
   \       0x2E   0x682B             LDR      R3,[R5, #+0]
   \       0x30   0xEBAC 0x0201      SUB      R2,R12,R1
   \       0x34   0xF113 0x0F01      CMN      R3,#+1
   \       0x38   0xD011             BEQ.N    ??xTaskCheckForTimeOut_2
   3342                      {
   3343                          /* If INCLUDE_vTaskSuspend is set to 1 and the block time
   3344                           * specified is the maximum block time then the task should block
   3345                           * indefinitely, and therefore never time out. */
   3346                          xReturn = pdFALSE;
   3347                      }
   3348                      else
   3349                  #endif
   3350          
   3351                  if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   \       0x3A   0x6E46             LDR      R6,[R0, #+100]
   \       0x3C   0x6827             LDR      R7,[R4, #+0]
   \       0x3E   0x42BE             CMP      R6,R7
   \       0x40   0xD005             BEQ.N    ??xTaskCheckForTimeOut_3
   \       0x42   0x458C             CMP      R12,R1
   \       0x44   0xD303             BCC.N    ??xTaskCheckForTimeOut_3
   3352                  {
   3353                      /* The tick count is greater than the time at which
   3354                       * vTaskSetTimeout() was called, but has also overflowed since
   3355                       * vTaskSetTimeOut() was called.  It must have wrapped all the way
   3356                       * around and gone past again. This passed since vTaskSetTimeout()
   3357                       * was called. */
   3358                      xReturn = pdTRUE;
   3359                      *pxTicksToWait = ( TickType_t ) 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x2401             MOVS     R4,#+1
   \       0x4A   0x6028             STR      R0,[R5, #+0]
   \       0x4C   0xE00C             B.N      ??xTaskCheckForTimeOut_4
   3360                  }
   3361                  else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   \                     ??xTaskCheckForTimeOut_3: (+1)
   \       0x4E   0x429A             CMP      R2,R3
   \       0x50   0xD207             BCS.N    ??xTaskCheckForTimeOut_5
   3362                  {
   3363                      /* Not a genuine timeout. Adjust parameters for time remaining. */
   3364                      *pxTicksToWait -= xElapsedTime;
   \       0x52   0x1A9A             SUBS     R2,R3,R2
   \       0x54   0x602A             STR      R2,[R5, #+0]
   3365                      vTaskInternalSetTimeOutState( pxTimeOut );
   \       0x56   0x6E41             LDR      R1,[R0, #+100]
   \       0x58   0x6021             STR      R1,[R4, #+0]
   \       0x5A   0x6D00             LDR      R0,[R0, #+80]
   \       0x5C   0x6060             STR      R0,[R4, #+4]
   3366                      xReturn = pdFALSE;
   \                     ??xTaskCheckForTimeOut_2: (+1)
   \       0x5E   0x2400             MOVS     R4,#+0
   \       0x60   0xE002             B.N      ??xTaskCheckForTimeOut_4
   3367                  }
   3368                  else
   3369                  {
   3370                      *pxTicksToWait = ( TickType_t ) 0;
   \                     ??xTaskCheckForTimeOut_5: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x6028             STR      R0,[R5, #+0]
   3371                      xReturn = pdTRUE;
   \       0x66   0x2401             MOVS     R4,#+1
   3372                  }
   3373              }
   3374              taskEXIT_CRITICAL();
   \                     ??xTaskCheckForTimeOut_4: (+1)
   \       0x68   0x.... 0x....      BL       vPortExitCritical
   3375          
   3376              return xReturn;
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0xBDF2             POP      {R1,R4-R7,PC}
   3377          }
   3378          /*-----------------------------------------------------------*/
   3379          

   \                                 In section .text, align 2, keep-with-next
   3380          void vTaskMissedYield( void )
   3381          {
   3382              xYieldPending = pdTRUE;
   \                     vTaskMissedYield: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \        0x6   0x6601             STR      R1,[R0, #+96]
   3383          }
   \        0x8   0x4770             BX       LR
   3384          /*-----------------------------------------------------------*/
   3385          
   3386          #if ( configUSE_TRACE_FACILITY == 1 )
   3387          

   \                                 In section .text, align 2, keep-with-next
   3388              UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   3389              {
   3390                  UBaseType_t uxReturn;
   3391                  TCB_t const * pxTCB;
   3392          
   3393                  if( xTask != NULL )
   \                     uxTaskGetTaskNumber: (+1)
   \        0x0   0xB100             CBZ.N    R0,??uxTaskGetTaskNumber_0
   3394                  {
   3395                      pxTCB = xTask;
   3396                      uxReturn = pxTCB->uxTaskNumber;
   \        0x2   0x6C40             LDR      R0,[R0, #+68]
   3397                  }
   3398                  else
   3399                  {
   3400                      uxReturn = 0U;
   3401                  }
   3402          
   3403                  return uxReturn;
   \                     ??uxTaskGetTaskNumber_0: (+1)
   \        0x4   0x4770             BX       LR
   3404              }
   3405          
   3406          #endif /* configUSE_TRACE_FACILITY */
   3407          /*-----------------------------------------------------------*/
   3408          
   3409          #if ( configUSE_TRACE_FACILITY == 1 )
   3410          

   \                                 In section .text, align 2, keep-with-next
   3411              void vTaskSetTaskNumber( TaskHandle_t xTask,
   3412                                       const UBaseType_t uxHandle )
   3413              {
   3414                  TCB_t * pxTCB;
   3415          
   3416                  if( xTask != NULL )
   \                     vTaskSetTaskNumber: (+1)
   \        0x0   0xB100             CBZ.N    R0,??vTaskSetTaskNumber_0
   3417                  {
   3418                      pxTCB = xTask;
   3419                      pxTCB->uxTaskNumber = uxHandle;
   \        0x2   0x6441             STR      R1,[R0, #+68]
   3420                  }
   3421              }
   \                     ??vTaskSetTaskNumber_0: (+1)
   \        0x4   0x4770             BX       LR
   3422          
   3423          #endif /* configUSE_TRACE_FACILITY */
   3424          
   3425          /*
   3426           * -----------------------------------------------------------
   3427           * The Idle task.
   3428           * ----------------------------------------------------------
   3429           *
   3430           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   3431           * language extensions.  The equivalent prototype for this function is:
   3432           *
   3433           * void prvIdleTask( void *pvParameters );
   3434           *
   3435           */

   \                                 In section .text, align 4, keep-with-next
   3436          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   3437          {
   \                     prvIdleTask: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   3438              /* Stop warnings. */
   3439              ( void ) pvParameters;
   \        0x2   0x....             LDR.N    R4,??DataTable43
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable56_1
   \        0x8   0xE011             B.N      ??prvIdleTask_0
   \                     ??prvIdleTask_1: (+1)
   \        0xA   0x.... 0x....      BL       vPortEnterCritical
   \        0xE   0x6A28             LDR      R0,[R5, #+32]
   \       0x10   0x68C6             LDR      R6,[R0, #+12]
   \       0x12   0x1D30             ADDS     R0,R6,#+4
   \       0x14   0x.... 0x....      BL       uxListRemove
   \       0x18   0x6CE8             LDR      R0,[R5, #+76]
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0x64E8             STR      R0,[R5, #+76]
   \       0x1E   0x6B68             LDR      R0,[R5, #+52]
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0x6368             STR      R0,[R5, #+52]
   \       0x24   0x.... 0x....      BL       vPortExitCritical
   \       0x28   0x4630             MOV      R0,R6
   \       0x2A   0x.... 0x....      BL       prvDeleteTCB
   \                     ??prvIdleTask_0: (+1)
   \       0x2E   0x6B68             LDR      R0,[R5, #+52]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1EA             BNE.N    ??prvIdleTask_1
   3440          
   3441              /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
   3442               * SCHEDULER IS STARTED. **/
   3443          
   3444              /* In case a task that has a secure context deletes itself, in which case
   3445               * the idle task is responsible for deleting the task's secure context, if
   3446               * any. */
   3447              portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
   3448          
   3449              for( ; ; )
   3450              {
   3451                  /* See if any tasks have deleted themselves - if so then the idle task
   3452                   * is responsible for freeing the deleted task's TCB and stack. */
   3453                  prvCheckTasksWaitingTermination();
   3454          
   3455                  #if ( configUSE_PREEMPTION == 0 )
   3456                      {
   3457                          /* If we are not using preemption we keep forcing a task switch to
   3458                           * see if any other task has become available.  If we are using
   3459                           * preemption we don't need to do this as any task becoming available
   3460                           * will automatically get the processor anyway. */
   3461                          taskYIELD();
   3462                      }
   3463                  #endif /* configUSE_PREEMPTION */
   3464          
   3465                  #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   3466                      {
   3467                          /* When using preemption tasks of equal priority will be
   3468                           * timesliced.  If a task that is sharing the idle priority is ready
   3469                           * to run then the idle task should yield before the end of the
   3470                           * timeslice.
   3471                           *
   3472                           * A critical region is not required here as we are just reading from
   3473                           * the list, and an occasional incorrect value will not matter.  If
   3474                           * the ready list at the idle priority contains more than one task
   3475                           * then a task other than the idle task is ready to execute. */
   3476                          if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x2902             CMP      R1,#+2
   \       0x38   0xD3F9             BCC.N    ??prvIdleTask_0
   3477                          {
   3478                              taskYIELD();
   \       0x3A   0x.... 0x....      BL       vPortYield
   \       0x3E   0xE7F6             B.N      ??prvIdleTask_0
   3479                          }
   3480                          else
   3481                          {
   3482                              mtCOVERAGE_TEST_MARKER();
   3483                          }
   3484                      }
   3485                  #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   3486          
   3487                  #if ( configUSE_IDLE_HOOK == 1 )
   3488                      {
   3489                          extern void vApplicationIdleHook( void );
   3490          
   3491                          /* Call the user defined function from within the idle task.  This
   3492                           * allows the application designer to add background functionality
   3493                           * without the overhead of a separate task.
   3494                           * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   3495                           * CALL A FUNCTION THAT MIGHT BLOCK. */
   3496                          vApplicationIdleHook();
   3497                      }
   3498                  #endif /* configUSE_IDLE_HOOK */
   3499          
   3500                  /* This conditional compilation should use inequality to 0, not equality
   3501                   * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   3502                   * user defined low power mode  implementations require
   3503                   * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   3504                  #if ( configUSE_TICKLESS_IDLE != 0 )
   3505                      {
   3506                          TickType_t xExpectedIdleTime;
   3507          
   3508                          /* It is not desirable to suspend then resume the scheduler on
   3509                           * each iteration of the idle task.  Therefore, a preliminary
   3510                           * test of the expected idle time is performed without the
   3511                           * scheduler suspended.  The result here is not necessarily
   3512                           * valid. */
   3513                          xExpectedIdleTime = prvGetExpectedIdleTime();
   3514          
   3515                          if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3516                          {
   3517                              vTaskSuspendAll();
   3518                              {
   3519                                  /* Now the scheduler is suspended, the expected idle
   3520                                   * time can be sampled again, and this time its value can
   3521                                   * be used. */
   3522                                  configASSERT( xNextTaskUnblockTime >= xTickCount );
   3523                                  xExpectedIdleTime = prvGetExpectedIdleTime();
   3524          
   3525                                  /* Define the following macro to set xExpectedIdleTime to 0
   3526                                   * if the application does not want
   3527                                   * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
   3528                                  configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
   3529          
   3530                                  if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3531                                  {
   3532                                      traceLOW_POWER_IDLE_BEGIN();
   3533                                      portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   3534                                      traceLOW_POWER_IDLE_END();
   3535                                  }
   3536                                  else
   3537                                  {
   3538                                      mtCOVERAGE_TEST_MARKER();
   3539                                  }
   3540                              }
   3541                              ( void ) xTaskResumeAll();
   3542                          }
   3543                          else
   3544                          {
   3545                              mtCOVERAGE_TEST_MARKER();
   3546                          }
   3547                      }
   3548                  #endif /* configUSE_TICKLESS_IDLE */
   3549              }
   3550          }
   3551          /*-----------------------------------------------------------*/
   3552          
   3553          #if ( configUSE_TICKLESS_IDLE != 0 )
   3554          
   3555              eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   3556              {
   3557                  /* The idle task exists in addition to the application tasks. */
   3558                  const UBaseType_t uxNonApplicationTasks = 1;
   3559                  eSleepModeStatus eReturn = eStandardSleep;
   3560          
   3561                  /* This function must be called from a critical section. */
   3562          
   3563                  if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   3564                  {
   3565                      /* A task was made ready while the scheduler was suspended. */
   3566                      eReturn = eAbortSleep;
   3567                  }
   3568                  else if( xYieldPending != pdFALSE )
   3569                  {
   3570                      /* A yield was pended while the scheduler was suspended. */
   3571                      eReturn = eAbortSleep;
   3572                  }
   3573                  else if( xPendedTicks != 0 )
   3574                  {
   3575                      /* A tick interrupt has already occurred but was held pending
   3576                       * because the scheduler is suspended. */
   3577                      eReturn = eAbortSleep;
   3578                  }
   3579                  else
   3580                  {
   3581                      /* If all the tasks are in the suspended list (which might mean they
   3582                       * have an infinite block time rather than actually being suspended)
   3583                       * then it is safe to turn all clocks off and just wait for external
   3584                       * interrupts. */
   3585                      if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   3586                      {
   3587                          eReturn = eNoTasksWaitingTimeout;
   3588                      }
   3589                      else
   3590                      {
   3591                          mtCOVERAGE_TEST_MARKER();
   3592                      }
   3593                  }
   3594          
   3595                  return eReturn;
   3596              }
   3597          
   3598          #endif /* configUSE_TICKLESS_IDLE */
   3599          /*-----------------------------------------------------------*/
   3600          
   3601          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3602          

   \                                 In section .text, align 2, keep-with-next
   3603              void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
   3604                                                      BaseType_t xIndex,
   3605                                                      void * pvValue )
   3606              {
   \                     vTaskSetThreadLocalStoragePointer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4616             MOV      R6,R2
   3607                  TCB_t * pxTCB;
   3608          
   3609                  if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   \        0x8   0x2D02             CMP      R5,#+2
   \        0xA   0xDA0D             BGE.N    ??vTaskSetThreadLocalStoragePointer_0
   3610                  {
   3611                      pxTCB = prvGetTCBFromHandle( xTaskToSet );
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF02             ITTT     EQ
   \       0x10   0x.... 0x....      LDREQ.W  R0,??DataTable56_1
   \       0x14   0x6A84             LDREQ    R4,[R0, #+40]
   \       0x16   0x2C00             CMPEQ    R4,#+0
   3612                      configASSERT( pxTCB != NULL );
   \       0x18   0xD103             BNE.N    ??CrossCallReturnLabel_12
   \       0x1A   0xF640 0x611C      MOVW     R1,#+3612
   \       0x1E   0x.... 0x....      BL       ?Subroutine5
   3613                      pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x22   0xEB04 0x0185      ADD      R1,R4,R5, LSL #+2
   \       0x26   0x650E             STR      R6,[R1, #+80]
   3614                  }
   3615              }
   \                     ??vTaskSetThreadLocalStoragePointer_0: (+1)
   \       0x28   0xBD70             POP      {R4-R6,PC}
   3616          
   3617          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3618          /*-----------------------------------------------------------*/
   3619          
   3620          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3621          

   \                                 In section .text, align 2, keep-with-next
   3622              void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
   3623                                                         BaseType_t xIndex )
   3624              {
   \                     pvTaskGetThreadLocalStoragePointer: (+1)
   \        0x0   0x4602             MOV      R2,R0
   3625                  void * pvReturn = NULL;
   \        0x2   0x2000             MOVS     R0,#+0
   3626                  TCB_t * pxTCB;
   3627          
   3628                  if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   \        0x4   0x2902             CMP      R1,#+2
   \        0x6   0xDA06             BGE.N    ??pvTaskGetThreadLocalStoragePointer_0
   3629                  {
   3630                      pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   \        0x8   0xB912             CBNZ.N   R2,??pvTaskGetThreadLocalStoragePointer_1
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \        0xE   0x6A82             LDR      R2,[R0, #+40]
   3631                      pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
   \                     ??pvTaskGetThreadLocalStoragePointer_1: (+1)
   \       0x10   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \       0x14   0x6D00             LDR      R0,[R0, #+80]
   3632                  }
   3633                  else
   3634                  {
   3635                      pvReturn = NULL;
   3636                  }
   3637          
   3638                  return pvReturn;
   \                     ??pvTaskGetThreadLocalStoragePointer_0: (+1)
   \       0x16   0x4770             BX       LR
   3639              }
   3640          
   3641          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3642          /*-----------------------------------------------------------*/
   3643          
   3644          #if ( portUSING_MPU_WRAPPERS == 1 )
   3645          
   3646              void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
   3647                                            const MemoryRegion_t * const xRegions )
   3648              {
   3649                  TCB_t * pxTCB;
   3650          
   3651                  /* If null is passed in here then we are modifying the MPU settings of
   3652                   * the calling task. */
   3653                  pxTCB = prvGetTCBFromHandle( xTaskToModify );
   3654          
   3655                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   3656              }
   3657          
   3658          #endif /* portUSING_MPU_WRAPPERS */
   3659          /*-----------------------------------------------------------*/
   3660          
   3661          static void prvInitialiseTaskLists( void )
   3662          {
   3663              UBaseType_t uxPriority;
   3664          
   3665              for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   3666              {
   3667                  vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   3668              }
   3669          
   3670              vListInitialise( &xDelayedTaskList1 );
   3671              vListInitialise( &xDelayedTaskList2 );
   3672              vListInitialise( &xPendingReadyList );
   3673          
   3674              #if ( INCLUDE_vTaskDelete == 1 )
   3675                  {
   3676                      vListInitialise( &xTasksWaitingTermination );
   3677                  }
   3678              #endif /* INCLUDE_vTaskDelete */
   3679          
   3680              #if ( INCLUDE_vTaskSuspend == 1 )
   3681                  {
   3682                      vListInitialise( &xSuspendedTaskList );
   3683                  }
   3684              #endif /* INCLUDE_vTaskSuspend */
   3685          
   3686              /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   3687               * using list2. */
   3688              pxDelayedTaskList = &xDelayedTaskList1;
   3689              pxOverflowDelayedTaskList = &xDelayedTaskList2;
   3690          }
   3691          /*-----------------------------------------------------------*/
   3692          
   3693          static void prvCheckTasksWaitingTermination( void )
   3694          {
   3695              /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
   3696          
   3697              #if ( INCLUDE_vTaskDelete == 1 )
   3698                  {
   3699                      TCB_t * pxTCB;
   3700          
   3701                      /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
   3702                       * being called too often in the idle task. */
   3703                      while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   3704                      {
   3705                          taskENTER_CRITICAL();
   3706                          {
   3707                              pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3708                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   3709                              --uxCurrentNumberOfTasks;
   3710                              --uxDeletedTasksWaitingCleanUp;
   3711                          }
   3712                          taskEXIT_CRITICAL();
   3713          
   3714                          prvDeleteTCB( pxTCB );
   3715                      }
   3716                  }
   3717              #endif /* INCLUDE_vTaskDelete */
   3718          }
   3719          /*-----------------------------------------------------------*/
   3720          
   3721          #if ( configUSE_TRACE_FACILITY == 1 )
   3722          

   \                                 In section .text, align 2, keep-with-next
   3723              void vTaskGetInfo( TaskHandle_t xTask,
   3724                                 TaskStatus_t * pxTaskStatus,
   3725                                 BaseType_t xGetFreeStackSpace,
   3726                                 eTaskState eState )
   3727              {
   \                     vTaskGetInfo: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   3728                  TCB_t * pxTCB;
   3729          
   3730                  /* xTask is NULL then get the state of the calling task. */
   3731                  pxTCB = prvGetTCBFromHandle( xTask );
   \                     ??CrossCallReturnLabel_47: (+1)
   \        0x6   0x....             LDR.N    R0,??DataTable42
   \        0x8   0xBF08             IT       EQ
   \        0xA   0x6A84             LDREQ    R4,[R0, #+40]
   3732          
   3733                  pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
   \        0xC   0x6034             STR      R4,[R6, #+0]
   3734                  pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
   \        0xE   0xF104 0x0234      ADD      R2,R4,#+52
   \       0x12   0x6072             STR      R2,[R6, #+4]
   3735                  pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
   \       0x14   0x6AE1             LDR      R1,[R4, #+44]
   \       0x16   0x6131             STR      R1,[R6, #+16]
   3736                  pxTaskStatus->pxStackBase = pxTCB->pxStack;
   \       0x18   0x6B22             LDR      R2,[R4, #+48]
   \       0x1A   0x61F2             STR      R2,[R6, #+28]
   3737                  pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
   \       0x1C   0x6C21             LDR      R1,[R4, #+64]
   3738          
   3739                  #if ( configUSE_MUTEXES == 1 )
   3740                      {
   3741                          pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
   3742                      }
   3743                  #else
   3744                      {
   3745                          pxTaskStatus->uxBasePriority = 0;
   3746                      }
   3747                  #endif
   3748          
   3749                  #if ( configGENERATE_RUN_TIME_STATS == 1 )
   3750                      {
   3751                          pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
   3752                      }
   3753                  #else
   3754                      {
   3755                          pxTaskStatus->ulRunTimeCounter = 0;
   \       0x1E   0x2200             MOVS     R2,#+0
   3756                      }
   3757                  #endif
   3758          
   3759                  /* Obtaining the task state is a little fiddly, so is only done if the
   3760                   * value of eState passed into this function is eInvalid - otherwise the
   3761                   * state is just set to whatever is passed in. */
   3762                  if( eState != eInvalid )
   \       0x20   0x2B05             CMP      R3,#+5
   \       0x22   0x60B1             STR      R1,[R6, #+8]
   \       0x24   0x6CA7             LDR      R7,[R4, #+72]
   \       0x26   0x61B2             STR      R2,[R6, #+24]
   \       0x28   0x6177             STR      R7,[R6, #+20]
   \       0x2A   0xD010             BEQ.N    ??vTaskGetInfo_0
   3763                  {
   3764                      if( pxTCB == pxCurrentTCB )
   \       0x2C   0x6A80             LDR      R0,[R0, #+40]
   \       0x2E   0x4284             CMP      R4,R0
   \       0x30   0xBF08             IT       EQ
   \       0x32   0x7332             STRBEQ   R2,[R6, #+12]
   3765                      {
   3766                          pxTaskStatus->eCurrentState = eRunning;
   \       0x34   0xD00F             BEQ.N    ??vTaskGetInfo_1
   3767                      }
   3768                      else
   3769                      {
   3770                          pxTaskStatus->eCurrentState = eState;
   \       0x36   0x7333             STRB     R3,[R6, #+12]
   3771          
   3772                          #if ( INCLUDE_vTaskSuspend == 1 )
   3773                              {
   3774                                  /* If the task is in the suspended list then there is a
   3775                                   *  chance it is actually just blocked indefinitely - so really
   3776                                   *  it should be reported as being in the Blocked state. */
   3777                                  if( eState == eSuspended )
   \       0x38   0x2B03             CMP      R3,#+3
   \       0x3A   0xD10C             BNE.N    ??vTaskGetInfo_1
   3778                                  {
   3779                                      vTaskSuspendAll();
   \       0x3C   0x.... 0x....      BL       vTaskSuspendAll
   3780                                      {
   3781                                          if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \       0x40   0x6AA0             LDR      R0,[R4, #+40]
   \       0x42   0xB108             CBZ.N    R0,??vTaskGetInfo_2
   3782                                          {
   3783                                              pxTaskStatus->eCurrentState = eBlocked;
   \       0x44   0x2102             MOVS     R1,#+2
   \       0x46   0x7331             STRB     R1,[R6, #+12]
   3784                                          }
   3785                                      }
   3786                                      ( void ) xTaskResumeAll();
   \                     ??vTaskGetInfo_2: (+1)
   \       0x48   0x.... 0x....      BL       xTaskResumeAll
   \       0x4C   0xE003             B.N      ??vTaskGetInfo_1
   3787                                  }
   3788                              }
   3789                          #endif /* INCLUDE_vTaskSuspend */
   3790                      }
   3791                  }
   3792                  else
   3793                  {
   3794                      pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
   \                     ??vTaskGetInfo_0: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x.... 0x....      BL       eTaskGetState
   \       0x54   0x7330             STRB     R0,[R6, #+12]
   3795                  }
   3796          
   3797                  /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
   3798                   * parameter is provided to allow it to be skipped. */
   3799                  if( xGetFreeStackSpace != pdFALSE )
   \                     ??vTaskGetInfo_1: (+1)
   \       0x56   0xB11D             CBZ.N    R5,??vTaskGetInfo_3
   3800                  {
   3801                      #if ( portSTACK_GROWTH > 0 )
   3802                          {
   3803                              pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
   3804                          }
   3805                      #else
   3806                          {
   3807                              pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
   \       0x58   0x6B20             LDR      R0,[R4, #+48]
   \       0x5A   0x.... 0x....      BL       prvTaskCheckFreeStackSpace
   \       0x5E   0xE000             B.N      ??vTaskGetInfo_4
   3808                          }
   3809                      #endif
   3810                  }
   3811                  else
   3812                  {
   3813                      pxTaskStatus->usStackHighWaterMark = 0;
   \                     ??vTaskGetInfo_3: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \                     ??vTaskGetInfo_4: (+1)
   \       0x62   0x8430             STRH     R0,[R6, #+32]
   3814                  }
   3815              }
   \       0x64   0xBDF1             POP      {R0,R4-R7,PC}
   3816          
   3817          #endif /* configUSE_TRACE_FACILITY */
   3818          /*-----------------------------------------------------------*/
   3819          
   3820          #if ( configUSE_TRACE_FACILITY == 1 )
   3821          

   \                                 In section .text, align 2, keep-with-next
   3822              static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
   3823                                                               List_t * pxList,
   3824                                                               eTaskState eState )
   3825              {
   \                     prvListTasksWithinSingleList: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   3826                  configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
   3827                  UBaseType_t uxTask = 0;
   3828          
   3829                  if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x2700             MOVS     R7,#+0
   \        0xE   0xB1C8             CBZ.N    R0,??prvListTasksWithinSingleList_0
   3830                  {
   3831                      listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \       0x10   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x14   0xBF04             ITT      EQ
   \       0x16   0x6849             LDREQ    R1,[R1, #+4]
   \       0x18   0x6069             STREQ    R1,[R5, #+4]
   \       0x1A   0x6868             LDR      R0,[R5, #+4]
   \       0x1C   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   3832          
   3833                      /* Populate an TaskStatus_t structure within the
   3834                       * pxTaskStatusArray array for each task that is referenced from
   3835                       * pxList.  See the definition of TaskStatus_t in task.h for the
   3836                       * meaning of each TaskStatus_t structure member. */
   3837                      do
   3838                      {
   3839                          listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   \                     ??prvListTasksWithinSingleList_1: (+1)
   \       0x20   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0x24   0xBF04             ITT      EQ
   \       0x26   0x6849             LDREQ    R1,[R1, #+4]
   \       0x28   0x6069             STREQ    R1,[R5, #+4]
   \       0x2A   0x6868             LDR      R0,[R5, #+4]
   3840                          vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
   \       0x2C   0x4643             MOV      R3,R8
   \       0x2E   0x2201             MOVS     R2,#+1
   \       0x30   0x68C6             LDR      R6,[R0, #+12]
   \       0x32   0x2024             MOVS     R0,#+36
   \       0x34   0x4378             MULS     R0,R0,R7
   \       0x36   0x1821             ADDS     R1,R4,R0
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       vTaskGetInfo
   3841                          uxTask++;
   \       0x3E   0x1C7F             ADDS     R7,R7,#+1
   3842                      } while( pxNextTCB != pxFirstTCB );
   \       0x40   0x454E             CMP      R6,R9
   \       0x42   0xD1ED             BNE.N    ??prvListTasksWithinSingleList_1
   3843                  }
   3844                  else
   3845                  {
   3846                      mtCOVERAGE_TEST_MARKER();
   3847                  }
   3848          
   3849                  return uxTask;
   \                     ??prvListTasksWithinSingleList_0: (+1)
   \       0x44   0x4638             MOV      R0,R7
   \       0x46   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   3850              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x6868             LDR      R0,[R5, #+4]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF105 0x0008      ADD      R0,R5,#+8
   \        0x8   0x6069             STR      R1,[R5, #+4]
   \        0xA   0x4281             CMP      R1,R0
   \        0xC   0x4770             BX       LR
   3851          
   3852          #endif /* configUSE_TRACE_FACILITY */
   3853          /*-----------------------------------------------------------*/
   3854          
   3855          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
   3856          

   \                                 In section .text, align 2, keep-with-next
   3857              static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3858              {
   \                     prvTaskCheckFreeStackSpace: (+1)
   \        0x0   0x4601             MOV      R1,R0
   3859                  uint32_t ulCount = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xE000             B.N      ??prvTaskCheckFreeStackSpace_0
   3860          
   3861                  while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3862                  {
   3863                      pucStackByte -= portSTACK_GROWTH;
   3864                      ulCount++;
   \                     ??prvTaskCheckFreeStackSpace_1: (+1)
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   3865                  }
   \                     ??prvTaskCheckFreeStackSpace_0: (+1)
   \        0x8   0xF811 0x2B01      LDRB     R2,[R1], #+1
   \        0xC   0x2AA5             CMP      R2,#+165
   \        0xE   0xD0FA             BEQ.N    ??prvTaskCheckFreeStackSpace_1
   3866          
   3867                  ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3868          
   3869                  return ( configSTACK_DEPTH_TYPE ) ulCount;
   \       0x10   0x0380             LSLS     R0,R0,#+14
   \       0x12   0x0C00             LSRS     R0,R0,#+16
   \       0x14   0x4770             BX       LR
   3870              }
   3871          
   3872          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */
   3873          /*-----------------------------------------------------------*/
   3874          
   3875          #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
   3876          
   3877          /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
   3878           * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
   3879           * user to determine the return type.  It gets around the problem of the value
   3880           * overflowing on 8-bit types without breaking backward compatibility for
   3881           * applications that expect an 8-bit return type. */
   3882              configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
   3883              {
   3884                  TCB_t * pxTCB;
   3885                  uint8_t * pucEndOfStack;
   3886                  configSTACK_DEPTH_TYPE uxReturn;
   3887          
   3888                  /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
   3889                   * the same except for their return type.  Using configSTACK_DEPTH_TYPE
   3890                   * allows the user to determine the return type.  It gets around the
   3891                   * problem of the value overflowing on 8-bit types without breaking
   3892                   * backward compatibility for applications that expect an 8-bit return
   3893                   * type. */
   3894          
   3895                  pxTCB = prvGetTCBFromHandle( xTask );
   3896          
   3897                  #if portSTACK_GROWTH < 0
   3898                      {
   3899                          pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3900                      }
   3901                  #else
   3902                      {
   3903                          pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3904                      }
   3905                  #endif
   3906          
   3907                  uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
   3908          
   3909                  return uxReturn;
   3910              }
   3911          
   3912          #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
   3913          /*-----------------------------------------------------------*/
   3914          
   3915          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3916          

   \                                 In section .text, align 2, keep-with-next
   3917              UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3918              {
   3919                  TCB_t * pxTCB;
   3920                  uint8_t * pucEndOfStack;
   3921                  UBaseType_t uxReturn;
   3922          
   3923                  pxTCB = prvGetTCBFromHandle( xTask );
   \                     uxTaskGetStackHighWaterMark: (+1)
   \        0x0   0xB910             CBNZ.N   R0,??uxTaskGetStackHighWaterMark_0
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \        0x6   0x6A80             LDR      R0,[R0, #+40]
   3924          
   3925                  #if portSTACK_GROWTH < 0
   3926                      {
   3927                          pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3928                      }
   3929                  #else
   3930                      {
   3931                          pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3932                      }
   3933                  #endif
   3934          
   3935                  uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3936          
   3937                  return uxReturn;
   \                     ??uxTaskGetStackHighWaterMark_0: (+1)
   \        0x8   0x6B00             LDR      R0,[R0, #+48]
   \        0xA   0x....             B.N      prvTaskCheckFreeStackSpace
   3938              }
   3939          
   3940          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3941          /*-----------------------------------------------------------*/
   3942          
   3943          #if ( INCLUDE_vTaskDelete == 1 )
   3944          

   \                                 In section .text, align 2, keep-with-next
   3945              static void prvDeleteTCB( TCB_t * pxTCB )
   3946              {
   \                     prvDeleteTCB: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   3947                  /* This call is required specifically for the TriCore port.  It must be
   3948                   * above the vPortFree() calls.  The call is also used by ports/demos that
   3949                   * want to allocate and clean RAM statically. */
   3950                  portCLEAN_UP_TCB( pxTCB );
   3951          
   3952                  /* Free up the memory allocated by the scheduler for the task.  It is up
   3953                   * to the task to free any memory allocated at the application level.
   3954                   * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
   3955                   * for additional information. */
   3956                  #if ( configUSE_NEWLIB_REENTRANT == 1 )
   3957                      {
   3958                          _reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3959                      }
   3960                  #endif /* configUSE_NEWLIB_REENTRANT */
   3961          
   3962                  #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
   3963                      {
   3964                          /* The task can only have been allocated dynamically - free both
   3965                           * the stack and TCB. */
   3966                          vPortFree( pxTCB->pxStack );
   3967                          vPortFree( pxTCB );
   3968                      }
   3969                  #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
   3970                      {
   3971                          /* The task could have been allocated statically or dynamically, so
   3972                           * check what was statically allocated before trying to free the
   3973                           * memory. */
   3974                          if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   \        0x4   0xF894 0x005D      LDRB     R0,[R4, #+93]
   \        0x8   0xB918             CBNZ.N   R0,??prvDeleteTCB_0
   3975                          {
   3976                              /* Both the stack and TCB were allocated dynamically, so both
   3977                               * must be freed. */
   3978                              vPortFree( pxTCB->pxStack );
   \        0xA   0x6B20             LDR      R0,[R4, #+48]
   \        0xC   0x.... 0x....      BL       vPortFree
   3979                              vPortFree( pxTCB );
   \       0x10   0xE001             B.N      ??prvDeleteTCB_1
   3980                          }
   3981                          else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   \                     ??prvDeleteTCB_0: (+1)
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD104             BNE.N    ??prvDeleteTCB_2
   3982                          {
   3983                              /* Only the stack was statically allocated, so the TCB is the
   3984                               * only memory that must be freed. */
   3985                              vPortFree( pxTCB );
   \                     ??prvDeleteTCB_1: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x.... 0x....      B.W      vPortFree
   3986                          }
   3987                          else
   3988                          {
   3989                              /* Neither the stack nor the TCB were allocated dynamically, so
   3990                               * nothing needs to be freed. */
   3991                              configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
   \                     ??prvDeleteTCB_2: (+1)
   \       0x20   0x2802             CMP      R0,#+2
   \       0x22   0xD007             BEQ.N    ??prvDeleteTCB_3
   \       0x24   0xF640 0x7197      MOVW     R1,#+3991
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable56_2
   \       0x2C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x30   0x.... 0x....      B.W      assertEFM
   3992                              mtCOVERAGE_TEST_MARKER();
   3993                          }
   3994                      }
   3995                  #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   3996              }
   \                     ??prvDeleteTCB_3: (+1)
   \       0x34   0xBD10             POP      {R4,PC}
   3997          
   3998          #endif /* INCLUDE_vTaskDelete */
   3999          /*-----------------------------------------------------------*/
   4000          

   \                                 In section .text, align 2, keep-with-next
   4001          static void prvResetNextTaskUnblockTime( void )
   4002          {
   4003              if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   \                     prvResetNextTaskUnblockTime: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable42
   \        0x2   0x6AC8             LDR      R0,[R1, #+44]
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xB918             CBNZ.N   R0,??prvResetNextTaskUnblockTime_0
   4004              {
   4005                  /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
   4006                   * the maximum possible value so it is  extremely unlikely that the
   4007                   * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   4008                   * there is an item in the delayed list. */
   4009                  xNextTaskUnblockTime = portMAX_DELAY;
   \        0x8   0xF04F 0x32FF      MOV      R2,#+4294967295
   \        0xC   0x66CA             STR      R2,[R1, #+108]
   \        0xE   0x4770             BX       LR
   4010              }
   4011              else
   4012              {
   4013                  /* The new current delayed list is not empty, get the value of
   4014                   * the item at the head of the delayed list.  This is the time at
   4015                   * which the task at the head of the delayed list should be removed
   4016                   * from the Blocked state. */
   4017                  xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
   \                     ??prvResetNextTaskUnblockTime_0: (+1)
   \       0x10   0x6ACB             LDR      R3,[R1, #+44]
   \       0x12   0x68DA             LDR      R2,[R3, #+12]
   \       0x14   0x6810             LDR      R0,[R2, #+0]
   \       0x16   0x66C8             STR      R0,[R1, #+108]
   4018              }
   4019          }
   \       0x18   0x4770             BX       LR
   4020          /*-----------------------------------------------------------*/
   4021          
   4022          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   4023          

   \                                 In section .text, align 2, keep-with-next
   4024              TaskHandle_t xTaskGetCurrentTaskHandle( void )
   4025              {
   4026                  TaskHandle_t xReturn;
   4027          
   4028                  /* A critical section is not required as this is not called from
   4029                   * an interrupt and the current TCB will always be the same for any
   4030                   * individual execution thread. */
   4031                  xReturn = pxCurrentTCB;
   4032          
   4033                  return xReturn;
   \                     xTaskGetCurrentTaskHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable56_1
   \        0x4   0x6A80             LDR      R0,[R0, #+40]
   \        0x6   0x4770             BX       LR
   4034              }
   4035          
   4036          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   4037          /*-----------------------------------------------------------*/
   4038          
   4039          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   4040          

   \                                 In section .text, align 2, keep-with-next
   4041              BaseType_t xTaskGetSchedulerState( void )
   4042              {
   4043                  BaseType_t xReturn;
   4044          
   4045                  if( xSchedulerRunning == pdFALSE )
   \                     xTaskGetSchedulerState: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \        0x4   0x6D88             LDR      R0,[R1, #+88]
   \        0x6   0xB908             CBNZ.N   R0,??xTaskGetSchedulerState_0
   4046                  {
   4047                      xReturn = taskSCHEDULER_NOT_STARTED;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   4048                  }
   4049                  else
   4050                  {
   4051                      if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??xTaskGetSchedulerState_0: (+1)
   \        0xC   0x6F48             LDR      R0,[R1, #+116]
   \        0xE   0xB908             CBNZ.N   R0,??xTaskGetSchedulerState_1
   4052                      {
   4053                          xReturn = taskSCHEDULER_RUNNING;
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0x4770             BX       LR
   4054                      }
   4055                      else
   4056                      {
   4057                          xReturn = taskSCHEDULER_SUSPENDED;
   \                     ??xTaskGetSchedulerState_1: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   4058                      }
   4059                  }
   4060          
   4061                  return xReturn;
   \       0x16   0x4770             BX       LR
   4062              }
   4063          
   4064          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   4065          /*-----------------------------------------------------------*/
   4066          
   4067          #if ( configUSE_MUTEXES == 1 )
   4068          

   \                                 In section .text, align 2, keep-with-next
   4069              BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   4070              {
   \                     xTaskPriorityInherit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   4071                  TCB_t * const pxMutexHolderTCB = pxMutexHolder;
   4072                  BaseType_t xReturn = pdFALSE;
   \        0x4   0x2000             MOVS     R0,#+0
   4073          
   4074                  /* If the mutex was given back by an interrupt while the queue was
   4075                   * locked then the mutex holder might now be NULL.  _RB_ Is this still
   4076                   * needed as interrupts can no longer use mutexes? */
   4077                  if( pxMutexHolder != NULL )
   \        0x6   0xB37C             CBZ.N    R4,??xTaskPriorityInherit_0
   4078                  {
   4079                      /* If the holder of the mutex has a priority below the priority of
   4080                       * the task attempting to obtain the mutex then it will temporarily
   4081                       * inherit the priority of the task attempting to obtain the mutex. */
   4082                      if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   \        0x8   0x6AE1             LDR      R1,[R4, #+44]
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable56_1
   \        0xE   0x6AAB             LDR      R3,[R5, #+40]
   \       0x10   0x6ADA             LDR      R2,[R3, #+44]
   \       0x12   0x4291             CMP      R1,R2
   \       0x14   0xD222             BCS.N    ??xTaskPriorityInherit_1
   4083                      {
   4084                          /* Adjust the mutex holder state to account for its new
   4085                           * priority.  Only reset the event list item value if the value is
   4086                           * not being used for anything else. */
   4087                          if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   \       0x16   0x69A3             LDR      R3,[R4, #+24]
   \       0x18   0x2B00             CMP      R3,#+0
   \       0x1A   0xD404             BMI.N    ??xTaskPriorityInherit_2
   4088                          {
   4089                              listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \       0x1C   0x6AAA             LDR      R2,[R5, #+40]
   \       0x1E   0x6AD0             LDR      R0,[R2, #+44]
   \       0x20   0xF1C0 0x0038      RSB      R0,R0,#+56
   \       0x24   0x61A0             STR      R0,[R4, #+24]
   4090                          }
   4091                          else
   4092                          {
   4093                              mtCOVERAGE_TEST_MARKER();
   4094                          }
   4095          
   4096                          /* If the task being modified is in the ready state it will need
   4097                           * to be moved into a new list. */
   4098                          if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   \                     ??xTaskPriorityInherit_2: (+1)
   \       0x26   0x2714             MOVS     R7,#+20
   \       0x28   0x4379             MULS     R1,R7,R1
   \       0x2A   0x6962             LDR      R2,[R4, #+20]
   \       0x2C   0x.... 0x....      LDR.W    R6,??DataTable56
   \       0x30   0x4431             ADD      R1,R6,R1
   \       0x32   0x428A             CMP      R2,R1
   \       0x34   0xD10E             BNE.N    ??xTaskPriorityInherit_3
   4099                          {
   4100                              if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x36   0x.... 0x....      BL       ?Subroutine14
   4101                              {
   4102                                  /* It is known that the task is in its ready list so
   4103                                   * there is no need to check again and the port level
   4104                                   * reset macro can be called directly. */
   4105                                  portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
   4106                              }
   4107                              else
   4108                              {
   4109                                  mtCOVERAGE_TEST_MARKER();
   4110                              }
   4111          
   4112                              /* Inherit the priority before being moved into the new list. */
   4113                              pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0x3A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x3C   0x6AC0             LDR      R0,[R0, #+44]
   4114                              prvAddTaskToReadyList( pxMutexHolderTCB );
   \       0x3E   0x6D69             LDR      R1,[R5, #+84]
   \       0x40   0x4281             CMP      R1,R0
   \       0x42   0xBF38             IT       CC
   \       0x44   0x6568             STRCC    R0,[R5, #+84]
   \       0x46   0x4347             MULS     R7,R7,R0
   \       0x48   0x62E0             STR      R0,[R4, #+44]
   \       0x4A   0x1D21             ADDS     R1,R4,#+4
   \       0x4C   0x19F0             ADDS     R0,R6,R7
   \       0x4E   0x.... 0x....      BL       vListInsertEnd
   \       0x52   0xE008             B.N      ??xTaskPriorityInherit_4
   4115                          }
   4116                          else
   4117                          {
   4118                              /* Just inherit the priority. */
   4119                              pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   \                     ??xTaskPriorityInherit_3: (+1)
   \       0x54   0x6AA9             LDR      R1,[R5, #+40]
   \       0x56   0x6AC8             LDR      R0,[R1, #+44]
   \       0x58   0x62E0             STR      R0,[R4, #+44]
   4120                          }
   4121          
   4122                          traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
   4123          
   4124                          /* Inheritance occurred. */
   4125                          xReturn = pdTRUE;
   \       0x5A   0xE004             B.N      ??xTaskPriorityInherit_4
   4126                      }
   4127                      else
   4128                      {
   4129                          if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   \                     ??xTaskPriorityInherit_1: (+1)
   \       0x5C   0x6CA1             LDR      R1,[R4, #+72]
   \       0x5E   0x6AAB             LDR      R3,[R5, #+40]
   \       0x60   0x6ADA             LDR      R2,[R3, #+44]
   \       0x62   0x4291             CMP      R1,R2
   \       0x64   0xD200             BCS.N    ??xTaskPriorityInherit_0
   4130                          {
   4131                              /* The base priority of the mutex holder is lower than the
   4132                               * priority of the task attempting to take the mutex, but the
   4133                               * current priority of the mutex holder is not lower than the
   4134                               * priority of the task attempting to take the mutex.
   4135                               * Therefore the mutex holder must have already inherited a
   4136                               * priority, but inheritance would have occurred if that had
   4137                               * not been the case. */
   4138                              xReturn = pdTRUE;
   \                     ??xTaskPriorityInherit_4: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
   4139                          }
   4140                          else
   4141                          {
   4142                              mtCOVERAGE_TEST_MARKER();
   4143                          }
   4144                      }
   4145                  }
   4146                  else
   4147                  {
   4148                      mtCOVERAGE_TEST_MARKER();
   4149                  }
   4150          
   4151                  return xReturn;
   \                     ??xTaskPriorityInherit_0: (+1)
   \       0x68   0xBDF2             POP      {R1,R4-R7,PC}
   4152              }
   4153          
   4154          #endif /* configUSE_MUTEXES */
   4155          /*-----------------------------------------------------------*/
   4156          
   4157          #if ( configUSE_MUTEXES == 1 )
   4158          

   \                                 In section .text, align 2, keep-with-next
   4159              BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   4160              {
   \                     xTaskPriorityDisinherit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   4161                  TCB_t * const pxTCB = pxMutexHolder;
   4162                  BaseType_t xReturn = pdFALSE;
   \        0x4   0x2500             MOVS     R5,#+0
   4163          
   4164                  if( pxMutexHolder != NULL )
   \        0x6   0xB334             CBZ.N    R4,??xTaskPriorityDisinherit_0
   4165                  {
   4166                      /* A task can only have an inherited priority if it holds the mutex.
   4167                       * If the mutex is held by a task then it cannot be given from an
   4168                       * interrupt, and if a mutex is given by the holding task then it must
   4169                       * be the running state task. */
   4170                      configASSERT( pxTCB == pxCurrentTCB );
   \        0x8   0x.... 0x....      LDR.W    R6,??DataTable56_1
   \        0xC   0x6AB2             LDR      R2,[R6, #+40]
   \        0xE   0x.... 0x....      LDR.W    R7,??DataTable56_2
   \       0x12   0x4294             CMP      R4,R2
   \       0x14   0xD003             BEQ.N    ??CrossCallReturnLabel_39
   \       0x16   0xF241 0x014A      MOVW     R1,#+4170
   \       0x1A   0x.... 0x....      BL       ?Subroutine7
   4171                      configASSERT( pxTCB->uxMutexesHeld );
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x1E   0x6CE0             LDR      R0,[R4, #+76]
   \       0x20   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_38
   \       0x22   0xF241 0x014B      MOVW     R1,#+4171
   \       0x26   0x.... 0x....      BL       ?Subroutine7
   4172                      ( pxTCB->uxMutexesHeld )--;
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x2A   0x6CE0             LDR      R0,[R4, #+76]
   4173          
   4174                      /* Has the holder of the mutex inherited the priority of another
   4175                       * task? */
   4176                      if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   \       0x2C   0x6AE2             LDR      R2,[R4, #+44]
   \       0x2E   0x6CA1             LDR      R1,[R4, #+72]
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0x64E0             STR      R0,[R4, #+76]
   \       0x34   0x428A             CMP      R2,R1
   \       0x36   0xD00E             BEQ.N    ??xTaskPriorityDisinherit_0
   4177                      {
   4178                          /* Only disinherit if no other mutexes are held. */
   4179                          if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   \       0x38   0xB968             CBNZ.N   R0,??xTaskPriorityDisinherit_0
   4180                          {
   4181                              /* A task can only have an inherited priority if it holds
   4182                               * the mutex.  If the mutex is held by a task then it cannot be
   4183                               * given from an interrupt, and if a mutex is given by the
   4184                               * holding task then it must be the running state task.  Remove
   4185                               * the holding task from the ready list. */
   4186                              if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x3A   0x.... 0x....      BL       ?Subroutine14
   4187                              {
   4188                                  portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
   4189                              }
   4190                              else
   4191                              {
   4192                                  mtCOVERAGE_TEST_MARKER();
   4193                              }
   4194          
   4195                              /* Disinherit the priority before adding the task into the
   4196                               * new  ready list. */
   4197                              traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   4198                              pxTCB->uxPriority = pxTCB->uxBasePriority;
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0x3E   0x6CA2             LDR      R2,[R4, #+72]
   4199          
   4200                              /* Reset the event list item value.  It cannot be in use for
   4201                               * any other purpose if this task is running, and it must be
   4202                               * running to give back the mutex. */
   4203                              listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \       0x40   0xF1C2 0x0138      RSB      R1,R2,#+56
   \       0x44   0x61A1             STR      R1,[R4, #+24]
   \       0x46   0x62E2             STR      R2,[R4, #+44]
   4204                              prvAddTaskToReadyList( pxTCB );
   \       0x48   0x6D70             LDR      R0,[R6, #+84]
   \       0x4A   0x4290             CMP      R0,R2
   \       0x4C   0xBF38             IT       CC
   \       0x4E   0x6572             STRCC    R2,[R6, #+84]
   \       0x50   0x.... 0x....      BL       ?Subroutine12
   4205          
   4206                              /* Return true to indicate that a context switch is required.
   4207                               * This is only actually required in the corner case whereby
   4208                               * multiple mutexes were held and the mutexes were given back
   4209                               * in an order different to that in which they were taken.
   4210                               * If a context switch did not occur when the first mutex was
   4211                               * returned, even if a task was waiting on it, then a context
   4212                               * switch should occur when the last mutex is returned whether
   4213                               * a task is waiting on it or not. */
   4214                              xReturn = pdTRUE;
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x54   0x2501             MOVS     R5,#+1
   4215                          }
   4216                          else
   4217                          {
   4218                              mtCOVERAGE_TEST_MARKER();
   4219                          }
   4220                      }
   4221                      else
   4222                      {
   4223                          mtCOVERAGE_TEST_MARKER();
   4224                      }
   4225                  }
   4226                  else
   4227                  {
   4228                      mtCOVERAGE_TEST_MARKER();
   4229                  }
   4230          
   4231                  return xReturn;
   \                     ??xTaskPriorityDisinherit_0: (+1)
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
   4232              }
   4233          
   4234          #endif /* configUSE_MUTEXES */
   4235          /*-----------------------------------------------------------*/
   4236          
   4237          #if ( configUSE_MUTEXES == 1 )
   4238          

   \                                 In section .text, align 2, keep-with-next
   4239              void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
   4240                                                        UBaseType_t uxHighestPriorityWaitingTask )
   4241              {
   \                     vTaskPriorityDisinheritAfterTimeout: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   4242                  TCB_t * const pxTCB = pxMutexHolder;
   4243                  UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
   4244                  const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   4245          
   4246                  if( pxMutexHolder != NULL )
   \        0x6   0xD037             BEQ.N    ??vTaskPriorityDisinheritAfterTimeout_0
   4247                  {
   4248                      /* If pxMutexHolder is not NULL then the holder must hold at least
   4249                       * one mutex. */
   4250                      configASSERT( pxTCB->uxMutexesHeld );
   \        0x8   0x6CE2             LDR      R2,[R4, #+76]
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable56_2
   \        0xE   0xB922             CBNZ.N   R2,??vTaskPriorityDisinheritAfterTimeout_1
   \       0x10   0xF241 0x019A      MOVW     R1,#+4250
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x.... 0x....      BL       assertEFM
   4251          
   4252                      /* Determine the priority to which the priority of the task that
   4253                       * holds the mutex should be set.  This will be the greater of the
   4254                       * holding task's base priority and the priority of the highest
   4255                       * priority task that is waiting to obtain the mutex. */
   4256                      if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   \                     ??vTaskPriorityDisinheritAfterTimeout_1: (+1)
   \       0x1A   0x6CA0             LDR      R0,[R4, #+72]
   \       0x1C   0x4286             CMP      R6,R0
   \       0x1E   0xBF38             IT       CC
   \       0x20   0x4606             MOVCC    R6,R0
   4257                      {
   4258                          uxPriorityToUse = uxHighestPriorityWaitingTask;
   4259                      }
   4260                      else
   4261                      {
   4262                          uxPriorityToUse = pxTCB->uxBasePriority;
   4263                      }
   4264          
   4265                      /* Does the priority need to change? */
   4266                      if( pxTCB->uxPriority != uxPriorityToUse )
   \       0x22   0x6AE1             LDR      R1,[R4, #+44]
   \       0x24   0x42B1             CMP      R1,R6
   \       0x26   0xD027             BEQ.N    ??vTaskPriorityDisinheritAfterTimeout_0
   4267                      {
   4268                          /* Only disinherit if no other mutexes are held.  This is a
   4269                           * simplification in the priority inheritance implementation.  If
   4270                           * the task that holds the mutex is also holding other mutexes then
   4271                           * the other mutexes may have caused the priority inheritance. */
   4272                          if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   \       0x28   0x6CE0             LDR      R0,[R4, #+76]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD124             BNE.N    ??vTaskPriorityDisinheritAfterTimeout_0
   4273                          {
   4274                              /* If a task has timed out because it already holds the
   4275                               * mutex it was trying to obtain then it cannot of inherited
   4276                               * its own priority. */
   4277                              configASSERT( pxTCB != pxCurrentTCB );
   \       0x2E   0x.... 0x....      LDR.W    R7,??DataTable56_1
   \       0x32   0x6AB8             LDR      R0,[R7, #+40]
   \       0x34   0x4284             CMP      R4,R0
   \       0x36   0xD104             BNE.N    ??vTaskPriorityDisinheritAfterTimeout_2
   \       0x38   0xF241 0x01B5      MOVW     R1,#+4277
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       assertEFM
   4278          
   4279                              /* Disinherit the priority, remembering the previous
   4280                               * priority to facilitate determining the subject task's
   4281                               * state. */
   4282                              traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
   4283                              uxPriorityUsedOnEntry = pxTCB->uxPriority;
   4284                              pxTCB->uxPriority = uxPriorityToUse;
   4285          
   4286                              /* Only reset the event list item value if the value is not
   4287                               * being used for anything else. */
   4288                              if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   \                     ??vTaskPriorityDisinheritAfterTimeout_2: (+1)
   \       0x42   0x69A2             LDR      R2,[R4, #+24]
   \       0x44   0x6AE0             LDR      R0,[R4, #+44]
   \       0x46   0x62E6             STR      R6,[R4, #+44]
   \       0x48   0x2A00             CMP      R2,#+0
   \       0x4A   0xBF5C             ITT      PL
   \       0x4C   0xF1C6 0x0638      RSBPL    R6,R6,#+56
   \       0x50   0x61A6             STRPL    R6,[R4, #+24]
   4289                              {
   4290                                  listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   4291                              }
   4292                              else
   4293                              {
   4294                                  mtCOVERAGE_TEST_MARKER();
   4295                              }
   4296          
   4297                              /* If the running task is not the task that holds the mutex
   4298                               * then the task that holds the mutex could be in either the
   4299                               * Ready, Blocked or Suspended states.  Only remove the task
   4300                               * from its current state list if it is in the Ready state as
   4301                               * the task's priority is going to change and there is one
   4302                               * Ready list per priority. */
   4303                              if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   \       0x52   0x2614             MOVS     R6,#+20
   \       0x54   0x4370             MULS     R0,R6,R0
   \       0x56   0x6961             LDR      R1,[R4, #+20]
   \       0x58   0x.... 0x....      LDR.W    R5,??DataTable56
   \       0x5C   0x4428             ADD      R0,R5,R0
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xD10A             BNE.N    ??vTaskPriorityDisinheritAfterTimeout_0
   4304                              {
   4305                                  if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x62   0x.... 0x....      BL       ?Subroutine14
   4306                                  {
   4307                                      /* It is known that the task is in its ready list so
   4308                                       * there is no need to check again and the port level
   4309                                       * reset macro can be called directly. */
   4310                                      portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
   4311                                  }
   4312                                  else
   4313                                  {
   4314                                      mtCOVERAGE_TEST_MARKER();
   4315                                  }
   4316          
   4317                                  prvAddTaskToReadyList( pxTCB );
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0x66   0x6AE0             LDR      R0,[R4, #+44]
   \       0x68   0x6D79             LDR      R1,[R7, #+84]
   \       0x6A   0x4281             CMP      R1,R0
   \       0x6C   0xBF38             IT       CC
   \       0x6E   0x6578             STRCC    R0,[R7, #+84]
   \       0x70   0x4346             MULS     R6,R6,R0
   \       0x72   0x1D21             ADDS     R1,R4,#+4
   \       0x74   0x19A8             ADDS     R0,R5,R6
   \       0x76   0x....             B.N      ?Subroutine2
   4318                              }
   4319                              else
   4320                              {
   4321                                  mtCOVERAGE_TEST_MARKER();
   4322                              }
   4323                          }
   4324                          else
   4325                          {
   4326                              mtCOVERAGE_TEST_MARKER();
   4327                          }
   4328                      }
   4329                      else
   4330                      {
   4331                          mtCOVERAGE_TEST_MARKER();
   4332                      }
   4333                  }
   4334                  else
   4335                  {
   4336                      mtCOVERAGE_TEST_MARKER();
   4337                  }
   4338              }
   \                     ??vTaskPriorityDisinheritAfterTimeout_0: (+1)
   \       0x78   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \        0x4   0x.... 0x....      B.W      vListInsertEnd
   4339          
   4340          #endif /* configUSE_MUTEXES */
   4341          /*-----------------------------------------------------------*/
   4342          
   4343          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   4344          
   4345              void vTaskEnterCritical( void )
   4346              {
   4347                  portDISABLE_INTERRUPTS();
   4348          
   4349                  if( xSchedulerRunning != pdFALSE )
   4350                  {
   4351                      ( pxCurrentTCB->uxCriticalNesting )++;
   4352          
   4353                      /* This is not the interrupt safe version of the enter critical
   4354                       * function so  assert() if it is being called from an interrupt
   4355                       * context.  Only API functions that end in "FromISR" can be used in an
   4356                       * interrupt.  Only assert if the critical nesting count is 1 to
   4357                       * protect against recursive calls if the assert function also uses a
   4358                       * critical section. */
   4359                      if( pxCurrentTCB->uxCriticalNesting == 1 )
   4360                      {
   4361                          portASSERT_IF_IN_ISR();
   4362                      }
   4363                  }
   4364                  else
   4365                  {
   4366                      mtCOVERAGE_TEST_MARKER();
   4367                  }
   4368              }
   4369          
   4370          #endif /* portCRITICAL_NESTING_IN_TCB */
   4371          /*-----------------------------------------------------------*/
   4372          
   4373          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   4374          
   4375              void vTaskExitCritical( void )
   4376              {
   4377                  if( xSchedulerRunning != pdFALSE )
   4378                  {
   4379                      if( pxCurrentTCB->uxCriticalNesting > 0U )
   4380                      {
   4381                          ( pxCurrentTCB->uxCriticalNesting )--;
   4382          
   4383                          if( pxCurrentTCB->uxCriticalNesting == 0U )
   4384                          {
   4385                              portENABLE_INTERRUPTS();
   4386                          }
   4387                          else
   4388                          {
   4389                              mtCOVERAGE_TEST_MARKER();
   4390                          }
   4391                      }
   4392                      else
   4393                      {
   4394                          mtCOVERAGE_TEST_MARKER();
   4395                      }
   4396                  }
   4397                  else
   4398                  {
   4399                      mtCOVERAGE_TEST_MARKER();
   4400                  }
   4401              }
   4402          
   4403          #endif /* portCRITICAL_NESTING_IN_TCB */
   4404          /*-----------------------------------------------------------*/
   4405          
   4406          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   4407          
   4408              static char * prvWriteNameToBuffer( char * pcBuffer,
   4409                                                  const char * pcTaskName )
   4410              {
   4411                  size_t x;
   4412          
   4413                  /* Start by copying the entire string. */
   4414                  strcpy( pcBuffer, pcTaskName );
   4415          
   4416                  /* Pad the end of the string with spaces to ensure columns line up when
   4417                   * printed out. */
   4418                  for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   4419                  {
   4420                      pcBuffer[ x ] = ' ';
   4421                  }
   4422          
   4423                  /* Terminate. */
   4424                  pcBuffer[ x ] = ( char ) 0x00;
   4425          
   4426                  /* Return the new end of string. */
   4427                  return &( pcBuffer[ x ] );
   4428              }
   4429          
   4430          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   4431          /*-----------------------------------------------------------*/
   4432          
   4433          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   4434          
   4435              void vTaskList( char * pcWriteBuffer )
   4436              {
   4437                  TaskStatus_t * pxTaskStatusArray;
   4438                  UBaseType_t uxArraySize, x;
   4439                  char cStatus;
   4440          
   4441                  /*
   4442                   * PLEASE NOTE:
   4443                   *
   4444                   * This function is provided for convenience only, and is used by many
   4445                   * of the demo applications.  Do not consider it to be part of the
   4446                   * scheduler.
   4447                   *
   4448                   * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   4449                   * uxTaskGetSystemState() output into a human readable table that
   4450                   * displays task names, states and stack usage.
   4451                   *
   4452                   * vTaskList() has a dependency on the sprintf() C library function that
   4453                   * might bloat the code size, use a lot of stack, and provide different
   4454                   * results on different platforms.  An alternative, tiny, third party,
   4455                   * and limited functionality implementation of sprintf() is provided in
   4456                   * many of the FreeRTOS/Demo sub-directories in a file called
   4457                   * printf-stdarg.c (note printf-stdarg.c does not provide a full
   4458                   * snprintf() implementation!).
   4459                   *
   4460                   * It is recommended that production systems call uxTaskGetSystemState()
   4461                   * directly to get access to raw stats data, rather than indirectly
   4462                   * through a call to vTaskList().
   4463                   */
   4464          
   4465          
   4466                  /* Make sure the write buffer does not contain a string. */
   4467                  *pcWriteBuffer = ( char ) 0x00;
   4468          
   4469                  /* Take a snapshot of the number of tasks in case it changes while this
   4470                   * function is executing. */
   4471                  uxArraySize = uxCurrentNumberOfTasks;
   4472          
   4473                  /* Allocate an array index for each task.  NOTE!  if
   4474                   * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4475                   * equate to NULL. */
   4476                  pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   4477          
   4478                  if( pxTaskStatusArray != NULL )
   4479                  {
   4480                      /* Generate the (binary) data. */
   4481                      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   4482          
   4483                      /* Create a human readable table from the binary data. */
   4484                      for( x = 0; x < uxArraySize; x++ )
   4485                      {
   4486                          switch( pxTaskStatusArray[ x ].eCurrentState )
   4487                          {
   4488                              case eRunning:
   4489                                  cStatus = tskRUNNING_CHAR;
   4490                                  break;
   4491          
   4492                              case eReady:
   4493                                  cStatus = tskREADY_CHAR;
   4494                                  break;
   4495          
   4496                              case eBlocked:
   4497                                  cStatus = tskBLOCKED_CHAR;
   4498                                  break;
   4499          
   4500                              case eSuspended:
   4501                                  cStatus = tskSUSPENDED_CHAR;
   4502                                  break;
   4503          
   4504                              case eDeleted:
   4505                                  cStatus = tskDELETED_CHAR;
   4506                                  break;
   4507          
   4508                              case eInvalid: /* Fall through. */
   4509                              default:       /* Should not get here, but it is included
   4510                                              * to prevent static checking errors. */
   4511                                  cStatus = ( char ) 0x00;
   4512                                  break;
   4513                          }
   4514          
   4515                          /* Write the task name to the string, padding with spaces so it
   4516                           * can be printed in tabular form more easily. */
   4517                          pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4518          
   4519                          /* Write the rest of the string. */
   4520                          sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   4521                          pcWriteBuffer += strlen( pcWriteBuffer );                                                                                                                                                                                                /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   4522                      }
   4523          
   4524                      /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4525                       * is 0 then vPortFree() will be #defined to nothing. */
   4526                      vPortFree( pxTaskStatusArray );
   4527                  }
   4528                  else
   4529                  {
   4530                      mtCOVERAGE_TEST_MARKER();
   4531                  }
   4532              }
   4533          
   4534          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
   4535          /*----------------------------------------------------------*/
   4536          
   4537          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   4538          
   4539              void vTaskGetRunTimeStats( char * pcWriteBuffer )
   4540              {
   4541                  TaskStatus_t * pxTaskStatusArray;
   4542                  UBaseType_t uxArraySize, x;
   4543                  uint32_t ulTotalTime, ulStatsAsPercentage;
   4544          
   4545                  #if ( configUSE_TRACE_FACILITY != 1 )
   4546                      {
   4547                          #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   4548                      }
   4549                  #endif
   4550          
   4551                  /*
   4552                   * PLEASE NOTE:
   4553                   *
   4554                   * This function is provided for convenience only, and is used by many
   4555                   * of the demo applications.  Do not consider it to be part of the
   4556                   * scheduler.
   4557                   *
   4558                   * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   4559                   * of the uxTaskGetSystemState() output into a human readable table that
   4560                   * displays the amount of time each task has spent in the Running state
   4561                   * in both absolute and percentage terms.
   4562                   *
   4563                   * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   4564                   * function that might bloat the code size, use a lot of stack, and
   4565                   * provide different results on different platforms.  An alternative,
   4566                   * tiny, third party, and limited functionality implementation of
   4567                   * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   4568                   * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   4569                   * a full snprintf() implementation!).
   4570                   *
   4571                   * It is recommended that production systems call uxTaskGetSystemState()
   4572                   * directly to get access to raw stats data, rather than indirectly
   4573                   * through a call to vTaskGetRunTimeStats().
   4574                   */
   4575          
   4576                  /* Make sure the write buffer does not contain a string. */
   4577                  *pcWriteBuffer = ( char ) 0x00;
   4578          
   4579                  /* Take a snapshot of the number of tasks in case it changes while this
   4580                   * function is executing. */
   4581                  uxArraySize = uxCurrentNumberOfTasks;
   4582          
   4583                  /* Allocate an array index for each task.  NOTE!  If
   4584                   * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4585                   * equate to NULL. */
   4586                  pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   4587          
   4588                  if( pxTaskStatusArray != NULL )
   4589                  {
   4590                      /* Generate the (binary) data. */
   4591                      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   4592          
   4593                      /* For percentage calculations. */
   4594                      ulTotalTime /= 100UL;
   4595          
   4596                      /* Avoid divide by zero errors. */
   4597                      if( ulTotalTime > 0UL )
   4598                      {
   4599                          /* Create a human readable table from the binary data. */
   4600                          for( x = 0; x < uxArraySize; x++ )
   4601                          {
   4602                              /* What percentage of the total run time has the task used?
   4603                               * This will always be rounded down to the nearest integer.
   4604                               * ulTotalRunTimeDiv100 has already been divided by 100. */
   4605                              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   4606          
   4607                              /* Write the task name to the string, padding with
   4608                               * spaces so it can be printed in tabular form more
   4609                               * easily. */
   4610                              pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4611          
   4612                              if( ulStatsAsPercentage > 0UL )
   4613                              {
   4614                                  #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4615                                      {
   4616                                          sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   4617                                      }
   4618                                  #else
   4619                                      {
   4620                                          /* sizeof( int ) == sizeof( long ) so a smaller
   4621                                           * printf() library can be used. */
   4622                                          sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   4623                                      }
   4624                                  #endif
   4625                              }
   4626                              else
   4627                              {
   4628                                  /* If the percentage is zero here then the task has
   4629                                   * consumed less than 1% of the total run time. */
   4630                                  #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4631                                      {
   4632                                          sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   4633                                      }
   4634                                  #else
   4635                                      {
   4636                                          /* sizeof( int ) == sizeof( long ) so a smaller
   4637                                           * printf() library can be used. */
   4638                                          sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   4639                                      }
   4640                                  #endif
   4641                              }
   4642          
   4643                              pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   4644                          }
   4645                      }
   4646                      else
   4647                      {
   4648                          mtCOVERAGE_TEST_MARKER();
   4649                      }
   4650          
   4651                      /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4652                       * is 0 then vPortFree() will be #defined to nothing. */
   4653                      vPortFree( pxTaskStatusArray );
   4654                  }
   4655                  else
   4656                  {
   4657                      mtCOVERAGE_TEST_MARKER();
   4658                  }
   4659              }
   4660          
   4661          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
   4662          /*-----------------------------------------------------------*/
   4663          

   \                                 In section .text, align 2, keep-with-next
   4664          TickType_t uxTaskResetEventItemValue( void )
   4665          {
   4666              TickType_t uxReturn;
   4667          
   4668              uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   \                     uxTaskResetEventItemValue: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable56_1
   \        0x4   0x6A90             LDR      R0,[R2, #+40]
   \        0x6   0x6980             LDR      R0,[R0, #+24]
   4669          
   4670              /* Reset the event list item to its normal value - so it can be used with
   4671               * queues and semaphores. */
   4672              listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \        0x8   0x6A91             LDR      R1,[R2, #+40]
   \        0xA   0x6A93             LDR      R3,[R2, #+40]
   \        0xC   0x6ADA             LDR      R2,[R3, #+44]
   \        0xE   0xF1C2 0x0238      RSB      R2,R2,#+56
   \       0x12   0x618A             STR      R2,[R1, #+24]
   4673          
   4674              return uxReturn;
   \       0x14   0x4770             BX       LR
   4675          }
   4676          /*-----------------------------------------------------------*/
   4677          
   4678          #if ( configUSE_MUTEXES == 1 )
   4679          

   \                                 In section .text, align 2, keep-with-next
   4680              TaskHandle_t pvTaskIncrementMutexHeldCount( void )
   4681              {
   4682                  /* If xSemaphoreCreateMutex() is called before any tasks have been created
   4683                   * then pxCurrentTCB will be NULL. */
   4684                  if( pxCurrentTCB != NULL )
   \                     pvTaskIncrementMutexHeldCount: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \        0x4   0x6A88             LDR      R0,[R1, #+40]
   \        0x6   0xB118             CBZ.N    R0,??pvTaskIncrementMutexHeldCount_0
   4685                  {
   4686                      ( pxCurrentTCB->uxMutexesHeld )++;
   \        0x8   0x6A8A             LDR      R2,[R1, #+40]
   \        0xA   0x6CD0             LDR      R0,[R2, #+76]
   \        0xC   0x1C40             ADDS     R0,R0,#+1
   \        0xE   0x64D0             STR      R0,[R2, #+76]
   4687                  }
   4688          
   4689                  return pxCurrentTCB;
   \                     ??pvTaskIncrementMutexHeldCount_0: (+1)
   \       0x10   0x6A88             LDR      R0,[R1, #+40]
   \       0x12   0x4770             BX       LR
   4690              }
   4691          
   4692          #endif /* configUSE_MUTEXES */
   4693          /*-----------------------------------------------------------*/
   4694          
   4695          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   4696          

   \                                 In section .text, align 2, keep-with-next
   4697              uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
   4698                                                BaseType_t xClearCountOnExit,
   4699                                                TickType_t xTicksToWait )
   4700              {
   \                     ulTaskGenericNotifyTake: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   4701                  uint32_t ulReturn;
   4702          
   4703                  configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
   \        0x8   0xD003             BEQ.N    ??CrossCallReturnLabel_11
   \        0xA   0xF241 0x215F      MOVW     R1,#+4703
   \        0xE   0x.... 0x....      BL       ?Subroutine5
   4704          
   4705                  taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x12   0x.... 0x....      BL       vPortEnterCritical
   4706                  {
   4707                      /* Only block if the notification count is not already non-zero. */
   4708                      if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
   \       0x16   0x.... 0x....      LDR.W    R7,??DataTable56_1
   \       0x1A   0x6AB8             LDR      R0,[R7, #+40]
   \       0x1C   0xEB00 0x0184      ADD      R1,R0,R4, LSL #+2
   \       0x20   0x6D88             LDR      R0,[R1, #+88]
   \       0x22   0xB950             CBNZ.N   R0,??ulTaskGenericNotifyTake_0
   4709                      {
   4710                          /* Mark this task as waiting for a notification. */
   4711                          pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
   \       0x24   0x6AB8             LDR      R0,[R7, #+40]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4420             ADD      R0,R0,R4
   \       0x2A   0xF880 0x105C      STRB     R1,[R0, #+92]
   4712          
   4713                          if( xTicksToWait > ( TickType_t ) 0 )
   \       0x2E   0xB126             CBZ.N    R6,??ulTaskGenericNotifyTake_0
   4714                          {
   4715                              prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   4716                              traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
   4717          
   4718                              /* All ports are written to allow a yield in a critical
   4719                               * section (some will yield immediately, others wait until the
   4720                               * critical section exits) - but it is not something that
   4721                               * application code should ever do. */
   4722                              portYIELD_WITHIN_API();
   \       0x36   0x.... 0x....      BL       vPortYield
   4723                          }
   4724                          else
   4725                          {
   4726                              mtCOVERAGE_TEST_MARKER();
   4727                          }
   4728                      }
   4729                      else
   4730                      {
   4731                          mtCOVERAGE_TEST_MARKER();
   4732                      }
   4733                  }
   4734                  taskEXIT_CRITICAL();
   \                     ??ulTaskGenericNotifyTake_0: (+1)
   \       0x3A   0x.... 0x....      BL       vPortExitCritical
   4735          
   4736                  taskENTER_CRITICAL();
   \       0x3E   0x.... 0x....      BL       vPortEnterCritical
   4737                  {
   4738                      traceTASK_NOTIFY_TAKE( uxIndexToWait );
   4739                      ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
   \       0x42   0x6AB8             LDR      R0,[R7, #+40]
   \       0x44   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x48   0x6D86             LDR      R6,[R0, #+88]
   4740          
   4741                      if( ulReturn != 0UL )
   \       0x4A   0xB13E             CBZ.N    R6,??ulTaskGenericNotifyTake_1
   4742                      {
   4743                          if( xClearCountOnExit != pdFALSE )
   \       0x4C   0x6ABA             LDR      R2,[R7, #+40]
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0xEB02 0x0184      ADD      R1,R2,R4, LSL #+2
   \       0x54   0xBF14             ITE      NE
   \       0x56   0x2000             MOVNE    R0,#+0
   \       0x58   0x1E70             SUBEQ    R0,R6,#+1
   4744                          {
   4745                              pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
   4746                          }
   4747                          else
   4748                          {
   4749                              pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
   \       0x5A   0x6588             STR      R0,[R1, #+88]
   4750                          }
   4751                      }
   4752                      else
   4753                      {
   4754                          mtCOVERAGE_TEST_MARKER();
   4755                      }
   4756          
   4757                      pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
   \                     ??ulTaskGenericNotifyTake_1: (+1)
   \       0x5C   0x6AB8             LDR      R0,[R7, #+40]
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x4420             ADD      R0,R0,R4
   \       0x62   0xF880 0x105C      STRB     R1,[R0, #+92]
   4758                  }
   4759                  taskEXIT_CRITICAL();
   \       0x66   0x.... 0x....      BL       vPortExitCritical
   4760          
   4761                  return ulReturn;
   \       0x6A   0x4630             MOV      R0,R6
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}
   4762              }
   4763          
   4764          #endif /* configUSE_TASK_NOTIFICATIONS */
   4765          /*-----------------------------------------------------------*/
   4766          
   4767          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   4768          

   \                                 In section .text, align 2, keep-with-next
   4769              BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
   4770                                                 uint32_t ulBitsToClearOnEntry,
   4771                                                 uint32_t ulBitsToClearOnExit,
   4772                                                 uint32_t * pulNotificationValue,
   4773                                                 TickType_t xTicksToWait )
   4774              {
   \                     xTaskGenericNotifyWait: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461D             MOV      R5,R3
   4775                  BaseType_t xReturn;
   4776          
   4777                  configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
   \        0xC   0xD003             BEQ.N    ??CrossCallReturnLabel_10
   \        0xE   0xF241 0x21A9      MOVW     R1,#+4777
   \       0x12   0x.... 0x....      BL       ?Subroutine5
   4778          
   4779                  taskENTER_CRITICAL();
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x16   0x.... 0x....      BL       vPortEnterCritical
   4780                  {
   4781                      /* Only block if a notification is not already pending. */
   4782                      if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
   \       0x1A   0x.... 0x....      LDR.W    R7,??DataTable56_1
   \       0x1E   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x22   0xD015             BEQ.N    ??xTaskGenericNotifyWait_0
   \       0x24   0x9806             LDR      R0,[SP, #+24]
   4783                      {
   4784                          /* Clear bits in the task's notification value as bits may get
   4785                           * set  by the notifying task or interrupt.  This can be used to
   4786                           * clear the value to zero. */
   4787                          pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
   \       0x26   0x6AB9             LDR      R1,[R7, #+40]
   \       0x28   0xF101 0x0358      ADD      R3,R1,#+88
   \       0x2C   0xF853 0x2024      LDR      R2,[R3, R4, LSL #+2]
   \       0x30   0xF101 0x0C58      ADD      R12,R1,#+88
   4788          
   4789                          /* Mark this task as waiting for a notification. */
   4790                          pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0xEA22 0x0808      BIC      R8,R2,R8
   \       0x3A   0xF84C 0x8024      STR      R8,[R12, R4, LSL #+2]
   \       0x3E   0x6ABA             LDR      R2,[R7, #+40]
   \       0x40   0x4422             ADD      R2,R2,R4
   \       0x42   0xF882 0x105C      STRB     R1,[R2, #+92]
   4791          
   4792                          if( xTicksToWait > ( TickType_t ) 0 )
   \       0x46   0xB118             CBZ.N    R0,??xTaskGenericNotifyWait_0
   4793                          {
   4794                              prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x48   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   4795                              traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
   4796          
   4797                              /* All ports are written to allow a yield in a critical
   4798                               * section (some will yield immediately, others wait until the
   4799                               * critical section exits) - but it is not something that
   4800                               * application code should ever do. */
   4801                              portYIELD_WITHIN_API();
   \       0x4C   0x.... 0x....      BL       vPortYield
   4802                          }
   4803                          else
   4804                          {
   4805                              mtCOVERAGE_TEST_MARKER();
   4806                          }
   4807                      }
   4808                      else
   4809                      {
   4810                          mtCOVERAGE_TEST_MARKER();
   4811                      }
   4812                  }
   4813                  taskEXIT_CRITICAL();
   \                     ??xTaskGenericNotifyWait_0: (+1)
   \       0x50   0x.... 0x....      BL       vPortExitCritical
   4814          
   4815                  taskENTER_CRITICAL();
   \       0x54   0x.... 0x....      BL       vPortEnterCritical
   4816                  {
   4817                      traceTASK_NOTIFY_WAIT( uxIndexToWait );
   4818          
   4819                      if( pulNotificationValue != NULL )
   \       0x58   0xB12D             CBZ.N    R5,??xTaskGenericNotifyWait_1
   4820                      {
   4821                          /* Output the current notification value, which may or may not
   4822                           * have changed. */
   4823                          *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
   \       0x5A   0x6AB8             LDR      R0,[R7, #+40]
   \       0x5C   0xF100 0x0158      ADD      R1,R0,#+88
   \       0x60   0xF851 0x0024      LDR      R0,[R1, R4, LSL #+2]
   \       0x64   0x6028             STR      R0,[R5, #+0]
   4824                      }
   4825          
   4826                      /* If ucNotifyValue is set then either the task never entered the
   4827                       * blocked state (because a notification was already pending) or the
   4828                       * task unblocked because of a notification.  Otherwise the task
   4829                       * unblocked because of a timeout. */
   4830                      if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
   \                     ??xTaskGenericNotifyWait_1: (+1)
   \       0x66   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0x6A   0xBF18             IT       NE
   \       0x6C   0x2500             MOVNE    R5,#+0
   4831                      {
   4832                          /* A notification was not received. */
   4833                          xReturn = pdFALSE;
   \       0x6E   0xD10A             BNE.N    ??xTaskGenericNotifyWait_2
   4834                      }
   4835                      else
   4836                      {
   4837                          /* A notification was already pending or a notification was
   4838                           * received while the task was waiting. */
   4839                          pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
   \       0x70   0x6AB8             LDR      R0,[R7, #+40]
   4840                          xReturn = pdTRUE;
   \       0x72   0x2501             MOVS     R5,#+1
   \       0x74   0xF100 0x0258      ADD      R2,R0,#+88
   \       0x78   0xF852 0x1024      LDR      R1,[R2, R4, LSL #+2]
   \       0x7C   0x3058             ADDS     R0,R0,#+88
   \       0x7E   0xEA21 0x0606      BIC      R6,R1,R6
   \       0x82   0xF840 0x6024      STR      R6,[R0, R4, LSL #+2]
   4841                      }
   4842          
   4843                      pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
   \                     ??xTaskGenericNotifyWait_2: (+1)
   \       0x86   0x6AB9             LDR      R1,[R7, #+40]
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x4421             ADD      R1,R1,R4
   \       0x8C   0xF881 0x005C      STRB     R0,[R1, #+92]
   4844                  }
   4845                  taskEXIT_CRITICAL();
   \       0x90   0x.... 0x....      BL       vPortExitCritical
   4846          
   4847                  return xReturn;
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0xE8BD 0x81F0      POP      {R4-R8,PC}
   4848              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x6AB8             LDR      R0,[R7, #+40]
   \        0x2   0x1901             ADDS     R1,R0,R4
   \        0x4   0xF891 0x005C      LDRB     R0,[R1, #+92]
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0x4770             BX       LR
   4849          
   4850          #endif /* configUSE_TASK_NOTIFICATIONS */
   4851          /*-----------------------------------------------------------*/
   4852          
   4853          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   4854          

   \                                 In section .text, align 4, keep-with-next
   4855              BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
   4856                                             UBaseType_t uxIndexToNotify,
   4857                                             uint32_t ulValue,
   4858                                             eNotifyAction eAction,
   4859                                             uint32_t * pulPreviousNotificationValue )
   4860              {
   \                     xTaskGenericNotify: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x4699             MOV      R9,R3
   4861                  TCB_t * pxTCB;
   4862                  BaseType_t xReturn = pdPASS;
   \        0xC   0xF04F 0x0801      MOV      R8,#+1
   4863                  uint8_t ucOriginalNotifyState;
   4864          
   4865                  configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
   \       0x10   0x.... 0x....      LDR.W    R10,??DataTable56_2
   \       0x14   0xD003             BEQ.N    ??CrossCallReturnLabel_3
   \       0x16   0xF241 0x3101      MOVW     R1,#+4865
   \       0x1A   0x.... 0x....      BL       ?Subroutine3
   4866                  configASSERT( xTaskToNotify );
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x1E   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_2
   \       0x20   0xF241 0x3102      MOVW     R1,#+4866
   \       0x24   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x28   0x9E08             LDR      R6,[SP, #+32]
   4867                  pxTCB = xTaskToNotify;
   4868          
   4869                  taskENTER_CRITICAL();
   \       0x2A   0x.... 0x....      BL       vPortEnterCritical
   4870                  {
   4871                      if( pulPreviousNotificationValue != NULL )
   \       0x2E   0xEB05 0x0084      ADD      R0,R5,R4, LSL #+2
   \       0x32   0xB10E             CBZ.N    R6,??xTaskGenericNotify_1
   4872                      {
   4873                          *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
   \       0x34   0x6D81             LDR      R1,[R0, #+88]
   \       0x36   0x6031             STR      R1,[R6, #+0]
   4874                      }
   4875          
   4876                      ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
   \                     ??xTaskGenericNotify_1: (+1)
   \       0x38   0x192A             ADDS     R2,R5,R4
   \       0x3A   0x.... 0x....      BL       ?Subroutine21
   4877          
   4878                      pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
   4879          
   4880                      switch( eAction )
   \                     ??CrossCallReturnLabel_92: (+1)
   \       0x3E   0x....             LDR.N    R4,??DataTable56_1
   \       0x40   0xF1B9 0x0F04      CMP      R9,#+4
   \       0x44   0xD812             BHI.N    ??xTaskGenericNotify_2
   \       0x46   0xE8DF 0xF009      TBB      [PC, R9]
   \                     ??xTaskGenericNotify_0:
   \       0x4A   0x17 0x03          DC8      0x17,0x3,0x6,0xF
   \              0x06 0x0F
   \       0x4E   0x0A 0x00          DC8      0xA,0x0
   4881                      {
   4882                          case eSetBits:
   4883                              pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
   \                     ??xTaskGenericNotify_3: (+1)
   \       0x50   0x6D81             LDR      R1,[R0, #+88]
   \       0x52   0x430F             ORRS     R7,R7,R1
   \       0x54   0xE008             B.N      ??xTaskGenericNotify_4
   4884                              break;
   4885          
   4886                          case eIncrement:
   4887                              ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
   \                     ??xTaskGenericNotify_5: (+1)
   \       0x56   0x6D81             LDR      R1,[R0, #+88]
   \       0x58   0x1C49             ADDS     R1,R1,#+1
   \       0x5A   0x6581             STR      R1,[R0, #+88]
   4888                              break;
   \       0x5C   0xE00C             B.N      ??CrossCallReturnLabel_1
   4889          
   4890                          case eSetValueWithOverwrite:
   4891                              pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
   4892                              break;
   4893          
   4894                          case eSetValueWithoutOverwrite:
   4895          
   4896                              if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   \                     ??xTaskGenericNotify_6: (+1)
   \       0x5E   0x2E02             CMP      R6,#+2
   \       0x60   0xBF08             IT       EQ
   \       0x62   0xF04F 0x0800      MOVEQ    R8,#+0
   \       0x66   0xD025             BEQ.N    ??xTaskGenericNotify_7
   4897                              {
   4898                                  pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
   \                     ??xTaskGenericNotify_4: (+1)
   \       0x68   0x6587             STR      R7,[R0, #+88]
   \       0x6A   0xE005             B.N      ??CrossCallReturnLabel_1
   4899                              }
   4900                              else
   4901                              {
   4902                                  /* The value could not be written to the task. */
   4903                                  xReturn = pdFAIL;
   4904                              }
   4905          
   4906                              break;
   4907          
   4908                          case eNoAction:
   4909          
   4910                              /* The task is being notified without its notify value being
   4911                               * updated. */
   4912                              break;
   4913          
   4914                          default:
   4915          
   4916                              /* Should not get here if all enums are handled.
   4917                               * Artificially force an assert by testing a value the
   4918                               * compiler can't assume is const. */
   4919                              configASSERT( xTickCount == ( TickType_t ) 0 );
   \                     ??xTaskGenericNotify_2: (+1)
   \       0x6C   0x6D20             LDR      R0,[R4, #+80]
   \       0x6E   0xB118             CBZ.N    R0,??CrossCallReturnLabel_1
   \       0x70   0xF241 0x3137      MOVW     R1,#+4919
   \       0x74   0x.... 0x....      BL       ?Subroutine3
   4920          
   4921                              break;
   4922                      }
   4923          
   4924                      traceTASK_NOTIFY( uxIndexToNotify );
   4925          
   4926                      /* If the task is in the blocked state specifically to wait for a
   4927                       * notification then unblock it now. */
   4928                      if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x78   0x2E01             CMP      R6,#+1
   \       0x7A   0xD11B             BNE.N    ??xTaskGenericNotify_7
   4929                      {
   4930                          ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x7C   0x1D28             ADDS     R0,R5,#+4
   \       0x7E   0x.... 0x....      BL       uxListRemove
   4931                          prvAddTaskToReadyList( pxTCB );
   \       0x82   0x6AEA             LDR      R2,[R5, #+44]
   \       0x84   0x6D60             LDR      R0,[R4, #+84]
   \       0x86   0x4290             CMP      R0,R2
   \       0x88   0xBF38             IT       CC
   \       0x8A   0x6562             STRCC    R2,[R4, #+84]
   \       0x8C   0x2014             MOVS     R0,#+20
   \       0x8E   0x4342             MULS     R2,R0,R2
   \       0x90   0x....             LDR.N    R3,??DataTable56
   \       0x92   0x1D29             ADDS     R1,R5,#+4
   \       0x94   0x1898             ADDS     R0,R3,R2
   \       0x96   0x.... 0x....      BL       vListInsertEnd
   4932          
   4933                          /* The task should not have been on an event list. */
   4934                          configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \       0x9A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x9C   0xB118             CBZ.N    R0,??CrossCallReturnLabel_0
   \       0x9E   0xF241 0x3146      MOVW     R1,#+4934
   \       0xA2   0x.... 0x....      BL       ?Subroutine3
   4935          
   4936                          #if ( configUSE_TICKLESS_IDLE != 0 )
   4937                              {
   4938                                  /* If a task is blocked waiting for a notification then
   4939                                   * xNextTaskUnblockTime might be set to the blocked task's time
   4940                                   * out time.  If the task is unblocked for a reason other than
   4941                                   * a timeout xNextTaskUnblockTime is normally left unchanged,
   4942                                   * because it will automatically get reset to a new value when
   4943                                   * the tick count equals xNextTaskUnblockTime.  However if
   4944                                   * tickless idling is used it might be more important to enter
   4945                                   * sleep mode at the earliest possible time - so reset
   4946                                   * xNextTaskUnblockTime here to ensure it is updated at the
   4947                                   * earliest possible time. */
   4948                                  prvResetNextTaskUnblockTime();
   4949                              }
   4950                          #endif
   4951          
   4952                          if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xA6   0x6AA1             LDR      R1,[R4, #+40]
   \       0xA8   0x6AC8             LDR      R0,[R1, #+44]
   \       0xAA   0x6AE9             LDR      R1,[R5, #+44]
   \       0xAC   0x4288             CMP      R0,R1
   \       0xAE   0xBF38             IT       CC
   4953                          {
   4954                              /* The notified task has a priority above the currently
   4955                               * executing task so a yield is required. */
   4956                              taskYIELD_IF_USING_PREEMPTION();
   \       0xB0   0x.... 0x....      BLCC     vPortYield
   4957                          }
   4958                          else
   4959                          {
   4960                              mtCOVERAGE_TEST_MARKER();
   4961                          }
   4962                      }
   4963                      else
   4964                      {
   4965                          mtCOVERAGE_TEST_MARKER();
   4966                      }
   4967                  }
   4968                  taskEXIT_CRITICAL();
   \                     ??xTaskGenericNotify_7: (+1)
   \       0xB4   0x.... 0x....      BL       vPortExitCritical
   4969          
   4970                  return xReturn;
   \       0xB8   0x4640             MOV      R0,R8
   \       0xBA   0xE8BD 0x87F0      POP      {R4-R10,PC}
   4971              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0xF892 0x605C      LDRB     R6,[R2, #+92]
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0xF882 0x105C      STRB     R1,[R2, #+92]
   \        0xA   0x4770             BX       LR
   4972          
   4973          #endif /* configUSE_TASK_NOTIFICATIONS */
   4974          /*-----------------------------------------------------------*/
   4975          
   4976          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   4977          

   \                                 In section .text, align 4, keep-with-next
   4978              BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
   4979                                                    UBaseType_t uxIndexToNotify,
   4980                                                    uint32_t ulValue,
   4981                                                    eNotifyAction eAction,
   4982                                                    uint32_t * pulPreviousNotificationValue,
   4983                                                    BaseType_t * pxHigherPriorityTaskWoken )
   4984              {
   \                     xTaskGenericNotifyFromISR: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x469B             MOV      R11,R3
   4985                  TCB_t * pxTCB;
   4986                  uint8_t ucOriginalNotifyState;
   4987                  BaseType_t xReturn = pdPASS;
   \        0xC   0x2701             MOVS     R7,#+1
   4988                  UBaseType_t uxSavedInterruptStatus;
   4989          
   4990                  configASSERT( xTaskToNotify );
   \        0xE   0x.... 0x....      LDR.W    R9,??DataTable56_2
   \       0x12   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_45
   \       0x14   0xF241 0x317E      MOVW     R1,#+4990
   \       0x18   0x.... 0x....      BL       ?Subroutine8
   4991                  configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x1C   0xB11D             CBZ.N    R5,??CrossCallReturnLabel_44
   \       0x1E   0xF241 0x317F      MOVW     R1,#+4991
   \       0x22   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x26   0x9E0A             LDR      R6,[SP, #+40]
   4992          
   4993                  /* RTOS ports that support interrupt nesting have the concept of a
   4994                   * maximum  system call (or maximum API call) interrupt priority.
   4995                   * Interrupts that are  above the maximum system call priority are keep
   4996                   * permanently enabled, even when the RTOS kernel is in a critical section,
   4997                   * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4998                   * is defined in FreeRTOSConfig.h then
   4999                   * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   5000                   * failure if a FreeRTOS API function is called from an interrupt that has
   5001                   * been assigned a priority above the configured maximum system call
   5002                   * priority.  Only FreeRTOS functions that end in FromISR can be called
   5003                   * from interrupts  that have been assigned a priority at or (logically)
   5004                   * below the maximum system call interrupt priority.  FreeRTOS maintains a
   5005                   * separate interrupt safe API to ensure interrupt entry is as fast and as
   5006                   * simple as possible.  More information (albeit Cortex-M specific) is
   5007                   * provided on the following link:
   5008                   * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   5009                  portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   5010          
   5011                  pxTCB = xTaskToNotify;
   5012          
   5013                  uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x28   0x.... 0x....      BL       ulSetInterruptMask
   \       0x2C   0x4680             MOV      R8,R0
   5014                  {
   5015                      if( pulPreviousNotificationValue != NULL )
   \       0x2E   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \       0x32   0xB10E             CBZ.N    R6,??xTaskGenericNotifyFromISR_1
   5016                      {
   5017                          *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
   \       0x34   0x6D81             LDR      R1,[R0, #+88]
   \       0x36   0x6031             STR      R1,[R6, #+0]
   5018                      }
   5019          
   5020                      ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
   \                     ??xTaskGenericNotifyFromISR_1: (+1)
   \       0x38   0x1962             ADDS     R2,R4,R5
   \       0x3A   0x.... 0x....      BL       ?Subroutine21
   5021                      pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
   5022          
   5023                      switch( eAction )
   \                     ??CrossCallReturnLabel_93: (+1)
   \       0x3E   0x....             LDR.N    R5,??DataTable56_1
   \       0x40   0xF1BB 0x0F04      CMP      R11,#+4
   \       0x44   0xD813             BHI.N    ??xTaskGenericNotifyFromISR_2
   \       0x46   0xE8DF 0xF00B      TBB      [PC, R11]
   \                     ??xTaskGenericNotifyFromISR_0:
   \       0x4A   0x18 0x03          DC8      0x18,0x3,0x7,0xF
   \              0x07 0x0F
   \       0x4E   0x0B 0x00          DC8      0xB,0x0
   5024                      {
   5025                          case eSetBits:
   5026                              pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
   \                     ??xTaskGenericNotifyFromISR_3: (+1)
   \       0x50   0x6D81             LDR      R1,[R0, #+88]
   \       0x52   0xEA4A 0x0A01      ORR      R10,R10,R1
   \       0x56   0xE007             B.N      ??xTaskGenericNotifyFromISR_4
   5027                              break;
   5028          
   5029                          case eIncrement:
   5030                              ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
   \                     ??xTaskGenericNotifyFromISR_5: (+1)
   \       0x58   0x6D81             LDR      R1,[R0, #+88]
   \       0x5A   0x1C49             ADDS     R1,R1,#+1
   \       0x5C   0x6581             STR      R1,[R0, #+88]
   5031                              break;
   \       0x5E   0xE00C             B.N      ??CrossCallReturnLabel_43
   5032          
   5033                          case eSetValueWithOverwrite:
   5034                              pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
   5035                              break;
   5036          
   5037                          case eSetValueWithoutOverwrite:
   5038          
   5039                              if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   \                     ??xTaskGenericNotifyFromISR_6: (+1)
   \       0x60   0x2E02             CMP      R6,#+2
   \       0x62   0xBF08             IT       EQ
   \       0x64   0x2700             MOVEQ    R7,#+0
   \       0x66   0xD028             BEQ.N    ??xTaskGenericNotifyFromISR_7
   5040                              {
   5041                                  pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
   \                     ??xTaskGenericNotifyFromISR_4: (+1)
   \       0x68   0xF8C0 0xA058      STR      R10,[R0, #+88]
   \       0x6C   0xE005             B.N      ??CrossCallReturnLabel_43
   5042                              }
   5043                              else
   5044                              {
   5045                                  /* The value could not be written to the task. */
   5046                                  xReturn = pdFAIL;
   5047                              }
   5048          
   5049                              break;
   5050          
   5051                          case eNoAction:
   5052          
   5053                              /* The task is being notified without its notify value being
   5054                               * updated. */
   5055                              break;
   5056          
   5057                          default:
   5058          
   5059                              /* Should not get here if all enums are handled.
   5060                               * Artificially force an assert by testing a value the
   5061                               * compiler can't assume is const. */
   5062                              configASSERT( xTickCount == ( TickType_t ) 0 );
   \                     ??xTaskGenericNotifyFromISR_2: (+1)
   \       0x6E   0x6D28             LDR      R0,[R5, #+80]
   \       0x70   0xB118             CBZ.N    R0,??CrossCallReturnLabel_43
   \       0x72   0xF241 0x31C6      MOVW     R1,#+5062
   \       0x76   0x.... 0x....      BL       ?Subroutine8
   5063                              break;
   5064                      }
   5065          
   5066                      traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
   5067          
   5068                      /* If the task is in the blocked state specifically to wait for a
   5069                       * notification then unblock it now. */
   5070                      if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x7A   0x2E01             CMP      R6,#+1
   \       0x7C   0xD11D             BNE.N    ??xTaskGenericNotifyFromISR_7
   5071                      {
   5072                          /* The task should not have been on an event list. */
   5073                          configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \       0x7E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x80   0xB118             CBZ.N    R0,??CrossCallReturnLabel_42
   \       0x82   0xF241 0x31D1      MOVW     R1,#+5073
   \       0x86   0x.... 0x....      BL       ?Subroutine8
   5074          
   5075                          if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x8A   0x6F68             LDR      R0,[R5, #+116]
   \       0x8C   0xB940             CBNZ.N   R0,??xTaskGenericNotifyFromISR_8
   5076                          {
   5077                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x8E   0x.... 0x....      BL       ?Subroutine14
   5078                              prvAddTaskToReadyList( pxTCB );
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x92   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_87: (+1)
   \       0x96   0xBF38             IT       CC
   \       0x98   0x656A             STRCC    R2,[R5, #+84]
   \       0x9A   0x.... 0x....      BL       ?Subroutine17
   5079                          }
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x9E   0xE002             B.N      ??xTaskGenericNotifyFromISR_9
   5080                          else
   5081                          {
   5082                              /* The delayed and ready lists cannot be accessed, so hold
   5083                               * this task pending until the scheduler is resumed. */
   5084                              vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskGenericNotifyFromISR_8: (+1)
   \       0xA0   0xF104 0x0118      ADD      R1,R4,#+24
   \       0xA4   0x4628             MOV      R0,R5
   \                     ??xTaskGenericNotifyFromISR_9: (+1)
   \       0xA6   0x.... 0x....      BL       vListInsertEnd
   5085                          }
   5086          
   5087                          if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0xAA   0x.... 0x....      BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0xAE   0xD204             BCS.N    ??xTaskGenericNotifyFromISR_7
   \       0xB0   0x980B             LDR      R0,[SP, #+44]
   5088                          {
   5089                              /* The notified task has a priority above the currently
   5090                               * executing task so a yield is required. */
   5091                              if( pxHigherPriorityTaskWoken != NULL )
   \       0xB2   0xB100             CBZ.N    R0,??xTaskGenericNotifyFromISR_10
   5092                              {
   5093                                  *pxHigherPriorityTaskWoken = pdTRUE;
   \       0xB4   0x6007             STR      R7,[R0, #+0]
   5094                              }
   5095          
   5096                              /* Mark that a yield is pending in case the user is not
   5097                               * using the "xHigherPriorityTaskWoken" parameter to an ISR
   5098                               * safe FreeRTOS function. */
   5099                              xYieldPending = pdTRUE;
   \                     ??xTaskGenericNotifyFromISR_10: (+1)
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0x6628             STR      R0,[R5, #+96]
   5100                          }
   5101                          else
   5102                          {
   5103                              mtCOVERAGE_TEST_MARKER();
   5104                          }
   5105                      }
   5106                  }
   5107                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskGenericNotifyFromISR_7: (+1)
   \       0xBA   0x4640             MOV      R0,R8
   \       0xBC   0x.... 0x....      BL       vClearInterruptMask
   5108          
   5109                  return xReturn;
   \       0xC0   0x4638             MOV      R0,R7
   \       0xC2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   5110              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4648             MOV      R0,R9
   \        0x2   0x.... 0x....      B.W      assertEFM
   5111          
   5112          #endif /* configUSE_TASK_NOTIFICATIONS */
   5113          /*-----------------------------------------------------------*/
   5114          
   5115          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   5116          

   \                                 In section .text, align 2, keep-with-next
   5117              void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
   5118                                                  UBaseType_t uxIndexToNotify,
   5119                                                  BaseType_t * pxHigherPriorityTaskWoken )
   5120              {
   \                     vTaskGenericNotifyGiveFromISR: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      BL       ?Subroutine9
   5121                  TCB_t * pxTCB;
   5122                  uint8_t ucOriginalNotifyState;
   5123                  UBaseType_t uxSavedInterruptStatus;
   5124          
   5125                  configASSERT( xTaskToNotify );
   \                     ??CrossCallReturnLabel_48: (+1)
   \        0x8   0x.... 0x....      LDR.W    R8,??DataTable56_2
   \        0xC   0xD103             BNE.N    ??CrossCallReturnLabel_32
   \        0xE   0xF241 0x4105      MOVW     R1,#+5125
   \       0x12   0x.... 0x....      BL       ?Subroutine6
   5126                  configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x16   0xB11E             CBZ.N    R6,??CrossCallReturnLabel_31
   \       0x18   0xF241 0x4106      MOVW     R1,#+5126
   \       0x1C   0x.... 0x....      BL       ?Subroutine6
   5127          
   5128                  /* RTOS ports that support interrupt nesting have the concept of a
   5129                   * maximum  system call (or maximum API call) interrupt priority.
   5130                   * Interrupts that are  above the maximum system call priority are keep
   5131                   * permanently enabled, even when the RTOS kernel is in a critical section,
   5132                   * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   5133                   * is defined in FreeRTOSConfig.h then
   5134                   * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   5135                   * failure if a FreeRTOS API function is called from an interrupt that has
   5136                   * been assigned a priority above the configured maximum system call
   5137                   * priority.  Only FreeRTOS functions that end in FromISR can be called
   5138                   * from interrupts  that have been assigned a priority at or (logically)
   5139                   * below the maximum system call interrupt priority.  FreeRTOS maintains a
   5140                   * separate interrupt safe API to ensure interrupt entry is as fast and as
   5141                   * simple as possible.  More information (albeit Cortex-M specific) is
   5142                   * provided on the following link:
   5143                   * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
   5144                  portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   5145          
   5146                  pxTCB = xTaskToNotify;
   5147          
   5148                  uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x20   0x.... 0x....      BL       ulSetInterruptMask
   \       0x24   0x4607             MOV      R7,R0
   5149                  {
   5150                      ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
   \       0x26   0x19A2             ADDS     R2,R4,R6
   \       0x28   0xF892 0x005C      LDRB     R0,[R2, #+92]
   5151                      pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
   \       0x2C   0x2102             MOVS     R1,#+2
   \       0x2E   0xF882 0x105C      STRB     R1,[R2, #+92]
   5152          
   5153                      /* 'Giving' is equivalent to incrementing a count in a counting
   5154                       * semaphore. */
   5155                      ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
   \       0x32   0xEB04 0x0286      ADD      R2,R4,R6, LSL #+2
   \       0x36   0x6D91             LDR      R1,[R2, #+88]
   \       0x38   0x1C49             ADDS     R1,R1,#+1
   \       0x3A   0x6591             STR      R1,[R2, #+88]
   5156          
   5157                      traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
   5158          
   5159                      /* If the task is in the blocked state specifically to wait for a
   5160                       * notification then unblock it now. */
   5161                      if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD121             BNE.N    ??vTaskGenericNotifyGiveFromISR_0
   5162                      {
   5163                          /* The task should not have been on an event list. */
   5164                          configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \       0x40   0x6AA0             LDR      R0,[R4, #+40]
   \       0x42   0xB118             CBZ.N    R0,??CrossCallReturnLabel_30
   \       0x44   0xF241 0x412C      MOVW     R1,#+5164
   \       0x48   0x.... 0x....      BL       ?Subroutine6
   5165          
   5166                          if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x4C   0x....             LDR.N    R6,??DataTable56_1
   \       0x4E   0x6F70             LDR      R0,[R6, #+116]
   \       0x50   0xB948             CBNZ.N   R0,??vTaskGenericNotifyGiveFromISR_1
   5167                          {
   5168                              ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x52   0x.... 0x....      BL       ?Subroutine14
   5169                              prvAddTaskToReadyList( pxTCB );
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0x56   0x6AE2             LDR      R2,[R4, #+44]
   \       0x58   0x6D70             LDR      R0,[R6, #+84]
   \       0x5A   0x4290             CMP      R0,R2
   \       0x5C   0xBF38             IT       CC
   \       0x5E   0x6572             STRCC    R2,[R6, #+84]
   \       0x60   0x.... 0x....      BL       ?Subroutine17
   5170                          }
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x64   0xE002             B.N      ??vTaskGenericNotifyGiveFromISR_2
   5171                          else
   5172                          {
   5173                              /* The delayed and ready lists cannot be accessed, so hold
   5174                               * this task pending until the scheduler is resumed. */
   5175                              vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??vTaskGenericNotifyGiveFromISR_1: (+1)
   \       0x66   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x6A   0x4630             MOV      R0,R6
   \                     ??vTaskGenericNotifyGiveFromISR_2: (+1)
   \       0x6C   0x.... 0x....      BL       vListInsertEnd
   5176                          }
   5177          
   5178                          if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0x70   0x6AB1             LDR      R1,[R6, #+40]
   \       0x72   0x6AC8             LDR      R0,[R1, #+44]
   \       0x74   0x6AE1             LDR      R1,[R4, #+44]
   \       0x76   0x4288             CMP      R0,R1
   \       0x78   0xD204             BCS.N    ??vTaskGenericNotifyGiveFromISR_0
   5179                          {
   5180                              /* The notified task has a priority above the currently
   5181                               * executing task so a yield is required. */
   5182                              if( pxHigherPriorityTaskWoken != NULL )
   \       0x7A   0xB10D             CBZ.N    R5,??vTaskGenericNotifyGiveFromISR_3
   5183                              {
   5184                                  *pxHigherPriorityTaskWoken = pdTRUE;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0x6028             STR      R0,[R5, #+0]
   5185                              }
   5186          
   5187                              /* Mark that a yield is pending in case the user is not
   5188                               * using the "xHigherPriorityTaskWoken" parameter in an ISR
   5189                               * safe FreeRTOS function. */
   5190                              xYieldPending = pdTRUE;
   \                     ??vTaskGenericNotifyGiveFromISR_3: (+1)
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x6631             STR      R1,[R6, #+96]
   5191                          }
   5192                          else
   5193                          {
   5194                              mtCOVERAGE_TEST_MARKER();
   5195                          }
   5196                      }
   5197                  }
   5198                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??vTaskGenericNotifyGiveFromISR_0: (+1)
   \       0x84   0x4638             MOV      R0,R7
   \       0x86   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x8A   0x.... 0x....      B.W      vClearInterruptMask
   5199              }
   5200          
   5201          #endif /* configUSE_TASK_NOTIFICATIONS */
   5202          /*-----------------------------------------------------------*/
   5203          
   5204          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   5205          

   \                                 In section .text, align 2, keep-with-next
   5206              BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
   5207                                                       UBaseType_t uxIndexToClear )
   5208              {
   \                     xTaskGenericNotifyStateClear: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   5209                  TCB_t * pxTCB;
   5210                  BaseType_t xReturn;
   5211          
   5212                  configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
   \        0x6   0xD003             BEQ.N    ??CrossCallReturnLabel_9
   \        0x8   0xF241 0x415C      MOVW     R1,#+5212
   \        0xC   0x.... 0x....      BL       ?Subroutine5
   5213          
   5214                  /* If null is passed in here then it is the calling task that is having
   5215                   * its notification state cleared. */
   5216                  pxTCB = prvGetTCBFromHandle( xTask );
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x10   0xB90D             CBNZ.N   R5,??xTaskGenericNotifyStateClear_0
   \       0x12   0x....             LDR.N    R0,??DataTable56_1
   \       0x14   0x6A85             LDR      R5,[R0, #+40]
   5217          
   5218                  taskENTER_CRITICAL();
   \                     ??xTaskGenericNotifyStateClear_0: (+1)
   \       0x16   0x.... 0x....      BL       vPortEnterCritical
   5219                  {
   5220                      if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
   \       0x1A   0x1928             ADDS     R0,R5,R4
   \       0x1C   0xF890 0x205C      LDRB     R2,[R0, #+92]
   \       0x20   0x2A02             CMP      R2,#+2
   \       0x22   0xBF03             ITTTE    EQ
   \       0x24   0x2100             MOVEQ    R1,#+0
   \       0x26   0xF880 0x105C      STRBEQ   R1,[R0, #+92]
   \       0x2A   0x2401             MOVEQ    R4,#+1
   \       0x2C   0x2400             MOVNE    R4,#+0
   5221                      {
   5222                          pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
   5223                          xReturn = pdPASS;
   5224                      }
   5225                      else
   5226                      {
   5227                          xReturn = pdFAIL;
   5228                      }
   5229                  }
   5230                  taskEXIT_CRITICAL();
   \       0x2E   0x.... 0x....      BL       vPortExitCritical
   5231          
   5232                  return xReturn;
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
   5233              }
   5234          
   5235          #endif /* configUSE_TASK_NOTIFICATIONS */
   5236          /*-----------------------------------------------------------*/
   5237          
   5238          #if ( configUSE_TASK_NOTIFICATIONS == 1 )
   5239          

   \                                 In section .text, align 2, keep-with-next
   5240              uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
   5241                                                      UBaseType_t uxIndexToClear,
   5242                                                      uint32_t ulBitsToClear )
   5243              {
   \                     ulTaskGenericNotifyValueClear: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine9
   5244                  TCB_t * pxTCB;
   5245                  uint32_t ulReturn;
   5246          
   5247                  /* If null is passed in here then it is the calling task that is having
   5248                   * its notification state cleared. */
   5249                  pxTCB = prvGetTCBFromHandle( xTask );
   \                     ??CrossCallReturnLabel_49: (+1)
   \        0x6   0xBF04             ITT      EQ
   \        0x8   0x....             LDREQ.N  R0,??DataTable56_1
   \        0xA   0x6A84             LDREQ    R4,[R0, #+40]
   5250          
   5251                  taskENTER_CRITICAL();
   \        0xC   0x.... 0x....      BL       vPortEnterCritical
   5252                  {
   5253                      /* Return the notification as it was before the bits were cleared,
   5254                       * then clear the bit mask. */
   5255                      ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
   \       0x10   0xEB04 0x0186      ADD      R1,R4,R6, LSL #+2
   \       0x14   0x6D8C             LDR      R4,[R1, #+88]
   5256                      pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
   \       0x16   0x6D88             LDR      R0,[R1, #+88]
   \       0x18   0xEA20 0x0505      BIC      R5,R0,R5
   \       0x1C   0x658D             STR      R5,[R1, #+88]
   5257                  }
   5258                  taskEXIT_CRITICAL();
   \       0x1E   0x.... 0x....      BL       vPortExitCritical
   5259          
   5260                  return ulReturn;
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0xBD70             POP      {R4-R6,PC}
   5261              }
   5262          
   5263          #endif /* configUSE_TASK_NOTIFICATIONS */
   5264          /*-----------------------------------------------------------*/
   5265          
   5266          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
   5267          
   5268              uint32_t ulTaskGetIdleRunTimeCounter( void )
   5269              {
   5270                  return xIdleTaskHandle->ulRunTimeCounter;
   5271              }
   5272          
   5273          #endif
   5274          /*-----------------------------------------------------------*/
   5275          

   \                                 In section .text, align 2, keep-with-next
   5276          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
   5277                                                      const BaseType_t xCanBlockIndefinitely )
   5278          {
   \                     prvAddCurrentTaskToDelayedList: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   5279              TickType_t xTimeToWake;
   5280              const TickType_t xConstTickCount = xTickCount;
   \        0x2   0x....             LDR.N    R6,??DataTable56_1
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x6D37             LDR      R7,[R6, #+80]
   5281          
   5282              #if ( INCLUDE_xTaskAbortDelay == 1 )
   5283                  {
   5284                      /* About to enter a delayed list, so ensure the ucDelayAborted flag is
   5285                       * reset to pdFALSE so it can be detected as having been set to pdTRUE
   5286                       * when the task leaves the Blocked state. */
   5287                      pxCurrentTCB->ucDelayAborted = pdFALSE;
   5288                  }
   5289              #endif
   5290          
   5291              /* Remove the task from the ready list before adding it to the blocked list
   5292               * as the same list item is used for both lists. */
   5293              if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \        0x8   0x6AB1             LDR      R1,[R6, #+40]
   \        0xA   0x4605             MOV      R5,R0
   \        0xC   0x1D08             ADDS     R0,R1,#+4
   \        0xE   0x.... 0x....      BL       uxListRemove
   5294              {
   5295                  /* The current task must be in a ready list, so there is no need to
   5296                   * check, and the port reset macro can be called directly. */
   5297                  portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   5298              }
   5299              else
   5300              {
   5301                  mtCOVERAGE_TEST_MARKER();
   5302              }
   5303          
   5304              #if ( INCLUDE_vTaskSuspend == 1 )
   5305                  {
   5306                      if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   \       0x12   0xF115 0x0F01      CMN      R5,#+1
   \       0x16   0xD105             BNE.N    ??prvAddCurrentTaskToDelayedList_0
   \       0x18   0xB124             CBZ.N    R4,??prvAddCurrentTaskToDelayedList_0
   5307                      {
   5308                          /* Add the task to the suspended task list instead of a delayed task
   5309                           * list to ensure it is not woken by a timing event.  It will block
   5310                           * indefinitely. */
   5311                          vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   \       0x1A   0x6AB0             LDR      R0,[R6, #+40]
   \       0x1C   0x1D01             ADDS     R1,R0,#+4
   \       0x1E   0xF106 0x0038      ADD      R0,R6,#+56
   \       0x22   0x....             B.N      ?Subroutine2
   5312                      }
   5313                      else
   5314                      {
   5315                          /* Calculate the time at which the task should be woken if the event
   5316                           * does not occur.  This may overflow but this doesn't matter, the
   5317                           * kernel will manage it correctly. */
   5318                          xTimeToWake = xConstTickCount + xTicksToWait;
   5319          
   5320                          /* The list item will be inserted in wake time order. */
   5321                          listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   \                     ??prvAddCurrentTaskToDelayedList_0: (+1)
   \       0x24   0x6AB0             LDR      R0,[R6, #+40]
   \       0x26   0x19ED             ADDS     R5,R5,R7
   5322          
   5323                          if( xTimeToWake < xConstTickCount )
   \       0x28   0x42BD             CMP      R5,R7
   \       0x2A   0x6045             STR      R5,[R0, #+4]
   \       0x2C   0x6AB0             LDR      R0,[R6, #+40]
   \       0x2E   0xD205             BCS.N    ??prvAddCurrentTaskToDelayedList_1
   5324                          {
   5325                              /* Wake time has overflowed.  Place this item in the overflow
   5326                               * list. */
   5327                              vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   \       0x30   0x1D01             ADDS     R1,R0,#+4
   \       0x32   0x6B30             LDR      R0,[R6, #+48]
   \       0x34   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x38   0x.... 0x....      B.W      vListInsert
   5328                          }
   5329                          else
   5330                          {
   5331                              /* The wake time has not overflowed, so the current block list
   5332                               * is used. */
   5333                              vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   \                     ??prvAddCurrentTaskToDelayedList_1: (+1)
   \       0x3C   0x1D01             ADDS     R1,R0,#+4
   \       0x3E   0x6AF0             LDR      R0,[R6, #+44]
   \       0x40   0x.... 0x....      BL       vListInsert
   5334          
   5335                              /* If the task entering the blocked state was placed at the
   5336                               * head of the list of blocked tasks then xNextTaskUnblockTime
   5337                               * needs to be updated too. */
   5338                              if( xTimeToWake < xNextTaskUnblockTime )
   \       0x44   0x6EF0             LDR      R0,[R6, #+108]
   \       0x46   0x4285             CMP      R5,R0
   \       0x48   0xBF38             IT       CC
   \       0x4A   0x66F5             STRCC    R5,[R6, #+108]
   5339                              {
   5340                                  xNextTaskUnblockTime = xTimeToWake;
   5341                              }
   5342                              else
   5343                              {
   5344                                  mtCOVERAGE_TEST_MARKER();
   5345                              }
   5346                          }
   5347                      }
   5348                  }
   5349              #else /* INCLUDE_vTaskSuspend */
   5350                  {
   5351                      /* Calculate the time at which the task should be woken if the event
   5352                       * does not occur.  This may overflow but this doesn't matter, the kernel
   5353                       * will manage it correctly. */
   5354                      xTimeToWake = xConstTickCount + xTicksToWait;
   5355          
   5356                      /* The list item will be inserted in wake time order. */
   5357                      listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   5358          
   5359                      if( xTimeToWake < xConstTickCount )
   5360                      {
   5361                          /* Wake time has overflowed.  Place this item in the overflow list. */
   5362                          vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5363                      }
   5364                      else
   5365                      {
   5366                          /* The wake time has not overflowed, so the current block list is used. */
   5367                          vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5368          
   5369                          /* If the task entering the blocked state was placed at the head of the
   5370                           * list of blocked tasks then xNextTaskUnblockTime needs to be updated
   5371                           * too. */
   5372                          if( xTimeToWake < xNextTaskUnblockTime )
   5373                          {
   5374                              xNextTaskUnblockTime = xTimeToWake;
   5375                          }
   5376                          else
   5377                          {
   5378                              mtCOVERAGE_TEST_MARKER();
   5379                          }
   5380                      }
   5381          
   5382                      /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
   5383                      ( void ) xCanBlockIndefinitely;
   5384                  }
   5385              #endif /* INCLUDE_vTaskSuspend */
   5386          }
   \       0x4C   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x75 0x74          DC8 0x75, 0x74, 0x69, 0x6C, 0x5C, 0x74, 0x68, 0x69
   \              0x69 0x6C    
   \              0x5C 0x74    
   \              0x68 0x69
   \       0x50   0x72 0x64          DC8 0x72, 0x64, 0x5F, 0x70, 0x61, 0x72, 0x74, 0x79
   \              0x5F 0x70    
   \              0x61 0x72    
   \              0x74 0x79
   \       0x58   0x5C 0x66          DC8 0x5C, 0x66, 0x72, 0x65, 0x65, 0x72, 0x74, 0x6F
   \              0x72 0x65    
   \              0x65 0x72    
   \              0x74 0x6F
   \       0x60   0x73 0x5C          DC8 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C
   \              0x6B 0x65    
   \              0x72 0x6E    
   \              0x65 0x6C
   \       0x68   0x5C 0x74          DC8 0x5C, 0x74, 0x61, 0x73, 0x6B, 0x73, 0x2E, 0x63
   \              0x61 0x73    
   \              0x6B 0x73    
   \              0x2E 0x63
   \       0x70   0x00               DC8 0
   \       0x71                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x49 0x44          DC8 "IDLE"
   \              0x4C 0x45    
   \              0x00
   \        0x5                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x....'....        DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \        0x0   0x....'....        DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \        0x0   0x....'....        DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \        0x0   0x....'....        DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_2:
   \        0x0   0x....'....        DC32     ?_0
   5387          
   5388          /* Code below here allows additional code to be inserted into this source file,
   5389           * especially where access to file scope functions and data is needed (for example
   5390           * when performing module tests). */
   5391          
   5392          #ifdef FREERTOS_MODULE_TEST
   5393              #include "tasks_test_access_functions.h"
   5394          #endif
   5395          
   5396          
   5397          #if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
   5398          
   5399              #include "freertos_tasks_c_additions.h"
   5400          
   5401              #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   5402                  static void freertos_tasks_c_additions_init( void )
   5403                  {
   5404                      FREERTOS_TASKS_C_ADDITIONS_INIT();
   5405                  }
   5406              #endif
   5407          
   5408          #endif /* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   eTaskGetState
        24   -> assertEFM
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       8   pcTaskGetName
         8   -> assertEFM
      24   prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
         0   -> vListInsert
        24   -> vListInsert
         0   -> vListInsertEnd
      24   prvAddNewTaskToReadyList
        24   -> vListInitialise
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
         0   -> vPortYield
       8   prvDeleteTCB
         0   -> assertEFM
         0   -> vPortFree
         8   -> vPortFree
      16   prvIdleTask
        16   -> prvDeleteTCB
        16   -> uxListRemove
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
      32   prvInitialiseNewTask
        32   -> __aeabi_memclr
        32   -> __aeabi_memset4
        32   -> pxPortInitialiseStack
        32   -> vListInitialiseItem
      32   prvListTasksWithinSingleList
        32   -> vTaskGetInfo
       0   prvResetNextTaskUnblockTime
       0   prvTaskCheckFreeStackSpace
      16   prvTaskIsTaskSuspended
        16   -> assertEFM
       0   pvTaskGetThreadLocalStoragePointer
       0   pvTaskIncrementMutexHeldCount
      24   ulTaskGenericNotifyTake
        24   -> assertEFM
        24   -> prvAddCurrentTaskToDelayedList
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYield
      16   ulTaskGenericNotifyValueClear
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   uxTaskGetNumberOfTasks
       0   uxTaskGetStackHighWaterMark
         0   -> prvTaskCheckFreeStackSpace
      32   uxTaskGetSystemState
        32   -> prvListTasksWithinSingleList
        32   -> vTaskSuspendAll
        32   -> xTaskResumeAll
       0   uxTaskGetTaskNumber
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   uxTaskPriorityGetFromISR
         8   -> ulSetInterruptMask
         8   -> vClearInterruptMask
       0   uxTaskResetEventItemValue
       8   vTaskDelay
         8   -> assertEFM
         8   -> prvAddCurrentTaskToDelayedList
         0   -> vPortYield
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
      16   vTaskDelete
        16   -> assertEFM
        16   -> prvDeleteTCB
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
         0   -> vPortYield
       8   vTaskEndScheduler
         8   -> ulSetInterruptMask
         0   -> vPortEndScheduler
      24   vTaskGenericNotifyGiveFromISR
        24   -> assertEFM
        24   -> ulSetInterruptMask
        24   -> uxListRemove
         0   -> vClearInterruptMask
        24   -> vListInsertEnd
      24   vTaskGetInfo
        24   -> eTaskGetState
        24   -> prvTaskCheckFreeStackSpace
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
       0   vTaskInternalSetTimeOutState
       0   vTaskMissedYield
      16   vTaskPlaceOnEventList
        16   -> assertEFM
         0   -> prvAddCurrentTaskToDelayedList
        16   -> vListInsert
      16   vTaskPlaceOnEventListRestricted
        16   -> assertEFM
         0   -> prvAddCurrentTaskToDelayedList
        16   -> vListInsertEnd
      24   vTaskPlaceOnUnorderedEventList
        24   -> assertEFM
         0   -> prvAddCurrentTaskToDelayedList
        24   -> vListInsertEnd
      24   vTaskPriorityDisinheritAfterTimeout
        24   -> assertEFM
        24   -> uxListRemove
         0   -> vListInsertEnd
      24   vTaskPrioritySet
        24   -> assertEFM
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
         0   -> vPortExitCritical
        24   -> vPortYield
      24   vTaskRemoveFromUnorderedEventList
        24   -> assertEFM
        24   -> uxListRemove
        24   -> vListInsertEnd
      16   vTaskResume
        16   -> assertEFM
        16   -> prvTaskIsTaskSuspended
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
        16   -> vPortYield
       0   vTaskSetTaskNumber
      16   vTaskSetThreadLocalStoragePointer
        16   -> assertEFM
       8   vTaskSetTimeOutState
         8   -> assertEFM
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
      32   vTaskStartScheduler
        32   -> assertEFM
        32   -> ulSetInterruptMask
        32   -> vApplicationGetIdleTaskMemory
        32   -> xPortStartScheduler
        32   -> xTaskCreateStatic
        32   -> xTimerCreateTimerTask
      16   vTaskSuspend
        16   -> assertEFM
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
         0   -> vPortYield
         0   -> vTaskSwitchContext
       0   vTaskSuspendAll
      24   vTaskSwitchContext
        24   -> assertEFM
        24   -> vApplicationStackOverflowHook
      16   xTaskCatchUpTicks
        16   -> assertEFM
        16   -> vTaskSuspendAll
         0   -> xTaskResumeAll
      24   xTaskCheckForTimeOut
        24   -> assertEFM
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      48   xTaskCreate
        48   -> prvAddNewTaskToReadyList
        48   -> prvInitialiseNewTask
        48   -> pvPortMalloc
        48   -> vPortFree
      56   xTaskCreateStatic
        56   -> assertEFM
        56   -> prvAddNewTaskToReadyList
        56   -> prvInitialiseNewTask
      24   xTaskDelayUntil
        24   -> assertEFM
        24   -> prvAddCurrentTaskToDelayedList
        24   -> vPortYield
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
      32   xTaskGenericNotify
        32   -> assertEFM
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
      40   xTaskGenericNotifyFromISR
        40   -> assertEFM
        40   -> ulSetInterruptMask
        40   -> uxListRemove
        40   -> vClearInterruptMask
        40   -> vListInsertEnd
      16   xTaskGenericNotifyStateClear
        16   -> assertEFM
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
      24   xTaskGenericNotifyWait
        24   -> assertEFM
        24   -> prvAddCurrentTaskToDelayedList
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYield
       0   xTaskGetCurrentTaskHandle
       0   xTaskGetSchedulerState
       0   xTaskGetTickCount
       0   xTaskGetTickCountFromISR
      32   xTaskIncrementTick
        32   -> assertEFM
        32   -> prvResetNextTaskUnblockTime
        32   -> uxListRemove
        32   -> vListInsertEnd
      24   xTaskPriorityDisinherit
        24   -> assertEFM
        24   -> uxListRemove
        24   -> vListInsertEnd
      24   xTaskPriorityInherit
        24   -> uxListRemove
        24   -> vListInsertEnd
      16   xTaskRemoveFromEventList
        16   -> assertEFM
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskResumeAll
        16   -> assertEFM
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
        16   -> xTaskIncrementTick
      24   xTaskResumeFromISR
        24   -> assertEFM
        24   -> prvTaskIsTaskSuspended
        24   -> ulSetInterruptMask
        24   -> uxListRemove
        24   -> vClearInterruptMask
        24   -> vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable37
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable56_2
       8  ?Subroutine0
       8  ?Subroutine1
       6  ?Subroutine10
       6  ?Subroutine11
      16  ?Subroutine12
      10  ?Subroutine13
       6  ?Subroutine14
       8  ?Subroutine15
      14  ?Subroutine16
      12  ?Subroutine17
       8  ?Subroutine18
      14  ?Subroutine19
       8  ?Subroutine2
      12  ?Subroutine20
      12  ?Subroutine21
       6  ?Subroutine3
      14  ?Subroutine4
       8  ?Subroutine5
       6  ?Subroutine6
       6  ?Subroutine7
       6  ?Subroutine8
       8  ?Subroutine9
     116  ?_0
       8  ?_1
     110  eTaskGetState
      30  pcTaskGetName
      78  prvAddCurrentTaskToDelayedList
     176  prvAddNewTaskToReadyList
      54  prvDeleteTCB
      64  prvIdleTask
     160  prvInitialiseNewTask
      74  prvListTasksWithinSingleList
      26  prvResetNextTaskUnblockTime
      22  prvTaskCheckFreeStackSpace
      44  prvTaskIsTaskSuspended
      24  pvTaskGetThreadLocalStoragePointer
      20  pvTaskIncrementMutexHeldCount
   1'120  pxReadyTasksLists
     110  ulTaskGenericNotifyTake
      38  ulTaskGenericNotifyValueClear
       8  uxTaskGetNumberOfTasks
      12  uxTaskGetStackHighWaterMark
     140  uxTaskGetSystemState
       6  uxTaskGetTaskNumber
      24  uxTaskPriorityGet
      26  uxTaskPriorityGetFromISR
      22  uxTaskResetEventItemValue
      50  vTaskDelay
      94  vTaskDelete
      22  vTaskEndScheduler
     142  vTaskGenericNotifyGiveFromISR
     102  vTaskGetInfo
      14  vTaskInternalSetTimeOutState
      10  vTaskMissedYield
      36  vTaskPlaceOnEventList
      42  vTaskPlaceOnEventListRestricted
      70  vTaskPlaceOnUnorderedEventList
     122  vTaskPriorityDisinheritAfterTimeout
     150  vTaskPrioritySet
      76  vTaskRemoveFromUnorderedEventList
      80  vTaskResume
       6  vTaskSetTaskNumber
      42  vTaskSetThreadLocalStoragePointer
      38  vTaskSetTimeOutState
     104  vTaskStartScheduler
     118  vTaskSuspend
      12  vTaskSuspendAll
     134  vTaskSwitchContext
       4  xIdleTaskHandle
     160  xPendingReadyList
          xTasksWaitingTermination
          pxCurrentTCB
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          uxDeletedTasksWaitingCleanUp
          xSuspendedTaskList
          uxCurrentNumberOfTasks
          xTickCount
          uxTopReadyPriority
          xSchedulerRunning
          xPendedTicks
          xYieldPending
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          uxTopUsedPriority
          uxSchedulerSuspended
          xDelayedTaskList1
          xDelayedTaskList2
      36  xTaskCatchUpTicks
     112  xTaskCheckForTimeOut
      92  xTaskCreate
     124  xTaskCreateStatic
     110  xTaskDelayUntil
     190  xTaskGenericNotify
     198  xTaskGenericNotifyFromISR
      54  xTaskGenericNotifyStateClear
     154  xTaskGenericNotifyWait
       8  xTaskGetCurrentTaskHandle
      24  xTaskGetSchedulerState
       2  xTaskGetTickCount
       2  xTaskGetTickCountFromISR
     192  xTaskIncrementTick
      90  xTaskPriorityDisinherit
     106  xTaskPriorityInherit
      78  xTaskRemoveFromEventList
     148  xTaskResumeAll
      94  xTaskResumeFromISR

 
 1'124 bytes in section .bss
   160 bytes in section .data
   116 bytes in section .rodata
 4'780 bytes in section .text
 
 4'780 bytes of CODE  memory
   116 bytes of CONST memory
 1'284 bytes of DATA  memory

Errors: none
Warnings: none
