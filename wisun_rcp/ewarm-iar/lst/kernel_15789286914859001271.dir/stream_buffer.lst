###############################################################################
#
# IAR ANSI C/C++ Compiler V9.50.2.385/W64 for ARM         27/Nov/2024  12:17:20
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\stream_buffer.c
#    Command line      =
#        -f
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\stream_buffer.o.rsp
#        (C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\stream_buffer.c
#        -D EFR32FG28B322F1024IM48=1 -D
#        configNUM_SDK_THREAD_LOCAL_STORAGE_POINTERS=2 -D
#        SL_COMPONENT_CATALOG_PRESENT=1 -D
#        MBEDTLS_CONFIG_FILE=<sl_mbedtls_config.h> -D
#        MBEDTLS_PSA_CRYPTO_CONFIG_FILE=<psa_crypto_config.h> -D
#        SL_RAIL_LIB_MULTIPROTOCOL_SUPPORT=0 -D
#        SL_RAIL_UTIL_PA_CONFIG_HEADER=<sl_rail_util_pa_config.h> -D
#        RTT_USE_ASM=0 -D MBED_CONF_MBED_TRACE_ENABLE=1 -D
#        MBED_CONF_NANOSTACK_CONFIGURATION=ws_router -D
#        MBED_TRACE_MAX_LEVEL=TRACE_ACTIVE_LEVEL_ALL -D DEBUG_EFM_USER=1 -D
#        HAVE_LFN=1 -D HAVE_LFN_PARENT=1 -lC
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\kernel_15789286914859001271.dir
#        --diag_suppress Pa050 -o
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir
#        --debug --endian=little --cpu=Cortex-M33 --cmse --cmse -e
#        --fpu=VFPv5_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\
#        -I C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\autogen\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\ -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\config\rail\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\Device\SiliconLabs\EFR32FG28\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\Core\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\CMSIS\RTOS2\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\device_init\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\dmadrv\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\common\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emlib\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\cmsis\Include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\portable\IAR\ARM_CM33_NTZ\non_secure\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\iostream\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\config\preset\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_mbedtls_support\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\include\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\mbedtls\library\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\emdrv\nvm3\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\peripheral\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\sl_psa_driver\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\common\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\wmbus\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\protocol\sidewalk\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\pa-conversions\efr32xg28\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\radio\rail_lib\plugin\rail_util_pti\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\security\sl_component\se_manager\src\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\segger\systemview\SEGGER\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\silicon_labs\silabs_core\memory_manager\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\common\toolchain\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\system\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\ns_list\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\app\wisun\component\trace_util\nanostack\nanostack-libservice\mbed-client-libservice\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\platform\service\sleeptimer\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\app\wisun_rcp\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\inc\socket\
#        -I
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\protocol\wisun\stack\src\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\stream_buffer.o.iar_deps
#    Locale            =  C
#    List file         =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\lst\kernel_15789286914859001271.dir\stream_buffer.lst
#    Object file       =
#        C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\ewarm-iar\obj\kernel_15789286914859001271.dir\stream_buffer.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\DELL\SimplicityStudio\v5_workspace\wisun_rcp_7\gecko_sdk_4.4.3\util\third_party\freertos\kernel\stream_buffer.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          
     14          /*
     15           * FreeRTOS Kernel V10.4.3
     16           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
     17           *
     18           * Permission is hereby granted, free of charge, to any person obtaining a copy of
     19           * this software and associated documentation files (the "Software"), to deal in
     20           * the Software without restriction, including without limitation the rights to
     21           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     22           * the Software, and to permit persons to whom the Software is furnished to do so,
     23           * subject to the following conditions:
     24           *
     25           * The above copyright notice and this permission notice shall be included in all
     26           * copies or substantial portions of the Software.
     27           *
     28           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     29           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     30           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     31           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     32           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     33           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     34           *
     35           * https://www.FreeRTOS.org
     36           * https://github.com/FreeRTOS
     37           *
     38           */
     39          
     40          /* Standard includes. */
     41          #include <stdint.h>
     42          #include <string.h>
     43          
     44          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     45           * all the API functions to use the MPU wrappers.  That should only be done when
     46           * task.h is included from an application file. */
     47          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     48          
     49          /* FreeRTOS includes. */
     50          #include "FreeRTOS.h"
     51          #include "task.h"
     52          #include "stream_buffer.h"
     53          
     54          #if ( configUSE_TASK_NOTIFICATIONS != 1 )
     55              #error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
     56          #endif
     57          
     58          /* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified
     59           * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     60           * for the header files above, but not in this file, in order to generate the
     61           * correct privileged Vs unprivileged linkage and placement. */
     62          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     63          
     64          /* If the user has not provided application specific Rx notification macros,
     65           * or #defined the notification macros away, them provide default implementations
     66           * that uses task notifications. */
     67          /*lint -save -e9026 Function like macros allowed and needed here so they can be overridden. */
     68          #ifndef sbRECEIVE_COMPLETED
     69              #define sbRECEIVE_COMPLETED( pxStreamBuffer )                         \
     70              vTaskSuspendAll();                                                    \
     71              {                                                                     \
     72                  if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )              \
     73                  {                                                                 \
     74                      ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend, \
     75                                            ( uint32_t ) 0,                         \
     76                                            eNoAction );                            \
     77                      ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                \
     78                  }                                                                 \
     79              }                                                                     \
     80              ( void ) xTaskResumeAll();
     81          #endif /* sbRECEIVE_COMPLETED */
     82          
     83          #ifndef sbRECEIVE_COMPLETED_FROM_ISR
     84              #define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,                            \
     85                                                    pxHigherPriorityTaskWoken )                \
     86              {                                                                                \
     87                  UBaseType_t uxSavedInterruptStatus;                                          \
     88                                                                                               \
     89                  uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();  \
     90                  {                                                                            \
     91                      if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )                     \
     92                      {                                                                        \
     93                          ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend, \
     94                                                       ( uint32_t ) 0,                         \
     95                                                       eNoAction,                              \
     96                                                       pxHigherPriorityTaskWoken );            \
     97                          ( pxStreamBuffer )->xTaskWaitingToSend = NULL;                       \
     98                      }                                                                        \
     99                  }                                                                            \
    100                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                 \
    101              }
    102          #endif /* sbRECEIVE_COMPLETED_FROM_ISR */
    103          
    104          /* If the user has not provided an application specific Tx notification macro,
    105           * or #defined the notification macro away, them provide a default implementation
    106           * that uses task notifications. */
    107          #ifndef sbSEND_COMPLETED
    108              #define sbSEND_COMPLETED( pxStreamBuffer )                               \
    109              vTaskSuspendAll();                                                       \
    110              {                                                                        \
    111                  if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )              \
    112                  {                                                                    \
    113                      ( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive, \
    114                                            ( uint32_t ) 0,                            \
    115                                            eNoAction );                               \
    116                      ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                \
    117                  }                                                                    \
    118              }                                                                        \
    119              ( void ) xTaskResumeAll();
    120          #endif /* sbSEND_COMPLETED */
    121          
    122          #ifndef sbSEND_COMPLETE_FROM_ISR
    123              #define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )       \
    124              {                                                                                   \
    125                  UBaseType_t uxSavedInterruptStatus;                                             \
    126                                                                                                  \
    127                  uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();     \
    128                  {                                                                               \
    129                      if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \
    130                      {                                                                           \
    131                          ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive, \
    132                                                       ( uint32_t ) 0,                            \
    133                                                       eNoAction,                                 \
    134                                                       pxHigherPriorityTaskWoken );               \
    135                          ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \
    136                      }                                                                           \
    137                  }                                                                               \
    138                  portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );                    \
    139              }
    140          #endif /* sbSEND_COMPLETE_FROM_ISR */
    141          /*lint -restore (9026) */
    142          
    143          /* The number of bytes used to hold the length of a message in the buffer. */
    144          #define sbBYTES_TO_STORE_MESSAGE_LENGTH    ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )
    145          
    146          /* Bits stored in the ucFlags field of the stream buffer. */
    147          #define sbFLAGS_IS_MESSAGE_BUFFER          ( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
    148          #define sbFLAGS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */
    149          
    150          /*-----------------------------------------------------------*/
    151          
    152          /* Structure that hold state information on the buffer. */
    153          typedef struct StreamBufferDef_t                 /*lint !e9058 Style convention uses tag. */
    154          {
    155              volatile size_t xTail;                       /* Index to the next item to read within the buffer. */
    156              volatile size_t xHead;                       /* Index to the next item to write within the buffer. */
    157              size_t xLength;                              /* The length of the buffer pointed to by pucBuffer. */
    158              size_t xTriggerLevelBytes;                   /* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
    159              volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
    160              volatile TaskHandle_t xTaskWaitingToSend;    /* Holds the handle of a task waiting to send data to a message buffer that is full. */
    161              uint8_t * pucBuffer;                         /* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
    162              uint8_t ucFlags;
    163          
    164              #if ( configUSE_TRACE_FACILITY == 1 )
    165                  UBaseType_t uxStreamBufferNumber; /* Used for tracing purposes. */
    166              #endif
    167          } StreamBuffer_t;
    168          
    169          /*
    170           * The number of bytes available to be read from the buffer.
    171           */
    172          static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
    173          
    174          /*
    175           * Add xCount bytes from pucData into the pxStreamBuffer message buffer.
    176           * Returns the number of bytes written, which will either equal xCount in the
    177           * success case, or 0 if there was not enough space in the buffer (in which case
    178           * no data is written into the buffer).
    179           */
    180          static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
    181                                               const uint8_t * pucData,
    182                                               size_t xCount ) PRIVILEGED_FUNCTION;
    183          
    184          /*
    185           * If the stream buffer is being used as a message buffer, then reads an entire
    186           * message out of the buffer.  If the stream buffer is being used as a stream
    187           * buffer then read as many bytes as possible from the buffer.
    188           * prvReadBytesFromBuffer() is called to actually extract the bytes from the
    189           * buffer's data storage area.
    190           */
    191          static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
    192                                                  void * pvRxData,
    193                                                  size_t xBufferLengthBytes,
    194                                                  size_t xBytesAvailable,
    195                                                  size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
    196          
    197          /*
    198           * If the stream buffer is being used as a message buffer, then writes an entire
    199           * message to the buffer.  If the stream buffer is being used as a stream
    200           * buffer then write as many bytes as possible to the buffer.
    201           * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's
    202           * data storage area.
    203           */
    204          static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
    205                                                 const void * pvTxData,
    206                                                 size_t xDataLengthBytes,
    207                                                 size_t xSpace,
    208                                                 size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
    209          
    210          /*
    211           * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them
    212           * to pucData.
    213           */
    214          static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
    215                                                uint8_t * pucData,
    216                                                size_t xMaxCount,
    217                                                size_t xBytesAvailable ) PRIVILEGED_FUNCTION;
    218          
    219          /*
    220           * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to
    221           * initialise the members of the newly created stream buffer structure.
    222           */
    223          static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
    224                                                    uint8_t * const pucBuffer,
    225                                                    size_t xBufferSizeBytes,
    226                                                    size_t xTriggerLevelBytes,
    227                                                    uint8_t ucFlags ) PRIVILEGED_FUNCTION;
    228          
    229          /*-----------------------------------------------------------*/
    230          
    231          #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    232          

   \                                 In section .text, align 2, keep-with-next
    233              StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
    234                                                               size_t xTriggerLevelBytes,
    235                                                               BaseType_t xIsMessageBuffer )
    236              {
   \                     xStreamBufferGenericCreate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    237                  uint8_t * pucAllocatedMemory;
    238                  uint8_t ucFlags;
    239          
    240                  /* In case the stream buffer is going to be used as a message buffer
    241                   * (that is, it will hold discrete messages with a little meta data that
    242                   * says how big the next message is) check the buffer will be large enough
    243                   * to hold at least one message. */
    244                  if( xIsMessageBuffer == pdTRUE )
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable9
   \        0xA   0x2A01             CMP      R2,#+1
   \        0xC   0xD104             BNE.N    ??xStreamBufferGenericCreate_0
    245                  {
    246                      /* Is a message buffer but not statically allocated. */
    247                      ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
   \        0xE   0x2701             MOVS     R7,#+1
    248                      configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
   \       0x10   0x2C05             CMP      R4,#+5
   \       0x12   0xD207             BCS.N    ??xStreamBufferGenericCreate_1
   \       0x14   0x21F8             MOVS     R1,#+248
   \       0x16   0xE002             B.N      ??xStreamBufferGenericCreate_2
    249                  }
    250                  else
    251                  {
    252                      /* Not a message buffer and not statically allocated. */
    253                      ucFlags = 0;
   \                     ??xStreamBufferGenericCreate_0: (+1)
   \       0x18   0x2700             MOVS     R7,#+0
    254                      configASSERT( xBufferSizeBytes > 0 );
   \       0x1A   0xB91C             CBNZ.N   R4,??xStreamBufferGenericCreate_1
   \       0x1C   0x21FE             MOVS     R1,#+254
   \                     ??xStreamBufferGenericCreate_2: (+1)
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       assertEFM
    255                  }
    256          
    257                  configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
   \                     ??xStreamBufferGenericCreate_1: (+1)
   \       0x24   0x42AC             CMP      R4,R5
   \       0x26   0xD204             BCS.N    ??xStreamBufferGenericCreate_3
   \       0x28   0xF240 0x1101      MOVW     R1,#+257
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0x.... 0x....      BL       assertEFM
    258          
    259                  /* A trigger level of 0 would cause a waiting task to unblock even when
    260                   * the buffer was empty. */
    261                  if( xTriggerLevelBytes == ( size_t ) 0 )
   \                     ??xStreamBufferGenericCreate_3: (+1)
   \       0x32   0xB905             CBNZ.N   R5,??xStreamBufferGenericCreate_4
    262                  {
    263                      xTriggerLevelBytes = ( size_t ) 1;
   \       0x34   0x2501             MOVS     R5,#+1
    264                  }
    265          
    266                  /* A stream buffer requires a StreamBuffer_t structure and a buffer.
    267                   * Both are allocated in a single call to pvPortMalloc().  The
    268                   * StreamBuffer_t structure is placed at the start of the allocated memory
    269                   * and the buffer follows immediately after.  The requested size is
    270                   * incremented so the free space is returned as the user would expect -
    271                   * this is a quirk of the implementation that means otherwise the free
    272                   * space would be reported as one byte smaller than would be logically
    273                   * expected. */
    274                  if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
   \                     ??xStreamBufferGenericCreate_4: (+1)
   \       0x36   0xF104 0x0025      ADD      R0,R4,#+37
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xD20D             BCS.N    ??xStreamBufferGenericCreate_5
    275                  {
    276                      xBufferSizeBytes++;
   \       0x3E   0x1C64             ADDS     R4,R4,#+1
    277                      pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
   \       0x40   0x.... 0x....      BL       pvPortMalloc
   \       0x44   0x0006             MOVS     R6,R0
    278                  }
    279                  else
    280                  {
    281                      pucAllocatedMemory = NULL;
    282                  }
    283                  
    284          
    285                  if( pucAllocatedMemory != NULL )
   \       0x46   0xD006             BEQ.N    ??xStreamBufferGenericCreate_6
    286                  {
    287                      prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    288                                                    pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
    289                                                    xBufferSizeBytes,
    290                                                    xTriggerLevelBytes,
    291                                                    ucFlags );
   \       0x48   0x9700             STR      R7,[SP, #+0]
   \       0x4A   0x462B             MOV      R3,R5
   \       0x4C   0x4622             MOV      R2,R4
   \       0x4E   0xF106 0x0124      ADD      R1,R6,#+36
   \       0x52   0x.... 0x....      BL       prvInitialiseNewStreamBuffer
    292          
    293                      traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
    294                  }
    295                  else
    296                  {
    297                      traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
    298                  }
    299          
    300                  return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
   \                     ??xStreamBufferGenericCreate_6: (+1)
   \       0x56   0x4630             MOV      R0,R6
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??xStreamBufferGenericCreate_5: (+1)
   \       0x5A   0x2600             MOVS     R6,#+0
   \       0x5C   0xE7FB             B.N      ??xStreamBufferGenericCreate_6
    301              }
    302          
    303          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    304          /*-----------------------------------------------------------*/
    305          
    306          #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    307          

   \                                 In section .text, align 2, keep-with-next
    308              StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
    309                                                                     size_t xTriggerLevelBytes,
    310                                                                     BaseType_t xIsMessageBuffer,
    311                                                                     uint8_t * const pucStreamBufferStorageArea,
    312                                                                     StaticStreamBuffer_t * const pxStaticStreamBuffer )
    313              {
   \                     xStreamBufferGenericCreateStatic: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x001C             MOVS     R4,R3
    314                  StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
    315                  StreamBufferHandle_t xReturn;
    316                  uint8_t ucFlags;
    317          
    318                  configASSERT( pucStreamBufferStorageArea );
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable9
   \       0x10   0xD103             BNE.N    ??CrossCallReturnLabel_25
   \       0x12   0xF44F 0x719F      MOV      R1,#+318
   \       0x16   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x1A   0x9D08             LDR      R5,[SP, #+32]
    319                  configASSERT( pxStaticStreamBuffer );
   \       0x1C   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_24
   \       0x1E   0xF240 0x113F      MOVW     R1,#+319
   \       0x22   0x.... 0x....      BL       ?Subroutine4
    320                  configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x26   0x45B1             CMP      R9,R6
   \       0x28   0xD203             BCS.N    ??CrossCallReturnLabel_23
   \       0x2A   0xF44F 0x71A0      MOV      R1,#+320
   \       0x2E   0x.... 0x....      BL       ?Subroutine4
    321          
    322                  /* A trigger level of 0 would cause a waiting task to unblock even when
    323                   * the buffer was empty. */
    324                  if( xTriggerLevelBytes == ( size_t ) 0 )
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x32   0xB906             CBNZ.N   R6,??xStreamBufferGenericCreateStatic_0
    325                  {
    326                      xTriggerLevelBytes = ( size_t ) 1;
   \       0x34   0x2601             MOVS     R6,#+1
    327                  }
    328          
    329                  if( xIsMessageBuffer != pdFALSE )
   \                     ??xStreamBufferGenericCreateStatic_0: (+1)
   \       0x36   0x2F00             CMP      R7,#+0
   \       0x38   0xBF14             ITE      NE
   \       0x3A   0x2703             MOVNE    R7,#+3
   \       0x3C   0x2702             MOVEQ    R7,#+2
    330                  {
    331                      /* Statically allocated message buffer. */
    332                      ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
    333                  }
    334                  else
    335                  {
    336                      /* Statically allocated stream buffer. */
    337                      ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
    338                  }
    339          
    340                  /* In case the stream buffer is going to be used as a message buffer
    341                   * (that is, it will hold discrete messages with a little meta data that
    342                   * says how big the next message is) check the buffer will be large enough
    343                   * to hold at least one message. */
    344                  configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
   \       0x3E   0xF1B9 0x0F05      CMP      R9,#+5
   \       0x42   0xD203             BCS.N    ??CrossCallReturnLabel_22
   \       0x44   0xF44F 0x71AC      MOV      R1,#+344
   \       0x48   0x.... 0x....      BL       ?Subroutine4
    345          
    346                  #if ( configASSERT_DEFINED == 1 )
    347                      {
    348                          /* Sanity check that the size of the structure used to declare a
    349                           * variable of type StaticStreamBuffer_t equals the size of the real
    350                           * message buffer structure. */
    351                          volatile size_t xSize = sizeof( StaticStreamBuffer_t );
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x4C   0x2024             MOVS     R0,#+36
   \       0x4E   0x9000             STR      R0,[SP, #+0]
    352                          configASSERT( xSize == sizeof( StreamBuffer_t ) );
   \       0x50   0x9900             LDR      R1,[SP, #+0]
   \       0x52   0x2924             CMP      R1,#+36
   \       0x54   0xD003             BEQ.N    ??CrossCallReturnLabel_21
   \       0x56   0xF44F 0x71B0      MOV      R1,#+352
   \       0x5A   0x.... 0x....      BL       ?Subroutine4
    353                      } /*lint !e529 xSize is referenced is configASSERT() is defined. */
    354                  #endif /* configASSERT_DEFINED */
    355          
    356                  if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xBF18             IT       NE
   \       0x62   0x2D00             CMPNE    R5,#+0
   \       0x64   0xD00B             BEQ.N    ??xStreamBufferGenericCreateStatic_1
    357                  {
    358                      prvInitialiseNewStreamBuffer( pxStreamBuffer,
    359                                                    pucStreamBufferStorageArea,
    360                                                    xBufferSizeBytes,
    361                                                    xTriggerLevelBytes,
    362                                                    ucFlags );
   \       0x66   0x9700             STR      R7,[SP, #+0]
   \       0x68   0x4633             MOV      R3,R6
   \       0x6A   0x464A             MOV      R2,R9
   \       0x6C   0x4621             MOV      R1,R4
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0x.... 0x....      BL       prvInitialiseNewStreamBuffer
    363          
    364                      /* Remember this was statically allocated in case it is ever deleted
    365                       * again. */
    366                      pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
   \       0x74   0x7F28             LDRB     R0,[R5, #+28]
   \       0x76   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x7A   0x7728             STRB     R0,[R5, #+28]
    367          
    368                      traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
    369          
    370                      xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */
   \       0x7C   0xE000             B.N      ??xStreamBufferGenericCreateStatic_2
    371                  }
    372                  else
    373                  {
    374                      xReturn = NULL;
   \                     ??xStreamBufferGenericCreateStatic_1: (+1)
   \       0x7E   0x2500             MOVS     R5,#+0
    375                      traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
    376                  }
    377          
    378                  return xReturn;
   \                     ??xStreamBufferGenericCreateStatic_2: (+1)
   \       0x80   0x4628             MOV      R0,R5
   \       0x82   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    379              }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x.... 0x....      B.W      assertEFM
    380          
    381          #endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    382          /*-----------------------------------------------------------*/
    383          

   \                                 In section .text, align 2, keep-with-next
    384          void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
    385          {
   \                     vStreamBufferDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    386              StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    387          
    388              configASSERT( pxStreamBuffer );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_8
   \        0x6   0xF44F 0x71C2      MOV      R1,#+388
   \        0xA   0x.... 0x....      BL       ?Subroutine2
    389          
    390              traceSTREAM_BUFFER_DELETE( xStreamBuffer );
    391          
    392              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0xE   0x7F21             LDRB     R1,[R4, #+28]
   \       0x10   0x0788             LSLS     R0,R1,#+30
   \       0x12   0xD404             BMI.N    ??vStreamBufferDelete_0
    393              {
    394                  #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    395                      {
    396                          /* Both the structure and the buffer were allocated using a single call
    397                          * to pvPortMalloc(), hence only one call to vPortFree() is required. */
    398                          vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x.... 0x....      B.W      vPortFree
    399                      }
    400                  #else
    401                      {
    402                          /* Should not be possible to get here, ucFlags must be corrupt.
    403                           * Force an assert. */
    404                          configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
    405                      }
    406                  #endif
    407              }
    408              else
    409              {
    410                  /* The structure and buffer were not allocated dynamically and cannot be
    411                   * freed - just scrub the structure so future use will assert. */
    412                  ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
   \                     ??vStreamBufferDelete_0: (+1)
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x2124             MOVS     R1,#+36
   \       0x22   0xE8BD 0x4010      POP      {R4,LR}
   \       0x26   0x.... 0x....      B.W      __aeabi_memclr4
    413              }
    414          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable9
   \        0x4   0x.... 0x....      B.W      assertEFM
    415          /*-----------------------------------------------------------*/
    416          

   \                                 In section .text, align 2, keep-with-next
    417          BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
    418          {
   \                     xStreamBufferReset: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    419              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    420              BaseType_t xReturn = pdFAIL;
   \        0x4   0x2600             MOVS     R6,#+0
    421          
    422              #if ( configUSE_TRACE_FACILITY == 1 )
    423                  UBaseType_t uxStreamBufferNumber;
    424              #endif
    425          
    426              configASSERT( pxStreamBuffer );
   \        0x6   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_7
   \        0x8   0xF44F 0x71D5      MOV      R1,#+426
   \        0xC   0x.... 0x....      BL       ?Subroutine2
    427          
    428              #if ( configUSE_TRACE_FACILITY == 1 )
    429                  {
    430                      /* Store the stream buffer number so it can be restored after the
    431                       * reset. */
    432                      uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x10   0x6A25             LDR      R5,[R4, #+32]
    433                  }
    434              #endif
    435          
    436              /* Can only reset a message buffer if there are no tasks blocked on it. */
    437              taskENTER_CRITICAL();
   \       0x12   0x.... 0x....      BL       vPortEnterCritical
    438              {
    439                  if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
   \       0x16   0x6920             LDR      R0,[R4, #+16]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xBF04             ITT      EQ
   \       0x1C   0x6960             LDREQ    R0,[R4, #+20]
   \       0x1E   0x2800             CMPEQ    R0,#+0
    440                  {
    441                      if( pxStreamBuffer->xTaskWaitingToSend == NULL )
   \       0x20   0xD109             BNE.N    ??xStreamBufferReset_0
    442                      {
    443                          prvInitialiseNewStreamBuffer( pxStreamBuffer,
    444                                                        pxStreamBuffer->pucBuffer,
    445                                                        pxStreamBuffer->xLength,
    446                                                        pxStreamBuffer->xTriggerLevelBytes,
    447                                                        pxStreamBuffer->ucFlags );
   \       0x22   0x7F20             LDRB     R0,[R4, #+28]
   \       0x24   0x2601             MOVS     R6,#+1
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x68E3             LDR      R3,[R4, #+12]
   \       0x2A   0x68A2             LDR      R2,[R4, #+8]
   \       0x2C   0x69A1             LDR      R1,[R4, #+24]
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       prvInitialiseNewStreamBuffer
    448                          xReturn = pdPASS;
    449          
    450                          #if ( configUSE_TRACE_FACILITY == 1 )
    451                              {
    452                                  pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
   \       0x34   0x6225             STR      R5,[R4, #+32]
    453                              }
    454                          #endif
    455          
    456                          traceSTREAM_BUFFER_RESET( xStreamBuffer );
    457                      }
    458                  }
    459              }
    460              taskEXIT_CRITICAL();
   \                     ??xStreamBufferReset_0: (+1)
   \       0x36   0x.... 0x....      BL       vPortExitCritical
    461          
    462              return xReturn;
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0xBD76             POP      {R1,R2,R4-R6,PC}
    463          }
    464          /*-----------------------------------------------------------*/
    465          

   \                                 In section .text, align 2, keep-with-next
    466          BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
    467                                                   size_t xTriggerLevel )
    468          {
   \                     xStreamBufferSetTriggerLevel: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    469              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    470              BaseType_t xReturn;
    471          
    472              configASSERT( pxStreamBuffer );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_6
   \        0x8   0xF44F 0x71EC      MOV      R1,#+472
   \        0xC   0x.... 0x....      BL       ?Subroutine2
    473          
    474              /* It is not valid for the trigger level to be 0. */
    475              if( xTriggerLevel == ( size_t ) 0 )
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x10   0xB905             CBNZ.N   R5,??xStreamBufferSetTriggerLevel_0
    476              {
    477                  xTriggerLevel = ( size_t ) 1;
   \       0x12   0x2501             MOVS     R5,#+1
    478              }
    479          
    480              /* The trigger level is the number of bytes that must be in the stream
    481               * buffer before a task that is waiting for data is unblocked. */
    482              if( xTriggerLevel <= pxStreamBuffer->xLength )
   \                     ??xStreamBufferSetTriggerLevel_0: (+1)
   \       0x14   0x68A0             LDR      R0,[R4, #+8]
   \       0x16   0x42A8             CMP      R0,R5
   \       0x18   0xD302             BCC.N    ??xStreamBufferSetTriggerLevel_1
    483              {
    484                  pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
   \       0x1A   0x60E5             STR      R5,[R4, #+12]
    485                  xReturn = pdPASS;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
    486              }
    487              else
    488              {
    489                  xReturn = pdFALSE;
   \                     ??xStreamBufferSetTriggerLevel_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
    490              }
    491          
    492              return xReturn;
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
    493          }
    494          /*-----------------------------------------------------------*/
    495          

   \                                 In section .text, align 2, keep-with-next
    496          size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
    497          {
   \                     xStreamBufferSpacesAvailable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    498              const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    499              size_t xSpace;
    500          
    501              configASSERT( pxStreamBuffer );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_5
   \        0x6   0xF240 0x11F5      MOVW     R1,#+501
   \        0xA   0x.... 0x....      BL       ?Subroutine2
    502          
    503              xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
    504              xSpace -= pxStreamBuffer->xHead;
    505              xSpace -= ( size_t ) 1;
   \       0x10   0x68A2             LDR      R2,[R4, #+8]
   \       0x12   0x6861             LDR      R1,[R4, #+4]
   \       0x14   0x1880             ADDS     R0,R0,R2
   \       0x16   0x1A40             SUBS     R0,R0,R1
   \       0x18   0x1E40             SUBS     R0,R0,#+1
    506          
    507              if( xSpace >= pxStreamBuffer->xLength )
   \       0x1A   0x4290             CMP      R0,R2
   \       0x1C   0xBF28             IT       CS
   \       0x1E   0x1A80             SUBCS    R0,R0,R2
    508              {
    509                  xSpace -= pxStreamBuffer->xLength;
    510              }
    511              else
    512              {
    513                  mtCOVERAGE_TEST_MARKER();
    514              }
    515          
    516              return xSpace;
   \       0x20   0xBD10             POP      {R4,PC}
    517          }
    518          /*-----------------------------------------------------------*/
    519          

   \                                 In section .text, align 2, keep-with-next
    520          size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
    521          {
   \                     xStreamBufferBytesAvailable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    522              const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    523              size_t xReturn;
    524          
    525              configASSERT( pxStreamBuffer );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_4
   \        0x6   0xF240 0x210D      MOVW     R1,#+525
   \        0xA   0x.... 0x....      BL       ?Subroutine2
    526          
    527              xReturn = prvBytesInBuffer( pxStreamBuffer );
    528              return xReturn;
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0xE8BD 0x4010      POP      {R4,LR}
   \       0x14   0x....             B.N      prvBytesInBuffer
    529          }
    530          /*-----------------------------------------------------------*/
    531          

   \                                 In section .text, align 2, keep-with-next
    532          size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
    533                                    const void * pvTxData,
    534                                    size_t xDataLengthBytes,
    535                                    TickType_t xTicksToWait )
    536          {
   \                     xStreamBufferSend: (+1)
   \        0x0   0xE92D 0x43FC      PUSH     {R2-R9,LR}
   \        0x4   0xB083             SUB      SP,SP,#+12
   \        0x6   0x4605             MOV      R5,R0
    537              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    538              size_t xReturn, xSpace = 0;
    539              size_t xRequiredSpace = xDataLengthBytes;
    540              TimeOut_t xTimeOut;
    541          
    542              /* The maximum amount of space a stream buffer will ever report is its length
    543               * minus 1. */
    544              const size_t xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
   \        0x8   0x68AE             LDR      R6,[R5, #+8]
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x460C             MOV      R4,R1
   \        0xE   0x4647             MOV      R7,R8
   \       0x10   0x1E76             SUBS     R6,R6,#+1
    545          
    546              configASSERT( pvTxData );
   \       0x12   0x.... 0x....      LDR.W    R9,??DataTable9
   \       0x16   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_17
   \       0x18   0xF240 0x2122      MOVW     R1,#+546
   \       0x1C   0x.... 0x....      BL       ?Subroutine3
    547              configASSERT( pxStreamBuffer );
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x20   0xB91D             CBNZ.N   R5,??CrossCallReturnLabel_16
   \       0x22   0xF240 0x2123      MOVW     R1,#+547
   \       0x26   0x.... 0x....      BL       ?Subroutine3
    548          
    549              /* This send function is used to write to both message buffers and stream
    550               * buffers.  If this is a message buffer then the space needed must be
    551               * increased by the amount of bytes needed to store the length of the
    552               * message. */
    553              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x2A   0x7F29             LDRB     R1,[R5, #+28]
   \       0x2C   0x07C8             LSLS     R0,R1,#+31
   \       0x2E   0xD50B             BPL.N    ??xStreamBufferSend_0
    554              {
    555                  xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
   \       0x30   0x1D3F             ADDS     R7,R7,#+4
    556          
    557                  /* Overflow? */
    558                  configASSERT( xRequiredSpace > xDataLengthBytes );
   \       0x32   0x45B8             CMP      R8,R7
   \       0x34   0xD303             BCC.N    ??CrossCallReturnLabel_15
   \       0x36   0xF240 0x212E      MOVW     R1,#+558
   \       0x3A   0x.... 0x....      BL       ?Subroutine3
    559          
    560                  /* If this is a message buffer then it must be possible to write the
    561                   * whole message. */
    562                  if( xRequiredSpace > xMaxReportedSpace )
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x3E   0x42BE             CMP      R6,R7
   \       0x40   0xD205             BCS.N    ??xStreamBufferSend_1
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x9004             STR      R0,[SP, #+16]
   \       0x46   0xE02F             B.N      ??xStreamBufferSend_2
    563                  {
    564                      /* The message would not fit even if the entire buffer was empty,
    565                       * so don't wait for space. */
    566                      xTicksToWait = ( TickType_t ) 0;
    567                  }
    568                  else
    569                  {
    570                      mtCOVERAGE_TEST_MARKER();
    571                  }
    572              }
    573              else
    574              {
    575                  /* If this is a stream buffer then it is acceptable to write only part
    576                   * of the message to the buffer.  Cap the length to the total length of
    577                   * the buffer. */
    578                  if( xRequiredSpace > xMaxReportedSpace )
   \                     ??xStreamBufferSend_0: (+1)
   \       0x48   0x42BE             CMP      R6,R7
   \       0x4A   0xBF98             IT       LS
   \       0x4C   0x4637             MOVLS    R7,R6
    579                  {
    580                      xRequiredSpace = xMaxReportedSpace;
    581                  }
    582                  else
    583                  {
    584                      mtCOVERAGE_TEST_MARKER();
    585                  }
    586              }
    587          
    588              if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xStreamBufferSend_1: (+1)
   \       0x4E   0x9804             LDR      R0,[SP, #+16]
   \       0x50   0xB350             CBZ.N    R0,??xStreamBufferSend_2
    589              {
    590                  vTaskSetTimeOutState( &xTimeOut );
   \       0x52   0xA801             ADD      R0,SP,#+4
   \       0x54   0x.... 0x....      BL       vTaskSetTimeOutState
    591          
    592                  do
    593                  {
    594                      /* Wait until the required number of bytes are free in the message
    595                       * buffer. */
    596                      taskENTER_CRITICAL();
   \                     ??xStreamBufferSend_3: (+1)
   \       0x58   0x.... 0x....      BL       vPortEnterCritical
    597                      {
    598                          xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0x.... 0x....      BL       xStreamBufferSpacesAvailable
   \       0x62   0x4606             MOV      R6,R0
    599          
    600                          if( xSpace < xRequiredSpace )
   \       0x64   0x42BE             CMP      R6,R7
   \       0x66   0xD245             BCS.N    ??xStreamBufferSend_4
    601                          {
    602                              /* Clear notification state as going to wait for space. */
    603                              ( void ) xTaskNotifyStateClear( NULL );
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x.... 0x....      BL       xTaskGenericNotifyStateClear
    604          
    605                              /* Should only be one writer. */
    606                              configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
   \       0x70   0x6968             LDR      R0,[R5, #+20]
   \       0x72   0xB118             CBZ.N    R0,??CrossCallReturnLabel_14
   \       0x74   0xF240 0x215E      MOVW     R1,#+606
   \       0x78   0x.... 0x....      BL       ?Subroutine3
    607                              pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x7C   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x80   0x6168             STR      R0,[R5, #+20]
    608                          }
    609                          else
    610                          {
    611                              taskEXIT_CRITICAL();
    612                              break;
    613                          }
    614                      }
    615                      taskEXIT_CRITICAL();
   \       0x82   0x.... 0x....      BL       vPortExitCritical
    616          
    617                      traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
    618                      ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
   \       0x86   0x9804             LDR      R0,[SP, #+16]
   \       0x88   0x2300             MOVS     R3,#+0
   \       0x8A   0x2200             MOVS     R2,#+0
   \       0x8C   0x9000             STR      R0,[SP, #+0]
   \       0x8E   0x2100             MOVS     R1,#+0
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x.... 0x....      BL       xTaskGenericNotifyWait
    619                      pxStreamBuffer->xTaskWaitingToSend = NULL;
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x6168             STR      R0,[R5, #+20]
    620                  } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
   \       0x9A   0xA904             ADD      R1,SP,#+16
   \       0x9C   0xA801             ADD      R0,SP,#+4
   \       0x9E   0x.... 0x....      BL       xTaskCheckForTimeOut
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD0D8             BEQ.N    ??xStreamBufferSend_3
    621              }
    622              else
    623              {
    624                  mtCOVERAGE_TEST_MARKER();
    625              }
    626          
    627              if( xSpace == ( size_t ) 0 )
   \                     ??xStreamBufferSend_5: (+1)
   \       0xA6   0xB91E             CBNZ.N   R6,??xStreamBufferSend_6
    628              {
    629                  xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
   \                     ??xStreamBufferSend_2: (+1)
   \       0xA8   0x4628             MOV      R0,R5
   \       0xAA   0x.... 0x....      BL       xStreamBufferSpacesAvailable
   \       0xAE   0x4606             MOV      R6,R0
    630              }
    631              else
    632              {
    633                  mtCOVERAGE_TEST_MARKER();
    634              }
    635          
    636              xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
   \                     ??xStreamBufferSend_6: (+1)
   \       0xB0   0x9700             STR      R7,[SP, #+0]
   \       0xB2   0x4633             MOV      R3,R6
   \       0xB4   0x4642             MOV      R2,R8
   \       0xB6   0x4621             MOV      R1,R4
   \       0xB8   0x4628             MOV      R0,R5
   \       0xBA   0x.... 0x....      BL       prvWriteMessageToBuffer
   \       0xBE   0x0004             MOVS     R4,R0
    637          
    638              if( xReturn > ( size_t ) 0 )
   \       0xC0   0xD014             BEQ.N    ??xStreamBufferSend_7
    639              {
    640                  traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
    641          
    642                  /* Was a task waiting for the data? */
    643                  if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
   \       0xC2   0x4628             MOV      R0,R5
   \       0xC4   0x.... 0x....      BL       prvBytesInBuffer
   \       0xC8   0x68E9             LDR      R1,[R5, #+12]
   \       0xCA   0x4288             CMP      R0,R1
   \       0xCC   0xD30E             BCC.N    ??xStreamBufferSend_7
    644                  {
    645                      sbSEND_COMPLETED( pxStreamBuffer );
   \       0xCE   0x.... 0x....      BL       vTaskSuspendAll
   \       0xD2   0x6928             LDR      R0,[R5, #+16]
   \       0xD4   0xB140             CBZ.N    R0,??xStreamBufferSend_8
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0x9100             STR      R1,[SP, #+0]
   \       0xDA   0x6928             LDR      R0,[R5, #+16]
   \       0xDC   0x2300             MOVS     R3,#+0
   \       0xDE   0x2200             MOVS     R2,#+0
   \       0xE0   0x.... 0x....      BL       xTaskGenericNotify
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0x6128             STR      R0,[R5, #+16]
   \                     ??xStreamBufferSend_8: (+1)
   \       0xE8   0x.... 0x....      BL       xTaskResumeAll
    646                  }
    647                  else
    648                  {
    649                      mtCOVERAGE_TEST_MARKER();
    650                  }
    651              }
    652              else
    653              {
    654                  mtCOVERAGE_TEST_MARKER();
    655                  traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    656              }
    657          
    658              return xReturn;
   \                     ??xStreamBufferSend_7: (+1)
   \       0xEC   0x4620             MOV      R0,R4
   \       0xEE   0xB005             ADD      SP,SP,#+20
   \       0xF0   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??xStreamBufferSend_4: (+1)
   \       0xF4   0x.... 0x....      BL       vPortExitCritical
   \       0xF8   0xE7D5             B.N      ??xStreamBufferSend_5
    659          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4648             MOV      R0,R9
   \        0x2   0x.... 0x....      B.W      assertEFM
    660          /*-----------------------------------------------------------*/
    661          

   \                                 In section .text, align 2, keep-with-next
    662          size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
    663                                           const void * pvTxData,
    664                                           size_t xDataLengthBytes,
    665                                           BaseType_t * const pxHigherPriorityTaskWoken )
    666          {
   \                     xStreamBufferSendFromISR: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4690             MOV      R8,R2
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x000D             MOVS     R5,R1
   \        0xA   0x461E             MOV      R6,R3
    667              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    668              size_t xReturn, xSpace;
    669              size_t xRequiredSpace = xDataLengthBytes;
   \        0xC   0x4647             MOV      R7,R8
    670          
    671              configASSERT( pvTxData );
   \        0xE   0x.... 0x....      LDR.W    R9,??DataTable9
   \       0x12   0xD103             BNE.N    ??CrossCallReturnLabel_13
   \       0x14   0xF240 0x219F      MOVW     R1,#+671
   \       0x18   0x.... 0x....      BL       ?Subroutine3
    672              configASSERT( pxStreamBuffer );
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x1C   0xB91C             CBNZ.N   R4,??CrossCallReturnLabel_12
   \       0x1E   0xF44F 0x7128      MOV      R1,#+672
   \       0x22   0x.... 0x....      BL       ?Subroutine3
    673          
    674              /* This send function is used to write to both message buffers and stream
    675               * buffers.  If this is a message buffer then the space needed must be
    676               * increased by the amount of bytes needed to store the length of the
    677               * message. */
    678              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x26   0x7F21             LDRB     R1,[R4, #+28]
   \       0x28   0x07C8             LSLS     R0,R1,#+31
   \       0x2A   0xBF48             IT       MI
   \       0x2C   0x1D3F             ADDMI    R7,R7,#+4
    679              {
    680                  xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    681              }
    682              else
    683              {
    684                  mtCOVERAGE_TEST_MARKER();
    685              }
    686          
    687              xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       xStreamBufferSpacesAvailable
    688              xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
   \       0x34   0x4603             MOV      R3,R0
   \       0x36   0x9700             STR      R7,[SP, #+0]
   \       0x38   0x4642             MOV      R2,R8
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       prvWriteMessageToBuffer
   \       0x42   0x0005             MOVS     R5,R0
    689          
    690              if( xReturn > ( size_t ) 0 )
   \       0x44   0xD011             BEQ.N    ??xStreamBufferSendFromISR_0
    691              {
    692                  /* Was a task waiting for the data? */
    693                  if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x.... 0x....      BL       prvBytesInBuffer
   \       0x4C   0x68E1             LDR      R1,[R4, #+12]
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD30B             BCC.N    ??xStreamBufferSendFromISR_0
    694                  {
    695                      sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
   \       0x52   0x.... 0x....      BL       ulSetInterruptMask
   \       0x56   0x4607             MOV      R7,R0
   \       0x58   0x6920             LDR      R0,[R4, #+16]
   \       0x5A   0xB118             CBZ.N    R0,??xStreamBufferSendFromISR_1
   \       0x5C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x6120             STR      R0,[R4, #+16]
   \                     ??xStreamBufferSendFromISR_1: (+1)
   \       0x64   0x4638             MOV      R0,R7
   \       0x66   0x.... 0x....      BL       vClearInterruptMask
    696                  }
    697                  else
    698                  {
    699                      mtCOVERAGE_TEST_MARKER();
    700                  }
    701              }
    702              else
    703              {
    704                  mtCOVERAGE_TEST_MARKER();
    705              }
    706          
    707              traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
    708          
    709              return xReturn;
   \                     ??xStreamBufferSendFromISR_0: (+1)
   \       0x6A   0x....             B.N      ?Subroutine1
    710          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0xE8BD 0x83FE      POP      {R1-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x9601             STR      R6,[SP, #+4]
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x6920             LDR      R0,[R4, #+16]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x.... 0x....      B.W      xTaskGenericNotifyFromISR
    711          /*-----------------------------------------------------------*/
    712          

   \                                 In section .text, align 2, keep-with-next
    713          static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
    714                                                 const void * pvTxData,
    715                                                 size_t xDataLengthBytes,
    716                                                 size_t xSpace,
    717                                                 size_t xRequiredSpace )
    718          {
   \                     prvWriteMessageToBuffer: (+1)
   \        0x0   0xB534             PUSH     {R2,R4,R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    719              BaseType_t xShouldWrite;
    720              size_t xReturn;
    721          
    722              if( xSpace == ( size_t ) 0 )
   \        0x6   0xB1B3             CBZ.N    R3,??prvWriteMessageToBuffer_0
    723              {
    724                  /* Doesn't matter if this is a stream buffer or a message buffer, there
    725                   * is no space to write. */
    726                  xShouldWrite = pdFALSE;
    727              }
    728              else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
   \        0x8   0x7F29             LDRB     R1,[R5, #+28]
   \        0xA   0x07C8             LSLS     R0,R1,#+31
   \        0xC   0xD40A             BMI.N    ??prvWriteMessageToBuffer_1
    729              {
    730                  /* This is a stream buffer, as opposed to a message buffer, so writing a
    731                   * stream of bytes rather than discrete messages.  Write as many bytes as
    732                   * possible. */
    733                  xShouldWrite = pdTRUE;
    734                  xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
   \        0xE   0x4610             MOV      R0,R2
   \       0x10   0x4298             CMP      R0,R3
   \       0x12   0xBF88             IT       HI
   \       0x14   0x4618             MOVHI    R0,R3
   \       0x16   0x9000             STR      R0,[SP, #+0]
    735              }
    736              else if( xSpace >= xRequiredSpace )
    737              {
    738                  /* This is a message buffer, as opposed to a stream buffer, and there
    739                   * is enough space to write both the message length and the message itself
    740                   * into the buffer.  Start by writing the length of the data, the data
    741                   * itself will be written later in this function. */
    742                  xShouldWrite = pdTRUE;
    743                  ( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    744              }
    745              else
    746              {
    747                  /* There is space available, but not enough space. */
    748                  xShouldWrite = pdFALSE;
    749              }
    750          
    751              if( xShouldWrite != pdFALSE )
    752              {
    753                  /* Writes the data itself. */
    754                  xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
   \                     ??prvWriteMessageToBuffer_2: (+1)
   \       0x18   0x9A00             LDR      R2,[SP, #+0]
   \       0x1A   0x4621             MOV      R1,R4
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x.... 0x....      BL       prvWriteBytesToBuffer
    755              }
    756              else
    757              {
    758                  xReturn = 0;
    759              }
    760          
    761              return xReturn;
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??prvWriteMessageToBuffer_1: (+1)
   \       0x24   0x9804             LDR      R0,[SP, #+16]
   \       0x26   0x4283             CMP      R3,R0
   \       0x28   0xD305             BCC.N    ??prvWriteMessageToBuffer_0
   \       0x2A   0x2204             MOVS     R2,#+4
   \       0x2C   0x4669             MOV      R1,SP
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x.... 0x....      BL       prvWriteBytesToBuffer
   \       0x34   0xE7F0             B.N      ??prvWriteMessageToBuffer_2
   \                     ??prvWriteMessageToBuffer_0: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
    762          }
    763          /*-----------------------------------------------------------*/
    764          

   \                                 In section .text, align 2, keep-with-next
    765          size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
    766                                       void * pvRxData,
    767                                       size_t xBufferLengthBytes,
    768                                       TickType_t xTicksToWait )
    769          {
   \                     xStreamBufferReceive: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x4693             MOV      R11,R2
   \        0xA   0x461F             MOV      R7,R3
    770              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    771              size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
   \        0xC   0xF04F 0x0900      MOV      R9,#+0
    772          
    773              configASSERT( pvRxData );
   \       0x10   0x.... 0x....      LDR.W    R8,??DataTable9
   \       0x14   0xD103             BNE.N    ??CrossCallReturnLabel_20
   \       0x16   0xF240 0x3105      MOVW     R1,#+773
   \       0x1A   0x.... 0x....      BL       ?Subroutine4
    774              configASSERT( pxStreamBuffer );
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x1E   0xB91E             CBNZ.N   R6,??CrossCallReturnLabel_19
   \       0x20   0xF240 0x3106      MOVW     R1,#+774
   \       0x24   0x.... 0x....      BL       ?Subroutine4
    775          
    776              /* This receive function is used by both message buffers, which store
    777               * discrete messages, and stream buffers, which store a continuous stream of
    778               * bytes.  Discrete messages include an additional
    779               * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    780               * message. */
    781              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    782              {
    783                  xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    784              }
    785              else
    786              {
    787                  xBytesToStoreMessageLength = 0;
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x28   0x7F35             LDRB     R5,[R6, #+28]
   \       0x2A   0xF005 0x0501      AND      R5,R5,#0x1
   \       0x2E   0x00AD             LSLS     R5,R5,#+2
    788              }
    789          
    790              if( xTicksToWait != ( TickType_t ) 0 )
   \       0x30   0xB30F             CBZ.N    R7,??xStreamBufferReceive_0
    791              {
    792                  /* Checking if there is data and clearing the notification state must be
    793                   * performed atomically. */
    794                  taskENTER_CRITICAL();
   \       0x32   0x.... 0x....      BL       vPortEnterCritical
    795                  {
    796                      xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x.... 0x....      BL       prvBytesInBuffer
   \       0x3C   0x4682             MOV      R10,R0
    797          
    798                      /* If this function was invoked by a message buffer read then
    799                       * xBytesToStoreMessageLength holds the number of bytes used to hold
    800                       * the length of the next discrete message.  If this function was
    801                       * invoked by a stream buffer read then xBytesToStoreMessageLength will
    802                       * be 0. */
    803                      if( xBytesAvailable <= xBytesToStoreMessageLength )
   \       0x3E   0x4555             CMP      R5,R10
   \       0x40   0xD30C             BCC.N    ??xStreamBufferReceive_1
    804                      {
    805                          /* Clear notification state as going to wait for data. */
    806                          ( void ) xTaskNotifyStateClear( NULL );
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x.... 0x....      BL       xTaskGenericNotifyStateClear
    807          
    808                          /* Should only be one reader. */
    809                          configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
   \       0x4A   0x6930             LDR      R0,[R6, #+16]
   \       0x4C   0xB118             CBZ.N    R0,??CrossCallReturnLabel_18
   \       0x4E   0xF240 0x3129      MOVW     R1,#+809
   \       0x52   0x.... 0x....      BL       ?Subroutine4
    810                          pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x56   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x5A   0x6130             STR      R0,[R6, #+16]
    811                      }
    812                      else
    813                      {
    814                          mtCOVERAGE_TEST_MARKER();
    815                      }
    816                  }
    817                  taskEXIT_CRITICAL();
   \                     ??xStreamBufferReceive_1: (+1)
   \       0x5C   0x.... 0x....      BL       vPortExitCritical
    818          
    819                  if( xBytesAvailable <= xBytesToStoreMessageLength )
   \       0x60   0x4555             CMP      R5,R10
   \       0x62   0xD30C             BCC.N    ??xStreamBufferReceive_2
    820                  {
    821                      /* Wait for data to be available. */
    822                      traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
    823                      ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
   \       0x64   0x9700             STR      R7,[SP, #+0]
   \       0x66   0x2300             MOVS     R3,#+0
   \       0x68   0x2200             MOVS     R2,#+0
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x.... 0x....      BL       xTaskGenericNotifyWait
    824                      pxStreamBuffer->xTaskWaitingToReceive = NULL;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x6130             STR      R0,[R6, #+16]
    825          
    826                      /* Recheck the data available after blocking. */
    827                      xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    828                  }
    829                  else
    830                  {
    831                      mtCOVERAGE_TEST_MARKER();
    832                  }
    833              }
    834              else
    835              {
    836                  xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \                     ??xStreamBufferReceive_0: (+1)
   \       0x76   0x4630             MOV      R0,R6
   \       0x78   0x.... 0x....      BL       prvBytesInBuffer
   \       0x7C   0x4682             MOV      R10,R0
    837              }
    838          
    839              /* Whether receiving a discrete message (where xBytesToStoreMessageLength
    840               * holds the number of bytes used to store the message length) or a stream of
    841               * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
    842               * available must be greater than xBytesToStoreMessageLength to be able to
    843               * read bytes from the buffer. */
    844              if( xBytesAvailable > xBytesToStoreMessageLength )
   \                     ??xStreamBufferReceive_2: (+1)
   \       0x7E   0x4555             CMP      R5,R10
   \       0x80   0xD218             BCS.N    ??xStreamBufferReceive_3
   \       0x82   0x465A             MOV      R2,R11
    845              {
    846                  xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
   \       0x84   0x9500             STR      R5,[SP, #+0]
   \       0x86   0x4653             MOV      R3,R10
   \       0x88   0x4621             MOV      R1,R4
   \       0x8A   0x4630             MOV      R0,R6
   \       0x8C   0x.... 0x....      BL       prvReadMessageFromBuffer
   \       0x90   0xEA5F 0x0900      MOVS     R9,R0
    847          
    848                  /* Was a task waiting for space in the buffer? */
    849                  if( xReceivedLength != ( size_t ) 0 )
   \       0x94   0xD00E             BEQ.N    ??xStreamBufferReceive_3
    850                  {
    851                      traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
    852                      sbRECEIVE_COMPLETED( pxStreamBuffer );
   \       0x96   0x.... 0x....      BL       vTaskSuspendAll
   \       0x9A   0x6970             LDR      R0,[R6, #+20]
   \       0x9C   0xB140             CBZ.N    R0,??xStreamBufferReceive_4
   \       0x9E   0x2100             MOVS     R1,#+0
   \       0xA0   0x9100             STR      R1,[SP, #+0]
   \       0xA2   0x6970             LDR      R0,[R6, #+20]
   \       0xA4   0x2300             MOVS     R3,#+0
   \       0xA6   0x2200             MOVS     R2,#+0
   \       0xA8   0x.... 0x....      BL       xTaskGenericNotify
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x6170             STR      R0,[R6, #+20]
   \                     ??xStreamBufferReceive_4: (+1)
   \       0xB0   0x.... 0x....      BL       xTaskResumeAll
    853                  }
    854                  else
    855                  {
    856                      mtCOVERAGE_TEST_MARKER();
    857                  }
    858              }
    859              else
    860              {
    861                  traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
    862                  mtCOVERAGE_TEST_MARKER();
    863              }
    864          
    865              return xReceivedLength;
   \                     ??xStreamBufferReceive_3: (+1)
   \       0xB4   0x4648             MOV      R0,R9
   \       0xB6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    866          }
    867          /*-----------------------------------------------------------*/
    868          

   \                                 In section .text, align 2, keep-with-next
    869          size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
    870          {
   \                     xStreamBufferNextMessageLengthBytes: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    871              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    872              size_t xReturn, xBytesAvailable, xOriginalTail;
    873              configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;
    874          
    875              configASSERT( pxStreamBuffer );
   \        0x4   0x....             LDR.N    R5,??DataTable9
   \        0x6   0xD104             BNE.N    ??xStreamBufferNextMessageLengthBytes_0
   \        0x8   0xF240 0x316B      MOVW     R1,#+875
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0x.... 0x....      BL       assertEFM
    876          
    877              /* Ensure the stream buffer is being used as a message buffer. */
    878              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferNextMessageLengthBytes_0: (+1)
   \       0x12   0x7F21             LDRB     R1,[R4, #+28]
   \       0x14   0x07C8             LSLS     R0,R1,#+31
   \       0x16   0xD514             BPL.N    ??xStreamBufferNextMessageLengthBytes_1
    879              {
    880                  xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       prvBytesInBuffer
   \       0x1E   0x4603             MOV      R3,R0
    881          
    882                  if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
   \       0x20   0x2B04             CMP      R3,#+4
   \       0x22   0xD908             BLS.N    ??xStreamBufferNextMessageLengthBytes_2
    883                  {
    884                      /* The number of bytes available is greater than the number of bytes
    885                       * required to hold the length of the next message, so another message
    886                       * is available.  Return its length without removing the length bytes
    887                       * from the buffer.  A copy of the tail is stored so the buffer can be
    888                       * returned to its prior state as the message is not actually being
    889                       * removed from the buffer. */
    890                      xOriginalTail = pxStreamBuffer->xTail;
   \       0x24   0x6825             LDR      R5,[R4, #+0]
    891                      ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
   \       0x26   0x2204             MOVS     R2,#+4
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       prvReadBytesFromBuffer
    892                      xReturn = ( size_t ) xTempReturn;
   \       0x30   0x9800             LDR      R0,[SP, #+0]
    893                      pxStreamBuffer->xTail = xOriginalTail;
   \       0x32   0x6025             STR      R5,[R4, #+0]
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
    894                  }
    895                  else
    896                  {
    897                      /* The minimum amount of bytes in a message buffer is
    898                       * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
    899                       * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
    900                       * value is 0. */
    901                      configASSERT( xBytesAvailable == 0 );
   \                     ??xStreamBufferNextMessageLengthBytes_2: (+1)
   \       0x36   0xB123             CBZ.N    R3,??xStreamBufferNextMessageLengthBytes_1
   \       0x38   0xF240 0x3185      MOVW     R1,#+901
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       assertEFM
    902                      xReturn = 0;
    903                  }
    904              }
    905              else
    906              {
    907                  xReturn = 0;
   \                     ??xStreamBufferNextMessageLengthBytes_1: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
    908              }
    909          
    910              return xReturn;
   \       0x44   0xBD32             POP      {R1,R4,R5,PC}
    911          }
    912          /*-----------------------------------------------------------*/
    913          

   \                                 In section .text, align 2, keep-with-next
    914          size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
    915                                              void * pvRxData,
    916                                              size_t xBufferLengthBytes,
    917                                              BaseType_t * const pxHigherPriorityTaskWoken )
    918          {
   \                     xStreamBufferReceiveFromISR: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
    919              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    920              size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
   \        0xC   0x2500             MOVS     R5,#+0
    921          
    922              configASSERT( pvRxData );
   \        0xE   0x....             LDR.N    R7,??DataTable9
   \       0x10   0xB924             CBNZ.N   R4,??xStreamBufferReceiveFromISR_0
   \       0x12   0xF240 0x319A      MOVW     R1,#+922
   \       0x16   0x4638             MOV      R0,R7
   \       0x18   0x.... 0x....      BL       assertEFM
    923              configASSERT( pxStreamBuffer );
   \                     ??xStreamBufferReceiveFromISR_0: (+1)
   \       0x1C   0xB926             CBNZ.N   R6,??xStreamBufferReceiveFromISR_1
   \       0x1E   0xF240 0x319B      MOVW     R1,#+923
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x.... 0x....      BL       assertEFM
    924          
    925              /* This receive function is used by both message buffers, which store
    926               * discrete messages, and stream buffers, which store a continuous stream of
    927               * bytes.  Discrete messages include an additional
    928               * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    929               * message. */
    930              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    931              {
    932                  xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    933              }
    934              else
    935              {
    936                  xBytesToStoreMessageLength = 0;
   \                     ??xStreamBufferReceiveFromISR_1: (+1)
   \       0x28   0x7F37             LDRB     R7,[R6, #+28]
    937              }
    938          
    939              xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       prvBytesInBuffer
   \       0x30   0xF007 0x0701      AND      R7,R7,#0x1
   \       0x34   0x00BF             LSLS     R7,R7,#+2
    940          
    941              /* Whether receiving a discrete message (where xBytesToStoreMessageLength
    942               * holds the number of bytes used to store the message length) or a stream of
    943               * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
    944               * available must be greater than xBytesToStoreMessageLength to be able to
    945               * read bytes from the buffer. */
    946              if( xBytesAvailable > xBytesToStoreMessageLength )
   \       0x36   0x4287             CMP      R7,R0
   \       0x38   0xD21B             BCS.N    ??xStreamBufferReceiveFromISR_2
    947              {
    948                  xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
   \       0x3A   0x4603             MOV      R3,R0
   \       0x3C   0x9700             STR      R7,[SP, #+0]
   \       0x3E   0x4642             MOV      R2,R8
   \       0x40   0x4621             MOV      R1,R4
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0x.... 0x....      BL       prvReadMessageFromBuffer
   \       0x48   0x0005             MOVS     R5,R0
    949          
    950                  /* Was a task waiting for space in the buffer? */
    951                  if( xReceivedLength != ( size_t ) 0 )
   \       0x4A   0xD012             BEQ.N    ??xStreamBufferReceiveFromISR_2
    952                  {
    953                      sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
   \       0x4C   0x.... 0x....      BL       ulSetInterruptMask
   \       0x50   0x4604             MOV      R4,R0
   \       0x52   0x6970             LDR      R0,[R6, #+20]
   \       0x54   0xB150             CBZ.N    R0,??xStreamBufferReceiveFromISR_3
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x5C   0x9100             STR      R1,[SP, #+0]
   \       0x5E   0x6970             LDR      R0,[R6, #+20]
   \       0x60   0x2300             MOVS     R3,#+0
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x6170             STR      R0,[R6, #+20]
   \                     ??xStreamBufferReceiveFromISR_3: (+1)
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0x.... 0x....      BL       vClearInterruptMask
    954                  }
    955                  else
    956                  {
    957                      mtCOVERAGE_TEST_MARKER();
    958                  }
    959              }
    960              else
    961              {
    962                  mtCOVERAGE_TEST_MARKER();
    963              }
    964          
    965              traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
    966          
    967              return xReceivedLength;
   \                     ??xStreamBufferReceiveFromISR_2: (+1)
   \       0x72                      REQUIRE ?Subroutine1
   \       0x72                      ;; // Fall through to label ?Subroutine1
    968          }
    969          /*-----------------------------------------------------------*/
    970          

   \                                 In section .text, align 2, keep-with-next
    971          static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
    972                                                  void * pvRxData,
    973                                                  size_t xBufferLengthBytes,
    974                                                  size_t xBytesAvailable,
    975                                                  size_t xBytesToStoreMessageLength )
    976          {
   \                     prvReadMessageFromBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x9C08             LDR      R4,[SP, #+32]
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x461F             MOV      R7,R3
    977              size_t xOriginalTail, xReceivedLength, xNextMessageLength;
    978              configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    979          
    980              if( xBytesToStoreMessageLength != ( size_t ) 0 )
   \        0xE   0xB154             CBZ.N    R4,??prvReadMessageFromBuffer_0
    981              {
    982                  /* A discrete message is being received.  First receive the length
    983                   * of the message.  A copy of the tail is stored so the buffer can be
    984                   * returned to its prior state if the length of the message is too
    985                   * large for the provided buffer. */
    986                  xOriginalTail = pxStreamBuffer->xTail;
   \       0x10   0x6835             LDR      R5,[R6, #+0]
    987                  ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
   \       0x12   0x4622             MOV      R2,R4
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x.... 0x....      BL       prvReadBytesFromBuffer
    988                  xNextMessageLength = ( size_t ) xTempNextMessageLength;
   \       0x1A   0x9A00             LDR      R2,[SP, #+0]
    989          
    990                  /* Reduce the number of bytes available by the number of bytes just
    991                   * read out. */
    992                  xBytesAvailable -= xBytesToStoreMessageLength;
   \       0x1C   0x1B3F             SUBS     R7,R7,R4
    993          
    994                  /* Check there is enough space in the buffer provided by the
    995                   * user. */
    996                  if( xNextMessageLength > xBufferLengthBytes )
   \       0x1E   0x4591             CMP      R9,R2
   \       0x20   0xBF3C             ITT      CC
   \       0x22   0x6035             STRCC    R5,[R6, #+0]
   \       0x24   0x2200             MOVCC    R2,#+0
    997                  {
    998                      /* The user has provided insufficient space to read the message
    999                       * so return the buffer to its previous state (so the length of
   1000                       * the message is in the buffer again). */
   1001                      pxStreamBuffer->xTail = xOriginalTail;
   1002                      xNextMessageLength = 0;
   1003                  }
   1004                  else
   1005                  {
   1006                      mtCOVERAGE_TEST_MARKER();
   1007                  }
   1008              }
   1009              else
   1010              {
   1011                  /* A stream of bytes is being received (as opposed to a discrete
   1012                   * message), so read as many bytes as possible. */
   1013                  xNextMessageLength = xBufferLengthBytes;
   1014              }
   1015          
   1016              /* Read the actual data. */
   1017              xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
   1018          
   1019              return xReceivedLength;
   \                     ??prvReadMessageFromBuffer_0: (+1)
   \       0x26   0x463B             MOV      R3,R7
   \       0x28   0x4641             MOV      R1,R8
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       prvReadBytesFromBuffer
   \       0x30   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1020          }
   1021          /*-----------------------------------------------------------*/
   1022          

   \                                 In section .text, align 2, keep-with-next
   1023          BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
   1024          {
   \                     xStreamBufferIsEmpty: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1025              const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   1026              BaseType_t xReturn;
   1027              size_t xTail;
   1028          
   1029              configASSERT( pxStreamBuffer );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_3
   \        0x6   0xF240 0x4105      MOVW     R1,#+1029
   \        0xA   0x.... 0x....      BL       ?Subroutine2
   1030          
   1031              /* True if no bytes are available. */
   1032              xTail = pxStreamBuffer->xTail;
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   1033          
   1034              if( pxStreamBuffer->xHead == xTail )
   \       0x10   0x6861             LDR      R1,[R4, #+4]
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD101             BNE.N    ??xStreamBufferIsEmpty_0
   1035              {
   1036                  xReturn = pdTRUE;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD10             POP      {R4,PC}
   1037              }
   1038              else
   1039              {
   1040                  xReturn = pdFALSE;
   \                     ??xStreamBufferIsEmpty_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   1041              }
   1042          
   1043              return xReturn;
   \       0x1C   0xBD10             POP      {R4,PC}
   1044          }
   1045          /*-----------------------------------------------------------*/
   1046          

   \                                 In section .text, align 2, keep-with-next
   1047          BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
   1048          {
   \                     xStreamBufferIsFull: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1049              BaseType_t xReturn;
   1050              size_t xBytesToStoreMessageLength;
   1051              const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   1052          
   1053              configASSERT( pxStreamBuffer );
   \        0x4   0xD103             BNE.N    ??CrossCallReturnLabel_2
   \        0x6   0xF240 0x411D      MOVW     R1,#+1053
   \        0xA   0x.... 0x....      BL       ?Subroutine2
   1054          
   1055              /* This generic version of the receive function is used by both message
   1056               * buffers, which store discrete messages, and stream buffers, which store a
   1057               * continuous stream of bytes.  Discrete messages include an additional
   1058               * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
   1059              if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   1060              {
   1061                  xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
   1062              }
   1063              else
   1064              {
   1065                  xBytesToStoreMessageLength = 0;
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0xE   0x7F25             LDRB     R5,[R4, #+28]
   1066              }
   1067          
   1068              /* True if the available space equals zero. */
   1069              if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       xStreamBufferSpacesAvailable
   \       0x16   0xF005 0x0501      AND      R5,R5,#0x1
   \       0x1A   0x00AD             LSLS     R5,R5,#+2
   \       0x1C   0x4285             CMP      R5,R0
   \       0x1E   0x4180             SBCS     R0,R0,R0
   \       0x20   0x43C0             MVNS     R0,R0
   \       0x22   0x0FC0             LSRS     R0,R0,#+31
   1070              {
   1071                  xReturn = pdTRUE;
   1072              }
   1073              else
   1074              {
   1075                  xReturn = pdFALSE;
   1076              }
   1077          
   1078              return xReturn;
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
   1079          }
   1080          /*-----------------------------------------------------------*/
   1081          

   \                                 In section .text, align 2, keep-with-next
   1082          BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
   1083                                                        BaseType_t * pxHigherPriorityTaskWoken )
   1084          {
   \                     xStreamBufferSendCompletedFromISR: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   1085              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   1086              BaseType_t xReturn;
   1087              UBaseType_t uxSavedInterruptStatus;
   1088          
   1089              configASSERT( pxStreamBuffer );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_1
   \        0x8   0xF240 0x4141      MOVW     R1,#+1089
   \        0xC   0x.... 0x....      BL       ?Subroutine2
   1090          
   1091              uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x10   0x.... 0x....      BL       ulSetInterruptMask
   \       0x14   0x4605             MOV      R5,R0
   1092              {
   1093                  if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
   \       0x16   0x6920             LDR      R0,[R4, #+16]
   \       0x18   0xB128             CBZ.N    R0,??xStreamBufferSendCompletedFromISR_0
   1094                  {
   1095                      ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
   1096                                                   ( uint32_t ) 0,
   1097                                                   eNoAction,
   1098                                                   pxHigherPriorityTaskWoken );
   \       0x1A   0x.... 0x....      BL       ?Subroutine5
   1099                      ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6120             STR      R0,[R4, #+16]
   1100                      xReturn = pdTRUE;
   \       0x22   0x2401             MOVS     R4,#+1
   \       0x24   0xE000             B.N      ??xStreamBufferSendCompletedFromISR_1
   1101                  }
   1102                  else
   1103                  {
   1104                      xReturn = pdFALSE;
   \                     ??xStreamBufferSendCompletedFromISR_0: (+1)
   \       0x26   0x2400             MOVS     R4,#+0
   1105                  }
   1106              }
   1107              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xStreamBufferSendCompletedFromISR_1: (+1)
   \       0x28   0x....             B.N      ?Subroutine0
   1108          
   1109              return xReturn;
   1110          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x.... 0x....      BL       vClearInterruptMask
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0xBD76             POP      {R1,R2,R4-R6,PC}
   1111          /*-----------------------------------------------------------*/
   1112          

   \                                 In section .text, align 2, keep-with-next
   1113          BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
   1114                                                           BaseType_t * pxHigherPriorityTaskWoken )
   1115          {
   \                     xStreamBufferReceiveCompletedFromISR: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   1116              StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   1117              BaseType_t xReturn;
   1118              UBaseType_t uxSavedInterruptStatus;
   1119          
   1120              configASSERT( pxStreamBuffer );
   \        0x6   0xD103             BNE.N    ??CrossCallReturnLabel_0
   \        0x8   0xF44F 0x618C      MOV      R1,#+1120
   \        0xC   0x.... 0x....      BL       ?Subroutine2
   1121          
   1122              uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x10   0x.... 0x....      BL       ulSetInterruptMask
   \       0x14   0x4605             MOV      R5,R0
   1123              {
   1124                  if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
   \       0x16   0x6960             LDR      R0,[R4, #+20]
   \       0x18   0xB158             CBZ.N    R0,??xStreamBufferReceiveCompletedFromISR_0
   1125                  {
   1126                      ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
   1127                                                   ( uint32_t ) 0,
   1128                                                   eNoAction,
   1129                                                   pxHigherPriorityTaskWoken );
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x9601             STR      R6,[SP, #+4]
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   \       0x20   0x6960             LDR      R0,[R4, #+20]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   1130                      ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6160             STR      R0,[R4, #+20]
   1131                      xReturn = pdTRUE;
   \       0x2E   0x2401             MOVS     R4,#+1
   \       0x30   0xE000             B.N      ??xStreamBufferReceiveCompletedFromISR_1
   1132                  }
   1133                  else
   1134                  {
   1135                      xReturn = pdFALSE;
   \                     ??xStreamBufferReceiveCompletedFromISR_0: (+1)
   \       0x32   0x2400             MOVS     R4,#+0
   1136                  }
   1137              }
   1138              portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xStreamBufferReceiveCompletedFromISR_1: (+1)
   \       0x34                      REQUIRE ?Subroutine0
   \       0x34                      ;; // Fall through to label ?Subroutine0
   1139          
   1140              return xReturn;
   1141          }
   1142          /*-----------------------------------------------------------*/
   1143          

   \                                 In section .text, align 2, keep-with-next
   1144          static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
   1145                                               const uint8_t * pucData,
   1146                                               size_t xCount )
   1147          {
   \                     prvWriteBytesToBuffer: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0xEA5F 0x0802      MOVS     R8,R2
   1148              size_t xNextHead, xFirstLength;
   1149          
   1150              configASSERT( xCount > ( size_t ) 0 );
   \        0xC   0x.... 0x....      LDR.W    R9,??DataTable9
   \       0x10   0xD103             BNE.N    ??CrossCallReturnLabel_11
   \       0x12   0xF240 0x417E      MOVW     R1,#+1150
   \       0x16   0x.... 0x....      BL       ?Subroutine3
   1151          
   1152              xNextHead = pxStreamBuffer->xHead;
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x1A   0x687C             LDR      R4,[R7, #+4]
   1153          
   1154              /* Calculate the number of bytes that can be added in the first write -
   1155               * which may be less than the total number of bytes that need to be added if
   1156               * the buffer will wrap back to the beginning. */
   1157              xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
   \       0x1C   0x68B9             LDR      R1,[R7, #+8]
   \       0x1E   0x1B0E             SUBS     R6,R1,R4
   \       0x20   0x4546             CMP      R6,R8
   \       0x22   0xBF88             IT       HI
   \       0x24   0x4646             MOVHI    R6,R8
   1158          
   1159              /* Write as many bytes as can be written in the first write. */
   1160              configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
   \       0x26   0x1930             ADDS     R0,R6,R4
   \       0x28   0x4281             CMP      R1,R0
   \       0x2A   0xD203             BCS.N    ??CrossCallReturnLabel_10
   \       0x2C   0xF44F 0x6191      MOV      R1,#+1160
   \       0x30   0x.... 0x....      BL       ?Subroutine3
   1161              ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x34   0x69B8             LDR      R0,[R7, #+24]
   \       0x36   0x4632             MOV      R2,R6
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x1900             ADDS     R0,R0,R4
   \       0x3C   0x.... 0x....      BL       __aeabi_memcpy
   1162          
   1163              /* If the number of bytes written was less than the number that could be
   1164               * written in the first write... */
   1165              if( xCount > xFirstLength )
   \       0x40   0x4546             CMP      R6,R8
   \       0x42   0xD20D             BCS.N    ??prvWriteBytesToBuffer_0
   1166              {
   1167                  /* ...then write the remaining bytes to the start of the buffer. */
   1168                  configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
   \       0x44   0x68B9             LDR      R1,[R7, #+8]
   \       0x46   0xEBA8 0x0A06      SUB      R10,R8,R6
   \       0x4A   0x4551             CMP      R1,R10
   \       0x4C   0xD203             BCS.N    ??CrossCallReturnLabel_9
   \       0x4E   0xF44F 0x6192      MOV      R1,#+1168
   \       0x52   0x.... 0x....      BL       ?Subroutine3
   1169                  ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x56   0x69B8             LDR      R0,[R7, #+24]
   \       0x58   0x4652             MOV      R2,R10
   \       0x5A   0x19A9             ADDS     R1,R5,R6
   \       0x5C   0x.... 0x....      BL       __aeabi_memcpy
   1170              }
   1171              else
   1172              {
   1173                  mtCOVERAGE_TEST_MARKER();
   1174              }
   1175          
   1176              xNextHead += xCount;
   1177          
   1178              if( xNextHead >= pxStreamBuffer->xLength )
   \                     ??prvWriteBytesToBuffer_0: (+1)
   \       0x60   0x68B8             LDR      R0,[R7, #+8]
   \       0x62   0x4444             ADD      R4,R8,R4
   \       0x64   0x4284             CMP      R4,R0
   \       0x66   0xBF28             IT       CS
   \       0x68   0x1A24             SUBCS    R4,R4,R0
   1179              {
   1180                  xNextHead -= pxStreamBuffer->xLength;
   1181              }
   1182              else
   1183              {
   1184                  mtCOVERAGE_TEST_MARKER();
   1185              }
   1186          
   1187              pxStreamBuffer->xHead = xNextHead;
   \       0x6A   0x607C             STR      R4,[R7, #+4]
   1188          
   1189              return xCount;
   \       0x6C   0x4640             MOV      R0,R8
   \       0x6E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1190          }
   1191          /*-----------------------------------------------------------*/
   1192          

   \                                 In section .text, align 2, keep-with-next
   1193          static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
   1194                                                uint8_t * pucData,
   1195                                                size_t xMaxCount,
   1196                                                size_t xBytesAvailable )
   1197          {
   \                     prvReadBytesFromBuffer: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4691             MOV      R9,R2
   \        0x6   0x461C             MOV      R4,R3
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x4688             MOV      R8,R1
   1198              size_t xCount, xFirstLength, xNextTail;
   1199          
   1200              /* Use the minimum of the wanted bytes and the available bytes. */
   1201              xCount = configMIN( xBytesAvailable, xMaxCount );
   \        0xC   0x454C             CMP      R4,R9
   \        0xE   0xBF88             IT       HI
   \       0x10   0x464C             MOVHI    R4,R9
   1202          
   1203              if( xCount > ( size_t ) 0 )
   \       0x12   0xB394             CBZ.N    R4,??prvReadBytesFromBuffer_0
   1204              {
   1205                  xNextTail = pxStreamBuffer->xTail;
   \       0x14   0x683D             LDR      R5,[R7, #+0]
   1206          
   1207                  /* Calculate the number of bytes that can be read - which may be
   1208                   * less than the number wanted if the data wraps around to the start of
   1209                   * the buffer. */
   1210                  xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
   \       0x16   0x68BE             LDR      R6,[R7, #+8]
   \       0x18   0x1B76             SUBS     R6,R6,R5
   \       0x1A   0x42A6             CMP      R6,R4
   \       0x1C   0xBF88             IT       HI
   \       0x1E   0x4626             MOVHI    R6,R4
   1211          
   1212                  /* Obtain the number of bytes it is possible to obtain in the first
   1213                   * read.  Asserts check bounds of read and write. */
   1214                  configASSERT( xFirstLength <= xMaxCount );
   \       0x20   0x.... 0x....      LDR.W    R10,??DataTable9
   \       0x24   0x45B1             CMP      R9,R6
   \       0x26   0xD204             BCS.N    ??prvReadBytesFromBuffer_1
   \       0x28   0xF240 0x41BE      MOVW     R1,#+1214
   \       0x2C   0x4650             MOV      R0,R10
   \       0x2E   0x.... 0x....      BL       assertEFM
   1215                  configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
   \                     ??prvReadBytesFromBuffer_1: (+1)
   \       0x32   0x68B9             LDR      R1,[R7, #+8]
   \       0x34   0x1970             ADDS     R0,R6,R5
   \       0x36   0x4281             CMP      R1,R0
   \       0x38   0xD204             BCS.N    ??prvReadBytesFromBuffer_2
   \       0x3A   0xF240 0x41BF      MOVW     R1,#+1215
   \       0x3E   0x4650             MOV      R0,R10
   \       0x40   0x.... 0x....      BL       assertEFM
   1216                  ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??prvReadBytesFromBuffer_2: (+1)
   \       0x44   0x69B8             LDR      R0,[R7, #+24]
   \       0x46   0x4632             MOV      R2,R6
   \       0x48   0x1941             ADDS     R1,R0,R5
   \       0x4A   0x4640             MOV      R0,R8
   \       0x4C   0x.... 0x....      BL       __aeabi_memcpy
   1217          
   1218                  /* If the total number of wanted bytes is greater than the number
   1219                   * that could be read in the first read... */
   1220                  if( xCount > xFirstLength )
   \       0x50   0x42A6             CMP      R6,R4
   \       0x52   0xD20C             BCS.N    ??prvReadBytesFromBuffer_3
   1221                  {
   1222                      /*...then read the remaining bytes from the start of the buffer. */
   1223                      configASSERT( xCount <= xMaxCount );
   \       0x54   0x45A1             CMP      R9,R4
   \       0x56   0xD204             BCS.N    ??prvReadBytesFromBuffer_4
   \       0x58   0xF240 0x41C7      MOVW     R1,#+1223
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0x.... 0x....      BL       assertEFM
   1224                      ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??prvReadBytesFromBuffer_4: (+1)
   \       0x62   0x69B9             LDR      R1,[R7, #+24]
   \       0x64   0x1BA2             SUBS     R2,R4,R6
   \       0x66   0xEB08 0x0006      ADD      R0,R8,R6
   \       0x6A   0x.... 0x....      BL       __aeabi_memcpy
   1225                  }
   1226                  else
   1227                  {
   1228                      mtCOVERAGE_TEST_MARKER();
   1229                  }
   1230          
   1231                  /* Move the tail pointer to effectively remove the data read from
   1232                   * the buffer. */
   1233                  xNextTail += xCount;
   1234          
   1235                  if( xNextTail >= pxStreamBuffer->xLength )
   \                     ??prvReadBytesFromBuffer_3: (+1)
   \       0x6E   0x68B8             LDR      R0,[R7, #+8]
   \       0x70   0x1965             ADDS     R5,R4,R5
   \       0x72   0x4285             CMP      R5,R0
   \       0x74   0xBF28             IT       CS
   \       0x76   0x1A2D             SUBCS    R5,R5,R0
   1236                  {
   1237                      xNextTail -= pxStreamBuffer->xLength;
   1238                  }
   1239          
   1240                  pxStreamBuffer->xTail = xNextTail;
   \       0x78   0x603D             STR      R5,[R7, #+0]
   1241              }
   1242              else
   1243              {
   1244                  mtCOVERAGE_TEST_MARKER();
   1245              }
   1246          
   1247              return xCount;
   \                     ??prvReadBytesFromBuffer_0: (+1)
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1248          }
   1249          /*-----------------------------------------------------------*/
   1250          

   \                                 In section .text, align 2, keep-with-next
   1251          static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
   1252          {
   \                     prvBytesInBuffer: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1253          /* Returns the distance between xTail and xHead. */
   1254              size_t xCount;
   1255          
   1256              xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
   \        0x2   0x6848             LDR      R0,[R1, #+4]
   1257              xCount -= pxStreamBuffer->xTail;
   \        0x4   0x688A             LDR      R2,[R1, #+8]
   \        0x6   0x6809             LDR      R1,[R1, #+0]
   \        0x8   0x1880             ADDS     R0,R0,R2
   \        0xA   0x1A40             SUBS     R0,R0,R1
   1258          
   1259              if( xCount >= pxStreamBuffer->xLength )
   \        0xC   0x4290             CMP      R0,R2
   \        0xE   0xBF28             IT       CS
   \       0x10   0x1A80             SUBCS    R0,R0,R2
   1260              {
   1261                  xCount -= pxStreamBuffer->xLength;
   1262              }
   1263              else
   1264              {
   1265                  mtCOVERAGE_TEST_MARKER();
   1266              }
   1267          
   1268              return xCount;
   \       0x12   0x4770             BX       LR
   1269          }
   1270          /*-----------------------------------------------------------*/
   1271          

   \                                 In section .text, align 2, keep-with-next
   1272          static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
   1273                                                    uint8_t * const pucBuffer,
   1274                                                    size_t xBufferSizeBytes,
   1275                                                    size_t xTriggerLevelBytes,
   1276                                                    uint8_t ucFlags )
   1277          {
   \                     prvInitialiseNewStreamBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x9C06             LDR      R4,[SP, #+24]
   1278              /* Assert here is deliberately writing to the entire buffer to ensure it can
   1279               * be written to without generating exceptions, and is setting the buffer to a
   1280               * known value to assist in development/debugging. */
   1281              #if ( configASSERT_DEFINED == 1 )
   1282                  {
   1283                      /* The value written just has to be identifiable when looking at the
   1284                       * memory.  Don't use 0xA5 as that is the stack fill value and could
   1285                       * result in confusion as to what is actually being observed. */
   1286                      const BaseType_t xWriteValue = 0x55;
   1287                      configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
   \        0xE   0x2255             MOVS     R2,#+85
   \       0x10   0x4631             MOV      R1,R6
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       __aeabi_memset
   1288                  } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
   1289              #endif
   1290          
   1291              ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
   \       0x18   0x2124             MOVS     R1,#+36
   \       0x1A   0x4638             MOV      R0,R7
   \       0x1C   0x.... 0x....      BL       __aeabi_memclr
   1292              pxStreamBuffer->pucBuffer = pucBuffer;
   \       0x20   0x61BD             STR      R5,[R7, #+24]
   1293              pxStreamBuffer->xLength = xBufferSizeBytes;
   \       0x22   0x60BE             STR      R6,[R7, #+8]
   1294              pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
   \       0x24   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1295              pxStreamBuffer->ucFlags = ucFlags;
   \       0x28   0x773C             STRB     R4,[R7, #+28]
   1296          }
   \       0x2A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1297          
   1298          #if ( configUSE_TRACE_FACILITY == 1 )
   1299          

   \                                 In section .text, align 2, keep-with-next
   1300              UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
   1301              {
   1302                  return xStreamBuffer->uxStreamBufferNumber;
   \                     uxStreamBufferGetStreamBufferNumber: (+1)
   \        0x0   0x6A00             LDR      R0,[R0, #+32]
   \        0x2   0x4770             BX       LR
   1303              }
   1304          
   1305          #endif /* configUSE_TRACE_FACILITY */
   1306          /*-----------------------------------------------------------*/
   1307          
   1308          #if ( configUSE_TRACE_FACILITY == 1 )
   1309          

   \                                 In section .text, align 2, keep-with-next
   1310              void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,
   1311                                                       UBaseType_t uxStreamBufferNumber )
   1312              {
   1313                  xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
   \                     vStreamBufferSetStreamBufferNumber: (+1)
   \        0x0   0x6201             STR      R1,[R0, #+32]
   1314              }
   \        0x2   0x4770             BX       LR
   1315          
   1316          #endif /* configUSE_TRACE_FACILITY */
   1317          /*-----------------------------------------------------------*/
   1318          
   1319          #if ( configUSE_TRACE_FACILITY == 1 )
   1320          

   \                                 In section .text, align 2, keep-with-next
   1321              uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
   1322              {
   1323                  return( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
   \                     ucStreamBufferGetStreamBufferType: (+1)
   \        0x0   0x7F00             LDRB     R0,[R0, #+28]
   \        0x2   0xF000 0x0001      AND      R0,R0,#0x1
   \        0x6   0x4770             BX       LR
   1324              }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x55, 0x73, 0x65, 0x72, 0x73
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73
   \        0x8   0x5C 0x44          DC8 0x5C, 0x44, 0x45, 0x4C, 0x4C, 0x5C, 0x53, 0x69
   \              0x45 0x4C    
   \              0x4C 0x5C    
   \              0x53 0x69
   \       0x10   0x6D 0x70          DC8 0x6D, 0x70, 0x6C, 0x69, 0x63, 0x69, 0x74, 0x79
   \              0x6C 0x69    
   \              0x63 0x69    
   \              0x74 0x79
   \       0x18   0x53 0x74          DC8 0x53, 0x74, 0x75, 0x64, 0x69, 0x6F, 0x5C, 0x76
   \              0x75 0x64    
   \              0x69 0x6F    
   \              0x5C 0x76
   \       0x20   0x35 0x5F          DC8 0x35, 0x5F, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x70
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x73 0x70
   \       0x28   0x61 0x63          DC8 0x61, 0x63, 0x65, 0x5C, 0x77, 0x69, 0x73, 0x75
   \              0x65 0x5C    
   \              0x77 0x69    
   \              0x73 0x75
   \       0x30   0x6E 0x5F          DC8 0x6E, 0x5F, 0x72, 0x63, 0x70, 0x5F, 0x37, 0x5C
   \              0x72 0x63    
   \              0x70 0x5F    
   \              0x37 0x5C
   \       0x38   0x67 0x65          DC8 0x67, 0x65, 0x63, 0x6B, 0x6F, 0x5F, 0x73, 0x64
   \              0x63 0x6B    
   \              0x6F 0x5F    
   \              0x73 0x64
   \       0x40   0x6B 0x5F          DC8 0x6B, 0x5F, 0x34, 0x2E, 0x34, 0x2E, 0x33, 0x5C
   \              0x34 0x2E    
   \              0x34 0x2E    
   \              0x33 0x5C
   \       0x48   0x75 0x74          DC8 0x75, 0x74, 0x69, 0x6C, 0x5C, 0x74, 0x68, 0x69
   \              0x69 0x6C    
   \              0x5C 0x74    
   \              0x68 0x69
   \       0x50   0x72 0x64          DC8 0x72, 0x64, 0x5F, 0x70, 0x61, 0x72, 0x74, 0x79
   \              0x5F 0x70    
   \              0x61 0x72    
   \              0x74 0x79
   \       0x58   0x5C 0x66          DC8 0x5C, 0x66, 0x72, 0x65, 0x65, 0x72, 0x74, 0x6F
   \              0x72 0x65    
   \              0x65 0x72    
   \              0x74 0x6F
   \       0x60   0x73 0x5C          DC8 0x73, 0x5C, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C
   \              0x6B 0x65    
   \              0x72 0x6E    
   \              0x65 0x6C
   \       0x68   0x5C 0x73          DC8 0x5C, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x5F
   \              0x74 0x72    
   \              0x65 0x61    
   \              0x6D 0x5F
   \       0x70   0x62 0x75          DC8 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x63
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x2E 0x63
   \       0x78   0x00               DC8 0
   \       0x79                      DS8 3
   1325          
   1326          #endif /* configUSE_TRACE_FACILITY */
   1327          /*-----------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvBytesInBuffer
      24   prvInitialiseNewStreamBuffer
        24   -> __aeabi_memclr
        24   -> __aeabi_memset
      32   prvReadBytesFromBuffer
        32   -> __aeabi_memcpy
        32   -> assertEFM
      32   prvReadMessageFromBuffer
        32   -> prvReadBytesFromBuffer
      32   prvWriteBytesToBuffer
        32   -> __aeabi_memcpy
        32   -> assertEFM
      16   prvWriteMessageToBuffer
        16   -> prvWriteBytesToBuffer
       0   ucStreamBufferGetStreamBufferType
       0   uxStreamBufferGetStreamBufferNumber
       8   vStreamBufferDelete
         0   -> __aeabi_memclr4
         8   -> assertEFM
         0   -> vPortFree
       0   vStreamBufferSetStreamBufferNumber
       8   xStreamBufferBytesAvailable
         8   -> assertEFM
         0   -> prvBytesInBuffer
      24   xStreamBufferGenericCreate
        24   -> assertEFM
        24   -> prvInitialiseNewStreamBuffer
        24   -> pvPortMalloc
      32   xStreamBufferGenericCreateStatic
        32   -> assertEFM
        32   -> prvInitialiseNewStreamBuffer
       8   xStreamBufferIsEmpty
         8   -> assertEFM
      16   xStreamBufferIsFull
        16   -> assertEFM
        16   -> xStreamBufferSpacesAvailable
      16   xStreamBufferNextMessageLengthBytes
        16   -> assertEFM
        16   -> prvBytesInBuffer
        16   -> prvReadBytesFromBuffer
      40   xStreamBufferReceive
        40   -> assertEFM
        40   -> prvBytesInBuffer
        40   -> prvReadMessageFromBuffer
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vTaskSuspendAll
        40   -> xTaskGenericNotify
        40   -> xTaskGenericNotifyStateClear
        40   -> xTaskGenericNotifyWait
        40   -> xTaskGetCurrentTaskHandle
        40   -> xTaskResumeAll
      24   xStreamBufferReceiveCompletedFromISR
        24   -> assertEFM
        24   -> ulSetInterruptMask
        24   -> vClearInterruptMask
        24   -> xTaskGenericNotifyFromISR
      40   xStreamBufferReceiveFromISR
        40   -> assertEFM
        40   -> prvBytesInBuffer
        40   -> prvReadMessageFromBuffer
        40   -> ulSetInterruptMask
        40   -> vClearInterruptMask
        40   -> xTaskGenericNotifyFromISR
      24   xStreamBufferReset
        24   -> assertEFM
        24   -> prvInitialiseNewStreamBuffer
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      48   xStreamBufferSend
        48   -> assertEFM
        48   -> prvBytesInBuffer
        48   -> prvWriteMessageToBuffer
        48   -> vPortEnterCritical
        48   -> vPortExitCritical
        48   -> vTaskSetTimeOutState
        48   -> vTaskSuspendAll
        48   -> xStreamBufferSpacesAvailable
        48   -> xTaskCheckForTimeOut
        48   -> xTaskGenericNotify
        48   -> xTaskGenericNotifyStateClear
        48   -> xTaskGenericNotifyWait
        48   -> xTaskGetCurrentTaskHandle
        48   -> xTaskResumeAll
      24   xStreamBufferSendCompletedFromISR
        24   -> assertEFM
        24   -> ulSetInterruptMask
        24   -> vClearInterruptMask
        24   -> xTaskGenericNotifyFromISR
      40   xStreamBufferSendFromISR
        40   -> assertEFM
        40   -> prvBytesInBuffer
        40   -> prvWriteMessageToBuffer
        40   -> ulSetInterruptMask
        40   -> vClearInterruptMask
        40   -> xStreamBufferSpacesAvailable
        40   -> xTaskGenericNotifyFromISR
      16   xStreamBufferSetTriggerLevel
        16   -> assertEFM
       8   xStreamBufferSpacesAvailable
         8   -> assertEFM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
      10  ?Subroutine0
       6  ?Subroutine1
       8  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
      16  ?Subroutine5
     124  ?_0
      20  prvBytesInBuffer
      46  prvInitialiseNewStreamBuffer
     128  prvReadBytesFromBuffer
      52  prvReadMessageFromBuffer
     114  prvWriteBytesToBuffer
      58  prvWriteMessageToBuffer
       8  ucStreamBufferGetStreamBufferType
       4  uxStreamBufferGetStreamBufferNumber
      42  vStreamBufferDelete
       4  vStreamBufferSetStreamBufferNumber
      22  xStreamBufferBytesAvailable
      94  xStreamBufferGenericCreate
     134  xStreamBufferGenericCreateStatic
      30  xStreamBufferIsEmpty
      38  xStreamBufferIsFull
      70  xStreamBufferNextMessageLengthBytes
     186  xStreamBufferReceive
      52  xStreamBufferReceiveCompletedFromISR
     114  xStreamBufferReceiveFromISR
      62  xStreamBufferReset
     250  xStreamBufferSend
      42  xStreamBufferSendCompletedFromISR
     108  xStreamBufferSendFromISR
      36  xStreamBufferSetTriggerLevel
      34  xStreamBufferSpacesAvailable

 
   124 bytes in section .rodata
 1'804 bytes in section .text
 
 1'804 bytes of CODE  memory
   124 bytes of CONST memory

Errors: none
Warnings: none
